/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var stropheMD5 = (function () {
    /*
     * Configurable variables. You may need to tweak these to be compatible with
     * the server-side, but the defaults work in most cases.
     */
    var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase */
    var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance */
    var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode */

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    var safe_add = function (x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    var bit_rol = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
     * Convert a string to an array of little-endian words
     * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
     */
    var str2binl = function (str) {
        var bin = [];
        var mask = (1 << chrsz) - 1;
        for(var i = 0; i < str.length * chrsz; i += chrsz)
        {
            bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
        }
        return bin;
    };

    /*
     * Convert an array of little-endian words to a string
     */
    var binl2str = function (bin) {
        var str = "";
        var mask = (1 << chrsz) - 1;
        for(var i = 0; i < bin.length * 32; i += chrsz)
        {
            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a hex string.
     */
    var binl2hex = function (binarray) {
        var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
        var str = "";
        for(var i = 0; i < binarray.length * 4; i++)
        {
            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a base-64 string
     */
    var binl2b64 = function (binarray) {
        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var str = "";
        var triplet, j;
        for(var i = 0; i < binarray.length * 4; i += 3)
        {
            triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16) |
                (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 ) |
                ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
            for(j = 0; j < 4; j++)
            {
                if(i * 8 + j * 6 > binarray.length * 32) { str += b64pad; }
                else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
            }
        }
        return str;
    };

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    var md5_cmn = function (q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
    };

    var md5_ff = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };

    var md5_gg = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };

    var md5_hh = function (a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };

    var md5_ii = function (a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    var core_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a =  1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d =  271733878;

        var olda, oldb, oldc, oldd;
        for (var i = 0; i < x.length; i += 16)
        {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    };


    /*
     * Calculate the HMAC-MD5, of a key and some data
     */
    var core_hmac_md5 = function (key, data) {
        var bkey = str2binl(key);
        if(bkey.length > 16) { bkey = core_md5(bkey, key.length * chrsz); }

        var ipad = new Array(16), opad = new Array(16);
        for(var i = 0; i < 16; i++)
        {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }

        var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
        return core_md5(opad.concat(hash), 512 + 128);
    };

    var obj = {
        /*
         * These are the functions you'll usually want to call.
         * They take string arguments and return either hex or base-64 encoded
         * strings.
         */
        hexdigest: function (s) {
            return binl2hex(core_md5(str2binl(s), s.length * chrsz));
        },

        b64digest: function (s) {
            return binl2b64(core_md5(str2binl(s), s.length * chrsz));
        },

        hash: function (s) {
            return binl2str(core_md5(str2binl(s), s.length * chrsz));
        },

        hmac_hexdigest: function (key, data) {
            return binl2hex(core_hmac_md5(key, data));
        },

        hmac_b64digest: function (key, data) {
            return binl2b64(core_hmac_md5(key, data));
        },

        hmac_hash: function (key, data) {
            return binl2str(core_hmac_md5(key, data));
        },

        /*
         * Perform a simple self-test to see if the VM is working
         */
        test: function () {
            return stropheMD5.hexdigest("abc") === "900150983cd24fb0d6963f7d28e17f72";
        }
    };

    return obj;
})();
// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

var Base64 = (function () {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    var obj = {
        /**
         * Encodes a string in base64
         * @param {String} input The string to encode in base64.
         */
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
            } while (i < input.length);

            return output;
        },

        /**
         * Decodes a base64 string.
         * @param {String} input The string to decode.
         */
        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
            } while (i < input.length);

            return output;
        }
    };

    return obj;
})();
/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jslint configuration: */
/*global document, window, setTimeout, clearTimeout, console,
    XMLHttpRequest, ActiveXObject,
    Base64, MD5,
    Strophe, $build, $msg, $iq, $pres */

/** File: strophe.js
 *  A JavaScript library for XMPP BOSH.
 *
 *  This is the JavaScript version of the Strophe library.  Since JavaScript
 *  has no facilities for persistent TCP connections, this library uses
 *  Bidirectional-streams Over Synchronous HTTP (BOSH) to emulate
 *  a persistent, stateful, two-way connection to an XMPP server.  More
 *  information on BOSH can be found in XEP 124.
 */

/** PrivateFunction: Function.prototype.bind
 *  Bind a function to an instance.
 *
 *  This Function object extension method creates a bound method similar
 *  to those in Python.  This means that the 'this' object will point
 *  to the instance you want.  See
 *  <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind'>MDC's bind() documentation</a> and 
 *  <a href='http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/'>Bound Functions and Function Imports in JavaScript</a>
 *  for a complete explanation.
 *
 *  This extension already exists in some browsers (namely, Firefox 3), but
 *  we provide it to support those that don't.
 *
 *  Parameters:
 *    (Object) obj - The object that will become 'this' in the bound function.
 *    (Object) argN - An option argument that will be prepended to the 
 *      arguments given for the function call
 *
 *  Returns:
 *    The bound function.
 */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (obj /*, arg1, arg2, ... */)
    {
        var func = this;
        var _slice = Array.prototype.slice;
        var _concat = Array.prototype.concat;
        var _args = _slice.call(arguments, 1);
        
        return function () {
            return func.apply(obj ? obj : this,
                              _concat.call(_args,
                                           _slice.call(arguments, 0)));
        };
    };
}

/** PrivateFunction: Array.prototype.indexOf
 *  Return the index of an object in an array.
 *
 *  This function is not supplied by some JavaScript implementations, so
 *  we provide it if it is missing.  This code is from:
 *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
 *
 *  Parameters:
 *    (Object) elt - The object to look for.
 *    (Integer) from - The index from which to start looking. (optional).
 *
 *  Returns:
 *    The index of elt in the array or -1 if not found.
 */
if (!Array.prototype.indexOf)
{
    Array.prototype.indexOf = function(elt /*, from*/)
    {
        var len = this.length;

        var from = Number(arguments[1]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0) {
            from += len;
        }

        for (; from < len; from++) {
            if (from in this && this[from] === elt) {
                return from;
            }
        }

        return -1;
    };
}

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

(function (callback) {
var Strophe;

/** Function: $build
 *  Create a Strophe.Builder.
 *  This is an alias for 'new Strophe.Builder(name, attrs)'.
 *
 *  Parameters:
 *    (String) name - The root element name.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $build(name, attrs) { return new Strophe.Builder(name, attrs); }
/** Function: $msg
 *  Create a Strophe.Builder with a <message/> element as the root.
 *
 *  Parmaeters:
 *    (Object) attrs - The <message/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $msg(attrs) { return new Strophe.Builder("message", attrs); }
/** Function: $iq
 *  Create a Strophe.Builder with an <iq/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <iq/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $iq(attrs) { return new Strophe.Builder("iq", attrs); }
/** Function: $pres
 *  Create a Strophe.Builder with a <presence/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <presence/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

/** Class: Strophe
 *  An object container for all Strophe library functions.
 *
 *  This class is just a container for all the objects and constants
 *  used in the library.  It is not meant to be instantiated, but to
 *  provide a namespace for library objects, constants, and functions.
 */
Strophe = {
    /** Constant: VERSION
     *  The version of the Strophe library. Unreleased builds will have
     *  a version of head-HASH where HASH is a partial revision.
     */
    VERSION: "@VERSION@",

    /** Constants: XMPP Namespace Constants
     *  Common namespace constants from the XMPP RFCs and XEPs.
     *
     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
     *  NS.BOSH - BOSH namespace from XEP 206.
     *  NS.CLIENT - Main XMPP client namespace.
     *  NS.AUTH - Legacy authentication namespace.
     *  NS.ROSTER - Roster operations namespace.
     *  NS.PROFILE - Profile namespace.
     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
     *  NS.MUC - Multi-User Chat namespace from XEP 45.
     *  NS.SASL - XMPP SASL namespace from RFC 3920.
     *  NS.STREAM - XMPP Streams namespace from RFC 3920.
     *  NS.BIND - XMPP Binding namespace from RFC 3920.
     *  NS.SESSION - XMPP Session namespace from RFC 3920.
     */
    NS: {
        HTTPBIND: "http://jabber.org/protocol/httpbind",
        BOSH: "urn:xmpp:xbosh",
        CLIENT: "jabber:client",
        AUTH: "jabber:iq:auth",
        ROSTER: "jabber:iq:roster",
        PROFILE: "jabber:iq:profile",
        DISCO_INFO: "http://jabber.org/protocol/disco#info",
        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
        MUC: "http://jabber.org/protocol/muc",
        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
        STREAM: "http://etherx.jabber.org/streams",
        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
        VERSION: "jabber:iq:version",
        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas"
    },

    /** Function: addNamespace
     *  This function is used to extend the current namespaces in
     *  Strophe.NS.  It takes a key and a value with the key being the
     *  name of the new namespace, with its actual value.
     *  For example:
     *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
     *
     *  Parameters:
     *    (String) name - The name under which the namespace will be
     *      referenced under Strophe.NS
     *    (String) value - The actual namespace.
     */
    addNamespace: function (name, value)
    {
    Strophe.NS[name] = value;
    },

    /** Constants: Connection Status Constants
     *  Connection status constants for use by the connection handler
     *  callback.
     *
     *  Status.ERROR - An error has occurred
     *  Status.CONNECTING - The connection is currently being made
     *  Status.CONNFAIL - The connection attempt failed
     *  Status.AUTHENTICATING - The connection is authenticating
     *  Status.AUTHFAIL - The authentication attempt failed
     *  Status.CONNECTED - The connection has succeeded
     *  Status.DISCONNECTED - The connection has been terminated
     *  Status.DISCONNECTING - The connection is currently being terminated
     *  Status.ATTACHED - The connection has been attached
     */
    Status: {
        ERROR: 0,
        CONNECTING: 1,
        CONNFAIL: 2,
        AUTHENTICATING: 3,
        AUTHFAIL: 4,
        CONNECTED: 5,
        DISCONNECTED: 6,
        DISCONNECTING: 7,
        ATTACHED: 8
    },

    /** Constants: Log Level Constants
     *  Logging level indicators.
     *
     *  LogLevel.DEBUG - Debug output
     *  LogLevel.INFO - Informational output
     *  LogLevel.WARN - Warnings
     *  LogLevel.ERROR - Errors
     *  LogLevel.FATAL - Fatal errors
     */
    LogLevel: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        FATAL: 4
    },

    /** PrivateConstants: DOM Element Type Constants
     *  DOM element types.
     *
     *  ElementType.NORMAL - Normal element.
     *  ElementType.TEXT - Text data element.
     */
    ElementType: {
        NORMAL: 1,
        TEXT: 3,
        CDATA: 4
    },

    /** PrivateConstants: Timeout Values
     *  Timeout values for error states.  These values are in seconds.
     *  These should not be changed unless you know exactly what you are
     *  doing.
     *
     *  TIMEOUT - Timeout multiplier. A waiting request will be considered
     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 1.1, and with default wait, 66 seconds.
     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
     *      Strophe can detect early failure, it will consider the request
     *      failed if it doesn't return after
     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 0.1, and with default wait, 6 seconds.
     */
    TIMEOUT: 1.1,
    SECONDARY_TIMEOUT: 0.1,

    /** Function: forEachChild
     *  Map a function over some or all child elements of a given element.
     *
     *  This is a small convenience function for mapping a function over
     *  some or all of the children of an element.  If elemName is null, all
     *  children will be passed to the function, otherwise only children
     *  whose tag names match elemName will be passed.
     *
     *  Parameters:
     *    (XMLElement) elem - The element to operate on.
     *    (String) elemName - The child element tag name filter.
     *    (Function) func - The function to apply to each child.  This
     *      function should take a single argument, a DOM element.
     */
    forEachChild: function (elem, elemName, func)
    {
        var i, childNode;

        for (i = 0; i < elem.childNodes.length; i++) {
            childNode = elem.childNodes[i];
            if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                (!elemName || this.isTagEqual(childNode, elemName))) {
                func(childNode);
            }
        }
    },

    /** Function: isTagEqual
     *  Compare an element's tag name with a string.
     *
     *  This function is case insensitive.
     *
     *  Parameters:
     *    (XMLElement) el - A DOM element.
     *    (String) name - The element name.
     *
     *  Returns:
     *    true if the element's tag name matches _el_, and false
     *    otherwise.
     */
    isTagEqual: function (el, name)
    {
        return el.tagName.toLowerCase() == name.toLowerCase();
    },

    /** PrivateVariable: _xmlGenerator
     *  _Private_ variable that caches a DOM document to
     *  generate elements.
     */
    _xmlGenerator: null,

    /** PrivateFunction: _makeGenerator
     *  _Private_ function that creates a dummy XML DOM document to serve as
     *  an element and text node generator.
     */
    _makeGenerator: function () {
        var doc;

        if (document.implementation.createDocument === undefined) {
            doc = this._getIEXmlDom();
            doc.appendChild(doc.createElement('strophe'));
        } else {
            doc = document.implementation
                .createDocument('jabber:client', 'strophe', null);
        }

        return doc;
    },

    /** Function: xmlGenerator
     *  Get the DOM document to generate elements.
     *
     *  Returns:
     *    The currently used DOM document.
     */
    xmlGenerator: function () {
        if (!Strophe._xmlGenerator) {
            Strophe._xmlGenerator = Strophe._makeGenerator();
        }
        return Strophe._xmlGenerator;
    },

    /** PrivateFunction: _getIEXmlDom
     *  Gets IE xml doc object
     *
     *  Returns:
     *    A Microsoft XML DOM Object
     *  See Also:
     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
     */
    _getIEXmlDom : function() {
        var doc = null;
        var docStrings = [
            "Msxml2.DOMDocument.6.0",
            "Msxml2.DOMDocument.5.0",
            "Msxml2.DOMDocument.4.0",
            "MSXML2.DOMDocument.3.0",
            "MSXML2.DOMDocument",
            "MSXML.DOMDocument",
            "Microsoft.XMLDOM"
        ];

        for (var d = 0; d < docStrings.length; d++) {
            if (doc === null) {
                try {
                    doc = new ActiveXObject(docStrings[d]);
                } catch (e) {
                    doc = null;
                }
            } else {
                break;
            }
        }

        return doc;
    },

    /** Function: xmlElement
     *  Create an XML DOM element.
     *
     *  This function creates an XML DOM element correctly across all
     *  implementations. Note that these are not HTML DOM elements, which
     *  aren't appropriate for XMPP stanzas.
     *
     *  Parameters:
     *    (String) name - The name for the element.
     *    (Array|Object) attrs - An optional array or object containing
     *      key/value pairs to use as element attributes. The object should
     *      be in the format {'key': 'value'} or {key: 'value'}. The array
     *      should have the format [['key1', 'value1'], ['key2', 'value2']].
     *    (String) text - The text child data for the element.
     *
     *  Returns:
     *    A new XML DOM element.
     */
    xmlElement: function (name)
    {
        if (!name) { return null; }

        var node = Strophe.xmlGenerator().createElement(name);

        // FIXME: this should throw errors if args are the wrong type or
        // there are more than two optional args
        var a, i, k;
        for (a = 1; a < arguments.length; a++) {
            if (!arguments[a]) { continue; }
            if (typeof(arguments[a]) == "string" ||
                typeof(arguments[a]) == "number") {
                node.appendChild(Strophe.xmlTextNode(arguments[a]));
            } else if (typeof(arguments[a]) == "object" &&
                       typeof(arguments[a].sort) == "function") {
                for (i = 0; i < arguments[a].length; i++) {
                    if (typeof(arguments[a][i]) == "object" &&
                        typeof(arguments[a][i].sort) == "function") {
                        node.setAttribute(arguments[a][i][0],
                                          arguments[a][i][1]);
                    }
                }
            } else if (typeof(arguments[a]) == "object") {
                for (k in arguments[a]) {
                    if (arguments[a].hasOwnProperty(k)) {
                        node.setAttribute(k, arguments[a][k]);
                    }
                }
            }
        }

        return node;
    },

    /*  Function: xmlescape
     *  Excapes invalid xml characters.
     *
     *  Parameters:
     *     (String) text - text to escape.
     *
     *  Returns:
     *      Escaped text.
     */
    xmlescape: function(text)
    {
        text = text.replace(/\&/g, "&amp;");
        text = text.replace(/</g,  "&lt;");
        text = text.replace(/>/g,  "&gt;");
        text = text.replace(/'/g,  "&apos;");
        text = text.replace(/"/g,  "&quot;");
        return text;
    },

    /** Function: xmlTextNode
     *  Creates an XML DOM text node.
     *
     *  Provides a cross implementation version of document.createTextNode.
     *
     *  Parameters:
     *    (String) text - The content of the text node.
     *
     *  Returns:
     *    A new XML DOM text node.
     */
    xmlTextNode: function (text)
    {
        return Strophe.xmlGenerator().createTextNode(text);
    },

    /** Function: getText
     *  Get the concatenation of all text children of an element.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A String with the concatenated text of all text element children.
     */
    getText: function (elem)
    {
        if (!elem) { return null; }

        var str = "";
        if (elem.childNodes.length === 0 && elem.nodeType ==
            Strophe.ElementType.TEXT) {
            str += elem.nodeValue;
        }

        for (var i = 0; i < elem.childNodes.length; i++) {
            if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                str += elem.childNodes[i].nodeValue;
            }
        }

        return str;
    },

    /** Function: copyElement
     *  Copy an XML DOM element.
     *
     *  This function copies a DOM element and all its descendants and returns
     *  the new copy.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A new, copied DOM element tree.
     */
    copyElement: function (elem)
    {
        var i, el;
        if (elem.nodeType == Strophe.ElementType.NORMAL) {
            el = Strophe.xmlElement(elem.tagName);

            for (i = 0; i < elem.attributes.length; i++) {
                el.setAttribute(elem.attributes[i].nodeName.toLowerCase(),
                                elem.attributes[i].value);
            }

            for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.copyElement(elem.childNodes[i]));
            }
        } else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
        }

        return el;
    },

    /** Function: escapeNode
     *  Escape the node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An escaped node (or local part).
     */
    escapeNode: function (node)
    {
        return node.replace(/^\s+|\s+$/g, '')
            .replace(/\\/g,  "\\5c")
            .replace(/ /g,   "\\20")
            .replace(/\"/g,  "\\22")
            .replace(/\&/g,  "\\26")
            .replace(/\'/g,  "\\27")
            .replace(/\//g,  "\\2f")
            .replace(/:/g,   "\\3a")
            .replace(/</g,   "\\3c")
            .replace(/>/g,   "\\3e")
            .replace(/@/g,   "\\40");
    },

    /** Function: unescapeNode
     *  Unescape a node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An unescaped node (or local part).
     */
    unescapeNode: function (node)
    {
        return node.replace(/\\20/g, " ")
            .replace(/\\22/g, '"')
            .replace(/\\26/g, "&")
            .replace(/\\27/g, "'")
            .replace(/\\2f/g, "/")
            .replace(/\\3a/g, ":")
            .replace(/\\3c/g, "<")
            .replace(/\\3e/g, ">")
            .replace(/\\40/g, "@")
            .replace(/\\5c/g, "\\");
    },

    /** Function: getNodeFromJid
     *  Get the node portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the node.
     */
    getNodeFromJid: function (jid)
    {
        if (jid.indexOf("@") < 0) { return null; }
        return jid.split("@")[0];
    },

    /** Function: getDomainFromJid
     *  Get the domain portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the domain.
     */
    getDomainFromJid: function (jid)
    {
        var bare = Strophe.getBareJidFromJid(jid);
        if (bare.indexOf("@") < 0) {
            return bare;
        } else {
            var parts = bare.split("@");
            parts.splice(0, 1);
            return parts.join('@');
        }
    },

    /** Function: getResourceFromJid
     *  Get the resource portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the resource.
     */
    getResourceFromJid: function (jid)
    {
        var s = jid.split("/");
        if (s.length < 2) { return null; }
        s.splice(0, 1);
        return s.join('/');
    },

    /** Function: getBareJidFromJid
     *  Get the bare JID from a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the bare JID.
     */
    getBareJidFromJid: function (jid)
    {
        return jid ? jid.split("/")[0] : null;
    },

    /** Function: log
     *  User overrideable logging function.
     *
     *  This function is called whenever the Strophe library calls any
     *  of the logging functions.  The default implementation of this
     *  function does nothing.  If client code wishes to handle the logging
     *  messages, it should override this with
     *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
     *
     *  Please note that data sent and received over the wire is logged
     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
     *
     *  The different levels and their meanings are
     *
     *    DEBUG - Messages useful for debugging purposes.
     *    INFO - Informational messages.  This is mostly information like
     *      'disconnect was called' or 'SASL auth succeeded'.
     *    WARN - Warnings about potential problems.  This is mostly used
     *      to report transient connection errors like request timeouts.
     *    ERROR - Some error occurred.
     *    FATAL - A non-recoverable fatal error occurred.
     *
     *  Parameters:
     *    (Integer) level - The log level of the log message.  This will
     *      be one of the values in Strophe.LogLevel.
     *    (String) msg - The log message.
     */
    log: function (level, msg)
    {
        return;
    },

    /** Function: debug
     *  Log a message at the Strophe.LogLevel.DEBUG level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    debug: function(msg)
    {
        this.log(this.LogLevel.DEBUG, msg);
    },

    /** Function: info
     *  Log a message at the Strophe.LogLevel.INFO level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    info: function (msg)
    {
        this.log(this.LogLevel.INFO, msg);
    },

    /** Function: warn
     *  Log a message at the Strophe.LogLevel.WARN level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    warn: function (msg)
    {
        this.log(this.LogLevel.WARN, msg);
    },

    /** Function: error
     *  Log a message at the Strophe.LogLevel.ERROR level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    error: function (msg)
    {
        this.log(this.LogLevel.ERROR, msg);
    },

    /** Function: fatal
     *  Log a message at the Strophe.LogLevel.FATAL level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    fatal: function (msg)
    {
        this.log(this.LogLevel.FATAL, msg);
    },

    /** Function: serialize
     *  Render a DOM element and all descendants to a String.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The serialized element tree as a String.
     */
    serialize: function (elem)
    {
        var result;

        if (!elem) { return null; }

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }

        var nodeName = elem.nodeName;
        var i, child;

        if (elem.getAttribute("_realname")) {
            nodeName = elem.getAttribute("_realname");
        }

        result = "<" + nodeName;
        for (i = 0; i < elem.attributes.length; i++) {
               if(elem.attributes[i].nodeName != "_realname") {
                 result += " " + elem.attributes[i].nodeName.toLowerCase() +
                "='" + elem.attributes[i].value
                    .replace(/&/g, "&amp;")
                       .replace(/\'/g, "&apos;")
                       .replace(/</g, "&lt;") + "'";
               }
        }

        if (elem.childNodes.length > 0) {
            result += ">";
            for (i = 0; i < elem.childNodes.length; i++) {
                child = elem.childNodes[i];
                switch( child.nodeType ){
                  case Strophe.ElementType.NORMAL:
                    // normal element, so recurse
                    result += Strophe.serialize(child);
                    break;
                  case Strophe.ElementType.TEXT:
                    // text element to escape values
                    result += Strophe.xmlescape(child.nodeValue);
                    break;
                  case Strophe.ElementType.CDATA:
                    // cdata section so don't escape values
                    result += "<![CDATA["+child.nodeValue+"]]>";
                }
            }
            result += "</" + nodeName + ">";
        } else {
            result += "/>";
        }

        return result;
    },

    /** PrivateVariable: _requestId
     *  _Private_ variable that keeps track of the request ids for
     *  connections.
     */
    _requestId: 0,

    /** PrivateVariable: Strophe.connectionPlugins
     *  _Private_ variable Used to store plugin names that need
     *  initialization on Strophe.Connection construction.
     */
    _connectionPlugins: {},

    /** Function: addConnectionPlugin
     *  Extends the Strophe.Connection object with the given plugin.
     *
     *  Parameters:
     *    (String) name - The name of the extension.
     *    (Object) ptype - The plugin's prototype.
     */
    addConnectionPlugin: function (name, ptype)
    {
        Strophe._connectionPlugins[name] = ptype;
    }
};

/** Class: Strophe.Builder
 *  XML DOM builder.
 *
 *  This object provides an interface similar to JQuery but for building
 *  DOM element easily and rapidly.  All the functions except for toString()
 *  and tree() return the object, so calls can be chained.  Here's an
 *  example using the $iq() builder helper.
 *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
 *  >     .c('query', {xmlns: 'strophe:example'})
 *  >     .c('example')
 *  >     .toString()
 *  The above generates this XML fragment
 *  > <iq to='you' from='me' type='get' id='1'>
 *  >   <query xmlns='strophe:example'>
 *  >     <example/>
 *  >   </query>
 *  > </iq>
 *  The corresponding DOM manipulations to get a similar fragment would be
 *  a lot more tedious and probably involve several helper variables.
 *
 *  Since adding children makes new operations operate on the child, up()
 *  is provided to traverse up the tree.  To add two children, do
 *  > builder.c('child1', ...).up().c('child2', ...)
 *  The next operation on the Builder will be relative to the second child.
 */

/** Constructor: Strophe.Builder
 *  Create a Strophe.Builder object.
 *
 *  The attributes should be passed in object notation.  For example
 *  > var b = new Builder('message', {to: 'you', from: 'me'});
 *  or
 *  > var b = new Builder('messsage', {'xml:lang': 'en'});
 *
 *  Parameters:
 *    (String) name - The name of the root element.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder.
 */
Strophe.Builder = function (name, attrs)
{
    // Set correct namespace for jabber:client elements
    if (name == "presence" || name == "message" || name == "iq") {
        if (attrs && !attrs.xmlns) {
            attrs.xmlns = Strophe.NS.CLIENT;
        } else if (!attrs) {
            attrs = {xmlns: Strophe.NS.CLIENT};
        }
    }

    // Holds the tree being built.
    this.nodeTree = Strophe.xmlElement(name, attrs);

    // Points to the current operation node.
    this.node = this.nodeTree;
};

Strophe.Builder.prototype = {
    /** Function: tree
     *  Return the DOM tree.
     *
     *  This function returns the current DOM tree as an element object.  This
     *  is suitable for passing to functions like Strophe.Connection.send().
     *
     *  Returns:
     *    The DOM tree as a element object.
     */
    tree: function ()
    {
        return this.nodeTree;
    },

    /** Function: toString
     *  Serialize the DOM tree to a String.
     *
     *  This function returns a string serialization of the current DOM
     *  tree.  It is often used internally to pass data to a
     *  Strophe.Request object.
     *
     *  Returns:
     *    The serialized DOM tree in a String.
     */
    toString: function ()
    {
        return Strophe.serialize(this.nodeTree);
    },

    /** Function: up
     *  Make the current parent element the new current element.
     *
     *  This function is often used after c() to traverse back up the tree.
     *  For example, to add two children to the same element
     *  > builder.c('child1', {}).up().c('child2', {});
     *
     *  Returns:
     *    The Stophe.Builder object.
     */
    up: function ()
    {
        this.node = this.node.parentNode;
        return this;
    },

    /** Function: attrs
     *  Add or modify attributes of the current element.
     *
     *  The attributes should be passed in object notation.  This function
     *  does not move the current element pointer.
     *
     *  Parameters:
     *    (Object) moreattrs - The attributes to add/modify in object notation.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    attrs: function (moreattrs)
    {
        for (var k in moreattrs) {
            if (moreattrs.hasOwnProperty(k)) {
                this.node.setAttribute(k, moreattrs[k]);
            }
        }
        return this;
    },

    /** Function: c
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function moves the current element pointer to the child,
     *  unless text is provided.  If you need to add another child, it
     *  is necessary to use up() to go back to the parent in the tree.
     *
     *  Parameters:
     *    (String) name - The name of the child.
     *    (Object) attrs - The attributes of the child in object notation.
     *    (String) text - The text to add to the child.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    c: function (name, attrs, text)
    {
        var child = Strophe.xmlElement(name, attrs, text);
        this.node.appendChild(child);
        if (!text) {
            this.node = child;
        }
        return this;
    },

    /** Function: cnode
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function is the same as c() except that instead of using a
     *  name and an attributes object to create the child it uses an
     *  existing DOM element object.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    cnode: function (elem)
    {
        var xmlGen = Strophe.xmlGenerator();
        try {
            var impNode = (xmlGen.importNode !== undefined);
        }
        catch (e) {
            var impNode = false;
        }
        var newElem = impNode ?
                      xmlGen.importNode(elem, true) :
                      Strophe.copyElement(elem);
        this.node.appendChild(newElem);
        this.node = newElem;
        return this;
    },

    /** Function: t
     *  Add a child text element.
     *
     *  This *does not* make the child the new current element since there
     *  are no children of text elements.
     *
     *  Parameters:
     *    (String) text - The text data to append to the current element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    t: function (text)
    {
        var child = Strophe.xmlTextNode(text);
        this.node.appendChild(child);
        return this;
    }
};


/** PrivateClass: Strophe.Handler
 *  _Private_ helper class for managing stanza handlers.
 *
 *  A Strophe.Handler encapsulates a user provided callback function to be
 *  executed when matching stanzas are received by the connection.
 *  Handlers can be either one-off or persistant depending on their
 *  return value. Returning true will cause a Handler to remain active, and
 *  returning false will remove the Handler.
 *
 *  Users will not use Strophe.Handler objects directly, but instead they
 *  will use Strophe.Connection.addHandler() and
 *  Strophe.Connection.deleteHandler().
 */

/** PrivateConstructor: Strophe.Handler
 *  Create and initialize a new Strophe.Handler.
 *
 *  Parameters:
 *    (Function) handler - A function to be executed when the handler is run.
 *    (String) ns - The namespace to match.
 *    (String) name - The element name to match.
 *    (String) type - The element type to match.
 *    (String) id - The element id attribute to match.
 *    (String) from - The element from attribute to match.
 *    (Object) options - Handler options
 *
 *  Returns:
 *    A new Strophe.Handler object.
 */
Strophe.Handler = function (handler, ns, name, type, id, from, options)
{
    this.handler = handler;
    this.ns = ns;
    this.name = name;
    this.type = type;
    this.id = id;
    this.options = options || {matchbare: false};

    // default matchBare to false if undefined
    if (!this.options.matchBare) {
        this.options.matchBare = false;
    }

    if (this.options.matchBare) {
        this.from = from ? Strophe.getBareJidFromJid(from) : null;
    } else {
        this.from = from;
    }

    // whether the handler is a user handler or a system handler
    this.user = true;
};

Strophe.Handler.prototype = {
    /** PrivateFunction: isMatch
     *  Tests if a stanza matches the Strophe.Handler.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element to test.
     *
     *  Returns:
     *    true if the stanza matches and false otherwise.
     */
    isMatch: function (elem)
    {
        var nsMatch;
        var from = null;

        if (this.options.matchBare) {
            from = Strophe.getBareJidFromJid(elem.getAttribute('from'));
        } else {
            from = elem.getAttribute('from');
        }

        nsMatch = false;
        if (!this.ns) {
            nsMatch = true;
        } else {
            var that = this;
            Strophe.forEachChild(elem, null, function (elem) {
                if (elem.getAttribute("xmlns") == that.ns) {
                    nsMatch = true;
                }
            });

            nsMatch = nsMatch || elem.getAttribute("xmlns") == this.ns;
        }

        if (nsMatch &&
            (!this.name || Strophe.isTagEqual(elem, this.name)) &&
            (!this.type || elem.getAttribute("type") == this.type) &&
            (!this.id || elem.getAttribute("id") == this.id) &&
            (!this.from || from == this.from)) {
                return true;
        }

        return false;
    },

    /** PrivateFunction: run
     *  Run the callback on a matching stanza.
     *
     *  Parameters:
     *    (XMLElement) elem - The DOM element that triggered the
     *      Strophe.Handler.
     *
     *  Returns:
     *    A boolean indicating if the handler should remain active.
     */
    run: function (elem)
    {
        var result = null;
        try {
            result = this.handler(elem);
        } catch (e) {
            if (e.sourceURL) {
                Strophe.fatal("error: " + this.handler +
                              " " + e.sourceURL + ":" +
                              e.line + " - " + e.name + ": " + e.message);
            } else if (e.fileName) {
                if (typeof(console) != "undefined") {
                    console.trace();
                    console.error(this.handler, " - error - ", e, e.message);
                }
                Strophe.fatal("error: " + this.handler + " " +
                              e.fileName + ":" + e.lineNumber + " - " +
                              e.name + ": " + e.message);
            } else {
                Strophe.fatal("error: " + this.handler);
            }

            throw e;
        }

        return result;
    },

    /** PrivateFunction: toString
     *  Get a String representation of the Strophe.Handler object.
     *
     *  Returns:
     *    A String.
     */
    toString: function ()
    {
        return "{Handler: " + this.handler + "(" + this.name + "," +
            this.id + "," + this.ns + ")}";
    }
};

/** PrivateClass: Strophe.TimedHandler
 *  _Private_ helper class for managing timed handlers.
 *
 *  A Strophe.TimedHandler encapsulates a user provided callback that
 *  should be called after a certain period of time or at regular
 *  intervals.  The return value of the callback determines whether the
 *  Strophe.TimedHandler will continue to fire.
 *
 *  Users will not use Strophe.TimedHandler objects directly, but instead
 *  they will use Strophe.Connection.addTimedHandler() and
 *  Strophe.Connection.deleteTimedHandler().
 */

/** PrivateConstructor: Strophe.TimedHandler
 *  Create and initialize a new Strophe.TimedHandler object.
 *
 *  Parameters:
 *    (Integer) period - The number of milliseconds to wait before the
 *      handler is called.
 *    (Function) handler - The callback to run when the handler fires.  This
 *      function should take no arguments.
 *
 *  Returns:
 *    A new Strophe.TimedHandler object.
 */
Strophe.TimedHandler = function (period, handler)
{
    this.period = period;
    this.handler = handler;

    this.lastCalled = new Date().getTime();
    this.user = true;
};

Strophe.TimedHandler.prototype = {
    /** PrivateFunction: run
     *  Run the callback for the Strophe.TimedHandler.
     *
     *  Returns:
     *    true if the Strophe.TimedHandler should be called again, and false
     *      otherwise.
     */
    run: function ()
    {
        this.lastCalled = new Date().getTime();
        return this.handler();
    },

    /** PrivateFunction: reset
     *  Reset the last called time for the Strophe.TimedHandler.
     */
    reset: function ()
    {
        this.lastCalled = new Date().getTime();
    },

    /** PrivateFunction: toString
     *  Get a string representation of the Strophe.TimedHandler object.
     *
     *  Returns:
     *    The string representation.
     */
    toString: function ()
    {
        return "{TimedHandler: " + this.handler + "(" + this.period +")}";
    }
};

/** PrivateClass: Strophe.Request
 *  _Private_ helper class that provides a cross implementation abstraction
 *  for a BOSH related XMLHttpRequest.
 *
 *  The Strophe.Request class is used internally to encapsulate BOSH request
 *  information.  It is not meant to be used from user's code.
 */

/** PrivateConstructor: Strophe.Request
 *  Create and initialize a new Strophe.Request object.
 *
 *  Parameters:
 *    (XMLElement) elem - The XML data to be sent in the request.
 *    (Function) func - The function that will be called when the
 *      XMLHttpRequest readyState changes.
 *    (Integer) rid - The BOSH rid attribute associated with this request.
 *    (Integer) sends - The number of times this same request has been
 *      sent.
 */
Strophe.Request = function (elem, func, rid, sends)
{
    this.id = ++Strophe._requestId;
    this.xmlData = elem;
    this.data = Strophe.serialize(elem);
    // save original function in case we need to make a new request
    // from this one.
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends || 0;
    this.abort = false;
    this.dead = null;
    this.age = function () {
        if (!this.date) { return 0; }
        var now = new Date();
        return (now - this.date) / 1000;
    };
    this.timeDead = function () {
        if (!this.dead) { return 0; }
        var now = new Date();
        return (now - this.dead) / 1000;
    };
    this.xhr = this._newXHR();
};

Strophe.Request.prototype = {
    /** PrivateFunction: getResponse
     *  Get a response from the underlying XMLHttpRequest.
     *
     *  This function attempts to get a response from the request and checks
     *  for errors.
     *
     *  Throws:
     *    "parsererror" - A parser error occured.
     *
     *  Returns:
     *    The DOM element tree of the response.
     */
    getResponse: function ()
    {
        var node = null;
        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
            node = this.xhr.responseXML.documentElement;
            if (node.tagName == "parsererror") {
                Strophe.error("invalid response received");
                Strophe.error("responseText: " + this.xhr.responseText);
                Strophe.error("responseXML: " +
                              Strophe.serialize(this.xhr.responseXML));
                throw "parsererror";
            }
        } else if (this.xhr.responseText) {
            Strophe.error("invalid response received");
            Strophe.error("responseText: " + this.xhr.responseText);
            Strophe.error("responseXML: " +
                          Strophe.serialize(this.xhr.responseXML));
        }

        return node;
    },

    /** PrivateFunction: _newXHR
     *  _Private_ helper function to create XMLHttpRequests.
     *
     *  This function creates XMLHttpRequests across all implementations.
     *
     *  Returns:
     *    A new XMLHttpRequest.
     */
    _newXHR: function ()
    {
        var xhr = null;
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
            if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/xml");
            }
        } else if (window.ActiveXObject) {
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }

        // use Function.bind() to prepend ourselves as an argument
        xhr.onreadystatechange = this.func.bind(null, this);

        return xhr;
    }
};

/** Class: Strophe.Connection
 *  XMPP Connection manager.
 *
 *  Thie class is the main part of Strophe.  It manages a BOSH connection
 *  to an XMPP server and dispatches events to the user callbacks as
 *  data arrives.  It supports SASL PLAIN, SASL DIGEST-MD5, and legacy
 *  authentication.
 *
 *  After creating a Strophe.Connection object, the user will typically
 *  call connect() with a user supplied callback to handle connection level
 *  events like authentication failure, disconnection, or connection
 *  complete.
 *
 *  The user will also have several event handlers defined by using
 *  addHandler() and addTimedHandler().  These will allow the user code to
 *  respond to interesting stanzas or do something periodically with the
 *  connection.  These handlers will be active once authentication is
 *  finished.
 *
 *  To send data to the connection, use send().
 */

/** Constructor: Strophe.Connection
 *  Create and initialize a Strophe.Connection object.
 *
 *  Parameters:
 *    (String) service - The BOSH service URL.
 *
 *  Returns:
 *    A new Strophe.Connection object.
 */
Strophe.Connection = function (service)
{
    /* The path to the httpbind service. */
    this.service = service;
    /* The connected JID. */
    this.jid = "";
    /* request id for body tags */
    this.rid = Math.floor(Math.random() * 4294967295);
    /* The current session ID. */
    this.sid = null;
    this.streamId = null;
    /* stream:features */
    this.features = null;

    // SASL
    this.do_session = false;
    this.do_bind = false;

    // handler lists
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];

    this._idleTimeout = null;
    this._disconnectTimeout = null;

    this.authenticated = false;
    this.disconnecting = false;
    this.connected = false;

    this.errors = 0;

    this.paused = false;

    // default BOSH values
    this.hold = 1;
    this.wait = 60;
    this.window = 5;

    this._data = [];
    this._requests = [];
    this._uniqueId = Math.round(Math.random() * 10000);

    this._sasl_success_handler = null;
    this._sasl_failure_handler = null;
    this._sasl_challenge_handler = null;

    // setup onIdle callback every 1/10th of a second
    this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);

    // initialize plugins
    for (var k in Strophe._connectionPlugins) {
        if (Strophe._connectionPlugins.hasOwnProperty(k)) {
        var ptype = Strophe._connectionPlugins[k];
            // jslint complaints about the below line, but this is fine
            var F = function () {};
            F.prototype = ptype;
            this[k] = new F();
        this[k].init(this);
        }
    }
};

Strophe.Connection.prototype = {
    /** Function: reset
     *  Reset the connection.
     *
     *  This function should be called after a connection is disconnected
     *  before that connection is reused.
     */
    reset: function ()
    {
        this.rid = Math.floor(Math.random() * 4294967295);

        this.sid = null;
        this.streamId = null;

        // SASL
        this.do_session = false;
        this.do_bind = false;

        // handler lists
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];

        this.authenticated = false;
        this.disconnecting = false;
        this.connected = false;

        this.errors = 0;

        this._requests = [];
        this._uniqueId = Math.round(Math.random()*10000);
    },

    /** Function: pause
     *  Pause the request manager.
     *
     *  This will prevent Strophe from sending any more requests to the
     *  server.  This is very useful for temporarily pausing while a lot
     *  of send() calls are happening quickly.  This causes Strophe to
     *  send the data in a single request, saving many request trips.
     */
    pause: function ()
    {
        this.paused = true;
    },

    /** Function: resume
     *  Resume the request manager.
     *
     *  This resumes after pause() has been called.
     */
    resume: function ()
    {
        this.paused = false;
    },

    /** Function: getUniqueId
     *  Generate a unique ID for use in <iq/> elements.
     *
     *  All <iq/> stanzas are required to have unique id attributes.  This
     *  function makes creating these easy.  Each connection instance has
     *  a counter which starts from zero, and the value of this counter
     *  plus a colon followed by the suffix becomes the unique id. If no
     *  suffix is supplied, the counter is used as the unique id.
     *
     *  Suffixes are used to make debugging easier when reading the stream
     *  data, and their use is recommended.  The counter resets to 0 for
     *  every new connection for the same reason.  For connections to the
     *  same server that authenticate the same way, all the ids should be
     *  the same, which makes it easy to see changes.  This is useful for
     *  automated testing as well.
     *
     *  Parameters:
     *    (String) suffix - A optional suffix to append to the id.
     *
     *  Returns:
     *    A unique string to be used for the id attribute.
     */
    getUniqueId: function (suffix)
    {
        if (typeof(suffix) == "string" || typeof(suffix) == "number") {
            return ++this._uniqueId + ":" + suffix;
        } else {
            return ++this._uniqueId + "";
        }
    },

    /** Function: connect
     *  Starts the connection process.
     *
     *  As the connection process proceeds, the user supplied callback will
     *  be triggered multiple times with status updates.  The callback
     *  should take two arguments - the status code and the error condition.
     *
     *  The status code will be one of the values in the Strophe.Status
     *  constants.  The error condition will be one of the conditions
     *  defined in RFC 3920 or the condition 'strophe-parsererror'.
     *
     *  Please see XEP 124 for a more detailed explanation of the optional
     *  parameters below.
     *
     *  Parameters:
     *    (String) jid - The user's JID.  This may be a bare JID,
     *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
     *      authentication will be attempted.
     *    (String) pass - The user's password.
     *    (Function) callback - The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     */
    connect: function (jid, pass, callback, wait, hold)
    {
        this.jid = jid;
        this.pass = pass;
        this.connect_callback = callback;
        this.disconnecting = false;
        this.connected = false;
        this.authenticated = false;
        this.errors = 0;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;

        // parse jid for domain and resource
        this.domain = Strophe.getDomainFromJid(this.jid);

        // build the body tag
        var body = this._buildBody().attrs({
            to: this.domain,
            "xml:lang": "en",
            wait: this.wait,
            hold: this.hold,
            content: "text/xml; charset=utf-8",
            ver: "1.6",
            "xmpp:version": "1.0",
            "xmlns:xmpp": Strophe.NS.BOSH
        });

        this._changeConnectStatus(Strophe.Status.CONNECTING, null);

        this._requests.push(
            new Strophe.Request(body.tree(),
                                this._onRequestStateChange.bind(
                                    this, this._connect_cb.bind(this)),
                                body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** Function: attach
     *  Attach to an already created and authenticated BOSH session.
     *
     *  This function is provided to allow Strophe to attach to BOSH
     *  sessions which have been created externally, perhaps by a Web
     *  application.  This is often used to support auto-login type features
     *  without putting user credentials into the page.
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *    (String) sid - The SID of the BOSH session.
     *    (String) rid - The current RID of the BOSH session.  This RID
     *      will be used by the next request.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    attach: function (jid, sid, rid, callback, wait, hold, wind)
    {
        this.jid = jid;
        this.sid = sid;
        this.rid = rid;
        this.connect_callback = callback;

        this.domain = Strophe.getDomainFromJid(this.jid);

        this.authenticated = true;
        this.connected = true;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;
        this.window = wind || this.window;

        this._changeConnectStatus(Strophe.Status.ATTACHED, null);
    },

    /** Function: xmlInput
     *  User overrideable function that receives XML data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (XMLElement) elem - The XML data received by the connection.
     */
    xmlInput: function (elem)
    {
        return;
    },

    /** Function: xmlOutput
     *  User overrideable function that receives XML data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (XMLElement) elem - The XMLdata sent by the connection.
     */
    xmlOutput: function (elem)
    {
        return;
    },

    /** Function: rawInput
     *  User overrideable function that receives raw data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data received by the connection.
     */
    rawInput: function (data)
    {
        return;
    },

    /** Function: rawOutput
     *  User overrideable function that receives raw data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data sent by the connection.
     */
    rawOutput: function (data)
    {
        return;
    },

    /** Function: send
     *  Send a stanza.
     *
     *  This function is called to push data onto the send queue to
     *  go out over the wire.  Whenever a request is sent to the BOSH
     *  server, all pending data is sent and the queue is flushed.
     *
     *  Parameters:
     *    (XMLElement |
     *     [XMLElement] |
     *     Strophe.Builder) elem - The stanza to send.
     */
    send: function (elem)
    {
        if (elem === null) { return ; }
        if (typeof(elem.sort) === "function") {
            for (var i = 0; i < elem.length; i++) {
                this._queueData(elem[i]);
            }
        } else if (typeof(elem.tree) === "function") {
            this._queueData(elem.tree());
        } else {
            this._queueData(elem);
        }

        this._throttledRequestHandler();
        clearTimeout(this._idleTimeout);
        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
    },

    /** Function: flush
     *  Immediately send any pending outgoing data.
     *
     *  Normally send() queues outgoing data until the next idle period
     *  (100ms), which optimizes network use in the common cases when
     *  several send()s are called in succession. flush() can be used to
     *  immediately send all pending data.
     */
    flush: function ()
    {
        // cancel the pending idle period and run the idle function
        // immediately
        clearTimeout(this._idleTimeout);
        this._onIdle();
    },

    /** Function: sendIQ
     *  Helper function to send IQ stanzas.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza to send.
     *    (Function) callback - The callback function for a successful request.
     *    (Function) errback - The callback function for a failed or timed
     *      out request.  On timeout, the stanza will be null.
     *    (Integer) timeout - The time specified in milliseconds for a
     *      timeout to occur.
     *
     *  Returns:
     *    The id used to send the IQ.
    */
    sendIQ: function(elem, callback, errback, timeout) {
        var timeoutHandler = null;
        var that = this;

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }
    var id = elem.getAttribute('id');

    // inject id if not found
    if (!id) {
        id = this.getUniqueId("sendIQ");
        elem.setAttribute("id", id);
    }

    var handler = this.addHandler(function (stanza) {
        // remove timeout handler if there is one
            if (timeoutHandler) {
                that.deleteTimedHandler(timeoutHandler);
            }

            var iqtype = stanza.getAttribute('type');
        if (iqtype == 'result') {
        if (callback) {
                    callback(stanza);
                }
        } else if (iqtype == 'error') {
        if (errback) {
                    errback(stanza);
                }
        } else {
                throw {
                    name: "StropheError",
                    message: "Got bad IQ type of " + iqtype
                };
            }
    }, null, 'iq', null, id);

    // if timeout specified, setup timeout handler.
    if (timeout) {
        timeoutHandler = this.addTimedHandler(timeout, function () {
                // get rid of normal handler
                that.deleteHandler(handler);

            // call errback on timeout with null stanza
                if (errback) {
            errback(null);
                }
        return false;
        });
    }

    this.send(elem);

    return id;
    },

    /** PrivateFunction: _queueData
     *  Queue outgoing data for later sending.  Also ensures that the data
     *  is a DOMElement.
     */
    _queueData: function (element) {
        if (element === null ||
            !element.tagName ||
            !element.childNodes) {
            throw {
                name: "StropheError",
                message: "Cannot queue non-DOMElement."
            };
        }

        this._data.push(element);
    },

    /** PrivateFunction: _sendRestart
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function ()
    {
        this._data.push("restart");

        this._throttledRequestHandler();
        clearTimeout(this._idleTimeout);
        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
    },

    /** Function: addTimedHandler
     *  Add a timed handler to the connection.
     *
     *  This function adds a timed handler.  The provided handler will
     *  be called every period milliseconds until it returns false,
     *  the connection is terminated, or the handler is removed.  Handlers
     *  that wish to continue being invoked should return true.
     *
     *  Because of method binding it is necessary to save the result of
     *  this function if you wish to remove a handler with
     *  deleteTimedHandler().
     *
     *  Note that user handlers are not active until authentication is
     *  successful.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addTimedHandler: function (period, handler)
    {
        var thand = new Strophe.TimedHandler(period, handler);
        this.addTimeds.push(thand);
        return thand;
    },

    /** Function: deleteTimedHandler
     *  Delete a timed handler for a connection.
     *
     *  This function removes a timed handler from the connection.  The
     *  handRef parameter is *not* the function passed to addTimedHandler(),
     *  but is the reference returned from addTimedHandler().
     *
     *  Parameters:
     *    (Strophe.TimedHandler) handRef - The handler reference.
     */
    deleteTimedHandler: function (handRef)
    {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeTimeds.push(handRef);
    },

    /** Function: addHandler
     *  Add a stanza handler for the connection.
     *
     *  This function adds a stanza handler to the connection.  The
     *  handler callback will be called for any stanza that matches
     *  the parameters.  Note that if multiple parameters are supplied,
     *  they must all match for the handler to be invoked.
     *
     *  The handler will receive the stanza that triggered it as its argument.
     *  The handler should return true if it is to be invoked again;
     *  returning false will remove the handler after it returns.
     *
     *  As a convenience, the ns parameters applies to the top level element
     *  and also any of its immediate children.  This is primarily to make
     *  matching /iq/query elements easy.
     *
     *  The options argument contains handler matching flags that affect how
     *  matches are determined. Currently the only flag is matchBare (a
     *  boolean). When matchBare is true, the from parameter and the from
     *  attribute on the stanza will be matched as bare JIDs instead of
     *  full JIDs. To use this, pass {matchBare: true} as the value of
     *  options. The default value for matchBare is false.
     *
     *  The return value should be saved if you wish to remove the handler
     *  with deleteHandler().
     *
     *  Parameters:
     *    (Function) handler - The user callback.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String) type - The stanza type attribute to match.
     *    (String) id - The stanza id attribute to match.
     *    (String) from - The stanza from attribute to match.
     *    (String) options - The handler options
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addHandler: function (handler, ns, name, type, id, from, options)
    {
        var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
        this.addHandlers.push(hand);
        return hand;
    },

    /** Function: deleteHandler
     *  Delete a stanza handler for a connection.
     *
     *  This function removes a stanza handler from the connection.  The
     *  handRef parameter is *not* the function passed to addHandler(),
     *  but is the reference returned from addHandler().
     *
     *  Parameters:
     *    (Strophe.Handler) handRef - The handler reference.
     */
    deleteHandler: function (handRef)
    {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeHandlers.push(handRef);
    },

    /** Function: disconnect
     *  Start the graceful disconnection process.
     *
     *  This function starts the disconnection process.  This process starts
     *  by sending unavailable presence and sending BOSH body of type
     *  terminate.  A timeout handler makes sure that disconnection happens
     *  even if the BOSH server does not respond.
     *
     *  The user supplied connection callback will be notified of the
     *  progress as this process happens.
     *
     *  Parameters:
     *    (String) reason - The reason the disconnect is occuring.
     */
    disconnect: function (reason)
    {
        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);

        Strophe.info("Disconnect was called because: " + reason);
        if (this.connected) {
            // setup timeout handler
            this._disconnectTimeout = this._addSysTimedHandler(
                3000, this._onDisconnectTimeout.bind(this));
            this._sendTerminate();
        }
    },

    /** PrivateFunction: _changeConnectStatus
     *  _Private_ helper function that makes sure plugins and the user's
     *  callback are notified of connection status changes.
     *
     *  Parameters:
     *    (Integer) status - the new connection status, one of the values
     *      in Strophe.Status
     *    (String) condition - the error condition or null
     */
    _changeConnectStatus: function (status, condition)
    {
        // notify all plugins listening for status changes
        for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                var plugin = this[k];
                if (plugin.statusChanged) {
                    try {
                        plugin.statusChanged(status, condition);
                    } catch (err) {
                        Strophe.error("" + k + " plugin caused an exception " +
                                      "changing status: " + err);
                    }
                }
            }
        }

        // notify the user's callback
        if (this.connect_callback) {
            try {
                this.connect_callback(status, condition);
            } catch (e) {
                Strophe.error("User connection callback caused an " +
                              "exception: " + e);
            }
        }
    },

    /** PrivateFunction: _buildBody
     *  _Private_ helper function to generate the <body/> wrapper for BOSH.
     *
     *  Returns:
     *    A Strophe.Builder with a <body/> element.
     */
    _buildBody: function ()
    {
        var bodyWrap = $build('body', {
            rid: this.rid++,
            xmlns: Strophe.NS.HTTPBIND
        });

        if (this.sid !== null) {
            bodyWrap.attrs({sid: this.sid});
        }

        return bodyWrap;
    },

    /** PrivateFunction: _removeRequest
     *  _Private_ function to remove a request from the queue.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request to remove.
     */
    _removeRequest: function (req)
    {
        Strophe.debug("removing request");

        var i;
        for (i = this._requests.length - 1; i >= 0; i--) {
            if (req == this._requests[i]) {
                this._requests.splice(i, 1);
            }
        }

        // IE6 fails on setting to null, so set to empty function
        req.xhr.onreadystatechange = function () {};

        this._throttledRequestHandler();
    },

    /** PrivateFunction: _restartRequest
     *  _Private_ function to restart a request that is presumed dead.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _restartRequest: function (i)
    {
        var req = this._requests[i];
        if (req.dead === null) {
            req.dead = new Date();
        }

        this._processRequest(i);
    },

    /** PrivateFunction: _processRequest
     *  _Private_ function to process a request in the queue.
     *
     *  This function takes requests off the queue and sends them and
     *  restarts dead requests.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _processRequest: function (i)
    {
        var req = this._requests[i];
        var reqStatus = -1;

        try {
            if (req.xhr.readyState == 4) {
                reqStatus = req.xhr.status;
            }
        } catch (e) {
            Strophe.error("caught an error in _requests[" + i +
                          "], reqStatus: " + reqStatus);
        }

        if (typeof(reqStatus) == "undefined") {
            reqStatus = -1;
        }

        // make sure we limit the number of retries
        if (req.sends > 5) {
            this._onDisconnectTimeout();
            return;
        }

        var time_elapsed = req.age();
        var primaryTimeout = (!isNaN(time_elapsed) &&
                              time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
        var secondaryTimeout = (req.dead !== null &&
                                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
        var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                                               (reqStatus < 1 ||
                                                reqStatus >= 500));
        if (primaryTimeout || secondaryTimeout ||
            requestCompletedWithServerError) {
            if (secondaryTimeout) {
                Strophe.error("Request " +
                              this._requests[i].id +
                              " timed out (secondary), restarting");
            }
            req.abort = true;
            req.xhr.abort();
            // setting to null fails on IE6, so set to empty function
            req.xhr.onreadystatechange = function () {};
            this._requests[i] = new Strophe.Request(req.xmlData,
                                                    req.origFunc,
                                                    req.rid,
                                                    req.sends);
            req = this._requests[i];
        }

        if (req.xhr.readyState === 0) {
            Strophe.debug("request id " + req.id +
                          "." + req.sends + " posting");

            try {
                req.xhr.open("POST", this.service + '?' + Math.random(), true);
            } catch (e2) {
                Strophe.error("XHR open failed.");
                if (!this.connected) {
                    this._changeConnectStatus(Strophe.Status.CONNFAIL,
                                              "bad-service");
                }
                this.disconnect();
                return;
            }

            // Fires the XHR request -- may be invoked immediately
            // or on a gradually expanding retry window for reconnects
            var sendFunc = function () {
                req.date = new Date();
                req.xhr.send(req.data);
            };

            // Implement progressive backoff for reconnects --
            // First retry (send == 1) should also be instantaneous
            if (req.sends > 1) {
                // Using a cube of the retry number creates a nicely
                // expanding retry window
                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                       Math.pow(req.sends, 3)) * 1000;
                setTimeout(sendFunc, backoff);
            } else {
                sendFunc();
            }

            req.sends++;

            if (this.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                this.xmlOutput(req.xmlData);
            }
            if (this.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                this.rawOutput(req.data);
            }
        } else {
            Strophe.debug("_processRequest: " +
                          (i === 0 ? "first" : "second") +
                          " request has readyState of " +
                          req.xhr.readyState);
        }
    },

    /** PrivateFunction: _throttledRequestHandler
     *  _Private_ function to throttle requests to the connection window.
     *
     *  This function makes sure we don't send requests so fast that the
     *  request ids overflow the connection window in the case that one
     *  request died.
     */
    _throttledRequestHandler: function ()
    {
        if (!this._requests) {
            Strophe.debug("_throttledRequestHandler called with " +
                          "undefined requests");
        } else {
            Strophe.debug("_throttledRequestHandler called with " +
                          this._requests.length + " requests");
        }

        if (!this._requests || this._requests.length === 0) {
            return;
        }

        if (this._requests.length > 0) {
            this._processRequest(0);
        }

        if (this._requests.length > 1 &&
            Math.abs(this._requests[0].rid -
                     this._requests[1].rid) < this.window) {
            this._processRequest(1);
        }
    },

    /** PrivateFunction: _onRequestStateChange
     *  _Private_ handler for Strophe.Request state changes.
     *
     *  This function is called when the XMLHttpRequest readyState changes.
     *  It contains a lot of error handling logic for the many ways that
     *  requests can fail, and calls the request callback when requests
     *  succeed.
     *
     *  Parameters:
     *    (Function) func - The handler for the request.
     *    (Strophe.Request) req - The request that is changing readyState.
     */
    _onRequestStateChange: function (func, req)
    {
        Strophe.debug("request id " + req.id +
                      "." + req.sends + " state changed to " +
                      req.xhr.readyState);

        if (req.abort) {
            req.abort = false;
            return;
        }

        // request complete
        var reqStatus;
        if (req.xhr.readyState == 4) {
            reqStatus = 0;
            try {
                reqStatus = req.xhr.status;
            } catch (e) {
                // ignore errors from undefined status attribute.  works
                // around a browser bug
            }

            if (typeof(reqStatus) == "undefined") {
                reqStatus = 0;
            }

            if (this.disconnecting) {
                if (reqStatus >= 400) {
                    this._hitError(reqStatus);
                    return;
                }
            }

            var reqIs0 = (this._requests[0] == req);
            var reqIs1 = (this._requests[1] == req);

            if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                // remove from internal queue
                this._removeRequest(req);
                Strophe.debug("request id " +
                              req.id +
                              " should now be removed");
            }

            // request succeeded
            if (reqStatus == 200) {
                // if request 1 finished, or request 0 finished and request
                // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                // restart the other - both will be in the first spot, as the
                // completed request has been removed from the queue already
                if (reqIs1 ||
                    (reqIs0 && this._requests.length > 0 &&
                     this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                    this._restartRequest(0);
                }
                // call handler
                Strophe.debug("request id " +
                              req.id + "." +
                              req.sends + " got 200");
                func(req);
                this.errors = 0;
            } else {
                Strophe.error("request id " +
                              req.id + "." +
                              req.sends + " error " + reqStatus +
                              " happened");
                if (reqStatus === 0 ||
                    (reqStatus >= 400 && reqStatus < 600) ||
                    reqStatus >= 12000) {
                    this._hitError(reqStatus);
                    if (reqStatus >= 400 && reqStatus < 500) {
                        this._changeConnectStatus(Strophe.Status.DISCONNECTING,
                                                  null);
                        this._doDisconnect();
                    }
                }
            }

            if (!((reqStatus > 0 && reqStatus < 500) ||
                  req.sends > 5)) {
                this._throttledRequestHandler();
            }
        }
    },

    /** PrivateFunction: _hitError
     *  _Private_ function to handle the error count.
     *
     *  Requests are resent automatically until their error count reaches
     *  5.  Each time an error is encountered, this function is called to
     *  increment the count and disconnect if the count is too high.
     *
     *  Parameters:
     *    (Integer) reqStatus - The request status.
     */
    _hitError: function (reqStatus)
    {
        this.errors++;
        Strophe.warn("request errored, status: " + reqStatus +
                     ", number of errors: " + this.errors);
        if (this.errors > 4) {
            this._onDisconnectTimeout();
        }
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  This is the last piece of the disconnection logic.  This resets the
     *  connection and alerts the user's connection callback.
     */
    _doDisconnect: function ()
    {
        Strophe.info("_doDisconnect was called");
        this.authenticated = false;
        this.disconnecting = false;
        this.sid = null;
        this.streamId = null;
        this.rid = Math.floor(Math.random() * 4294967295);

        // tell the parent we disconnected
        if (this.connected) {
            this._changeConnectStatus(Strophe.Status.DISCONNECTED, null);
            this.connected = false;
        }

        // delete handlers
        this.handlers = [];
        this.timedHandlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];
    },

    /** PrivateFunction: _dataRecv
     *  _Private_ handler to processes incoming data from the the connection.
     *
     *  Except for _connect_cb handling the initial connection request,
     *  this function handles the incoming data for all requests.  This
     *  function also fires stanza handlers that match each incoming
     *  stanza.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request that has data ready.
     */
    _dataRecv: function (req)
    {
        try {
            var elem = req.getResponse();
        } catch (e) {
            if (e != "parsererror") { throw e; }
            this.disconnect("strophe-parsererror");
        }
        if (elem === null) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            this.xmlInput(elem);
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            this.rawInput(Strophe.serialize(elem));
        }

        // remove handlers scheduled for deletion
        var i, hand;
        while (this.removeHandlers.length > 0) {
            hand = this.removeHandlers.pop();
            i = this.handlers.indexOf(hand);
            if (i >= 0) {
                this.handlers.splice(i, 1);
            }
        }

        // add handlers scheduled for addition
        while (this.addHandlers.length > 0) {
            this.handlers.push(this.addHandlers.pop());
        }

        // handle graceful disconnect
        if (this.disconnecting && this._requests.length === 0) {
            this.deleteTimedHandler(this._disconnectTimeout);
            this._disconnectTimeout = null;
            this._doDisconnect();
            return;
        }

        var typ = elem.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // Don't process stanzas that come in after disconnect
            if (this.disconnecting) {
                return;
            }

            // an error occurred
            cond = elem.getAttribute("condition");
            conflict = elem.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            this.disconnect();
            return;
        }

        // send each incoming stanza through the handler chain
        var that = this;
        Strophe.forEachChild(elem, null, function (child) {
            var i, newList;
            // process handlers
            newList = that.handlers;
            that.handlers = [];
            for (i = 0; i < newList.length; i++) {
                var hand = newList[i];
                // encapsulate 'handler.run' not to lose the whole handler list if
                // one of the handlers throws an exception
                try {
                    if (hand.isMatch(child) &&
                        (that.authenticated || !hand.user)) {
                        if (hand.run(child)) {
                            that.handlers.push(hand);
                        }
                    } else {
                        that.handlers.push(hand);
                    }
                } catch(e) {
                    //if the handler throws an exception, we consider it as false
                }
            }
        });
    },

    /** PrivateFunction: _sendTerminate
     *  _Private_ function to send initial disconnect sequence.
     *
     *  This is the first step in a graceful disconnect.  It sends
     *  the BOSH server a terminate body and includes an unavailable
     *  presence if authentication has completed.
     */
    _sendTerminate: function ()
    {
        Strophe.info("_sendTerminate was called");
        var body = this._buildBody().attrs({type: "terminate"});

        if (this.authenticated) {
            body.c('presence', {
                xmlns: Strophe.NS.CLIENT,
                type: 'unavailable'
            });
        }

        this.disconnecting = true;

        var req = new Strophe.Request(body.tree(),
                                      this._onRequestStateChange.bind(
                                          this, this._dataRecv.bind(this)),
                                      body.tree().getAttribute("rid"));

        this._requests.push(req);
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ handler for initial connection request.
     *
     *  This handler is used to process the initial connection request
     *  response from the BOSH server. It is used to set up authentication
     *  handlers and start the authentication process.
     *
     *  SASL authentication will be attempted if available, otherwise
     *  the code will fall back to legacy authentication.
     *
     *  Parameters:
     *    (Strophe.Request) req - The current request.
     */
    _connect_cb: function (req)
    {
        Strophe.info("_connect_cb was called");

        this.connected = true;
        var bodyWrap = req.getResponse();
        if (!bodyWrap) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            this.xmlInput(bodyWrap);
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            this.rawInput(Strophe.serialize(bodyWrap));
        }

        var typ = bodyWrap.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // an error occurred
            cond = bodyWrap.getAttribute("condition");
            conflict = bodyWrap.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            return;
        }

        // check to make sure we don't overwrite these if _connect_cb is
        // called multiple times in the case of missing stream:features
        if (!this.sid) {
            this.sid = bodyWrap.getAttribute("sid");
        }
        if (!this.stream_id) {
            this.stream_id = bodyWrap.getAttribute("authid");
        }
        var wind = bodyWrap.getAttribute('requests');
        if (wind) { this.window = parseInt(wind, 10); }
        var hold = bodyWrap.getAttribute('hold');
        if (hold) { this.hold = parseInt(hold, 10); }
        var wait = bodyWrap.getAttribute('wait');
        if (wait) { this.wait = parseInt(wait, 10); }


        var do_sasl_plain = false;
        var do_sasl_digest_md5 = false;
        var do_sasl_anonymous = false;

        var mechanisms = bodyWrap.getElementsByTagName("mechanism");
        var i, mech, auth_str, hashed_auth_str;
        if (mechanisms.length > 0) {
            for (i = 0; i < mechanisms.length; i++) {
                mech = Strophe.getText(mechanisms[i]);
                if (mech == 'DIGEST-MD5') {
                    do_sasl_digest_md5 = true;
                } else if (mech == 'PLAIN') {
                    do_sasl_plain = true;
                } else if (mech == 'ANONYMOUS') {
                    do_sasl_anonymous = true;
                }
            }
        } else {
            // we didn't get stream:features yet, so we need wait for it
            // by sending a blank poll request
            var body = this._buildBody();
            this._requests.push(
                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, this._connect_cb.bind(this)),
                                    body.tree().getAttribute("rid")));
            this._throttledRequestHandler();
            return;
        }

        if (Strophe.getNodeFromJid(this.jid) === null &&
            do_sasl_anonymous) {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_success_handler = this._addSysHandler(
                this._sasl_success_cb.bind(this), null,
                "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "ANONYMOUS"
            }).tree());
        } else if (Strophe.getNodeFromJid(this.jid) === null) {
            // we don't have a node, which is required for non-anonymous
            // client connections
            this._changeConnectStatus(Strophe.Status.CONNFAIL,
                                      'x-strophe-bad-non-anon-jid');
            this.disconnect();
        } else if (do_sasl_digest_md5) {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_challenge_handler = this._addSysHandler(
                this._sasl_challenge1_cb.bind(this), null,
                "challenge", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "DIGEST-MD5"
            }).tree());
        } else if (do_sasl_plain) {
            // Build the plain auth string (barejid null
            // username null password) and base 64 encoded.
            auth_str = Strophe.getBareJidFromJid(this.jid);
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + Strophe.getNodeFromJid(this.jid);
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + this.pass;

            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_success_handler = this._addSysHandler(
                this._sasl_success_cb.bind(this), null,
                "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            hashed_auth_str = Base64.encode(auth_str);
            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "PLAIN"
            }).t(hashed_auth_str).tree());
        } else {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._addSysHandler(this._auth1_cb.bind(this), null, null,
                                null, "_auth_1");

            this.send($iq({
                type: "get",
                to: this.domain,
                id: "_auth_1"
            }).c("query", {
                xmlns: Strophe.NS.AUTH
            }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree());
        }
    },

    /** PrivateFunction: _sasl_challenge1_cb
     *  _Private_ handler for DIGEST-MD5 SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The challenge stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_challenge1_cb: function (elem)
    {
        var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;

        var challenge = Base64.decode(Strophe.getText(elem));
        var cnonce = stropheMD5.hexdigest("" + (Math.random() * 1234567890));
        var realm = "";
        var host = null;
        var nonce = "";
        var qop = "";
        var matches;

        // remove unneeded handlers
        this.deleteHandler(this._sasl_failure_handler);

        while (challenge.match(attribMatch)) {
            matches = challenge.match(attribMatch);
            challenge = challenge.replace(matches[0], "");
            matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
            switch (matches[1]) {
            case "realm":
                realm = matches[2];
                break;
            case "nonce":
                nonce = matches[2];
                break;
            case "qop":
                qop = matches[2];
                break;
            case "host":
                host = matches[2];
                break;
            }
        }

        var digest_uri = "xmpp/" + this.domain;
        if (host !== null) {
            digest_uri = digest_uri + "/" + host;
        }

        var A1 = stropheMD5.hash(Strophe.getNodeFromJid(this.jid) +
                          ":" + realm + ":" + this.pass) +
            ":" + nonce + ":" + cnonce;
        var A2 = 'AUTHENTICATE:' + digest_uri;

        var responseText = "";
        responseText += 'username=' +
            this._quote(Strophe.getNodeFromJid(this.jid)) + ',';
        responseText += 'realm=' + this._quote(realm) + ',';
        responseText += 'nonce=' + this._quote(nonce) + ',';
        responseText += 'cnonce=' + this._quote(cnonce) + ',';
        responseText += 'nc="00000001",';
        responseText += 'qop="auth",';
        responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
        responseText += 'response=' + this._quote(
            stropheMD5.hexdigest(stropheMD5.hexdigest(A1) + ":" +
                          nonce + ":00000001:" +
                          cnonce + ":auth:" +
                          stropheMD5.hexdigest(A2))) + ',';
        responseText += 'charset="utf-8"';

        this._sasl_challenge_handler = this._addSysHandler(
            this._sasl_challenge2_cb.bind(this), null,
            "challenge", null, null);
        this._sasl_success_handler = this._addSysHandler(
            this._sasl_success_cb.bind(this), null,
            "success", null, null);
        this._sasl_failure_handler = this._addSysHandler(
            this._sasl_failure_cb.bind(this), null,
            "failure", null, null);

        this.send($build('response', {
            xmlns: Strophe.NS.SASL
        }).t(Base64.encode(responseText)).tree());

        return false;
    },

    /** PrivateFunction: _quote
     *  _Private_ utility function to backslash escape and quote strings.
     *
     *  Parameters:
     *    (String) str - The string to be quoted.
     *
     *  Returns:
     *    quoted string
     */
    _quote: function (str)
    {
        return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
        //" end string workaround for emacs
    },


    /** PrivateFunction: _sasl_challenge2_cb
     *  _Private_ handler for second step of DIGEST-MD5 SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The challenge stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_challenge2_cb: function (elem)
    {
        // remove unneeded handlers
        this.deleteHandler(this._sasl_success_handler);
        this.deleteHandler(this._sasl_failure_handler);

        this._sasl_success_handler = this._addSysHandler(
            this._sasl_success_cb.bind(this), null,
            "success", null, null);
        this._sasl_failure_handler = this._addSysHandler(
            this._sasl_failure_cb.bind(this), null,
            "failure", null, null);
        this.send($build('response', {xmlns: Strophe.NS.SASL}).tree());
        return false;
    },

    /** PrivateFunction: _auth1_cb
     *  _Private_ handler for legacy authentication.
     *
     *  This handler is called in response to the initial <iq type='get'/>
     *  for legacy authentication.  It builds an authentication <iq/> and
     *  sends it, creating a handler (calling back to _auth2_cb()) to
     *  handle the result
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _auth1_cb: function (elem)
    {
        // build plaintext auth iq
        var iq = $iq({type: "set", id: "_auth_2"})
            .c('query', {xmlns: Strophe.NS.AUTH})
            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
            .up()
            .c('password').t(this.pass);

        if (!Strophe.getResourceFromJid(this.jid)) {
            // since the user has not supplied a resource, we pick
            // a default one here.  unlike other auth methods, the server
            // cannot do this for us.
            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
        }
        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

        this._addSysHandler(this._auth2_cb.bind(this), null,
                            null, null, "_auth_2");

        this.send(iq.tree());

        return false;
    },

    /** PrivateFunction: _sasl_success_cb
     *  _Private_ handler for succesful SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_success_cb: function (elem)
    {
        Strophe.info("SASL authentication succeeded.");

        // remove old handlers
        this.deleteHandler(this._sasl_failure_handler);
        this._sasl_failure_handler = null;
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        this._addSysHandler(this._sasl_auth1_cb.bind(this), null,
                            "stream:features", null, null);

        // we must send an xmpp:restart now
        this._sendRestart();

        return false;
    },

    /** PrivateFunction: _sasl_auth1_cb
     *  _Private_ handler to start stream binding.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_auth1_cb: function (elem)
    {
        // save stream:features for future usage
        this.features = elem;

        var i, child;

        for (i = 0; i < elem.childNodes.length; i++) {
            child = elem.childNodes[i];
            if (child.nodeName == 'bind') {
                this.do_bind = true;
            }

            if (child.nodeName == 'session') {
                this.do_session = true;
            }
        }

        if (!this.do_bind) {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        } else {
            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,
                                null, "_bind_auth_2");

            var resource = Strophe.getResourceFromJid(this.jid);
            if (resource) {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .c('resource', {}).t(resource).tree());
            } else {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .tree());
            }
        }

        return false;
    },

    /** PrivateFunction: _sasl_bind_cb
     *  _Private_ handler for binding result and session start.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_bind_cb: function (elem)
    {
        if (elem.getAttribute("type") == "error") {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }

        // TODO - need to grab errors
        var bind = elem.getElementsByTagName("bind");
        var jidNode;
        if (bind.length > 0) {
            // Grab jid
            jidNode = bind[0].getElementsByTagName("jid");
            if (jidNode.length > 0) {
                this.jid = Strophe.getText(jidNode[0]);

                if (this.do_session) {
                    this._addSysHandler(this._sasl_session_cb.bind(this),
                                        null, null, null, "_session_auth_2");

                    this.send($iq({type: "set", id: "_session_auth_2"})
                                  .c('session', {xmlns: Strophe.NS.SESSION})
                                  .tree());
                } else {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                }
            }
        } else {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }
    },

    /** PrivateFunction: _sasl_session_cb
     *  _Private_ handler to finish successful SASL connection.
     *
     *  This sets Connection.authenticated to true on success, which
     *  starts the processing of user handlers.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_session_cb: function (elem)
    {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            Strophe.info("Session creation failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }

        return false;
    },

    /** PrivateFunction: _sasl_failure_cb
     *  _Private_ handler for SASL authentication failure.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_failure_cb: function (elem)
    {
        // delete unneeded handlers
        if (this._sasl_success_handler) {
            this.deleteHandler(this._sasl_success_handler);
            this._sasl_success_handler = null;
        }
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
        return false;
    },

    /** PrivateFunction: _auth2_cb
     *  _Private_ handler to finish legacy authentication.
     *
     *  This handler is called when the result from the jabber:iq:auth
     *  <iq/> stanza is returned.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _auth2_cb: function (elem)
    {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            this.disconnect();
        }

        return false;
    },

    /** PrivateFunction: _addSysTimedHandler
     *  _Private_ function to add a system level timed handler.
     *
     *  This function is used to add a Strophe.TimedHandler for the
     *  library code.  System timed handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     */
    _addSysTimedHandler: function (period, handler)
    {
        var thand = new Strophe.TimedHandler(period, handler);
        thand.user = false;
        this.addTimeds.push(thand);
        return thand;
    },

    /** PrivateFunction: _addSysHandler
     *  _Private_ function to add a system level stanza handler.
     *
     *  This function is used to add a Strophe.Handler for the
     *  library code.  System stanza handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Function) handler - The callback function.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String) type - The stanza type attribute to match.
     *    (String) id - The stanza id attribute to match.
     */
    _addSysHandler: function (handler, ns, name, type, id)
    {
        var hand = new Strophe.Handler(handler, ns, name, type, id);
        hand.user = false;
        this.addHandlers.push(hand);
        return hand;
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  If the graceful disconnect process does not complete within the
     *  time allotted, this handler finishes the disconnect anyway.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _onDisconnectTimeout: function ()
    {
        Strophe.info("_onDisconnectTimeout was called");

        // cancel all remaining requests and clear the queue
        var req;
        while (this._requests.length > 0) {
            req = this._requests.pop();
            req.abort = true;
            req.xhr.abort();
            // jslint complains, but this is fine. setting to empty func
            // is necessary for IE6
            req.xhr.onreadystatechange = function () {};
        }

        // actually disconnect
        this._doDisconnect();

        return false;
    },

    /** PrivateFunction: _onIdle
     *  _Private_ handler to process events during idle cycle.
     *
     *  This handler is called every 100ms to fire timed handlers that
     *  are ready and keep poll requests going.
     */
    _onIdle: function ()
    {
        var i, thand, since, newList;

        // add timed handlers scheduled for addition
        // NOTE: we add before remove in the case a timed handler is
        // added and then deleted before the next _onIdle() call.
        while (this.addTimeds.length > 0) {
            this.timedHandlers.push(this.addTimeds.pop());
        }

        // remove timed handlers that have been scheduled for deletion
        while (this.removeTimeds.length > 0) {
            thand = this.removeTimeds.pop();
            i = this.timedHandlers.indexOf(thand);
            if (i >= 0) {
                this.timedHandlers.splice(i, 1);
            }
        }

        // call ready timed handlers
        var now = new Date().getTime();
        newList = [];
        for (i = 0; i < this.timedHandlers.length; i++) {
            thand = this.timedHandlers[i];
            if (this.authenticated || !thand.user) {
                since = thand.lastCalled + thand.period;
                if (since - now <= 0) {
                    if (thand.run()) {
                        newList.push(thand);
                    }
                } else {
                    newList.push(thand);
                }
            }
        }
        this.timedHandlers = newList;

        var body, time_elapsed;

        // if no requests are in progress, poll
        if (this.authenticated && this._requests.length === 0 &&
            this._data.length === 0 && !this.disconnecting) {
            Strophe.info("no requests during idle cycle, sending " +
                         "blank request");
            this._data.push(null);
        }

        if (this._requests.length < 2 && this._data.length > 0 &&
            !this.paused) {
            body = this._buildBody();
            for (i = 0; i < this._data.length; i++) {
                if (this._data[i] !== null) {
                    if (this._data[i] === "restart") {
                        body.attrs({
                            to: this.domain,
                            "xml:lang": "en",
                            "xmpp:restart": "true",
                            "xmlns:xmpp": Strophe.NS.BOSH
                        });
                    } else {
                        body.cnode(this._data[i]).up();
                    }
                }
            }
            delete this._data;
            this._data = [];
            this._requests.push(
                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, this._dataRecv.bind(this)),
                                    body.tree().getAttribute("rid")));
            this._processRequest(this._requests.length - 1);
        }

        if (this._requests.length > 0) {
            time_elapsed = this._requests[0].age();
            if (this._requests[0].dead !== null) {
                if (this._requests[0].timeDead() >
                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                    this._throttledRequestHandler();
                }
            }

            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                Strophe.warn("Request " +
                             this._requests[0].id +
                             " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                             " seconds since last activity");
                this._throttledRequestHandler();
            }
        }

        clearTimeout(this._idleTimeout);

        // reactivate the timer only if connected
        if (this.connected) {
            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
        }
    }
};

if (callback) {
    callback(Strophe, $build, $msg, $iq, $pres);
}

})(function () {
    window.Strophe = arguments[0];
    window.$build = arguments[1];
    window.$msg = arguments[2];
    window.$iq = arguments[3];
    window.$pres = arguments[4];
});
/**
*
*  UTF-8 data encode / decode
*  http://www.webtoolkit.info/
*
**/
 
var Utf8 = {
 
    // public method for url encoding
    encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
 
        for (var n = 0; n < string.length; n++) {
 
            var c = string.charCodeAt(n);
 
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
 
        }
 
        return utftext;
    },
 
    // public method for url decoding
    decode : function (utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;
 
        while ( i < utftext.length ) {
 
            c = utftext.charCodeAt(i);
 
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
 
        }
 
        return string;
    }
 
}
if (typeof( XMPPChat ) == 'undefined') {
    XMPPChat = {};
}

// Типы сообщений XMPP
XMPPChat.XMPP_MT_PRIVATE = 'chat';
XMPPChat.XMPP_MT_ROOM    = 'groupchat';
XMPPChat.XMPP_MT_ERROR   = 'error';

// Типы сообщений в игре
XMPPChat.MT_PRIVATE = 'private';
XMPPChat.MT_ROOM    = 'room';
XMPPChat.MT_ERROR   = 'error';
XMPPChat.MT_COMMAND = 'commands';

// Типы присутствий XMPP
XMPPChat.PT_UNAVAILABLE = 'unavailable';
XMPPChat.PT_ERROR       = 'error';

// Данные для объекта Connection
XMPPChat.BOSH_SERVICE        = '/chb/';
XMPPChat.XMPP_HOST           = 'localhost';
XMPPChat.XMPP_RESOURCE       = 'Game';
XMPPChat.XMPP_FORUM_RESOURCE = 'Forum';
XMPPChat.XMPP_MUC            = 'rooms.localhost';
XMPPChat.XMPP_MULTI_PRIVATE  = '#multi_private@localhost';
if (typeof(XMPPChat) == 'undefined') {
    XMPPChat = {};
}


/*******************************************************************************
 *  Создает объект Connection для взаимодействия с ejabberd.
 *
 *  Parameters:
 *    (String) realName - имя персонажа в игре.
 *    (String) password - пароль соответствующего пользователя в ejabberd.
 *    (String) resource - ресурс для подключения.
 *    (Object) handlers - Обработчики.
 *      (Function) handlers.onStatusChange - изменение статуса соединения
 *      (Function) handlers.onConnect - соответствует статусу "connected" соединения
 *      (Function) handlers.onDisconnect - соответствует статусу "disconnected" соединения
 *      (Function) handlers.onPresence - для станса "presence".
 *      (Function) handlers.onMessage - для станса "message".
 *      (Function) handlers.onQuery - для станса "iq".
 *
 *  Передаваемые параметры обработчикам:
 *    onStatusChange - (Integer) status
 *    onConnect - none
 *    onDisconnect - none
 *    onPresence - см. _onPresence
 *    onMessage - см. _onMessage
 *    onQuery - см. _onQuery
 *
 *  Returns:
 *    Connection object.
 */
XMPPChat.Connection = function(realName, password, resource, handlers) {
    this._realName = realName;
    this._password = password;

    this._username = this.getChatUsername(this._realName);
    this._jid = this._getJIDFromRealName(this._realName, resource);
    this._isLog = false;

    Strophe.log = (function(level, message) {
        if (level == Strophe.LogLevel.WARN ||
            level == Strophe.LogLevel.ERROR ||
            level == Strophe.LogLevel.FATAL
           ) {
            this._log(message);
        }

    }).bind(this);

    this._storeHandlers(handlers);
    this._connection = new Strophe.Connection(XMPPChat.BOSH_SERVICE);
}


/*******************************************************************************
 *  Отправляет присутствие.
 *  Как правило, вызывается один раз при подключении к ejabberd.
 */
XMPPChat.Connection.prototype.sendPresence = function() {
    var oPresence = $pres();
    this._connection.send(oPresence.tree());
}


/*******************************************************************************
 *  Отправляет присутствие в комнату.
 *
 *  Parameters:
 *    (String) to - идентификатор комнаты в ejabberd.
 */
XMPPChat.Connection.prototype.sendRoomPresence = function(to) {
    var toJID = this._getJIDFromRoomId(to);
    var oPresence = $pres({to : toJID + '/' + this._username});
    this._connection.send(oPresence.tree());
}


/*******************************************************************************
 *  Отправляет присутствие 'unavailable' в комнату.
 *
 *  Parameters:
 *    (String) to - идентификатор комнаты в ejabberd.
 */
XMPPChat.Connection.prototype.sendRoomPresenceUnavailable = function(to) {
    var toJID = this._getJIDFromRoomId(to);
    var oPresence = $pres({to : toJID, type : 'unavailable'});
    this._connection.send(oPresence.tree());
}


/*******************************************************************************
 *  Отправляет приватное сообщение.
 *
 *  Parameters:
 *    (String) to - имя персонажа в игре.
 *    (String) message - сообщение.
 *    (Object) атрибуты для тэга "x".
 */
XMPPChat.Connection.prototype.sendPrivateMessage = function(to, message, attrs) {
    var toJID = this._getJIDFromRealName(to);
    var xAttrs = this._addAttributes(attrs, {to_realuser : to});

    var oMessage = $msg({
        to : toJID,
        type : XMPPChat.XMPP_MT_PRIVATE
    }).c('x', xAttrs).up().c('body').t(message);

    this._connection.send(oMessage.tree());
}


/*******************************************************************************
 *  Отправляет приватное сообщение нескольким персонажам.
 *
 *  Parameters:
 *    (String) to - имя персонажа в игре.
 *    (String) message - сообщение.
 *    (Object) атрибуты для тэга "x".
 */
XMPPChat.Connection.prototype.sendMultiPrivateMessage = function(to, message, attrs) {
    var xAttrs = this._addAttributes(
        attrs, {to_realuser : to, to_users : this.getChatUsername(to)}
    );

    var oMessage = $msg({
        to : XMPPChat.XMPP_MULTI_PRIVATE,
        type : XMPPChat.XMPP_MT_PRIVATE
    }).c('x', xAttrs).up().c('body').t(message);

    this._connection.send(oMessage.tree());
}


/*******************************************************************************
 *  Отправляет внутрикомнатное сообщение.
 *
 *  Parameters:
 *    (String) to - идентификатор комнаты в ejabberd.
 *    (String) message - сообщение.
 *    (Object) атрибуты для тэга "x".
 */
XMPPChat.Connection.prototype.sendRoomMessage = function(to, message, attrs) {
    var toJID = this._getJIDFromRoomId(to);
    var xAttrs = attrs;

    var oMessage = $msg({
        to : toJID,
        type : XMPPChat.XMPP_MT_ROOM
    }).c('x', xAttrs).up().c('body').t(message);

    this._connection.send(oMessage.tree());
}


/*******************************************************************************
 *  Возвращает имя игрока в ejabberd.
 *
 *  Parameters:
 *    (String) realName - имя персонажа в игре.
 *
 *  Returns:
 *    имя игрока в ejabberd.
 */
XMPPChat.Connection.prototype.getChatUsername = function(realName) {
    realName = '' + realName;
    var reg = new RegExp(/^[,\_\s\-A-Za-zАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя\d]+$/);

    if (! reg.test(realName)) {
        return '';
    }

    realName = realName.replace(/\s/g, '_');
    realName = realName.toLowerCase();

    return realName;
}


/*******************************************************************************
 *  Возвращает имя персонажа в игре (все буквы строчные).
 *
 *  Parameters:
 *    (String) username - имя персонажа в ejabberd.
 *
 *  Returns:
 *    имя персонажа в игре строчными буквами.
 */
XMPPChat.Connection.prototype.getRealName = function(username) {
    if (! username) {
        return '';
    }

    username = username.replace(/_/g, ' ');

    return username;
}


/*******************************************************************************
 *  Включает/отключает логирование.
 *
 *  Parameters:
 *    (Boolean) state - true для включения, false для выключения.
 */
XMPPChat.Connection.prototype.setLogging = function(state) {
    this._isLog = state ? true : false;
}


/*******************************************************************************
 *  Стартует процесс подключения.
 */
XMPPChat.Connection.prototype.connect = function() {
    this._connection.connect(
        Utf8.encode(this._jid),
        this._password,
        this._onConnect.bind(this)
    );
}


/*******************************************************************************
 *  Стартует процесс отключения.
 */
XMPPChat.Connection.prototype.disconnect = function() {
    this._connection.disconnect();
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Обрабатывает статус соединения с ejabberd.
 *
 *  Parameters:
 *    (Integer) status - статус состояния соединения.
 *
 *  Возможные статусы:
 *  0 - Strophe.Status.ERROR
 *  1 - Strophe.Status.CONNECTING
 *  2 - Strophe.Status.CONNFAIL
 *  3 - Strophe.Status.AUTHENTICATING
 *  4 - Strophe.Status.AUTHFAIL
 *  5 - Strophe.Status.CONNECTED
 *  6 - Strophe.Status.DISCONNECTED
 *  7 - Strophe.Status.DISCONNECTING
 */
XMPPChat.Connection.prototype._onConnect = function(status) {
    if (status == Strophe.Status.ERROR) {
        this._log(status + ': Error from Strophe.');
    } else if (status == Strophe.Status.CONNECTING) {
        this._log(status + ': Strophe is connecting.');
    } else if (status == Strophe.Status.CONNFAIL) {
        this._log(status + ': Strophe connection failed.');
    } else if (status == Strophe.Status.AUTHENTICATING) {
        this._log(status + ': Strophe is authenticating.');
    } else if (status == Strophe.Status.AUTHFAIL) {
        this._log(status + ': Strophe authentication failed.');
    } else if (status == Strophe.Status.CONNECTED) {
        this._log(status + ': Strophe is connected.');

        this._connection.addHandler(
            this._onPresence.bind(this), null, 'presence', null, null, null
        );

        this._connection.addHandler(
            this._onMessage.bind(this), null, 'message', null, null, null
        );

        this._connection.addHandler(
            this._onQuery.bind(this), null, 'iq', null, null, null
        );

        if (this._onConnectHandler) {
            this._onConnectHandler();
        }

    } else if (status == Strophe.Status.DISCONNECTED) {
        this._log(status + ': Strophe is disconnected.');

        if (this._onDisconnectHandler) {
            this._onDisconnectHandler();
        }
    } else if (status == Strophe.Status.DISCONNECTING) {
        this._log(status + ': Strophe is disconnecting.');
    }

    if (this._onChangeStatusHandler) {
        this._onChangeStatusHandler(status);
    }
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Обрабатывает станс "presence" и вызывает соответствующий обработчик.
 *
 *  Вызываемому обработчику передается:
 *    (Object) data - см. _parsePresence
 *    (XMLElement) presence - станс
 *
 *  Parameters:
 *    (XMLElement) presence - станс.
 */
XMPPChat.Connection.prototype._onPresence = function(presence) {
    if (! this._onPresenceHandler) {
        return true;
    }

    var data = this._parsePresence(presence);

    if (data.fromJID) {
        this._onPresenceHandler(data, presence);
    }

    return true;
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Обрабатывает станс "message" и вызывает соответствующий обработчик.
 *
 *  Вызываемому обработчику передается:
 *    (Object) data - см. _parseMessage
 *    (XMLElement) message - станс
 *
 *  Parameters:
 *    (XMLElement) message - станс.
 */
XMPPChat.Connection.prototype._onMessage = function(message) {
    if (! this._onMessageHandler) {
        return true;
    }

    var data = this._parseMessage(message);

    if (data.fromJID) {
        try {
            this._onMessageHandler(data, message);
        } catch (e) {
            this._log(e);
        }
    }

    return true;
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Обрабатывает станс "iq" и вызывает соответствующий обработчик.
 *
 *  Parameters:
 *    (XMLElement) iq - станс.
 */
XMPPChat.Connection.prototype._onQuery = function(iq) {
    if (! this._onQueryHandler) {
        return true;
    }

    var data = this._parseQuery(iq);
    this._onQueryHandler(data, iq);

    return true;
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Возвращает JID персонажа в ejabberd.
 *
 *  Parameters:
 *    (String) realName - имя персонажа в игре.
 *
 *  Returns:
 *    JID персонажа в ejabberd.
 */
XMPPChat.Connection.prototype._getJIDFromRealName = function(realName, resource) {
    if (! resource) {
        resource = XMPPChat.XMPP_RESOURCE;
    }

    return this.getChatUsername(realName) +
        '@' + XMPPChat.XMPP_HOST + '/' + resource;
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Возвращает JID комнаты в ejabberd.
 *
 *  Parameters:
 *    (String) roomId - идентификатор комнаты в ejabberd.
 *
 *  Returns:
 *    JID комнаты в ejabberd.
 */
XMPPChat.Connection.prototype._getJIDFromRoomId = function(roomId) {
    return roomId + '@' + XMPPChat.XMPP_MUC;
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Парсит станс "presence".
 *
 *  Parameters:
 *    (XMLElement) presence - станс.
 *
 *  Returns:
 *    (Object) data со следующими полями:
 *      (String) type - тип присутствия (присутствие, отсутствие, ошибочное)
 *      (String) from - имя игрока-отправителя в ejabberd
 *      (String) roomId - идентификатор комнаты в ejabberd для внутрикомнатного присутствия
 *      (String) errorCode - код ошибки для ошибочного присутствия
 *      (String) fromJID - JID отправителя
 *      (String) toJID - JID получателя
 *      (Object) x - объект, содержащий параметры элемента "x" станса "presence"
 *      (XMLElement) xmlX - тэг "x" как xml-объект
 *      (XMLElement) xmlStatus - тэг "status" как xml-объект
 *      (XMLElement) xmlDestroy - тэг "destroy" как xml-объект
 */
XMPPChat.Connection.prototype._parsePresence = function(presence) {
    var data = {
        type : presence.getAttribute('type'),
        fromJID : presence.getAttribute('from'),
        toJID : presence.getAttribute('to'),
        x : this._getXParams(presence)
    };

    // Интересуют только комнатные присутствия
    if (Strophe.getDomainFromJid(data.fromJID) == XMPPChat.XMPP_MUC) {
        data.from = Strophe.getResourceFromJid(data.fromJID);
        data.roomId = Strophe.getNodeFromJid(data.fromJID);
    }

    var statuses = presence.getElementsByTagName('status');

    if (statuses && statuses.length > 0) {
        data.xmlStatus = statuses[0];
    }

    var xs = presence.getElementsByTagName('x');

    if (xs && xs.length > 0) {
        data.xmlX = xs[0];
        var destroys = data.xmlX.getElementsByTagName('destroy');

        if (destroys && destroys.length > 0) {
            data.xmlDestroy = destroys[0];
        }
    }

    if (data.type == XMPPChat.PT_ERROR) {
        var errors = presence.getElementsByTagName('error');

        if (errors && errors.length > 0) {
            data.errorCode = errors[0].getAttribute('code');
        }
    }

    return data;
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Парсит станс "message".
 *
 *  Parameters:
 *    (XMLElement) message - станс.
 *
 *  Returns:
 *    (Object) data со следующими полями:
 *      (String) type - тип сообщения (приватное, внутрикомнатное, ошибочное)
 *      (String) from - имя игрока-отправителя в ejabberd
 *      (String) roomId - идентификатор комнаты в ejabberd для внутрикомнатного сообщения
 *      (String) errorCode - код ошибки для ошибочного сообщения
 *      (String) fromJID - JID отправителя
 *      (String) toJID - JID получателя
 *      (Object) x - объект, содержащий параметры элемента "x" станса "message"
 *      (String) body - текст тэга "body"
 *      (XMLElement) xmlBody - тэг "body" как xml-объект
 */
XMPPChat.Connection.prototype._parseMessage = function(message) {
    var bodies = message.getElementsByTagName('body');

    if (! bodies || bodies.length == 0) {
        this._log(
            'Error: Empty body received for stanza: ' +
            Strophe.serialize(message)
        );

        return {};
    }

    var data = {
        fromJID : message.getAttribute('from'),
        toJID : message.getAttribute('to'),
        x : this._getXParams(message),
        body : Strophe.getText(bodies[0]),
        xmlBody : bodies[0]
    };

    var type = message.getAttribute('type');

    if (type == XMPPChat.XMPP_MT_PRIVATE) {
        data.from = Strophe.getNodeFromJid(data.fromJID);

        if (data.x.command) {
            data.type = XMPPChat.MT_COMMAND;
        } else {
            data.type = XMPPChat.MT_PRIVATE;
        }
    } else if (type == XMPPChat.XMPP_MT_ROOM) {
        if (data.x.command) {
            data.type = XMPPChat.MT_COMMAND;
        } else {
            data.type = XMPPChat.MT_ROOM;
        }
        data.from = Strophe.getResourceFromJid(data.fromJID);
        data.roomId = Strophe.getNodeFromJid(data.fromJID);
    } else if (type == XMPPChat.XMPP_MT_ERROR) {
        data.type = XMPPChat.MT_ERROR;
        data.from = Strophe.getNodeFromJid(data.fromJID);

        var errors = message.getElementsByTagName('error');

        if (errors && errors.length > 0) {
            data.errorCode = errors[0].getAttribute('code');
        }
    }

    return data;
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Парсит станс "iq". Пока ничего не делает
 *
 *  Parameters:
 *    (XMLElement) message - станс.
 *
 *  Returns: {}
 */
XMPPChat.Connection.prototype._parseQuery = function(iq) {
    return {};
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Возвращает параметры тэга "x" станса.
 *
 *  Parameters:
 *    (XMLElement) stanza - станс.
 *
 *  Returns:
 *    Объект с параметрами тэга "x" станса.
 */
XMPPChat.Connection.prototype._getXParams = function(stanza) {
    var xs = stanza.getElementsByTagName('x');
    var x = {};

    if (xs && xs.length > 0) {
        for (var i = 0; i < xs[0].attributes.length; i++) {
            x[xs[0].attributes[i].name] = xs[0].getAttribute(
                xs[0].attributes[i].name
            );
        }
    }

    return x;
}


/*******************************************************************************
 *  Добавляет атрибуты к списку атрибутов.
 *
 *  Parameters:
 *    (Object) newAttrs - добавляемые атрибуты.
 *    (Object) attrs - существующие атрибуты.
 */
XMPPChat.Connection.prototype._addAttributes = function(newAttrs, attrs) {
    if (! newAttrs) {
        newAttrs = {};
    }

    if (! attrs) {
        attrs = {};
    }

    for (var name in newAttrs) {
        attrs[name] = newAttrs[name];
    }

    return attrs;
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Записывает сообщение в лог. На текущий момент логом является консоль браузера.
 *
 *  Parameters:
 *    (String) message - сообщение.
 */
XMPPChat.Connection.prototype._log = function(message) {
    if (this._isLog && console) {
        try {
            console.log(message);
        } catch (e) {
        }
    }
}


/*******************************************************************************
 *  Внутренняя функция.
 *  Запоминает пользовательские обработчики.
 *
 *  Parameters:
 *    (Object) handlers - объект с обработчиками.
 */
XMPPChat.Connection.prototype._storeHandlers = function(handlers) {
    this._onStatusChangeHandler = null;
    this._onConnectHandler = null;
    this._onDisconnectHandler = null;
    this._onPresenceHandler = null;
    this._onMessageHandler = null;
    this._onQueryHandler = null;

    if (handlers) {
        if (handlers.onStatusChange) {
            this._onStatusChangeHandler = handlers.onStatusChange;
        }

        if (handlers.onConnect) {
            this._onConnectHandler = handlers.onConnect;
        }

        if (handlers.onDisconnect) {
            this._onDisconnectHandler = handlers.onDisconnect;
        }

        if (handlers.onPresence) {
            this._onPresenceHandler = handlers.onPresence;
        }

        if (handlers.onMessage) {
            this._onMessageHandler = handlers.onMessage;
        }

        if (handlers.onQuery) {
            this._onQueryHandler = handlers.onQuery;
        }
    }
}
if (typeof(XMPPChat) == 'undefined') {
    XMPPChat = {};
}


XMPPChat.GameChat = function() {
    this.connection = new XMPPChat.Connection(
        $('#username').get(0).value,
        $('#pass').get(0).value,
        'Game',
        {
            onChangeStatus : this.onChangeStatus.bind(this),
            onConnect : this.onConnect.bind(this),
            onPresence : this.onPresence.bind(this),
            onMessage : this.onMessage.bind(this)
        }
    );
}


XMPPChat.GameChat.prototype.sendPresence = function(to) {
    this.connection.sendPresence(to);
}


XMPPChat.GameChat.prototype.sendRoomPresence = function(to) {
    this.connection.sendRoomPresence(to);
}


XMPPChat.GameChat.prototype.sendPrivateMessage = function(to, message) {
    this.connection.sendPrivateMessage(to, message);
}


XMPPChat.GameChat.prototype.sendMultiPrivateMessage = function(to, message) {
    this.connection.sendMultiPrivateMessage(to, message);
}


XMPPChat.GameChat.prototype.sendRoomMessage = function(to, message) {
    this.connection.sendRoomMessage(to, message);
}


XMPPChat.GameChat.prototype.onChangeStatus = function(status) {
}


XMPPChat.GameChat.prototype.onConnect = function(status) {
    this.sendPresence();
}


XMPPChat.GameChat.prototype.onPresence = function(data, presence) {
    if (data.from) {
        log('Stanza: ' + Strophe.serialize(presence));
        log('From: ' + data.from);
        log('roomId: ' + data.roomId);
    }
}


XMPPChat.GameChat.prototype.onMessage = function(data, message) {
    log('Stanza: ' + Strophe.serialize(message));
    log('From: ' + data.from);
    log('Message: ' + data.body);

    if (data.errorCode) {
        log('Error code: ' + data.errorCode);
    }
}
;(function() {

/**
 * Базовые оверрайды компонентов Ext'а
 */

// чтобы избежать кеширования AJAX POST запросов в iOS 6+
if (Ext.is.iOS) {
    Ext.override(Ext.Ajax, {
        setOptions: function() {
            var options = this.callParent(arguments);

            if (options.method === 'POST') {
                options.url = Ext.String.urlAppend(options.url, this.disableCachingParam + '=' + (new Date().getTime()));
            }

            return options;
        }
    });
}

/*
 * Добавляем возможность посставить AJAX запросы в очередь при наличии
 * соответствующего параметра *queue*
 */
// Ext.override(Ext.Ajax, {
//  queue: [],

//  request : function(options) {
//         options = options || {};
        
//         var me = this,
//             requestOptions, request;
        
//         if (me.fireEvent('beforerequest', me, options) !== false) {
//             requestOptions = me.setOptions(options, options.scope || Ext.global);
            
//             request = me.createRequest(options, requestOptions);
            
//          //  // override
//          if (options.operation && options.operation.queue) {
//              options.queue = true;
//          }

//          if (!options.queue) {
//              return request.start(requestOptions.data);
//          } else {
//              me.queue.push({
//                  request: request,
//                  data: requestOptions.data
//              });
//              if (!me.queue.length) {
//                  return request.start(requestOptions.data);
//              }
//          }
//          // end: override
//         }

//         Ext.callback(options.callback, options.scope, [options, undefined, undefined]);

//         return Ext.Deferred.rejected([options, undefined, undefined]);
//  }
// });

// function requestCallback(conn, response, options) {
//  var queue = conn.queue,
//      request, data;

//  if (options.queue) {
//      conn.queue.shift();

//      if (conn.queue.length) {
//          request = conn.queue[0].request;
//          data = conn.queue[0].data;
//          request.start(data);
//      }
//  }
// }

// Ext.Ajax.on({
//  requestcomplete: {
//      fn: requestCallback,
//      delay: 1
//  },

//  requestexception: {
//      fn: requestCallback,
//      delay: 1
//  }
// });


/**
 * Тултипы для радиокнопок
 */
if (!Ext.is.iOS && !Ext.is.Android) {
    Ext.override(Ext.form.field.Radio, {
        afterRender: function() {
            var me = this,
                tooltip = me.qtip || me.tooltip;

            me.callParent(arguments);

            if (tooltip) {
                if (Ext.isObject(tooltip)) {
                    Ext.tip.QuickTipManager.register(Ext.apply({
                        target: me.id
                    }, tooltip));
                }
                else {
                    me.el.dom.setAttribute('data-qtip', tooltip);
                }
            }
        }
    });
}

Ext.Date.getMonthNumber = function(name) {
    return Ext.Date.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
};

Ext.Date.getShortDayName = function(day) {
    return Ext.Date.dayNames[day].substring(0, 3);
};

// Ext.override(Ext.form.field.Date, {
//  disabledDaysText    : 'Не доступно',
//  disabledDatesText   : 'Не доступно',
//  minText             : 'Дата в этом поле должна быть позже {0}',
//  maxText             : 'Дата в этом поле должна быть раньше {0}',
//  invalidText         : '{0} не является правильной датой - дата должна быть указана в формате {1}',
//  format              : 'd.m.Y',
//  altFormats          : 'd.m.y|d/m/Y|d-m-y|d-m-Y|d/m|d-m|dm|dmy|dmY|d|Y-m-d',
//  startDay            : 1
// });

// Ext.override(Ext.form.field.Text, {
//  blankText: 'Это поле обязательно для заполнения',
//  minLengthText: 'Минимальная длина этого поля {0}',
//  maxLengthText: 'Максимальная длина этого поля {0}'
// });

// Ext.apply(Ext.form.field.VTypes, {
//  emailText: 'Это поле должно содержать адрес электронной почты в формате "user@example.com"'
// });

// Ext.override(Ext.picker.Date, {
//  todayText          : 'Сегодня',
//  minText            : 'Эта дата раньше минимальной даты',
//  maxText            : 'Эта дата позже максимальной даты',
//  disabledDaysText   : '',
//  disabledDatesText  : '',
//  monthNames         : Ext.Date.monthNames,
//  dayNames           : Ext.Date.dayNames,
//  nextText           : 'Следующий месяц (Control+Вправо)',
//  prevText           : 'Предыдущий месяц (Control+Влево)',
//  monthYearText      : 'Выбор месяца (Control+Вверх/Вниз для выбора года)',
//  todayTip           : '{0} (Пробел)',
//  format             : 'd.m.Y',
//  startDay           : 1
// });

// Ext.override(Ext.picker.Month, {
//  okText             : '&#160;OK&#160;',
//  cancelText         : 'Отмена'
// });

if (Ext.is.iOS) {
    Ext.override(Ext.form.field.TextArea, {
        afterRender: function() {
            var me = this;

            me.callParent(arguments);

            me.inputEl.on('click', function() {
                this.dom.focus();
            });
        }
    });
}

Ext.override(Ext.view.AbstractView, {
    loadingText: ''
});

Ext.data.Model.override({

    mixins: {
        observable: Ext.util.Observable
    },

    constructor: function(data, session) {

        // для совместимости с версией ExtJS 4.1.2
        this.raw = Ext.clone(data); 

        this.mixins.observable.constructor.call(this);
        this.callParent(arguments);
        this.join(this); // сама модель себя слушает (например, имеет обработчики типа afterEdit)
    },

    /**
     * Подгрузка сырых данных в существующую модель.
     * Метод использует стандартный ридер (reader) модели для считывания данных и метод set для обновления текущих данных
     */
    setRawData: function(data) {
        var me = this,
            reader = me.getProxy().reader,
            record;

        me.raw = Ext.clone(data);

        // удаляю все ключи, которых нет в новых данных
        Ext.Object.each(me.data, function(key) {
            if (me.data.hasOwnProperty(key) && !data[key]) {
                me.data[key] = undefined;
            }
        });

        record = reader.read(data).records[0];
        me.set(record.data);
    },

    privates: {
        isEqual: function(a, b) {
            var me = this;
            
            if (Ext.isDate(a) && Ext.isDate(b)) {
                return a.getTime() === b.getTime();
            }
            
            if (Ext.isArray(a) && Ext.isArray(b)) {
                if (a.length != b.length) {
                    return false;
                } else {
                    var count = a.length;
                    Ext.Array.each(a, function(item, index) {
                        if (me.isEqual(a[index], b[index])) {
                            count--;
                        } else {
                            return false;
                        }
                    });
                    
                    return count ? false : true;
                }
            }
            
            if (Ext.isObject(a) && Ext.isObject(b)) {
                if (Ext.getClassName(a) && Ext.getClassName(b)) {
                    return true;
                }
                if (Ext.Object.getSize(a) != Ext.Object.getSize(b)) {
                    return false;
                } else {
                    var count = Ext.Object.getSize(a);
                    Ext.Object.each(a, function(key, value) {
                        if (me.isEqual(a[key], b[key])) {
                            count--;
                        } else {
                            return false;
                        }
                    });
                    
                    return count ? false : true;
                }
            }
            
            return a === b;
        }
    },

});

Ext.data.field.Field.override({

    isEqual: function(a, b) {
        var me = this;
        
        if (Ext.isDate(a) && Ext.isDate(b)) {
            return a.getTime() === b.getTime();
        }
        
        if (Ext.isArray(a) && Ext.isArray(b)) {
            if (a.length != b.length) {
                return false;
            } else {
                var count = a.length;
                Ext.Array.each(a, function(item, index) {
                    if (me.isEqual(a[index], b[index])) {
                        count--;
                    } else {
                        return false;
                    }
                });
                
                return count ? false : true;
            }
        }
        
        if (Ext.isObject(a) && Ext.isObject(b)) {
            if (Ext.getClassName(a) && Ext.getClassName(b)) {
                return true;
            }
            if (Ext.Object.getSize(a) != Ext.Object.getSize(b)) {
                return false;
            } else {
                var count = Ext.Object.getSize(a);
                Ext.Object.each(a, function(key, value) {
                    if (me.isEqual(a[key], b[key])) {
                        count--;
                    } else {
                        return false;
                    }
                });
                
                return count ? false : true;
            }
        }
        
        return a === b;
    }

});

/*
 * BUG: suspentEvents not honoured in Ext.app.EventBus
 *
 * note: this fix does not queue events when asked.
 *
 * http://www.sencha.com/forum/showthread.php?171525
 */
Ext.override(Ext.app.EventBus, {
    constructor: function() {
        this.mixins.observable.constructor.call(this);
        this.bus = {};

        var me = this;

        Ext.override(Ext.Component, {
            fireEvent: function(ev) {
                if (Ext.util.Observable.prototype.fireEvent.apply(this, arguments) !== false) {
                    if (!this.eventsSuspended) {
                        return me.dispatch.call(me, ev, this, arguments);
                    } else {
                        return true;
                    }
                }
                return false;
            }
        });
    }
});

// Ext.override(Ext.app.Application, {

//  getController: function(name) {
//         var me          = this,
//             controllers = me.controllers,
//             className, controller, fullName;

//         controller = controllers.get(name);

//         if (!controller) {
//             className  = me.getModuleClassName(name, 'controller');
//             fullName = Ext.app.Controller.getFullName(name, 'controller', me.$namespace);

//             controller = Ext.create(className, {
//                 application: me,
//                 id:          fullName.shortName // id котнроллера всегда будет его короткое имя,
//                                              // например для контроллера "ClientAction@ExGodsCore.controller" id будет "ClientAction"
//             });

//             controllers.add(controller);

//             if (me._initialized) {
//                 controller.doInit(me);
//             }
//         }

//         return controller;
//     }
// });

/**
 * Добавил поддержку слоёв в компоненты
 * Логика такая - если указан слой компонента, то делаю его autoRender и при рендеринге (через doAutoRender) добавляю компонент на слой
 */
Ext.override(Ext.AbstractComponent, {
    initComponent: function() {
        if (this.layer) {
            if (typeof this.layer == 'string') {
                this.layer = ExGods.Layers.get(this.layer);
            }
            this.on('destroy', function(cmp) {
                delete cmp.layer;
            });
            this.autoRender = true;
            this.doAutoRender = function() {
                if (this.layer) {
                    this.layer.add(this);
                }
            };
        }
        this.callParent(arguments);
    }
});

/**
 * Позводяет хранить в локальном сторе данные любого типа, не только строки
 */
Ext.override(Ext.util.LocalStorage, {
    setItem: function() {
        arguments[1] = Ext.encode(arguments[1]);
        this.callOverridden(arguments);
    },
    getItem: function() {
        var value = this.callOverridden(arguments);
        return value ? Ext.decode(value) : '';
    }
});

})();/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}
// End: md5


/*!
* screenfull
* v1.0.2 - 2012-10-15
* https://github.com/sindresorhus/screenfull.js
* (c) Sindre Sorhus; MIT License
*/
(function(e,t){"use strict";var n=typeof Element!="undefined"&&"ALLOW_KEYBOARD_INPUT"in Element,r=function(){var e,n,r=[["requestFullscreen","exitFullscreen","fullscreenElement","fullscreenEnabled","fullscreenchange","fullscreenerror"],["webkitRequestFullscreen","webkitExitFullscreen","webkitFullscreenElement","webkitFullscreenEnabled","webkitfullscreenchange","webkitfullscreenerror"],["webkitRequestFullScreen","webkitCancelFullScreen","webkitCurrentFullScreenElement","","webkitfullscreenchange","webkitfullscreenerror"],["mozRequestFullScreen","mozCancelFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozfullscreenchange","mozfullscreenerror"]],i=0,s=r.length,o={};for(;i<s;i++){e=r[i];if(e&&e[1]in t){for(i=0,n=e.length;i<n;i++)o[r[0][i]]=e[i];return o}}return!1}(),i={request:function(e){var i=r.requestFullscreen;e=e||t.documentElement,/5\.1[\.\d]* Safari/.test(navigator.userAgent)?e[i]():e[i](n&&Element.ALLOW_KEYBOARD_INPUT)},exit:function(){t[r.exitFullscreen]()},toggle:function(e){this.isFullscreen?this.exit():this.request(e)},onchange:function(){},onerror:function(){}};if(!r)return e.screenfull=!1;Object.defineProperties(i,{isFullscreen:{get:function(){return!!t[r.fullscreenElement]}},element:{enumerable:!0,get:function(){return t[r.fullscreenElement]}},enabled:{enumerable:!0,get:function(){return t[r.fullscreenEnabled]}}}),t.addEventListener(r.fullscreenchange,function(e){i.onchange.call(i,e)}),t.addEventListener(r.fullscreenerror,function(e){i.onerror.call(i,e)}),e.screenfull=i})(window,document);


function getUID() {
    return hex_md5([(new Date()).getTime(), screen.width, screen.height].join('')).substr(16, 16);
}

function NoClickDelay(el) {
    this.element = typeof el == 'object' ? el : document.getElementById(el);
    //if ( window.Touch )
    if (this.element.addEventListener)
        this.element.addEventListener('touchstart', this, false);
}

NoClickDelay.prototype = {
    handleEvent: function(e) {
        var type = e.target.getAttribute('type');
        
        if (type == 'text')
            return;
        
        switch(e.type) {
            case 'touchstart': this.onTouchStart(e); break;
            case 'touchmove': this.onTouchMove(e); break;
            case 'touchend': this.onTouchEnd(e); break;
        }
    },

    onTouchStart: function(e) {
        e.preventDefault();
        this.moved = false;
        
        this.element.addEventListener('touchmove', this, false);
        this.element.addEventListener('touchend', this, false);
    },

    onTouchMove: function(e) {
        this.moved = true;
    },

    onTouchEnd: function(e) {
        this.element.removeEventListener('touchmove', this, false);
        this.element.removeEventListener('touchend', this, false);

        if ( !this.moved ) {
            // Place your code here or use the click simulation below
            var theTarget = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            if (theTarget.nodeType == 3) theTarget = theTarget.parentNode;
            
            var theEvent = document.createEvent('MouseEvents');
            theEvent.initEvent('click', true, true);
            theTarget.dispatchEvent(theEvent);
        }
    }
};

/**
 * Глобальные форматы дат
 */
var dateFormat = 'd.m.Y',
    timeFormat = 'H:i:s',
    dateTimeFormat = 'd.m.Y H:i:s',
    altDateFormats = '',
    serverDateFormat = 'Y-m-d',
    serverTimeFormat = 'H:i:s',
    serverDateTimeFormat = serverDateFormat + ' ' + serverTimeFormat;;(function() {

/*
 * Переопределяем ряд свойств и методов компонент Ext JS
 */
Ext.override(Ext.LoadMask, {
    floating: {
        shadow: false
    },
    msg: '',
    ui: 'hourglass'
});

// для темы оформления
Ext.override(Ext.AbstractComponent, {
    ui: 'exgods'
});

// для темы оформления
Ext.override(Ext.tip.Tip, {
    alwaysFramed: false,
    shadow: 'frame',
    showDelay: 3000
});

// чтобы не мешался
Ext.override(Ext.button.Button, {
    scale: ''
});

Ext.override(Ext.dom.Element, {
    mask: function(msg, msgCls) {
        var me = this,
            data = me.getData(),
            maskEl,
            maskMsg,
            startClass = msgCls;

        if (data.btn) {
            data.reloadBtn.destroy();
        }

        if (msg && msgCls != 'hourglass') {
            msgCls = 'x-mask-msg-reload';
        }

        this.callParent(arguments);

        maskEl = data.maskEl;
        maskMsg = Ext.get(maskEl.dom.firstChild);

        if (maskMsg.hasCls('x-mask-msg-reload') && startClass != 'local-mask') {
            data.reloadBtn = Ext.widget('button', {
                cls: 'h-46',
                handler: function() {
                    location.reload();
                },
                height: 46,
                icon: IMAGE_URL + 'loader-reload.png',
                renderTo: maskMsg,
                width: 46,
                ui: 'image'
            });
        }

        maskMsg.setDisplayed(false);

        setTimeout(function() {
            if (maskMsg && maskMsg.dom && me.dom) {
                maskMsg.setDisplayed(true);
                maskMsg.center(me);

                if (startClass == 'local-mask') {

                    if (msg) {
                        maskMsg.addCls('animating');
                    }

                    //через 1 анимацию проверяем:
                    // если уже можно удалять, то удаляем;
                    // если ещё не удалён, то можно удалять - 1 секунда анимации проигралась. (удаление произойдёт в методе unmask() )
                    setTimeout(function() {
                        if (maskMsg && maskMsg.dom && me.dom) {

                            if ( maskMsg.hasCls('removed') ) {
                                maskMsg.removeCls('animating');
                                me.unmask();
                            }
                            else {
                                maskMsg.removeCls('animating');
                            }
                        }
                    }, 1000);
                }
            }
        }, 500);

        return maskEl;
    },

    unmask: function() {
        var maskEl = this.getData().maskEl,
            maskMsg = maskEl ? Ext.get(maskEl.dom.firstChild) : '';
        // если ещё анимируется, то можно удалять. (удаление произойдёт в методе block() после анимации );
        // если уже не анимируется, то удаляем.
        if (maskMsg && maskMsg.dom) {
            if ( maskMsg.hasCls('animating') ) {
                maskMsg.addCls('removed');
            }
            else {
                this.callParent(arguments);
            }
        }
    }
});

// меняем свойства тени
Ext.override(Ext.Shadow, {
    offset: 6
});

Ext.override(Ext.view.AbstractView, {
    loadingText: ''
});

// убираю подсветку контейнера после восстановления
Ext.override(Ext.dd.DragSource, {
    
    repairHighlightColor: false,

    afterRepair: function() {
        var me = this;
        if (Ext.enableFx && me.repairHighlightColor) {
            me.el.highlight(me.repairHighlightColor);
        }
        me.dragging = false;
    }

});

// добавляю метод подгрузки ресурсов для компонент
Ext.override(Ext.tab.Panel, {
    getResources: function() {
        var me = this,
            images = [];
        if (me.tabBar && me.tabBar.items) {
            me.tabBar.items.each(function(item) {
                if (item.icon) {
                    images.push(item.icon);
                }
            });
        }
        return {
            images: images,
        }
    },
});



/// Исключение для вьюшки пояса, на которую прокручивает экст при различных манипуляциях
//  с ним, от покупки слота, до переносе вещей
//
Ext.Component.override({
    onHide: function(animateTarget, cb, scope) {
        var me = this,
            ghostPanel, fromSize, toBox;
        
        if (me.previousFocus && me.previousFocus.ignore_focus){
            me.previousFocus = null;
        }
        
        me.revertFocus();
        
        animateTarget = me.getAnimateTarget(animateTarget);
        
        if (!me.ghost) {
            animateTarget = null;
        }
        
        if (animateTarget) {
            toBox = {
                x: animateTarget.getX(),
                y: animateTarget.getY(),
                width: animateTarget.dom.offsetWidth,
                height: animateTarget.dom.offsetHeight
            };
            ghostPanel = me.ghost();
            ghostPanel.el.stopAnimation();
            fromSize = me.getSize();
            ghostPanel.el.animate({
                to: toBox,
                listeners: {
                    afteranimate: function() {
                        delete ghostPanel.componentLayout.lastComponentSize;
                        ghostPanel.el.hide();
                        ghostPanel.setHiddenState(true);
                        ghostPanel.el.setSize(fromSize);
                        me.afterHide(cb, scope);
                    }
                }
            });
        }
        me.el.hide();
        if (!animateTarget) {
            me.afterHide(cb, scope);
        }
    }
});

})();/**
 * Mixin, который позволяет писать в лог приложения
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGodsCore.util.Loggable', {
    logConfig: {
        enabled: {
            info: true,
            error: true,
            warn: true
        },
        prefix: ''
    },
    /**
     * Пишет в лог приложения.
     * Первым параметром может идти как само сообщение, так и его уровень (info, error, warn). Если уровень не указан - сообщение печатается с уровнем info
     */
    log: function() {
        var args = Ext.Array.from(arguments),
            level, msg;
        // определяю уровень сообщения
        if (args[0] == 'error' || args[0] == 'warn' || args[0] == 'info') {
            level = args.shift();
            msg = args;
        } else if (typeof this.logConfig.enabled == 'object' && this.logConfig.enabled[args[0]]) {
            // поддержка для кастомных типов
            level = args.shift();
            msg = args;
        } else {
            level = "info";
            msg = args;
        }
        // проверяю, разрешен ли лог с таким уровнем
        if (this.logConfig.enabled === true || (typeof this.logConfig.enabled == 'object' && (this.logConfig.enabled[level]))) {
            // добавляю префикс
            if (this.logConfig.prefix) {
                msg.unshift(this.logConfig.prefix);
            }
            // печатаю, если доступна консоль
            if (typeof window.console == 'object') {
                if (typeof window.console[level] == 'function') {
                    console[level].apply(console, msg);
                } else if (typeof console.log == 'function') {
                    console.log.apply(console, msg);
                }
            }
        }
    },
    /**
     * Заменяет метод объекта методом, который будет записывать в лог параметры вызова и вызывать оригинальный метод
     * @param {String} method Название метода объекта
     */
    logMethod: function(method) {
        var me = this,
            origFn = this[method];
        if (typeof origFn == 'function') {
            this[method] = Ext.Function.createInterceptor(origFn, function() {
                me.log('вызов метода', method, 'с параметрами', arguments);
                return true;
            }, me);
        }
    }
});

/**
 * Базовый класс Имущество
 */
Ext.define('ExGods.stuff.Stuff', {
    extend: Ext.util.Observable,
    /**
     * @cfg stuff {Object} Объект имущества в формате имущества ({type: <String>, params: <Object>})
     */
    stuff: {},
    /**
     * @cfg tooltip {Boolean} Показывать тултип при наведении или нет
     */
    tooltip: true,
    /**
     * @property dblclickAction {String} Название действия для двойного клика
     */
    dblclickAction: '',
    /**
     * @property printTpl {Mixed} Шаблон печати имущества
     */
    printTpl: [
        '<span id="{id}" class="{[ this.getCls(values) ]}" style="{[ this.getStyle(values) ]}" {[ this.getAttributes(values) ]}>',
        '{text}',
        '</span>',
        {
            getCls: function(values) {
                var cls = 'exg-stuff-item exg-stuff-printed';
                cls += ' exg-stuff-item-' + values.stuff.type;
                if (values.tooltip) {
                    cls += ' exgtip';
                }
                return cls;
            },
            getStyle: function(values) {
                var style = '',
                    img;
                if (values.img) {
                    if (/^http/.test(values.img)) {
                        img = values.img;
                    } else {
                        img = IMAGE_URL + values.img;
                    }
                    style += 'background-image:url(' + img + ')';
                }
                return style;
            },
            getAttributes: function(values) {
                var attrs = [];
                if (values.tooltip) {
                    attrs.push('data-exgtip_type="stuff"');
                    attrs.push('data-exgtip_value="' + values.id + '"');
                }
                return attrs.join(' ');
            }
        }
    ],
    /**
     * @property imageTpl {Mixed} Шаблон печати имущества в виде картинки
     */
    imageTpl: [
        '<div id="{id}" class="{[ this.getCls(values) ]}" {[ this.getAttributes(values) ]} >',
        '{[ this.decorate("before", values) ]}',
        '<div class="exg-stuff-img" style="background-image:url({[ /^http/.test(values.img) ? values.img : IMAGE_URL + values.img ]})"></div>',
        '{[ this.decorate("after", values) ]}',
        '</div>',
        {
            getCls: function(values) {
                var cls = [];
                cls.push('exg-stuff-item');
                cls.push('exg-stuff-imaged');
                cls.push('exg-stuff-item-' + values.stuff.type);
                if (values.tooltip) {
                    cls.push('exgtip');
                }
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator) {
                        var decoCls = decorator.getCls(values);
                        if (decoCls) {
                            cls.push(decoCls);
                        }
                    });
                }
                return cls.join(' ');
            },
            getAttributes: function(values) {
                var attrs = [];
                if (values.tooltip) {
                    attrs.push('data-exgtip_type="stuff"');
                    attrs.push('data-exgtip_value="' + values.id + '"');
                }
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator) {
                        var decoAttributes = decorator.getAttributes(values);
                        if (decoAttributes) {
                            attrs.push(decoAttributes);
                        }
                    });
                }
                return attrs.join(' ');
            },
            decorate: function(afterOrBefore, values) {
                var html = [];
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator, index) {
                        try {
                            if (afterOrBefore == 'after' && decorator.decorateAfter) {
                                html.push(decorator.decorateAfter(values));
                            } else if (decorator.decorateBefore) {
                                html.push(decorator.decorateBefore(values));
                            }
                        } catch (e) {
                            /***/
                            ExGods.stuff.StuffManager.log('error', '@decorate ошибка декоратора', values, index, e);
                        }
                    });
                }
                return html.join('');
            }
        }
    ],
    /**
     * @property detailsTpl {Mixed} Шаблон окна информации
     */
    detailsTpl: [
        '<div id="{id}" class="exg-stuff-item exg-stuff-item-{stuff.type} exg-stuff-details">',
        '<div class="header">',
        '<div style="display: table;">',
        '<div class="image {[ this.getDecoratorCls(values) ]}">',
        '{[ this.decorate("before", values) ]}',
        '<img src="{[ /^http/.test(values.img) ? values.img : IMAGE_URL + values.img ]}"/>',
        '{[ this.decorate("after", values) ]}',
        '</div>',
        '<span class="title {[ this.getTitleCls(values) ]}">{title}</span>',
        '</div>',
        '</div>',
        '<div class="details">',
        '<tpl if="description">',
        '<div class="exg-stuff-block-separator"></div>',
        '<div class="description">',
        '{[ ExGods.app.applyTpl(values.description) ]}',
        '</div>',
        '</tpl>',
        '{[ this.printBlocks(values) ]}',
        '<tpl if="values.buttons && values.buttons.length && (values.description || (values.blocks && values.blocks.length))">',
        '<div class="exg-stuff-block-separator"></div>',
        '</tpl>',
        '</div>',
        '</div>',
        {
            getDecoratorCls: function(values) {
                var cls = [];
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator) {
                        var decoCls = decorator.getCls ? decorator.getCls(values) : '';
                        if (decoCls) {
                            cls.push(decoCls);
                        }
                    });
                }
                return cls.join(' ');
            },
            decorate: function(afterOrBefore, values) {
                var html = [];
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator, index) {
                        try {
                            if (afterOrBefore == 'after' && decorator.decorateAfter) {
                                html.push(decorator.decorateAfter(values));
                            } else if (decorator.decorateBefore) {
                                html.push(decorator.decorateBefore(values));
                            }
                        } catch (e) {
                            /***/
                            ExGods.stuff.StuffManager.log('error', '@decorate ошибка декоратора', values, index, e);
                        }
                    });
                }
                return html.join('');
            },
            printBlocks: function(values) {
                var html = [];
                if (values.blocks && values.blocks.length) {
                    values.blocks.forEach(function(block, index) {
                        try {
                            var title = block.getTitle ? block.getTitle(values) : '',
                                content = block.getContent ? block.getContent(values) : '',
                                cls = "exg-stuff-block " + (block.getCls && block.getCls(values) ? block.getCls(values) : ''),
                                blockHtml;
                            if (content) {
                                blockHtml = '<div class="' + cls + '">';
                                if (title) {
                                    blockHtml += '<div class="exg-stuff-block-title">' + title + '</div>';
                                }
                                if (content) {
                                    if (Ext.isArray(content)) {
                                        blockHtml += '<table class="exg-stuff-block-content">';
                                        content.forEach(function(row) {
                                            blockHtml += '<tr>';
                                            if (Ext.isArray(row)) {
                                                row.forEach(function(cell) {
                                                    blockHtml += '<td>' + cell + '</td>';
                                                });
                                            } else {
                                                blockHtml += '<td>' + row + '</td>';
                                            }
                                            blockHtml += '</tr>';
                                        });
                                        blockHtml += '</table>';
                                    } else {
                                        blockHtml += '<div class="exg-stuff-block-content">' + content + '</div>';
                                    }
                                }
                                blockHtml += '</div>';
                                html.push(blockHtml);
                            }
                        } catch (e) {
                            /***/
                            ExGods.stuff.StuffManager.log('error', '@printBlocks ошибка при печати блока', values, index, e);
                        }
                    });
                }
                if (html.length) {
                    return '<div class="exg-stuff-block-separator"></div>' + html.join('<div class="exg-stuff-block-separator"></div>');
                } else {
                    return '';
                }
            },
            // TODO переделать надо это 
            getTitleCls: function(values) {
                var cls = [];
                if (values.protoModel) {
                    cls.push('item-grade-color-' + (values.protoModel.data.data.item_grade || 1));
                }
                return cls.join(' ');
            }
        }
    ],
    constructor: function(config) {
        var me = this;
        me.id = Ext.id();
        me.callParent(arguments);
    },
    /**
     * Напечатает имущество в виде строки
     * @return {String}
     */
    print: function() {
        var me = this;
        if (!me.compiledPrintTpl) {
            me.compiledPrintTpl = new Ext.XTemplate(me.printTpl);
        }
        return me.compiledPrintTpl.apply(me.getPrintData());
    },
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this;
        return {
            id: me.id,
            img: '',
            text: me.stuff.type + ' x ' + (me.stuff.params.quantity ? me.stuff.params.quantity : ''),
            tooltip: me.tooltip,
            stuff: me.stuff
        };
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        var me = this;
        return me.tooltip;
    },
    getDblClickAction: function() {
        var me = this;
        return me.dblclickAction;
    },
    /**
     * Напечатать имущество в виде картинки
     * @return {String}
     */
    image: function() {
        var me = this;
        if (!me.compiledImageTpl) {
            me.compiledImageTpl = new Ext.XTemplate(me.imageTpl);
        }
        return me.compiledImageTpl.apply(me.getImageData());
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this;
        return {
            id: me.id,
            img: '',
            tooltip: me.tooltip,
            stuff: me.stuff,
            decorators: []
        };
    },
    /**
     * Вернет черно-белую картинку
     */
    getDisabledImage: function() {
        return '';
    },
    /**
     * Показать окно информации об имуществе
     * @param config
     *      clickedEl {Ext.dom.Element} DOM элемент имущества, по которому кликнули. Не обязательный параметр
            targetEl {Ext.dom.Element} DOM элемент в который нужно отрисовать окно информации
            asHTML {Boolean} true, если нужно просто вернуть html строку информации
            tooltip {Boolean} true, если информация показывается в режиме тултипа
     */
    details: function(config) {
        var me = this,
            data = me.getDetailsData(),
            win;
        if (!me.compiledDetailsTpl) {
            me.compiledDetailsTpl = new Ext.XTemplate(me.detailsTpl);
        }
        if (config.tooltip && data.buttons && data.buttons.length) {
            data.buttons = [
                {
                    xtype: 'component',
                    style: {
                        'text-align': 'center'
                    },
                    html: ExGods.getMsgByKey('tooltip_text')
                }
            ];
        }
        if (config.targetEl) {
            Ext.widget('component', {
                tpl: me.compiledDetailsTpl,
                data: data,
                renderTo: config.targetEl
            });
        } else if (config.asHTML) {
            return me.compiledDetailsTpl.apply(data);
        } else {
            win = Ext.widget('parchmentwindow', {
                padding: '4 4 10 4',
                tpl: me.compiledDetailsTpl,
                data: data,
                closable: config.tooltip ? false : true,
                cascade: false,
                //config.tooltip ? false : true,
                itemElement: config.clickedEl,
                dockedItems: [
                    {
                        xtype: 'toolbar',
                        layout: 'anchor',
                        hidden: !data.buttons || !data.buttons.length,
                        defaults: {
                            anchor: '100%',
                            margin: '2 0',
                            cls: 'no_border',
                            handler: function(btn) {
                                me.fireEvent('action', me, btn.action, btn, win);
                            }
                        },
                        defaultType: 'textbutton',
                        dock: 'bottom',
                        itemId: 'actions',
                        margin: '5 0 10 0',
                        padding: '0 8 0 8',
                        items: data.buttons
                    }
                ]
            });
            return win;
        }
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this;
        return {
            id: me.id,
            img: '',
            title: '',
            description: '',
            decorators: [],
            blocks: [],
            buttons: [],
            stuff: me.stuff
        };
    }
});

/**
 * Массив имуществ
 */
Ext.define('ExGods.stuff.StuffCollection', {
    extend: ExGods.stuff.Stuff,
    /**
     * @cfg stuff {Array} Массив имуществ
     */
    stuff: [],
    /**
     * @cfg sorted {Boolean} Флаг, сортировать ли стафф
     */
    sorted: true,
    /**
     * @cfg printTpl {Mixed} Шаблон печати имущества
     */
    printTpl: [
        '<ul class="exg-stuff-collection exg-stuff-printed">',
        '<tpl for="stuff">',
        '<li>{[ ExGods.stuff.StuffManager.print(values) ]}</li>',
        '</tpl>',
        '</ul>'
    ],
    imageTpl: [
        '<ul class="exg-stuff-collection exg-stuff-imaged">',
        '<tpl for="stuff">',
        '<li>{[ ExGods.stuff.StuffManager.image(values) ]}</li>',
        '</tpl>',
        '</ul>'
    ],
    detailsTpl: [
        '<ul class="exg-stuff-collection exg-stuff-details">',
        '<tpl for="stuff">',
        '<li>',
        '{[ ExGods.stuff.StuffManager.details(values) ]}',
        '<div class="info-icon"></div>',
        '<div class="exg-stuff-block-separator"></div>',
        '</li>',
        '</tpl>',
        '</ul>'
    ],
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        if (me.sorted) {
            me.stuff = me.sortStuff(me.stuff);
        }
    },
    sortStuff: function(stuff) {
        return Ext.Array.sort(stuff, function(a, b) {
            if (a.type == b.type)  {
                return 0;
            }
            
            if (a.type == 'item')  {
                return 1;
            }
            
            if (b.type == 'item')  {
                return -1;
            }
            
            if (a.type == 'trophy')  {
                return -1;
            }
            
            if (b.type == 'trophy')  {
                return 1;
            }
            
            if (a.type == 'expa')  {
                return -1;
            }
            
            if (b.type == 'expa')  {
                return 1;
            }
            
            if (a.type == 'valour')  {
                return -1;
            }
            
            if (b.type == 'valour')  {
                return 1;
            }
            
            if (a.type == 'currency')  {
                return -1;
            }
            
            if (b.type == 'currency')  {
                return 1;
            }
            
            if (a.type == 'ability')  {
                return -1;
            }
            
            if (b.type == 'ability')  {
                return 1;
            }
            
            if (a.type == 'feature')  {
                return -1;
            }
            
            if (b.type == 'feature')  {
                return 1;
            }
            
            if (a.type == 'timed')  {
                return -1;
            }
            
            if (b.type == 'timed')  {
                return 1;
            }
            
            return 1;
        });
    },
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this;
        return {
            stuff: me.stuff
        };
    },
    /**
     * Вернет заголовки имуществ через запятую
     */
    getTitle: function() {
        return Ext.Array.map(me.stuff, function(el) {
            return ExGods.stuff.StuffManager.title(el);
        });
    }
});

/**
 * Базовый класс композитного имущества.
 * Композитное имущество - это обертка над другими видами имущества. Композитное имущество создает экземпляр объекта
 * имущества конкретного типа и все вызовы делегирует этому объекту.
 *
 * Note: Формат данных композитного имущества должно быть в таком виде:

        stuff: {
            params: {
                stuff: <Object> // Данные в формате имущества
            }
        }

 * 
 */
Ext.define('ExGods.stuff.Composite', {
    extend: ExGods.stuff.Stuff,
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        // быстрая ссылка до данных обернутого имущества
        me.wrappedStuff = me.stuff.params.stuff;
        // объект обернутого имущества
        me.obj = ExGods.stuff.StuffManager.factory(me.wrappedStuff, true);
        // подменяю id композита на id объекта имущества, тем самым StuffManager будет обращаться
        // к объекту композита при клике на dom-элемент объекта имущества
        me.id = me.obj.id;
        // пробрасываю события объекта имущества как события композита
        me.relayEvents(me.obj, 'action');
    },
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this;
        return me.obj.getPrintData();
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this;
        return me.obj.getImageData();
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this;
        return me.obj.getDetailsData();
    },
    /**
     * Проверяет, содержит ли композит имущество с типом <typeName>
     */
    hasType: function(typeName) {
        var me = this,
            checkType = function(stuff, type) {
                if (stuff.type == type) {
                    return true;
                } else if (stuff.params.stuff) {
                    return checkType(stuff.params.stuff);
                } else {
                    return false;
                }
            };
        return checkType(me.stuff, typeName);
    }
});

/**
 * Базовый класс блока.
 */
Ext.define('ExGods.stuff.Block', {
    inheritableStatics: {
        /**
         * Класс, который будет добавлен к верхнему элементу блока
         */
        getCls: function(data) {},
        //
        /**
         * Вернет заголовок блока, если нужно
         */
        getTitle: function(data) {},
        //
        /**
         * Вернет содержимое блока
         * @return {Mixed} Строка или массив. Массив будет преобразован в html-таблицу. Каждый элемент массива - это строка таблицы.
         *
         * Пример для контента в виде таблицы можно посмотреть в ExGods.stuff.block.item.Stats1
         */
        getContent: function(data) {}
    }
});
//              

/**
 * Базовый класс декоратора.
 */
Ext.define('ExGods.stuff.Decorator', {
    inheritableStatics: {
        getCls: function(data) {},
        //
        getAttributes: function(data) {},
        //
        decorateBefore: function(data) {},
        //
        decorateAfter: function(data) {}
    }
});
//

/**
 * Класс имущества "Опыт"

    Формат имущества:

        type: "expa"
        params:
            quantity: 12            
        

 */
Ext.define('ExGods.stuff.stuff.Expa', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            text: me.stuff.params.quantity,
            tooltip: me.getTitle(),
            img: ExGods.ref('images|user_stuff_icons').image.exp
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        return ExGods.getMsgByKey('stuff_tooltip_experience');
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            tooltip: ExGods.getMsgByKey('stuff_tooltip_experience'),
            img: ExGods.ref('user_hoard|expa').image_big,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            img: ExGods.ref('user_hoard|expa').image_big,
            title: ExGods.ref('user_hoard|expa').label,
            description: ExGods.getMsgByKey('currency_description_expa'),
            decorators: [],
            //
            blocks: []
        });
    },
    //
    /**
     * Вернет черно-белую картинку
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('user_hoard|expa');
        return refData.image_disabled;
    }
});

/**
 * Класс имущества "Трофеи"

    Формат имущества:

        type: "trophy"
        params:
            quantity: 12            
        

 */
Ext.define('ExGods.stuff.stuff.Trophy', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            text: me.stuff.params.quantity,
            tooltip: me.getTitle(),
            img: ExGods.ref('images|user_stuff_icons').image.valour
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        return ExGods.getMsgByKey('stuff_tooltip_trophy');
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            tooltip: ExGods.getMsgByKey('stuff_tooltip_trophy'),
            img: ExGods.ref('user_hoard|trophy').image_big,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            img: ExGods.ref('user_hoard|trophy').image_big,
            title: ExGods.ref('user_hoard|trophy').label,
            description: ExGods.getMsgByKey('currency_description_trophy'),
            decorators: [],
            //
            blocks: []
        });
    },
    //
    /**
     * Вернет черно-белую картинку
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('user_hoard|trophy');
        return refData.image_disabled;
    }
});

/**
 * Класс имущества "Валюта"

    Формат имущества:

        type: "currency"
        params:
            id: "gold",
            quantity: 12            
        

 */
Ext.define('ExGods.stuff.stuff.Currency', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_money|' + me.stuff.params.id);
        return Ext.apply(data, {
            text: Ext.util.Format.number(me.stuff.params.quantity, "0,0"),
            tooltip: me.getTitle(),
            img: refData.image
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        var me = this;
        return ExGods.ref('user_money|' + me.stuff.params.id).label;
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_money|' + me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: refData.label,
            img: refData.image_big,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_money|' + me.stuff.params.id);
        return Ext.apply(data, {
            img: refData.image_big,
            title: refData.label,
            description: ExGods.getMsgByKey('currency_description_' + me.stuff.params.id),
            decorators: [],
            //
            blocks: []
        });
    },
    //
    /**
     * Вернет черно-белую картинку
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('user_money|' + me.stuff.params.id);
        return refData.image_disabled;
    }
});

/**
 * Класс имущества "Восстанавливаемая характеристика"

    Формат имущества:

        type: "timed"
        params:
            id: "gold_chest_tries",
            quantity: 1
        

 */
Ext.define('ExGods.stuff.stuff.Timed', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_timed|' + me.stuff.params.id);
        return Ext.apply(data, {
            text: Ext.util.Format.number(me.stuff.params.quantity, "0,0"),
            tooltip: me.getTitle(),
            img: refData.img.img2
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        var me = this;
        return ExGods.ref('user_timed|' + me.stuff.params.id).img.label;
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_timed|' + me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: refData.img.label,
            img: refData.img.stuff,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_timed|' + me.stuff.params.id);
        return Ext.apply(data, {
            img: refData.img.stuff,
            title: refData.img.label,
            description: refData.img.desc,
            decorators: [],
            //
            blocks: []
        });
    }
});
//

/**
 * Класс имущества "Предмет"
 *

    Формат имущества:

        type: "item"
        params: 
            grade: 3
            id: "1894"
            quantity: 1
            slot_type: 0
            title: "Тотем Фурфура"

 */
Ext.define('ExGods.stuff.stuff.Item', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            text: me.getTitle() + (me.stuff.params.quantity > 1 ? '&nbsp;(' + me.stuff.params.quantity + ')' : ''),
            tooltip: ExGods.getMsgByKey('stuff_tooltip_item'),
            img: ExGods.ref('images|user_stuff_icons').image.item
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        var me = this;
        return [
            '<span class="title item-grade-color-' + (me.stuff.params.grade || 1) + '">',
            me.stuff.params.title,
            '</span>'
        ].join('');
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.app.getItemPrototypesStore().getById(parseInt(me.stuff.params.id));
        return Ext.apply(data, {
            tooltip: proto.data.title,
            img: proto.data.images.info,
            protoModel: proto,
            decorators: [
                ExGods.stuff.decorator.Quantity,
                ExGods.stuff.decorator.ItemGrade
            ]
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.app.getItemPrototypesStore().getById(parseInt(me.stuff.params.id));
        return Ext.apply(data, {
            img: proto.data.images.info,
            title: proto.data.title,
            protoModel: proto,
            decorators: [
                ExGods.stuff.decorator.ItemGrade
            ],
            blocks: [
                ExGods.stuff.block.item.Stats1,
                ExGods.stuff.block.item.ExpireAfter,
                ExGods.stuff.block.item.Stats2,
                ExGods.stuff.block.item.Description,
                ExGods.stuff.block.item.ProtoFeatures
            ]
        });
    },
    /**
     * Вернет черно-белую картинку
     */
    getDisabledImage: function() {
        var me = this,
            proto = ExGods.app.getItemPrototypesStore().getById(parseInt(me.stuff.params.id));
        return proto.get('images').disabled;
    }
});

/**
 * Класс имущества "Набор предметов"

    Формат имущества:

        type: "kit"
        params: 
            id: "1"
            quantity: 12

 */
Ext.define('ExGods.stuff.stuff.Kit', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return Ext.apply(data, {
            text: me.getTitle() + (me.stuff.params.quantity > 1 ? '&nbsp;(' + me.stuff.params.quantity + ')' : ''),
            tooltip: proto.label,
            img: ExGods.ref('images|user_stuff_icons').image.item
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        var me = this,
            proto = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return '<span class="title">' + proto.label + '</span>';
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: proto.label,
            img: proto.params.image,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return Ext.apply(data, {
            img: proto.params.image,
            title: proto.label,
            //description: proto.params.description,
            decorators: []
        });
    },
    //
    /**
     * Вернет черно-белую картинку
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return refData.params.image;
    }
});

/**
 * Класс имущества "Экземпляр предмета"
 *

    Формат имущества:

        type: "iteminstance"
        params: 
            itemModel: <Object>

 */
Ext.define('ExGods.stuff.stuff.ItemInstance', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = me.stuff.params.itemModel.getProto(),
            quantity = me.stuff.params.itemModel.data.count;
        return Ext.apply(data, {
            text: me.getTitle() + (quantity > 1 ? '&nbsp;(' + quantity + ')' : ''),
            tooltip: ExGods.getMsgByKey('stuff_tooltip_item'),
            img: ExGods.ref('images|user_stuff_icons').image.item
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        var me = this,
            proto = me.stuff.params.itemModel.getProto();
        return [
            '<span class="title item-grade-color-' + (proto.data.data.item_grade || 1) + '">',
            proto.data.title,
            '</span>'
        ].join('');
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = me.stuff.params.itemModel.getProto();
        return Ext.apply(data, {
            tooltip: proto.data.title,
            img: proto.data.images.info,
            protoModel: proto,
            itemModel: me.stuff.params.itemModel,
            decorators: [
                ExGods.stuff.decorator.ItemGrade
            ]
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = me.stuff.params.itemModel.getProto();
        return Ext.apply(data, {
            img: proto.data.images.info,
            title: proto.data.title,
            protoModel: proto,
            itemModel: me.stuff.params.itemModel,
            decorators: [
                ExGods.stuff.decorator.ItemGrade
            ],
            blocks: [
                ExGods.stuff.block.item.Stats1,
                ExGods.stuff.block.item.ExpireTimer,
                ExGods.stuff.block.item.Stats2,
                ExGods.stuff.block.item.Description,
                ExGods.stuff.block.item.ProtoFeatures,
                ExGods.stuff.block.item.Features
            ]
        });
    }
});

/**
 * Класс имущества "Ингредиент"

    Формат имущества:

        type: "ingredients"
        params: 
            id: "ore_1"
            quantity: 12

 */
Ext.define('ExGods.stuff.stuff.Ingredient', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('ingredients|' + me.stuff.params.id);
        return Ext.apply(data, {
            text: me.getTitle() + (me.stuff.params.quantity > 1 ? '&nbsp;(' + me.stuff.params.quantity + ')' : ''),
            tooltip: proto.label,
            img: ExGods.ref('images|user_stuff_icons').image.item
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        var me = this,
            proto = ExGods.ref('ingredients|' + me.stuff.params.id);
        return '<span class="title">' + proto.label + '</span>';
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('ingredients|' + me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: proto.label,
            img: proto.params.images.img_1,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('ingredients|' + me.stuff.params.id);
        return Ext.apply(data, {
            img: proto.params.images.img_1,
            title: proto.label,
            description: proto.params.description,
            decorators: []
        });
    },
    //
    /**
     * Вернет черно-белую картинку
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('ingredients|' + me.stuff.params.id);
        return refData.params.images.img_2;
    }
});

/**
 * Класс имущества "Фича"
 *

    Формат имущества:

        type: "feature"
        params: 
            grade: 3
            id: "1894"
            quantity: 1
            slot_type: 0
            title: "Тотем Фурфура"

 */
Ext.define('ExGods.stuff.stuff.Feature', {
    extend: ExGods.stuff.Stuff,
    /**
     * Вернёт данные для шаблона печати.
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            text: me.getTitle(),
            tooltip: ExGods.getMsgByKey('stuff_tooltip_item'),
            img: ExGods.ref('images|user_stuff_icons').image.buff
        });
    },
    /**
     * Вернёт заголовок имущества
     */
    getTitle: function() {
        var me = this;
        return [
            '<span class="title item-grade-color-' + (me.stuff.params.grade || 1) + '">',
            me.stuff.params.title,
            '</span>'
        ].join('');
    },
    /**
     * Вернёт данные для шаблона печати картинки.
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.app.getFeaturePrototypesStore().getById(me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: proto.data.label,
            img: proto.data.images.main
        });
    },
    /**
     * Вернет данные для шаблона окна информации
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.app.getFeaturePrototypesStore().getById(me.stuff.params.id);
        return Ext.apply(data, {
            img: proto.data.images.main,
            title: proto.data.label,
            description: proto.data.description,
            decorators: [],
            // 
            blocks: []
        });
    },
    //
    /**
     * Вернет черно-белую картинку
     */
    getDisabledImage: function() {
        var me = this,
            proto = ExGods.app.getFeaturePrototypesStore().getById(me.stuff.params.id);
        return proto.get('images').main;
    }
});

/**
 * Декоратор "Недоступно"
 */
Ext.define('ExGods.stuff.decorator.Disabled', {
    extend: ExGods.stuff.Decorator,
    statics: {
        /**
         * @override
         */
        getCls: function(data) {
            return 'exg-stuff-decorator-disabled';
        }
    }
});

/**
 * Декоратор "Бонус"
 */
Ext.define('ExGods.stuff.decorator.BonusStick', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="exg-stuff-decorator-bonusstick exg-stuff-decorator-bonusstick-image"></div>';
        }
    }
});

/**
 * Декоратор "Акция"
 */
Ext.define('ExGods.stuff.decorator.SaleStick', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="exg-stuff-decorator-salestick exg-stuff-decorator-salestick-image"></div>';
        }
    }
});

/**
 * Декоратор "Лучшее"
 */
Ext.define('ExGods.stuff.decorator.BestStick', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="exg-stuff-decorator-beststick exg-stuff-decorator-beststick-image"></div>';
        }
    }
});

/**
 * Декоратор "Количество"
 */
Ext.define('ExGods.stuff.decorator.Quantity', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var quantity = this.getQuantity(data);
            if (quantity) {
                return '<div class="exg-stuff-decorator-quantity-counter"><span>' + quantity + '</span></div>';
            }
        },
        /**
         * Возвращает кол-во счетчика. Если счетчик показывать не надо - вернуть false
         */
        getQuantity: function(data) {
            var quantity = data.stuff.params.quantity;
            if (quantity) {
                if (quantity == 1 && (data.stuff.type == 'item' || data.stuff.type == 'iteminstance')) {
                    return false;
                } else {
                    return quantity;
                }
            }
        }
    }
});

/**
 * Декоратор "Уровень прокачки предмета"
 */
Ext.define('ExGods.stuff.decorator.ItemGrade', {
    extend: ExGods.stuff.Decorator,
    inheritableStatics: {
        decorateAfter: function(data) {
            var html = '',
                grade = this.getGrade(data);
            if (grade) {
                html += '<div class="exg-stuff-decorator-itemgrade" style="width:' + (14 * grade) + 'px;"></div>';
            }
            return html;
        },
        /**
         * Возвращает уровень грейда предмета.
         */
        getGrade: function(data) {
            if (data.itemModel && data.itemModel.isUpgraded()) {
                return data.itemModel.get('param').upgrades;
            } else {
                var proto = ExGods.app.getItemPrototypesStore().getById(parseInt(data.stuff.params.id));
                if (proto) {
                    return proto.get('param').upgrades;
                }
            }
        }
    }
});

/**
 * Блок статов предмета Уровень, Цена, Прочность

    Note: Для блока предмета необходимо передать protoModel и, если есть, itemModel

 */
Ext.define('ExGods.stuff.block.item.Stats1', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        getContent: function(data) {
            var content = [];
            content.push(this.getLevel(data));
            content.push(this.getPrice(data));
            content.push(this.getDur(data));
            content = Ext.Array.clean(content);
            return content.length ? content : false;
        },
        getLevel: function(data) {
            if (data.protoModel.data.data.strict.level) {
                return [
                    ExGods.ref('user_hoard|level').label,
                    '',
                    data.protoModel.data.data.strict.level
                ];
            }
        },
        getPrice: function(data) {
            if (data.protoModel.data.data.price) {
                return [
                    ExGods.getMsgByKey('price_text'),
                    ExGods.util.Format.printMoney({
                        name: 'gold'
                    }),
                    data.protoModel.data.data.price
                ];
            }
        },
        getDur: function(data) {
            var type = ExGods.ref('item_type').getByKey(data.protoModel.data.type),
                breakable, label, value;
            if (data.itemModel && typeof data.itemModel.get('param').nonbr != 'undefined') {
                breakable = !parseInt(data.itemModel.get('param').nonbr);
            } else if (typeof data.protoModel.data.param.nonbr != 'undefined') {
                breakable = !parseInt(data.protoModel.data.param.nonbr);
            } else {
                breakable = !parseInt(type.param.nonbr);
            }
            if (breakable) {
                label = ExGods.getMsgByKey('durability');
                value = (data.itemModel ? data.itemModel.getDur() + '/' : '') + data.protoModel.data.param.dur;
                if (data.itemModel && data.itemModel.hasCriticalDurability()) {
                    label = '<span class="exg-stuff-criticaldur">' + label + '</span>';
                    value = '<span class="exg-stuff-criticaldur">' + value + '</span>';
                }
                return [
                    label,
                    '',
                    value
                ];
            }
        }
    }
});

/**
 * Блок статов предмета Урон, здоровье, щит ..

    Note: Для блока предмета необходимо передать protoModel и, если есть, itemModel

 */
Ext.define('ExGods.stuff.block.item.Stats2', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        getContent: function(data) {
            var content,
                stats = this.getItemStats(data);
            content = ExGods.util.User.printUserStats(stats, {
                visibleValue: 1,
                align: 'right',
                changes: this.getStatsChanged(data),
                maxStats: this.getStatsMax(data)
            });
            if (ExGods.util.User.printUserStats(stats, {
                visibleValue: 2
            })) {
                content += '<div style="padding: 5px 0 0 0;">' + ExGods.util.User.printUserStats(stats, {
                    visibleValue: 2
                }) + '</div>';
            }
            return content;
        },
        /**
         * Возвращает текущие статы предмета
         */
        getItemStats: function(data) {
            var itemStats = Ext.apply({}, data.protoModel.data.data.stats);
            if (data.itemModel && data.itemModel.data.param.stat) {
                Ext.Object.each(data.itemModel.data.param.stat, function(key, value) {
                    itemStats[key] = (itemStats[key] || 0) + value;
                });
            }
            return itemStats;
        },
        /**
         * Возвращает разницу статов предмета и аналогичного по типу надетого предмета
         */
        getStatsChanged: function(data) {
            if (data.itemModel && data.itemModel.get('clothed')) {
                return {};
            }
            var protoTypeInfo = data.protoModel.getTypeInfo(),
                clothedItem = null,
                clothedItemStats = {},
                itemStats = {},
                changes = {};
            ExGods.app.user.slots().each(function(slot) {
                if (slot.data.type == protoTypeInfo.slot_on) {
                    clothedItem = slot.items().first();
                }
            });
            if (clothedItem) {
                // если есть надетый предмет аналогичного типа, собираю его статы
                clothedItemStats = Ext.clone(clothedItem.getProto().data.data.stats);
                Ext.Object.each(clothedItem.data.param.stat, function(key, value) {
                    clothedItemStats[key] += value;
                });
                // статы сравниваемого предмета
                itemStats = this.getItemStats(data);
                // и сравниваю
                Ext.Object.each(itemStats, function(key, value) {
                    changes[key] = value - clothedItemStats[key] || 0;
                });
            }
            return changes;
        },
        /**
         * Возвращает максимально возможные статы предмета
         */
        getStatsMax: function(data) {
            return {};
        }
    }
});

/**
 * Блок отображающий фичи, источником которых являются действия из прототипа предмета.
 *
 */
Ext.define('ExGods.stuff.block.item.ProtoFeatures', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        featureTpl: [
            '<div class="feature cf {[ Ext.isNumeric(values.feature.grade) ? "graded" : "" ]}">',
            '<tpl if="feature.images">',
            '<div class="image"><img src="{[ this.printImageUrl(values) ]}" /></div>',
            '</tpl>',
            '<div class="info">',
            '<div class="label item-grade-color-{item.grade}">{feature.label}</div>',
            '<tpl if="Ext.isNumeric(values.feature.grade)">',
            '<div class="grade">',
            '<div class="grade-inner" style="width: {[ ExGods.ref("constants|item_feature_stars").value*14 ]}px;">',
            '<div style="width: {[ 14*values.feature.grade ]}px"></div>',
            '</div>',
            '</div>',
            '</tpl>',
            '<div class="desc">{feature.description2}</div>',
            '</div>',
            '</div>',
            {
                printImageUrl: function(values) {
                    return IMAGE_URL + values.feature.images.main;
                }
            }
        ],
        /**
         * @override
         */
        getCls: function(data) {
            return 'exg-stuff-feature-block';
        },
        /**
         * @override
         */
        getContent: function(data) {
            var features = this.getFeaturesData(data),
                html = [],
                featureTpl;
            if (!this.compiledFeatureTpl) {
                this.compiledFeatureTpl = new Ext.XTemplate(this.featureTpl);
            }
            featureTpl = this.compiledFeatureTpl;
            features.forEach(function(feature) {
                html.push(featureTpl.apply({
                    item: {
                        grade: data.protoModel.data.data.item_grade || 1
                    },
                    feature: feature
                }));
            });
            return html.join('<div class="exg-stuff-block-separator"></div>');
        },
        /**
         * Вернёт данные фич
         */
        getFeaturesData: function(data) {
            var features = [];
            Ext.Array.each(data.protoModel.get('action_full') || [], function(action) {
                if (action.type == 'feature' && (!action.only_proto || !data.itemModel)) {
                    features.push(action);
                }
            });
            return features;
        }
    }
});

/**
 * Блок отображающий фичи предмета (itemModel.data.features)
 *
 */
Ext.define('ExGods.stuff.block.item.Features', {
    extend: ExGods.stuff.block.item.ProtoFeatures,
    inheritableStatics: {
        /**
         * @override
         */
        getFeaturesData: function(data) {
            return data.itemModel.data.features || [];
        }
    }
});

/**
 * Блок отображающий время через которое предмет исчезнет (Время жизни: ..)
 *
 */
Ext.define('ExGods.stuff.block.item.ExpireAfter', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        /**
         * @override
         */
        getContent: function(data) {
            var expireTime = this.getExpirationTime(data);
            if (expireTime) {
                return [
                    [
                        ExGods.getMsgByKey('item_expire_after'),
                        '',
                        ExGods.util.Time.printRestTime(expireTime, {
                            format: 'twonums'
                        })
                    ]
                ];
            }
        },
        /**
         * Вернет время через которое предмет должен исчезнуть ()
         */
        getExpirationTime: function(data) {
            var me = this,
                expire_after = data.protoModel.data.data.expire_after,
                validto = data.protoModel.data.data.validto;
            if (expire_after) {
                expire_after = ExGods.util.Date.parseString(expire_after) || Infinity;
            } else  {
                expire_after = Infinity;
            }
            
            if (validto) {
                validto = ExGods.util.Date.parseString(validto) || Infinity;
            } else  {
                validto = Infinity;
            }
            
            if (expire_after !== Infinity || validto !== Infinity) {
                return ExGods.util.Date.normalizeServerDateTime(new Date(Math.min(expire_after, validto)));
            }
        }
    }
});

/**
 * Блок отображающий время через которое предмет исчезнет (Исчезнет через: ..)
 *
 */
Ext.define('ExGods.stuff.block.item.ExpireTimer', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        /**
         * @override
         */
        getContent: function(data) {
            var expireTime = this.getExpirationTime(data);
            if (expireTime) {
                return [
                    [
                        ExGods.getMsgByKey('item_validto_label'),
                        '',
                        ExGods.util.Timers.printRestTimer('exg-stuff-item-timer', expireTime, {
                            format: 'twonums'
                        })
                    ]
                ];
            }
        },
        /**
         * Вернет время через которое предмет должен исчезнуть ()
         */
        getExpirationTime: function(data) {
            var me = this,
                expire_str = data.itemModel.data.param.expire_str,
                validto = data.protoModel.data.data.validto;
            if (expire_str) {
                expire_str = ExGods.util.Date.parseString(expire_str) || Infinity;
            } else  {
                expire_str = Infinity;
            }
            
            if (validto) {
                validto = ExGods.util.Date.parseString(validto) || Infinity;
            } else  {
                validto = Infinity;
            }
            
            if (expire_str !== Infinity || validto !== Infinity) {
                return ExGods.util.Date.normalizeServerDateTime(new Date(Math.min(expire_str, validto)));
            }
        }
    }
});

/**
 * Блок отображающий описание предмета
 *
 */
Ext.define('ExGods.stuff.block.item.Description', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        /**
         * @override
         */
        getContent: function(data) {
            var desc = data.protoModel.data.data.description;
            if (desc) {
                return ExGods.app.applyTpl(desc, {
                    item: data.itemModel,
                    itemPrototype: data.protoModel
                });
            }
        }
    }
});

/**
 * Менеджер объектов имущества
 */
Ext.define('ExGods.stuff.StuffManager', {
    extend: Ext.util.Observable,
    singleton: true,
    mixins: {
        loggable: ExGodsCore.util.Loggable
    },
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'StuffManager:'
    },
    constructor: function(config) {
        var me = this;
        me.mixins.loggable.constructor.call(me, config);
        me.types = {};
        me.objects = [];
        me.callParent(arguments);
        // регистрирую классы базовых типов имущества
        me.register('expa', ExGods.stuff.stuff.Expa);
        me.register('trophy', ExGods.stuff.stuff.Trophy);
        me.register('currency', ExGods.stuff.stuff.Currency);
        me.register('timed', ExGods.stuff.stuff.Timed);
        me.register('item', ExGods.stuff.stuff.Item);
        me.register('kit', ExGods.stuff.stuff.Kit);
        me.register('iteminstance', ExGods.stuff.stuff.ItemInstance);
        me.register('ingredients', ExGods.stuff.stuff.Ingredient);
        me.register('feature', ExGods.stuff.stuff.Feature);
        // подписываю обработчик клика по имуществу
        Ext.getBody().on('click', function(e, t) {
            if (e.getTarget('.exg-stuff-details') && !Ext.fly(t).up('.exg-stuff-collection')) {
                return;
            }
            me.onStuffClick(Ext.get(t));
        }, me, {
            delegate: '.exg-stuff-item'
        });
        me.registerTooltipSource();
        // запускаю сборщик мусора
        me.gc();
    },
    /**
     * Зарегистрировать класс для имущества по типу имущества.
     * @param type {String} Тип имущества
     * @param classObj {Ext.Class} Класс имущества.
     * @param listeners {Object} События и обработчики действий над имуществом вида {<event_name>: <event_handler>}
     */
    register: function(type, classObj, listeners) {
        var me = this;
        if (Ext.isObject(type)) {
            Ext.Object.each(type, function(key, value) {
                if (value.classObj) {
                    me.register(key, value.classObj, value.listeners);
                } else {
                    me.register(key, value);
                }
            });
            return;
        }
        me.types[type] = {
            classObj: classObj,
            listeners: listeners
        };
    },
    /**
     * Создает объект имущества
     * @param stuff {Object} Данные в формате имущества
     * @param isInnerObject {Boolean} Внутренний объект или нет. Жизненный цикл внутренного объекта управляется 
     * объектом-создателем, а не внутренного - самим менеджером (ExGods.stuff.StuffManager)
     */
    factory: function(stuff, isInnerObject) {
        var me = this;
        if (me.types[stuff.type]) {
            obj = new me.types[stuff.type].classObj({
                stuff: stuff
            });
            if (!isInnerObject) {
                me.objects.push(obj);
                obj.on('action', me.actionHandler, me);
            }
            return obj;
        } else {
            /****/
            me.log('warn', '@factory Класс имущества "' + stuff.type + '" не определен');
        }
    },
    /**
     * Напечатать имущество в виде строки
     * @param stuff {Mixed} Данные имущества или массив имущества
     * @return {String}
     */
    print: function(stuff) {
        var me = this,
            obj, html;
        stuff = this.normalize(stuff);
        if (Ext.isArray(stuff)) {
            return (new ExGods.stuff.StuffCollection({
                stuff: stuff
            })).print();
        } else {
            obj = me.factory(stuff);
            if (obj) {
                try {
                    html = obj.print();
                    return html;
                } catch (e) {
                    /***/
                    me.log('error', '@print Ошибка при печати имущества', e, stuff);
                }
            }
        }
    },
    /**
     * Напечатает имущество в виде картинки
     * @param stuff {Object} Данные имущества
     * @return {String}
     */
    image: function(stuff) {
        var me = this,
            obj, html;
        stuff = this.normalize(stuff);
        if (Ext.isArray(stuff)) {
            return (new ExGods.stuff.StuffCollection({
                stuff: stuff
            })).image();
        } else {
            obj = me.factory(stuff);
            if (obj) {
                try {
                    html = obj.image();
                    return html;
                } catch (e) {
                    /***/
                    me.log('error', '@image Ошибка при печати имущества', e, stuff);
                }
            }
        }
    },
    /**
     * Напечатает имущество в виде заголовков
     * @param stuff {Object} Данные имущества
     * @return {String}
     */
    title: function(stuff) {
        var me = this,
            obj, html;
        stuff = this.normalize(stuff);
        if (Ext.isArray(stuff)) {
            return (new ExGods.stuff.StuffCollection({
                stuff: stuff
            })).getTitle();
        } else {
            obj = me.factory(stuff);
            if (obj) {
                try {
                    html = obj.getTitle();
                    return html;
                } catch (e) {
                    /***/
                    me.log('error', '@image Ошибка при печати имущества', e, stuff);
                }
            }
        }
    },
    /**
     * Напечатает данные имущества в виде строки
     * @param stuff {Object} Данные имущества
     * @return {String}
     */
    details: function(stuff) {
        var me = this,
            obj, html;
        stuff = this.normalize(stuff);
        if (Ext.isArray(stuff)) {
            return (new ExGods.stuff.StuffCollection({
                stuff: stuff
            })).details({
                asHTML: true
            });
        } else {
            obj = me.factory(stuff);
            if (obj) {
                try {
                    html = obj.details({
                        asHTML: true
                    });
                    return html;
                } catch (e) {
                    /***/
                    me.log('error', '@details Ошибка при печати имущества', e, stuff);
                }
            }
        }
    },
    /**
     * Обработчик клика по имуществу
     */
    onStuffClick: function(el) {
        var me = this,
            obj = me.getObjectById(el.id);
        if (obj) {
            obj.clicks = obj.clicks ? obj.clicks + 1 : 1;
            me.stuffClickHandler(obj, el);
        } else {
            /***/
            me.log('warn', '@stuffClickHandler Объект имущества для элемента не найден', el);
        }
    },
    /**
     * Обработчик клика по имуществу
     */
    stuffClickHandler: Ext.Function.createBuffered(function(obj, el) {
        var me = this;
        if (obj.clicks > 1 && obj.getDblClickAction()) {
            me.actionHandler(obj, obj.getDblClickAction(), null, null);
        } else {
            obj.details({
                clickedEl: el
            });
        }
        obj.clicks = 0;
    }, 200),
    /**
     * Обработчик клика по кнопки объекта имущества
     */
    actionHandler: function(obj, actionName, btn, win) {
        var me = this;
        if (actionName === false)  {
            return;
        }
        
        if (me.types[obj.stuff.type]) {
            if (me.types[obj.stuff.type].listeners && me.types[obj.stuff.type].listeners[actionName]) {
                me.types[obj.stuff.type].listeners[actionName].call(me.types[obj.stuff.type].listeners.scope || me, obj, btn, win);
            } else {
                /****/
                me.log('warn', '@actionHandler Обработчик события ' + actionName + ' имущества ' + obj.stuff.type + ' не определен');
            }
        }
    },
    /**
     * Вернет объект имущества по id
     */
    getObjectById: function(id) {
        var me = this,
            obj;
        for (var i = 0; i < me.objects.length; i++) {
            if (me.objects[i].id == id) {
                obj = me.objects[i];
                break;
            }
        }
        return obj;
    },
    /**
     * Приводит данные имущества к единому виду, где каждый элемент имущества описывается отдельным объектом.
     * Например, валюта которая приходит в сгруппированном виде, как {type: "currency", params: [<data1>,<data2>, etc]}, разбивается на два 
     * независимых объекта с типом currency
     */
    normalize: function(stuff) {
        var me = this,
            result;
        if (Ext.isObject(stuff)) {
            if (stuff.type && stuff.params) {
                if (Ext.isArray(stuff.params)) {
                    result = [];
                    Ext.Array.each(stuff.params, function(item) {
                        result.push({
                            type: stuff.type,
                            params: item
                        });
                    });
                } else {
                    result = stuff;
                }
            } else {
                /***/
                me.log('error', '@normalize: Неверный формат данных имущества ', stuff);
            }
        } else if (Ext.isArray(stuff)) {
            result = [];
            Ext.Array.each(stuff, function(item) {
                var normalizedStuff = me.normalize(item);
                if (Ext.isArray(normalizedStuff)) {
                    result = result.concat(normalizedStuff);
                } else {
                    result.push(normalizedStuff);
                }
            });
        } else {
            /***/
            me.log('error', '@normalize: Неверный формат данных имущества ', stuff);
        }
        return result;
    },
    /**
     * Запускает сборщик мусора
     */
    gc: function() {
        var me = this,
            els = [],
            liveIds;
        setInterval(function() {
            liveIds = [];
            els = Ext.select('.exg-stuff-item').elements;
            for (var i = 0; i < els.length; i++) {
                liveIds.push(els[i].id);
            }
            for (var j = 0; j < me.objects.length; j++) {
                if (liveIds.indexOf(me.objects[j].id) == -1) {
                    me.objects[j] = null;
                }
            }
            me.objects = Ext.Array.clean(me.objects);
        }, 10 * 1000);
    },
    /**
     * Регистрирую менеджер как источник тултипов с типом "stuff"
     */
    registerTooltipSource: function() {
        var me = this,
            interval,
            times = 0;
        interval = setInterval(function() {
            if (!ExGods.app || !ExGods.app.getController('TooltipManager')) {
                if (++times > 10) {
                    clearInterval(interval);
                }
            } else {
                ExGods.app.getController('TooltipManager').register(me, 'stuff');
                clearInterval(interval);
            }
        }, 1000);
    },
    // пауза, чтобы дождаться инициализации объекта приложения
    /**
     * Реализация метода источника тултипов
     */
    getTooltipData: function(type, value) {
        var me = this;
        return this.getObjectById(value);
    }
});

//@define ExGods.util.Stuff
/**
 * Работа с имуществом
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
ExGods.util.Stuff = {
    /**
     * @property templates Темплейты печали имущества
     */
    templates: {
        currency: function(item, ref) {
            var params = Ext.isArray(item.params) ? item.params : [
                    item.params
                ],
                // валюта может быть сгруппирована в массив
                html = [];
            Ext.Array.each(params, function(param) {
                html.push('<span data-qtip="' + ref.currency.get(param.id).label + '">' + '<span style="white-space: nowrap;">' + '<img src="' + ref.currency.get(param.id).image + '"/>' + Ext.util.Format.number(param.quantity, "0,0") + '</span>' + '</span>');
            });
            return html.join('');
        },
        expa: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_experience') + '" class="item-tpl" style="background-image: url(' + ref.icons.image.exp + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        valour: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_valour') + '" class="item-tpl" style="background-image: url(' + ref.icons.image.valour + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        item: function(item, ref, options) {
            var cls = options.simple ? '' : 'class="item" ',
                style = [
                    'color:' + ExGods.references.get('constants_list').item_grades.value[Number(item.params.grade) - 1 || 0]
                ];
            //if(!options.simple){
            style.push('background-image: url(' + ref.icons.image.item + ')');
            //}
            style = ' style="' + style.join(';') + '"';
            return '<span ' + cls + 'data-proto_id="' + (item.params.id || item.params.entry) + '">' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_item') + '" class="item-tpl ' + (options.simple ? '' : 'decorated ') + '"' + style + '>' + item.params.title + (item.params.quantity > 1 ? '</span>(' + item.params.quantity + ')' : '</span>') + '</span>';
        },
        ability: function(item, ref) {
            return '<span class="ability" data-ability_id="' + item.params.id + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        feature: function(item, ref) {
            return '<span class="feature" data-feature_id="' + item.params.id + '">' + "<span data-qtip=''+ ref.messages.get('stuff_tooltip_feature') +'' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.buff + ")'>" + item.params.title + '</span>' + '</span>';
        },
        timed: function(item, ref) {
            var img = ref.timed.get(item.params.id).img || {};
            return '<span>' + '<span data-qtip="' + ref.stats.get(item.params.id).label + '" class="item-tpl" style="background-image: url(' + IMAGE_URL + img.stuff + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        trophy: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_trophy') + '" class="item-tpl" style="background-image: url(' + IMAGE_URL + 'icons/ico_trophy.png)">' + item.params.quantity + '</span>' + '</span>';
        },
        ingredients: function(item, ref) {
            var label = ref.ingredients.get(item.params.id).label;
            return '<span>' + '<span data-qtip="' + label + '" class="item-tpl decorated clickable" style="background-image: url(' + ref.icons.image.item + ')"">' + label + (item.params.quantity > 1 ? '</span>(' + item.params.quantity + ')' : '</span>') + '</span>' + '</span>';
        }
    },
    /**
     * Преобразует данные по имуществу в HTML строку
     * @param {Array} stuff Массив или объект, описывающий имущество в формате:
     * 
     *   [{
     *      type: {String} тип имущества,
     *      params: {
     *          id: {String} идентификатор имущество
     *          quantity {Number} количество 
     *          title {String} Название, актуально для предмета
     *          label {String} Название, актуальное для абилки
     *      }
     *   }]
     *
     * @param {Object} options Настройки. Поддерживаемые настройки:
     *
     *    display = "inline"|"block". По умолчанию список выстраивается горизонтально (display = 'inline').
     *                                Чтобы выстроить его вертикально укажите display = 'block'
     *
     *    delimiter {String}. Разделитель списка. По умолчанию "&nbsp;"
     * 
     * @return {String}
     */
    printStuff: function(stuff, options) {
        if (!stuff)  {
            return '';
        }
        
        //если нет цены выходим, но лучше проверять заранее
        if (stuff.stuff) {
            stuff = stuff.stuff;
        }
        // новый формат с прогрессивной стоимостью. ({discount, old, stuff}). Пока просто беру, имущество игнорируя остальное
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        options = Ext.applyIf(options || {}, {
            display: 'inline',
            delimiter: '&nbsp;'
        });
        var ref = {
                currency: ExGods.ref('user_money'),
                timed: ExGods.ref('user_timed'),
                stats: ExGods.ref('user_stat'),
                icons: ExGods.ref('images').get('user_stuff_icons'),
                ingredients: ExGods.ref('ingredients'),
                messages: ExGods.ref('message_client')
            },
            html = [],
            tplFn;
        Ext.each(stuff, function(item) {
            if (Ext.isObject(item) && !Ext.Object.isEmpty(item)) {
                tplFn = ExGods.util.Stuff.templates[item.type];
                if (tplFn) {
                    html = html.concat(tplFn(item, ref, options));
                } else {
                    /***/
                    ExGods.app.log('error', 'Шаблон для типа имущества ' + item.type + ' не определён.');
                }
            }
        });
        if (html.length > 1) {
            return '<ul class="exg-stuff exg-stuff-' + options.display + '">' + '<li>' + html.join(options.delimiter + '</li><li>') + '</li>' + '</ul>';
        } else {
            return '<span class="exg-stuff exg-stuff-' + options.display + '">' + html + '</span>';
        }
    }
};

//@define ExGods.util.Stuff2
/**
 * Работа с имуществом
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
Ext.require([
    'ExGods.util.Stuff'
], function() {
    ExGods.util.Stuff2 = {
        /**
     * Напечатает большую информацию о предмете или валюте
     * @params {Object} itemParams Параметры предмета в формате имущества (id, title, quantity, grade)
     * @params {Object} options
     *          disabledImage {Boolean} Печатать чернобелые картинки
     *          checkUser {Boolean} Проверить наличие имущества у юзера, и если нет - соответственно нарисовать
     *          noSort {Boolean} тру если не надо сортировать награды
     *          skulls {Boolean} тру если надо рисовать черепки
     * @return {String}
     */
        printBigRewards: function(all_stuff, options) {
            var me = this,
                protos = ExGods.app.getItemPrototypesStore(),
                items = curency = '',
                missedProtos = [],
                items_count = 0,
                sorterFn = function(rewards) {
                    return Ext.Array.sort(rewards, function(a, b) {
                        if (a.type == b.type)  {
                            return 0;
                        }
                        
                        if (a.type == 'item')  {
                            return 1;
                        }
                        
                        if (b.type == 'item')  {
                            return -1;
                        }
                        
                        if (a.type == 'trophy')  {
                            return -1;
                        }
                        
                        if (b.type == 'trophy')  {
                            return 1;
                        }
                        
                        if (a.type == 'expa')  {
                            return -1;
                        }
                        
                        if (b.type == 'expa')  {
                            return 1;
                        }
                        
                        if (a.type == 'valour')  {
                            return -1;
                        }
                        
                        if (b.type == 'valour')  {
                            return 1;
                        }
                        
                        if (a.type == 'currency')  {
                            return -1;
                        }
                        
                        if (b.type == 'currency')  {
                            return 1;
                        }
                        
                        if (a.type == 'ability')  {
                            return -1;
                        }
                        
                        if (b.type == 'ability')  {
                            return 1;
                        }
                        
                        if (a.type == 'feature')  {
                            return -1;
                        }
                        
                        if (b.type == 'feature')  {
                            return 1;
                        }
                        
                        if (a.type == 'timed')  {
                            return -1;
                        }
                        
                        if (b.type == 'timed')  {
                            return 1;
                        }
                        
                        return 1;
                    });
                };
            options = options || {};
            all_stuff = Ext.isArray(all_stuff) ? all_stuff : [
                all_stuff
            ];
            if (!options.noSort) {
                all_stuff = sorterFn(all_stuff);
            }
            for (var i = 0; i < all_stuff.length; i++) {
                var item_stuff = all_stuff[i];
                if (item_stuff.type == 'item' && item_stuff.item) {
                    //при потере предмета после боя
                    var proto_id = parseInt(item_stuff.params.id),
                        item = protos.data.getByKey(proto_id);
                    var stars = '<div class="upgrade_stars_container">';
                    for (var j = 0; j < item_stuff.item.param.upgrades; j++) {
                        stars += '<div class="upgrade_star"></div>';
                    }
                    stars += '</div>';
                    if (item) {
                        items += '<div class="info-box-itembox item" id="item_proto_' + proto_id + '" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + (item_stuff.params.quantity > 1 ? item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>' : '') + (item_stuff.item.param.upgrades ? stars : '') + '</div>';
                        items_count++;
                    } else {
                        missedProtos.push(proto_id);
                    }
                } else if (item_stuff.type == 'item' && options.skulls) {
                    var proto_id = parseInt(item_stuff.params.id),
                        item = protos.data.getByKey(proto_id);
                    if (item) {
                        items += '<div class="info-box-itembox item" id="item_proto_' + proto_id + '" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + '<span class="stack-counter big_counter"><span class="big_counter_mid"><span class="skull"><div></div>x ' + (item_stuff.params.quantity || 1) + '</span></span></span>' + '</div>';
                        items_count++;
                    } else {
                        missedProtos.push(proto_id);
                    }
                } else if (item_stuff.type == 'item') {
                    var proto_id = parseInt(item_stuff.params.id),
                        item = protos.data.getByKey(proto_id),
                        valid = options.checkUser && !ExGods.app.user.checkStuff([
                            item_stuff
                        ]),
                        haveItems = ExGods.app.user.getItemsCountByProto(proto_id);
                    if (item) {
                        items += '<div class="info-box-itembox item" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" ' + (valid ? 'class="missed-item" ' : '') + 'src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + ((item_stuff.params.quantity > 1 || options.checkUser) ? (item_stuff.params.quantity < 99 && !options.checkUser) ? ('<span class="stack-counter' + (valid ? ' red_color' : '') + '">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid' + (valid ? ' red_color' : (options.checkUser ? ' green_color' : '')) + '">' + (options.checkUser ? haveItems + '/' : '') + item_stuff.params.quantity + '</span></span>' : '') + (item_stuff.params.extra ? '<div class="extra-expa" style="background-image:url(' + ExGods.ref('images|common_text_images').image.bonus_on_items + ')"></div>' : '') + '</div>';
                        items_count++;
                    } else {
                        missedProtos.push(proto_id);
                    }
                } else if (item_stuff.type == 'currency') {
                    var proto = ExGods.ref('user_money|' + item_stuff.params.id);
                    items += '<div class="info-box-itembox item" data-big_stuff_img="' + proto.image_big + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.params.id + '" data-qtip="' + proto.label + '">' + '<img height="64" src="' + (options.disabledImage ? proto.image_disabled : proto.image_big) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa" style="background-image:url(' + ExGods.ref('images|common_text_images').image.bonus_on_items + ')"></div>' : '') + '</div>';
                    items_count++;
                } else if (item_stuff.type == 'ingredients') {
                    var proto = ExGods.ref('ingredients|' + item_stuff.params.id);
                    items += '<div class="info-box-itembox item" data-big_stuff_id = "' + item_stuff.params.id + '" data-big_stuff_img="' + IMAGE_URL + proto.params.images.img_1 + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="ingredients" data-qtip="' + proto.label + '">' + '<img height="64" src="' + IMAGE_URL + (options.disabledImage ? proto.params.images.img_2 : proto.params.images.img_1) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa" style="background-image:url(' + ExGods.ref('images|common_text_images').image.bonus_on_items + ')"></div>' : '') + '</div>';
                    items_count++;
                } else if (item_stuff.type == 'expa' || item_stuff.type == 'trophy') {
                    var proto = ExGods.ref('user_hoard|' + item_stuff.type),
                        image = options.disabledImage ? proto.image_disabled : proto.image_big;
                    items += '<div class="info-box-itembox item"  data-big_stuff_img="' + proto.image_big + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.type + '" data-qtip="' + proto.label + '">' + '<img height="64" src="' + (options.disabledImage ? proto.image_disabled : proto.image_big) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa" style="background-image:url(' + ExGods.ref('images|common_text_images').image.bonus_on_items + ')"></div>' : '') + '</div>';
                    items_count++;
                } else if (item_stuff.type == 'timed') {
                    var proto = ExGods.ref('user_timed|' + item_stuff.params.id),
                        timed = ExGods.app.user.get('timed')[item_stuff.params.id],
                        valid = options.checkUser && !ExGods.app.user.checkStuff([
                            item_stuff
                        ]),
                        image = IMAGE_URL + proto.img.stuff,
                        //options.disabledImage ? proto.image_disabled : proto.image_big;
                        label = proto.img.label,
                        desc = proto.img.desc;
                    /**
                 * timed - array
                 * timed[0] - Math.floor - текущее количество
                 * timed[1] - максимальное количество
                 * timed[2] - скорость восстановления (не нужно на клиенте)
                 * timed[3] - время до +1 (типа 1426066955)
                 */
                    items += '<div class="info-box-itembox item" data-big_stuff_img="' + image + '" data-big_stuff_desc="' + Ext.String.htmlEncode(desc) + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.type + '" data-qtip="' + label + '">' + '<img class="' + (valid ? 'class="missed-item" ' : '') + '" height="64" src="' + image + '" width="64" />' + '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>' + '</div>';
                    items_count++;
                } else if (item_stuff.type == 'feature') {
                    var proto = ExGods.app.getFeaturePrototypesStore().getById(item_stuff.params.id);
                    if (proto) {
                        items += '<div class="info-box-itembox item feature" data-feature_id="' + item_stuff.params.id + '" data-qtip="' + proto.data.label + '">' + '<div style="background-image: url(' + IMAGE_URL + proto.data.images.main + ');"></div>' + '</div>';
                        items_count++;
                    }
                } else if (item_stuff.type == 'action') {
                    var proto = ExGods.ref("direct_actions|" + item_stuff.params.id);
                    if (proto) {
                        items += '<div class="info-box-itembox item action-item" data-action_id="' + item_stuff.params.id + '" data-qtip="' + proto.images.name + '">' + '<div style="background-image: url(' + IMAGE_URL + proto.images.simple + ');"></div>' + '</div>';
                        items_count++;
                    }
                } else {
                    curency += ExGods.util.Stuff.printStuff(item_stuff) + '&nbsp;';
                }
            }
            return {
                items: items,
                currency: curency,
                missedProtos: missedProtos,
                itemsCount: items_count
            };
        },
        printBigStuff: function(stuff, options) {
            stuff = Ext.isArray(stuff) ? stuff : [
                stuff
            ];
            return ExGods.util.Stuff2.printBigRewards(stuff, options).items;
        }
    };
});

//@define ExGods.util.User
/**
 * Работа с объектом пользователя
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
ExGods.util.User = {
    /**
     * Напечатает данные пользователя (имя, ранк, уровень)
     * @param {Object} user Данные пользователя
     * @param {Object} options Настройки:
     *  
     *  fields - список полей, которые нужно вывести. По умолчанию, ['name', 'rank', 'level', 'infoicon']. Допускается передавать в строке, разделяя запятыми
     *           Поддерживаемые поля: 'name', 'rank', 'level', 'infoicon', 'guild'
     *
     *  maxNameWidth - максимальная ширина имени пользователя в пикселях. По умолчанию не определено.
     *
     *  cls - css класс, который добавиться к корневому элементу
     *
     *  hideLevelIcon - скрыть иконку уровня
     *
     */
    printUser: function(user, options) {
        var tpl;
        options = Ext.applyIf(options || {}, {
            fields: 'name, rank, level, infoicon',
            cls: ''
        });
        if (typeof options.fields == 'string') {
            options.fields = Ext.Array.map(options.fields.split(','), function(item) {
                return Ext.String.trim(item);
            });
        }
        if (!ExGods.util.User.userinfoTpl) {
            ExGods.util.User.userinfoTpl = new Ext.XTemplate([
                '<span class="userinfo {options.cls} {[this.getCls(values.user)]}" style="{[this.getStyle(values.user)]}" data-uname="{user.display_title}" data-urace="{user.race}">',
                '<tpl if="this.isVisibleField(options, \'infoiconleft\')">',
                '<span class="userinfo-icon info-icon info-icon-left" style="background-image: url(',
                '<tpl if="user.gender == 1">',
                '' + IMAGE_URL + 'interface/icon_male.png',
                '<tpl else>',
                '' + IMAGE_URL + 'interface/icon_female.png',
                '</tpl>',
                ')',
                '" data-qtip="' + ExGods.getMsgByKey("user_info_tooltip") + '"></span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'guild\') && values.user.guild">',
                '<span class="guild-name" data-qtip="{user.guild.title}">',
                '[<strong>{user.guild.tag}</strong>]&nbsp;',
                '</span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'name\')">',
                '<span class="name" data-qtip="{[this.getTooltipText(values.user)]}" <tpl if="options.maxNameWidth">style="max-width: {options.maxNameWidth}px;"</tpl>>',
                '{user.display_title}',
                '</span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'rating_rank\') && this.getRankImg(values.user.rating_rank)">',
                '<span class="rank" ',
                'style="background-image: url({[this.getRankImg(values.user.rating_rank)]});"></span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'trophy_level\') && this.getTrophyLevelImg(values.user)">',
                '<span class="trophylevel-icon" data-qtip="{[this.getTrophyLevelTooltip(values.user)]}"',
                'style="background-image: url({[this.getTrophyLevelImg(values.user)]});"></span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'level\')">',
                '<tpl if="this.isVisibleField(options, \'name\') || this.isVisibleField(options, \'rank\')">',
                '&nbsp;',
                '</tpl>',
                '<span class="level" data-qtip="' + Ext.String.format(ExGods.getMsgByKey('user_level_tooltip'), '{user.hoard.level}') + '">',
                '<tpl if="!options.hideLevelIcon">',
                '<span class="level-icon" style="background-image: url(' + IMAGE_URL + 'icons/level.png' + ');"></span>',
                '</tpl>',
                '{user.hoard.level}',
                '</span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'infoicon\')">',
                '<span class="userinfo-icon info-icon" style="background-image: url(',
                '<tpl if="user.gender == 1">',
                '' + IMAGE_URL + 'interface/icon_male.png',
                '<tpl else>',
                '' + IMAGE_URL + 'interface/icon_female.png',
                '</tpl>',
                ')',
                '" data-qtip="' + ExGods.getMsgByKey("user_info_tooltip") + '"></span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'menuicon\')">',
                '<span class="menu-icon"></span>',
                '</tpl>',
                '</span>',
                {
                    getCls: function(data) {
                        var cls = [];
                        if (data.race) {
                            cls.push('race-' + data.race);
                        }
                        if (data.moder) {
                            cls.push('moder');
                        }
                        return cls.join(' ');
                    },
                    getStyle: function(data) {
                        var style = [];
                        // if (data.moder) {
                        //  style.push('color:' + ExGods.ref('constants|chat_moder_color').value);
                        // }
                        return style.join(';');
                    },
                    isVisibleField: function(options, field) {
                        return Ext.Array.indexOf(options.fields, field) != -1;
                    },
                    getRankTitle: function(rank) {
                        var rec = ExGods.references.get('user_valour').getByKey(rank);
                        return rec.data.rank ? rec.data.rank : '';
                    },
                    getTrophyLevelImg: function(user) {
                        if (user.hoard && user.hoard.trophy_level && user.hoard.trophy_level >= 2) {
                            switch (user.hoard.trophy_level) {
                                case 2:
                                    return IMAGE_URL + 'icons/trophy_rank/bronze.png';
                                case 3:
                                    return IMAGE_URL + 'icons/trophy_rank/silver.png';
                                case 4:
                                    return IMAGE_URL + 'icons/trophy_rank/gold.png';
                                case 5:
                                    return IMAGE_URL + 'icons/trophy_rank/crystal.png';
                            }
                        }
                    },
                    getTrophyLevelTooltip: function(user) {
                        if (user.hoard && user.hoard.trophy_level && user.hoard.trophy_level >= 2) {
                            var refData = ExGods.ref('user_trophy|' + user.hoard.trophy_level);
                            if (refData && refData.description) {
                                return refData.description.label;
                            }
                        }
                    },
                    getRankImg: function(rank) {
                        var images = {
                                1: IMAGE_URL + 'place1.png',
                                2: IMAGE_URL + 'place2.png',
                                3: IMAGE_URL + 'place3.png'
                            };
                        return images[rank] || '';
                    },
                    getTooltipText: function(data) {
                        var tooltipText = data.display_title;
                        return tooltipText;
                    }
                }
            ]);
        }
        return ExGods.util.User.userinfoTpl.apply({
            user: user,
            options: options
        });
    },
    /**
     * Печатает конкретный стат юзера с иконкой
     */
    printStat: function(name, value) {
        var stat = ExGods.ref('user_stat|' + name);
        if (!stat)  {
            return '';
        }
        
        if (!value)  {
            value = '';
        }
        
        return '<div class="exg-user-stat" data-qtip="' + stat.label + '" style="background-image:url(' + IMAGE_URL + stat.param.icon + ')">' + value + '</div>';
    },
    /**
     * Статические изображения для предварительной загрузки ресурсов
     *  
     */
    getUserStatImages: function() {
        return [
            IMAGE_URL + 'icons/stats/ico_injury16.png',
            IMAGE_URL + 'icons/stats/ico_life16.png',
            IMAGE_URL + 'icons/stats/ico_shield16.png',
            IMAGE_URL + 'icons/stats/ico_mana16.png',
            IMAGE_URL + 'icons/stats/ico_fury16.png',
            IMAGE_URL + 'mask/ico_adroitness.png',
            IMAGE_URL + 'mask/star_red.png',
            IMAGE_URL + 'mask/star_green.png',
            IMAGE_URL + 'mask/star.png',
            IMAGE_URL + 'mask/stars_bg.png',
            IMAGE_URL + 'mask/ico_power.png',
            IMAGE_URL + 'mask/ico_armor.png',
            IMAGE_URL + 'mask/ico_accuracy.png'
        ];
    },
    /**
     * Печатает статы юзера.
     * @param {Array} stats 
     * @param {Object} options Настройки:
     *  visibleValue - значение свойства visible у стата, для которого делать вывод.
     *  column - кол-во колонок, в которых выводить статы. По умолчанию 1
     *  changes - хеш изменений значений статов
     *  maxStats - хеш максимально возможных значений (отображается как "(max. 4)")
     *  inline - если true - отображать в одну строку, по умолчанию false
     *  colorize - если true - положительные значения отображаются зеленым, отрицательные красным, по умолчанию false
     */
    printUserStats: function(stats, options) {
        var data = {
                stats: []
            },
            statsRef = ExGods.ref('user_stat'),
            statInfo,
            tpl = new Ext.XTemplate([
                '<tpl if="options.visibleValue == 1">',
                '<tpl if="options.inline">',
                '<ul class="inline-list">',
                '<tpl for="stats">',
                '<li>',
                '<span class="value icon">{[ this.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ ExGods.printNumber(this.printValue(values.value), 1000, "0", "0.0") ]}</span>',
                '</li>',
                '</tpl>',
                '</ul>',
                '<tpl elseif="options.align != \'right\'">',
                '<table class="user-stats user-stats-{options.visibleValue}">',
                '<tpl for="stats">',
                '<tr class="{[xindex % 2 === 0 ? "even" : ""]}">',
                '<td>{label}</td>',
                '<td>',
                '<span class="value icon">{[ this.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ this.printValue(values.value) ]}',
                '<tpl if="changes">',
                '<span class="changes">',
                '<small>(</small>',
                '<tpl if="Ext.isNumeric(values.changes)">',
                '<span class="{[ values.changes > 0 ? "up" : "down" ]}">{[values.changes > 0 ? "+" : ""]}{changes}</span>',
                '<tpl else>',
                '{changes}',
                '</tpl>',
                '<small>)</small>',
                '</span>',
                '</tpl>',
                '<tpl if="maxStat">',
                '<span><small>(</small><span style="color:' + ExGods.ref('constants|max_upgrade_color').value + '">max. {maxStat}</span><small>)</small></span>',
                '</tpl>',
                '</span>',
                '</td>',
                '</tr>',
                '</tpl>',
                '</table>',
                '<tpl else>',
                '<ul class="table-list">',
                '<tpl for="stats">',
                '<li class="{[xindex % 2 === 0 ? "even" : ""]}">',
                '<span class="label">{label}</span>',
                '<span class="value icon">{[ this.printIcon(values.param.icon) ]}</span>',
                '<span class="value{[ this.getValueClass(this.printValue(values.value)) ]}">{[ this.printValue(values.value) ]}',
                '<tpl if="changes">',
                '<span class="changes">',
                '<small>(</small>',
                '<tpl if="Ext.isNumeric(values.changes)">',
                '<span class="{[ values.changes > 0 ? "up" : "down" ]}">{[values.changes > 0 ? "+" : ""]}{changes}</span>',
                '<tpl else>',
                '{changes}',
                '</tpl>',
                '<small>)</small>',
                '</span>',
                '</tpl>',
                '<tpl if="maxStat">',
                '<span><small>(</small><span style="color:' + ExGods.ref('constants|max_upgrade_color').value + '">max. {maxStat}</span><small>)</small></span>',
                '</tpl>',
                '</span>',
                '</li>',
                '</tpl>',
                '</ul>',
                '</tpl>',
                '<tpl else>',
                '<table class="user-stats user-stats-{options.visibleValue}">',
                '<tpl if="options.visibleValue == 2">',
                '<tr>',
                '<tpl for="stats">',
                '<td data-qtip="{label} - {[ this.printValue(values.value) ]}">',
                '<div class="background" style="background: url(' + IMAGE_URL + '{param.empty})">',
                '<div class="icon" style="background: url(' + IMAGE_URL + '{param.icon})"></div>',
                '<div class="fill-red" style="{[ this.getRedStarsStyle(values.value) ]}"></div>',
                '<div class="fill-green" style="{[ this.getGreenStarsStyle(values.value) ]}"></div>',
                '<div class="fill" style="{[ this.getStarsStyle(values.value) ]};background: url(' + IMAGE_URL + '{param.fill});"></div>',
                '</div>',
                '</td>',
                '<tpl if="xindex % 2 == 0 && xindex < xcount">',
                '</tr><tr>',
                '</tpl>',
                '</tpl>',
                '</tr>',
                '</tpl>',
                '</table>',
                '</tpl>',
                {
                    printValue: function(v) {
                        return Ext.isArray(v) ? v[0] : /*+ '/' + v[1]*/
                        v;
                    },
                    getValueClass: function(v) {
                        if (options.colorize) {
                            return v > 0 ? ' up' : ' down';
                        } else  {
                            return '';
                        }
                        
                    },
                    getRedStarsStyle: function(v) {
                        var style = [];
                        style.push('background: url(' + IMAGE_URL + 'mask/star_red.png)');
                        if (Ext.isArray(v) && v[0] < v[1]) {
                            style.push('left: ' + (24 + v[0] * 14) + 'px');
                            style.push('width: ' + (Math.min(v[1] - v[0], 5 - v[0]) * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    getGreenStarsStyle: function(v) {
                        var style = [];
                        style.push('background: url(' + IMAGE_URL + 'mask/star_green.png)');
                        if (Ext.isArray(v) && v[0] > v[1]) {
                            style.push('left: ' + (24 + v[1] * 14) + 'px');
                            style.push('width: ' + (Math.min(v[0] - v[1], 5 - v[1]) * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    getStarsStyle: function(v) {
                        var style = [];
                        if (Ext.isArray(v)) {
                            style.push('width: ' + (Math.min(v[0], v[1]) * 14) + 'px');
                        } else {
                            style.push('width: ' + (v * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    printIcon: function(icon) {
                        return '<img width="16" height="16" style="margin: 0 2px -3px 0;" src="' + IMAGE_URL + icon + '"/>';
                    }
                }
            ]);
        data.options = Ext.applyIf(options || {}, {
            columns: 1,
            visibleValue: 1,
            inline: false,
            changes: {},
            maxStats: {}
        });
        var sorters = {
                damage: 1,
                fury: 5,
                hp: 2,
                mp: 4,
                shield: 3,
                stamina: 3,
                strength: 2,
                accuracy: 4,
                agility: 1
            };
        // подготавливаю данные для шаблона
        Ext.Object.each(stats, function(key, value) {
            statInfo = statsRef.get(key);
            if (!statInfo) {
                /***/
                //ExGods.app.log('error', 'Данные для стата ' + key + ' не найдены в справочнике');
                return;
            }
            if ((options.visibleValue == statInfo.visible) && (value !== null)) {
                // if(options.visibleValue == 2 && data.options.changes[key]){
                //  value = [value, value - data.options.changes[key]];
                // }
                data.stats.push({
                    name: key,
                    value: value,
                    label: statInfo.label,
                    visible: statInfo.visible,
                    param: statInfo.param,
                    changes: data.options.changes[key],
                    maxStat: data.options.maxStats[key]
                });
            }
        });
        if (data.stats.length) {
            Ext.Array.sort(data.stats, function(a, b) {
                return sorters[a.name] > sorters[b.name];
            });
            return tpl.apply(data);
        } else {
            return '';
        }
    }
};
// aliases
ExGods.printUser = ExGods.util.User.printUser;
ExGods.printStat = ExGods.util.User.printStat;

//@define ExGods.util.Sprite
/**
 * Работа со спрайтами
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
ExGods.util.Sprite = {
    /**
     * Печатает цисло по спрайту
     * @param {Number} number - required - число;
     * @param {String} sprite - ссылка на картинку спрайта, либо полная либо от корня. Можно не передавать, если задать в css в классе util-sign
     * @param {Object} options - required - параметры
     * - @param {Boolean} horizontal - default:false. Определяет, горизонтальный спрайт или вертикальный
     * - @param {String} indent - отступ, с которого начинать рисовать спрайт. Если спрайт горизонтальный -
     *      то отступ вертикальный и наоборот.
     * - @param {String} cls - css класс контейнера
     * - @param {String} tag - dom tag контейнера
     * - @param {Number} width - required - ширина цифры
     * - @param {Number} height - required - высота цифры
     * - @param {Boolean} lastZero - default: false Если в спрайте "0" стоит на последнем месте
     * - @param {Boolean} twoDigits - default: false для цифр с длиной 1 добавлять 0 в начале
     */
    printSprite: function(number, sprite, options) {
        var n = parseInt(number).toString(),
            w = options.width,
            h = options.height,
            tag = options.tag || 'div',
            cls = options.cls || '',
            i = 0,
            totalWidth = 0,
            numberHtml = '',
            left, top, sign, bgimg, bgpos;
        if (sprite) {
            sprite = (sprite.substr(0, 4) == 'http') ? sprite : IMAGE_URL + sprite;
        }
        if (options.twoDigits && n.length == 1)  {
            n = '0' + n;
        }
        
        for (; i < n.length; i++) {
            totalWidth += w;
            sign = parseInt(n.charAt(i));
            if (options.lastZero) {
                if (sign === 0) {
                    sign = 9;
                } else {
                    sign--;
                }
            }
            if (options.horizontal) {
                left = sign ? '-' + sign * w + 'px' : 0;
                top = options.indent || 0;
            } else {
                left = options.indent || 0;
                top = sign ? '-' + sign * h + 'px' : 0;
            }
            bgpos = 'background-position: ' + left + ' ' + top;
            bgimg = (sprite) ? 'background-image: url(' + sprite + ');' : '';
            numberHtml += '<div class="util-sign" style="' + bgimg + bgpos + ';width:' + w + 'px;height:' + h + 'px"></div>';
        }
        result = '<' + tag + ' class="util-sign-container ' + cls + '">' + '<div style="width:' + totalWidth + 'px;height:' + h + 'px">' + numberHtml + '</div>' + '</' + tag + '>';
        return result;
    }
};

//@define ExGods.util.Time
/**
 * Работа со временем
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
ExGods.util.Time = {
    /**
     * Печатает время в удобочитаемом виде
     * @param {Number} time Время в секундах
     * @param {Object} options Настройки. Поддерживаемые настройки:
     *
     *  format = "detailed"|"threenums"|"short" - формат отображения. По умолчанию, "detailed"
     *
     *      Примеры: "detailed" - '7 дн. 10 ч. 10 м. 10 с',
     *               "short" - '7 дней' или '10:10:10'
     *               "threenums" - '2 недели 3 ч. 10 мин.' или '3 дня 10 ч. 10 мин.' или '10 ч. 10 мин. 10 сек.' 
     *               "twonums" - '13 ч 48 м'
     *               "bignums" - '13:48' в виде спрайта из больших цифр
     *
     *  emptyText = <String> - сообщение, если время <= 0
     *
     */
    printTime: function(time, options) {
        var me = this,
            units,
            delimiter = ' ',
            digitFormat = 'd',
            output = [],
            messages = ExGods.ref('message_client'),
            value, i,
            // Печатает одиночное число в опредленном формате
            // @param {Number} value Значение 
            // @param {digitFormat} Формат числа. "dd" - '01', "d" - '1'
            // @param {String} label Название единицы измерения
            printDigit = function(value, digitFormat, label) {
                var res = '';
                if (digitFormat == 'dd') {
                    res += (value < 10 ? '0' : '') + value;
                } else {
                    res += value;
                }
                if (label) {
                    if (Ext.isArray(label)) {
                        res += ' ' + Ext.util.Format.plural(value, units[i].label);
                    } else {
                        res += ' ' + label;
                    }
                }
                return res;
            };
        options = Ext.applyIf(options || {}, {
            format: 'detailed',
            emptyText: ''
        });
        if (time >= 1) {
            if (options.format == 'detailed') {
                units = [
                    {
                        max: 24 * 3600,
                        label: messages.get('date_format_days_dn') + '.'
                    },
                    {
                        max: 3600,
                        label: messages.get('date_format_hours_ch') + '.'
                    },
                    {
                        max: 60,
                        label: messages.get('date_format_minutes_min') + '.'
                    },
                    {
                        max: 1,
                        label: messages.get('date_format_seconds_s') + '.',
                        digitFormat: 'dd'
                    }
                ];
            } else if (options.format == 'threenums') {
                if (time / (7 * 24 * 3600) > 1) {
                    units = [
                        {
                            max: 7 * 24 * 3600,
                            label: messages.get('date_format_weeks_n') + '.'
                        },
                        // ['неделя', 'недели', 'недель']
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d') + '.'
                        },
                        // ['день', 'дня', 'дней']
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        }
                    ];
                }
                // ['час', 'часа', 'часов']
                else if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_dn') + '.'
                        },
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m') + '.'
                        }
                    ];
                } else {
                    units = [
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m') + '.'
                        },
                        {
                            max: 1,
                            label: messages.get('date_format_seconds_s') + '.',
                            digitFormat: 'dd'
                        }
                    ];
                }
            } else if (options.format == 'twonums') {
                if (time / (7 * 24 * 3600) > 1) {
                    units = [
                        {
                            max: 7 * 24 * 3600,
                            label: messages.get('date_format_weeks_n')
                        },
                        // ['неделя', 'недели', 'недель']
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d')
                        }
                    ];
                }
                // ['день', 'дня', 'дней']
                else if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d')
                        },
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch')
                        }
                    ];
                } else if (time / (3600) > 1) {
                    units = [
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch')
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m')
                        }
                    ];
                } else {
                    units = [
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m')
                        },
                        {
                            max: 1,
                            label: messages.get('date_format_seconds_s'),
                            digitFormat: 'dd'
                        }
                    ];
                }
            } else if (options.format == 'bignums') {
                if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_text').split(',')
                        }
                    ];
                } else {
                    delimiter = ':';
                    digitFormat = 'dd';
                    units = [
                        {
                            max: 3600,
                            label: ''
                        },
                        {
                            max: 60,
                            label: ''
                        },
                        {
                            max: 1,
                            label: ''
                        }
                    ];
                }
            } else {
                if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_text').split(',')
                        }
                    ];
                } else {
                    delimiter = ':';
                    digitFormat = 'dd';
                    units = [
                        {
                            max: 3600,
                            label: ''
                        },
                        {
                            max: 60,
                            label: ''
                        },
                        {
                            max: 1,
                            label: ''
                        }
                    ];
                }
            }
            for (i = 0; i < units.length; i++) {
                value = Math.floor(time / units[i].max);
                if (value != 0 || (options.format == 'short' && units[i].max != 3600) || (options.format == 'threenums' && (units[i].max == 1 || output.length)) || (options.format == 'twonums' && (units[i].max == 1 || output.length)) || (options.format == 'bignums' && units[i].max != 3600)) {
                    output.push(printDigit(value, units[i].digitFormat || digitFormat, units[i].label));
                    time -= value * units[i].max;
                }
            }
            if (options.format == 'bignums') {
                var sprites = [];
                if (output.length == 1) {
                    output.unshift('0');
                }
                Ext.Array.each(output, function(num) {
                    sprites.push(ExGods.util.Sprite.printSprite(num, IMAGE_URL + '/numbers.png', {
                        width: 21,
                        height: 30,
                        twoDigits: true
                    }));
                });
                return sprites.slice(0, 2).join('<span class="bignum-delimiter"></span>');
            } else  {
                return output.join(delimiter);
            }
            
        } else {
            return options.emptyText;
        }
    },
    /**
     * Напечатает время, оставшееся до даты (@param date) в удобном виде
     * @param {Date} date
     * @param {Object} options Настройки:
     *
     *  format = "detailed"|"short" (см. настройки для ExGods.util.Time.printTime)
     *
     *  emptyText - Текст, который будет отображен, если дата истекла
     */
    printRestTime: function(date, options) {
        var restTime;
        options = Ext.applyIf(options || {}, {
            emptyText: '',
            stringFormat: '{0}'
        });
        restTime = Math.ceil((date - new Date()) / 1000);
        if (restTime > 0) {
            return Ext.String.format(options.stringFormat, this.printTime(restTime, options));
        } else {
            return options.emptyText;
        }
    }
};

//@define ExGods.util.Format
/**
 * Класс-помощник. В основном содержит вспомогательные методы по преобразованию данных в строку
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
Ext.require([
    'ExGods.util.Stuff',
    'ExGods.util.Stuff2',
    'ExGods.util.User'
], function() {
    ExGods.util.Format = {
        /**
         * Напечатает информацию о предмете
         * @params {Object} itemParams Параметры предмета в формате имущества (id, title, quantity, grade)
         * @return {String}
         */
        printItem: function(itemParams) {
            return ExGods.util.Stuff.printStuff({
                type: 'item',
                params: itemParams
            });
        },
        /**
         * Напечатает информацию о абилке(ах)
         * @params {Object} abilityParams Параметры предмета в формате имущества ([{id, label}, ... ])
         * @return {String}
         */
        printAbility: function(abilityParams) {
            var stuff = [];
            abilityParams = Ext.isArray(abilityParams) ? abilityParams : [
                abilityParams
            ];
            for (var i = 0; i < abilityParams.length; i++) {
                stuff.push({
                    type: 'ability',
                    params: {
                        id: abilityParams[i].id,
                        label: abilityParams[i].label
                    }
                });
            }
            return ExGods.util.Stuff.printStuff(stuff);
        },
        /**
         * Напечатает информацию о фиче(ах)
         * @params {Object} featureParams Параметры предмета в формате имущества ([{id, label}, ... ])
         * @return {String}
         */
        printFeature: function(featureParams) {
            var stuff = [];
            featureParams = Ext.isArray(featureParams) ? featureParams : [
                featureParams
            ];
            for (var i = 0; i < featureParams.length; i++) {
                stuff.push({
                    type: 'feature',
                    params: {
                        id: featureParams[i].id,
                        title: featureParams[i].label
                    }
                });
            }
            return ExGods.util.Stuff.printStuff(stuff);
        },
        /**
         * Напечатает money
         * @params {Object} moneyParams Параметры денег в формате валюты ([{name, value}, ... ])
         * @return {String}
         */
        printMoney: function(moneyParams) {
            var stuff = [];
            moneyParams = Ext.isArray(moneyParams) ? moneyParams : [
                moneyParams
            ];
            for (var i = 0; i < moneyParams.length; i++) {
                stuff.push({
                    type: 'currency',
                    params: {
                        id: moneyParams[i].name,
                        quantity: moneyParams[i].value
                    }
                });
            }
            return ExGods.util.Stuff.printStuff(stuff);
        },
        /**
         * Вернет число разделенное на порядки.
         *
         * @param {Number/String} quantity Число которое необходимо разделить
         * @param {Number} shortFrom Число, начиная с которого нужно перобразовывать в короткую форму (используя "k/kk"). По умолчанию 1000
         *   Например, для shortFrom = 10000, число 123456 будет выведено как "123к", а число 1234567 - "1кк"
         * @param {String} format Формат числа, соответсвующий параметру format функции Ext.util.Format.number. По умолчанию, '0,0'
         * @param {String} decimalFormat Формат числа с дробной частью
         */
        printNumber: function(quantity, shortFrom, format, decimalFormat) {
            var postfix = '';
            quantity = '' + quantity;
            // преобразую в строку
            shortFrom = shortFrom || 1000000000;
            format = format || '0,0';
            if (quantity >= shortFrom) {
                if (quantity >= 10000000) {
                    quantity = quantity.substr(0, quantity.length - 6);
                    postfix = 'kk';
                } else if (quantity >= 1000000) {
                    quantity = (parseInt(quantity.substr(0, quantity.length - 5)) / 10).toString();
                    postfix = 'kk';
                } else if (quantity >= 10000) {
                    quantity = quantity.substr(0, quantity.length - 3);
                    postfix = 'k';
                } else if (quantity >= 1000) {
                    quantity = (parseInt(quantity.substr(0, quantity.length - 2)) / 10).toString();
                    postfix = 'k';
                }
            }
            if (quantity.split('.').length > 1 && decimalFormat) {
                format = decimalFormat;
            }
            return Ext.util.Format.number(quantity, format) + postfix;
        }
    };
    // для совместимости с шаблонами в справочниках. Не использовать в коде!
    ExGods.util.Format.printUserInfo = ExGods.util.User.printUser;
    ExGods.util.Format.printStuff = ExGods.util.Stuff.printStuff;
    ExGods.printItem = ExGods.util.Format.printItem;
    ExGods.printAbility = ExGods.util.Format.printAbility;
    ExGods.printFeature = ExGods.util.Format.printFeature;
    ExGods.printBigStuff = ExGods.util.Stuff2.printBigStuff;
    // aliases
    ExGods.printNumber = ExGods.util.Format.printNumber;
    ExGods.printMoney = ExGods.util.Format.printMoney;
});

//@define ExGods.util.Date
/**
 * Утилита для работы с датой
 *
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
ExGods.util.Date = {
    /**
     * @property {String} serverDateTimeFormat
     * Формат даты и времени сервера
     */
    serverDateTimeFormat: serverDateTimeFormat,
    /**
     * @property {Number} serverTimezoneOffset
     * Сдвиг таймзоны (Москва) на сервере в минутах
     */
    serverTimezoneOffset: -3 * 60,
    /**
     * @property {Number} serverTimeOffset
     * Смещение серверного времени относительно клиентского в секундах
     */
    serverTimeOffset: parseInt(new Date().getTime() / 1000, 10) - window.now,
    /**
     * Парсит строку с датой и возвращает объект даты (не нормализованный)
     */
    parseString: function(str) {
        var me = this,
            dt;
        dt = Ext.Date.parse(str, this.serverDateTimeFormat);
        if (!dt) {
            // возможно дата пришла в формате timestamp - 'YmdHis'
            dt = Ext.Date.parse(str, 'YmdHis');
        }
        if (!dt) {
            // возможно дата пришла в формате "7d" или "eday"
            if (str == 'eday') {
                // до полуночи              
                dt = new Date();
                dt.setHours(23);
                dt.setHours(23);
                dt.setHours(23);
            } else if (str.match(/^\d+[d,m,s]/)) {
                var count = str.match(/^\d+/)[0];
                var units = str.match(/[d,m,s]/)[0];
                if (units == "d") {
                    dt = Ext.Date.add(new Date(), Ext.Date.DAY, count);
                } else if (units == "m") {
                    dt = Ext.Date.add(new Date(), Ext.Date.MINUTE, count);
                } else if (units == "s") {
                    dt = Ext.Date.add(new Date(), Ext.Date.SECOND, count);
                }
            }
        }
        return dt;
    },
    /**
     * Вернет клиентское время, соответствующее времени сервера, переданного в строке serverDateTime
     * @param {String|Date} serverDateTime Серверная дата в формате ExGods.util.Date.serverDateTimeFormat или объект даты
     * @return {Date} Клиентское время, соответствующее времени сервера
     */
    normalizeServerDateTime: function(serverDateTime) {
        var dt;
        if (typeof serverDateTime == 'string') {
            dt = this.parseString(serverDateTime);
        } else {
            dt = serverDateTime;
        }
        dt = Ext.Date.add(dt, Ext.Date.MINUTE, -dt.getTimezoneOffset() + this.serverTimezoneOffset);
        dt = Ext.Date.add(dt, Ext.Date.SECOND, this.serverTimeOffset);
        return dt;
    },
    /**
     * Нормализует серверное время в unixtime в секундах
     */
    normalizeUnixTime: function(time) {
        var me = this;
        return new Date((parseInt(time) + this.serverTimeOffset) * 1000);
    }
};

//@define ExGods.util.Ticker
/**
 * @class ExGods.util.Ticker
 *
 * Предоставляет доступ к общему тикеру (временному интервалу в 1 секунду)
 *
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
ExGods.util.Ticker = (function() {
    var listeners = [];
    /**
     * Добавляет обработчик тика
     * @param {Function} fn (required)
     * @param {Object} scope
     * @param {Object} options Опции
     *
     * Поддерживаемые опции:
     *    period - Интервал вызова обработчика в секундах. По умолчанию - 1 секунда
     *
     * @return {Function} Добавленный обработчик
     */
    function addListener(fn, scope, options) {
        options = Ext.applyIf(options || {}, {
            period: 1
        });
        listeners.push({
            fn: fn,
            options: options,
            left: options.period,
            scope: scope || window
        });
        return fn;
    }
    /**
     * Удаляет обработчик
     * @param {Function} fn (required)   
     * @param {Object} scope
     */
    function removeListener(fn, scope) {
        Ext.Array.each(listeners, function(listener, index) {
            if (listener.fn === fn && (!scope || listener.scope === scope)) {
                Ext.Array.erase(listeners, index, 1);
                return false;
            }
        });
    }
    // Запуск тикера
    window.setInterval(function() {
        Ext.Array.each(listeners, function(listener) {
            if (listener) {
                listener.left--;
                if (listener.left <= 0) {
                    listener.fn.call(listener.scope);
                    listener.left = listener.options.period;
                }
            }
        });
    }, 1000);
    return {
        addListener: addListener,
        removeListener: removeListener
    };
}());

//@define ExGods.util.Helper
/**
 * Набор полезных утилиток
 * @author Олег Михайлов
 */
Ext.ns('ExGods.util');
ExGods.util.Helper = {
    /**
    * Раскладывает 16-ое значение цвета в RGB
    * @return Array
    */
    hexToRgb: function(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ] : null;
    },
    /**
     * Экранирует спец. символы регулярных выражений
     */
    escapeRegexp: function(text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    },
    /**
     * Заменяю спец. коды иконок сообщений чата на иконки
     * @param {text/tpl} text Текст сообщения со смайликами в виде тэгов
     * @return {text/tpl} text Текст сообщения со смайликами в виде картинок
     */
    processTextWithSmiles: function(text) {
        var iconCodes = ExGods.ref('images|chat_message_icons').image,
            maxSmiles = parseInt(ExGods.ref('constants|chat_smiles_cap').value),
            smilesCount = 0,
            regexp, keys, value;
        for (var key in iconCodes) {
            keys = key.split('|');
            value = iconCodes[key];
            for (j = 0; j < keys.length; j++) {
                regexp = new RegExp(ExGods.util.Helper.escapeRegexp(keys[j]));
                while (regexp.test(text)) {
                    if (smilesCount < maxSmiles) {
                        text = text.replace(regexp, '<span class="message-icon" style="background-image: url(' + value + ');"></span>');
                        smilesCount++;
                    } else {
                        text = text.replace(regexp, '', 'gi');
                    }
                }
            }
        }
        return text;
    },
    /**
     * Заменяю мат на спецсимволы
     */
    censoreText: function(msg) {
        var me = this,
            mat = ExGods.references.get('constants_list').mat.value,
            msgArr = msg.split(' ');
        Ext.Array.each(msgArr, function(word, i) {
            if (mat.indexOf(word.toLowerCase().replace(/[^A-Za-zА-Яа-я]+/g, '')) != -1)  {
                msgArr[i] = '<' + ExGods.getMsgByKey('chat_censor_text') + '>';
            }
            
        });
        return msgArr.join(' ');
    },
    /**
     * Быстрый доступ к справочнику
     * @param {String} key Ключ вида "ref_name|ref_item_key", ref_name - название справочника; ref_item_key - идентификатор элемента справочника (не обязателен)
     * @return {Mixin} Данные справочника или undefined в случае, если не найден справочник или элемент
     */
    ref: function(key) {
        var parts = key.split('|'),
            ref = ExGods.app.references.get(parts[0]);
        if (ref) {
            if (parts.length > 1) {
                return ref.get(parts[1]);
            } else {
                return ref;
            }
        } else {
            return undefined;
        }
    },
    /**
     * Вернет сообщение из справочника клиентских сообщений
     * @param {String} key Идентификатор сообщения в справочнике
     * @return {String}
     */
    getMsgByKey: function(key, defaultMsg) {
        return ExGods.ref('message_client|' + key) || defaultMsg || '';
    },
    /**
     * Вернет ссылку на профиль пользователя в соц. сети 
     * @param {socialNetName}
     * @param {socialNetId}
     */
    getUserSocialNetLink: function(socialNetName, socialNetId) {
        var link = '#';
        switch (socialNetName) {
            case 'fb':
                link = 'http://fb.com/profile.php?id=' + socialNetId;
                break;
            case 'vk':
                link = 'http://vk.com/id' + socialNetId;
                break;
            case 'vka':
                link = 'http://vk.com/id' + socialNetId;
                break;
            case 'ok':
                link = 'http://odnoklassniki.ru/profile/' + socialNetId;
                break;
            case 'oka':
                link = 'http://odnoklassniki.ru/profile/' + socialNetId;
                break;
            case 'tw':
                link = 'http://twitter.com/' + socialNetId;
                break;
            case 'mm':
                link = 'http://my.mail.ru/mail/' + socialNetId;
                break;
            case 'mma':
                link = socialNetId;
                break;
            default:
                break;
        }
        return link;
    },
    maskElement: function(element) {
        element.mask(ExGods.getMsgByKey('wait_message'), 'local-mask').addCls('global-mask');
    },
    /**
     * Парсит html и заменяет компонентную вёрстку на компоненты ExtJS
     * @param {HTMLElement} el Куда будет отрисован компонент
     * @param {Ext.container.Container} parent Родительский контейнер, к которому будет привязан компонент
     */
    renderComponents: function(el, parent) {
        var nodeToConfig = function(node) {
                var config;
                if (node.nodeName == 'SPAN' || node.nodeName == 'DIV' || node.nodeName == 'LI') {
                    config = {};
                    Ext.Array.each(node.children, function(child) {
                        if (child.attributes && child.attributes.role) {
                            var key = child.attributes.role.value.split(':'),
                                value;
                            value = nodeToConfig(child);
                            if (key.length > 1) {
                                // приводим value к типу
                                if (key[1] == 'int') {
                                    value = parseInt(value);
                                } else if (key[1] == 'bool') {
                                    value = value === 'true' || value == 1;
                                } else if (key[1] == 'object') {
                                    value = Ext.JSON.decode(value);
                                }
                            }
                            config[key[0]] = value;
                        }
                    });
                    if (Ext.Object.isEmpty(config)) {
                        config = node.innerHTML;
                    }
                } else if (node.nodeName == 'UL') {
                    config = [];
                    Ext.Array.each(node.children, function(child) {
                        config.push(nodeToConfig(child));
                    });
                }
                return config;
            };
        Ext.fly(el).select('.component').each(function() {
            var el = this,
                config, cmp;
            config = nodeToConfig(el.dom);
            config.renderTo = el;
            el.setHTML('');
            cmp = Ext.widget(config.xtype, config);
            if (parent) {
                if (parent.getRefItems) {
                    // если указан родительский контейнер, то переопределяю его метод getRefItems, чтобы он возвращал ещё и этот компонент
                    // getRefItems - используется в ComponentQuery при поиске компонентов через метод query                 
                    var originalFn = parent.getRefItems;
                    parent.getRefItems = function(deep) {
                        var me = this,
                            items = originalFn.apply(parent, arguments);
                        items.push(cmp);
                        if (deep && cmp.getRefItems) {
                            items.push.apply(items, cmp.getRefItems(true));
                        }
                        return items;
                    };
                }
                cmp.mon(parent, 'afterlayout', function() {
                    if (cmp.updateLayout) {
                        cmp.updateLayout();
                    }
                });
                cmp.mon(parent, 'destroy', function() {
                    if (cmp.el.dom) {
                        cmp.destroy();
                    }
                });
            }
        });
    },
    /**
     * Удаляет компоненты, созданные через renderComponents
     * @param {HTMLElement} el Где отрисованы компоненты
     * @param {Ext.container.Container} parent Родительский контейнер, к которому будет были привязаны
     */
    destroyComponents: function(el) {
        Ext.fly(el).select('.component').each(function() {
            var el = Ext.get(this),
                cmpEl, cmp;
            if (el) {
                cmpEl = el.child('*');
                if (cmpEl) {
                    cmp = Ext.getCmp(cmpEl.id);
                    if (cmp) {
                        cmp.destroy();
                    }
                }
            }
        });
    },
    /**
     * Подгружает прототипов (предметов, фич, etc)
     * @param {Mixed} data Данные, содержащие информацию о предметах
     * @param {String} path Путь до proto_id в data в формате "<key_name1>.<key_name2>.<..". Несколько путей разделяются '|'
     * @param {String} typeOfProto Тип прототипа. Может быть "item", "feature". По умолчанию, "item".
     */
    loadProtos: function(data, path, callback, typeOfProto) {
        var store = typeOfProto == "feature" ? ExGods.app.getFeaturePrototypesStore() : ExGods.app.getItemPrototypesStore(),
            ids = [],
            findProtoIds = function(data, path, index) {
                var key = path[index++],
                    ids;
                if (key) {
                    if (data[key]) {
                        if (Ext.isArray(data[key])) {
                            ids = Ext.Array.map(data[key], function(item) {
                                return findProtoIds(item, path, index);
                            });
                            return Ext.Array.clean(Ext.Array.flatten(ids));
                        } else {
                            return findProtoIds(data[key], path, index);
                        }
                    } else {
                        if (Ext.isArray(data)) {
                            return Ext.Array.map(data, function(item) {
                                return findProtoIds(item[key], path, index);
                            });
                        } else {
                            return [];
                        }
                    }
                } else // ключ не найден
                {
                    if (typeOfProto == 'feature') {
                        return data;
                    } else {
                        return [
                            parseInt(data) || null
                        ];
                    }
                }
            };
        callback = callback || Ext.emptyFn;
        Ext.Array.each(path.split('|'), function(path) {
            ids = ids.concat(findProtoIds(data, path.split('.'), 0));
        });
        if (ids.length) {
            store.loadNew(Ext.Array.unique(ids), function() {
                callback();
            });
        } else {
            callback();
        }
    },
    /**
     * Подгружает прототипы из имущества.
     * Поддерживается подгрузка прототипов предметов, фич
     */
    loadProtosFromStuff: function(stuff, callback) {
        var me = this,
            items = [],
            features = [];
        try {
            stuff = Ext.isArray(stuff) ? stuff : [
                stuff
            ];
            for (var i = 0; i < stuff.length; i++) {
                if (stuff[i].type == 'item') {
                    items.push(stuff[i]);
                } else if (stuff[i].type == 'feature') {
                    features.push(stuff[i]);
                }
            }
        } catch (err) {
            me.log('error', 'Пришел некоректный стафф.', err);
            items = [];
        }
        me.loadProtos(items, 'params.id', function() {
            me.loadProtos(features, 'params.id', callback, 'feature');
        });
    },
    /**
     * Вернёт сумму двух имуществ
     */
    sumStuff: function(stuff1, stuff2) {
        var result;
        stuff1 = Ext.isArray(stuff1) ? stuff1 : [
            stuff1
        ];
        stuff2 = Ext.isArray(stuff2) ? stuff2 : [
            stuff2
        ];
        result = Ext.clone(stuff1);
        Ext.Array.each(stuff2, function(s1) {
            var calculated = false;
            Ext.Array.each(result, function(s2) {
                if (s1.type == s2.type) {
                    if ((s1.type == 'expa' || s1.type == 'trophy') || ((s1.type == 'currency' || s1.type == 'timed') && s1.params.id == s2.params.id)) {
                        s2.params.quantity += s1.params.quantity;
                        calculated = true;
                    }
                }
            });
            if (!calculated) {
                result.push(s1);
            }
        });
        return result;
    },
    /**
     * Суммирует элементы имущества одного типа, если возможно
     * @param stuff Имущество
     * @param options Настройки:
     *  - flatItems {Boolean} Суммировать ли предметы по прототипу. По умолчанию, не суммирует
     */
    flatStuff: function(stuff, options) {
        var result;
        options = options || {};
        stuff = Ext.clone(Ext.isArray(stuff) ? stuff : [
            stuff
        ]);
        result = [];
        Ext.Array.each(stuff, function(s1) {
            var calculated = false;
            Ext.Array.each(result, function(s2) {
                if (s1.type == s2.type) {
                    if ((s1.type == 'expa' || s2.type == 'trophy') || (s1.type == 'currency' || s1.type == 'timed' || s1.type == 'ingredients' || (s1.type == 'item' && options.flatItems)) && s1.params.id == s2.params.id) {
                        s2.params.quantity += s1.params.quantity;
                        calculated = true;
                    }
                }
            });
            if (!calculated) {
                result.push(s1);
            }
        });
        return result;
    },
    //тут храняться все таймеры для функции ExGods.util.Helper.startMenuTimer
    timerTickListener: [],
    /**
     * Рисуем таймер на меню, до конечного времени.
     *
     * menuId - string - Идентификатор меню где нужно рисовать таймер
     * timerId - string - Идентификатор самого таймера
     * endTime - time - Время до которого нужно рисовать таймер
     * callBackFunction - function - Действия после окончания таймера
     */
    startMenuTimer: function(menuId, timerId, endTime, callBackFunction) {
        var me = this;
        me.stopMenuTimer(timerId);
        var el = Ext.fly(menuId).insertHtml('beforeEnd', ExGods.util.Timers.printRestTimer(timerId, endTime, {
                needNormalized: true,
                format: 'twonums',
                cls: 'mainmenu-timer'
            }), true);
        el.dom.id = timerId;
        ExGods.util.Timers.on(timerId + '-expire', callBackFunction || Ext.emptyFn);
    },
    stopMenuTimer: function(timerId) {
        if (Ext.fly(timerId)) {
            Ext.fly(timerId).remove();
        }
    },
    /**
     * Рисуем квадратный таймер на элементе
     *
     * endTime - time - Время окончания
     * startTime - time - Время начала
     * pauseTime - time - Состояние в котором находится таймер (если нет, то будет текущее время)
     * intervalsContainer - function - Контейнер таймеров
     * intervalId - string - Идентификатор таймера в контейнере таймеров
     * elementId - string - Элемент в котором рисовать таймер
     * squareWidthOfSide - int - Ширина и высота таймера
     * aditionalTimer - function - Дополнительный таймер
     */
    createSquareTimer: function(endTime, startTime, pauseTime, intervalsContainer, intervalId, elementId, squareWidthOfSide, aditionalTimer) {
        //текущее время никак не будет меньше млн, так что проверяю приходит время или не время через сравнение с 1 млн
        var end_sec_time, start_sec_time, pause_sec_time;
        if (typeof endTime != 'number' || endTime > 1000000) {
            end_sec_time = endTime;
            start_sec_time = startTime;
            pause_sec_time = pauseTime;
        } else {
            end_sec_time = startTime;
            start_sec_time = endTime;
            pause_sec_time = startTime - pauseTime;
        }
        if (end_sec_time == start_sec_time)  {
            return;
        }
        
        //если вдруг возникнет такая ситация, чтобы не повисал браузер (но такой ситуации не должно быть)
        var isTimerFreeze = pauseTime;
        if (isTimerFreeze) {
            timeLeft = end_sec_time - pause_sec_time;
        } else {
            timeLeft = end_sec_time - new Date().getTime();
        }
        if (timeLeft) {
            var arr = [],
                curTime = new Date(),
                intervalFn = (intervalsContainer) ? intervalsContainer[intervalId] : undefined,
                x, y, i, poly, time, ticks, tickTime;
            //время от паузы до конца или от текущего момента до конца
            if (isTimerFreeze) {
                i = Math.ceil(360 - timeLeft * 360 / (end_sec_time - start_sec_time));
                tickTime = Math.round((end_sec_time - start_sec_time) / 360);
            } else {
                i = Math.ceil(360 - timeLeft * 360 / (end_sec_time - start_sec_time));
                tickTime = Math.round((end_sec_time - start_sec_time) / 360);
            }
            if (intervalFn) {
                clearInterval(intervalFn);
            }
            for (; i < 361; i++) {
                if (i <= 45) {
                    x = Math.round(squareWidthOfSide / 2 + squareWidthOfSide * i / 90);
                    y = 0;
                } else if (i > 45 && i <= 135) {
                    x = squareWidthOfSide;
                    y = Math.round(squareWidthOfSide * (i - 45) / 90);
                } else if (i > 135 && i <= 225) {
                    x = Math.round(squareWidthOfSide * (90 - (i - 135)) / 90);
                    y = squareWidthOfSide;
                } else if (i > 225 && i <= 315) {
                    x = 0;
                    y = Math.round(squareWidthOfSide * (90 - (i - 225)) / 90);
                } else if (i > 315) {
                    x = Math.round(squareWidthOfSide * (i - 315) / 90);
                    y = 0;
                }
                arr.push([
                    x,
                    y
                ]);
            }
            if (arr.length) {
                arr.push([
                    squareWidthOfSide / 2,
                    squareWidthOfSide / 2
                ]);
            } else  {
                return;
            }
            
            if (!isTimerFreeze) {
                intervalsContainer[intervalId] = setInterval(function() {
                    var el = Ext.get(elementId);
                    if (arr.length) {
                        if (el) {
                            if (el.down('svg') && poly) {
                                poly.plot(arr);
                            } else {
                                if (el.down('svg'))  {
                                    el.down('svg').remove();
                                }
                                
                                var svg = SVG(elementId).size(squareWidthOfSide, squareWidthOfSide);
                                poly = svg.polygon(arr).fill('black').opacity(0.5);
                            }
                        }
                        time = new Date();
                        ticks = Math.round((time - curTime) / tickTime);
                        curTime = time;
                        arr.splice(0, ticks);
                    } else {
                        clearInterval(intervalsContainer[intervalId]);
                        delete intervalsContainer[intervalId];
                        if (el)  {
                            el.remove();
                        }
                        
                    }
                }, tickTime);
                if (aditionalTimer)  {
                    aditionalTimer();
                }
                
            }
            setTimeout(function() {
                var el = Ext.get(elementId);
                if (arr.length) {
                    if (el) {
                        if (!el.down('svg')) {
                            var svg = SVG(elementId).size(squareWidthOfSide, squareWidthOfSide);
                            poly = svg.polygon(arr).fill('black').opacity(0.5);
                        }
                    }
                }
            }, 0);
        }
    },
    /**
     * подсветка элемента спрайтом
     * 
     * el {Ext.Element} - элемент внутри которого будет обыгрываться анимация
     * cls - css класс самого элемента со спрайтом анимации - картинка спрайта в классе
     * iters - количество итераций в анимации
     * deltaY - шаг картинки спрайта
     * interval - интервал между итерациями
     * callback - функция по окончанию анимации
     */
    shine: function(el, cls, iters, deltaY, interval, callback) {
        var shine = el.insertHtml('beforeEnd', '<div class="' + cls + '"></div>', true),
            i = 0;
        (function() {
            if (i < iters) {
                i++;
                shine.setStyle('background-position', '0 ' + (deltaY * i) + 'px');
                setTimeout(arguments.callee, interval);
            } else {
                shine.remove();
                if (callback) {
                    callback();
                }
            }
        })();
        return shine;
    },
    /**
     * Анимация валюты
     *
     * @params
     *  ct - DOM-элемент где будет показана анимация
     *  stuff - имущество
     *  callback - fn по завершнию
     *  extraCls - доп. класс элемента анимации
     *
     * @return DOM-элемент анимации
     */
    animateCurrency: function(ct, stuff, callback, extraCls) {
        var me = this,
            _getDigits = function(num) {
                var digits = [];
                num = num + '';
                for (var i = 0; i < num.length; i++) {
                    digits.push(num.substr(i, 1));
                }
                return digits;
            },
            iters = 0,
            timePerIter = ExGods.ref('constants|bot_banish_anim_spf').value,
            interval, el, currency, digits, icon,
            html = [];
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        callback = callback || Ext.emptyFn;
        Ext.Array.each(stuff, function(s) {
            if (s.type == 'currency' && (s.params.id == 'gold' || s.params.id == 'crystal')) {
                currency = s;
            }
        });
        if (currency) {
            icon = IMAGE_URL + (currency.params.id == 'gold' ? 'currency/anim/coin.png' : 'currency/anim/crystal.png');
            digits = _getDigits(currency.params.quantity);
            html = [
                '<div class="currency-anim ' + extraCls + '">',
                '<div class="icon" style="background-image: url(' + icon + ')"></div>'
            ];
            for (var i = 0; i < digits.length; i++) {
                html.push('<div class="digit" style="background-image: url(' + IMAGE_URL + 'currency/anim/numbers.png); background-position: 0 ' + (-31 * digits[i] - 5) + 'px"></div>');
            }
            html.push('</div>');
            el = Ext.get(ct).insertHtml('beforeEnd', html.join(''), true);
            interval = setInterval(function() {
                iters = ++iters % 31;
                if (currency.params.id == 'gold') {
                    el.select('.icon').applyStyles({
                        'background-position': '-3px ' + (-33 * iters - 8) + 'px'
                    });
                } else {
                    el.select('.icon').applyStyles({
                        'background-position': '-3px ' + (-36 * iters - 13) + 'px'
                    });
                }
            }, timePerIter);
            el.animate({
                duration: ExGods.ref('constants|bot_banish_anim_time1').value,
                easing: 'cubic-bezier(0, 0, 1, 1)',
                from: {
                    top: ExGods.ref('constants|bot_banish_anim_y_from').value + 'px'
                },
                to: {
                    top: ExGods.ref('constants|bot_banish_anim_y_to').value + 'px'
                },
                callback: function() {
                    clearInterval(interval);
                    el.remove();
                    if (callback) {
                        callback();
                    }
                }
            });
            return el;
        } else {
            callback();
            return null;
        }
    },
    /**
     * Проверяет на равенства a и b, которые могут быть строкой, числом, объектом, массивом и прочее
     */
    isEqual: function(a, b) {
        var me = this;
        if (Ext.isDate(a) && Ext.isDate(b)) {
            return a.getTime() === b.getTime();
        }
        if (Ext.isArray(a) && Ext.isArray(b)) {
            if (a.length != b.length) {
                return false;
            } else {
                var count = a.length;
                Ext.Array.each(a, function(item, index) {
                    if (me.isEqual(a[index], b[index])) {
                        count--;
                    } else {
                        return false;
                    }
                });
                return count ? false : true;
            }
        }
        if (Ext.isObject(a) && Ext.isObject(b)) {
            if (Ext.getClassName(a) && Ext.getClassName(b)) {
                return true;
            }
            if (Ext.Object.getSize(a) != Ext.Object.getSize(b)) {
                return false;
            } else {
                var count = Ext.Object.getSize(a);
                Ext.Object.each(a, function(key, value) {
                    if (me.isEqual(a[key], b[key])) {
                        count--;
                    } else {
                        return false;
                    }
                });
                return count ? false : true;
            }
        }
        return a === b;
    },
    /**
     * Кириллицу в латиницу
     */
    translit: function(text) {
        return text.replace(/([а-яё])|([\s_-])|([^a-z\d])/gi, function(all, ch, space, words, i) {
            if (space || words) {
                return space ? '-' : '';
            }
            var code = ch.charCodeAt(0),
                index = code == 1025 || code == 1105 ? 0 : code > 1071 ? code - 1071 : code - 1039,
                t = [
                    'yo',
                    'a',
                    'b',
                    'v',
                    'g',
                    'd',
                    'e',
                    'zh',
                    'z',
                    'i',
                    'y',
                    'k',
                    'l',
                    'm',
                    'n',
                    'o',
                    'p',
                    'r',
                    's',
                    't',
                    'u',
                    'f',
                    'h',
                    'c',
                    'ch',
                    'sh',
                    'shch',
                    '',
                    'y',
                    '',
                    'e',
                    'yu',
                    'ya'
                ];
            return t[index];
        });
    }
};
// aliases
ExGods.helpme = ExGods.util.Helper;
ExGods.ref = ExGods.util.Helper.ref;
ExGods.getMsgByKey = ExGods.util.Helper.getMsgByKey;

//@define ExGods.util.Timers
/**
 * @class ExGods.util.Timers
 *
 * Позволяет создавать таймеры в html с автомтическим обновлением. Каждый таймер обновляется раз в секунду.
 * Если время таймера истекло, вызывается соответствующее событие.
 *
 * @author Олег Михайлов
 */
Ext.define('ExGods.util.Timers', {
    extend: Ext.util.Observable,
    singleton: true,
    constructor: function() {
        var me = this;
        me.callParent(arguments);
        ExGods.util.Ticker.addListener(me.onTick, me);
    },
    /**
     * Напечать код таймера
     * @param type {String} Тип таймера
     * @param name {String} Название таймера (или группы таймеров). Название нужно для события истечения таймера (см. @method this.onTimerExpired)
     * @param value {Mixed} Начальное значение таймера. В зависимости от типа, это может быть дата или кол-во секунд
     * @param options {Object} Опции:
     *  - format - формат отображения времени (twonums, short, etc). По умолчанию, twonums
     *  - emptyText - строка, отображается когда таймер истёк
     *  - needNormalized True, если дата не нормализована.
     *  - cls Класс, который добавится в элемент таймера
     *  
     */
    printTimer: function(type, name, value, options) {
        var me = this,
            format, html;
        options = options || {};
        if (type == 'rest') {
            if (typeof value == 'string') {
                value = ExGods.util.Date.parseString(value);
            }
            if (options.needNormalized) {
                value = ExGods.util.Date.normalizeServerDateTime(value);
            }
        }
        format = options.format || 'twonums';
        html = '<span class="exg-timer ' + (options.cls ? options.cls : "") + '" data-type="' + type + '" data-name="' + name + '" data-format="' + format + '" data-value="' + value + '" ' + ' data-epmty-text="' + (options.emptyText || '') + '">';
        if (type == 'rest') {
            html += ExGods.util.Time.printRestTime(value, {
                format: format
            });
        }
        html += '</span>';
        return html;
    },
    /**
     * Напечать таймер до определенной даты
     * Паратетры .. (см @method this.printTimer)
     */
    printRestTimer: function(name, value, options) {
        return this.printTimer('rest', name, value, options);
    },
    /**
     * key: ID элемента таймера
     * value: Параметры для отображения
     */
    square_timers: {},
    /**
     * Рисуем квадратный таймер на элементе
     *
     * end - Required {Date|Number} - Время окончания
     * start - {Date|Number} - Время начала
     * pause - {Date|Number} - Состояние в котором находится таймер (если нет, то будет текущее время)
     * side - int - Ширина и высота таймера
     */
    printSquareTimer: function(options) {
        var me = this,
            convert = function(value) {
                if (value instanceof Date) {
                    return value.getTime();
                } else  {
                    return Number(value) || 0;
                }
                
            },
            end = convert(options.end),
            start = convert(options.start),
            pause = convert(options.pause),
            now = Date.now(),
            side = options.side || 50,
            left = end - (pause || now),
            html = '';
        if (!left)  {
            return html;
        }
        
        var points = [],
            i = Math.ceil(360 - left * 360 / (end - start)),
            tick_time = Math.round((end - start) / 360),
            id = 'exg-square-timer-' + Ext.id();
        for (; i < 361; i++) {
            if (i <= 45) {
                points.push([
                    Math.round(side / 2 + side * i / 90),
                    0
                ]);
            } else if (i > 45 && i <= 135) {
                points.push([
                    side,
                    Math.round(side * (i - 45) / 90)
                ]);
            } else if (i > 135 && i <= 225) {
                points.push([
                    Math.round(side * (90 - (i - 135)) / 90),
                    side
                ]);
            } else if (i > 225 && i <= 315) {
                points.push([
                    0,
                    Math.round(side * (90 - (i - 225)) / 90)
                ]);
            } else if (i > 315) {
                points.push([
                    Math.round(side * (i - 315) / 90),
                    0
                ]);
            }
        }
        if (points.length) {
            points.push([
                side / 2,
                side / 2
            ]);
        }
        me.square_timers[id] = {
            pause: pause,
            started_at: pause || now,
            side: side,
            tick_time: tick_time,
            points: points
        };
        //пытаюсь сразу отрисовать таймер, если элемент создается чтобы сразу отрендериться
        setTimeout(function() {
            me.updateSquareTimer(id);
        }, 0);
        return '<div class="exg-square-timer" id="' + id + '"></div>';
    },
    /**
     * @private
     */
    onTick: function() {
        var me = this;
        Ext.select('.exg-timer').each(function(el) {
            if (el.hasCls('exg-timer-expired')) {
                return;
            }
            var timerName = el.dom.getAttribute('data-name'),
                type = el.dom.getAttribute('data-type'),
                value = el.dom.getAttribute('data-value'),
                format = el.dom.getAttribute('data-format'),
                emptyText = el.dom.getAttribute('data-epmty-text'),
                rest;
            if (type == 'rest') {
                value = new Date(Number(value) || value);
                rest = Math.ceil((value - new Date()) / 1000);
                if (rest > 0) {
                    el.setHTML(ExGods.util.Time.printTime(rest, {
                        format: format
                    }));
                } else {
                    el.setHTML(emptyText || '');
                    el.addCls('exg-timer-expired');
                    me.onTimerExpired(timerName, el);
                }
            }
        });
        for (var id in me.square_timers) {
            me.updateSquareTimer(id);
        }
    },
    /**
     * @private
     */
    updateSquareTimer: function(id) {
        var me = this,
            params = me.square_timers[id],
            el = document.getElementById(id),
            timestamp = params.pause || Date.now(),
            i = Math.round((timestamp - params.started_at) / params.tick_time),
            points = params.points.slice(i);
        if (!el)  {
            return;
        }
        
        if (!params.svg) {
            params.svg = SVG(id).size(params.side, params.side);
        }
        if (!params.poly) {
            params.poly = params.svg.polygon(points).fill('black').opacity(0.5);
        }
        if (points.length) {
            params.poly.plot(points);
        } else {
            delete me.square_timers[id];
            el.remove();
            me.fireEvent(id + '-expire');
        }
    },
    /**
     * @private Обработчик истечения таймера
     * @param timerName {String} Название таймера
     * @param el {Ext.dom.Element} DOM элемент таймера
     * @param
     */
    onTimerExpired: function(timerName, el) {
        var me = this;
        me.fireEvent(timerName + '-expire', el);
    }
});

//@define ExGods.util.RemoteDebug
/**
 * Позволяет накапливать и отсылать отладочную информацию на сервер (информация будет доступна в разделе ошибок CMS )
 */
Ext.ns('ExGods.util');
(function() {
    var Debugger = function(config) {
            this.title = config.title;
            this.showInConsole = config.showInConsole;
            this.limit = config.limit;
            this.logs = [];
        };
    Debugger.prototype.log = function(msg) {
        this.logs.push(Ext.Date.format(new Date(), 'H:i:s') + ' ' + msg);
        if (this.showInConsole) {
            console.log(msg);
        }
    };
    Debugger.prototype.clear = function() {
        this.logs = [];
    };
    Debugger.prototype.send = function() {
        var message = '',
            logs = this.logs;
        if (this.limit) {
            logs = logs.slice(Math.max(logs.length - this.limit, 0), logs.length);
        }
        message += logs.join('<br/>');
        message += '<br/>' + Ext.Date.format(new Date(), 'H:i:s') + ' ' + navigator.userAgent;
        Ext.Ajax.request({
            url: 'game.pl?cmd=bugs&autorequest=1',
            params: {
                type: 8,
                subject: this.title,
                message: message
            }
        });
        this.clear();
    };
    ExGods.util.RemoteDebug = {
        debuggers: {},
        factory: function(name, config) {
            this.debuggers[name] = new Debugger(config);
            return this.debuggers[name];
        },
        get: function(name) {
            return this.debuggers[name];
        }
    };
}());

/**
 * Модель локации
 */
Ext.define('ExGodsCore.model.Location', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'action',
            type: 'auto'
        },
        {
            // параметры локации
            name: 'blob',
            convert: function(v) {
                if (v) {
                    // преобразую объекты локации в более удобный вид: каждый объект локации однозначно связан с одним интерактивом;
                    v.objects = (function() {
                        var objects = [];
                        Ext.Array.each(v.objects || [], function(item) {
                            var interactive = item.interactive;
                            Ext.Array.each(interactive, function(interactiveItem) {
                                var itemClone = Ext.clone(item);
                                itemClone.interactive = interactiveItem;
                                objects.push(itemClone);
                            });
                        });
                        return objects;
                    }());
                }
                return v;
            }
        },
        {
            // идентификатор комнаты в чате
            name: 'chat_room_name',
            type: 'string'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            // название комнаты
            name: 'name',
            type: 'string'
        },
        {
            name: 'prototype',
            type: 'auto'
        },
        {
            // список соседних комнат
            name: 'to',
            type: 'auto'
        }
    ],
    /**
     * Возвращает адрес картинки локации
     * @return {String} Адрес картинки
     */
    getThumb: function() {
        return this.get('blob').thumb ? IMAGE_URL + this.get('blob').thumb : Ext.BLANK_IMAGE_URL;
    },
    /**
     * Возвращает название локации
     * @return {String} Название локации
     */
    getName: function() {
        return this.get('name');
    },
    /**
     * Возвращает адрес картинки локации
     * @return {String} Адрес картинки
     */
    getImage: function() {
        return IMAGE_URL + this.get('blob').image || Ext.BLANK_IMAGE_URL;
    },
    getType: function() {
        return this.get('prototype').type;
    },
    /**
     * Вернет массив интерактивных объектов локации
     * @return {Array} Массив объектов вида:
     *      {
     *          type - тип объета,
     *          params_type - параметры объекта 
     *          interactive - параметры для отображения
     *          description - текстовое описание 
     *      }
     */
    getObjects: function() {
        return this.get('blob').objects || [];
    },
    /**
     * Вернет прототип локации
     * @return {Object}
     */
    getProto: function() {
        var me = this,
            proto = me.get('prototype');
        if (typeof proto == "object") {
            return proto;
        } else {
            return ExGodsCore.references.get('prototypes_rooms').get(parseInt(proto, 10));
        }
    },
    /**
     * Вернет true, если локация опасна
     */
    isDanger: function() {
        var me = this;
        return this.getProto().blob.danger === "1";
    }
});

/**
 * Список всех локаций
 */
Ext.define('ExGods.store.Locations', {
    extend: Ext.data.Store,
    model: 'ExGodsCore.model.Location'
});

/**
 * Базовая модель пользователя
 *
 * Есть одна особенность у этой модели. Для фукции set нужно использовать только
 * один аргумент типа Object.
 */
Ext.define('ExGodsCore.model.BasicUser', {
    extend: Ext.data.Model,
    idProperty: 'title',
    fields: [
        {
            // привязки
            name: 'binding',
            type: 'auto',
            convert: function(v, rec) {
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key, value, myself) {
                        if (value)  {
                            myself[key] = parseInt(myself[key]);
                        }
                        else  {
                            myself[key] = 0;
                        }
                        
                    });
                }
                return v;
            }
        },
        {
            // отображаемое имя
            name: 'display_title',
            type: 'string'
        },
        {
            // пол
            name: 'gender',
            type: 'string'
        },
        {
            // накопительные характеристики
            name: 'hoard',
            type: 'auto',
            convert: function(v, rec) {
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key, value, myself) {
                        if (value)  {
                            myself[key] = parseInt(myself[key]);
                        }
                        else  {
                            myself[key] = 0;
                        }
                        
                    });
                }
                return v;
            }
        },
        {
            name: 'id',
            type: 'int'
        },
        {
            // признак ментора
            name: 'is_mentor',
            type: 'int'
        },
        {
            // уровень модерирования
            name: 'moder',
            type: 'int'
        },
        {
            // онлайн состояние
            name: 'online',
            type: 'int'
        },
        {
            // раса
            name: 'race',
            type: 'int'
        },
        {
            // признак готовности начать обучение
            name: 'ready_pupil',
            type: 'int'
        },
        {
            name: 'reg_date',
            type: 'date',
            dateFormat: serverDateTimeFormat
        },
        {
            // привязка к аватару
            name: 'shape',
            type: 'auto'
        },
        {
            // уникальное имя
            name: 'title',
            type: 'string'
        },
        {
            // уникальное имя
            name: 'rating_rank',
            type: 'number'
        },
        /*
         * Специфичные для ботов параметры
         */
        {
            name: 'bot_data',
            type: 'auto'
        },
        /*
         * Состояние бота
         */
        {
            name: 'bot_state',
            type: 'auto'
        },
        {
            /**
         * Флаг - защита от нападения
         */
            name: 'attack_immune',
            type: 'int',
            convert: function(v) {
                if (v && typeof v == 'object') {
                    // может быть объектом в текущей реализации. Нам важно просто наличие                   
                    return 1;
                } else {
                    return parseInt(v, 10);
                }
            }
        },
        {
            // все характеристики
            name: 'stats',
            type: 'auto'
        }
    ],
    /**
     * Возвращает аватар персонажа
     * 
     * @return {String}
     */
    getAvatar: function() {
        return this.getShape().avatar;
    },
    /**
     * Возвращает аватар персонажа для инвенторя
     *
     * @return {String}
     */
    getInventoryAvatar: function() {
        return this.getShape().full;
    },
    /**
     * Возвращает уровень персонажа
     * 
     * @return {Number}
     */
    getLevel: function() {
        return this.get('hoard').level;
    },
    getLocation: function() {
        return this.get('binding').room;
    },
    /**
     * Возвращает всю информаци о внешности персонажа из справочника shapes (справочник автаров пользователей и ботов)
     */
    getShape: function() {
        var shape = this.get('shape');
        if (typeof shape == 'object') {
            return {
                thumb: shape.small ? (/^http/.test(shape.small) ? shape.small : IMAGE_URL + shape.small) : Ext.BLANK_IMAGE_URL,
                avatar: shape.medium ? (/^http/.test(shape.medium) ? shape.medium : IMAGE_URL + shape.medium) : Ext.BLANK_IMAGE_URL,
                full: shape.large ? (/^http/.test(shape.large) ? shape.large : IMAGE_URL + shape.large) : Ext.BLANK_IMAGE_URL,
                battle: shape.battle ? (/^http/.test(shape.battle) ? shape.battle : IMAGE_URL + shape.battle) : Ext.BLANK_IMAGE_URL
            };
        } else {
            return ExGodsCore.app.references.get('user_shape').getByKey(shape);
        }
    },
    /**
     * Возвращает URL маленького аватара персонажа
     * @return {String}
     */
    getThumb: function() {
        var shape = this.getShape();
        if (shape) {
            return shape.thumb;
        } else {
            return '';
        }
    },
    /**
     * Возвращает один из трёх типов пользователя: игрок, бот (с которым можно подраться) или npc
     * @return {String}
     */
    getType: function() {
        var botData = this.get('bot_data');
        if (!botData) {
            return 'user';
        } else if (botData.hostile) {
            return 'bot';
        } else {
            return 'npc';
        }
    },
    getWorld: function() {
        return this.get('binding').world;
    },
    getGuild: function() {
        return this.get('binding').guild;
    }
});

/**
 * Модель навыков
 */
Ext.define('ExGodsCore.model.Feature', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'comment',
            type: 'string'
        },
        {
            name: 'created',
            type: 'string'
        },
        {
            name: 'ended',
            type: 'auto'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'hidden',
            type: 'int',
            defaultValue: 0
        },
        {
            name: 'source',
            type: 'string'
        },
        {
            // номер текущего шага действия фичи
            // например, время жизни фичи 4 шага (свойство "turn") текущий шаг - 2
            name: 'step',
            type: 'int'
        },
        {
            name: 'talant',
            type: 'int'
        },
        {
            // прототип фичи
            name: 'proto',
            type: 'string'
        },
        {
            // тип фичи
            name: 'type',
            type: 'string'
        },
        {
            // время действия фичи в шагах (см. также свойство "step")
            name: 'turn',
            type: 'int'
        },
        {
            name: 'value',
            type: 'auto'
        }
    ]
});

/**
 * Модель предмета
 */
Ext.define('ExGodsCore.model.Item', {
    extend: Ext.data.Model,
    idProperty: 'item_id',
    fields: [
        {
            name: 'item_id',
            type: 'int'
        },
        {
            name: 'param',
            type: 'auto'
        },
        {
            name: 'features',
            type: 'auto'
        },
        {
            name: 'proto_id',
            type: 'int'
        },
        {
            name: 'slot_id',
            type: 'int'
        },
        {
            // признак, что предмет надет
            name: 'clothed',
            type: 'int'
        },
        // для стекового предмета
        {
            name: 'stack_ids',
            type: 'auto'
        },
        // для стекового предмета
        {
            name: 'groupdur',
            type: 'auto'
        },
        {
            name: 'count',
            type: 'int'
        }
    ],
    proxy: 'memory',
    /**
     * Возвращает прототип предмета
     * 
     * @return {ExGods.model.ItemPrototype}
     */
    getProto: function() {
        return ExGods.app.getItemPrototypesStore().data.getByKey(this.get('proto_id'));
    },
    getType: function() {
        var proto = this.getProto(),
            type = proto.get('type');
        return ExGodsCore.app.references.get('item_type').getByKey(type);
    },
    /**
     * Вернет текущую прочность предмета
     */
    getDur: function() {
        return parseInt(this.get('param').dur);
    },
    /**
     * Вернет максимальную прочность предмета
     */
    getMaxDur: function() {
        var proto = this.getProto();
        if (proto) {
            return this.getProto().get('param').dur;
        }
    },
    /**
     * Вернет истину, если предмет поврежден
     */
    isDamaged: function() {
        var me = this;
        return me.getDur() < me.getProto().get('param').dur;
    },
    /**
     * true, если предмет имеет усиление
     */
    isUpgraded: function() {
        return this.get('param').upgrades > 0;
    },
    // isEqual: function(a, b) {
    //  if (Ext.isDate(a) && Ext.isDate(b)) {
    //      return a.getTime() === b.getTime();
    //  }
    //  return a === b;
    // },
    /**
     * Определяет ломаемый ли предмет
     *
     * @return {Boolean}
     */
    isBreakable: function() {
        return !parseInt(this.get('param').nonbr);
    },
    /**
     * Определяет, находится ли прочность предмета в критическом состоянии
     *
     * @return {Boolean}
     */
    hasCriticalDurability: function() {
        var me = this,
            breakable = me.isBreakable(),
            dur = me.getDur(),
            maxDur = me.getMaxDur();
        // если макс. возможная прочность == 1, считаем, что такой предмет не находится в критическом состоянии
        return breakable && dur && maxDur > 1 && dur <= ExGodsCore.app.references.get('constants').get('critical_item_durability').value;
    },
    /**
     * Рассчитать цену предмета
     *
     * @param {Number} cost Базовая расчетная стоимость
     * @param {Boolean} allInStack Расчитать цену предмета, включая его стек (если есть). Default false
     * @param {Boolean} format Отформатировать цену или нет. Default false
     *
     * @return {Number/String} Стоимость предмета
     */
    calcPrice: function(cost, withStack, format) {
        var me = this,
            k = ExGodsCore.app.references.get('constants').get('sell_wear_percent').value / 100,
            dur = me.getDur(),
            maxDur = me.getProto().get('param').dur,
            count = me.get('count'),
            price = Math.floor(cost * (1 - (1 - dur / maxDur) * (1 - k)));
        if (withStack && count) {
            price *= count;
        }
        return format ? Ext.util.Format.number(price, '0,0') : price;
    },
    /**
     * Вернет true, если срок действия предмета истек
     */
    isExpired: function() {
        var me = this,
            validto = me.getProto().get("data").validto,
            expire = me.get('param').expire_str,
            now = new Date();
        if (validto) {
            validto = ExGodsCore.util.Date.normalizeServerDateTime(validto);
        } else {
            validto = 0;
        }
        if (expire) {
            expire = ExGodsCore.util.Date.normalizeServerDateTime(expire);
        } else {
            expire = 0;
        }
        expire = Math.max(expire, validto);
        if (expire != 0 && expire - now < 0) {
            return true;
        } else {
            return false;
        }
    }
});

/**
 * Слот для предметов
 */
Ext.define('ExGodsCore.model.Slot', {
    extend: Ext.data.Model,
    idProperty: 'ekey',
    fields: [
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'ekey',
            type: 'int'
        },
        {
            name: 'type',
            type: 'int'
        },
        {
            name: 'protect',
            type: 'auto'
        },
        {
            name: 'features',
            type: 'auto'
        },
        {
            name: 'items',
            type: 'auto',
            convert: function(itemsData, record) {
                if (!itemsData)  {
                    return itemsData;
                }
                
                var me = this,
                    items = record.itemsStore,
                    missedProtos = [],
                    protos = ExGodsCore.app.getItemPrototypesStore(),
                    cntByProtoId = new Ext.util.HashMap(),
                    cntByProtoIdNew = new Ext.util.HashMap();
                var collectIds = function(cntByProtoId) {
                        var res = [];
                        items.each(function(rec) {
                            if (rec.isExpired()) {
                                return;
                            }
                            var cnt = rec.get('count');
                            var cnt__ = cntByProtoId.get(rec.get('proto_id')) ? cntByProtoId.get(rec.get('proto_id')) : 0;
                            cnt += cnt__;
                            cntByProtoId.add(rec.get('proto_id'), cnt);
                            var stack_ids = rec.get('stack_ids');
                            if (Ext.isArray(stack_ids)) {
                                res = Ext.Array.merge(res, stack_ids);
                            } else {
                                res.push(rec.get('item_id'));
                            }
                        });
                        return res;
                    };
                // сохраняю старые ids для проверки на новые предметы
                collectIds(cntByProtoId);
                // пробегаемя по всем предметам в поисках незагруженных прототипов
                Ext.Array.forEach(itemsData, function(item) {
                    var proto_id = parseInt(item.proto_id);
                    if (!protos.data.getByKey(proto_id) && !Ext.Array.contains(missedProtos, proto_id)) {
                        missedProtos.push(proto_id);
                    }
                });
                protos.loadNew(missedProtos, function() {
                    var grouped = record.groupItems(itemsData);
                    if (!items.isDestroyed) {
                        items.loadRawData(grouped);
                    }
                    // в поисках новых предметов
                    collectIds(cntByProtoIdNew);
                    var newCntItems = 0;
                    cntByProtoIdNew.each(function(rec, val) {
                        var oldVal = cntByProtoId.get(rec) ? cntByProtoId.get(rec) : 0;
                        val -= oldVal;
                        newCntItems += val;
                    });
                    if (newCntItems > 0) {
                        record.fireEvent('newitemsadded', record, {
                            length: newCntItems
                        });
                    }
                });
                return items;
            }
        }
    ],
    proxy: 'memory',
    constructor: function(config) {
        var me = this;
        me.itemsStore = Ext.create('Ext.data.Store', {
            model: 'ExGodsCore.model.Item'
        });
        me.callParent(arguments);
    },
    //
    // @oleg commented cause addEvents is deprecated in 5.1.1
    //
    // me.addEvents(
    //  /**
    //   * @event newitemsadded
    //   * Срабатывает при добавлении новых предметов в слот
    //   */
    //  'newitemsadded',
    //  *
    //   * @event highlight
    //   * Указывает на необходимость подсветить слот
    //  'highlight',
    //  /**
    //   * @event unhighlight
    //   * Указывает на необходимость убрать подсвтку слота
    //   */
    //  'unhighlight'
    // );
    /**
     * Событие изменения данных пользователя
     * @private
     */
    afterEdit: function() {
        var me = this,
            changes = me.getChanges();
        /**
         * @event change
         * Срабатывает, когда информация персонажа изменилась
         * @param {Ext.Component} this
         */
        me.fireEvent('change', me);
        if (changes.protect) {
            me.fireEvent('protect', me);
        }
    },
    /**
     * Возвращает хранилище предметов слота
     * @return {Ext.data.Store} Хранилище предметов
     */
    items: function() {
        return this.itemsStore;
    },
    /**
     * Группирует стековые предметы
     * 
     * Note: предметы группируются по прототипу.
     * По геймдизайну предполагается, что стековые предметы имеют одинаковые характеристики.
     *
     * @param {Array} items Предметы
     */
    groupItems: function(items) {
        var groups = new Ext.util.HashMap(),
            protos = ExGodsCore.app.getItemPrototypesStore(),
            newItems = [],
            groupedItem,
            i = 0,
            item;
        // сортирую предметы так, чтобы в начале шли предметы из магазина, чтобы в стеке шли сначала магазинные предметы. тогда,
        // любые действия над предметом в стеке (продажа, исползование) сначала совершается с предметами из магазина
        items.sort(function(a, b) {
            if (a.param.from_shop == 1 && b.param.from_shop != 1) {
                return 1;
            } else if (b.param.from_shop == 1 && a.param.from_shop != 1) {
                return -1;
            } else {
                return 0;
            }
        });
        for (; i < items.length; i++) {
            var item = items[i],
                proto_id = parseInt(item.proto_id),
                proto = protos.data.getByKey(proto_id);
            if (proto.isStack()) {
                // ссылка на ранее сгруппированный предмет
                groupedItem = groups.get(proto_id);
                if (groupedItem) {
                    groupedItem.stack_ids.push(parseInt(item.item_id));
                    groupedItem.groupdur += parseInt(item.param.dur);
                    groupedItem.count += parseInt(item.param.count) || 1;
                } else {
                    item.stack_ids = [
                        parseInt(item.item_id)
                    ];
                    item.groupdur = parseInt(item.param.dur);
                    item.count = parseInt(item.param.count) || 1;
                    groups.add(proto_id, item);
                    newItems.push(item);
                }
            } else {
                item.count = parseInt(item.param.count) || 1;
                newItems.push(item);
            }
        }
        return newItems;
    },
    /**
     * @deprecated Instead use getSlotTypeInfo
     * 
     * Возвращает тип слопа
     * @return {Object} Тип слота
     */
    getSlotType: function() {
        return ExGodsCore.app.references.get('slot_type').getByKey(this.get('type'));
    },
    /**
     * Вернет всю информацию по типу слота из соответсвующего справочника
     * @return {Object} Тип слота
     */
    getSlotTypeInfo: function() {
        return ExGodsCore.app.references.get('slot_type').getByKey(this.get('type'));
    },
    /**
     * Уничтожает все хранилища модели
     */
    destroyStores: function() {
        var me = this;
        if (me.itemsStore) {
            me.itemsStore.destroyStore();
            me.itemsStore = null;
        }
    },
    checkExpired: function(onExpire) {
        var me = this,
            expired = [];
        me.itemsStore.each(function(item) {
            if (item.isExpired()) {
                expired.push(item);
            }
        });
        if (expired.length) {
            me.itemsStore.remove(expired);
            if (onExpire) {
                onExpire(expired);
            }
        }
    }
});

/**
 * Слоты пользователя, в которых храняться предметы
 */
Ext.define('ExGodsCore.store.Slots', {
    extend: Ext.data.Store,
    model: 'ExGodsCore.model.Slot',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'type',
            direction: 'ASC'
        }
    ],
    /**
     * Вернет слоты с размещением "Образы", если есть 
     * @return {Array}
     */
    getShapesSlots: function() {
        var me = this,
            result = [];
        me.each(function(slot) {
            var slotType = ExGodsCore.app.references.get('slot_type').getByKey(slot.get('type'));
            if (slotType && slotType.active == 3) {
                result.push(slot);
            }
        });
        return result;
    },
    /**
     * Оверрайд метода Ext.data.AbstractStore
     */
    destroyStore: function() {
        var me = this;
        if (!me.isDestroyed) {
            // дропаем сторы элементов у каждой модели слота
            me.each(function(item) {
                item.destroyStores();
            });
        }
        me.callParent(arguments);
    },
    /**
     * Проверяет, есть ли у юзера предмет
     */
    hasItem: function(protoId) {
        var me = this,
            hasItem = false;
        me.each(function(slot) {
            slot.items().each(function(slotItem) {
                if (slotItem.data.proto_id == protoId) {
                    hasItem = true;
                }
            });
        });
        return hasItem;
    },
    /**
     * Вернет кол-во предметов, которые есть у игрока
     */
    getItemCount: function(protoId) {
        var me = this,
            count = 0;
        me.each(function(slot) {
            slot.items().each(function(slotItem) {
                if (slotItem.data.proto_id == protoId) {
                    count += slotItem.data.count;
                }
            });
        });
        return count;
    }
});

/**
 * Расширенная модель пользователя
 *
 * Есть одна особенность у этой модели. Для фукции set нужно использовать только
 * один аргумент типа Object.
 *
 * Свойство <code>payment</code> означает возможный способ оплаты, а также
 * является признаком регистрации пользователя через социальную сеть.
 */
Ext.define('ExGodsCore.model.User', {
    extend: ExGodsCore.model.BasicUser,
    proxy: 'memory',
    // чтобы модель создала свой собственный прокси, иначе модель User будет использовать прокси модели BasicUser, что
    // приведет к багам
    /**
     * Увеличивается, когда информация персонажа изменилась
     */
    userVersion: 0,
    fields: [
        {
            name: 'achievements',
            type: 'auto'
        },
        {
            // друзья и враги
            name: 'contact',
            type: 'auto'
        },
        {
            // счётчики
            name: 'counters',
            type: 'auto'
        },
        {
            // ключи автологина
            name: 'enterkey',
            type: 'auto'
        },
        {
            name: 'email',
            type: 'string'
        },
        {
            // финансы и очки доблести
            name: 'money',
            type: 'auto',
            convert: function(v, rec) {
                if (Ext.isObject(v)) {
                    // проходим по справочнику, т.к. не все валюты могут быть изначально у пользователя
                    // тех что нет просто обнуляем
                    ExGodsCore.app.references.get('user_money').eachKey(function(key, item) {
                        if (v[key]) {
                            v[key] = parseInt(v[key]);
                        } else {
                            v[key] = 0;
                        }
                    });
                }
                return v;
            }
        },
        {
            // последние заходы
            name: 'lastenter',
            type: 'auto'
        },
        {
            name: 'payment',
            type: 'string'
        },
        {
            // публичная информация
            name: 'public',
            type: 'auto'
        },
        {
            name: 'ratings',
            type: 'auto',
            convert: function(v) {
                if (Ext.isArray(v)) {
                    Ext.Array.sort(v, function(a, b) {
                        a.l_order = parseInt(a.l_order);
                        b.l_order = parseInt(b.l_order);
                        return a.l_order > b.l_order ? 1 : (a.l_order < b.l_order ? -1 : 0);
                    });
                }
                return v;
            }
        },
        {
            // просмотренные подсказки
            name: 'read_hints',
            type: 'auto'
        },
        {
            // настройки {Object}
            // название настройки : значение настройки
            name: 'settings',
            type: 'auto'
        },
        {
            // связь аккаунта с социальной сетью
            name: 'social',
            type: 'auto'
        },
        {
            // восстанавливаемые характеристики
            name: 'timed',
            type: 'auto',
            defaultValue: null
        },
        {
            // список навыков
            name: 'feature',
            type: 'auto',
            convert: function(v, record) {
                if (!v)  {
                    return v;
                }
                
                var features = record.initFeatures(),
                    counter = 0;
                if (Ext.isArray(v)) {
                    Ext.Array.forEach(v, function(feature) {
                        if (!feature.hidden && !features.data.getByKey(parseInt(feature.entry))) {
                            counter++;
                        }
                    });
                }
                features.loadRawData(v);
                if (counter) {
                    features.fireEvent('featuresadded', counter);
                }
                return features;
            }
        },
        {
            name: 'slots',
            type: 'auto',
            convert: function(v, record) {
                if (!v)  {
                    return v;
                }
                
                var slots = record.initSlots(),
                    i = 0,
                    slotData,
                    initial = slots.getCount() == 0;
                for (; i < v.length; i++) {
                    var slotData = v[i],
                        slot = slots.data.getByKey(parseInt(slotData.ekey));
                    // Предполагается, что слоты не заменяются при обновлении данных пользователя.
                    if (slot) {
                        slot.set(slotData);
                    } else {
                        slots.loadRawData([
                            slotData
                        ], true);
                        if (!initial) {
                            slots.fireEvent('new_slot', slots.data.getByKey(parseInt(slotData.ekey)));
                        }
                    }
                }
                // новый слот!
                slots.fireEvent('items_changed');
                return slots;
            }
        },
        {
            name: 'next_price_protect',
            //цена защиты слота
            type: 'auto'
        },
        /*
         * Специфичные параметры для боя (ekey, live, side)
         */
        {
            name: 'battle',
            type: 'auto',
            convert: function(v) {
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key, value, myself) {
                        if (!Ext.isObject(myself[key]))  {
                            myself[key] = parseInt(value);
                        }
                        
                    });
                }
                return v;
            }
        },
        {
            // Состояние в бою 
            name: 'battle_state',
            type: 'auto'
        },
        {
            // Аура на игроке. Пока актуальна только в бою, но может и вне боя имеет смысл - нужно уточнить.
            name: 'aura',
            type: 'auto'
        },
        /**
         * Метка - бот или нет. Актуально только для пользователя в бою.
         */
        {
            name: 'is_bot',
            type: 'int'
        },
        /**
         * Метка - животное или человек. Актуально только для пользователя в бою.
         */
        {
            name: 'real_user',
            type: 'auto'
        }
    ],
    /**
     * @property {Ext.data.Store} featureStore
     * Хранилище навыков
     */
    /**
     * @property {Object} updateInterval
     * Объект с идентификаторами интервалов обновления временных характеристик
     */
    constructor: function() {
        var me = this;
        me.updateInterval = {};
        me.callParent(arguments);
    },
    initFeatures: function() {
        var me = this;
        if (!me.featureStore) {
            me.featureStore = Ext.create('Ext.data.Store', {
                model: 'ExGodsCore.model.Feature',
                avatar_ruin_count: 0,
                //количество фич, изменяющих иконку.
                proxy: {
                    type: 'ajax',
                    url: '/game.pl?cmd=feature.list',
                    limitParam: false,
                    pageParam: false,
                    startParam: false,
                    reader: {
                        type: 'json',
                        root: 'user.feature'
                    }
                }
            });
        }
        return me.featureStore;
    },
    initSlots: function() {
        var me = this;
        if (!me.slotsStore)  {
            me.slotsStore = Ext.create('ExGodsCore.store.Slots');
        }
        
        return me.slotsStore;
    },
    get: function(field) {
        var me = this;
        switch (field) {
            case 'feature':
                return me.initFeatures();
                break;
            case 'slots':
                return me.initSlots();
                break;
            default:
                return me.callParent(arguments);
                break;
        }
    },
    /**
     * Обновляет временные характиристики
     * @param {String} key Ключ в объекте timed (пока их только три: hp, mp и endur)
     * @param {String} startTime Время с которого начал работать счётчик
     * @param {String} startkeyValue Начальное значение параметра с которого начал работать счётчик
     */
    updateTimed: function(key, startTime, startkeyValue) {
        var me = this,
            timed = me.data.timed[key],
            curTimed = timed[0],
            now = Date.now();
        timed[0] = startkeyValue + (Math.round((now - startTime) / 1000) - 1) * timed[2];
        if (timed[0] >= timed[1]) {
            timed[0] = timed[1];
            clearInterval(me.updateInterval[key]);
        }
        if (me == ExGods.app.user && timed[3] && now - 3000 >= /*временно лаг, иначе успевает 2-4 запроса сделать*/
        timed[3]) {
            if (me.loading_timed)  {
                return;
            }
            
            me.loading_timed = true;
            me.loadRemote(function() {
                me.loading_timed = false;
                me.fireEvent(key + 'changed', me.data.timed[key], me.data.timed[key][0] != curTimed);
            });
        }
        me.fireEvent(key + 'changed', timed, timed[0] != curTimed);
    },
    features: function() {
        return this.initFeatures();
    },
    slots: function() {
        return this.initSlots();
    },
    getBattle: function() {
        return parseInt(this.get('binding').battle);
    },
    /**
     * Методы боя
     * @param {String} key Ключ
     */
    getBattleInfo: function(key) {
        var me = this,
            battle = me.get('battle');
        if (battle) {
            if (key) {
                return battle[key];
            } else {
                return battle;
            }
        }
        return false;
    },
    getBattleEkey: function() {
        return this.getBattleInfo('ekey');
    },
    /**
     * Возвращает сторону, на которой дерётся пользователь
     *
     * @return {Number} Обычно это 1 или 2
     */
    getBattleSide: function() {
        var battle = this.get('battle');
        if (battle && battle.side != undefined) {
            return battle.side;
        } else {
            return false;
        }
    },
    /**
     * Возвращает идентификатор социальной сети, к которй привяязан пользователь
     *
     * @return {String}
     */
    getSocialNet: function() {
        var social = this.get('social');
        return social ? social.social_net : false;
    },
    /**
     * Возвращает значение настройки пользователя 
     * @param {String} settingName
     * @param {String} defaultValue
     * @return {String} Значение настройки или defaultValue, если она не задана
     *
     */
    getSetting: function(settingName, defaultValue) {
        var me = this,
            setting = this.get('settings')[settingName];
        return typeof setting == 'object' ? setting.value : defaultValue;
    },
    setSetting: function(name, value) {
        var me = this,
            settings = me.get('settings');
        if (typeof settings[name] == 'object') {
            settings[name].value = value;
            me.set({
                settings: settings
            });
            me.fireEvent('setting_change', name, value);
        }
    },
    /**
     * Возвращает флаг, в бою пользователь или нет
     * 
     * @return {Boolean}
     */
    isBattle: function() {
        return this.getBattle() ? true : false;
    },
    /**
     * Возвращает признак жив пользователь или мёртв во время боя
     * 
     * @return {Boolean}
     */
    isLiveInBattle: function() {
        return this.getBattleInfo('live') === 1;
    },
    /**
     * Вернёт true, если юзер в боевой цепочке
     */
    isChain: function() {
        var me = this;
        return parseInt(me.get('binding').battle_chain) ? true : false;
    },
    set: function() {
        var me = this;
        me.callParent(arguments);
        me.userVersion = me.userVersion + 1;
        me.fireEvent('change_user_version', me);
    },
    /**
     * Событие изменения данных пользователя
     * @private
     */
    afterEdit: function() {
        var me = this;
        /**
         * @event change
         * Срабатывает, когда информация персонажа изменилась
         * @param {Ext.Component} this
         */
        me.fireEvent('change', me);
        var changes = me.getChanges();
        Ext.Object.each(changes, function(key, value) {
            /**
             * @event statschanged
             * Срабатывает, когда статы персонажа изменилась
             * @param {Ext.Component} this
             */
            /**
             * @event timedchanged
             * Срабатывает, когда меняются временные характеристики персонажа (hp, mp, endur)
             * @param {Ext.Component} this
             */
            if (key != 'talant')  {
                // TODO: избавиться от этого ужаса, т.к. ключ talant есть в 2-х вариантах
                me.fireEvent(key + 'changed', me, value, me.modified[key]);
            }
            
            if (value != null) {
                switch (key) {
                    case 'binding':
                        if (Ext.isObject(value)) {
                            var modified = me.modified[key] || {};
                            Ext.Object.each(value, function(key, value) {
                                if (value != modified[key]) {
                                    /**
                                     * @event roomchanged
                                     * Срабатывает при смене локации
                                     * @param {Number} newValue Новая локация
                                     * @param {Number} oldValue Старая локация
                                     */
                                    /**
                                     * @event worldchanged
                                     * Срабатывает при смене мира
                                     * @param {Number} newValue Новый мир
                                     * @param {Number} oldValue Старый мир
                                     */
                                    me.fireEvent(key + 'changed', value, modified[key]);
                                }
                            });
                        };
                        break;
                    case 'hoard':
                        if (Ext.isObject(value)) {
                            var modified = me.modified[key] || {};
                            Ext.Object.each(value, function(key, value) {
                                if (value != modified[key]) {
                                    /**
                                     * @event expachanged
                                     * Срабатывает при изменении опыта
                                     * @param {Number} newValue Новое значение опыта
                                     * @param {Number} oldValue Старое значение опыта
                                     * @param {ExGods.model.User} this Пользователь
                                     */
                                    /**
                                     * @event valourchanged
                                     * Срабатывает при изменении доблести
                                     * @param {Number} newValue Новое значение доблести
                                     * @param {Number} oldValue Старое значение доблести
                                     * @param {ExGods.model.User} this Пользователь
                                     */
                                    me.fireEvent(key + 'changed', value, modified[key], me);
                                }
                            });
                        };
                        break;
                    case 'money':
                        if (Ext.isObject(value)) {
                            var modified = me.modified[key] || {};
                            var hasChanges = false;
                            Ext.Object.each(value, function(subkey, value) {
                                if (value != modified[subkey]) {
                                    /**
                                     * @event moneycrystalchanged
                                     * Срабатывает при изменении числа кристаллов у пользователя
                                     * @param {Number} newValue Новое значение опыта
                                     * @param {Number} oldValue Старое значение опыта
                                     * @param {ExGods.model.User} this Пользователь
                                     */
                                    /**
                                     * @event moneyglorychanged
                                     * @param {Number} newValue Новое значение
                                     * @param {Number} oldValue Старое значение
                                     * @param {ExGods.model.User} this Пользователь
                                     */
                                    /**
                                     * @event moneygoldchanged
                                     * @param {Number} newValue Новое значение
                                     * @param {Number} oldValue Старое значение
                                     * @param {ExGods.model.User} this Пользователь
                                     */
                                    /**
                                     * @event moneytalantchanged
                                     * @param {Number} newValue Новое значение
                                     * @param {Number} oldValue Старое значение
                                     * @param {ExGods.model.User} this Пользователь
                                     */
                                    me.fireEvent(key + subkey + 'changed', value, modified[subkey], me, subkey);
                                    hasChanges = true;
                                }
                            });
                            if (hasChanges) {
                                /**
                                 * @event moneychanged
                                 * @param {Object} Новое значение
                                 * @param {Object} Старое значение
                                 * @param {ExGods.model.User} this Пользователь
                                 */
                                me.fireEvent('moneychanged', value, modified, me);
                            }
                        };
                        break;
                    case 'timed':
                        Ext.Object.each(value, function(key, value) {
                            var current = value[0];
                            max = value[1] , speed = value[2];
                            /**
                             * @event hpchanged
                             * Срабатывает при изменении уровня жизней
                             * @param {Number[]} hp Новые параметры здоровья
                             */
                            /**
                             * @event mpchanged
                             * Срабатывает при изменении уровня маны
                             * @param {Number[]} hp Новые параметры здоровья
                             */
                            /**
                             * @event shieldchanged
                             * Срабатывает при изменении уровня щита
                             * @param {Number[]} energy Новые параметры щита
                             */
                            /**
                             * @event energychanged
                             * Срабатывает при изменении уровня энергии
                             * @param {Number[]} energy Новые параметры энергии
                             */
                            me.fireEvent(key + 'changed', value);
                            if (me.updateInterval[key]) {
                                clearInterval(me.updateInterval[key]);
                                me.updateInterval[key] = 0;
                            }
                            if (speed && current < max) {
                                var startTime = Date.now(),
                                    startKeyValue = me.data.timed[key][0];
                                me.updateInterval[key] = setInterval(function() {
                                    me.updateTimed(key, startTime, startKeyValue);
                                }, 1000);
                            }
                        });
                        break;
                    default:
                        break;
                }
            }
        });
        me.commit();
    },
    /**
     * Удалённая загрузка данных пользователя
     */
    loadRemote: function(callback, scope) {
        var me = this;
        Ext.Ajax.request({
            url: HOST_URL + '/game.pl?cmd=user',
            queue: true,
            success: function(response) {
                var result = Ext.decode(response.responseText, true);
                if (result) {
                    me.set(result);
                }
                if (callback) {
                    callback.call(scope || me, result);
                }
            }
        });
    },
    /**
     * Проверяет, висит ли на пользователе фича
     * @param {featureName} Название фичи
     * @return {Boolean}
     */
    hasFeature: function(featureType) {
        var me = this,
            feature;
        feature = me.features().findBy(function(item) {
            return item.get('type') == featureType;
        });
        return feature != -1 ? true : false;
    },
    /**
     * Уничтожает все хранилища модели
     */
    destroyStores: function() {
        var me = this;
        if (me.featureStore) {
            me.featureStore.destroyStore();
            me.featureStore = null;
        }
        if (me.slotsStore) {
            me.slotsStore.destroyStore();
            me.slotsStore = null;
        }
        if (me.talentsStore) {
            me.talentsStore.destroyStore();
            me.talentsStore = null;
        }
    }
});

/**
 * Базовая модель пользователя
 *
 * Есть одна особенность у этой модели. Для фукции set нужно использовать только
 * один аргумент типа Object.
 */
Ext.define('ExGods.model.BasicUser', {
    extend: ExGodsCore.model.BasicUser,
    idProperty: 'title',
    fields: [
        {
            // признак готовности начать обучение
            name: 'ready_pupil',
            type: 'int'
        },
        {
            // прототип маски юзера
            name: 'mask_proto_id',
            type: 'int'
        },
        {
            // данные гильдии
            name: 'guild',
            type: 'auto',
            convert: function(v) {
                if (typeof v != 'object') {
                    return '';
                }
                return v;
            }
        },
        {
            // группа маски юзера
            name: 'mask_group',
            type: 'string'
        }
    ],
    /**
     * Возвращает название ранка пользователя
     * @return {String}
     */
    getRankName: function() {
        return ExGods.references.get('user_valour').getByKey(parseInt(this.get('hoard').rank)).data.rank;
    },
    /**
     * Возвращает доблесть персонажа из справочника
     * 
     * @return {Object}
     */
    getValourRef: function() {
        var hoard = this.get('hoard'),
            ref = false;
        if (!hoard || hoard.rank == undefined)  {
            return false;
        }
        
        ref = ExGods.references.get('user_valour').getByKey(hoard.rank);
        return ref;
    },
    /**
     * Возвращает текущий уровень доблести персонажа
     * 
     * @return {Number}
     */
    getValourLevel: function() {
        var valour = this.get('hoard').valour,
            levels = ExGods.references.get('user_valour'),
            level = 0;
        levels.each(function(item, index, length) {
            if (valour < item.valour) {
                level = index;
                return false;
            }
        });
        return level;
    },
    /**
     * проставляет выполненные рейды в стор рейдов
     */
    setRaidAchievements: function(achievements) {
        achievements = achievements || this.get('achievements') || [];
        var me = this,
            ids = Ext.Array.map(achievements, function(el) {
                return el.achievement_id || el.id;
            });
        ExGods.app.getGuildRaidsStore().each(function(rec) {
            var achievement = rec.get('achievement');
            if (!achievement)  {
                return;
            }
            
            if (ids.indexOf(achievement.id) != -1) {
                rec.set('counter', 1);
            } else {
                rec.set('counter', 0);
            }
        });
    }
});

/**
 * Модель навыков
 */
Ext.define('ExGods.model.Feature', {
    extend: ExGodsCore.model.Feature,
    fields: [
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description2',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto',
            convert: function(v) {
                var images = {};
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key) {
                        images[key] = IMAGE_URL + v[key];
                    });
                }
                return images;
            }
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            // флаг, что фича является травмой
            name: 'trauma',
            type: 'int'
        },
        {
            // флаг, что фича имеет аддитивный эффект (эффект от нескольких подобных фич складывается)
            name: 'multiple',
            type: 'int'
        },
        {
            name: 'hidden',
            type: 'int'
        },
        {
            name: 'grade',
            type: 'int'
        }
    ]
});

/**
 * Расширенная модель пользователя
 *
 * Есть одна особенность у этой модели. Для фукции set нужно использовать только
 * один аргумент типа Object.
 *
 * Свойство <code>payment</code> означает возможный способ оплаты, а также
 * является признаком регистрации пользователя через социальную сеть.
 */
Ext.define('ExGods.model.User', {
    extend: ExGodsCore.model.User,
    mixins: [
        ExGods.model.BasicUser
    ],
    proxy: 'memory',
    // чтобы модель создала свой собственный прокси, иначе модель User будет использовать прокси модели BasicUser, что
    // приведет к багам
    fields: [
        {
            name: 'achievements',
            type: 'auto'
        },
        {
            // уровень опасности относительно базового уровня
            // Приходит только для пользователя в бою
            name: 'peril_rel',
            type: 'float'
        },
        {
            // друзья и враги
            name: 'contact',
            type: 'auto'
        },
        {
            // счётчики
            name: 'counters',
            type: 'auto'
        },
        {
            // ключи автологина
            name: 'enterkey',
            type: 'auto'
        },
        {
            // elo ratings
            name: 'elo',
            type: 'auto',
            convert: function(v, rec) {
                var elo = {};
                Ext.Array.each(v, function(el) {
                    for (var key in el) {
                        elo[key] = el[key];
                    }
                });
                return elo;
            }
        },
        {
            name: 'email',
            type: 'string'
        },
        {
            // финансы и очки доблести
            name: 'money',
            type: 'auto',
            convert: function(v, rec) {
                if (Ext.isObject(v)) {
                    // проходим по справочнику, т.к. не все валюты могут быть изначально у пользователя
                    // тех что нет просто обнуляем
                    ExGods.app.references.get('user_money').eachKey(function(key, item) {
                        if (v[key]) {
                            v[key] = parseInt(v[key]);
                        } else {
                            v[key] = 0;
                        }
                    });
                } else {
                    v = "";
                }
                return v;
            }
        },
        {
            // последние заходы
            name: 'lastenter',
            type: 'auto'
        },
        {
            name: 'payment',
            type: 'string'
        },
        {
            // публичная информация
            name: 'public',
            type: 'auto'
        },
        {
            name: 'ratings',
            type: 'auto',
            convert: function(v) {
                if (Ext.isArray(v)) {
                    Ext.Array.sort(v, function(a, b) {
                        a.l_order = parseInt(a.l_order);
                        b.l_order = parseInt(b.l_order);
                        return a.l_order > b.l_order ? 1 : (a.l_order < b.l_order ? -1 : 0);
                    });
                }
                return v;
            }
        },
        {
            // просмотренные подсказки
            name: 'read_hints',
            type: 'auto'
        },
        {
            name: 'reg_date',
            type: 'date',
            dateFormat: serverDateTimeFormat
        },
        {
            // настройки {Object}
            // название настройки : значение настройки
            name: 'settings',
            type: 'auto'
        },
        {
            // связь аккаунта с социальной сетью
            name: 'social',
            type: 'auto'
        },
        {
            // восстанавливаемые характеристики
            name: 'timed',
            type: 'auto',
            defaultValue: null,
            convert: function(v) {
                for (var k in v) {
                    if (v[k] && v[k][0])  {
                        v[k][0] = Number(v[k][0]);
                    }
                    
                    if (v[k] && v[k][3])  {
                        v[k][3] = ExGods.util.Date.normalizeUnixTime(v[k][3]);
                    }
                    
                }
                return v;
            }
        },
        /*
         * Прототип отслеживаемого квеста
         */
        {
            name: 'trace_quest_proto',
            type: 'int'
        },
        {
            //available_quests
            name: 'available_quests',
            type: 'auto',
            convert: function(v, record) {
                var store = record.initAvailableQuests();
                Ext.each(v, function(quest) {
                    var q = store.findRecord('proto_id', quest.proto_id);
                    if (q && q.get('expanded')) {
                        quest.expanded = q.get('expanded');
                    }
                });
                store.loadRawData(v);
                return store;
            }
        },
        {
            name: 'is_creator',
            type: 'int'
        },
        /**
         * свойства боевого бота
         */
        {
            name: 'bot_visible_battle_actions',
            type: 'auto'
        },
        {
            name: 'bot_visible_instants',
            type: 'auto'
        },
        {
            name: 'bot_visible_turns',
            type: 'auto'
        },
        {
            // виртуальное хранилище и лут
            name: 'stores',
            type: 'auto',
            convert: function(v, record) {
                if (!v)  {
                    return;
                }
                
                v = v || [];
                // заполняю сторы моделями для каждого имещества из каждой записи виртуального хранилища
                var virtualStore = ExGods.app.getStore('VirtualStore'),
                    lootStore = ExGods.app.getStore('Loot'),
                    virtual = [],
                    loot = [];
                for (var i = 0; i < v.length; i++) {
                    for (var j = 0; j < v[i].stuff.length; j++) {
                        var recData = {
                                entry: v[i].entry,
                                add_time: v[i].add_time,
                                source_id: v[i].source_id,
                                source_name: v[i].source_name,
                                destinations: v[i].destinations,
                                params: v[i].params,
                                index: j,
                                stuff: v[i].stuff[j]
                            };
                        if (v[i].source_name == 'loot') {
                            loot.push(recData);
                        } else {
                            virtual.push(recData);
                        }
                    }
                }
                virtualStore.loadRawData(virtual);
                lootStore.loadRawData(loot);
                return virtualStore;
            }
        },
        {
            // прототип маски юзера
            name: 'mask_proto_id',
            type: 'int'
        },
        {
            name: 'ingredients',
            type: 'auto',
            convert: function(v) {
                return v || [];
            }
        },
        {
            // данные гильдии
            name: 'guild',
            type: 'auto',
            convert: function(v) {
                if (typeof v != 'object') {
                    return '';
                }
                return v;
            }
        }
    ],
    /**
     * @property {Ext.data.Store} featureStore
     * Хранилище навыков
     */
    /**
     * @property {Object} updateInterval
     * Объект с идентификаторами интервалов обновления временных характеристик
     */
    constructor: function() {
        var me = this;
        me.updateInterval = {};
        me.callParent(arguments);
    },
    initAvailableQuests: function() {
        var me = this;
        if (!me.availableQuestsStore)  {
            me.availableQuestsStore = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.Quest',
                sorters: [
                    {
                        sorterFn: function(a, b) {
                            var ret = 0;
                            if (a.get('story') == 3 && b.get('story') != 3)  {
                                ret = -1;
                            }
                            
                            if (b.get('story') == 3 && a.get('story') != 3)  {
                                ret = 1;
                            }
                            
                            if (!a.get('repeat') && !a.get('timeout') && a.get('story') == 1 && (b.get('repeat') || b.get('timeout') || b.get('story') != 1))  {
                                ret = -1;
                            }
                            
                            if (!b.get('repeat') && !b.get('timeout') && b.get('story') == 1 && (a.get('repeat') || a.get('timeout') || a.get('story') != 1))  {
                                ret = 1;
                            }
                            
                            if (a.get('status') == 2 && b.get('status') != 2)  {
                                ret = 1;
                            }
                            
                            if (b.get('status') == 2 && a.get('status') != 2)  {
                                ret = -1;
                            }
                            
                            return ret;
                        }
                    }
                ]
            });
        }
        
        return me.availableQuestsStore;
    },
    initFeatures: function() {
        var me = this;
        if (!me.featureStore) {
            me.featureStore = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.Feature',
                avatar_ruin_count: 0,
                //количество фич, изменяющих иконку.
                getExpFeatures: function() {
                    var me = this,
                        ret = [];
                    me.each(function(feature) {
                        if (feature.data.type == 'battle_exp_add' || feature.data.type == 'experience') {
                            ret.push(feature);
                        }
                    });
                    Ext.Array.sort(ret, function(f1, f2) {
                        f1 = new Date(f1.get('ended').split('-').join('/')).getTime();
                        f2 = new Date(f2.get('ended').split('-').join('/')).getTime();
                        return f1 > f2;
                    });
                    return ret;
                },
                // proxy: {
                //  type: 'ajax',
                //  url: '/game.pl?cmd=feature.list',
                //  limitParam: false,
                //  pageParam: false,
                //  startParam: false,
                //  reader: {
                //      type: 'json',
                //      root: 'user.feature'
                //  }
                // },
                listeners: {
                    load: {
                        fn: function() {
                            var newAvatarRuinCount = 0;
                            this.each(function(feature) {
                                //считаем количество фич, изменяющих иконку.
                                if (feature.data.type == 'avatar_ruin') {
                                    newAvatarRuinCount++;
                                }
                            });
                            if (newAvatarRuinCount != me.featureStore.avatar_ruin_count) {
                                //если количество фич, изменяющих иконку, изменилось
                                me.fireEvent('avatar_ruin_changed', me);
                                me.featureStore.avatar_ruin_count = newAvatarRuinCount;
                            }
                        }
                    }
                }
            });
        }
        return me.featureStore;
    },
    initSlots: function() {
        var me = this;
        if (!me.slotsStore) {
            me.slotsStore = Ext.create('ExGodsCore.store.Slots');
        }
        return me.slotsStore;
    },
    get: function(field) {
        var me = this;
        switch (field) {
            case 'feature':
                return me.initFeatures();
                break;
            case 'slots':
                return me.initSlots();
                break;
            default:
                return me.callParent(arguments);
                break;
        }
    },
    /**
     * Возвращает боевой аватар персонажа
     * @return {String}
     */
    getBattleAvatar: function() {
        return this.getShape().battle;
    },
    /**
     * Возвращает массив со значениями выносливости
     * 
     * @return {Number[]}
     */
    getEndurance: function() {
        try {
            return this.get('timed').endur;
        } catch (e) {
            return false;
        }
    },
    /**
     * Возвращает массив со значениями энергии
     * 
     * @return {Number[]}
     */
    getEnergy: function() {
        try {
            return this.get('timed').energy;
        } catch (e) {
            return false;
        }
    },
    /**
     * Проверяю наличие стаффа у юзера, если есть - возврашаю true
     */
    checkStuff: function(stuff, options) {
        if (!stuff || stuff.length == 0)  {
            return true;
        }
        
        var me = this,
            valid = true;
        options = options || {};
        stuff = (Ext.isArray(stuff)) ? stuff : [
            stuff
        ];
        Ext.each(stuff, function(item) {
            if (!valid)  {
                return;
            }
            
            switch (item.type) {
                case 'timed':
                    valid = me.get('timed')[item.params.id][0] >= item.params.quantity;
                    break;
                case 'currency':
                    valid = me.get('money')[item.params.id] >= item.params.quantity;
                    break;
                case 'item':
                    var count = item.params.quantity,
                        haveItems = me.getItemsCountByProto(item.params.id, options.activeSlot);
                    valid = count <= haveItems;
                    break;
                case 'ingredients':
                    var count = item.params.quantity,
                        haveItems = me.getIngredientCountByName(item.params.id);
                    valid = count <= haveItems;
                    break;
                default:
                    break;
            }
        });
        return valid;
    },
    /**
     * возвращает количество предметов у персонажа по proto_id
     */
    getItemsCountByProto: function(proto_id, activeSlot) {
        var me = this,
            count = 0;
        me.slots().each(function(slot) {
            if (activeSlot && slot.get('type') != 14)  {
                return;
            }
            
            slot.itemsStore.each(function(el) {
                if (el.get('proto_id') == proto_id) {
                    var l = el.get('stack_ids') ? el.get('stack_ids').length || 1 : 1;
                    l = l * (Number(el.get('param').count) || 1);
                    count += l;
                }
            });
        });
        return count;
    },
    /**
     * Возвращает количество надетых на юзера предметов в критическом состоянии
     */
    getCriticallyDamagedEquippedItems: function() {
        var me = this,
            equipped = me.get('slots').queryBy(function(item) {
                return [
                    1,
                    2,
                    4,
                    5,
                    8,
                    11,
                    12,
                    13
                ].indexOf(item.get('type')) != -1;
            }),
            count = 0;
        equipped.each(function(slot) {
            var item = slot.get('items').getAt(0);
            if (item && item.hasCriticalDurability())  {
                count++;
            }
            
        });
        return count;
    },
    /**
     * Уничтожает все хранилища модели
     */
    destroyStores: function() {
        var me = this;
        if (me.featureStore) {
            me.featureStore.destroyStore();
            me.featureStore = null;
        }
        if (me.slotsStore) {
            me.slotsStore.destroyStore();
            me.slotsStore = null;
        }
    },
    isChatOn: function() {
        return Ext.util.Cookies.get('chat-on') === "1";
    },
    setChatOn: function(value) {
        Ext.util.Cookies.set('chat-on', value ? 1 : 0);
    },
    /**
     * Вернет слот маски игрока
     */
    getMaskSlot: function() {
        var me = this,
            slot, item,
            maskSlotType = ExGods.ref('constants|battle_mask_slot').value;
        me.slots().each(function(s) {
            if (s.data.type == maskSlotType) {
                slot = s;
            }
        });
        return slot;
    },
    /**
     * Вернет прототип маски игрока
     */
    getMaskProto: function() {
        var me = this,
            protos = ExGods.app.getItemPrototypesStore(),
            protoId, proto,
            getProtoIdFromMaskSlot = function() {
                var slot = me.getMaskSlot(),
                    item;
                if (slot) {
                    item = slot.items().first();
                    if (item) {
                        return item.data.proto_id;
                    }
                }
            };
        if (me.get('mask_proto_id')) {
            protoId = me.get('mask_proto_id');
        } else if (ExGods.app.user.get('display_title') == me.get('display_title')) {
            protoId = getProtoIdFromMaskSlot();
        }
        if (protoId) {
            proto = protos.getById(parseInt(protoId));
        }
        if (proto) {
            return proto.data;
        }
    },
    /**
     * Возвращает текущее значение ингредиентов у юзера по названию
     *
     * @return {Number}
     */
    getIngredientCountByName: function(name) {
        var ingredients = this.data.ingredients,
            value;
        Ext.Object.each(ingredients, function(index, item) {
            if (name == item.name) {
                value = item.value;
            }
        });
        return value ? value : 0;
    },
    /**
     * Возвращает ингредиенты определенной группы
     * @return {Array}
     */
    getIngredientsByGroup: function(group) {
        var ingredients = this.data.ingredients,
            ref = ExGods.ref('ingredients'),
            info,
            res = [];
        if (ingredients && ingredients.length) {
            Ext.Object.each(ingredients, function(index, item) {
                info = ref.get(item.name);
                if (info && info.group == group) {
                    res.push(item);
                }
            });
        }
        return res;
    },
    /**
     * Возвращает кол-во ингредиентов в группе
     */
    getIngredientsGroupCount: function(group) {
        var ingredients = this.getIngredientsByGroup(group),
            count = 0;
        ingredients.forEach(function(item) {
            count += parseInt(item.value);
        });
        return count;
    }
});

/**
 * Список всех персонажей (игроков/ботов/npc)
 */
Ext.define('ExGods.store.Users', {
    extend: Ext.data.Store,
    model: 'ExGods.model.User',
    proxy: {
        type: 'memory'
    },
    /**
     * Возвращает пользователя по ключу в бою
     *
     * @param {Number} ekey
     * @return {ExGods.model.User}
     */
    getByEkey: function(ekey) {
        var me = this;
        var index = me.findBy(function(record, id) {
                if (record.getBattleEkey() == ekey) {
                    return true;
                } else {
                    return false;
                }
            });
        if (index > -1) {
            return me.getAt(index);
        }
        return false;
    },
    /**
     * Отбирает пользователей по стороне
     *
     * @return {ExGods.model.User[]}
     */
    getBySide: function(side) {
        var me = this;
        var users = me.queryBy(function(record, id) {
                return record.getBattleSide() === side;
            });
        return users.getRange();
    },
    /**
     * Оверрайд метода Ext.data.AbstractStore
     */
    destroyStore: function() {
        var me = this;
        if (!me.isDestroyed) {
            // дропаем сторы элементов у каждой модели
            me.each(function(item) {
                item.destroyStores();
            });
        }
        me.callParent(arguments);
    }
});

/**
 * Модель мира
 */
Ext.define('ExGods.model.World', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            // доп. параметры мира
            name: 'blob',
            type: 'auto'
        },
        {
            // идентификатор комнаты в чате
            name: 'chat_room_name',
            type: 'string'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'title',
            type: 'string'
        }
    ],
    /**
     * Проверяет, видим ли мир в телепорте
     * @return {Boolean}
     */
    isVisible: function() {
        var visible = this.get('blob').visible;
        return visible && parseInt(visible) ? true : false;
    },
    /**
     * Возвращает название мира
     * @return {String} Название мира
     */
    getTitle: function() {
        return this.get('title');
    },
    /**
     * Возвращает изображение мира
     * @return {String}
     */
    getImage: function() {
        var image = this.get('blob').image;
        return image ? IMAGE_URL + this.get('blob').image : Ext.BLANK_IMAGE_URL;
    }
});

/**
 * Список всех миров
 */
Ext.define('ExGods.store.Worlds', {
    extend: Ext.data.Store,
    model: 'ExGods.model.World'
});

/**
 * Модель абилки/комбо/боевого приёма
 */
Ext.define('ExGodsCore.model.Ability', {
    extend: Ext.data.Model,
    idProperty: 'name',
    fields: [
        {
            /*
             * Cooldown
             * [current, max] во время боя
             * int - в мирное время
             */
            name: 'cd',
            type: 'auto'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            // краткое описание комбо
            name: 'short',
            type: 'string'
        },
        {
            // полное описание комбо
            name: 'description',
            type: 'string'
        },
        // далее идут данные, которые выдаются вне боя
        {
            // флаг, включён приём или нет
            name: 'status',
            type: 'int'
        }
    ],
    /**
     * Вернет true, если способность доступна для выполнения
     */
    isAvailable: function() {
        var cd = this.get('cd');
        return (parseInt(cd[0]) === 0) ? true : false;
    }
});

/**
 * Модель абилки/комбо/боевого приёма
 *
 * Боевые приёмы в игре представляются двумя хранилищами:
 * 
 * - в мирное время
 * - в бою
 *
 * Описание поля <code>strike</code>:
 * 
 * - strike - завершит ход после применения
 * - choose - выбираем цель (только своих или противника тоже?)
 * - target - выбираем цель на стороне противника
 */
Ext.define('ExGods.model.Ability', {
    extend: ExGodsCore.model.Ability,
    idProperty: 'name',
    fields: [
        {
            // current position for combo
            name: 'pos',
            type: 'int'
        },
        {
            name: 'list',
            type: 'auto'
        },
        {
            // количество ударов, необходимо для сбора комбо
            name: 'need',
            type: 'int'
        },
        {
            name: 'count',
            type: 'int'
        },
        {
            name: 'counted',
            type: 'int'
        },
        {
            name: 'strike',
            type: 'auto'
        },
        {
            name: 'battle',
            type: 'int'
        },
        // далее идут данные, которые выдаются вне боя
        {
            name: 'school',
            type: 'int'
        }
    ],
    /**
     * Выбор противника
     */
    isChooseEnemy: function() {
        var me = this,
            strike = me.get('strike');
        return (strike && strike.target == 1);
    },
    /**
     * Выбор цели (противники не учитывается?)
     */
    isChooseTarget: function() {
        var me = this,
            strike = me.get('strike');
        return (strike && strike.choose == 1);
    },
    /**
     * После выбора этого приёма ход завершется
     */
    isFinishBattleTurn: function() {
        var me = this,
            strike = me.get('strike');
        if (strike) {
            return strike.strike == 1;
        }
        return 0;
    }
});

/**
 * Список абилок
 */
Ext.define('ExGods.store.AbilityPrototypes', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Ability',
    proxy: {
        type: 'ajax',
        actionMethods: {
            read: 'POST'
        },
        limitParam: false,
        pageParam: false,
        reader: {
            type: 'json',
            rootProperty: 'list'
        },
        startParam: false
    },
    load: function(options) {
        var me = this;
        options = options || {};
        me.proxy.api = {
            read: HOST_URL + '/game.pl?cmd=battle.ability'
        };
        if (typeof options == 'function') {
            options = {
                callback: options
            };
        }
        options.addRecords = true;
        return me.callParent([
            options
        ]);
    },
    /**
     * Проверяет отсутсвие абилок в хранилище
     *
     * @param {String} protos ID абилки
     */
    check: function(protos) {
        var me = this,
            missed = [],
            i = 0,
            ln, proto_id;
        protos = Ext.Array.unique(protos);
        ln = protos.length;
        for (; i < ln; i++) {
            proto_id = protos[i];
            if (!me.data.getByKey(proto_id) && !Ext.Array.contains(missed, proto_id)) {
                missed.push(proto_id);
            }
        }
        return missed;
    },
    /**
     * Загружает и возвращает прототип(ы) абилок
     * 
     * @param {String} proto id прототита абилки
     * @param {Function} callback
     */
    loadNew: function(proto, callback) {
        var me = this,
            missed;
        if (!Ext.isArray(proto))  {
            proto = [
                proto
            ];
        }
        
        missed = me.check(proto);
        if (missed.length) {
            me.load({
                params: {
                    ids: Ext.encode(missed)
                },
                callback: callback,
                scope: me
            });
            return true;
        } else {
            callback.call(me);
        }
        return false;
    }
});

/**
 * Модель прототипа фичи
 */
Ext.define('ExGods.model.FeaturePrototype', {
    extend: Ext.data.Model,
    id: 'feature-prototype',
    idProperty: 'proto',
    fields: [
        {
            name: 'label',
            type: 'string'
        },
        {
            name: 'proto',
            type: 'string'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description2',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            name: 'hidden',
            type: 'int'
        },
        {
            name: 'params',
            type: 'auto'
        }
    ]
});

/**
 * Список фич
 */
Ext.define('ExGods.store.FeaturePrototypes', {
    extend: Ext.data.Store,
    model: 'ExGods.model.FeaturePrototype',
    proxy: {
        type: 'ajax',
        actionMethods: {
            read: 'POST'
        },
        limitParam: false,
        pageParam: false,
        reader: {
            type: 'json',
            rootProperty: 'list'
        },
        startParam: false
    },
    load: function(options) {
        var me = this;
        options = options || {};
        me.proxy.api = {
            read: HOST_URL + '/game.pl?cmd=feature.proto'
        };
        if (typeof options == 'function') {
            options = {
                callback: options
            };
        }
        options.addRecords = true;
        return me.callParent([
            options
        ]);
    },
    /**
     * Проверяет отсутсвие фичи в хранилище
     *
     * @param {String} protos ID фичи
     */
    check: function(protos) {
        var me = this,
            missed = [],
            i = 0,
            ln, proto_id;
        protos = Ext.Array.unique(protos);
        ln = protos.length;
        for (; i < ln; i++) {
            proto_id = protos[i];
            if (!me.data.getByKey(proto_id) && !Ext.Array.contains(missed, proto_id)) {
                missed.push(proto_id);
            }
        }
        return missed;
    },
    /**
     * Загружает и возвращает прототип(ы) фич
     * 
     * @param {String} proto id прототита фичи
     * @param {Function} callback
     */
    loadNew: function(proto, callback) {
        var me = this,
            missed;
        if (!Ext.isArray(proto))  {
            proto = [
                proto
            ];
        }
        
        missed = me.check(proto);
        if (missed.length) {
            me.load({
                params: {
                    ids: Ext.encode(missed)
                },
                callback: callback,
                scope: me
            });
            return true;
        } else {
            callback.call(me);
        }
        return false;
    }
});

//@define ExGodsCore.util.SvgText
/**
 * Утилита для работы с svg шрифтами
 *
 * @author Макс Дворцов
 */
Ext.ns('ExGodsCore.util');
ExGodsCore.util.SvgText = {
    letters: {
        'a': 'M0,12Q2,0-5,12',
        '_': 'M0,12L4,6',
        'p': 'M0,0L10,5L5,10',
        'M': '221.9660,282.1146m220.2571,284.5800L218.5061,284.5800L218.5061,274.3824L218.5061,273.9342-218.7022,273.6821-219.2065,273.6821c219.7108,273.6821-219.9069,273.9342-219.9069,274.3824C219.9069,282.6469L219.9349,282.6469L221.2656,280.6718L221.2656,280.4477L221.2656,280.0135-221.4617,279.6073-221.9660,279.6073c222.4983,279.6073-222.6664,280.0135-222.6664,280.4477C222.6664,280.6718L223.9971,282.6469L224.0251,282.6469L224.0251,274.3824L224.0251,273.9342-224.2212,273.6821-224.7255,273.6821c225.2297,273.6821-225.4259,273.9342-225.4259,274.3824C225.4259,284.5800L223.6749,284.5800L221.9660,282.1146L',
        't': 'M89 0c-3 0 -9 1 -11 12c-4 13 -33 234 -33 324c0 89 17 232 23 248c2 6 6 10 12 10s12 -4 17 -12c10 -17 29 -99 29 -225c0 -111 -13 -325 -18 -343c-2 -7 -11 -14 -19 -14zM387 604c-29 5 -109 17 -158 17c-53 0 -99 -5 -117 -8c-9 0 -19 6 -22 15c0 30 117 45 149 45c28 0 163 -19 165 -60c-2 -4 -8 -9 -17 -9z'
    },
    printText: function(text, params) {
        var me = ExGodsCore.util.SvgText,
            id = 'svg-' + Ext.id();
        setTimeout(function() {
            console.log(id);
            var svgtext = SVG(id),
                height = 0,
                width = 0,
                fontSize = params.size || 14,
                fontWeight = params.weight || 1;
            for (var i = 0; i < text.length; i++) {
                var letter = svgtext.path(me.letters[text.charAt(i)] || me.letters['_']).stroke({
                        width: fontWeight
                    }).fill('none').move(width, 0),
                    letterParams = letter.bbox();
                letter.scale(fontSize / letterParams.height);
                letterParams = letter.bbox();
                height = (height < letterParams.height) ? letterParams.height : height;
                width += letterParams.width;
            }
            svgtext.size(width, height);
        }, 50);
        return '<div id="' + id + '"></div>';
    }
};
//alias
ExGodsCore.printSvgText = ExGodsCore.util.SvgText.printText;

//@define ExGodsCore.util.Date
/**
 * Утилита для работы с датой
 *
 * @author Олег Михайлов
 */
Ext.ns('ExGodsCore.util');
ExGodsCore.util.Date = {
    /**
     * @property {String} serverDateTimeFormat
     * Формат даты и времени сервера
     */
    serverDateTimeFormat: serverDateTimeFormat,
    /**
     * @property {Number} serverTimezoneOffset
     * Сдвиг таймзоны (Москва) на сервере в минутах
     */
    serverTimezoneOffset: -3 * 60,
    /**
     * @property {Number} serverTimeOffset
     * Смещение серверного времени относительно клиентского в секундах
     */
    serverTimeOffset: parseInt(new Date().getTime() / 1000, 10) - window.now,
    /**
     * Парсит строку с датой и возвращает объект даты (не нормализованный)
     */
    parseString: function(str) {
        var me = this,
            dt;
        dt = Ext.Date.parse(str, this.serverDateTimeFormat);
        if (!dt) {
            // возможно дата пришла в формате timestamp - 'YmdHis'
            dt = Ext.Date.parse(str, 'YmdHis');
        }
        if (!dt) {
            // возможно дата пришла в формате "7d" или "eday"
            if (str == 'eday') {
                // до полуночи              
                dt = new Date();
                dt.setHours(23);
                dt.setHours(23);
                dt.setHours(23);
            } else if (str.match(/^\d+[d,m,s]/)) {
                var count = str.match(/^\d+/)[0];
                var units = str.match(/[d,m,s]/)[0];
                if (units == "d") {
                    dt = Ext.Date.add(new Date(), Ext.Date.DAY, count);
                } else if (units == "m") {
                    dt = Ext.Date.add(new Date(), Ext.Date.MINUTE, count);
                } else if (units == "s") {
                    dt = Ext.Date.add(new Date(), Ext.Date.SECOND, count);
                }
            }
        }
        return dt;
    },
    /**
     * Вернет клиентское время, соответствующее времени сервера, переданного в строке serverDateTime
     * @param {String|Date} serverDateTime Серверная дата в формате ExGods.util.Date.serverDateTimeFormat или объект даты
     * @return {Date} Клиентское время, соответствующее времени сервера
     */
    normalizeServerDateTime: function(serverDateTime) {
        var dt;
        if (typeof serverDateTime == 'string') {
            dt = this.parseString(serverDateTime);
        } else {
            dt = serverDateTime;
        }
        dt = Ext.Date.add(dt, Ext.Date.MINUTE, -dt.getTimezoneOffset() + this.serverTimezoneOffset);
        dt = Ext.Date.add(dt, Ext.Date.SECOND, this.serverTimeOffset);
        return dt;
    },
    /**
     * Нормализует серверное время в unixtime в секундах
     */
    normalizeUnixTime: function(time) {
        var me = this;
        return new Date((parseInt(time) + this.serverTimeOffset) * 1000);
    }
};

//@define ExGodsCore.util.Format
/**
 * Класс-помощник. В основном содержит вспомогательные методы по преобразованию данных в строку
 * @author Олег Михайлов
 */
Ext.ns('ExGodsCore.util');
ExGodsCore.util.Format = {
    /**
     * @property templates Конфигурация темплейтов для печали имущества
     */
    templates: {
        currency: function(item, ref) {
            var params = Ext.isArray(item.params) ? item.params : [
                    item.params
                ],
                // валюта может быть сгруппирована в массив
                html = [];
            Ext.Array.each(params, function(param) {
                html.push('<span data-qtip="' + ref.currency.get(param.id).label + '">' + '<span style="white-space: nowrap;">' + '<img src="' + ref.currency.get(param.id).image + '"/>' + Ext.util.Format.number(param.quantity, "0,0") + '</span>' + '</span>');
            });
            return html.join('');
        },
        expa: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_experience') + '" class="item-tpl" style="background-image: url(' + ref.icons.image.exp + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        valour: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_valour') + '" class="item-tpl" style="background-image: url(' + ref.icons.image.valour + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        item: function(item, ref, options) {
            var cls = options.simple ? '' : 'class="item" ',
                style = [
                    'color:' + ExGods.references.get('constants_list').item_grades.value[Number(item.params.grade) - 1 || 0]
                ];
            //if(!options.simple){
            style.push('background-image: url(' + ref.icons.image.item + ')');
            //}
            style = ' style="' + style.join(';') + '"';
            return '<span ' + cls + 'data-proto_id="' + (item.params.id || item.params.entry) + '">' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_item') + '" class="item-tpl ' + (options.simple ? '' : 'decorated ') + '"' + style + '>' + item.params.title + (item.params.quantity > 1 ? '</span>&nbsp;(' + item.params.quantity + ')' : '</span>') + '</span>';
        },
        ability: function(item, ref) {
            return '<span class="ability" data-ability_id="' + item.params.id + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        feature: function(item, ref) {
            return '<span class="feature" data-feature_id="' + item.params.id + '">' + "<span data-qtip=''+ ref.messages.get('stuff_tooltip_feature') +'' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.buff + ")'>" + item.params.title + '</span>' + '</span>';
        },
        timed: function(item, ref) {
            var img = ref.timed.get(item.params.id).img || {};
            return '<span>' + '<span data-qtip="' + ref.stats.get(item.params.id).label + '" class="item-tpl" style="background-image: url(' + IMAGE_URL + img.stuff + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        trophy: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_trophy') + '" class="item-tpl" style="background-image: url(' + IMAGE_URL + 'icons/ico_trophy.png)">' + item.params.quantity + '</span>' + '</span>';
        },
        turn: function(item, ref) {
            return '<span class="turn-link" data-turn_name="' + item.params.name + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        prep: function(item, ref) {
            return '<span class="prep-link" data-prep_name="' + item.params.name + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        battleaction: function(item, ref) {
            return '<span class="battleaction-link" data-battleaction_id="' + item.params.id + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        ingredients: function(item, ref) {
            return '<span>' + '<span data-qtip="' + (ref.ingredients.get(item.params.id).label) + '" class="">' + item.params.quantity + '</span>' + '</span>';
        }
    },
    /**
     * Преобразует данные по имуществу в HTML строку
     * @param {Array} stuff Массив или объект, описывающий имущество в формате:
     * 
     *   [{
     *      type: {String} тип имущества,
     *      params: {
     *          id: {String} идентификатор имущество
     *          quantity {Number} количество 
     *          title {String} Название, актуально для предмета
     *          label {String} Название, актуальное для абилки
     *      }
     *   }]
     *
     * @param {Object} options Настройки. Поддерживаемые настройки:
     *
     *    display = "inline"|"block". По умолчанию список выстраивается горизонтально (display = 'inline').
     *                                Чтобы выстроить его вертикально укажите display = 'block'
     *
     *    delimiter {String}. Разделитель списка. По умолчанию "&nbsp;"
     * 
     * @return {String}
     */
    printStuff: function(stuff, options) {
        if (!stuff)  {
            return '';
        }
        
        //если нет цены выходим, но лучше проверять заранее
        if (stuff.stuff) {
            stuff = stuff.stuff;
        }
        // новый формат с прогрессивной стоимостью. ({discount, old, stuff}). Пока просто беру, имущество игнорируя остальное
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        options = Ext.applyIf(options || {}, {
            display: 'inline',
            delimiter: '&nbsp;'
        });
        var ref = {
                currency: ExGodsCore.app.references.get('user_money'),
                timed: ExGodsCore.app.references.get('user_timed'),
                stats: ExGodsCore.app.references.get('user_stat'),
                icons: ExGodsCore.app.references.get('images').get('user_stuff_icons'),
                ingredients: ExGodsCore.app.references.get('ingredients'),
                messages: ExGodsCore.app.references.get('message_client')
            },
            html = [],
            tplFn;
        Ext.each(stuff, function(item) {
            if (Ext.isObject(item) && !Ext.Object.isEmpty(item)) {
                tplFn = ExGodsCore.util.Format.templates[item.type];
                if (tplFn) {
                    html = html.concat(tplFn(item, ref, options));
                } else {
                    /***/
                    ExGods.app.log('error', 'Шаблон для типа имущества ' + item.type + ' не определён.');
                }
            }
        });
        if (html.length > 1) {
            return '<ul class="exg-stuff exg-stuff-' + options.display + '">' + '<li>' + html.join(options.delimiter + '</li><li>') + '</li>' + '</ul>';
        } else {
            return '<span class="exg-stuff exg-stuff-' + options.display + '">' + html + '</span>';
        }
    },
    /**
     *
     * Напечатает иконку абилки(ах)
     * @return {String} reference - Справочник
     * @params {String} name - Имя скила
     *
     */
    printIcon: function(name, reference) {
        var iconHtml = '';
        var icon = reference == 'user_hoard' ? references.get(reference).getByKey(name).icon : reference == 'user_stat' ? references.get(reference).getByKey(name).param.icon : reference == 'user_summary' ? references.get(reference).getByKey(name).icon : name;
        if (icon) {
            iconHtml = '<img width="16" height="16" style="margin: 0 2px -3px 0;" src="' + IMAGE_URL + icon + '"/>';
        }
        return iconHtml;
    },
    /**
     * Печатает список наград.
     *
     * @param {Array} rewards Награды в формате имущества (см. @method ExGodsCore.util.Format.printStuff)
     * @param {Object} options Настройки (см. @method ExGodsCore.util.Format.printStuff)
     */
    printRewards: function(rewards, options) {
        return ExGodsCore.util.Format.printStuff(rewards, options);
    },
    /**
     * Напечатает информацию о предмете
     * @params {Object} itemParams Параметры предмета в формате имущества (id, title, quantity, grade)
     * @return {String}
     */
    printItem: function(itemParams) {
        return ExGodsCore.util.Format.printStuff({
            type: 'item',
            params: itemParams
        });
    },
    /**
     * Сортирует список наград.
     *
     * @param {Array} rewards Награды в формате имущества (см. @method ExGods.util.Format.printStuff)
     */
    sortRewards: function(rewards) {
        return Ext.Array.sort(rewards, function(a, b) {
            if (a.type == b.type)  {
                return 0;
            }
            
            if (a.type == 'item')  {
                return 1;
            }
            
            if (b.type == 'item')  {
                return -1;
            }
            
            if (a.type == 'trophy')  {
                return -1;
            }
            
            if (b.type == 'trophy')  {
                return 1;
            }
            
            if (a.type == 'expa')  {
                return -1;
            }
            
            if (b.type == 'expa')  {
                return 1;
            }
            
            if (a.type == 'valour')  {
                return -1;
            }
            
            if (b.type == 'valour')  {
                return 1;
            }
            
            if (a.type == 'trophy')  {
                return -1;
            }
            
            if (b.type == 'trophy')  {
                return 1;
            }
            
            if (a.type == 'currency')  {
                return -1;
            }
            
            if (b.type == 'currency')  {
                return 1;
            }
            
            if (a.type == 'ability')  {
                return -1;
            }
            
            if (b.type == 'ability')  {
                return 1;
            }
            
            if (a.type == 'feature')  {
                return -1;
            }
            
            if (b.type == 'feature')  {
                return 1;
            }
            
            if (a.type == 'timed')  {
                return -1;
            }
            
            if (b.type == 'timed')  {
                return 1;
            }
            
            return 1;
        });
    },
    /**
     * Напечатает большую информацию о предмете или валюте
     * @params {Object} itemParams Параметры предмета в формате имущества (id, title, quantity, grade)
     * @params {Object} options
     *          disabledImage {Boolean} Печатать чернобелые картинки
     *          checkUser {Boolean} Проверить наличие имущества у юзера, и если нет - соответственно нарисовать
     *          noSort {Boolean} тру если не надо сортировать награды
     *          skulls {Boolean} тру если надо рисовать черепки
     * @return {String}
     */
    printBigRewards: function(all_stuff, options) {
        var me = this,
            protos = ExGods.app.getItemPrototypesStore(),
            items = curency = '',
            missedProtos = [],
            items_count = 0;
        options = options || {};
        if (!options.noSort)  {
            all_stuff = ExGodsCore.util.Format.sortRewards(all_stuff);
        }
        
        for (var i = 0; i < all_stuff.length; i++) {
            var item_stuff = all_stuff[i];
            if (item_stuff.type == 'item' && item_stuff.item) {
                //при потере предмета после боя
                var proto_id = parseInt(item_stuff.params.id),
                    item = protos.data.getByKey(proto_id);
                var stars = '<div class="upgrade_stars_container">';
                for (var j = 0; j < item_stuff.item.param.upgrades; j++) {
                    stars += '<div class="upgrade_star"></div>';
                }
                stars += '</div>';
                if (item) {
                    items += '<div class="info-box-itembox item" id="item_proto_' + proto_id + '" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + (item_stuff.params.quantity > 1 ? item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>' : '') + (item_stuff.item.param.upgrades ? stars : '') + '</div>';
                    items_count++;
                } else {
                    missedProtos.push(proto_id);
                }
            } else if (item_stuff.type == 'item' && options.skulls) {
                var proto_id = parseInt(item_stuff.params.id),
                    item = protos.data.getByKey(proto_id);
                if (item) {
                    items += '<div class="info-box-itembox item" id="item_proto_' + proto_id + '" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + '<span class="stack-counter big_counter"><span class="big_counter_mid"><span class="skull"><div></div>x ' + (item_stuff.params.quantity || 1) + '</span></span></span>' + '</div>';
                    items_count++;
                } else {
                    missedProtos.push(proto_id);
                }
            } else if (item_stuff.type == 'item') {
                var proto_id = parseInt(item_stuff.params.id),
                    item = protos.data.getByKey(proto_id),
                    valid = options.checkUser && !ExGods.app.user.checkStuff([
                        item_stuff
                    ]),
                    haveItems = ExGods.app.user.getItemsCountByProto(proto_id);
                if (item) {
                    items += '<div class="info-box-itembox item" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" ' + (valid ? 'class="missed-item" ' : '') + 'src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + ((item_stuff.params.quantity > 1 || options.checkUser) ? (item_stuff.params.quantity < 99 && !options.checkUser) ? ('<span class="stack-counter' + (valid ? ' red_color' : '') + '">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid' + (valid ? ' red_color' : (options.checkUser ? ' green_color' : '')) + '">' + (options.checkUser ? haveItems + '/' : '') + item_stuff.params.quantity + '</span></span>' : '') + (item_stuff.params.extra ? '<div class="extra-expa"></div>' : '') + '</div>';
                    items_count++;
                } else {
                    missedProtos.push(proto_id);
                }
            } else if (item_stuff.type == 'currency') {
                var proto = ExGods.ref('user_money|' + item_stuff.params.id);
                items += '<div class="info-box-itembox item" data-big_stuff_img="' + proto.image_big + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.params.id + '" data-qtip="' + proto.label + '">' + '<img height="64" src="' + (options.disabledImage ? proto.image_disabled : proto.image_big) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa"></div>' : '') + '</div>';
                items_count++;
            } else if (item_stuff.type == 'ingredients') {
                var proto = ExGods.ref('ingredients|' + item_stuff.params.id);
                items += '<div class="info-box-itembox item" data-big_stuff_id = "' + item_stuff.params.id + '" data-big_stuff_img="' + IMAGE_URL + proto.params.images.img_1 + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="ingredients" data-qtip="' + proto.label + '">' + '<img height="64" src="' + IMAGE_URL + (options.disabledImage ? proto.params.images.img_2 : proto.params.images.img_1) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa"></div>' : '') + '</div>';
                items_count++;
            } else if (item_stuff.type == 'expa' || item_stuff.type == 'trophy') {
                var proto = ExGods.ref('user_hoard|' + item_stuff.type),
                    image = options.disabledImage ? proto.image_disabled : proto.image_big;
                items += '<div class="info-box-itembox item"  data-big_stuff_img="' + proto.image_big + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.type + '" data-qtip="' + proto.label + '">' + '<img height="64" src="' + (options.disabledImage ? proto.image_disabled : proto.image_big) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa"></div>' : '') + '</div>';
                items_count++;
            } else if (item_stuff.type == 'timed') {
                var proto = ExGods.ref('user_timed|' + item_stuff.params.id),
                    timed = ExGods.app.user.get('timed')[item_stuff.params.id],
                    valid = options.checkUser && !ExGods.app.user.checkStuff([
                        item_stuff
                    ]),
                    image = IMAGE_URL + proto.img.stuff,
                    //options.disabledImage ? proto.image_disabled : proto.image_big;
                    label = proto.img.label,
                    desc = proto.img.desc;
                /**
                 * timed - array
                 * timed[0] - Math.floor - текущее количество
                 * timed[1] - максимальное количество
                 * timed[2] - скорость восстановления (не нужно на клиенте)
                 * timed[3] - время до +1 (типа 1426066955)
                 */
                items += '<div class="info-box-itembox item" data-big_stuff_img="' + image + '" data-big_stuff_desc="' + Ext.String.htmlEncode(desc) + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.type + '" data-qtip="' + label + '">' + '<img class="' + (valid ? 'class="missed-item" ' : '') + '" height="64" src="' + image + '" width="64" />' + '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>' + '</div>';
                items_count++;
            } else if (item_stuff.type == 'feature') {
                var proto = ExGods.app.getFeaturePrototypesStore().getById(item_stuff.params.id);
                if (proto) {
                    items += '<div class="info-box-itembox item feature" data-feature_id="' + item_stuff.params.id + '" data-qtip="' + proto.data.label + '">' + '<div style="background-image: url(' + IMAGE_URL + proto.data.images.main + ');"></div>' + '</div>';
                    items_count++;
                }
            } else if (item_stuff.type == 'action') {
                var proto = ExGods.ref("direct_actions|" + item_stuff.params.id);
                if (proto) {
                    items += '<div class="info-box-itembox item action-item" data-action_id="' + item_stuff.params.id + '" data-qtip="' + proto.images.name + '">' + '<div style="background-image: url(' + IMAGE_URL + proto.images.simple + ');"></div>' + '</div>';
                    items_count++;
                }
            } else {
                curency += ExGodsCore.util.Format.printStuff(item_stuff) + '&nbsp;';
            }
        }
        return {
            items: items,
            currency: curency,
            missedProtos: missedProtos,
            itemsCount: items_count
        };
    },
    /**
     * Напечатает информацию о абилке(ах)
     * @params {Object} abilityParams Параметры предмета в формате имущества ([{id, label}, ... ])
     * @return {String}
     */
    printAbility: function(abilityParams) {
        var stuff = [];
        abilityParams = Ext.isArray(abilityParams) ? abilityParams : [
            abilityParams
        ];
        for (var i = 0; i < abilityParams.length; i++) {
            stuff.push({
                type: 'ability',
                params: {
                    id: abilityParams[i].id,
                    label: abilityParams[i].label
                }
            });
        }
        return ExGodsCore.util.Format.printStuff(stuff);
    },
    /**
     * Напечатает информацию о фиче(ах)
     * @params {Object} featureParams Параметры предмета в формате имущества ([{id, label}, ... ])
     * @return {String}
     */
    printFeature: function(featureParams) {
        var stuff = [];
        featureParams = Ext.isArray(featureParams) ? featureParams : [
            featureParams
        ];
        for (var i = 0; i < featureParams.length; i++) {
            stuff.push({
                type: 'feature',
                params: {
                    id: featureParams[i].id,
                    title: featureParams[i].label
                }
            });
        }
        return ExGodsCore.util.Format.printStuff(stuff);
    },
    /**
     * Напечатает money
     * @params {Object} moneyParams Параметры денег в формате валюты ([{name, value}, ... ])
     * @return {String}
     */
    printMoney: function(moneyParams) {
        var stuff = [];
        moneyParams = Ext.isArray(moneyParams) ? moneyParams : [
            moneyParams
        ];
        for (var i = 0; i < moneyParams.length; i++) {
            stuff.push({
                type: 'currency',
                params: {
                    id: moneyParams[i].name,
                    quantity: moneyParams[i].value
                }
            });
        }
        return ExGodsCore.util.Format.printStuff(stuff);
    },
    /**
     * Печатает время в удобочитаемом виде
     * @param {Number} time Время в секундах
     * @param {Object} options Настройки. Поддерживаемые настройки:
     *
     *  format = "detailed"|"threenums"|"short" - формат отображения. По умолчанию, "detailed"
     *
     *      Примеры: "detailed" - '7 дн. 10 ч. 10 м. 10 с',
     *               "short" - '7 дней' или '10:10:10'
     *               "threenums" - '2 недели 3 ч. 10 мин.' или '3 дня 10 ч. 10 мин.' или '10 ч. 10 мин. 10 сек.' 
     *               "twonums" - '13 ч 48 м'
     *               "bignums" - '13:48' в виде спрайта из больших цифр
     *
     *  emptyText = <String> - сообщение, если время <= 0
     *
     */
    printTime: function(time, options) {
        var me = this,
            units,
            delimiter = ' ',
            digitFormat = 'd',
            output = [],
            messages = ExGodsCore.app.references.get('message_client'),
            value, i,
            // Печатает одиночное число в опредленном формате
            // @param {Number} value Значение 
            // @param {digitFormat} Формат числа. "dd" - '01', "d" - '1'
            // @param {String} label Название единицы измерения
            printDigit = function(value, digitFormat, label) {
                var res = '';
                if (digitFormat == 'dd') {
                    res += (value < 10 ? '0' : '') + value;
                } else {
                    res += value;
                }
                if (label) {
                    if (Ext.isArray(label)) {
                        res += ' ' + Ext.util.Format.plural(value, units[i].label);
                    } else {
                        res += ' ' + label;
                    }
                }
                return res;
            };
        options = Ext.applyIf(options || {}, {
            format: 'detailed',
            emptyText: ''
        });
        if (time >= 1) {
            if (options.format == 'detailed') {
                units = [
                    {
                        max: 24 * 3600,
                        label: messages.get('date_format_days_dn') + '.'
                    },
                    {
                        max: 3600,
                        label: messages.get('date_format_hours_ch') + '.'
                    },
                    {
                        max: 60,
                        label: messages.get('date_format_minutes_min') + '.'
                    },
                    {
                        max: 1,
                        label: messages.get('date_format_seconds_s') + '.',
                        digitFormat: 'dd'
                    }
                ];
            } else if (options.format == 'threenums') {
                if (time / (7 * 24 * 3600) > 1) {
                    units = [
                        {
                            max: 7 * 24 * 3600,
                            label: messages.get('date_format_weeks_n') + '.'
                        },
                        // ['неделя', 'недели', 'недель']
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d') + '.'
                        },
                        // ['день', 'дня', 'дней']
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        }
                    ];
                }
                // ['час', 'часа', 'часов']
                else if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_dn') + '.'
                        },
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m') + '.'
                        }
                    ];
                } else {
                    units = [
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m') + '.'
                        },
                        {
                            max: 1,
                            label: messages.get('date_format_seconds_s') + '.',
                            digitFormat: 'dd'
                        }
                    ];
                }
            } else if (options.format == 'twonums') {
                if (time / (7 * 24 * 3600) > 1) {
                    units = [
                        {
                            max: 7 * 24 * 3600,
                            label: messages.get('date_format_weeks_n')
                        },
                        // ['неделя', 'недели', 'недель']
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d')
                        }
                    ];
                }
                // ['день', 'дня', 'дней']
                else if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d')
                        },
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch')
                        }
                    ];
                } else if (time / (3600) > 1) {
                    units = [
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch')
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m')
                        }
                    ];
                } else {
                    units = [
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m')
                        },
                        {
                            max: 1,
                            label: messages.get('date_format_seconds_s'),
                            digitFormat: 'dd'
                        }
                    ];
                }
            } else if (options.format == 'bignums') {
                if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_text').split(',')
                        }
                    ];
                } else {
                    delimiter = ':';
                    digitFormat = 'dd';
                    units = [
                        {
                            max: 3600,
                            label: ''
                        },
                        {
                            max: 60,
                            label: ''
                        },
                        {
                            max: 1,
                            label: ''
                        }
                    ];
                }
            } else {
                if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_text').split(',')
                        }
                    ];
                } else {
                    delimiter = ':';
                    digitFormat = 'dd';
                    units = [
                        {
                            max: 3600,
                            label: ''
                        },
                        {
                            max: 60,
                            label: ''
                        },
                        {
                            max: 1,
                            label: ''
                        }
                    ];
                }
            }
            for (i = 0; i < units.length; i++) {
                value = Math.floor(time / units[i].max);
                if (value != 0 || (options.format == 'short' && units[i].max != 3600) || (options.format == 'threenums' && (units[i].max == 1 || output.length)) || (options.format == 'twonums' && (units[i].max == 1 || output.length)) || (options.format == 'bignums' && units[i].max != 3600)) {
                    output.push(printDigit(value, units[i].digitFormat || digitFormat, units[i].label));
                    time -= value * units[i].max;
                }
            }
            if (options.format == 'bignums') {
                var sprites = [];
                if (output.length == 1) {
                    output.unshift('0');
                }
                Ext.Array.each(output, function(num) {
                    sprites.push(me.printSprite(num, IMAGE_URL + '/numbers.png', {
                        width: 21,
                        height: 30,
                        twoDigits: true
                    }));
                });
                return sprites.slice(0, 2).join('<span class="bignum-delimiter"></span>');
            } else  {
                return output.join(delimiter);
            }
            
        } else {
            return options.emptyText;
        }
    },
    /**
     * Напечатает время, оставшееся до даты (@param date) в удобном виде
     * @param {Date} date
     * @param {Object} options Настройки:
     *
     *  format = "detailed"|"short" (см. настройки для ExGodsCore.util.Format.printTime)
     *
     *  emptyText - Текст, который будет отображен, если дата истекла
     */
    printRestTime: function(date, options) {
        var restTime;
        options = Ext.applyIf(options || {}, {
            emptyText: '',
            stringFormat: '{0}'
        });
        restTime = Math.ceil((date - new Date()) / 1000);
        if (restTime > 0) {
            return Ext.String.format(options.stringFormat, this.printTime(restTime, options));
        } else {
            return options.emptyText;
        }
    },
    /**
     * Вернет число разделенное на порядки.
     *
     * @param {Number/String} quantity Число которое необходимо разделить
     * @param {Number} shortFrom Число, начиная с которого нужно перобразовывать в короткую форму (используя "k/kk"). По умолчанию 1000
     *   Например, для shortFrom = 10000, число 123456 будет выведено как "123к", а число 1234567 - "1кк"
     * @param {String} format Формат числа, соответсвующий параметру format функции Ext.util.Format.number. По умолчанию, '0,0'
     * @param {String} decimalFormat Формат числа с дробной частью
     */
    printNumber: function(quantity, shortFrom, format, decimalFormat) {
        var postfix = '';
        quantity = '' + quantity;
        // преобразую в строку
        shortFrom = shortFrom || 1000000000;
        format = format || '0,0';
        if (quantity >= shortFrom) {
            if (quantity >= 10000000) {
                quantity = quantity.substr(0, quantity.length - 6);
                postfix = 'кк';
            } else if (quantity >= 1000000) {
                quantity = (parseInt(quantity.substr(0, quantity.length - 5)) / 10).toString();
                postfix = 'кк';
            } else if (quantity >= 10000) {
                quantity = quantity.substr(0, quantity.length - 3);
                postfix = 'к';
            } else if (quantity >= 1000) {
                quantity = (parseInt(quantity.substr(0, quantity.length - 2)) / 10).toString();
                postfix = 'к';
            }
        }
        if (quantity.split('.').length > 1 && decimalFormat) {
            format = decimalFormat;
        }
        return Ext.util.Format.number(quantity, format) + postfix;
    },
    /**
     * Напечатает данные пользователя (имя, ранк, уровень)
     * @param {Object} user Данные пользователя
     * @param {Object} options Настройки:
     *  
     *  fields - список полей, которые нужно вывести. По умолчанию, ['name', 'rank', 'level', 'infoicon']. Допускается передавать в строке, разделяя запятыми
     *           Поддерживаемые поля: 'name', 'rank', 'level', 'infoicon', 'mentoricon', 'immuneicon'
     *
     *  maxNameWidth - максимальная ширина имени пользователя в пикселях. По умолчанию не определено.
     *
     *  cls - css класс, который добавиться к корневому элементу
     *
     */
    printUserInfo: function(user, options) {},
    //дефолтная функция
    /**
     * Печатает статы юзера.
     * @param {Array} stats 
     * @param {Object} options Настройки:
     *  visibleValue - значение свойства visible у стата, для которого делать вывод.
     *  column - кол-во колонок, в которых выводить статы. По умолчанию 1
     *  changes - хеш изменений значений статов
     *  inline - если true - отображать в одну строку, по умолчанию false
     */
    printUserStats: function(stats, options) {
        var data = {
                stats: []
            },
            statsRef = ExGodsCore.app.references.get('user_stat'),
            statInfo,
            tpl = new Ext.XTemplate([
                '<tpl if="options.visibleValue == 1">',
                '<tpl if="options.inline">',
                '<ul class="inline-list">',
                '<tpl for="stats">',
                '<li>',
                '<span class="value icon">{[ ExGodsCore.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ ExGods.printNumber(this.printValue(values.value), 1000, "0", "0.0") ]}</span>',
                '</li>',
                '</tpl>',
                '</ul>',
                '<tpl elseif="options.align != \'right\'">',
                '<table class="user-stats user-stats-{options.visibleValue}">',
                '<tpl for="stats">',
                '<tr class="{[xindex % 2 === 0 ? "even" : ""]}">',
                '<td>{label}</td>',
                '<td>',
                '<span class="value icon">{[ ExGodsCore.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ this.printValue(values.value) ]}',
                '<tpl if="changes">',
                '<span class="changes"><small>(</small><span class="{[ values.changes > 0 ? "up" : "down" ]}">{[values.changes > 0 ? "+" : ""]}{changes}</span><small>)</small>',
                //maxStat
                '<tpl if="maxStat">',
                '<small>(</small><span style="color:' + ExGods.ref('constants|max_upgrade_color').value + '">max. {maxStat}</span><small>)</small>',
                '</tpl>',
                '</span>',
                '</tpl>',
                '</span>',
                '</td>',
                '</tr>',
                '</tpl>',
                '</table>',
                '<tpl else>',
                '<ul class="table-list">',
                '<tpl for="stats">',
                '<li class="{[xindex % 2 === 0 ? "even" : ""]}">',
                '<span class="label">{label}</span>',
                '<span class="value icon">{[ ExGodsCore.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ this.printValue(values.value) ]}',
                '<tpl if="changes">',
                '<span class="changes"><small>(</small><span class="{[ values.changes > 0 ? "up" : "down" ]}">{[values.changes > 0 ? "+" : ""]}{changes}</span><small>)</small>',
                //maxStat
                '<tpl if="maxStat">',
                '<small>(</small><span style="color:' + ExGods.ref('constants|max_upgrade_color').value + '">max. {maxStat}</span><small>)</small>',
                '</tpl>',
                '</span>',
                '</tpl>',
                '</span>',
                '</li>',
                '</tpl>',
                '</ul>',
                '</tpl>',
                '<tpl else>',
                '<table class="user-stats user-stats-{options.visibleValue}">',
                '<tpl if="options.visibleValue == 2">',
                '<tr>',
                '<tpl for="stats">',
                '<td data-qtip="{label} - {[ this.printValue(values.value) ]}">',
                '<div class="background" style="background: url(' + IMAGE_URL + '{param.empty})">',
                '<div class="icon" style="background: url(' + IMAGE_URL + '{param.icon})"></div>',
                '<div class="fill-red" style="{[ this.getRedStarsStyle(values.value) ]}"></div>',
                '<div class="fill-green" style="{[ this.getGreenStarsStyle(values.value) ]}"></div>',
                '<div class="fill" style="{[ this.getStarsStyle(values.value) ]};background: url(' + IMAGE_URL + '{param.fill});"></div>',
                '</div>',
                '</td>',
                '<tpl if="xindex % 2 == 0 && xindex < xcount">',
                '</tr><tr>',
                '</tpl>',
                '</tpl>',
                '</tr>',
                '</tpl>',
                '</table>',
                '</tpl>',
                {
                    printValue: function(v) {
                        return Ext.isArray(v) ? v[0] : /*+ '/' + v[1]*/
                        v;
                    },
                    getRedStarsStyle: function(v) {
                        var style = [];
                        style.push('background: url(' + IMAGE_URL + 'mask/star_red.png)');
                        if (Ext.isArray(v) && v[0] < v[1]) {
                            style.push('left: ' + (24 + v[0] * 14) + 'px');
                            style.push('width: ' + (Math.min(v[1] - v[0], 5 - v[0]) * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    getGreenStarsStyle: function(v) {
                        var style = [];
                        style.push('background: url(' + IMAGE_URL + 'mask/star_green.png)');
                        if (Ext.isArray(v) && v[0] > v[1]) {
                            style.push('left: ' + (24 + v[1] * 14) + 'px');
                            style.push('width: ' + (Math.min(v[0] - v[1], 5 - v[1]) * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    getStarsStyle: function(v) {
                        var style = [];
                        if (Ext.isArray(v)) {
                            style.push('width: ' + (Math.min(v[0], v[1]) * 14) + 'px');
                        } else {
                            style.push('width: ' + (v * 14) + 'px');
                        }
                        return style.join(';');
                    }
                }
            ]);
        data.options = Ext.applyIf(options || {}, {
            columns: 1,
            visibleValue: 1,
            inline: false,
            changes: {},
            maxStats: {}
        });
        var sorters = {
                damage: 1,
                fury: 5,
                hp: 2,
                mp: 4,
                shield: 3,
                stamina: 3,
                strength: 2,
                accuracy: 4,
                agility: 1
            };
        // подготавливаю данные для шаблона
        Ext.Object.each(stats, function(key, value) {
            statInfo = statsRef.get(key);
            if (!statInfo) {
                /***/
                ExGods.app.log('error', 'Данные для стата ' + key + ' не найдены в справочнике');
                return;
            }
            if ((options.visibleValue == statInfo.visible) && (value != null)) {
                // if(options.visibleValue == 2 && data.options.changes[key]){
                //  value = [value, value - data.options.changes[key]];
                // }
                data.stats.push({
                    name: key,
                    value: value,
                    label: statInfo.label,
                    visible: statInfo.visible,
                    param: statInfo.param,
                    changes: data.options.changes[key],
                    maxStat: data.options.maxStats[key]
                });
            }
        });
        if (data.stats.length) {
            Ext.Array.sort(data.stats, function(a, b) {
                return sorters[a.name] > sorters[b.name];
            });
            return tpl.apply(data);
        } else  {
            return '';
        }
        
    },
    /**
     * Печатает цисло по спрайту
     * @param {Number} number - required - число;
     * @param {String} sprite - ссылка на картинку спрайта, либо полная либо от корня. Можно не передавать, если задать в css в классе util-sign
     * @param {Object} options - required - параметры
     * - @param {Boolean} horizontal - default:false. Определяет, горизонтальный спрайт или вертикальный
     * - @param {String} indent - отступ, с которого начинать рисовать спрайт. Если спрайт горизонтальный -
     *      то отступ вертикальный и наоборот.
     * - @param {String} cls - css класс контейнера
     * - @param {String} tag - dom tag контейнера
     * - @param {Number} width - required - ширина цифры
     * - @param {Number} height - required - высота цифры
     * - @param {Boolean} lastZero - default: false Если в спрайте "0" стоит на последнем месте
     * - @param {Boolean} twoDigits - default: false для цифр с длиной 1 добавлять 0 в начале
     */
    printSprite: function(number, sprite, options) {
        var n = parseInt(number).toString(),
            w = options.width,
            h = options.height,
            tag = options.tag || 'div',
            cls = options.cls || '',
            i = 0,
            totalWidth = 0,
            numberHtml = '',
            left, top, sign, bgimg, bgpos;
        if (sprite) {
            sprite = (sprite.substr(0, 4) == 'http') ? sprite : IMAGE_URL + sprite;
        }
        if (options.twoDigits && n.length == 1)  {
            n = '0' + n;
        }
        
        for (; i < n.length; i++) {
            totalWidth += w;
            sign = parseInt(n.charAt(i));
            if (options.lastZero) {
                if (sign === 0) {
                    sign = 9;
                } else {
                    sign--;
                }
            }
            if (options.horizontal) {
                left = sign ? '-' + sign * w + 'px' : 0;
                top = options.indent || 0;
            } else {
                left = options.indent || 0;
                top = sign ? '-' + sign * h + 'px' : 0;
            }
            bgpos = 'background-position: ' + left + ' ' + top;
            bgimg = (sprite) ? 'background-image: url(' + sprite + ');' : '';
            numberHtml += '<div class="util-sign" style="' + bgimg + bgpos + ';width:' + w + 'px;height:' + h + 'px"></div>';
        }
        result = '<' + tag + ' class="util-sign-container ' + cls + '">' + '<div style="width:' + totalWidth + 'px;height:' + h + 'px">' + numberHtml + '</div>' + '</' + tag + '>';
        return result;
    }
};
// aliases
ExGodsCore.printUser = ExGodsCore.util.Format.printUserInfo;
ExGodsCore.printItem = ExGodsCore.util.Format.printItem;
ExGodsCore.printAbility = ExGodsCore.util.Format.printAbility;
ExGodsCore.printFeature = ExGodsCore.util.Format.printFeature;
ExGodsCore.printNumber = ExGodsCore.util.Format.printNumber;
ExGodsCore.printMoney = ExGodsCore.util.Format.printMoney;
ExGodsCore.printIcon = ExGodsCore.util.Format.printIcon;
ExGodsCore.printBigRewards = ExGodsCore.util.Format.printBigRewards;

/**
 * Организует взаимодействие с сервером через ajax
 *
 * @oleg
 */
Ext.define('ExGodsCore.AjaxRequest', {
    singleton: true,
    mixins: {
        observable: Ext.util.Observable
    },
    /**
     * @property {Array} keyHandlersSequence Последовательность выполнения обработчиков по ключу (см. {@link this#addKeyHandler addKeyHandler}) 
     * @readonly
     */
    keyHandlersSequence: [],
    constructor: function(config) {
        config = config || {};
        Ext.apply(this, config);
        /**
         * @event jsondecodeerror
         * Ошибка парсинга ответа от сервера
         * @param {String} response
         */
        /**
         * @event requestexception
         * Ошибка запроса
         * @param {Ext.data.Connection} conn This Connection object.
         * @param {Object} response The XHR object containing the response data.
         * See [The XMLHttpRequest Object](http://www.w3.org/TR/XMLHttpRequest/) for details.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        Ext.Ajax.on('requestexception', function(conn, response, options) {
            this.fireEvent('requestexception', conn, response, options);
        }, this);
        this.mixins.observable.constructor.call(this);
    },
    /**
     * Общий метод обращения к серверу.  
     *
     * Функция по умолчанию указывает запросам, что они должны вставать в очередь,
     * которая реализована в переписанном методе Ext.Ajax#request - см. overrides
     *
     * @param {Object} args Аргументы аналогичные {@link Ext.data.Connection#request Ext.Ajax.request}
     */
    request: function(args) {
        var me = this,
            success = args.success,
            failure = args.failure,
            callback = args.callback,
            app = this.application;
        if (HOST_URL) {
            args.url = HOST_URL + args.url;
            args.cors = true;
            args.withCredentials = true;
        }
        delete args.success;
        if (typeof success == 'function') {
            success = {
                afterKeyHandlers: success
            };
        }
        args = Ext.apply({
            success: function(response, options) {
                var result = Ext.decode(response.responseText, true);
                if (!result) {
                    me.fireEvent('jsondecodeerror', response, args);
                } else {
                    if (success && success.beforeKeyHandlers) {
                        success.beforeKeyHandlers.call(this, result, options);
                    }
                    me.invokeKeyHandlers(result);
                    if (success && success.afterKeyHandlers) {
                        success.afterKeyHandlers.call(this, result, options);
                    }
                }
            },
            scope: args.scope || this
        }, args);
        // по умолчанию запрос ставим в очередь
        Ext.applyIf(args, {
            queue: true
        });
        return Ext.Ajax.request(args);
    },
    /** 
     * Задает последовательность выполнения обработчиков по ключу (см. {@link this#addKeyHandler addKeyHandler}) 
     * Этот метод должен быть вызван до первого вызова addKeyHandler, т.к. добавление обработчика уже работает с этой последовательностью
     * @param {Array} sequence Список ключей
     */
    initKeyHandlersSequence: function(sequence) {
        this.keyHandlersSequence = sequence;
    },
    /**
     * Добавить обработчик респонса от сервера по ключу в данных ответа.
     *   
     *  @param {String} key Ключ в респонсе, наличие которого требуется для выполнения обработчика. Если нет, то обработчик будет вызываться на любой запрос
     *  @param {Function} handler Функция-обработчик с параметрами: data (ответ сервера )
     *
     */
    addKeyHandler: function(key, handler, scope) {
        var me = this;
        if (!me.keyHandlers) {
            me.keyHandlers = [];
        }
        if (!me.keyHandlers[key]) {
            me.keyHandlers[key] = [];
        }
        me.keyHandlers[key].push({
            fn: handler,
            scope: scope || me
        });
        if (Ext.Array.indexOf(me.keyHandlersSequence, key) == -1) {
            // если ключ не добавлен в последовательность обработки - добавляю его в самый конец
            me.keyHandlersSequence.push(key);
        }
    },
    /**
     * @private
     */
    invokeKeyHandlers: function(data) {
        var me = this;
        Ext.iterate(me.keyHandlersSequence, function(key, index) {
            if (data.hasOwnProperty(key) && me.keyHandlers && me.keyHandlers[key]) {
                Ext.Array.each(me.keyHandlers[key], function(handler) {
                    handler.fn.call(handler.scope, data);
                });
            }
        });
    }
});

/**
 * Mixin, позволюяет объекту отправлять ajax запросы
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGodsCore.util.Ajaxable', {
    /**
     * Ajax-запрос на сервер
     * @param {Object} args Стандартные аргументы Ext.Ajax.request
     */
    ajaxRequest: function(args) {
        if (!args.scope) {
            args.scope = this;
        }
        return ExGodsCore.AjaxRequest.request(args);
    },
    /** 
     * Псевдоним для ajaxRequest
     */
    request: function() {
        return this.ajaxRequest.apply(this, arguments);
    },
    /**
     * См. {@link ExGodsCore.AjaxRequest#addKeyHandler addKeyHandler}
     */
    addAjaxRequestKeyHandler: function(key, handler, scope) {
        return ExGodsCore.AjaxRequest.addKeyHandler(key, handler, scope);
    }
});

/**
 * Создает и управляет коннекцией чата
 */
Ext.define('ExGodsCore.ChatConnection', {
    mixins: {
        observable: Ext.util.Observable,
        loggable: ExGodsCore.util.Loggable,
        ajaxable: ExGodsCore.util.Ajaxable
    },
    logConfig: {
        enabled: {
            info: false,
            error: true,
            warn: true
        },
        prefix: 'ChatConnection:'
    },
    //  requires:'ExGodsCore.controller.Direction',
    /**
     * @cfg {String} login (required)
     */
    /**
     * @cfg {String} password(required)
     */
    /**
     * @cfg {Boolean} disabled Признак блокировки чата
     */
    disabled: true,
    /**
      * @cfg {Number} pingPeriod
      * Период пинга сервера в секундах
      */
    pingPeriod: 60,
    /**
      * @cfg {Number} privateMessages
      * количество приватных сообщений за время пинга
      */
    privateMessages: 0,
    /**
      * @cfg {Number} publicMessages
      * количество публичных сообщений за время пинга
      */
    publicMessages: 0,
    constructor: function(config) {
        var me = this;
        Ext.apply(me, config);
        me.mixins.observable.constructor.call(me, config);
        me.mixins.loggable.constructor.call(me, config);
        me.mixins.ajaxable.constructor.call(me, config);
        //
        // @oleg commented cause addEvents is deprecated in 5.1.1
        //
        // me.addEvents(
        //  /**
        //   * @event beforeconnect
        //   * Выкидывается перед коннектом чата
        //   * @param this
        //   */
        //  'beforeconnect',
        //  /**
        //   * @event connect
        //   * Выкидывается после ТЕХНИЧЕСКОГО коннекта к чату. Полноценный коннект присутствиует после события "ready"
        //   */
        //  'connect',
        //  /**
        //   * @event presenceinit
        //   * Пришло наше присутствие подтверждено сервером
        //   * @param this
        //   */
        //  'presenceinit',
        //  /**
        //   * @event ready
        //   * Клиент чата готов к работе!
        //   * @param this
        //   * @param {Object} data Данные команды cmd=connect
        //   */
        //  'ready',
        //  /**
        //   * @event presenceavail
        //   * Пришло новое присутствие
        //   * @param this
        //   * @param {Object} data
        //   * @param {Object} presence
        //   */
        //  'presenceavail',
        //  /**
        //   * @event presenceunavail
        //   * Присутствие отключено
        //   * @param this
        //   * @param {Object} data
        //   * @param {Object} presence
        //   */
        //   'presenceunavail',
        //  /**
        //   * @event presenceerror
        //   * Ошибка присутствия
        //   * @param this
        //   * @param {Object} data
        //   * @param {Object} presence
        //   */
        //   'presenceerror',
        //   /**
        //   * @event disabled
        //   * Выкидывается при блокировки чата
        //   * @param this
        //   */
        //   'disabled',
        //   /**
        //   * @event enabled
        //   * Выкидывается при разблокировки чата
        //   * @param this
        //   */
        //   'enabled',
        //   /**
        //    * @event ping
        //    * Выбрасывается на положительный ответ от сервера на команду ping
        //    * @param this
        //    * @param {Object} data Ответ от сервера
        //    */
        //    'ping'
        // );
        window.onbeforeunload = function() {
            /***/
            me.log('info', 'отключение от чата по событию объекта window "onbeforeunload"');
            me.xmppChat.disconnect();
        };
        me.callParent(arguments);
    },
    /**
     * Коннект к чату
     */
    connect: function() {
        this.auth();
    },
    /**
     * Отправляет сообщение
     * @param {Object} message Сообщение
     *   {
     *      from - ник юзера от кого сообщение
     *      to - список юзеров, кому сообщение
     *      type - тип сообщения ("private" или "to")
     *      content - текст сообщения
     *      roomId - id комнаты, в которую передается сообщение. Необходимо только для комнатных сообщений
     *   }
     */
    sendMessage: function(message, attrs) {
        var me = this,
            to = message.to,
            content = message.content;
        attrs = attrs || {};
        if (content) {
            switch (message.type) {
                case 'private':
                    // отправка привата
                    if (to.length > 1) {
                        me.xmppChat.sendMultiPrivateMessage(to.join(','), content, attrs);
                    } else {
                        me.xmppChat.sendPrivateMessage(to[0], content, attrs);
                    };
                    me.privateMessages++;
                    break;
                case 'to':
                    // отправка комнатного сообщения персонажу(ам)
                    me.xmppChat.sendRoomMessage(message.roomId, content, Ext.apply(attrs, {
                        to: Ext.JSON.encode(message.to)
                    }));
                    me.publicMessages++;
                    break;
                default:
                    // отправка комнатного сообщения
                    me.xmppChat.sendRoomMessage(message.roomId, content, attrs);
                    me.publicMessages++;
                    break;
            }
        }
    },
    /**
     * @private
     * Авторизация в чате
     * @param {String} login
     * @param {String} password
     */
    auth: function() {
        var me = this;
        /***/
        me.log('info', 'запрашиваем коннект к чату');
        me.fireEvent('beforeconnect', me);
        XMPPChat.BOSH_SERVICE = HOST_URL + XMPPChat.BOSH_SERVICE;
        // вешаем события на чат
        me.xmppChat = new XMPPChat.Connection(me.login, me.password, 'Game', {
            onConnect: Ext.bind(me.onConnect, me),
            onPresence: Ext.bind(me.onPresence, me),
            onMessage: Ext.bind(me.onMessage, me),
            onDisconnect: Ext.bind(me.onDisconnect, me)
        });
        me.xmppChat.connect();
    },
    /**
     * @private
     * Обрабатывает подключение к чату
     */
    onConnect: function() {
        var me = this;
        /***/
        me.log('info', 'коннект получен - запрашиваем станс присутствия');
        me.xmppChat.sendPresence(me.xmppChat);
        me.fireEvent('connect');
    },
    /**
     * @private
     * Обработка события "присутствие"
     */
    onPresence: function(data, presence) {
        var me = this;
        /***/
        me.log('info', 'присутствие', data);
        if (data.roomId) {
            if (data.type == 'error') {
                me.fireEvent('presenceerror', me, data, presence);
            } else if (data.type == 'unavailable') {
                me.fireEvent('presenceunavail', me, data, presence);
            } else {
                me.fireEvent('presenceavail', me, data, presence);
            }
        } else if (data.fromJID === data.toJID) {
            me.fireEvent('presenceinit', me);
            me.ajaxRequest({
                url: '/game.pl?cmd=connect',
                params: {
                    localtime: Ext.Date.format(new Date(), 'Y-m-d H:i:s')
                },
                success: function(result) {
                    if (result.success == 1) {
                        if (!me.pingTask) {
                            // пинг для поддержания сессии каждую минуту
                            me.pingTask = Ext.TaskManager.start({
                                interval: me.pingPeriod * 1000,
                                run: me.ping,
                                scope: me
                            });
                        }
                        me.fireEvent('ready', me, result);
                    }
                }
            });
        }
    },
    // Блок получения и обработки сообщений от сервера
    /**
     * @private
     * Обработка входящего сообщения
     * 
     * @param {Object} data
     * @param {Object} xml
     */
    onMessage: function(data, xml) {
        var me = this;
        /***/
        me.log('info', 'сообщение с типом "' + data.type + '"', data);
        // убираем ненужную информацию
        delete data.xmlBody;
        if (data.x) {
            if (me.disabled && data.type != XMPPChat.MT_COMMAND) {
                // если чат заблокирован - разрешены только системные сообщения
                return;
            }
            if (data.type != XMPPChat.MT_COMMAND) {
                // экранируем теги для сообщений, кроме команд от сервера
                data.body = Ext.String.htmlEncode(data.body);
            }
            switch (data.type) {
                case 'error':
                case 'room':
                case 'private':
                    /**
                     * @event message_error
                     * Выбрасывается на сообщение с типом "error"
                     * @param this
                     * @param {Object} data Данные сообщения
                     */
                    /**
                     * @event message_room
                     * Выбрасывается на сообщение с типом "room"
                     * @param this
                     * @param {Object} data Данные сообщения
                     */
                    /**
                     * @event message_private
                     * Выбрасывается на сообщение с типом "private"
                     * @param this
                     * @param {Object} data Данные сообщения
                     */
                    me.fireEvent('message_' + data.type, me, data);
                    break;
                case XMPPChat.MT_COMMAND:
                    var body = Ext.decode(data.body, true);
                    if (Ext.isArray(body)) {
                        // сортирую пакет по log_id. Если log_id не указан - вконец
                        body = Ext.Array.sort(body, function(a, b) {
                            if (!a.data.log_id)  {
                                return 1;
                            }
                            
                            if (!b.data.log_id)  {
                                return -1;
                            }
                            
                            return a.data.log_id - b.data.log_id;
                        });
                        for (var i in body) {
                            if (body[i]) {
                                var cmdData = Ext.clone(data);
                                cmdData.body = body[i];
                                if (!cmdData.body.remove)  {
                                    cmdData.body = Ext.decode(me.application.getController('Direction').processText(Ext.encode(cmdData.body)));
                                }
                                
                                try {
                                    /**
                                     * генерирую событие на все команды
                                     */
                                    me.fireEvent('message_command', me, cmdData);
                                    /**
                                     * Генерирую события вида "command_post", "command_user".
                                     * Обработка должна идти в соответствующих контроллерах
                                     */
                                    me.fireEvent('command_' + cmdData.body.type, me, cmdData);
                                } catch (e) {
                                    /***/
                                    me.log('error', 'Ошибка обработки команды чата ', cmdData, e);
                                }
                            }
                        }
                    };
                    break;
                default:
                    /**
                     * @event message_default
                     * Выбрасывается на сообщение с неопределенным типом
                     * @param this
                     * @param {Object} data Данные сообщения
                     */
                    me.fireEvent('message_default', me, data);
                    break;
            }
        }
    },
    /**
     * @private
     * Обработка события отключения от чата
     */
    onDisconnect: function() {
        var me = this;
        /***/
        me.log('info', 'произошло отключение от чата - новый запрос на авторизацию');
        me.auth();
    },
    /**
     * Заблокировать/разблокировать чат.
     */
    setDisabled: function(v) {
        var me = this;
        if (me.disabled !== v) {
            me.disabled = v;
            me.fireEvent(me.disabled ? 'disabled' : 'enabled', me);
        }
    },
    /**
     * Добавить параметр к пингу
     */
    addPingParam: function(param, value) {
        var me = this;
        me.pingParams = me.pingParams || {};
        me.pingParams[param] = value;
    },
    /**
     * @private
     * Поддерживает игровую сессию
     */
    ping: function() {
        var me = this,
            params = {};
        if (me.pingParams) {
            for (var key in me.pingParams) {
                if (typeof me.pingParams[key] == 'function') {
                    params[key] = me.pingParams[key]();
                } else {
                    params[key] = me.pingParams[key];
                }
            }
        }
        //отправляю статистику по количеству отправленных сообщений
        if (me.privateMessages) {
            params.private_messages = me.privateMessages;
            me.privateMessages = 0;
        }
        if (me.publicMessages) {
            params.public_messages = me.publicMessages;
            me.publicMessages = 0;
        }
        me.request({
            url: '/ping.pl',
            params: params,
            success: function(result) {
                if (result.success != 1) {
                    window.location = isSocialApp ? '/logout-social.html' : '/';
                } else {
                    ExGodsCore.util.Date.serverTimeOffset = parseInt(new Date().getTime() / 1000, 10) - result.now;
                    me.fireEvent('ping', result);
                }
            },
            failure: function() {
                window.location = isSocialApp ? '/logout-social.html' : '/';
            }
        });
    }
});

/**
 * Базовый контроллер, от которого наследуются почти все остальные.
 * В нём собраны общие методы.
 */
Ext.define('ExGodsCore.controller.Base', {
    extend: Ext.app.Controller,
    mixins: [
        ExGodsCore.util.Loggable,
        ExGodsCore.util.Ajaxable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BaseCtrl:'
    },
    /**
     * добавляем рефы, сторы, вьюшки и модели родителя, если они не совпадают с существующими.
     */
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        if (me.superclass.config.refs) {
            me.ref(me.superclass.config.refs);
        }
    },
    doInit: function() {
        this.app = this.application;
        // просто короче название ссылки на app
        this.user = this.app.user;
        // ссылка на юзера
        this.callParent(arguments);
    },
    /**
     * Возвращает текущего пользователя
     * 
     * @return {ExGods.model.User}
     */
    getUser: function() {
        return this.app.user;
    },
    /**
     * Возвращает модель текущей локации пользователя
     * @return {Ext.data.Model}
     */
    getLocation: function() {
        return this.app.getLocation();
    },
    /**
     * Возвращает модель текущего мира пользователя
     * @return {Ext.data.Model}
     */
    getWorld: function() {
        return this.app.getWorld();
    }
});

/**
 * Модель сообщения чата
 */
Ext.define('ExGodsCore.model.ChatMessage', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'body',
            type: 'auto'
        },
        {
            name: 'from',
            type: 'string'
        },
        {
            name: 'fromJID',
            type: 'string'
        },
        {
            name: 'roomId',
            type: 'string'
        },
        {
            name: 'toJID',
            type: 'string'
        },
        {
            name: 'tpl',
            type: 'string'
        },
        {
            name: 'type',
            type: 'string'
        },
        {
            name: 'x',
            type: 'auto'
        }
    ]
});

/**
 * Кастомный компонент прокрутки.
 * Вся анимация происходит, когда меняется значение Ext.slider.Single скроллера.
 * Прокрутка работает только с компонентами унаследованными от Ext.panel.Panel,
 * т.к. в них присутствуют dock элементы необходимые для плагина.
 */
Ext.define('ExGodsCore.view.plugin.Scroller', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.corescroller',
    /**
     * @cfg {Boolean} [autoHide=false]
     * Следует ли панеле автоматически исчезать/появляться при необходимости
     */
    autoHide: false,
    /**
     * @private
     * @property {Ext.Component} cmp
     * Компонента, к которой применяется плагин
     */
    /**
     * @cfg {Number} scrollDeltaY шаг вертикального скрола в пикселях
     * {
     *  default:40
     * }
     */
    scrollDeltaY: 40,
    /**
     * @property {Ext.dom.Element} scrollEl
     * Элемент внутри которого осуществляется прокрутка
     */
    /**
     * @cfg {Boolean} [scrollToTopOnResize=false]
     * Прокручивать наверх при изменениях
     */
    scrollToTopOnResize: false,
    /**
     * @cfg {String/Boolean} [snap=false]
     * Селектор по которому осуществляется выравнивание после прокрутки
     */
    snap: false,
    /**
     * @cfg {Boolean} autoRestorePosition Автоматически восстанавливать позицию скролла после обновления лейаута компонента
     */
    autoRestorePosition: false,
    /**
     * @cfg {Object} scrollerConfig
     * Default:
     * {
     *  slider:{ <Полоска слайдера>
     *      animate: false,
     *      decimalPrecision: false,
     *      flex: 1,
     *      increment: 1,
     *      useTips: false,
     *      value: 100,
     *      vertical: true,
     *  },
     *  scrollTop:{ <Стрелка вверх>
     *      cls: 'scroll-top',
     *      height: 23
     *  },
     *  scrollBottom:{ <Стрелка вниз>
     *      cls: 'scroll-bottom',
     *      height: 23
     *  },
     *  toolbar:{ <Сам скроллер, сюда добавлять UI>
     *      dock: 'right',
     *      defaults: {
     *          margin: 0,
     *          width: 13
     *      },
     *      ui: 'scroller'
     *  }
     * }
     */
    scrollerConfig: {
        slider: {
            animate: false,
            decimalPrecision: false,
            flex: 1,
            increment: 1,
            useTips: false,
            value: 100,
            vertical: true
        },
        scrollTop: {
            cls: 'scroll-top',
            height: 22
        },
        scrollBottom: {
            cls: 'scroll-bottom',
            height: 22
        },
        toolbar: {
            dock: 'right',
            defaults: {
                margin: 0,
                width: 21
            },
            ui: 'scroller'
        }
    },
    init: function(cmp) {
        var me = this;
        if (!cmp.isPanel)  {
            return;
        }
        
        Ext.apply(me.scrollerConfig.slider, {
            listeners: {
                change: me.onSliderChange,
                changecomplete: {
                    fn: me.onSliderChangeComplete,
                    delay: 300
                },
                scope: me
            }
        });
        // слайдер по середине
        me.slider = Ext.widget('slider', me.scrollerConfig.slider);
        Ext.apply(me.scrollerConfig.toolbar, {
            padding: me.padding || 0,
            items: [
                Ext.apply(me.scrollerConfig.scrollTop, {
                    handler: me.scrollTop,
                    scope: me
                }),
                me.slider,
                Ext.apply(me.scrollerConfig.scrollBottom, {
                    handler: me.scrollBottom,
                    scope: me
                })
            ]
        });
        me.toolbar = Ext.widget('toolbar', me.scrollerConfig.toolbar);
        cmp.addDocked(me.toolbar);
        cmp.setAutoScroll(false);
        cmp.scroller = me;
        cmp.on({
            add: me.onItemAdd,
            afterlayout: me.afterCmpLayout,
            render: me.onCmpRender,
            resize: me.onCmpResize,
            scope: me
        });
    },
    onCmpRender: function(cmp) {
        var me = this;
        scrollEl = cmp.body;
        me.scrollEl = scrollEl;
        cmp.items.each(function(item) {
            me.onItemAdd(cmp, item);
        });
        scrollEl.on({
            mousewheel: me.onMouseWheel,
            scope: me
        });
        if (Ext.isGecko) {
            // Firefox
            scrollEl.el.dom.addEventListener('DOMMouseScroll', function(e) {
                me.onMouseWheel(e);
            }, false);
        }
        scrollEl.on({
            touchstart: me.onTouchStart,
            touchmove: me.onTouchMove,
            touchend: me.onTouchEnd,
            scope: me
        }, {
            translate: false
        });
    },
    /**
     * @private
     * Срабатывает после создания layout. Проверяем наличие innerCt у layout.
     * Если он есть, то меняем скроллируемый элемент на нужный нам.
     */
    afterCmpLayout: function(cmp, layout) {
        var me = this;
        if (me.autoRestorePosition) {
            me.restorePosition();
        }
    },
    onCmpResize: function(cmp) {
        this.onResize(cmp);
    },
    /**
     * Возвращает объект с рассчитаными знамчениями для Ext.slider.Single
     * 
     * @return {Object} Максимальные значения ползунков прокрутки:
     *
     *      {
     *          height: <Max вертикального ползунка>,
     *          width: <Max горизонтального ползунка>
     *      }
     */
    getScrollSize: function() {
        var me = this,
            dom = me.scrollEl.dom,
            size = me.scrollEl.getSize();
        return {
            height: dom.scrollHeight - size.height,
            width: dom.scrollWidth - size.width
        };
    },
    /**
     * Срабатывает при добавление компоненты в контейнер и навешивает на неё
     * события для скроллера
     */
    onItemAdd: function(cmp, item) {
        var me = this;
        if (item && item.isComponent)  {
            item.on({
                resize: me.onItemResize,
                scope: me
            });
        }
        
    },
    onItemResize: function(item) {
        this.onResize(item);
    },
    /**
     * Основная функция: пересчитывает положение ползунка и скрывает/показывает
     * полосу прокрутки
     */
    onResize: function() {
        var me = this,
            autoHide = me.autoHide,
            scrollEl = me.scrollEl,
            scrollSize = me.getScrollSize(),
            toolbar = me.toolbar,
            slider = me.slider;
        if (scrollEl.isScrollable() && scrollSize.height) {
            me.recalcSliderPos(scrollSize.height);
            if (autoHide) {
                if (!toolbar.isVisible()) {
                    toolbar.show();
                    me.cmp.updateLayout();
                }
            } else {
                toolbar.el.setStyle('visibility', 'visible');
            }
        } else {
            if (autoHide) {
                if (toolbar.isVisible()) {
                    toolbar.hide();
                    me.cmp.updateLayout();
                }
            } else {
                toolbar.el.setStyle('visibility', 'hidden');
            }
        }
        if (me.scrollToTopOnResize) {
            me.scrollToTop();
        }
    },
    /**
     * При изменении размеров контейнера или содержимого устанавливает ползунок
     * в прежнее положение
     *
     * @param {Number} [maxValue] Новое максимальное значение ползунка
     */
    recalcSliderPos: function(maxValue) {
        var me = this,
            slider = me.slider,
            oldValue = slider.getValue(),
            oldMaxValue = slider.maxValue,
            value;
        if (maxValue == undefined) {
            maxValue = me.scrollEl.getHeight();
        }
        value = maxValue - me.scrollEl.dom.scrollTop;
        // так вроде лучше будет
        slider.suspendEvents();
        slider.setMaxValue(maxValue);
        slider.setValue(value, false);
        slider.resumeEvents();
    },
    /**
     * Обновляет положение ползунка слайдера. Используется, если прокрутка
     * происходит извне.
     */
    updateSliderPos: function() {
        var me = this,
            slider = me.slider,
            maxValue = slider.maxValue;
        value = maxValue - me.scrollEl.dom.scrollTop;
        slider.suspendEvents();
        slider.setValue(value, false);
        slider.resumeEvents();
    },
    onMouseWheel: function(e) {
        var me = this,
            slider = me.slider,
            delta;
        if (Ext.isGecko) {
            delta = -e.detail;
        } else {
            delta = e.getWheelDelta();
        }
        slider.setValue(slider.getValue() + delta * me.scrollDeltaY);
        e.preventDefault();
    },
    onSliderChange: function(slider, newValue) {
        var me = this,
            scrollEl = me.scrollEl;
        if (scrollEl) {
            scrollEl.scrollTo('top', slider.maxValue - newValue);
        }
        me.cmp.fireEvent('scroll', me);
    },
    onSliderChangeComplete: function() {
        var me = this;
        if (me.snap) {}
    },
    //me.snapToEl();
    snapToEl: function() {
        var me = this,
            cmp = me.cmp,
            scrollEl = me.scrollEl,
            slider = me.slider,
            snap = me.snap;
        scrollEl.select(snap).each(function(el, c, index) {
            var offset = el.getOffsetsTo(scrollEl);
            if (offset[1] == 0)  {
                return false;
            }
            
            if (offset[1] > 0) {
                var prev = c.item(index - 1),
                    prevOffset = prev.getOffsetsTo(scrollEl);
                slider.suspendEvents();
                if (-prevOffset[1] > offset[1]) {
                    slider.setValue(slider.getValue() - offset[1]);
                } else {
                    slider.setValue(slider.getValue() - prevOffset[1]);
                }
                slider.resumeEvents();
                scrollEl.scrollTo('top', slider.maxValue - slider.getValue(), true);
                return false;
            }
        });
    },
    touchStart: 0,
    onTouchStart: function(e) {},
    // this.touchStart = e.browserEvent.changedTouches[0].pageY;
    onTouchMove: function(e) {},
    // var me = this,
    //  slider = me.slider,
    //  touchMove = e.browserEvent.changedTouches[0].pageY,
    //  delta = touchMove - this.touchStart;
    // if (delta) {
    //  slider.setValue(slider.getValue() + delta);
    //  me.touchStart = touchMove;
    // }
    // e.preventDefault();
    snapTimeoutId: 0,
    onTouchEnd: function() {},
    // var me = this;
    // if (me.snap) {
    //  var id = me.snapTimeoutId;
    //  clearTimeout(id);
    //  id = Ext.Function.defer(me.snapToEl, 300, me);
    // }
    scrollTop: function() {
        var me = this,
            slider = me.slider;
        slider.setValue(slider.getValue() + me.scrollDeltaY);
    },
    scrollBottom: function() {
        var me = this,
            slider = me.slider;
        slider.setValue(slider.getValue() - me.scrollDeltaY);
    },
    /**
     * Прокрутка наверх
     */
    scrollToTop: function() {
        var me = this;
        me.slider.setValue(me.slider.maxValue);
    },
    /**
     * Прокрутка в самый низ
     */
    scrollToBottom: function() {
        var me = this,
            slider = me.slider;
        if (me.cmp.rendered) {
            if (slider.getValue()) {
                slider.setValue(0);
            } else {
                me.scrollEl.scrollTo('top', slider.maxValue);
            }
        }
    },
    /**
     * Проверка, что мы находимся наверху прокручиваемой области
     *
     * @param {Number} accurancy Точность вычислений
     * @return {Boolean}
     */
    isTop: function(accurancy) {
        var me = this,
            slider = me.slider;
        if (typeof accurancy == 'undefined')  {
            accurancy = 0;
        }
        
        return (slider.getValue() + accurancy >= slider.maxValue);
    },
    /**
     * Проверка, что мы находимся внизу прокручиваемой области
     *
     * @param {Number} accurancy Точность вычислений
     * @return {Boolean}
     */
    isBottom: function(accurancy) {
        var me = this,
            slider = me.slider;
        if (typeof accurancy == 'undefined')  {
            accurancy = 0;
        }
        
        return (slider.getValue() - accurancy <= 0);
    },
    /**
     * Запомнить позицию скроллера с тем, чтобы восстановить ее через метод restorePosition
     */
    catchPosition: function() {
        var me = this;
        me._curPosition = {
            sliderValue: me.slider.getValue(),
            scrollSize: me.getScrollSize()
        };
    },
    /**
     * Восстановить позицию, сохраненную через метод catchPosition
     */
    restorePosition: function() {
        var me = this,
            pos = me._curPosition,
            scrollSize = me.getScrollSize(),
            newValue;
        if (pos) {
            newValue = pos.sliderValue + (scrollSize.height - pos.scrollSize.height);
            me.slider.setValue(newValue);
            me.onSliderChange(me.slider, newValue);
        }
    },
    destroy: function() {
        var me = this;
        me.cmp.un({
            add: me.onItemAdd,
            afterlayout: {
                fn: me.afterCmpLayout,
                single: true
            },
            render: me.onCmpRender,
            resize: me.onCmpResize,
            scope: me
        });
        me.cmp.scroller = null;
        me.cmp = null;
        if (me.scrollEl) {
            me.scrollEl.un({
                mousewheel: me.onMouseWheel,
                touchstart: me.onTouchStart,
                touchmove: me.onTouchMove,
                touchend: me.onTouchEnd,
                scope: me
            });
            me.scrollEl = null;
        }
        me.slider = null;
        me.toolbar = null;
        me.callParent(arguments);
    }
});

/**
 * Отображение списка сообщений чата
 */
Ext.define('ExGodsCore.view.chat.MessageList', {
    extend: Ext.panel.Panel,
    alias: 'widget.corechatmessagelist',
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: false,
        prefix: 'MessageListView: '
    },
    header: false,
    hideMode: 'offsets',
    // чтобы работала автопрокрутка когда вкладка скрыта    
    /**
     * @cfg {Number} [limit=100]
     * Ограничение на число сообщений отображаемых во вкладке чата
     * {
     *  default:100
     * }
     */
    limit: 100,
    /**
     * @cfg {boolean}
     * Параметр отвечающий за создание localStorage и за синхронизацию с ним. (
     * true - создаётся store и синхронизируется, false - store не создаётся и не синхронизируется)
     */
    sync: true,
    plugins: [
        {
            ptype: 'corescroller',
            resetOnShow: false,
            scrollDeltaY: 20
        }
    ],
    /**
     * @property {Object} messageTplByType
     * Шаблоны типов сообщений
     */
    /**
     * @property {String} storageId
     * Уникальная строка по которой идет поиск "старых" сообщений вкладки чата
     */
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    messageTplByType: {
        room: [
            '{from}: {body:linkify}'
        ],
        to: [
            '{from} to {to}: {body:linkify}'
        ],
        message: [
            '{body.body:linkify}'
        ],
        'private': [
            '{from} private {to}: {body:linkify}'
        ]
    },
    initComponent: function() {
        var me = this,
            user = me.user;
        me.data = new Ext.util.MixedCollection();
        for (var key in me.messageTplByType) {
            if (Ext.isArray(me.messageTplByType[key])) {
                me.messageTplByType[key] = new Ext.XTemplate(me.messageTplByType[key]);
            }
        }
        Ext.apply(me, {
            html: '<ul></ul>',
            listeners: {
                afterrender: me.onAfterRender,
                scope: me
            }
        });
        if (me.sync) {
            //если синхронизировать , то store создаём
            me.storage = Ext.util.LocalStorage.get('chat-messages');
            me.storageId = user.get('title') + '-' + me.getId();
            if (!me.channelType.world && !me.channelType.location) {
                var lastId = me.storage.getItem(me.channelType + 'Id') || '';
                if (lastId != me.channelId) {
                    me.storage.setItem(me.storageId, []);
                }
                me.storage.setItem(me.channelType + 'Id', me.channelId);
            }
            /**/
            me.log('подгужаю сообщения из хранилища с id', me.storageId);
            me.data.addAll(me.storage.getItem(me.storageId) || []);
        }
        me.callParent();
    },
    /** @private
     * Срабатывает после рендера окна чата
     * @require 'ul'
     * @require 'li.message'
     */
    onAfterRender: function() {
        var me = this,
            html = '';
        me.data.each(function(msg) {
            html += me.parseMessage(msg);
        });
        me.listEl = me.getEl().down('ul');
        me.listEl.dom.innerHTML = html;
        (Ext.Function.createDelayed(function() {
            me.scroller.scrollToBottom();
        }, 10)());
    },
    /** @private
     * Показывает сообщение
     */
    showMessage: function(msg) {
        var me = this;
        if (me.listEl && me.listEl.dom) {
            me.listEl.insertHtml('beforeEnd', me.parseMessage(msg));
        }
    },
    /** @private
     * Скрывает сообщение в чате
     * @param {Number} msgIndex индекс сообщения в чате
     */
    hideMessage: function(msgIndex) {
        var me = this,
            el = me.listEl && me.listEl.dom ? me.listEl.select('li').item(msgIndex) : null,
            scrollerValue = me.scroller.slider.getValue();
        if (el) {
            if (scrollerValue) {
                // если прокрутка не внизу нужно обновить значение скроллера после удаления элемента
                var h = el.getHeight();
                el.remove();
                me.scroller.slider.setValue(scrollerValue + h);
            } else {
                el.remove();
            }
        }
    },
    /**
     * Добавляет сообщение в хранилище
     * 
     * @param {Object} msg Сообщение чата
     */
    addMessage: function(msg) {
        var me = this,
            rec = ExGods.app.getChatContactsStore().findRecord('title', msg.x.from_realuser);
        if (rec && rec.get('moder')) {
            msg.x.moder = rec.get('moder');
        }
        if (!msg)  {
            return;
        }
        
        var isBottom = me.scroller.isBottom();
        msg.id = Ext.id() + '-' + new Date().getTime();
        me.data.add(msg);
        me.showMessage(msg);
        if (me.data.getCount() > me.limit) {
            me.data.removeAt(0);
            me.hideMessage(0);
        }
        me.syncData();
        if (me.scroller.scrollEl) {
            me.scroller.onResize();
            if (isBottom) {
                me.scroller.scrollToBottom();
            }
        }
        /**
         * @event addmessage
         * Срабатывает при добавлении сообщения в чат
         * @param {Object} data
         * @param {ExGods.view.chat.MessageList} this
         */
        me.fireEvent('addmessage', msg, me);
    },
    /**
     * @private
     * Превращаем пришёдшие данные в HTML код
     * 
     * @param {Object} data Данные сообщения. Переменная принимает два типа данных:
     * сырой и подготовленный (от этого формата я отказываюсь см. ниже). Эти данные
     * подготавливаются в функции {@link ExGods.controller.Chat#onMessage}
     * @return {String} HTML сообщение чата
     */
    parseMessage: function(data) {
        var me = this,
            html = '<li class="message message-empty"></li>',
            type = data.type,
            msgId = data.id,
            xtpl;
        xtpl = me.messageTplByType[type];
        if (xtpl) {
            try {
                html = '<li class="message" id="' + msgId + '">' + me.prepareMessageText(xtpl, data) + '</li>';
            } catch (e) {}
        } else if (data.tpl) {
            try {
                html = '<li class="message" id="' + msgId + '">' + me.prepareMessageText(data.tpl, data) + '</li>';
            } catch (e) {}
        }
        return html;
    },
    /**
     * @private
     * Подготавливает текст сообщения
     * @param {Object}/{String} tpl шаблон сообщения
     * @param {object} data - данные по сообщению
     * @return {HTML} текст сообщения
     */
    prepareMessageText: function(tpl, data) {
        var me = this;
        if (typeof tpl != 'object') {
            tpl = new Ext.XTemplate(tpl);
        }
        return tpl.apply(data);
    },
    /**
     * Очистить все сообщения
     */
    clear: function() {
        var me = this;
        me.data.clear();
        me.syncData();
        if (me.listEl && me.listEl.dom) {
            me.listEl.dom.innerHTML = '';
            me.scroller.onResize();
        }
    },
    // @private
    onDestroy: function() {
        var me = this;
        if (me.sync) {
            me.storage.setItem(me.storageId, []);
            if (me.syncDataTask) {
                Ext.util.TaskManager.stop(me.syncDataTask);
            }
        }
        me.callParent(arguments);
    },
    /**
     * @private
     */
    syncData: function() {
        var me = this;
        if (!me.sync)  {
            return;
        }
        
        //если синхронизировать ненадо
        me.data.sync_changes = false;
        if (!me.syncDataTask) {
            me.syncDataTask = Ext.TaskManager.start({
                run: function() {
                    if (!me.data.sync_changes) {
                        /**/
                        me.log('Данные изменились - сохраняю изменения в локальном хранилище.');
                        me.storage.setItem(me.storageId, me.data.getRange());
                        me.data.sync_changes = true;
                    }
                },
                interval: 5000
            });
        }
    }
});

/**
 * Контроллер отображения чата
 */
Ext.define('ExGodsCore.controller.Chat', {
    extend: ExGodsCore.controller.Base,
    /**
     * @property {Object} logConfig
     * Определяет какие типы сообщений выводить в консоль
     * @param {Object} enabled
     * @param {Boolean} enabled.info выводит информационные сообщения
     * @param {Boolean} enabled.error выводит сообщения об ошибках
     * @param {Boolean} enabled.warn выводит предупреждения
     * @param {String} prefix видимо сообщения выводятся с этим префиксом
     */
    logConfig: {
        enabled: {
            info: false,
            error: true,
            warn: true
        },
        prefix: 'ChatView:'
    },
    views: [
        'chat.MessageList'
    ],
    refs: [
        {
            /**
             * @method getChatTabPanel
             * Возвращает панель с табами чата
             * default selector: #chat-tab-panel
             * @return {ExGods.view.chat.MessageList}
             */
            ref: 'chatTabPanel',
            selector: '#chat-tab-panel'
        },
        {
            /**
             * @private
             * @method getInputField
             * Получет отображение строки чата
             * default selector: #chat-text-field
             * @return {Ext.form.field.Text}
             */
            ref: 'inputField',
            selector: '#chat-text-field'
        },
        {
            /**
             * @private
             * @method getSendButton
             * Возвращает панель с табами чата
             * default selector: #chat-send-button
             * @return {Ext.button.Button}
             */
            ref: 'sendButton',
            selector: '#chat-send-button'
        }
    ],
    /**
     * @property {Object[]} channelPatterns
     * Шаблоны (регулярные выражения) каналов вида:
     *
     *      [
     *          {
     *              xtype: <компонента_отображения>
     *              name: <имя для генерации референсов>     
     *              id: <идентификатор>
     *              pattern: <регулярка_для_определения_типа_канала>
     *              title: <название_вкладки_канала>
     *              type:{
     *                  input:{Boolean}
     *                  private:{Boolean}
     *                  default:{Boolean}
     *                  <а также любые другие типы, которые мы хотим видеть в приложении>
     *              }
     *              autoshow:{Boolean} определяет, переключать ли текущую вкладку чата на данную при создании данной
     *              autoremove: {Boolean} опреледяет, удалять ли данную вкладку при покидании "комнаты" чата
     *          },
     *          ...
     *      ]
     */
    channelPatterns: null,
    /**
     * @property {Object} messagePatterns
     * Шаблоны (регулярные выражения) сообщений
     */
    messagePatterns: {
        // приватное сообщение
        'private': /^\s*[\/\.\!\,](p|private|w|whisper|ш|шепнуть|шептать)\s+([^:]*?)\s*:\s*(.*)\s*$/i,
        // сообщение конкретным игрокам в комнате
        'to': /^\s*[\/\.\!\,](to)\s+([^:]*?)\s*:\s*(.*)\s*$/i,
        // комнатное сообщение
        'room': /^\s*(.*)\s*$/i
    },
    init: function(app) {
        var me = this,
            user = app.user;
        if (!me.channelPatterns) {
            me.channelPatterns = [
                {
                    xtype: 'corechatmessagelist',
                    id: 'world-chat-messages',
                    pattern: /^world#\d+$/,
                    title: ExGodsCore.app.references.get('message_client').get('chat_world_title'),
                    name: 'worldChatMessageList',
                    type: {
                        world: true,
                        input: true,
                        'private': true
                    }
                },
                {
                    xtype: 'chatmessagelist',
                    id: 'location-chat-messages',
                    pattern: /^\d+$/,
                    title: ExGodsCore.app.references.get('message_client').get('chat_location_title'),
                    name: 'locationChatMessageList',
                    type: {
                        location: true,
                        'default': true,
                        input: true,
                        'private': true
                    },
                    autoshow: true
                }
            ];
        }
        me.channels = new Ext.util.MixedCollection();
        //добавляю рефы для каналов чата
        /**
         * @method getChannelName
         * Возвращает конкретную панель чата по ее названием. Функция типа get<chatName>ChatMessageList, например:
         * {
         *      getWorldChatMessageList()
         * }
         * @return {ExGods.view.chat.MessageList} Ext.Component вкладки чата
         */
        var refs = [];
        for (var i = 0; i < me.channelPatterns.length; i++) {
            refs.push({
                ref: me.channelPatterns[i].name,
                selector: '#' + me.channelPatterns[i].id
            });
        }
        me.addRef(refs);
        me.control({
            'chatmessagelist': {
                nickclick: me.addNickToMessage
            },
            '#chat-text-field': {
                specialkey: me.onEnterTextField
            },
            '#chat-toolbar button[action="send"]': {
                click: me.sendMessage
            },
            '#chat-toolbar button[action="clear"]': {
                click: me.onClearBtnClick
            },
            '#contact-tab-panel dataview': {
                itemclick: {
                    fn: me.onContactListItemClick,
                    delay: 0
                }
            }
        });
        app.getChatConnection().on({
            connect: me.onChatConnect,
            disabled: me.onChatDisabled,
            enabled: me.onChatEnabled,
            presenceavail: me.onPresenseAvailable,
            presenceunavail: me.onPresenseUnavailable,
            message_error: me.onMessageTypeError,
            message_room: me.onMessageTypeRoom,
            message_private: me.onMessageTypePrivate,
            message_default: me.onMessageTypeDefault,
            command_message: me.onMessageTypeCommandMessage,
            command_prize: me.onMessageTypeCommandMessage,
            scope: me
        });
        me.getUser().features().on('load', me.checkChatDisablingFeature, me);
        me.getUser().features().on('datachanged', me.checkChatDisablingFeature, me);
    },
    /**
     * Возвращает отображение текущей вкладки чата
     *
     * @return {ExGods.view.chat.MessageList}
     */
    getActiveTab: function() {
        var me = this;
        return me.getChatTabPanel().getActiveTab();
    },
    /**
     * @private
     * Обрабатывает подключение к чату
     */
    onChatConnect: function(conn) {
        var me = this;
        if (!me.isChatDisable()) {
            me.enableInput();
        }
    },
    /**
     * @private
     * При смене присутствия создаёт при необходимости новую вкладку чата
     *
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data
     */
    onPresenseAvailable: function(chatcn, data) {
        var me = this,
            user = me.getUser();
        Ext.each(me.channelPatterns, function(channel) {
            // ищем тип канала чата
            var match = data.roomId.match(channel.pattern);
            if (match) {
                // проверяем, не существует ли уже канал
                var card = me.getChatTabPanel().down('#' + channel.id);
                if (card) {
                    // если канал есть, то меняем roomId на новый
                    card.channelId = data.roomId;
                } else {
                    //параметр отвечает за локальную синхронизацию (для чата "Просмотр боя" она не нужна)
                    channel.sync = !(channel.type == 'battle_obs');
                    // если канала нет, то создаём его
                    card = me.getChatTabPanel().add({
                        xtype: channel.xtype,
                        id: channel.id,
                        channelId: data.roomId,
                        channelType: channel.type,
                        channelParams: channel,
                        title: channel.title,
                        user: user,
                        sync: channel.sync,
                        autoremove: channel.autoremove
                    });
                    // если autoshow, то показываю вкладку при создании
                    if (channel.autoshow) {
                        me.getChatTabPanel().setActiveTab(card);
                    }
                }
                // добавляем канал в коллекцию с ключом roomId
                me.channels.add(data.roomId, card);
            }
        });
    },
    /**
     * @private
     * При покадании "комнаты" чата удаляет ненужную вкладку
     * 
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data Данные от чата
     */
    onPresenseUnavailable: function(chatcn, data) {
        var me = this,
            channel = me.channels.getByKey(data.roomId);
        if (channel) {
            me.channels.removeAtKey(data.roomId);
            if (channel.autoremove) {
                me.getChatTabPanel().remove(channel);
            }
        }
    },
    // Блок получения и обработки сообщений от сервера
    /**
     * @method getChannelByType
     * Возвращает {ExGods.view.chat.MessageList}вкладку чата или [{ExGods.view.chat.MessageList}]массив вкладок чата
     * @param {String} type тип чата
     * Базовые типы:
     * {
     *      private - чаты, в которых доступны личные сообщения
     *      input - чаты, в которых есть возможность писать сообщения
     *      default - дефолтный чат, в который пишется сообщение если альтернативы не указано. Обычно в единственном экземпляре.
     * }
     * @return {Ext.Component}/[] элемент или массив компонентов чата
     */
    getChannelByType: function(type) {
        var me = this,
            res = [];
        for (var i = 0; i < me.channelPatterns.length; i++) {
            if (me.channelPatterns[i].type[type]) {
                var cmp = Ext.ComponentQuery.query('#' + me.channelPatterns[i].id);
                if (cmp[0] && cmp[0].rendered) {
                    res.push(cmp[0]);
                }
            }
        }
        if (res.length == 1) {
            return res[0];
        } else if (!res.length) {
            return undefined;
        } else {
            return res;
        }
    },
    /**
     * @method getChannelPatternByType
     * Возвращает {Object}паттерн вкладки чата или [{Object}]массив паттернов вкладок чата
     * @param {String} type тип чата
     * Базовые типы:
     * {
     *      private - чаты, в которых доступны личные сообщения
     *      input - чаты, в которых есть возможность писать сообщения
     *      default - дефолтный чат, в который пишется сообщение если альтернативы не указано. Обычно в единственном экземпляре.
     * }
     * @return {Object}/[{Object}] паттерн вкладки чата или массив паттернов вкладок чата
     */
    getChannelPatternByType: function(type) {
        var me = this,
            res = [];
        for (var i = 0; i < me.channelPatterns.length; i++) {
            if (me.channelPatterns[i].type[type]) {
                res.push(me.channelPatterns[i]);
            }
        }
        if (res.length == 1) {
            return res[0];
        } else if (!res.length) {
            return undefined;
        } else {
            return res;
        }
    },
    /**
     * @private
     * @method onMessageTypeDefault
     * Сообщение с дефолтным типом
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data Данные от чата
     */
    onMessageTypeDefault: function(chatcn, data) {
        var me = this,
            channel = me.getChannelByType('default');
        if (channel) {
            if (Ext.isArray(channel)) {
                for (var i = 0; i < channel.length; i++) {
                    channel[i].addMessage(data);
                }
            } else {
                channel.addMessage(data);
            }
        }
    },
    /**
     * @private
     * @method onMessageTypeError
     * Сообщение об ошибке
     *
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data Данные от чата
     */
    onMessageTypeError: function(chatcn, data) {
        var me = this,
            messageTpl = me.application.references.get('message_client').get('chat_error_' + data.errorCode),
            from = data.from,
            arrayusers;
        //Преобразовываем data.x.to_realuser в один ник.        
        if (data.x.to_realuser) {
            arrayusers = data.x.to_realuser.split(',');
            for (var i = 0; i < arrayusers.length; i++) {
                var name = arrayusers[i].toLowerCase().replace(' ', '_');
                if (from === name) {
                    data.x.to_realuser = arrayusers[i];
                    break;
                }
            }
        }
        // убираю время из данных сообщения
        data.x.time = undefined;
        if (messageTpl && me.getActiveTab()) {
            data.tpl = messageTpl;
            me.getActiveTab().addMessage(data);
        }
    },
    /**
     * @private
     * @method onMessageTypeRoom
     * Получение комнатного сообщения
     *
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data Данные от чата
     */
    onMessageTypeRoom: function(chatcn, data) {
        var me = this,
            channel = null;
        if (data.roomId) {
            channel = me.channels.getByKey(data.roomId);
        }
        if (channel) {
            channel.addMessage(data);
        }
    },
    /**
     * @private
     * @method onMessageTypePrivate
     * Получение приватного сообщения
     * 
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data Данные от чата
     */
    onMessageTypePrivate: function(chatcn, data) {
        var me = this,
            channels = me.getChannelByType('private');
        if (channels) {
            channels = Ext.isArray(channels) ? channels : [
                channels
            ];
            channels.forEach(function(ch) {
                ch.addMessage(data);
            });
        }
    },
    /**
     * @private
     * @method onMessageTypeCommandMessage
     * Получение сообщения c коммандой message
     * 
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data Данные от чата
     */
    onMessageTypeCommandMessage: function(chatcn, data) {
        var me = this,
            channel;
        if (data.body.template) {
            data.tpl = data.body.template;
        }
        channel = me.getCommandMessageChannel(data);
        if (channel) {
            if (Ext.isArray(channel)) {
                for (var i = 0; i < channel.length; i++) {
                    channel[i].addMessage(data);
                }
            } else {
                channel.addMessage(data);
            }
        }
    },
    // END: Блок получения и обработки сообщений от сервера
    // Обработка сообщения пользователя
    /**
     * @method getSendMessageData
     * Получение данных из текстовой строки сообщения
     * 
     * @return {ExGods.model.SendMessage}
     */
    getSendMessageData: function() {
        var me = this,
            field = me.getInputField(),
            text = field.getValue(),
            message = {
                from: me.getUser().get('display_title'),
                type: 'room',
                to: [],
                content: '',
                roomId: false
            };
        Ext.Object.each(me.messagePatterns, function(key, exp) {
            var match = text.match(exp);
            if (match) {
                switch (key) {
                    case 'private':
                        var nicks = match[2].split(',');
                        nicks = Ext.Array.map(nicks, function(item) {
                            return Ext.String.trim(item);
                        });
                        Ext.apply(message, {
                            type: key,
                            to: nicks,
                            content: match[3]
                        });
                        break;
                    case 'to':
                        var nicks = match[2].split(',');
                        nicks = Ext.Array.map(nicks, function(item) {
                            return Ext.String.trim(item);
                        });
                        Ext.apply(message, {
                            type: key,
                            to: nicks,
                            content: match[3],
                            roomId: me.getChatRoomName()
                        });
                        break;
                    case 'room':
                        Ext.apply(message, {
                            type: key,
                            content: match[1],
                            roomId: me.getChatRoomName()
                        });
                        break;
                    default:
                        break;
                }
                // прекращаем поиск
                return false;
            }
        });
        return message;
    },
    /**
     * @private
     * @method updateSendMessageField
     * Обновляет экземпляр модели текущего сообщения, данные беруться из строки ввода
     * 
     * @param {String} newMessage Текст сообщения
     */
    updateSendMessageField: function(newMessage) {
        var me = this,
            field = me.getInputField(),
            message = newMessage ? newMessage : me.getSendMessageData(),
            type = message.type,
            to = message.to,
            content = message.content,
            str = '';
        if (type && type != 'room')  {
            str += '/' + type;
        }
        
        if (to.length) {
            str += ' ' + to.join(', ') + ': ';
        }
        str += content;
        field.setValue(str).focus();
        field.selectText(str.length, str.length);
    },
    /**
     * @method addNickToMessage
     * Вставляет ник пользователя для приватного сообщения
     * 
     * @param {String} nick Ник персонажа
     * @param {String} [type] Тип сообщения (to или private)
     * @param {String} [strongType] true, если type однозначно определяет тип сообщения.
     */
    addNickToMessage: function(nick, type, strongType) {
        var me = this,
            message = me.getSendMessageData();
        if (!Ext.Array.contains(message.to, nick)) {
            if (!message.to.length) {
                message.type = type || 'to';
            }
            message.to.push(nick);
        } else {
            if (type && strongType) {
                message.type = type;
            } else if (message.type != 'private') {
                message.type = 'private';
            } else {
                message.type = 'to';
            }
        }
        me.updateSendMessageField(message);
    },
    /**
     * @method sendMessage
     * Отправляет сообщение, функция сама определяет, что это за сообщение: 
     * комнатное, приватное или какое-то ещё
     */
    sendMessage: function() {
        var me = this,
            str = Ext.String.trim(me.getInputField().getValue());
        if (str) {
            me.app.getChatConnection().sendMessage(me.getSendMessageData());
            me.getInputField().setValue('');
        }
    },
    /**
     * @private
     * @method getChatRoomName
     * Возвращает ID комнаты, в которую отсылается сообщение
     *
     * @return {String}
     */
    getChatRoomName: function() {
        var me = this,
            tabs = me.getChatTabPanel(),
            tab = tabs.getActiveTab(),
            room = tab.channelId;
        return room || false;
    },
    /**
     * @method getCommandMessageChannel
     * Вернет канал для вывода сообщения от команды
     * @param {Object} data Данные команды
     * @return {ExGods.view.chat.MessageList} Канал чата для вывода сообщения от команды
     */
    getCommandMessageChannel: function(data) {
        var me = this,
            channel;
        if (data.fromJID == 'localhost') {
            // броадкастовое сообщение
            channel = me.getChannelByType('localhost');
        } else if (data.roomId) {
            channel = me.channels.getByKey(data.roomId);
        }
        if (!channel) {
            channel = me.getChannelByType('default');
        }
        return channel;
    },
    /**
     * @private
     * @method onEnterTextField
     * срабатывает на event нажатия на кнопку Enter, посылает сообщение в чат
     * @param {Ext.form.field.Text} Ext.form.field.Text
     * @param {Object} event
     */
    onEnterTextField: function(field, e) {
        if (e.getKey() == e.ENTER) {
            this.sendMessage();
        }
    },
    // End: Обработка сообщения пользователя
    onClearBtnClick: function() {
        var me = this;
        if (me.getInputField().getValue()) {
            // очищаю поле ввода
            me.getInputField().setValue('');
        } else {
            Ext.widget('confirmdialog', {
                title: '',
                message: ExGods.ref('message_client|chat_confirm_clear'),
                handler: function() {
                    me.clearChatChannel();
                }
            });
        }
    },
    /**
     * @method clearChatChannel
     * Очищает активную вкладку сообщений чата
     */
    clearChatChannel: function() {
        var me = this,
            tab = me.getChatTabPanel().getActiveTab();
        if (tab) {
            tab.clear();
        }
    },
    /**
     * @method disableInput
     * Блокировка ввода (текстовое поле и кнопка отправки сообщения)
     */
    disableInput: function() {
        var me = this;
        me.getInputField().disable();
        me.getSendButton().disable();
    },
    /**
     * @method enableInput
     * Разблокировка ввода
     */
    enableInput: function() {
        var me = this;
        me.getInputField().enable();
        //me.getInputField().focus(false, true);
        me.getSendButton().enable();
    },
    /**
     * @private
     * @method onChatDisabled
     * Обработка блокировки коннекции к чату
     */
    onChatDisabled: function() {
        var me = this;
        // блокирую поле ввода
        me.disableInput();
    },
    /**
     * @private
     * @method onChatEnabled
     * Обработка разблокировки коннекции к чату
     */
    onChatEnabled: function() {
        var me = this;
        // разрешаю поле ввода
        me.enableInput();
    },
    /**
     * @method isChatDisable
     * Проверка заблокирован ли чат
     * @return {Boolean}
     */
    isChatDisable: function() {
        var me = this,
            chatcn = me.app.getChatConnection();
        return chatcn.disabled;
    },
    /**
     * @method isWorldChatDisable
     * Проверка заблокирован ли мировой чат
     * @return {Boolean}
     */
    isWorldChatDisable: function() {
        return ExGods.ref('constants|world_chat_available') ? ExGods.ref('constants|world_chat_available').value == 0 : false;
    },
    /**
     * @private
     * @method checkChatDisablingFeature
     * Проверяет на наличие бафа блокировки чата у юзера. Если такой баф есть - блокируем чат
     */
    checkChatDisablingFeature: function() {
        var me = this,
            chatcn = me.app.getChatConnection();
        if (me.getUser().features().find('type', 'chat_inactive') != -1) {
            chatcn.setDisabled(true);
        } else {
            chatcn.setDisabled(false);
        }
    }
});

/**
 * Указание
 */
Ext.define('ExGods.view.Direction', {
    extend: Ext.panel.Panel,
    alias: 'widget.direction',
    cls: 'direction-dialog',
    width: 800,
    height: 410,
    initComponent: function() {
        var me = this,
            config = me.config,
            user = ExGods.app.getUser();
        me.margin = '' + (config.y ? config.y : '104') + ' 0 0 ' + (config.x ? config.x : '104');
        me.btn = Ext.widget('textbutton', Ext.apply({
            x: 348,
            y: 261,
            width: 175,
            style: {
                zIndex: 2
            },
            text: ExGods.app.applyTpl(config.btnText || '', {
                u: user.data
            }) || ExGods.getMsgByKey('look_more'),
            cls: 'no_border' + (config.btnColor ? ' x-btn-txt-' + config.btnColor : ''),
            href: me.config.action ? me.config.action.href : undefined,
            hrefTarget: me.config.action ? me.config.action.hrefTarget : undefined
        }, config.btn || {}));
        me.items = [
            {
                xtype: 'container',
                //layout: 'absolute',
                items: [
                    {
                        xtype: 'component',
                        width: 587,
                        tpl: [
                            '<div class="npc" style="background-image: url({[ this.getNpcImage() ]})"></div>',
                            '<div class="pergament bg"></div>',
                            '<div class="pergament">',
                            '<div class="close-btn ' + (config.close_btn && config.close_btn != 0 ? "" : "hidden") + '"></div>',
                            '<h1>' + ExGods.app.applyTpl(config.label || '', {
                                u: user.data
                            }) + '</h1>',
                            '<p>' + ExGods.app.applyTpl(config.text || '', {
                                u: user.data
                            }) + '</p>',
                            '</div>',
                            {
                                getNpcImage: function() {
                                    return me.getNpcImage();
                                }
                            }
                        ],
                        data: {},
                        afterRender: function() {
                            this.getEl().on('click', function() {
                                me.close();
                            }, this, {
                                delegate: '.close-btn'
                            });
                        }
                    },
                    me.btn
                ]
            }
        ];
        me.callParent(arguments);
    },
    // метод вызывается из указания, в случае авто-запуска указания
    directionAutoRun: function() {
        var me = this;
        me.btn.handler(me.btn);
    },
    getNpcImage: function() {
        var me = this,
            user = ExGods.app.user,
            u_gen = user.get('gender') == 1 ? 'm' : 'f',
            u_race = user.get('race') == 2 ? 'as' : 'van',
            imgName = 'npcImg_' + u_race + '_' + u_gen;
        if (me.config[imgName]) {
            return IMAGE_URL + me.config[imgName];
        } else if (me.config.npcImg) {
            return IMAGE_URL + me.config.npcImg;
        } else {
            return IMAGE_URL + 'direction/pers_fort_head.png';
        }
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                me.getNpcImage()
            ]
        };
    }
});

/**
 * Котроллер по управлению указаниями
 *
 * Указание - это директива сервера, запустить тот или иной сервис.
 * Такая директива вшита в текстовое сообщение, источником которого может быть чат, ответ сервера и т.д.
 *
 * Задача контроллера источника вызвать метод {@link ExGods.controller.Direction#processText}, который призван отыскать директиву
 * в текстовом сообщении источника.
 *
 * @author Олег Михайлов
 *
 */
Ext.define('ExGodsCore.controller.Direction', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Direction:'
    },
    disabled: true,
    init: function() {
        var me = this;
        me.storage = Ext.create('Ext.state.LocalStorageProvider');
        me.storage.storageId = 'exg-directions';
        me.control({
            '#battle-result': {
                destroy: {
                    fn: me.showDirections,
                    delay: 100
                }
            }
        });
        var directions = me.storage.get(me.storage.storageId, []);
        Ext.Array.each(directions, function(d) {
            if (d.data.object_name) {
                me.listenComponent(d.data.object_name);
            }
        });
        ExGods.Components.addComponentInitializer('direction', me.initDirectionDialogComponent, me);
        // метод для теста указаний
        ExGods.testDirection = function(directionName) {
            me.processText('[# ' + directionName + ' #]');
        };
    },
    shown: {},
    onLaunch: function(app) {
        var me = this;
        me.showDirections();
    },
    /**
     * Заблокировать / cнять блокировку с показа указаний
     */
    setDisabled: function(disabled) {
        var me = this;
        if (me.disabled !== disabled) {
            me.disabled = disabled;
            if (!me.disabled) {
                me.showDirections();
            }
        }
    },
    canShowDirections: function() {
        var me = this;
        return !me.disabled;
    },
    isBattle: function() {
        var me = this;
        return me.user.isBattle() || me.app.getController('battle.BattleView').isRendered() || Ext.getCmp('battle-result');
    },
    /**
     * Показывает указания 
     */
    showDirections: function(cmpId) {
        var me = this,
            directions = me.storage.get(me.storage.storageId, []),
            _waitAndShow = function(cmp, d) {
                var times = 0,
                    interval;
                interval = setInterval(function() {
                    if (cmp && cmp.isVisible() && !ExGods.loaderCt.isVisible()) {
                        me.runDirection(d);
                        Ext.Array.remove(directions, d);
                        me.storage.set(me.storage.storageId, directions);
                        clearInterval(interval);
                    } else {
                        if (++times > 10) {
                            clearInterval(interval);
                        }
                    }
                }, 250);
            };
        if (!me.canShowDirections()) {
            return;
        }
        Ext.Array.sort(directions, function(a, b) {
            return b.priority - a.priority;
        });
        /***/
        me.log('Показываю указания');
        var showen = [],
            lc = ExGods.loaderCt;
        Ext.Array.each(directions, function(d) {
            if (d.data.object_name && !d.data.not_show_with_open_component) {
                var cmp = Ext.getCmp(d.data.object_name);
                if (cmp) {
                    if (cmp.isVisible()) {
                        me.runDirection(d);
                        showen.push(d);
                    } else {
                        _waitAndShow(cmp, d);
                    }
                }
            } else if (me.isBattle() && d.data.show_in_battle != 1) {}
            //
            else if (lc.isVisible()) {
                lc.on('loader_removed', function() {
                    me.runDirection(d);
                }, me, {
                    single: true
                });
                showen.push(d);
            } else {
                me.runDirection(d);
                showen.push(d);
            }
        });
        directions = Ext.Array.difference(directions, showen);
        me.storage.set(me.storage.storageId, directions);
    },
    /**
     * Выполняет директиву
     */
    runDirection: function(d) {
        var me = this;
        /***/
        me.log('Выполняю указание', d);
        var fn = function() {
                if (d.data.make == 'service') {
                    // выполняю клиентское действие из указания
                    ExGods.ClientActions.createAndInvoke({
                        actionId: d.data.make_data.id
                    }, null, function(err) {
                        /***/
                        me.log('error', err);
                    });
                } else if (d.data.make == 'component') {
                    if (d.data.make_data.object_name) {
                        // показываю компонент из указания
                        var cmp = ExGods.Components.factory(d.data.make_data.object_name);
                        if (cmp == 'wrong_setting') {
                            /***/
                            me.log('info', 'Пользователь отключил указания и подсказки', d);
                            return;
                        } else if (cmp && !cmp.error) {
                            if (cmp.config.auto_run && cmp.directionAutoRun) {
                                cmp.directionAutoRun();
                                cmp.destroy();
                            } else if (cmp.autoShow !== false && !cmp.rendered) {
                                if (typeof cmp.getResources == 'function') {
                                    ExGods.Resources.load(cmp, function() {
                                        cmp.show();
                                    });
                                } else {
                                    cmp.show();
                                }
                            }
                        } else {
                            /***/
                            me.log('error', cmp ? cmp.error : 'Компонент для указания не создан ', d);
                        }
                    }
                } else {
                    /***/
                    me.log('error', 'Пустое указание - не указан ни клиентский объект, ни сервис');
                }
                if (d.data.sound) {
                    var sound = ExGods.ref('sounds|' + d.data.sound);
                    if (sound) {
                        ExGods.app.getSoundController().play(sound.audio);
                    }
                }
                if (d.data.caption) {
                    me.blinkTitle(d.data.caption);
                }
            };
        if (d.data.ask_direction && d.data.ask_direction.length) {
            var requests = Ext.Array.map(d.data.ask_direction, function(cfg) {
                    return me.askDirection.bind(me, cfg.command, function() {
                        requests.shift();
                        if (requests[0]) {
                            requests[0]();
                        } else  {
                            fn();
                        }
                        
                    });
                });
            requests[0]();
        } else {
            fn();
        }
    },
    askDirection: function(cmd, callback) {
        var me = this;
        me.request({
            url: '/game.pl',
            params: {
                cmd: 'ask_direction',
                ask: cmd
            },
            success: function(result) {
                me.onAskDirectionSuccess(result);
                callback();
            },
            failure: callback
        });
    },
    onAskDirectionSuccess: function(result) {
        if (result.ask_direction.mainmenu) {
            Ext.getCmp('mainmenu').updateMenu(result.ask_direction.mainmenu);
        }
    },
    /**
     * Обрабатывает текст на момент наличия директивы.
     *
     * Директива в тексте должна выглядеть следующим образом:
     *
     *  "... [# <direction_name> #]...."
     *  
     * direction_name - имя директивы из соответствующего справочника
     *
     * или:
     *
     *  "... [# hint_<hint_id> #]...."
     *
     * hint_id - ID подсказки.
     *
     * @param {String} Text
     * @return {String} Обработанный текст (все директивы вырезаются)
     */
    processText: function(text) {
        var me = this,
            pattern = /\[#\s([\w\d-_]+)\s#\]/ig,
            directions = [],
            hints = [],
            matches, d;
        while ((matches = pattern.exec(text)) != null) {
            if (/^hint_/.test(matches[1])) {
                if (me.user.getSetting('disable_hints') != 1)  {
                    hints.push(matches[1].replace('hint_', ''));
                }
                
            } else {
                d = ExGods.references.get('user_directions').get(matches[1]);
                if (d) {
                    directions.push(d);
                }
            }
        }
        if (directions.length) {
            Ext.Array.each(directions, function(d) {
                me.addDirection(d);
            });
            me.showDirections();
        }
        if (hints.length) {
            var hintsController = me.app.getController('Hints');
            Ext.Array.each(hints, function(h) {
                hintsController.showHintById(h);
            });
        }
        return text.replace(pattern, '');
    },
    /**
     * @private
     */
    addDirection: function(d) {
        var me = this,
            saved = me.storage.get(me.storage.storageId, []),
            alreadyHas = false;
        if (d.data.not_show_with_open_component == 1 && d.data.object_name && Ext.getCmp(d.data.object_name) && Ext.getCmp(d.data.object_name).isVisible()) {
            return;
        }
        // не добавляю указание, если стоит галочка "не показывать когда открыт" и компонент открыт
        /***/
        me.log('Добавляю указание в хранилище', d);
        Ext.Array.each(saved, function(sd) {
            if (sd.entry == d.entry) {
                alreadyHas = true;
            }
        });
        if (!alreadyHas) {
            saved.push(d);
            me.storage.set(me.storage.storageId, saved);
            if (d.data.object_name) {
                me.listenComponent(d.data.object_name);
            }
        }
    },
    listenComponent: function(cmpId) {
        var me = this,
            listener = {};
        me.listened = me.listened || [];
        if (Ext.Array.indexOf(me.listened, cmpId) == -1) {
            /****/
            me.log('Добавляю обработчик на показ компонента', cmpId);
            listener['#' + cmpId] = {
                show: {
                    fn: function() {
                        me.showDirections(cmpId);
                    },
                    single: false
                }
            };
            me.control(listener);
            me.listened.push(cmpId);
        }
    },
    /**
     * Метод вызывается автоматически при инициализации компонента
     */
    initDirectionDialogComponent: function(config, componentId) {
        var me = this,
            action,
            opts = {},
            view;
        //не показываю компонент если соответствующая настройка
        if (me.user.getSetting('disable_hints') == 1 && config.close_btn && config.close_btn != 0 && config.close_btn != 'Нет')  {
            return 'wrong_setting';
        }
        
        if (Ext.getCmp(componentId)) {
            return false;
        }
        if (config.serviceId && config.serviceId.id) {
            if (config.extra_service_opts) {
                opts = Ext.decode(config.extra_service_opts);
            }
            action = ExGods.ClientActions.factory({
                actionId: config.serviceId.id,
                src: 'direction',
                options: opts
            });
        }
        config.action = action;
        config.btn = {
            handler: function() {
                // закрываю все окна
                if (config.closeAll) {
                    me.app.getController('Viewport').closeAllWindows();
                }
                // выполняю клиентское действие
                if (action) {
                    ExGods.ClientActions.doAction(action, function(res) {
                        if (res.error) {
                            /***/
                            me.log('error', res.error);
                        }
                    });
                }
                // удаляю контейнер указания
                this.up('direction').close();
            }
        };
        view = Ext.widget('direction', {
            id: 'LETTER_' + componentId,
            //добавляю буквы в начало ID, т.к. 5-й экст ругается на ID начинающиеся с цифры
            layer: 'directions-layer',
            autoShow: true,
            config: config
        });
        return view;
    },
    blinkTitle: function(text) {
        var originalTitle = document.title,
            duration = ExGods.ref('constants|direction_title_blink_duration').value,
            blinkTime = ExGods.ref('constants|direction_title_blink_time').value,
            pauseTime = ExGods.ref('constants|direction_title_blink_time').value,
            spentTime = 0,
            started = new Date(),
            phase, now;
        document.title = text;
        phase = {
            type: 'blink',
            started: started,
            dur: blinkTime
        };
        var interval = setInterval(function() {
                now = new Date();
                spentTime = now - started;
                if (spentTime > duration) {
                    clearInterval(interval);
                    document.title = originalTitle;
                } else {
                    if (now - phase.started > phase.dur) {
                        if (phase.type == 'blink') {
                            document.title = originalTitle;
                            phase = {
                                type: 'pause',
                                started: now,
                                dur: pauseTime
                            };
                        } else {
                            document.title = text;
                            phase = {
                                type: 'blink',
                                started: now,
                                dur: blinkTime
                            };
                        }
                    }
                }
            }, 100);
    }
});

// @outdated //
/**
 * Управление навыками
 *
 * Отображает список навыков в правом окне и подробную информацию в левом.
 */
Ext.define('ExGodsCore.controller.Feature', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: false,
        prefix: 'Feature:'
    },
    // views: [
    //  'feature.Description',
    //  'feature.Tabs'
    // ],
    init: function(app) {
        var me = this,
            user = me.getUser();
        // me.control({
        //  '#combos-and-features-button': {
        //      afterrender: me.afterCombosButtonRender
        //  },
        //  '#features': {
        //      itemclick: {
        //          fn: me.onFeatureClick,
        //          delay: 0
        //      }
        //  },
        //  '#right-container': {
        //      hide: me.onRightPanelHide
        //  }
        // });
        //app.getController('MainMenu').on('combos-and-features-show', me.onComboTabsShow, me);
        // загружаем список навыков
        user.features().load();
    }
});
// user.features().on('load', me.onFeaturesUpdate, me);
// user.features().on('datachanged', me.onFeaturesUpdate, me);
// onLaunch: function() {
//  this.initComboTabs();
// },
// initComboTabs: function() {
//  var me = this;
//  if (!me.getCombosAndFeatures()) {
//      Ext.widget('combotabs', {
//          id: 'combos-and-features'
//      });
//  }
// },
/**
     * Возвращает отображение списка школ приёмов, создаёт их, если отсутствуют
     * 
     * @param {Boolean} autoCreate
     * @return {ExGods.view.talent.Groups}
     */
// getSchoolTabs: function(autoCreate) {
//  var me = this,
//      tabs = me.getFeatureTabs(),
//      user = me.getUser();
//  if (!tabs && autoCreate === false)
//      return false;
//  if (!tabs) {
//      tabs = Ext.widget('featuretabs', {
//          store: user.features()
//      });
//  }
//  return tabs;
// },
// onComboTabsShow: function(mainMenu, tabs) {
//  var me = this;
//  if (!tabs.down('featuretabs')) {
//      tabs.add(me.getSchoolTabs());
//  }
// },
// afterCombosButtonRender: function(button) {
//  var me = this,
//      user = me.getUser();
//  user.features().on('featuresadded', function(count) {
//      button.addCount(count);
//      if (me.getCombosAndFeatures().getActiveTab() != me.getFeatureTabs())
//          me.getFeatureTabs().tab.addCount(count);
//  });
// },
/**
     * Обрабатывает клик по фичи из списка выбора
     * @private
     */
// onFeatureClick: function(view, record, item, index, e) {
//  var me = this,
//      target = Ext.get(e.getTarget()),
//      status = record.get('status'),
//      left = me.getLeft();
//  left.remove('feature-description');
//  me.comboDescription = Ext.widget('featuredescription', {
//      data: record.data,
//  });
//  left.getLayout().setActiveItem(me.comboDescription);
// },
// onRightPanelHide: function(right) {
//  var me = this,
//      left = me.getLeft(),
//      desc = me.comboDescription;
//  if (me.getSchoolTabs(false) && !me.getSchoolTabs().isVisible(true) && desc && desc.isVisible(true)) {
//      desc.close();
//  }
// },
/**
     * @private
     * Обработчик обновления списка фич
     */
// onFeaturesUpdate: function(store) {
//  var me = this,
//      finishDate,
//      restTime;
//  /**/ me.log('Список фич изменился..');
//  // ищу фичу с ближайшим сроком истечения
//  store.each(function(feature) {
//      var featureFinishDate = feature.get('ended');
//      if (featureFinishDate) {
//          finishDate = finishDate && finishDate < featureFinishDate ? finishDate : featureFinishDate;
//      }
//  });
//  if (me.featureFinishTimeout) {
//      clearInterval(me.featureFinishTimeout);
//  }
//  if (finishDate) {
//      /**/ me.log('ближайший срок истечения фичи', finishDate);
//      restTime = Math.floor( (ExGods.util.Date.normalizeServerDateTime(finishDate) - new Date()) / 1000);
//      if (restTime > 0 && restTime < 24*60*60) { // Время в миллисекундах для таймаута (setTimeout) не должно превышать диапазона данных типа int
//                                                 // Выбрана граница в одни сутки
//          /**/ me.log('выставляю таймаут в', restTime, 'секунд до истечения фичи');
//          me.featureFinishTimeout = setTimeout(Ext.bind(me.onFeatureFinished, me), (restTime + 3)*1000); // 3 seconds delay чтобы учесть рассинхронизацию
//      }
//  } else {
//      /**/ me.log('Нет фич со сроком истечения.');
//  }
// },
/**
     * @private
     * Время фичи истекло.
     * Фича может влиять на статусы ботов или доступность того или иного элемента локации. Поэтому просто обновляем локацию
     */
// onFeatureFinished: function() {
//  var me = this;
//  if (!me.getUser().isBattle()) {
//      /**/ me.log('время действия фичи истекло - обновляю локацию');
//            me.application.getController('Location').updateLocation();
//  }
// }

/**
 * Модель прототипа предмета
 */
Ext.define('ExGodsCore.model.ItemPrototype', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'type',
            type: 'int'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'param',
            type: 'auto'
        },
        {
            name: 'data',
            type: 'auto'
        },
        {
            name: 'images',
            type: 'auto',
            convert: function(v) {
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key, value, myself) {
                        myself[key] = IMAGE_URL + myself[key];
                    });
                }
                return v;
            }
        },
        {
            // старые действия, удалить после реализации новых
            name: 'action',
            type: 'auto'
        },
        {
            // новые действия
            name: 'action_full',
            type: 'auto'
        },
        {
            // названия мирных и боевых действий "рун"
            name: 'action_value',
            type: 'auto'
        }
    ],
    /**
     * Возвращает признак стековости предмета
     * @return {Boolean}
     */
    isStack: function() {
        var data = this.get('data');
        return (Ext.isObject(data) && data.stack) ? true : false;
    },
    /**
     * Возвращает URL изображения предмета
     * @return {String}
     */
    getImage: function(type) {
        return this.get('images')[type];
    },
    getLevel: function() {
        return this.get('data').strict.level;
    },
    /**
     * Вернет справочную информацию по типу предмета (slot_on, slot_off, param)
     */
    getTypeInfo: function() {
        return ExGods.ref('item_type|' + this.get('type'));
    }
});

/**
 * Список предметов
 */
Ext.define('ExGodsCore.store.ItemPrototypes', {
    extend: Ext.data.Store,
    model: 'ExGodsCore.model.ItemPrototype',
    autoLoad: false,
    proxy: {
        type: 'ajax',
        actionMethods: {
            read: 'POST'
        },
        limitParam: false,
        pageParam: false,
        reader: {
            type: 'json',
            rootProperty: 'list'
        },
        startParam: false
    },
    load: function(options) {
        var me = this;
        options = options || {};
        me.proxy.api = {
            read: HOST_URL + '/game.pl?cmd=item.proto'
        };
        if (typeof options == 'function') {
            options = {
                callback: options
            };
        }
        // options.groupers = options.groupers ||  me.groupers.items;
        // options.page = options.page || me.currentPage;
        // options.start = (options.start !== undefined) ? options.start : (me.currentPage - 1) * me.pageSize;
        // options.limit = options.limit || me.pageSize;
        options.addRecords = true;
        if (me.buffered) {
            return me.loadToPrefetch(options);
        }
        return me.callParent([
            options
        ]);
    },
    /**
     * Проверяет отсутсвие прототипов в хранилище
     *
     * @param {Number[]} protos IDs прототипов
     * @return {Number[]} Массив из ID недостающих прототипов
     */
    check: function(protos) {
        var me = this,
            missed = [],
            i = 0,
            ln, proto_id;
        protos = Ext.Array.unique(protos);
        ln = protos.length;
        for (; i < ln; i++) {
            proto_id = parseInt(protos[i]);
            if (!me.data.getByKey(proto_id) && !Ext.Array.contains(missed, proto_id)) {
                missed.push(proto_id);
            }
        }
        return missed;
    },
    /**
     * Загружает и возвращает прототип(ы) предметов
     * 
     * @param {Number[]} protos Массив id прототитов предметов
     * @param {Function} callback
     * @return {Boolean} true - есть неподгруженные прототипы, false - все прототипы уже загружены
     */
    loadNew: function(protos, callback) {
        var me = this,
            missed;
        if (!Ext.isArray(protos))  {
            protos = [
                protos
            ];
        }
        
        missed = me.check(protos);
        if (missed.length) {
            me.read({
                params: {
                    ids: Ext.encode(missed)
                },
                callback: callback
            });
            return true;
        } else {
            callback();
        }
        return false;
    }
});

/**
 * Список контактов чата
 */
Ext.define('ExGodsCore.store.ChatContacts', {
    extend: Ext.data.Store,
    model: 'ExGodsCore.model.BasicUser',
    sorters: [
        {
            sorterFn: function(u1, u2) {
                var m1 = u1.get('moder') ? 1 : 0,
                    m2 = u2.get('moder') ? 1 : 0;
                return m1 < m2 ? -1 : (m1 > m2 ? 1 : 0);
            },
            direction: 'DESC'
        },
        {
            property: 'display_title',
            direction: 'ASC'
        }
    ]
});

/**
 * Базовый класс приложения
 *
 */
Ext.define('ExGodsCore.Application', {
    extend: Ext.app.Application,
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'App:'
    },
    namespaces: [
        'ExGodsCore'
    ],
    controllers: [
        'Chat',
        'Direction',
        'Feature'
    ],
    models: [
        'Location',
        'User',
        'Ability'
    ],
    stores: [
        'ItemPrototypes',
        'ChatContacts'
    ],
    /**
     * @property {Ext.data.Model} user Модель игрока
     */
    /**
     * @property {Ext.util.HashMap} references Справочники игры
     */
    /**
     * @property {ExGodsCore.ChatConnection} chatcn Коннекция к чату
     * @readonly
     */
    /**
     * @property {Boolean} gameStarted Признак, что игра запущенна
     */
    gameStarted: false,
    /**
     * @cfg {Array} serverRequestKeyHandlerSequence см. {@link ExGodsCore.AjaxRequest#keyHandlersSequence keyHandlersSequence}
     */
    serverRequestKeyHandlerSequence: [],
    /**
     * Вернёт модель пользователя приложения
     * @return {Ext.data.Model}
     */
    getUser: Ext.emptyFn,
    /**
     * Вернёт модель текущей локации
     * @return {Ext.data.Model}
     */
    getLocation: Ext.emptyFn,
    /**
     * Вернёт модель текущего мира
     * @return {Ext.data.Model}
     */
    getWorld: Ext.emptyFn,
    /**
     * Вернёт коннекцию приложения к чату
     * return {ExGodsCore.ChatConnection} connection
     */
    getChatConnection: function() {
        return this.chatcn;
    },
    /**
     * Инициализация приложения
     */
    init: function() {
        var me = this,
            appProperty = me.config.appProperty,
            ns;
        /***/
        me.log('info', 'создаю ссылку на объект приложения');
        ns = Ext.namespace(me.config.name);
        // здесь, т.к. она может понадобиться в дальнейшем ходе инициализации
        ns[appProperty] = me;
        ExGodsCore[appProperty] = me;
        IMAGE_URL = me.getImageUrl();
        HOST_URL = me.getHostUrl();
        /***/
        me.log('info', 'создаю справочники');
        me.references = me.createReferences();
        me.applyLanguageDependedOverrides();
        /***/
        me.log('info', 'подгружаю прототипы предметов из конфига');
        me.getItemPrototypesStore().loadRawData(config.references.item_proto);
        /***/
        me.log('info', 'создаю модель пользователя');
        me.user = me.createUser();
        /***/
        me.log('info', 'настраиваю атоматические обработчики ajax-запросов');
        ExGodsCore.AjaxRequest.initKeyHandlersSequence(me.serverRequestKeyHandlerSequence);
        /***/
        me.log('info', 'создаю коннекцию к чату');
        me.chatcn = new ExGodsCore.ChatConnection({
            login: config.chat.login,
            password: config.chat.password,
            application: me
        });
        me.callParent();
    },
    /**
     * Запуск приложения
     */
    launch: function() {
        var me = this;
        // коннекчусь к чату
        me.chatcn.on('ready', me.onChatConnectionReady, me);
        me.chatcn.connect();
    },
    /**
     * Глобальная блокировка интерфейса
     *
     * @param {String} [msg="Подождите…"] Сообщения для показа
     */
    block: function() {},
    //
    /**
     * Разблокирует интерфейс игры
     */
    unblock: function() {},
    //
    /**
     * См. {@link ExGodsCore.AjaxRequest#request ExGodsCore.AjaxRequest request}
     */
    request: function(args) {
        return ExGodsCore.AjaxRequest.request(args);
    },
    getImageUrl: function() {
        var imageUrl, imageHosts;
        Ext.util.Cookies.clear('image_url');
        // удаляю старую куку чтобы не мешала
        if (/^https/.test(location.protocol)) {
            if (!(imageUrl = Ext.util.Cookies.get('img_url_https'))) {
                imageHosts = Ext.Array.findBy(config.references.constants_list, function(el) {
                    return el.name == 'image_hosts_https';
                }).value;
                imageUrl = location.protocol + '//' + imageHosts[Math.floor(Math.random() * imageHosts.length)].v + '/';
                Ext.util.Cookies.set('img_url_https', imageUrl);
            } else {
                imageHosts = Ext.Array.findBy(config.references.constants_list, function(el) {
                    return el.name == 'image_hosts_https';
                }).value;
                imageUrl = location.protocol + '//' + imageHosts[Math.floor(Math.random() * imageHosts.length)].v + '/';
                Ext.util.Cookies.set('img_url_https', imageUrl);
            }
        } else {
            if (!(imageUrl = Ext.util.Cookies.get('img_url'))) {
                imageHosts = Ext.Array.findBy(config.references.constants_list, function(el) {
                    return el.name == 'image_hosts';
                }).value;
                imageUrl = location.protocol + '//' + imageHosts[Math.floor(Math.random() * imageHosts.length)].v + '/';
                Ext.util.Cookies.set('img_url', imageUrl);
            }
        }
        Ext.apply(Ext, {
            BLANK_IMAGE_URL: imageUrl + 'blank.gif'
        });
        return imageUrl;
    },
    getHostUrl: function() {
        return '';
    },
    /**
     * @private
     * Создает справочники игры
     */
    createReferences: function() {
        /**
         *  Список создаваемых справочников
         
        // Пока просто скопировал все справочники для ExGods.
        // По логике здесь должен быть список общих справочников, который будет переходить из проекта в проект.
        // @oleg


         * - main_page
         * - mod_group
         * - market
         * - images
         * - constants_list
         * - user_hint
         * - user_stat
         * - user_modif
         * - user_hoard
         * - user_summary
         * - user_money
         * - user_level
         * - user_trophy
         * - user_shape
         * - user_stuff
         * - user_timed
         * - item_type
         * - slot_type
         * - prototypes_rooms
         * - referer_action
         * - battle_strike
         * - battle_ability_school
         * - battle_log
         * - battle_types
         * - battle_bids_types
         * - constants
         * - components - компоненты
         * - components_objects - компоненты-объекты
         * - components_instances - компоненты реализация
         * - client_actions - клиентские действия
         * - service_protos - прототипы сервисов
         * - message_client - клиентские сообщения
         * - user_directions - справочник указаний
         * - user_settings - настройки пользователя
         * - battle_animations - анимации
         * - battle_turn - базовые действия в бою
         * - battle_prep - предварительные действия в бою
         * - battle_aura - aura в бою
         * - battle_continuing - длящиеся
         * - sounds - звуки
         * - direct_actions
        */
        var references = new Ext.util.HashMap();
        // справочник некоторых констант
        var mainPage = {};
        if (config.references.main_page.length) {
            for (var i = 0; i < config.references.main_page.length; i++) {
                var item = config.references.main_page[i];
                mainPage[item.name] = {
                    data: item.data,
                    value: item.value
                };
            }
        }
        references.add('main_page', mainPage);
        // справочник прототипов комнат "prototypes_rooms"
        var roomProtos = new Ext.util.HashMap();
        Ext.each(config.references.prototypes_rooms, function(item) {
            roomProtos.add(parseInt(item.entry, 10), item);
        });
        references.add('prototypes_rooms', roomProtos);
        // справочник групп модерирования
        var mod_group = {
                0: {
                    images: {
                        main: Ext.BLANK_IMAGE_URL
                    },
                    label: 'Без группы',
                    order: Infinity
                }
            };
        for (i = 0; i < config.references.mod_group.length; i++) {
            var item = config.references.mod_group[i];
            item.entry = parseInt(item.entry);
            item.order = item.order ? parseInt(item.order) : 0;
            item.images.main = item.images.main ? (IMAGE_URL + item.images.main) : Ext.BLANK_IMAGE_URL;
            mod_group[item.entry] = item;
        }
        references.add('mod_group', mod_group);
        // справочник звуков
        var sounds = new Ext.util.HashMap();
        Ext.each(config.references.sounds, function(item) {
            var file = item.params.file,
                audio = document.createElement('audio'),
                source = document.createElement('source'),
                type = 'audio/ogg';
            audio.appendChild(source);
            if (Ext.isSafari || Ext.isIE || Ext.isGecko) {
                //ogg поддерживают хром опера и мозилла, а mp3 хром, ие и сафари
                file = file.substr(0, file.length - 3) + 'mp3';
                type = 'audio/mpeg';
            }
            source.src = IMAGE_URL + file;
            source.type = type;
            audio.autobuffer = true;
            if (!Ext.isSafari)  {
                audio.load();
            }
            
            sounds.add(item.name, {
                label: item.label,
                description: item.description,
                audio: audio,
                pause: item.params.pause,
                fading: item.params.fading
            });
        });
        references.add('sounds', sounds);
        // справочник картинок
        var images = new Ext.util.HashMap();
        Ext.each(config.references.images, function(item) {
            var data = {};
            Ext.Array.forEach(item.data, function(image) {
                data[image.name] = IMAGE_URL + image.value;
            });
            images.add(item.name, {
                label: item.label,
                description: item.description,
                image: data
            });
        });
        references.add('images', images);
        var constants_list = references.add('constants_list', {});
        for (i = 0; i < config.references.constants_list.length; i++) {
            var item = config.references.constants_list[i],
                data = {};
            data.label = item.label;
            data.value = [];
            for (j = 0; j < item.value.length; j++) {
                data.value.push(item.value[j].v);
            }
            constants_list[item.name] = data;
        }
        // справочник подсказок
        var hints = {},
            hintsMap = new Ext.util.HashMap();
        for (i = 0; i < config.references.user_hint.length; i++) {
            var item = config.references.user_hint[i];
            if (!hints[item.label])  {
                hints[item.label] = [];
            }
            
            hints[item.label].push(item);
        }
        for (var key in hints) {
            Ext.Array.sort(hints[key], function(a, b) {
                return a.l_order > b.l_order;
            });
            hintsMap.add(key, hints[key]);
        }
        references.add('user_hint', hintsMap);
        // справочник статов
        var stats = new Ext.util.MixedCollection();
        Ext.each(config.references.user_stat, function(item) {
            stats.add(item.name, {
                label: item.label,
                visible: parseInt(item.visible),
                param: item.param
            });
        });
        references.add('user_stat', stats);
        // справочник модификаторов
        var modifiers = new Ext.util.MixedCollection();
        Ext.each(config.references.user_modif, function(item) {
            modifiers.add(item.name, {
                label: item.label,
                visible: parseInt(item.visible)
            });
        });
        references.add('user_modif', modifiers);
        // справочник накопительных характеристик
        var accumulative = new Ext.util.MixedCollection();
        Ext.each(config.references.user_hoard, function(item) {
            accumulative.add(item.name, {
                label: item.label,
                icon: item.params.icon,
                image_big: IMAGE_URL + item.params.image,
                image_disabled: IMAGE_URL + item.params.image_disabled,
                visible: parseInt(item.visible)
            });
        });
        references.add('user_hoard', accumulative);
        // справочник суммируемых характеристик
        var summable = new Ext.util.MixedCollection();
        Ext.each(config.references.user_summary, function(item) {
            summable.add(item.name, {
                label: item.label,
                icon: item.params.icon,
                visible: parseInt(item.visible)
            });
        });
        references.add('user_summary', summable);
        // справочник валют
        var currencies = new Ext.util.MixedCollection(false, function(item) {
                item.image = IMAGE_URL + item.param.image;
                item.image_big = IMAGE_URL + item.param.image_big;
                item.image_disabled = IMAGE_URL + item.param.image_disabled;
                item.visible = parseInt(item.visible);
                return item.name;
            });
        currencies.addAll(config.references.user_money);
        references.add('user_money', currencies);
        // справочник уровней
        var levels = new Ext.util.MixedCollection(false, function(item) {
                item.level = parseInt(item.level);
                item.expa = parseInt(item.expa);
                return item.level;
            });
        levels.addAll(config.references.user_level);
        references.add('user_level', levels);
        // справочник доблести
        var userValour = new Ext.util.MixedCollection(false, function(item) {
                item.level = parseInt(item.level);
                item.valour = parseInt(item.valour);
                item.data.img = item.data.img ? (IMAGE_URL + item.data.img) : '';
                return item.level;
            });
        userValour.sortByKey();
        userValour.addAll(config.references.user_valour);
        references.add('user_valour', userValour);
        // справочник образов
        var shapes = new Ext.util.MixedCollection(false, function(item) {
                item.thumb = item.small ? (IMAGE_URL + item.small) : Ext.BLANK_IMAGE_URL;
                item.avatar = item.medium ? (IMAGE_URL + item.medium) : Ext.BLANK_IMAGE_URL;
                item.full = item.large ? (IMAGE_URL + item.large) : Ext.BLANK_IMAGE_URL;
                item.battle = item.battle ? (IMAGE_URL + item.battle) : Ext.BLANK_IMAGE_URL;
                delete item.large;
                delete item.medium;
                delete item.small;
                return item.name;
            });
        shapes.addAll(config.references.user_shape);
        references.add('user_shape', shapes);
        // справочник имущества
        var stuff = new Ext.util.HashMap();
        for (var i = 0; i < config.references.user_stuff.length; i++) {
            var item = config.references.user_stuff[i];
            stuff.add(item.name, item);
        }
        references.add('user_stuff', stuff);
        // справочник восстанавливаемых характеристик
        var timed = new Ext.util.HashMap({
                keyFn: function(item) {
                    item.visible = parseInt(item.visible);
                    return item.stat;
                }
            });
        Ext.each(config.references.user_timed, function(item) {
            timed.add(item);
        });
        references.add('user_timed', timed);
        // справочник типов предметов
        var itemTypes = new Ext.util.MixedCollection();
        Ext.each(config.references.item_type, function(item) {
            itemTypes.add(parseInt(item.entry), {
                title: item.title,
                slot_on: parseInt(item.slot_on),
                slot_off: parseInt(item.slot_off),
                param: item.param
            });
        });
        references.add('item_type', itemTypes);
        // справочник типов слотов
        var slotTypes = new Ext.util.MixedCollection();
        Ext.each(config.references.slot_type, function(item) {
            if (Ext.isObject(item.images))  {
                Ext.Object.each(item.images, function(key, value, myself) {
                    item.images[key] = IMAGE_URL + item.images[key];
                });
            }
            
            slotTypes.add(item.entry, {
                title: item.title,
                stack: parseInt(item.stack),
                active: parseInt(item.active),
                images: item.images
            });
        });
        references.add('slot_type', slotTypes);
        references.add('referer_action', new Ext.util.MixedCollection(false, function(item) {
            item.entry = parseInt(item.entry);
            return item.entry;
        })).addAll(config.references.referer_action);
        // справочник суммируемых характеристик
        var battleStrikes = new Ext.util.MixedCollection();
        Ext.each(config.references.battle_strike, function(item) {
            battleStrikes.add(parseInt(item.entry), {
                action: item.action,
                image: IMAGE_URL + item.image,
                zone: parseInt(item.zone),
                label: item.label
            });
        });
        references.add('battle_strike', battleStrikes);
        // справочник боевых школ приёмов
        var battleSchools = new Ext.util.MixedCollection();
        Ext.each(config.references.battle_ability_school, function(item) {
            battleSchools.add(parseInt(item.entry), {
                entry: parseInt(item.entry),
                label: item.label,
                images: item.images
            });
        });
        references.add('battle_ability_school', battleSchools);
        // справочник боевых логов
        var battleLogs = new Ext.util.MixedCollection();
        Ext.each(config.references.battle_log, function(item) {
            battleLogs.add(item.type + '_' + (item.result || ''), {
                pattern: item.pattern,
                data: item.data
            });
        });
        references.add('battle_log', battleLogs);
        // справочник типов поединков
        var battleTypes = new Ext.util.HashMap();
        Ext.each(config.references.battle_types, function(item) {
            item.params.img = item.params.img ? (IMAGE_URL + item.params.img) : Ext.BLANK_IMAGE_URL;
            item.params.img_list = item.params.img_list ? (IMAGE_URL + item.params.img_list) : Ext.BLANK_IMAGE_URL;
            item.params.img_stat = item.params.img_stat ? (IMAGE_URL + item.params.img_stat) : Ext.BLANK_IMAGE_URL;
            battleTypes.add(parseInt(item.entry), {
                label: item.label,
                params: item.params
            });
        });
        references.add('battle_types', battleTypes);
        // справочник типов заявок на бой
        var battleBidTypes = new Ext.util.HashMap();
        Ext.each(config.references.battle_bids_types, function(item) {
            battleBidTypes.add(parseInt(item.id), item);
        });
        references.add('battle_bids_types', battleBidTypes);
        // константы
        var constants = new Ext.util.HashMap();
        Ext.each(config.references.constants, function(item) {
            constants.add(item.name, {
                label: item.label,
                value: item.value
            });
        });
        references.add('constants', constants);
        var components = new Ext.util.MixedCollection();
        Ext.each(config.references.client_components, function(item) {
            components.add(item.id, item);
        });
        references.add('components', components);
        var components_objects_old = new Ext.util.MixedCollection();
        Ext.each(config.references.client_objects, function(item) {
            Ext.applyIf(item, components.get(item.component_id));
            // накатываю данные прототипа
            components_objects_old.add(item.id, item);
        });
        references.add('components_objects_old', components_objects_old);
        var components_instances = new Ext.util.MixedCollection();
        Ext.each(config.references.client_implementations, function(item) {
            components_instances.add(item.id, item);
        });
        references.add('components_instances', components_instances);
        var service_protos = new Ext.util.MixedCollection();
        Ext.each(config.references.service_protos, function(item) {
            service_protos.add(item.id, item);
        });
        references.add('service_protos', service_protos);
        var services = new Ext.util.MixedCollection();
        Ext.each(config.references.client_actions, function(item) {
            item.proto = service_protos.get(item.type);
            services.add(item.id, item);
        });
        references.add('services', services);
        var client_objects = new Ext.util.MixedCollection();
        Ext.each(config.references.client_objects, function(item) {
            Ext.applyIf(item, components.get(item.component_id));
            // накатываю данные прототипа
            client_objects.add(item.name, item);
        });
        references.add('client_objects', client_objects);
        // справочник клиентских действий - производное из справочника сервисов
        var client_actions = new Ext.util.MixedCollection();
        services.each(function(service) {
            client_actions.add(service.id, {
                id: service.id,
                serviceId: service.id,
                componentId: service.params.component_id,
                componentObjectName: service.params.object_name
            });
        });
        references.add('client_actions', client_actions);
        var login_days_bonus = new Ext.util.MixedCollection();
        Ext.Object.each(config.references.login_days_bonus, function(day_num, stuff) {
            stuff[0].login_day_index = day_num;
            login_days_bonus.add(stuff[0]);
        });
        references.add('login_days_bonus', login_days_bonus);
        var kit_proto = new Ext.util.MixedCollection();
        Ext.each(config.references.kit_proto, function(item) {
            kit_proto.add(item.entry, item);
        });
        references.add('kit_proto', kit_proto);
        // справочник покупок
        var payment_preset = new Ext.util.MixedCollection();
        Ext.each(config.references.payment_preset, function(item) {
            payment_preset.add(item.entry, {
                entry: item.entry,
                price: item.price,
                count: item.count,
                bonus: item.bonus_ext
            });
        });
        references.add('payment_preset', payment_preset);
        // справочник клиентских сообщений
        var clientMessages = new Ext.util.HashMap();
        Ext.each(config.references.message_client, function(item) {
            clientMessages.add(item.name, item.label);
        });
        references.add('message_client', clientMessages);
        // справочник настроек пользователя
        var userSettings = new Ext.util.HashMap();
        Ext.each(config.references.user_settings, function(item) {
            userSettings.add(item.name, item);
        });
        references.add('user_settings', userSettings);
        // справочник указаний
        var directions = new Ext.util.HashMap();
        Ext.each(config.references.user_directions, function(item) {
            directions.add(item.name, item);
        });
        references.add('user_directions', directions);
        // справочник анимаций
        var animations = new Ext.util.HashMap();
        Ext.each(config.references.battle_animations, function(item) {
            for (var key in item) {
                if (Object.prototype.hasOwnProperty.call(item, key)) {
                    animations.add(key, item[key]);
                }
            }
        });
        references.add('battle_animations', animations);
        // справочник базовых боевых действий
        var battleTurns = new Ext.util.HashMap();
        Ext.each(config.references.battle_turn, function(item) {
            battleTurns.add(item.name, item);
        });
        references.add('battle_turn', battleTurns);
        // справочник предварительных боевых действий
        var battlePreps = new Ext.util.HashMap();
        Ext.each(config.references.battle_prep, function(item) {
            battlePreps.add(item.name, item);
        });
        references.add('battle_prep', battlePreps);
        // справочник боевых аур
        var battleAuras = new Ext.util.HashMap();
        Ext.each(config.references.battle_aura, function(item) {
            battleAuras.add(item.id, item);
        });
        references.add('battle_aura', battleAuras);
        // справочник длящихся
        var battleConts = new Ext.util.HashMap();
        Ext.each(config.references.battle_continuing, function(item) {
            battleConts.add(item.id, item);
        });
        references.add('battle_continuing', battleConts);
        // справочник боевых аур
        var battleActions = new Ext.util.HashMap();
        Ext.each(config.references.battle_actions, function(item) {
            battleActions.add(item.id, item);
        });
        references.add('battle_actions', battleActions);
        // справочник боевых аур
        var userTrophy = new Ext.util.HashMap();
        Ext.each(config.references.user_trophy, function(item) {
            userTrophy.add(item.entry, item);
        });
        references.add('user_trophy', userTrophy);
        // справочник elo
        var userElo = new Ext.util.HashMap();
        Ext.each(config.references.user_elo, function(item) {
            userElo.add(item.name, item);
        });
        references.add('user_elo', userElo);
        // справочник ингредиентов 
        var ingredients = new Ext.util.HashMap();
        Ext.each(config.references.ingredients, function(item) {
            ingredients.add(item.name, item);
        });
        references.add('ingredients', ingredients);
        // справочник прямых действий 
        var directActions = new Ext.util.HashMap();
        Ext.each(config.references.direct_actions, function(item) {
            directActions.add(item.entry, item);
        });
        references.add('direct_actions', directActions);
        // справочник запросов гильдии
        var guildRequests = new Ext.util.HashMap();
        Ext.each(config.references.guild_request_types, function(item) {
            guildRequests.add(item.entry, item);
        });
        references.add('guild_request_types', guildRequests);
        // справочник запросов гильдии
        var guildRaids = new Ext.util.HashMap();
        Ext.each(config.references.guild_raids, function(item) {
            guildRaids.add(item.entry, item);
        });
        references.add('guild_raids', guildRaids);
        // справочник рынка
        var marketRef = new Ext.util.HashMap();
        Ext.each(config.references.market, function(item) {
            marketRef.add(item.entry, item);
        });
        references.add('market', marketRef);
        // справочник питомцев
        var petsRef = new Ext.util.HashMap();
        Ext.each(config.references.pets, function(item) {
            petsRef.add(item.entry, item);
        });
        references.add('pets', petsRef);
        //группы скиллов
        references.add('skill_groups', config.references.user_skill_groups);
        //скиллы
        var skillsRef = new Ext.util.HashMap();
        Ext.each(config.references.user_skill, function(item) {
            skillsRef.add(item.name, item);
        });
        references.add('skills', skillsRef);
        return references;
    },
    /**
     * @private
     * Cоздает модель пользователя игры
     */
    createUser: function() {
        var me = this,
            userModel = me.getUserModel();
        return new userModel(config.user);
    },
    /**
     * @private 
     * Чат готов к работе
     */
    onChatConnectionReady: function(conn, data) {
        var me = this;
        if (!me.gameStarted) {
            me.gameStarted = true;
            /**
             * @event gamestarted
             * Срабатывает при полноценном логине в игру
             */
            me.fireEvent('gamestarted', data);
        }
    },
    /**
     * @private
     * Накатывает оверрайды, зависящие от языка
     */
    applyLanguageDependedOverrides: function() {
        Ext.Date.monthNames = [
            ExGodsCore.app.references.get('message_client').get('calendar_january'),
            ExGodsCore.app.references.get('message_client').get('calendar_february'),
            ExGodsCore.app.references.get('message_client').get('calendar_marth'),
            ExGodsCore.app.references.get('message_client').get('calendar_april'),
            ExGodsCore.app.references.get('message_client').get('calendar_may'),
            ExGodsCore.app.references.get('message_client').get('calendar_june'),
            ExGodsCore.app.references.get('message_client').get('calendar_july'),
            ExGodsCore.app.references.get('message_client').get('calendar_august'),
            ExGodsCore.app.references.get('message_client').get('calendar_september'),
            ExGodsCore.app.references.get('message_client').get('calendar_october'),
            ExGodsCore.app.references.get('message_client').get('calendar_november'),
            ExGodsCore.app.references.get('message_client').get('calendar_december')
        ];
        Ext.Date.shortMonthNames = [
            ExGodsCore.app.references.get('message_client').get('calendar_jan'),
            ExGodsCore.app.references.get('message_client').get('calendar_feb'),
            ExGodsCore.app.references.get('message_client').get('calendar_marth'),
            ExGodsCore.app.references.get('message_client').get('calendar_apr'),
            ExGodsCore.app.references.get('message_client').get('calendar_may'),
            ExGodsCore.app.references.get('message_client').get('calendar_june'),
            ExGodsCore.app.references.get('message_client').get('calendar_july'),
            ExGodsCore.app.references.get('message_client').get('calendar_aug'),
            ExGodsCore.app.references.get('message_client').get('calendar_sept'),
            ExGodsCore.app.references.get('message_client').get('calendar_oct'),
            ExGodsCore.app.references.get('message_client').get('calendar_nov'),
            ExGodsCore.app.references.get('message_client').get('calendar_dec')
        ];
        Ext.Date.monthNumbers = {
            'Янв': 0,
            'Фев': 1,
            'Мар': 2,
            'Апр': 3,
            'Май': 4,
            'Июн': 5,
            'Июл': 6,
            'Авг': 7,
            'Сен': 8,
            'Окт': 9,
            'Ноя': 10,
            'Дек': 11
        };
        Ext.Date.dayNames = [
            ExGodsCore.app.references.get('message_client').get('calendar_sunday'),
            ExGodsCore.app.references.get('message_client').get('calendar_monday'),
            ExGodsCore.app.references.get('message_client').get('calendar_tuesday'),
            ExGodsCore.app.references.get('message_client').get('calendar_wednesday'),
            ExGodsCore.app.references.get('message_client').get('calendar_thursday'),
            ExGodsCore.app.references.get('message_client').get('calendar_friday'),
            ExGodsCore.app.references.get('message_client').get('calendar_saturday')
        ];
    }
});

/**
 * Отображение сообщения в чате
 *
 * @author Тимур Нурутдинов
 */
Ext.define('ExGods.view.Template', {
    extend: Ext.XTemplate,
    apply: function() {
        var me = this;
        if (me.compiled != true) {
            delete me.fn;
        }
        return me.callParent(arguments);
    },
    isUserMan: function() {
        return ExGods.app.user.get('gender') == 1;
    },
    isUserGirl: function() {
        return ExGods.app.user.get('gender') == 2;
    },
    getUserRoom: function() {
        return ExGods.app.getController('Base').getLocation().getName();
    },
    getUserWorld: function() {
        return ExGods.app.getController('Base').getWorld().getTitle();
    },
    getUserDisplayTitle: function() {
        return ExGods.app.user.get('display_title');
    },
    getUserCls: function(user) {
        var cls = [];
        if (user[1] == ExGods.app.user.get('display_title'))  {
            cls.push('self');
        }
        
        return cls.join(' ');
    },
    getRank: function(rank) {
        return ExGods.references.get('user_valour').getByKey(parseInt(rank)).data.rank;
    }
});

/**
 * Вспомогательные функции для оформления подсказок для Ext.panel.Panel
 */
Ext.define('ExGods.view.plugin.HintDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.hintdeco',
    init: function(cmp) {
        Ext.applyIf(cmp, {
            padding: '20 25',
            title: ' '
        });
        Ext.apply(cmp, {
            shadow: false
        });
        cmp.on('render', this.addDeco, this, {
            single: true
        });
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.setUI('hint');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="hint-tl"></div>' + '<div class="hint-tm"></div>' + '<div class="hint-tr"></div>' + '<div class="hint-mr"></div>' + '<div class="hint-br"></div>' + '<div class="hint-bm"></div>' + '<div class="hint-bl"></div>' + '<div class="hint-ml"></div>' + '<div class="hint-tm2"></div>' + '<div class="hint-bm2"></div>' + '<div class="hint-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'deco/hint/hint_t_corn_l.png',
                IMAGE_URL + 'deco/hint/hint_t_corn_r.png',
                IMAGE_URL + 'deco/hint/hint_btm_corn_l.png',
                IMAGE_URL + 'deco/hint/hint_btm_corn_r.png',
                IMAGE_URL + 'deco/hint/hint_t_bg.png',
                IMAGE_URL + 'deco/hint/hint_btm_bg.png',
                IMAGE_URL + 'deco/hint/hint_l.png',
                IMAGE_URL + 'deco/hint/hint_r.png',
                IMAGE_URL + 'deco/hint/hint_center.png',
                IMAGE_URL + 'deco/hint/hint_t_c.png',
                IMAGE_URL + 'deco/hint/hint_btm_c.png'
            ]
        };
    }
});

/**
 * Плагин добавляющий оформление пергамента
 */
Ext.define('ExGods.view.plugin.ParchmentDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.parchmentdeco',
    padding: true,
    init: function(cmp) {
        if (!cmp.title)  {
            cmp.title = ' ';
        }
        
        if (cmp.bodyBorder !== false) {
            cmp.bodyCls += ' parchment-content';
            if (this.padding == false) {
                cmp.bodyCls += ' parchment-content-nop';
            }
        }
        cmp.addCls('parchment-deco');
        if (cmp.isPanel)  {
            Ext.override(cmp, {
                addTool: function(tools) {
                    tools = [].concat(tools);
                    Ext.Array.forEach(tools, function(tool) {
                        tool.height = 31;
                        tool.width = 32;
                    });
                    this.callParent(arguments);
                }
            });
        }
        
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header)  {
            cmp.header.setHeight(0);
        }
        
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'close.png',
                IMAGE_URL + 'parchment-tl.jpg',
                IMAGE_URL + 'parchment-tm.jpg',
                IMAGE_URL + 'parchment-tr.jpg',
                IMAGE_URL + 'parchment-mr.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'parchment-br.jpg',
                IMAGE_URL + 'parchment-bm.jpg',
                IMAGE_URL + 'parchment-bl.jpg',
                IMAGE_URL + 'parchment-ml.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'separator-horizontal.jpg'
            ]
        };
    }
});

/**
 * Оформление типа "Бумага"
 */
Ext.define('ExGods.view.plugin.PaperDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.paperdeco',
    init: function(cmp) {
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('x-paper');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="paper paper-tl"></div>' + '<div class="paper paper-tm"></div>' + '<div class="paper paper-tr"></div>' + '<div class="paper paper-mr"></div>' + '<div class="paper paper-br"></div>' + '<div class="paper paper-bm"></div>' + '<div class="paper paper-bl"></div>' + '<div class="paper paper-ml"></div>' + '<div class="paper paper-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'deco/paper/paper_top_left.png',
                IMAGE_URL + 'deco/paper/paper_top_middle.png',
                IMAGE_URL + 'deco/paper/paper_top_right.png',
                IMAGE_URL + 'deco/paper/paper_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_middle.png',
                IMAGE_URL + 'deco/paper/paper_bottom_left.png',
                IMAGE_URL + 'deco/paper/paper_left.png',
                IMAGE_URL + 'deco/paper/paper_center_tile.png'
            ]
        };
    }
});

/**
 * Вспомогательные функции для оформления скино-пергаметных элементов
 */
Ext.define('ExGods.view.plugin.SkinDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.skindeco',
    init: function(cmp) {
        cmp.title = ' ';
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('x-skin');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="skin skin-tl"></div>' + '<div class="skin skin-tm"></div>' + '<div class="skin skin-tr"></div>' + '<div class="skin skin-mr"></div>' + '<div class="skin skin-br"></div>' + '<div class="skin skin-bm"></div>' + '<div class="skin skin-bl"></div>' + '<div class="skin skin-ml"></div>' + '<div class="skin skin-bg"></div>');
    },
    destroy: function() {
        var me = this;
        if (me.cmp) {
            me.cmp.un('render', me.addDeco, me);
            me.cmp = null;
        }
        me.callParent(arguments);
    },
    /**
     * Ресурсы плагин предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'skin-tl.png',
                IMAGE_URL + 'skin-tm.png',
                IMAGE_URL + 'skin-tr.png',
                IMAGE_URL + 'skin-mr.png',
                IMAGE_URL + 'skin-br.png',
                IMAGE_URL + 'skin-bm.png',
                IMAGE_URL + 'skin-bl.png',
                IMAGE_URL + 'skin-ml.png',
                IMAGE_URL + 'skin-bg.png',
                IMAGE_URL + 'btn_close.png',
                IMAGE_URL + 'close.png',
                IMAGE_URL + 'skin-window-tl.png',
                IMAGE_URL + 'skin-window-tr.png',
                IMAGE_URL + 'skin-window-br.png',
                IMAGE_URL + 'skin-window-bl.png'
            ]
        };
    }
});

/**
 * Вспомогательные функции для оформления каменных элементов
 */
Ext.define('ExGods.view.plugin.StoneDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.stonedeco',
    init: function(cmp) {
        cmp.title = ' ';
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('x-stone');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="stone stone-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [
                IMAGE_URL + 'stone/forge_bg_stone.png',
                IMAGE_URL + 'stone/forge_button_x.png',
                IMAGE_URL + 'close.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Вспомогательные функции для оформления скино-пергаметных элементов
 */
Ext.define('ExGods.view.plugin.SkinParchmentDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.skinparchmentdeco',
    init: function(cmp) {
        Ext.applyIf(cmp, {
            padding: '13 16 17 15',
            title: ' '
        });
        Ext.apply(cmp, {
            shadow: false
        });
        cmp.on('render', this.addDeco, this, {
            single: true
        });
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.setUI('skinparchment');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="skin skin-tl"></div>' + '<div class="skin skin-tm"></div>' + '<div class="skin skin-tr"></div>' + '<div class="skin skin-mr"></div>' + '<div class="skin skin-br"></div>' + '<div class="skin skin-bm"></div>' + '<div class="skin skin-bl"></div>' + '<div class="skin skin-ml"></div>' + '<div class="skin skin-bg"></div>' + '<div class="parchment parchment-tl"></div>' + '<div class="parchment parchment-tm"></div>' + '<div class="parchment parchment-tr"></div>' + '<div class="parchment parchment-mr"></div>' + '<div class="parchment parchment-br"></div>' + '<div class="parchment parchment-bm"></div>' + '<div class="parchment parchment-bl"></div>' + '<div class="parchment parchment-ml"></div>' + '<div class="parchment parchment-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы плагин предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'skin-tl.png',
                IMAGE_URL + 'skin-tm.png',
                IMAGE_URL + 'skin-tr.png',
                IMAGE_URL + 'skin-mr.png',
                IMAGE_URL + 'skin-br.png',
                IMAGE_URL + 'skin-bm.png',
                IMAGE_URL + 'skin-bl.png',
                IMAGE_URL + 'skin-ml.png',
                IMAGE_URL + 'skin-bg.png',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'parchment-tl.jpg',
                IMAGE_URL + 'parchment-tm.jpg',
                IMAGE_URL + 'parchment-tr.jpg',
                IMAGE_URL + 'parchment-mr.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'parchment-br.jpg',
                IMAGE_URL + 'parchment-bm.jpg',
                IMAGE_URL + 'parchment-bl.jpg',
                IMAGE_URL + 'parchment-ml.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'separator-horizontal.jpg'
            ]
        };
    }
});

/**
 * Вспомогательные функции для оформления кожано-бумажных элементов
 */
Ext.define('ExGods.view.plugin.SkinPaperDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.skinpaperdeco',
    init: function(cmp) {
        Ext.applyIf(cmp, {
            padding: '13 17 27 14',
            title: ' '
        });
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        Ext.apply(cmp, {
            shadow: false
        });
        cmp.on('render', this.addDeco, this, {
            single: true
        });
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('x-skin');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="skin skin-tl"></div>' + '<div class="skin skin-tm"></div>' + '<div class="skin skin-tr"></div>' + '<div class="skin skin-mr"></div>' + '<div class="skin skin-br"></div>' + '<div class="skin skin-bm"></div>' + '<div class="skin skin-bl"></div>' + '<div class="skin skin-ml"></div>' + '<div class="skin skin-bg"></div>' + '<div class="paper paper-tl"></div>' + '<div class="paper paper-tm"></div>' + '<div class="paper paper-tr"></div>' + '<div class="paper paper-mr"></div>' + '<div class="paper paper-br"></div>' + '<div class="paper paper-bm"></div>' + '<div class="paper paper-bl"></div>' + '<div class="paper paper-ml"></div>' + '<div class="paper paper-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы плагин предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'skin-tl.png',
                IMAGE_URL + 'skin-tm.png',
                IMAGE_URL + 'skin-tr.png',
                IMAGE_URL + 'skin-mr.png',
                IMAGE_URL + 'skin-br.png',
                IMAGE_URL + 'skin-bm.png',
                IMAGE_URL + 'skin-bl.png',
                IMAGE_URL + 'skin-ml.png',
                IMAGE_URL + 'skin-bg.png',
                IMAGE_URL + 'deco/paper/paper_top_right.png',
                IMAGE_URL + 'deco/paper/paper_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_middle.png',
                IMAGE_URL + 'deco/paper/paper_bottom_left.png',
                IMAGE_URL + 'deco/paper/paper_left.png',
                IMAGE_URL + 'deco/paper/paper_center_tile.png'
            ]
        };
    }
});

/**
 * Вспомогательные функции для оформления окошек
 */
Ext.define('ExGods.view.plugin.WinDeco', {
    alias: 'plugin.windeco',
    extend: Ext.AbstractPlugin,
    init: function(cmp) {
        var me = this;
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 29;
                    tool.width = 25;
                });
                this.callParent(arguments);
            }
        });
        Ext.apply(cmp, {
            defaultDockWeights: {
                top: 7,
                bottom: 5,
                left: 3,
                right: 1
            },
            plain: true,
            shadow: false
        });
        cmp.header = Ext.apply(cmp.header || {}, {
            padding: '6 10 0 35',
            titleAlign: 'center'
        });
        cmp.padding = cmp.padding == undefined ? '0 17 19 18' : cmp.padding;
        cmp.on('render', me.addDeco, me);
        me.cmp = cmp;
    },
    /**
     * Добавляет элементы оформления
     */
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('window-deco');
        cmp.el.insertHtml('afterBegin', '<div class="battle-window-deco battle-window-tl window-frame window-tl"></div>' + '<div class="battle-window-deco battle-window-tm window-frame window-tm">' + '<div class="battle-window-title window-title"></div>' + '</div>' + '<div class="battle-window-deco battle-window-tr window-frame window-tr"></div>' + '<div class="battle-window-deco battle-window-mr window-frame window-mr"></div>' + '<div class="battle-window-deco battle-window-br window-frame window-br"></div>' + '<div class="battle-window-deco battle-window-bm window-frame window-bm"></div>' + '<div class="battle-window-deco battle-window-bl window-frame window-bl"></div>' + '<div class="battle-window-deco battle-window-ml window-frame window-ml"></div>' + '<div class="battle-window-deco battle-window-bg window-frame window-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [
                IMAGE_URL + 'battle-window-close.png',
                IMAGE_URL + 'battle-window-tl.png',
                IMAGE_URL + 'battle-window-tm.png',
                IMAGE_URL + 'battle-window-tr.png',
                IMAGE_URL + 'battle-window-mr.png',
                IMAGE_URL + 'battle-window-br.png',
                IMAGE_URL + 'battle-window-bm.png',
                IMAGE_URL + 'battle-window-bl.png',
                IMAGE_URL + 'battle-window-ml.png',
                IMAGE_URL + 'battle-window-bg.jpg'
            ].concat(arr_images)
        };
    }
});

/**
 * "Железное" оформление панели
 */
Ext.define('ExGods.view.plugin.IronDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.irondeco',
    init: function(cmp) {
        cmp.title = ' ';
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.setStyle({
            padding: '5px'
        });
        cmp.el.insertHtml('afterBegin', '<div class="iron-deco-tl"></div>' + '<div class="iron-deco-tm"></div>' + '<div class="iron-deco-tr"></div>' + '<div class="iron-deco-mr"></div>' + '<div class="iron-deco-br"></div>' + '<div class="iron-deco-bm"></div>' + '<div class="iron-deco-bl"></div>' + '<div class="iron-deco-ml"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы плагин предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'deco/iron/iron_deco_tl.png',
                IMAGE_URL + 'deco/iron/iron_deco_tm.png',
                IMAGE_URL + 'deco/iron/iron_deco_tr.png',
                IMAGE_URL + 'deco/iron/iron_deco_mr.png',
                IMAGE_URL + 'deco/iron/iron_deco_br.png',
                IMAGE_URL + 'deco/iron/iron_deco_bm.png',
                IMAGE_URL + 'deco/iron/iron_deco_bl.png',
                IMAGE_URL + 'deco/iron/iron_deco_ml.png'
            ]
        };
    }
});

/**
 * Компонент для добавления сообщения под компонент формы
 */
Ext.define('ExGods.view.plugin.FormSubText', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.formsubtext',
    init: function(form) {
        form.FormSubText = this;
        this.form = form;
    },
    removeSubText: function() {
        var formEl = this.form.getEl();
        if (formEl) {
            formEl.select(".form-subtext-elems").remove();
        }
        this.form.updateLayout();
    },
    update: function(result, color) {
        var me = this;
        formItems = me.form.items , length = formItems.items.length , formEl = me.form.getEl();
        if (!me.form.rendered) {
            return;
        }
        me.removeSubText();
        for (var i = 0; i < length; i++) {
            for (var j in result) {
                if (formItems.items[i].name === j) {
                    //Чтоб не растягивался textfield при длинне сообщения выше 22 букв, а переносил на следующую строку
                    if (formItems.items[i].xtype === 'textfield') {
                        var html = '<td colspan="2" width="' + formItems.items[i].getWidth() + 'px"><b style="colspan: 2;color:' + color + ';">' + result[j] + '</b></td>';
                    } else {
                        var html = '<td colspan="2"><b style="colspan: 2;color:' + color + ';">' + result[j] + '</b></td>';
                    }
                    Ext.get(formItems.items[i].id).down('tbody').createChild({
                        tag: 'tr',
                        cls: 'form-subtext-elems',
                        html: html
                    });
                }
            }
        }
        me.form.updateLayout();
    },
    destroy: function() {
        var me = this;
        me.form = null;
        me.callParent(arguments);
    }
});

/**
 * Листалка по страницам (вправо-влево). Используется, например, в магазине
 */
Ext.define('ExGods.view.plugin.Pager', {
    alias: 'plugin.pager',
    extend: Ext.AbstractPlugin,
    mixins: {
        observable: Ext.util.Observable
    },
    /**
     * cfg
     * Number - отступ левой кнопки
     */
    marginLeft: 0,
    /**
     * cfg
     * Number - отступ правой кнопки
     */
    marginRight: 0,
    /**
     * cfg
     * Number - отступ кнопок от верха элемента
     */
    top: 0,
    /**
     * cfg
     * total - количество страниц
     */
    total: 1,
    /**
     * cfg
     * current - текущая страница
     */
    current: 1,
    /**
     * cfg
     * totalTabs - количество вкладок
     */
    totalTabs: 0,
    /**
     * cfg
     * currentTab - текущая вкладка
     */
    currentTab: 0,
    /**
     * cfg
     * isWaitingForCenter - если компонент был создан пока center cкрыт - то надо подождать пока center откроется
     */
    isWaitingForCenter: false,
    /**
     * cfg
     * hidden - скрыт ли пейджер? вопрос
     */
    hidden: 0,
    /**
     * cfg
     * hideIfSinglePage - скрытать пейджер, если всего одна страница
     */
    hideIfSinglePage: 0,
    /**
     * cfg
     * tpl (Array) - template нижней панельки для пейджинга
     */
    tpl: [
        '<div class="pager-text">',
        '<div class="pager-text-left"></div>',
        '<div class="pager-text-center">{[this.printPages(values)]}</div>',
        '<div class="pager-text-right"></div>',
        '</div>',
        {
            printPages: function(values) {
                return ExGods.app.applyTpl(ExGods.getMsgByKey('plugin_pager_pagestpl'), {
                    current: values.current,
                    total: values.total || 1
                });
            }
        }
    ],
    /**
     * cfg для текста "Страница 1 из 1"
     */
    textTop: 341,
    textLeft: 491,
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        me.mixins.observable.constructor.call(me, config);
    },
    init: function(cmp) {
        var me = this;
        cmp.pager = me;
        cmp.on({
            afterlayout: me.addArrows,
            hide: me.hideArrows,
            close: me.hideArrows,
            scope: me
        });
        me.cmp = cmp;
        me.mon(Ext.getCmp('layer-over2'), 'show', me.refresh, me);
        me.mon(Ext.getCmp('layer-over2'), 'hide', me.refresh, me);
        me.mon(Ext.getCmp('center'), 'show', me.setVisible, me);
        me.mon(Ext.getCmp('center'), 'hide', me.setVisible, me);
        me.mon(cmp, 'show', me.onCmpShow, me);
        me.mon(cmp, 'render', function() {
            me.wnd = me.cmp.up('window1') || me.cmp.up('window2');
            me.onCmpShow();
        }, me);
    },
    onCmpShow: function() {
        this.setVisible();
    },
    setVisible: function() {
        var me = this;
        if (me.isVisible()) {
            this.showArrows();
            if (this.isWaitingForCenter) {
                this.setPosition();
                this.isWaitingForCenter = false;
            }
        } else {
            this.hideArrows();
        }
    },
    /**
     * Проверяет, виден ли пейджер
     */
    isVisible: function() {
        var me = this,
            centerContainer = Ext.getCmp('center');
        if (!centerContainer.isVisible()) {
            return false;
        } else {
            if (this.cmp && this.cmp.isVisible(true) && (!this.wnd || (this.wnd.isVisible())) && // && (this.wnd.layout.getActiveItem().down(this.cmp.xtype) ? 
            //  this.wnd.layout.getActiveItem().down(this.cmp.xtype).id : 
            //  this.wnd.layout.getActiveItem().id) == this.cmp.id
            !this.hidden && (!this.hideIfSinglePage || me.total > 1)) {
                return true;
            } else {
                return false;
            }
        }
    },
    setPosition: function() {
        var me = this,
            cmp = me.cmp,
            viewport = Ext.get('viewport'),
            position = cmp.el.getPageBox();
        if (me.leftArrow) {
            me.leftArrow.style.left = (position.left - (document.body.scrollWidth - viewport.getWidth()) / 2) + 'px';
            me.leftArrow.style.top = me.rightArrow.style.top = (position.top + me.top) + 'px';
            me.leftArrow.style.marginLeft = me.marginLeft + 'px';
        }
        if (me.rightArrow) {
            me.rightArrow.style.right = (document.body.scrollWidth - position.left - position.width - (document.body.scrollWidth - viewport.getWidth()) / 2) + 'px';
            me.rightArrow.style.marginRight = me.marginRight + 'px';
        }
        if (me.pagerText) {
            me.pagerText.style.top = me.textTop + 'px';
            me.pagerText.style.left = me.textLeft + 'px';
        }
    },
    hideArrows: function() {
        if (this.leftArrow)  {
            this.leftArrow.style.display = 'none';
        }
        
        if (this.rightArrow)  {
            this.rightArrow.style.display = 'none';
        }
        
        if (this.pagerText)  {
            this.pagerText.style.display = 'none';
        }
        
        this.fireEvent('hide', this);
    },
    showArrows: function() {
        if (this.leftArrow)  {
            this.leftArrow.style.display = 'block';
        }
        
        if (this.rightArrow)  {
            this.rightArrow.style.display = 'block';
        }
        
        if (this.pagerText)  {
            this.pagerText.style.display = 'block';
        }
        
        //this.setZIndex();
        this.fireEvent('show', this);
    },
    /**
     * Добавляет элементы оформления
     */
    addArrows: function() {
        var me = this,
            cmp = me.cmp,
            viewport = Ext.get('viewport'),
            position = cmp.el.getPageBox();
        if (!Ext.getCmp('center').isVisible()) {
            me.isWaitingForCenter = true;
        } else {
            me.isWaitingForCenter = false;
        }
        if (!me.leftArrow) {
            me.leftArrow = viewport.insertHtml('beforeEnd', '<div class="pager-left-arrow"><div></div></div>');
            me.leftArrow.onclick = function() {
                if (me.current <= 1 && me.currentTab <= 0)  {
                    return;
                }
                
                me.current--;
                if (typeof me.cmp.prevPage == 'function') {
                    me.cmp.prevPage(me);
                } else {
                    me.cmp.fireEvent('prev', me);
                }
            };
            if (me.current <= 1 && me.currentTab <= 0)  {
                me.leftArrow.firstChild.className += ' disabled';
            }
            
        }
        if (!me.rightArrow) {
            me.rightArrow = viewport.insertHtml('beforeEnd', '<div class="pager-right-arrow"><div></div></div>');
            me.rightArrow.onclick = function() {
                if (me.current >= me.total && me.currentTab >= me.totalTabs - 1)  {
                    return;
                }
                
                me.current++;
                if (typeof me.cmp.nextPage == 'function') {
                    me.cmp.nextPage(me);
                } else {
                    me.cmp.fireEvent('next', me);
                }
            };
            if (me.current >= me.total && me.currentTab >= me.totalTabs - 1)  {
                me.rightArrow.firstChild.className += ' disabled';
            }
            
        }
        if (me.tpl && !me.pagerText) {
            me.tpl = Ext.create('ExGods.view.Template', me.tpl);
            me.pagerText = me.tpl.insertAfter(cmp.el, {
                current: me.current,
                total: me.total
            });
        }
        me.setPosition();
        me.setZIndex();
        if (!me.isVisible()) {
            me.hideArrows();
        }
        me.fireEvent('render', me);
        return true;
    },
    setZIndex: function() {
        var me = this;
        setTimeout(function() {
            if (me.wnd && me.wnd.layer.el && me.leftArrow)  {
                me.leftArrow.style.zIndex = parseInt(me.wnd.layer.el.getStyle('z-index'));
            }
            
            if (me.wnd && me.wnd.layer.el && me.rightArrow)  {
                me.rightArrow.style.zIndex = parseInt(me.wnd.layer.el.getStyle('z-index'));
            }
            
        }, 0);
    },
    refresh: function() {
        if (!this.cmp || !this.wnd)  {
            return;
        }
        
        var me = this,
            layer = me.wnd.layer,
            removeDisabled = function(cls) {
                cls = cls.split(' ');
                for (var i = cls.length - 1; i >= 0; i--) {
                    if (cls[i] == 'disabled') {
                        cls.splice(i, 1);
                    }
                }
                return cls.join(' ');
            },
            disabled = false;
        me.setVisible();
        if (layer) {
            disabled = layer.id == 'layer-over1' && Ext.getCmp('layer-over2').isVisible();
        }
        if (!me.leftArrow && !me.addArrows())  {
            return;
        }
        
        if (disabled || (me.current <= 1 && me.currentTab <= 0)) {
            if (me.leftArrow.firstChild.className.split(' ').indexOf('disabled') == -1)  {
                me.leftArrow.firstChild.className += ' disabled';
            }
            
        } else {
            me.leftArrow.firstChild.className = removeDisabled(me.leftArrow.firstChild.className);
        }
        if (disabled || (me.current >= me.total && me.currentTab >= me.totalTabs - 1)) {
            if (me.rightArrow.firstChild.className.split(' ').indexOf('disabled') == -1)  {
                me.rightArrow.firstChild.className += ' disabled';
            }
            
        } else {
            me.rightArrow.firstChild.className = removeDisabled(me.rightArrow.firstChild.className);
        }
        if (Ext.getClassName(me.tpl) && me.isVisible()) {
            me.pagerText.parentNode.removeChild(me.pagerText);
            me.pagerText = me.tpl.insertAfter(me.cmp.el, {
                current: me.current || 1,
                total: me.total || 1
            });
            me.pagerText.style.top = me.textTop + 'px';
            me.pagerText.style.left = me.textLeft + 'px';
        }
        me.fireEvent('refresh');
    },
    removeArrows: function() {
        if (this.leftArrow) {
            this.leftArrow.parentNode.removeChild(this.leftArrow);
        }
        if (this.rightArrow) {
            this.rightArrow.parentNode.removeChild(this.rightArrow);
        }
    },
    removePagerText: function() {
        if (this.pagerText) {
            this.pagerText.parentNode.removeChild(this.pagerText);
        }
    },
    destroy: function() {
        var me = this;
        me.cmp.un({
            render: me.addArrows,
            afterlayout: me.addArrows,
            hide: me.hideArrows,
            close: me.hideArrows,
            show: me.showArrows,
            scope: me
        });
        me.mun(Ext.getCmp('layer-over2'), 'show', me.refresh, me);
        me.mun(Ext.getCmp('layer-over2'), 'hide', me.refresh, me);
        me.mun(Ext.getCmp('center'), 'show', me.setVisible, me);
        me.mun(Ext.getCmp('center'), 'hide', me.setVisible, me);
        me.mun(me.cmp, 'show', me.onCmpShow, me);
        me.removeArrows();
        me.removePagerText();
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'pager/btn_left_bg.png',
                IMAGE_URL + 'pager/btn_right_bg.png',
                IMAGE_URL + 'pager/btn_left.png',
                IMAGE_URL + 'pager/btn_right.png',
                IMAGE_URL + 'page_num.png'
            ]
        };
    }
});

/**
 * "Железное" оформление панели
 */
Ext.define('ExGods.view.plugin.InventoryFrame', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.inventory_frame',
    init: function(cmp) {
        cmp.title = ' ';
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        if (!cmp.noBorderImages) {
            cmp.el.setStyle({
                padding: '10px'
            });
            cmp.el.insertHtml('afterBegin', '<div class="inventorty-frame-ml"></div>' + '<div class="inventorty-frame-tm"></div>' + '<div class="inventorty-frame-bm"></div>' + '<div class="inventorty-frame-mr"></div>' + '<div class="inventorty-frame-br"></div>' + '<div class="inventorty-frame-bl"></div>' + '<div class="inventorty-frame-tr"></div>' + '<div class="inventorty-frame-tl"></div>');
        }
        cmp.el.insertHtml('afterBegin', '<div class="inventorty-frame-top"></div>');
        if (cmp.headerText) {
            cmp.el.insertHtml('afterBegin', '<div class="inventorty-frame-text inventory-frame-text-background">' + cmp.headerText + '</div>' + '<div class="inventorty-frame-text">' + cmp.headerText + '</div>');
        }
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'inventory/frm_top_left.jpg',
                IMAGE_URL + 'inventory/frm_top_center.jpg',
                IMAGE_URL + 'inventory/frm_top_right.jpg',
                IMAGE_URL + 'inventory/frm_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_center.jpg',
                IMAGE_URL + 'inventory/frm_bottom_left.jpg',
                IMAGE_URL + 'inventory/frm_left.jpg',
                IMAGE_URL + 'inventory/frm_top.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Кнопка в виде картинки
 */
Ext.define('ExGods.view.ImageButton', {
    alias: 'widget.imagebutton',
    extend: Ext.button.Button,
    image: Ext.BLANK_IMAGE_URL,
    padding: 0,
    onRender: function(ct, position) {
        var me = this;
        me.callParent(arguments);
        me.setImage();
    },
    /**
     * Устанваливает новую картинку
     * @param {String} image URL картинки
     */
    setImage: function(image) {
        var me = this;
        if (image)  {
            me.image = image;
        }
        
        me.btnEl.setStyle({
            background: 'url(' + me.image + ') no-repeat 50% 50%'
        });
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Кастомный компонент прокрутки.
 * Вся анимация происходит, когда меняется значение Ext.slider.Single скроллера.
 * Прокрутка работает только с компонентами унаследованными от Ext.panel.Panel,
 * т.к. в них присутствуют dock элементы необходимые для плагина.
 */
Ext.define('ExGods.view.plugin.Scroller', {
    extend: ExGodsCore.view.plugin.Scroller,
    alias: 'plugin.scroller',
    scrollerConfig: {
        slider: {
            animate: false,
            decimalPrecision: false,
            flex: 1,
            increment: 1,
            useTips: false,
            value: 100,
            vertical: true
        },
        scrollTop: {
            cls: 'scroll-top',
            height: 22
        },
        scrollBottom: {
            cls: 'scroll-bottom',
            height: 20
        },
        toolbar: {
            dock: 'right',
            defaults: {
                margin: 0,
                width: 21
            },
            ui: 'scroller'
        }
    },
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [
                IMAGE_URL + 'scrollbar/thumb.png',
                IMAGE_URL + 'scrollbar/bg_midle.png',
                IMAGE_URL + 'scrollbar/bg_top.png',
                IMAGE_URL + 'scrollbar/bg_bottom.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Отображение списка контактов
 */
Ext.define('ExGods.view.chat.ContactList', {
    extend: Ext.panel.Panel,
    alias: 'widget.chatcontactlist',
    plugins: [
        {
            ptype: 'scroller',
            autoHide: true,
            resetOnShow: false,
            scrollDeltaY: 23
        }
    ],
    title: '',
    cls: 'chat-contact-list',
    ignore_focus: true,
    // чтобы экст не скроллил боди
    /**
     * @cfg {Ext.data.Store} store Хранилище списка контактов
     */
    store: null,
    initComponent: function() {
        var me = this;
        me.items = {
            xtype: 'dataview',
            itemId: 'contact-list',
            autoEl: 'ul',
            cls: 'contacts userlist',
            itemSelector: 'li.userlist-item',
            loadMask: false,
            store: me.store,
            tpl: [
                '<tpl for=".">',
                '<li class="userlist-item {[this.getCls(values)]}">',
                '<span class="action-icon private-msg-icon" data-qtip="' + ExGods.getMsgByKey('view_chat_contactlist_privatett') + '"></span>',
                '<span class="action-icon user-info-icon" data-qtip="' + ExGods.getMsgByKey('view_chat_contactlist_infott') + '"></span>',
                '{[ ExGods.printUser(values, {fields: ["name", "guild"], maxNameWidth: (values.guild ? 122 : 146) }) ]}',
                '<span class="right-col">',
                '{[ ExGods.printUser(values, {fields: ["level", "rating_rank", "trophy_level", "menuicon"], hideLevelIcon: true}) ]}',
                '</span>',
                '</li>',
                '</tpl>',
                {
                    getCls: function(data) {
                        var cls = [];
                        if (data.binding.battle) {
                            cls.push('exg-bgcolor-in-battle');
                        }
                        if (data.moder) {
                            cls.push('moder');
                        }
                        cls.push('gender-' + data.gender);
                        return cls.join(' ');
                    }
                }
            ]
        };
        me.callParent();
    },
    /**
     * Подставляет новый стор к списку контактов
     * Метод выбрасывает событие {@event afterstorechanged} после обновления стора
     * @param {Ext.data.Store} store (required)
     */
    bindStore: function(store) {
        var me = this,
            dataview = me.down('dataview');
        dataview.bindStore(store);
        // пробрасываю событие об изменении хранилища, чтобы контроллер мог отловить подмену (это нужно, 
        // например, чтобы отфильтровать по общему фильтру)
        me.fireEvent('afterstorechanged', me);
    }
});

/**
 * Отображение списка сообщений чата
 */
Ext.define('ExGods.view.chat.MessageList', {
    extend: ExGodsCore.view.chat.MessageList,
    alias: 'widget.chatmessagelist',
    cls: 'chat-messages',
    ignore_focus: true,
    // чтобы экст не скроллил боди
    /**
     * @property {String} storageId
     * Уникальная строка по которой идет поиск "старых" сообщений вкладки чата
     */
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    initComponent: function() {
        var me = this;
        me.messageTplByType = {
            room: [
                '<span class="message-info">',
                '<span class="message-menu-icon"></span>',
                '<tpl if="x.time">',
                '<span class="time">{[ this.printTime(values.x.time) ]}</span>',
                '</tpl>',
                '{[ExGods.printUser({display_title: values.x.from_realuser, race: values.x.race, moder: values.x.moder}, {fields: ["name", "menuicon"] }) ]}',
                ': ',
                '</span>',
                '<span class="message-body">',
                '<span>{body:linkify}</span>',
                '</span>'
            ],
            to: [
                '<span class="message-info">',
                '<span class="message-menu-icon"></span>',
                '<tpl if="x.time">',
                '<span class="time">{[ this.printTime(values.x.time) ]}</span>',
                '</tpl>',
                '{[ExGods.printUser({display_title: values.x.from_realuser, race: values.x.race, moder: values.x.moder}, {fields: ["name", "menuicon"] }) ]}',
                '<img class="to-sign" height="11" src="' + IMAGE_URL + 'to_message.png" width="13" />',
                '<tpl for="Ext.JSON.decode(x.to)">',
                '{[ExGods.printUser({display_title: values, race: this.getRace(values, parent.x), moder: this.getModer(values, parent.x)}, {fields: ["name", "menuicon"] }) ]}',
                '<tpl if="xindex != xcount">, </tpl>',
                '</tpl>',
                ': ',
                '</span>',
                '<span class="message-body">',
                '<span>{body:linkify}</span>',
                '</span>'
            ],
            message: [
                '<tpl if="x.time">',
                '<span class="time">{[ this.printTime(values.x.time) ]}</span>',
                '</tpl>',
                '<span class="message-body">',
                '{body.body:linkify}',
                '</span>'
            ],
            'private': [
                '<span class="message-info">',
                '<span class="message-menu-icon"></span>',
                '<tpl if="x.time">',
                '<span class="time">{[ this.printTime(values.x.time) ]}</span>',
                '</tpl>',
                '{[ExGods.printUser({display_title: values.x.from_realuser, race: values.x.race, moder: values.x.moder}, {fields: ["name", "menuicon"] }) ]}',
                '<img class="private-sign" height="11" src="' + IMAGE_URL + 'private_message.png" width="13" />',
                '<tpl for="x.to_realuser.split(\',\')">',
                '{[ExGods.printUser({display_title: values, race: this.getRace(values, parent.x), moder: this.getModer(values, parent.x)}, {fields: ["name", "menuicon"] }) ]}',
                '<tpl if="xindex != xcount">, </tpl>',
                '</tpl>',
                ': ',
                '</span>',
                '<span class="message-body">',
                '<span>{body:linkify}</span>',
                '</span>'
            ],
            prize: ExGods.getMsgByKey('view_chat_you_get_reward')
        };
        Ext.Object.each(me.messageTplByType, function(key, tpl) {
            if (typeof tpl == 'object') {
                tpl.push({
                    printTime: function(time) {
                        return time.substr(0, 5);
                    },
                    getRace: function(nick, data) {
                        if (data.users_info && data.users_info[nick]) {
                            return data.users_info[nick].race || 0;
                        } else {
                            return 0;
                        }
                    },
                    getModer: function(nick, data) {
                        if (data.users_info && data.users_info[nick]) {
                            return data.users_info[nick].moder || 0;
                        } else {
                            return 0;
                        }
                    }
                });
            }
        });
        me.callParent(arguments);
    },
    // @private
    onAfterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.listEl.on('click', me.onMessageClick, me, {
            delegate: 'li.message'
        });
    },
    // me.listEl.on('mouseover', me.onMessageMouseOver, me, {delegate: 'li.message'});
    // me.listEl.on('mouseout', me.onMessageMouseOut, me, {delegate: 'li.message'});
    // addMessage: function(msg) {
    // },
    /**
     * @private
     * Обрабатывает клие по сообщению, дальнейшие действия зависят от контекста
     * и реализации
     */
    onMessageClick: function(e, t) {
        var me = this,
            nickEl = Ext.get(e.getTarget('.name')),
            item = Ext.get(e.getTarget('.item')),
            message = Ext.get(e.getTarget('.message')),
            messageMenuEl = Ext.get(e.getTarget('.message-menu-icon')),
            userMenuEl = Ext.get(e.getTarget('.menu-icon')),
            msgData = me.data.get(message.id),
            nick, type;
        if (nickEl) {
            nick = nickEl.dom.innerText || nickEl.dom.textContent;
            if (message.hasCls('message-to') || message.hasCls('message-room'))  {
                type = 'to';
            }
            
            if (message.hasCls('message-private'))  {
                type = 'private';
            }
            
            /**
             * @event userclick
             * Срабатывает при клике по нику в чате
             * @param {Ext.Component} this
             */
            me.fireEvent('user-click', me.getUserInfoFromMessage(nick, msgData), type);
        }
        if (item) {
            if (msgData) {
                var itemProtoId;
                if (!item.getAttribute('data-proto_id')) {
                    if (msgData.body.body && msgData.body.body.stuff && !Ext.isArray(msgData.body.body.stuff)) {
                        itemProtoId = msgData.body.body.stuff.params.id;
                    } else if (msgData.body.data && msgData.body.data.stuff && !Ext.isArray(msgData.body.data.stuff)) {
                        itemProtoId = msgData.body.data.stuff.params.id;
                    }
                }
                if (itemProtoId) {
                    /**
                     * @event itemclick
                     * Срабатывает при клике по предмету в чате
                     * @param {String} itemProtoId Прототип предмета
                     */
                    ExGods.app.fireEvent('itemclick', {
                        itemEl: item,
                        proto_id: itemProtoId
                    });
                }
            }
        }
        if (messageMenuEl) {
            me.fireEvent('message-menu-click', messageMenuEl, msgData);
        }
        if (userMenuEl) {
            var nick = userMenuEl.up('.userinfo').getAttribute('data-uname');
            me.fireEvent('user-menu-click', userMenuEl, me.getUserInfoFromMessage(nick, msgData));
        }
    },
    /**
     * @private
     * Превращаем пришёдшие данные в HTML код
     * 
     * @param {Object} data Данные сообщения. Переменная принимает два типа данных:
     * сырой и подготовленный (от этого формата я отказываюсь см. ниже). Эти данные
     * подготавливаются в функции {@link ExGods.controller.Chat#onMessage}
     * @return {String} HTML сообщение чата
     */
    parseMessage: function(data) {
        var me = this,
            html = '<li class="message message-empty"></li>',
            type = data.type,
            msgId = data.id,
            xtpl,
            cls = [
                'message'
            ],
            isMessageWithMe = function(data) {
                var chat = ExGods.app.getController('Chat');
                return chat.isMyMessage(data) || chat.isMessageToMe(data);
            };
        if (data.x.moder) {
            cls.push('moder-message');
        }
        if (data.x.to) {
            type = 'to';
        }
        xtpl = me.messageTplByType[type];
        if (!xtpl && data.tpl) {
            xtpl = new Ext.XTemplate([
                '<span class="message-info">',
                '<tpl if="x && x.time">',
                '<span class="time">{[ this.printTime(values.x.time)]}</span>',
                '</tpl>',
                '</span>',
                '<span class="message-body">',
                data.tpl,
                '</span>',
                {
                    printTime: function(time) {
                        return time.substr(0, 5);
                    }
                }
            ]);
        }
        if (xtpl) {
            try {
                html = '<li id="' + msgId + '" class="' + cls.join(' ') + ' message-' + type + ' ' + (isMessageWithMe(data) ? 'message-my' : '') + '">' + me.prepareMessageText(xtpl, data) + '</li>';
            } catch (e) {}
        }
        //
        return html;
    },
    /**
     * @private
     * Подготавливает текст сообщения
     */
    prepareMessageText: function(tpl, data) {
        var me = this,
            message;
        if (ExGods.app.getUser().get('moder') == 0 && typeof data.body == 'string') {
            data.body = ExGods.util.Helper.censoreText(data.body);
        }
        // применяю шаблон
        if (typeof tpl == 'object') {
            message = tpl.apply(data);
        } else {
            message = ExGods.app.applyTpl(tpl, data);
        }
        message = ExGods.util.Helper.processTextWithSmiles(message);
        return message;
    },
    getUserInfoFromMessage: function(nick, message) {
        var me = this;
        if (message.x && message.x.from_realuser == nick) {
            return {
                display_title: nick,
                race: message.x.race || 0,
                moder: message.x.moder || 0
            };
        } else if (message.x && message.x.users_info && message.x.users_info[nick]) {
            return {
                display_title: nick,
                race: message.x.users_info[nick].race || 0,
                moder: message.x.users_info[nick].moder || 0
            };
        } else {
            return {
                display_title: nick
            };
        }
    }
});
// onMessageMouseOver: function(e,t) {
//  var me = this,
//      el = Ext.get(t);
//  if (t == e.relatedTarget || Ext.fly(e.relatedTarget).parent('.message') == el) {
//      return;
//  }
//  if (me.mouseOverTimer) {                
//      clearTimeout(me.mouseOverTimer);
//  }
//  me.mouseOverTimer = setTimeout(function() {
//      el.addCls('selected');
//  }, ExGods.ref('constants|chat_messages_select_delay').value);
// },
// onMessageMouseOut: function(e,t) {
//  var me = this,
//      el = Ext.get(t);
//  if (t == e.relatedTarget || Ext.fly(e.relatedTarget).parent('.message') == el) {
//      return;
//  }
//  el.removeCls('selected');
//  clearTimeout(me.mouseOverTimer);
//  me.mouseOverTimer = null;       
// },

/**
 * Таб в виде надписи на пергаменте
 */
Ext.define('ExGods.view.chat.Tab', {
    extend: Ext.tab.Tab,
    alias: 'widget.chattab',
    ui: 'chat'
});

/**
 * Панель чата с вкладками
 */
Ext.define('ExGods.view.chat.TabPanel', {
    extend: Ext.tab.Panel,
    alias: 'widget.chattabpanel',
    tabBar: {
        defaults: {
            height: 26,
            margin: 0,
            padding: '0 5'
        },
        height: 26
    },
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {
                xtype: 'chattab'
            };
        } else {
            Ext.applyIf(item.tabConfig, {
                xtype: 'chattab'
            });
        }
        me.callParent(arguments);
    }
});

/**
 * Поле ввода сообщений чата
 */
Ext.define('ExGods.view.chat.InputField', {
    extend: Ext.container.Container,
    alias: 'widget.chatinputfield',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    ignore_focus: true,
    // чтобы экст не скроллил боди
    initComponent: function() {
        var me = this;
        me.message = me.emptyMessage();
        me.textField = Ext.widget('textfield', {
            itemId: 'textfield',
            emptyText: ExGods.getMsgByKey('view_chat_input_emptytext'),
            flex: 1,
            enforceMaxLength: true,
            maxLength: parseInt(ExGods.ref('constants|chat_message_max_length').value),
            padding: '0 0 0 0',
            disabled: me.disabled
        });
        me.items = [
            {
                xtype: 'dataview',
                itemId: 'nicks',
                data: {},
                itemSelector: 'li',
                maxWidth: 230,
                tpl: [
                    '<ul class="nick-list">',
                    '<tpl foreach="to">',
                    '<li data-index="{[ xindex -1 ]}" class="nick {parent.type}">',
                    '<div class="inner">',
                    '<span class="menu-icon"></span>',
                    '<span class="text">{.}</span>',
                    '<span class="close-icon"></span>',
                    '</div>',
                    '</li>',
                    '</tpl>',
                    '</ul>'
                ]
            },
            me.textField
        ];
        this.relayEvents(me.textField, [
            'specialkey'
        ]);
        // bubbling для события нажатия клавиш
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent();
        me.getEl().on('click', function(e, el) {
            var index = Ext.get(el).parent('li').getAttribute("data-index");
            me.message.to.splice(index, 1);
            if (!me.message.to.length) {
                me.message.type = 'room';
            }
            me.updateNickList(me.message);
        }, me, {
            delegate: '.close-icon'
        });
        me.getEl().on('click', function(e, el) {
            var index = Ext.get(el).parent('li').getAttribute("data-index");
            me.fireEvent('user-menu-click', el, me.message.to[index]);
        }, me, {
            delegate: '.menu-icon'
        });
    },
    updateNickList: function(data) {
        var me = this,
            nicksDataView = me.getComponent('nicks'),
            listEl;
        nicksDataView.update(data);
        listEl = nicksDataView.getEl().down('.nick-list');
        // сдвигаю ники влево, чтобы был виден последний
        if (listEl.getWidth() >= 230) {
            listEl.setStyle('margin-left', (230 - listEl.getWidth()) + 'px');
        } else {
            listEl.setStyle('margin-left', 0);
        }
    },
    /**
     * Показать новое сообщение.
     * @param {Object} message Данные сообщения в фомарте {type, content, to}
     */
    setMessage: function(message) {
        var me = this;
        if (!message) {
            message = me.emptyMessage();
        }
        me.message = message;
        me.updateNickList(message);
        me.setValue(message.content);
        setTimeout(function() {
            me.textField.focus();
        }, 0);
    },
    // иначе фокус теряется, если он инициализирован например из окна, которое затем закрывается
    getMessage: function() {
        var me = this;
        me.message.content = me.textField.getValue();
        return this.message;
    },
    emptyMessage: function() {
        return {
            type: 'room',
            to: [],
            content: ''
        };
    },
    // 
    // Реализация интерфейса текстового поля //
    //
    getValue: function() {
        var me = this;
        return me.textField.getValue();
    },
    setValue: function(value) {
        var me = this;
        return me.textField.setValue(value);
    },
    selectText: function(start, end) {
        var me = this;
        return me.textField.selectText(start, end);
    },
    disable: function() {
        var me = this;
        if (me.rendered) {
            me.textField.disable();
        }
        me.disabled = true;
    },
    enable: function() {
        var me = this;
        if (me.rendered) {
            me.textField.enable();
        }
        me.disabled = false;
    }
});

/**
 * Отображает полоску поиска по контактам чата
 */
Ext.define('ExGods.view.chat.ContactsFilter', {
    extend: Ext.form.FieldContainer,
    alias: 'widget.contactsfilter',
    id: 'chat-contacts-filter',
    initComponent: function() {
        var me = this;
        Ext.apply(me, {
            layout: 'hbox',
            items: [
                {
                    xtype: 'textfield',
                    flex: 1,
                    enableKeyEvents: true,
                    margin: '0 0 0 0',
                    height: 22,
                    emptyText: ExGods.getMsgByKey('view_chat_contactfilter_emptytext')
                },
                {
                    xtype: 'button',
                    id: 'chat-search-button',
                    width: 22,
                    height: 22,
                    margin: '0 0 0 -11'
                }
            ]
        });
        me.callParent(arguments);
    }
});

/**
 * Нижня панель управления чатом
 */
Ext.define('ExGods.view.chat.Toolbar', {
    extend: Ext.toolbar.Toolbar,
    alias: 'widget.chattoolbar',
    id: 'chat-toolbar',
    defaults: {
        height: 22
    },
    height: 28,
    padding: '0 0 2 27',
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'chatinputfield',
                id: 'chat-text-field',
                disabled: true,
                height: 22,
                padding: '0 0 0 0',
                width: 480
            },
            {
                xtype: 'imagebutton',
                id: 'chat-send-button',
                action: 'send',
                margin: '0 0 0 -11',
                width: 22,
                tooltip: ExGods.getMsgByKey('view_chat_toolbar_send')
            },
            {
                xtype: 'imagebutton',
                id: 'chat-clear-button',
                action: 'clear',
                width: 22,
                margin: '0 0 0 6',
                tooltip: ExGods.getMsgByKey('view_chat_toolbar_clear')
            },
            {
                xtype: 'imagebutton',
                id: 'chat-togglesmiles-button',
                action: 'togglesmiles',
                width: 22,
                margin: '0 0 0 6',
                tooltip: ExGods.getMsgByKey('view_chat_toolbar_smiles')
            },
            {
                xtype: 'contactsfilter',
                width: 210,
                margin: '0 0 0 54'
            }
        ];
        me.callParent();
    }
});

/**
 * Контейнер чата
 */
Ext.define('ExGods.view.chat.ChatContainer', {
    extend: Ext.panel.Panel,
    alias: 'widget.chatcontainer',
    bodyPadding: '0 0 0 0',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    padding: '0 0 0 0',
    region: 'south',
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'component',
                width: 20,
                id: 'chat-separator-left',
                margin: '26 0 0 0'
            },
            {
                // панель с вкладками чата
                xtype: 'chattabpanel',
                id: 'chat-tab-panel',
                defaultType: 'chatmessagelist',
                flex: 1,
                bodyPadding: '4 0',
                margin: '0 -3 0 -3'
            },
            {
                xtype: 'component',
                width: 18,
                id: 'chat-separator-center',
                margin: '26 0 0 0'
            },
            {
                // контакты локации
                xtype: 'chattabpanel',
                id: 'contact-tab-panel',
                width: 263,
                items: [
                    {
                        xtype: 'chatcontactlist',
                        id: 'chat-contact-list',
                        store: ExGods.app.getStore('ChatContacts')
                    },
                    {
                        xtype: 'chatcontactlist',
                        id: 'guild-contact-list',
                        store: ExGods.app.getStore('GuildOnlineList')
                    },
                    {
                        xtype: 'chatcontactlist',
                        id: 'guild-group-list',
                        store: ExGods.app.getStore('GuildGroupOnlineList')
                    }
                ],
                bodyPadding: '4 0'
            },
            {
                xtype: 'component',
                width: 20,
                id: 'chat-separator-right',
                margin: '26 0 0 0'
            }
        ];
        me.bbar = {
            xtype: 'chattoolbar'
        };
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        // фон шапки
        Ext.DomHelper.insertFirst('chat-container-body', {
            id: 'chat-top-deco',
            tag: 'div'
        });
        // фон подвала
        Ext.DomHelper.append('chat-toolbar', {
            id: 'chat-bottom-deco',
            tag: 'div'
        });
        // кнопка "Развернуть"
        Ext.widget('button', {
            xtype: 'button',
            id: 'chat-expand-btn',
            renderTo: 'chat-container-body',
            cls: 'chat-header-btn',
            x: 766,
            y: 2,
            floating: true,
            shadow: false,
            width: 26,
            height: 24,
            tooltip: ExGods.getMsgByKey('view_chat_container_fullchattt')
        });
        // кнопка "задать вопрос"
        Ext.widget('button', {
            xtype: 'button',
            id: 'chat-question-btn',
            renderTo: 'chat-container-body',
            cls: 'chat-header-btn',
            x: 794,
            y: 2,
            floating: true,
            shadow: false,
            width: 26,
            height: 24,
            tooltip: ExGods.getMsgByKey('view_chat_container_questionchattt')
        });
        // кнопка "Скрыть чат"
        Ext.widget('button', {
            xtype: 'button',
            id: 'chat-off-btn',
            renderTo: 'chat-container-body',
            cls: 'chat-header-btn',
            x: 822,
            y: 2,
            floating: true,
            shadow: false,
            width: 26,
            height: 24,
            tooltip: ExGods.getMsgByKey('view_chat_container_hidechattt')
        });
    },
    scrollChatToBottom: function() {
        var me = this,
            tabPanel = me.rendered ? Ext.getCmp('chat-tab-panel') : null,
            tab;
        if (tabPanel) {
            tab = tabPanel.getActiveTab();
            if (tab) {
                tab.scroller.onResize();
                tab.scroller.scrollToBottom();
            }
        }
    }
});

/**
 * Панель свернутого чата
 */
Ext.define('ExGods.view.chat.ChatOffPanel', {
    extend: Ext.panel.Panel,
    alias: 'widget.chatoffpanel',
    height: 56,
    padding: '0 32 0 32',
    layout: {
        type: 'hbox',
        align: 'middle',
        pack: 'center'
    },
    initComponent: function() {
        var me = this;
        me.btn = Ext.widget('textbutton', {
            width: 175,
            cls: 'double_text_btn',
            text: '<div class="text-btn-image" style="background-image: url(' + ExGods.ref('images|chat_images').image['message_btn_text'] + ')"></div>',
            listeners: {
                afterrender: function() {
                    me.resetCounter();
                }
            }
        });
        me.items = [
            me.btn
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        // кнопка "Задать вопроc"
        Ext.widget('button', {
            xtype: 'button',
            id: 'chat-question-big-btn',
            renderTo: 'chat-off-panel',
            x: 807,
            y: 7,
            floating: true,
            shadow: false,
            width: 40,
            height: 40,
            tooltip: ExGods.getMsgByKey('view_chat_container_questionchattt')
        });
    },
    // сбросить счетчик на кнопке Сообщений
    resetCounter: function() {
        var me = this;
        me.counter = 0;
        me.updateCounter();
    },
    // увеличить счетчик на кнопке Сообщений
    incCounter: function() {
        var me = this;
        me.counter++;
        me.updateCounter();
    },
    // обновить счетчик на кнопке Сообщений
    updateCounter: function() {
        var me = this,
            el;
        el = me.btn.el.down('.text-btn-image');
        el.dom.innerHTML = '<div>' + ExGods.util.Sprite.printSprite(me.counter, 'chat/counter_nums.png', {
            width: 10,
            height: 21,
            horizontal: true,
            lastZero: true
        });
    }
});

/**
 * Mixin, позволюяет объекту перетаскивать предметы
 *
 * @author Max Dvortsov
 */
Ext.define('ExGods.mixin.ItemDraggable', {
    /**
     * config - параметры конфига накатываются на параметры DragZone
     * config.view - вьюшка, к которой привязывается драг
     * config.cancelFn {Function} - метод, при отмене драга предмета или при неудачном драге
     * config.getItem {Function} (view,sourceEl) метод принимает элемент, которую двигаем и возвращает модель предмета.
     *      по дефолту возвращает модель, которую двигаем
     * config.getSourceEl {Function} (event,view) метод принимает эвент, возвращает Ext.dom.Element с которым работаем
     *      по дефолту вернет для датавью элемент по itemSelector, в противном случае view.el
     * config.getItemEl {Function} (sourceEl) метод принимает Ext.dom.Element, с которым работаем, возвращает Ext.dom.Element,
     *      который надо сделать прозрачным. По дефолту вернет себя же
     */
    initDrag: function(config) {
        config = config || {};
        var me = this,
            view = config.view || me,
            cancelFn = config.cancelFn || Ext.emptyFn;
        delete config.view;
        delete config.cancelFn;
        me.dragZone = new Ext.dd.DragZone(view.getEl(), Ext.apply({
            animRepair: false,
            ddGroup: 'all',
            getDragData: function(e) {
                var sourceEl = this.getSourceEl(e, view);
                if (sourceEl && sourceEl.dom.firstChild) {
                    var d = sourceEl.dom.firstChild.cloneNode(true),
                        d_el = Ext.fly(d),
                        item = this.getItem(view, sourceEl),
                        slot = view.slot;
                    if (!item)  {
                        return false;
                    }
                    
                    if (ExGods.app.user.isBattle())  {
                        return false;
                    }
                    
                    if (!slot) {
                        slot = ExGods.app.user.slots().getById(item.get('slot_id'));
                    }
                    d.id = Ext.id();
                    d_el.setSize(sourceEl.getSize());
                    //удаляю все что связано с квестмаркерами, т.к. переносимый элемент не должен подсвечиватья стрелкой
                    if (d_el.hasCls('qh-object')) {
                        d_el.removeCls('qh-object');
                    }
                    if (d_el.down('.qh-object')) {
                        d_el.down('.qh-object').removeCls('qh-object');
                    }
                    if (d.querySelector('.qh-pointer')) {
                        d.querySelector('.qh-pointer').remove();
                    }
                    //удаляю таймер на предмете
                    if (d.querySelector('.exg-timer')) {
                        d.querySelector('.exg-timer').remove();
                    }
                    return {
                        ddel: d,
                        item: item,
                        slot: slot,
                        itemEl: this.getItemEl(sourceEl),
                        cancel: function() {
                            sourceEl.setStyle('opacity', '');
                            cancelFn();
                        }
                    };
                }
            },
            getItem: function(view, sourceEl) {
                return view.getRecord(sourceEl);
            },
            getSourceEl: function(e, view) {
                return view.itemSelector ? Ext.get(e.getTarget(view.itemSelector)) : view.el;
            },
            getItemEl: function(sourceEl) {
                return sourceEl;
            },
            getView: function() {
                return view;
            },
            onStartDrag: function() {
                var dragData = this.dragData,
                    sourceEl = Ext.fly(dragData.itemEl),
                    quantityEl = sourceEl.down('.exg-stuff-decorator-quantity-counter');
                sourceEl.setStyle('opacity', 0.5);
                if (sourceEl.down('.qh-pointer'))  {
                    sourceEl.down('.qh-pointer').hide();
                }
                
                if (quantityEl && quantityEl.isVisible()) {
                    dragData.isCounter = true;
                    quantityEl.hide();
                }
                me.fireEvent('startdrag', dragData);
            },
            beforeInvalidDrop: function(e) {
                var dragData = this.dragData,
                    sourceEl = Ext.fly(dragData.itemEl);
                sourceEl.setStyle('opacity', '');
                if (sourceEl.down('.qh-pointer')) {
                    sourceEl.down('.qh-pointer').show();
                }
                if (dragData.isCounter) {
                    sourceEl.down('.exg-stuff-decorator-quantity-counter').show();
                }
                me.fireEvent('stopdrag', dragData);
            },
            setDelta: function(iDeltaX, iDeltaY) {
                this.deltaX = 32;
                this.deltaY = 32;
            }
        }, config));
        me.on('destroy', function() {
            me.dragZone.destroy();
            me.dragZone = null;
        }, me);
    }
});

/**
 * Mixin, позволюяет объекту перетаскивать предметы
 *
 * @author Max Dvortsov
 */
Ext.define('ExGods.mixin.ItemDroppable', {
    /**
     * config - параметры конфига накатываются на параметры DragZone
     * config.view - вьюшка, к которой привязывается драг
     */
    initDrop: function(config) {
        config = config || {};
        var me = this,
            view = config.view || me;
        delete config.view;
        me.dropZone = new Ext.dd.DropZone(view.getEl(), Ext.apply({
            ddGroup: 'all',
            getTargetFromEvent: function(e) {
                return e.getTarget();
            },
            getView: function() {
                return view;
            },
            onNodeDrop: function(target, dd, e, data) {
                var sourceEl = Ext.fly(data.itemEl),
                    counter = sourceEl.down('.exg-stuff-decorator-quantity-counter');
                if (sourceEl.down('.qh-pointer')) {
                    sourceEl.down('.qh-pointer').show();
                }
                if (counter && counter.dom.innerHTML) {
                    counter.show();
                }
                me.fireEvent('drop', target, data);
                return this.onDrop(target, dd, e, data);
            },
            onDrop: function(target, dd, e, data) {
                return true;
            }
        }, config));
        me.on('destroy', function() {
            me.dropZone.destroy();
            me.dropZone = null;
        }, me);
    }
});

/**
 * Mixin, вызывает подсветку правильных слотов при драге предметов в инвентаре
 *
 * @author Max Dvortsov
 */
Ext.define('ExGods.mixin.InventoryDragHighlight', {
    initDragHighlight: function() {
        this.on({
            startdrag: this.onStartDrag,
            stopdrag: this.onStopDrag,
            drop: this.onItemDrop,
            destroy: function() {
                this.un({
                    startdrag: this.onStartDrag,
                    stopdrag: this.onStopDrag,
                    drop: this.onItemDrop,
                    scope: this
                });
            },
            scope: this
        });
    },
    onStartDrag: function(data) {
        var proto = ExGods.app.getItemPrototypesStore().data.getByKey(data.item.get('proto_id')),
            active = data.slot ? data.slot.getSlotType().active : true,
            potion = data.slot && data.slot.get('type') == 14;
        if (data.item.get('proto_id')) {
            var type = data.item.getType().slot_on;
            ExGods.app.user.slots().each(function(slot) {
                if ((active && !slot.getSlotType().active) || (!active && slot.get('type') == type) || (potion && slot.get('type') == 14)) //конкретно для слотов под зелья, подсвечиваю их в том числе
                {
                    slot.fireEvent('highlight', slot);
                }
            });
            if (!active && proto.canPutInWareHouse()) {
                ExGods.app.getStore('WareHouse').fireEvent('highlight', data.item);
            }
        }
    },
    onStopDrag: function(data) {
        ExGods.app.user.slots().each(function(slot) {
            slot.fireEvent('unhighlight', slot);
        });
        ExGods.app.getStore('WareHouse').fireEvent('unhighlight', data.item);
        ExGods.app.getController('Item').afterDrop = true;
    },
    onItemDrop: function(target, data) {
        ExGods.app.user.slots().each(function(slot) {
            slot.fireEvent('unhighlight', slot);
        });
        ExGods.app.getStore('WareHouse').fireEvent('unhighlight', data.item);
    }
});

/**
 * Базовая модель действия
 */
Ext.define('ExGods.model.Action', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    statics: {
        // тип цели "пользователь из онлайн-листа"
        ONLINE_LIST_TARGET: 1,
        // тип цели "произвольная строка"
        STRING: 2,
        // тип цели "предмет"
        ITEM_TARGET: 3,
        // тип цели "пользователь из black-листа"
        BLACK_LIST_USER_TARGET: 4,
        // тип цели "пользователь"
        USER_TARGET: 5,
        // тип цели "из контекста"
        CONTEXT_TARGET: 6,
        // тип цели "список предметов по фильтру"
        ITEM_FILTER_TARGET: 7,
        // тип цели "список усиленных предметов"
        ITEM_UPGRADED_TARGET: 8
    },
    fields: [
        {
            // id действия
            name: 'condition_action',
            type: 'int'
        },
        {
            // id действия
            name: 'entry',
            type: 'int'
        },
        {
            name: 'confirm',
            type: 'auto'
        },
        {
            // тип действия
            name: 'type',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            // тип цели, на которую может быть направлено действие
            // 0 - ненаправленное действие; по умолчанию
            // 1 - на пользователя
            // 3 - на предмет
            name: 'target',
            type: 'int'
        },
        {
            // выбранная цель действия.
            name: 'selected_target',
            type: 'auto'
        },
        {
            // источник дейсвтия - объект, к которому привязано действие. Например, предмет
            name: 'source',
            type: 'auto'
        },
        {
            // стоимость выполнения действия в формате имущества (см ExGods.util.Stuff.printStuff)
            name: 'costs',
            type: 'auto'
        },
        {
            // параметры действия
            name: 'params',
            type: 'auto'
        },
        {
            // параметры цели
            name: 'target_params',
            type: 'auto'
        },
        {
            // сторона, из которой нужно выбрать цель для действия. Применяется только для действий в бою
            name: 'side',
            type: 'int'
        },
        {
            // нужны мертвые цели или живые
            name: 'dead',
            type: 'int'
        },
        {
            // идентификатор подсказки
            name: 'hints',
            type: 'auto'
        },
        {
            // идентификатор сервиса, который инициализирует действие.
            name: 'service_id',
            type: 'string'
        }
    ],
    /**
     * Вернет true, если действие боевое
     */
    isBattleAction: function() {
        return this.get('type') == 'battle';
    },
    isInventoryAction: function() {
        return this.get('type') == 'map.inventory';
    },
    isLocationAction: function() {
        return this.get('type') == 'map.location';
    },
    isServiceAction: function() {
        return this.get('service_id');
    },
    /**
     * Вернет true, если действие требует подтверждения
     */
    hasConfirmation: function() {
        return this.get('hints') && this.get('hints').length;
    },
    /**
     * Вернет true, если действие платное
     */
    hasCost: function() {
        return this.get('costs') && this.get('costs').length;
    },
    proxy: 'memory'
});

/**
 * "Быстрые" слоты слева
 */
Ext.define('ExGods.view.QuickSlots', {
    extend: Ext.view.View,
    alias: 'widget.quickslots',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.InventoryDragHighlight
    ],
    id: 'quick-slots',
    deferEmptyText: false,
    itemSelector: '.exg-stuff-item-quick_slot',
    ignore_focus: true,
    // чтобы экст не скроллил боди
    /**
     * @property {Ext.data.Store} store
     * Храналище быстрых слотов
     */
    initComponent: function() {
        var me = this;
        me.store = Ext.StoreMgr.lookup('quick-slots');
        me.tpl = [
            '<div class="top">',
            '<span>' + ExGods.getMsgByKey('view_quick_belt') + '</span>',
            '</div>',
            '<tpl for=".">',
            '<tpl if="item">',
            '{[ExGods.stuff.StuffManager.image(values.item)]}',
            '<tpl else>',
            '<div class="exg-stuff-item-quick_slot empty-quick-slot exgtip" data-exgtip_type="slot" data-exgtip_value="{ekey}" style="background-image: {[this.getEmptyBg(values)]}"></div>',
            '</tpl>',
            '</tpl>',
            '{[this.fillBuySlots(values)]}',
            '<div class="bottom"></div>',
            {
                getEmptyBg: function(values) {
                    if (values.protect) {
                        return 'url(' + IMAGE_URL + 'slots/new/frm.png), ' + 'url(' + ExGods.ref('slot_type|' + values.type).images.prot + ')';
                    } else {
                        return 'url(' + ExGods.ref('slot_type|' + values.type).images.empty + ')';
                    }
                },
                fillBuySlots: function() {
                    var buySlots = ExGods.app.getController('inventory.Inventory').service.data.next_buy_slot[14],
                        html = [];
                    if (buySlots) {
                        var i = buySlots.max - me.store.getCount();
                        while (i--) {
                            html.push('<div class="quick-slot-sale">', '<div data-qtip="' + ExGods.getMsgByKey('view_quickslots_buyslottt') + '" class="dummy"></div>', '</div>');
                        }
                    }
                    return html.join('');
                }
            }
        ];
        me.callParent();
        me.store.each(function(slot) {
            slot.on({
                highlight: me.highlight.bind(me, slot, true),
                unhighlight: me.highlight.bind(me, slot, false),
                scope: me
            });
        });
        me.on('refresh', function() {
            if (me.isDisabled()) {
                me.el.mask();
            }
        });
        me.getSelectionModel().preventFocus = true;
    },
    // иначе Ext скроллит body
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.initDD();
        me.el.on('click', function(e, el) {
            var service = ExGods.app.getController('inventory.Inventory').service,
                text = new Ext.XTemplate(ExGods.ref('message_client|buy_slot_confirm')).apply({
                    cost: ExGods.util.Stuff.printStuff(service.data.next_buy_slot[14].price)
                });
            Ext.widget('confirmdialog', {
                message: text,
                handler: function() {
                    ExGods.Services.get('inventory').command('buy_slot', {
                        slot_type: 14
                    });
                }
            });
        }, me, {
            delegate: '.quick-slot-sale'
        });
    },
    collectData: function(slots) {
        return Ext.Array.map(slots, function(slot) {
            data = Ext.clone(slot.data);
            var item = slot.items().data.items[0];
            if (item) {
                data.item = {
                    type: 'quick_slot',
                    params: {
                        slot: slot,
                        itemModel: item
                    }
                };
            }
            return data;
        });
    },
    highlight: function(slot, lightOn) {
        var me = this,
            node = me.getNode(slot),
            nodes = [],
            i = node.childNodes.length,
            classes, index;
        if (i) {
            while (i--) {
                if (node.childNodes[i].className.indexOf('slot-protect') != -1 || node.childNodes[i].className.indexOf('exg-stuff-img') != -1) {
                    node = node.childNodes[i];
                    break;
                }
            }
        }
        classes = node.className.split(' ');
        index = classes.indexOf('exg-highlighted');
        if (lightOn) {
            if (index == -1) {
                classes.push('exg-highlighted');
                node.className = classes.join(' ');
            }
        } else if (index != -1) {
            classes.splice(index, 1);
            node.className = classes.join(' ');
        }
    },
    /**
     * @private
     * Включает Drag&Drop
     */
    initDD: function() {
        var me = this;
        me.initDrag({
            getItem: function(view, sourceEl) {
                return view.getRecord(sourceEl).items().first();
            }
        });
        me.initDrop({
            onDrop: function(target, dd, e, data) {
                if (Ext.getClassName(data.item) != 'ExGodsCore.model.Item')  {
                    return false;
                }
                
                var type = data.item.getType().slot_on,
                    targetSlot = me.getRecord(target) || me.getRecord(target.parentNode),
                    isValid = false,
                    fn = function() {
                        ExGods.app.getController('Item').putOn(data.item, data.cancel, targetSlot);
                        return true;
                    };
                if (!targetSlot)  {
                    return false;
                }
                
                if (data.itemEl && data.itemEl.setStyle)  {
                    data.itemEl.setStyle('opacity', '');
                }
                
                me.store.each(function(slot) {
                    if (slot.get('type') == type) {
                        isValid = true;
                    }
                });
                if (!isValid)  {
                    return false;
                }
                
                var target_item = targetSlot.items().first();
                if (!target_item)  {
                    return fn();
                }
                
                var item_proto_id = data.item.get('proto_id'),
                    target_proto_id = target_item.get('proto_id'),
                    target_stack = ExGods.ref('slot_type|' + type).stack,
                    item_proto = ExGods.app.getItemPrototypesStore().data.getByKey(item_proto_id),
                    item_stack = item_proto.get('data').stack,
                    target_items_count = target_item.get('count');
                if (item_proto_id == target_proto_id && (!item_stack || !target_stack || Math.floor(target_stack / item_stack) == target_items_count)) {
                    return false;
                }
                return fn();
            }
        });
        me.initDragHighlight();
    },
    setDisabled: function(disabled) {
        var me = this;
        if (me.f_disabled !== disabled) {
            me.f_disabled = disabled;
            if (disabled) {
                me.getEl().mask();
            } else {
                me.getEl().unmask();
            }
        }
    },
    isDisabled: function() {
        return this.f_disabled;
    },
    applyMarks: function(actions, items) {
        var me = this,
            slots = [],
            time = parseInt(ExGods.ref('constants|bat_anim_pointer_speed').value) + 50;
        Ext.Array.each(actions, function(action_id) {
            me.store.each(function(slot) {
                var item = slot.get('items').getAt(0);
                if (!item)  {
                    return;
                }
                
                var proto_id = item.get('proto_id'),
                    proto = ExGods.app.getItemPrototypesStore().getById(proto_id);
                if (proto) {
                    Ext.each(proto.get('action'), function(action) {
                        if (action.value.action == action_id) {
                            slots.push(slot);
                        }
                    });
                }
            });
        });
        Ext.Array.each(items, function(item_id) {
            me.store.each(function(slot) {
                var item = slot.get('items').getAt(0);
                if (!item)  {
                    return;
                }
                
                var proto_id = item.get('proto_id'),
                    proto = ExGods.app.getItemPrototypesStore().getById(proto_id);
                if (proto && proto.get('entry') == item_id) {
                    slots.push(slot);
                }
            });
        });
        if (me.marksInterval)  {
            clearInterval(me.marksInterval);
        }
        
        if (slots.length) {
            me.marksInterval = setInterval(function() {
                if (me.isDisabled()) {
                    clearInterval(me.marksInterval);
                } else {
                    me.showPointer(slots[0]);
                }
            }, time);
        }
    },
    /**
     * Показать анимацию указателя на доступное действие
     */
    showPointer: function(slot) {
        var me = this,
            node = me.getNodeByRecord(slot),
            turn = Ext.get(node),
            container = me.up('#viewport'),
            style = [
                'left:' + (turn.getX() - container.getX() + 1) + 'px',
                'top:' + (turn.getY() - container.getY() + 1) + 'px'
            ].join(';'),
            html = [
                '<div class="finger" style="' + style + '">',
                '<div class="finger-image"></div>',
                '<div class="finger-text"></div>',
                '</div>'
            ].join(''),
            animEl = container.el.insertHtml('beforeEnd', html, true),
            img = animEl.down('.finger-image').dom,
            text = animEl.down('.finger-text').dom,
            cycles = ExGods.ref('constants|bat_anim_pointer_cycles').value,
            time_text_shown = ExGods.ref('constants|bat_anim_pointer_text_hidden').value,
            time_text_hidden = ExGods.ref('constants|bat_anim_pointer_text_shown').value,
            time = ExGods.ref('constants|bat_anim_pointer_speed').value,
            deltaOpacity = (time / (time - time_text_hidden - time_text_shown)).toFixed(2),
            startOpacity = (deltaOpacity * (time - time_text_hidden) / time).toFixed(2),
            i = maxI = 50 * cycles,
            showing = true,
            deltaX = 10,
            deltaY = 5,
            timestamp;
        animEl.on('click', function(e, el) {
            node.click();
        });
        (function() {
            //меняю текст
            text.style.opacity = startOpacity - Math.abs((i - maxI / (2)) / (maxI / (2))) * deltaOpacity;
            //меняю палец
            img.style.left = (24 + Math.abs(deltaX * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            img.style.top = (-18 - Math.abs(deltaY * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            //запускаю спрайт
            if (i % (maxI / cycles) == maxI / (2 * cycles))  {
                ExGods.helpme.shine(animEl, 'finger-sprite', 34, -62, 25);
            }
            
            if (i > 0) {
                i--;
                var curTime = new Date().getTime();
                if (!me.is_shown_pointer && !timestamp) {
                    timestamp = curTime + time / maxI * i + 100;
                }
                if (timestamp && curTime > timestamp) {
                    animEl.remove();
                    return;
                }
                setTimeout(arguments.callee, time / maxI);
            } else {
                i = maxI;
                if (me.is_shown_pointer) {
                    setTimeout(arguments.callee, time / maxI);
                } else {
                    animEl.remove();
                }
            }
        })();
    },
    getResources: function() {
        var me = this,
            images = [
                'slots/new/frm.png'
            ];
        me.store.each(function(item) {
            if (item.data.proto && item.data.proto.images) {
                for (var key in item.data.proto.images) {
                    images.push(item.data.proto.images[key]);
                }
            }
            if (item.data.item && item.data.item.proto && item.data.item.proto.images) {
                for (var key in item.data.item.proto.images) {
                    images.push(item.data.item.proto.images[key]);
                }
            }
        });
        return {
            images: images
        };
    }
});

/**
 * Кнопка главного меню
 *
 * Представляет из себя картинку с опциональным счётчиком
 */
Ext.define('ExGods.view.menu.MainMenuButton', {
    extend: Ext.button.Button,
    alias: 'widget.mainmenubutton',
    border: 0,
    cls: Ext.baseCSSPrefix + 'mainmenu-btn',
    /**
     * @cfg {Number} counter 
     * Показание счётчика кнопки
     */
    counter: 0,
    /**
     * @cfg {String} menuId Идентификатор меню, для которого предназначена кнопка
     */
    menuId: '',
    /**
     * @cfg {String} conditionMessage Если не пустое - кнопка становится неактивной и этот текст отображается поверх нее
     */
    conditionMessage: '',
    disabledByController: false,
    height: 60,
    width: 60,
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        // помечаю кнопку как отслеживаемый объект квест-хелпера с типом "menu"
        me.el.addCls('qh-object');
        me.el.set({
            'data-qh_otype': 'menu',
            'data-qh_oid': me.menuId
        });
        me.counterEl = me.btnEl.insertHtml('beforeEnd', '<div class="damaged-counter"></div>', true);
        //      me.counterEl.setStyle({
        //          backgroundImage: 'url(' + ExGods.references.get('images').get('new_icon').image.new_icon + ')'
        //      });
        me.counterEl.setVisibilityMode(Ext.Element.DISPLAY);
        me.counterEl[me.counter ? 'show' : 'hide']();
        if (me.conditionMessage) {
            me.el.addCls('x-btn-blocked');
        }
    },
    //для добавления текста в кнопку
    //me.btnEl.insertHtml('beforeEnd', '<div class="condition-text">'+ me.conditionMessage +'</div>', true);
    //для инвентаря показываю количество сломанных предметов
    //      if(me.menuId == 'inventory'){
    //          //var damaged = ExGods.app.getUser().getCriticallyDamagedEquippedItems();
    //          var damaged = me.counter;
    //          me.btnEl.insertHtml('beforeEnd', '<div class="damaged-counter" style="display:'+(damaged ? 'block' : 'none')+'">' + damaged + '</div>');
    //      }
    /**
     * Инкреминтирует счётчик на кнопке
     * @param {Number} value Значение, на которое увеличивается счётчик
     */
    addCount: function(value) {
        var me = this;
        me.counter += parseInt(value);
        if (me.menuId == 'combos-and-features')  {
            me.counterEl.setHTML('!');
        }
        else {
            me.counterEl.setHTML(me.counter);
        }
        me.counterEl[me.counter ? 'show' : 'hide']();
        if (me.menuId == 'quests')  {
            me.drawLocationCount();
        }
        
    },
    //      if(value) {
    //          me.fireEvent('addcount', me);
    //      }
    /**
     * Обнуляет и скрывает счётчик на кнопке
     */
    reset: function() {
        var me = this;
        if (me.counter) {
            me.counter = 0;
            me.counterEl.hide();
        }
    },
    drawLocationCount: function(redraw) {
        var me = this;
        if (me.menuId == 'quests') {
            if (Ext.get('LOB_QUEST_BUTTON')) {
                if (redraw) {
                    me.loctionEl = undefined;
                    delete me.loctionEl;
                }
                if (!me.loctionEl) {
                    me.loctionEl = Ext.get('LOB_QUEST_BUTTON').insertHtml('beforeEnd', '<div class="damaged-counter">' + me.counter + '</div>', true);
                    me.loctionEl.setVisibilityMode(Ext.Element.DISPLAY);
                    me.loctionEl.setStyle({
                        right: '-2px',
                        top: '-2px',
                        'z-index': 3
                    });
                } else {
                    me.loctionEl.setHTML(me.counter);
                }
            }
        }
        if (me.loctionEl && me.loctionEl.dom) {
            me.loctionEl[me.counter ? 'show' : 'hide']();
        }
    }
});

/**
 * Главное меню
 *
 * Располагается справа.
 */
Ext.define('ExGods.view.menu.MainMenu', {
    extend: Ext.panel.Panel,
    alias: 'widget.mainmenu',
    id: 'mainmenu',
    /**
     * @property {Ext.panel.Panel} btnCnt
     * Контейнер с кнопками меню
     */
    layout: {
        type: 'vbox',
        align: 'center'
    },
    /**
     * @cfg {Object} Конфиг основного меню 
     * 
     */
    menuConfig: {},
    /**
     * @property {Ext.button.Button} toggle
     * Кнопка скрытия/показа меню
     */
    width: 70,
    bodyPadding: '0 0 0 8',
    defaultType: 'mainmenubutton',
    maskOnDisable: false,
    initComponent: function() {
        var me = this;
        me.items = me.prepareMenuButtons();
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: ExGods.getMsgByKey('menu_title'),
                cls: 'main-menu-title'
            }
        ];
        me.callParent();
    },
    /**
     * @private
     */
    prepareMenuButtons: function() {
        var me = this,
            buttons = [],
            styleSheet = [],
            menuConfig = Ext.Array.sort(me.menuConfig, function(a, b) {
                var pos1 = parseInt(a.position);
                var pos2 = parseInt(b.position);
                if (pos1 > pos2) {
                    return 1;
                } else if (pos1 < pos2) {
                    return -1;
                } else {
                    return 0;
                }
            });
        Ext.Array.each(menuConfig, function(item) {
            buttons.push({
                id: item.id_menu + '-' + item.id_element + '-button',
                menuId: item.id_element,
                //tooltip: item.label,
                disabled: item.message ? true : false,
                conditionMessage: item.message,
                menuConfig: item,
                action: item.params.id,
                href: item.type == 'link' ? item.params.advanced_param.link : undefined,
                hrefTarget: item.type == 'link' ? item.params.advanced_param.target : undefined,
                listeners: {
                    render: function(panel) {
                        this.tooltip = Ext.create('Ext.tip.ToolTip', {
                            target: panel.el,
                            anchor: Ext.getBody().getWidth() < 1400 ? 'right' : undefined,
                            anchorOffset: 20,
                            maxWidth: parseInt(ExGods.ref('constants|tooltip_max_width').value),
                            cls: 'paperdeco-tooltip',
                            plugins: [
                                'paperdeco'
                            ],
                            html: '<div class="paper-title ellipsis">' + item.label + '</div>' + '<div class="tooltip-paper-body">' + item.description + '</div>'
                        });
                    }
                }
            });
            styleSheet.push([
                '#' + item.id_menu + '-' + item.id_element + '-button {',
                'background-image: url(' + IMAGE_URL + item.images.image + ');',
                'background-position:' + item.images.offset + 'px 0;',
                '}',
                '#' + item.id_menu + '-' + item.id_element + '-button.x-btn-over {',
                'background-position:' + item.images.offset + 'px -60px;',
                '}',
                '#' + item.id_menu + '-' + item.id_element + '-button.x-btn-pressed {',
                'background-position:' + item.images.offset + 'px -120px;',
                '}',
                '#' + item.id_menu + '-' + item.id_element + '-button.x-btn-disabled {',
                'background-position:' + item.images.offset + 'px -180px;',
                'cursor: default;',
                '}',
                '#' + item.id_menu + '-' + item.id_element + '-button.x-btn-blocked {',
                'background-position:' + item.images.offset + 'px -240px;',
                'cursor: default;',
                '}'
            ].join(''));
        });
        Ext.util.CSS.createStyleSheet(styleSheet.join(''));
        return buttons;
    },
    /**
     * Отключает (и скрывает) главное меню
     * @param {Array} exceptItems Список id эементов меню, которые отключать не нужно
     */
    disableMenu: function(exceptItems) {
        var me = this;
        exceptItems = exceptItems || [];
        me.items.each(function(item) {
            if (Ext.Array.indexOf(exceptItems, item.menuConfig.id_element) == -1) {
                item.disable();
            } else {
                item.enable();
            }
        });
    },
    /**
     * Включает главное меню
     */
    enableMenu: function() {
        var me = this;
        me.items.each(function(item) {
            if (!item.disabledByController)  {
                item.enable();
            }
            
        });
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            images = [];
        Ext.Array.each(me.menuConfig, function(item) {
            if (item.images.image && Ext.Array.indexOf(images, item.images.image) === -1) {
                images.push(item.images.image);
            }
        });
        return {
            images: images
        };
    },
    updateMenu: function(menuConfig) {
        var me = this;
        me.menuConfig = menuConfig;
        me.removeAll();
        me.add(me.prepareMenuButtons());
    }
});

/**
 * Верхнее системное меню
 */
Ext.define('ExGods.view.menu.SystemMenu', {
    extend: Ext.toolbar.Toolbar,
    alias: 'widget.systemmenu',
    padding: 0,
    /**
     * @cfg {Object} menuConfig Конфиг меню
     */
    menuConfig: {},
    initComponent: function() {
        var me = this,
            items = [],
            styleSheet = [],
            menuConfig = Ext.Array.sort(me.menuConfig, function(a, b) {
                var pos1 = parseInt(a.position);
                var pos2 = parseInt(b.position);
                if (pos1 > pos2) {
                    return 1;
                } else if (pos1 < pos2) {
                    return -1;
                } else {
                    return 0;
                }
            });
        me.layout = {
            pack: 'start'
        };
        me.defaults = {
            height: 30,
            padding: 0
        };
        Ext.Array.each(menuConfig, function(item) {
            var itemId = Ext.id(),
                action = ExGods.ClientActions.factory({
                    actionId: item.params.id,
                    src: 'menu'
                });
            items.push({
                id: itemId,
                href: action.href,
                hrefTarget: action.hrefTarget,
                disabled: item.message ? true : false,
                action: action,
                text: !item.images.image ? item.label : undefined,
                width: item.images.width
            });
            if (item.images.image) {
                styleSheet.push([
                    '#' + itemId + ' {',
                    'background-image: url(' + IMAGE_URL + item.images.image + ');',
                    'background-position:' + item.images.offset + 'px 0;',
                    '}',
                    '#' + itemId + ':hover {',
                    'background-position:' + item.images.offset + 'px -30px;',
                    '}',
                    '#' + itemId + '.x-btn-pressed {',
                    'background-position:' + item.images.offset + 'px -60px;',
                    '}',
                    '#' + itemId + '.x-btn-disabled {',
                    'background-position:' + item.images.offset + 'px -90px;',
                    '}'
                ].join(''));
            }
        });
        Ext.util.CSS.createStyleSheet(styleSheet.join(''));
        me.items = items;
        me.callParent();
    },
    getResources: function() {
        var me = this,
            images = [];
        Ext.Array.each(me.menuConfig, function(item) {
            if (item.images.image && Ext.Array.indexOf(images, item.images.image) === -1) {
                images.push(item.images.image);
            }
        });
        return {
            images: images
        };
    }
});

/**
 * Кнопка в меню инструментов
 */
Ext.define('ExGods.view.menu.ToolsMenuButton', {
    extend: Ext.button.Button,
    alias: 'widget.toolsmenubutton',
    /**
     * @cfg buttonData {Object} Данные кнопки из справочника
     */
    initComponent: function() {
        var me = this,
            styleSheet = [];
        var itemId = Ext.id();
        Ext.apply(me, {
            id: itemId,
            cls: "qh-object " + me.buttonData.id_element + '-button ' + me.id_cls_uniq ? me.id_cls_uniq : '',
            action: me.buttonData.id_element,
            text: !me.buttonData.images.image ? me.buttonData.label : undefined,
            width: me.buttonData.images.width,
            tooltip: me.buttonData.label || '',
            listeners: {
                afterrender: function(btn) {
                    var el = btn.getEl();
                    el.dom.setAttribute("data-qh_otype", "tools_menu_" + me.buttonData.id_element + '_button');
                    el.dom.setAttribute("data-qh_oid", "1");
                }
            }
        });
        if (me.buttonData.images.image) {
            styleSheet.push([
                '#' + itemId + ' {',
                'background-image: url(' + IMAGE_URL + me.buttonData.images.image + ');',
                'background-position:' + me.buttonData.images.offset + 'px 0;',
                '}',
                '#' + itemId + ':hover {',
                'background-position:' + me.buttonData.images.offset + 'px -30px;',
                '}',
                '#' + itemId + '.x-btn-pressed {',
                'background-position:' + me.buttonData.images.offset + 'px -60px;',
                '}',
                '#' + itemId + '.x-btn-disabled {',
                'background-position:' + me.buttonData.images.offset + 'px -90px;',
                '}',
                '#' + itemId + '.state2 {',
                'background-image: url(' + IMAGE_URL + me.buttonData.images.image + ');',
                'background-position:' + me.buttonData.images.offset + 'px -120px;',
                '}',
                '#' + itemId + '.state2:hover {',
                'background-position:' + me.buttonData.images.offset + 'px -150px;',
                '}',
                '#' + itemId + '.state2.x-btn-pressed {',
                'background-position:' + me.buttonData.images.offset + 'px -180px;',
                '}',
                '#' + itemId + '.state2.x-btn-disabled {',
                'background-position:' + me.buttonData.images.offset + 'px -210px;',
                '}'
            ].join(''));
        }
        Ext.util.CSS.createStyleSheet(styleSheet.join(''));
        me.callParent(arguments);
    },
    getResources: function() {
        me = this;
        return {
            images: [
                IMAGE_URL + me.buttonData.images.image
            ]
        };
    }
});

/**
 * Кнопка в меню инструментов в виде выпадающего списка
 */
Ext.define('ExGods.view.menu.ToolsMenuLangSelector', {
    extend: Ext.button.Button,
    alias: 'widget.toolsmenulangselect',
    id: 'tools_menu_lang_select',
    defaultValue: 'ru',
    langs: [
        'ru',
        'en'
    ],
    cls: 'tools-menu-lang-select',
    width: 82,
    height: 30,
    action: 'lang_select',
    initComponent: function() {
        var me = this,
            menu = [];
        me.lang = me.defaultValue;
        me.addCls(me.lang);
        // например, ".ru" или ".en"
        // формирую выпадающий список, как меню кнопки
        me.menu = {
            cls: 'tools-menu-lang-select-dropdown-list',
            items: [],
            padding: '6 0 6 0',
            shadow: false
        };
        me.langs.forEach(function(lang) {
            me.menu.items.push({
                cls: lang,
                lang: lang,
                height: 16,
                width: 85,
                margin: '0 0 3 0',
                listeners: {
                    click: me.onLangButtonClick,
                    scope: me
                }
            });
        });
        me.callParent(arguments);
    },
    /**
     * Утсановить значение языка
     */
    setLang: function(lang) {
        var me = this;
        me.removeCls(me.lang);
        me.lang = lang;
        me.addCls(me.lang);
    },
    /**
     * Вернет значение текущего языка
     */
    getLang: function() {
        return this.lang;
    },
    /********************  PRIVATES **************************/
    onLangButtonClick: function(btn) {
        var me = this;
        if (btn.lang != me.lang) {
            me.setLang(btn.lang);
            me.fireEvent('langselect', me.lang);
        }
    }
});

/**
 * Меню разных утилиток (звук, на весь экран и т.д.)
 */
Ext.define('ExGods.view.menu.ToolsMenu', {
    extend: Ext.toolbar.Toolbar,
    alias: 'widget.toolsmenu',
    layout: {
        type: 'hbox',
        pack: 'center'
    },
    /**
     * @cfg {Array} menuConfig Конфиг меню
     */
    menuConfig: [],
    width: 230,
    height: 48,
    initComponent: function() {
        var me = this,
            items = [],
            styleSheet = [],
            menuConfig = Ext.Array.sort(me.menuConfig || [], function(a, b) {
                var pos1 = parseInt(a.position);
                var pos2 = parseInt(b.position);
                if (pos1 > pos2) {
                    return 1;
                } else if (pos1 < pos2) {
                    return -1;
                } else {
                    return 0;
                }
            });
        me.defaults = {
            height: 30,
            padding: 0
        };
        Ext.Array.each(menuConfig, function(item) {
            if (!item.message) {
                // наличие message означает, что пункт меню недоступен по кондишену
                if (item.id_element == 'lang_select') {
                    items.push({
                        xtype: 'toolsmenulangselect',
                        buttonData: item
                    });
                } else if (item.id_element == 'fullscreen' && (Ext.browser.is.IE11 || Ext.browser.is.Safari)) {
                    items.push({
                        xtype: 'toolsmenubutton',
                        buttonData: item,
                        id_cls_uniq: 'fullScrBtn',
                        listeners: {
                            afterrender: function() {
                                var dom_ = Ext.query(".fullScrBtn")[0];
                                dom_.addEventListener("click", function() {
                                    ExGods.app.getController('Viewport').doFullscreen();
                                }, false);
                            }
                        }
                    });
                } else {
                    items.push({
                        xtype: 'toolsmenubutton',
                        buttonData: item
                    });
                }
            }
        });
        me.items = items;
        me.callParent();
    },
    getResources: function() {
        var me = this,
            images = [];
        Ext.Array.each(me.menuConfig, function(item) {
            if (item.images.image && Ext.Array.indexOf(images, item.images.image) === -1) {
                images.push(item.images.image);
            }
        });
        for (var i = 0; i < me.menuConfig.length; i++) {
            if (me.menuConfig[i].id_element == "lang_select") {
                images.push(IMAGE_URL + 'top-menu/top_menu_language_btn.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_bg_top.png');
                images.push(IMAGE_URL + 'top_menu_language_bg_bottom.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_ru.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_en.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_bg.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_bg_hover.png');
            }
        }
        return {
            images: images
        };
    }
});

/**
 * Экран приложения
 */
Ext.define('ExGods.view.Viewport', {
    extend: Ext.container.Container,
    id: 'viewport',
    isViewport: true,
    layout: {
        type: 'border',
        regionWeights: {
            west: 20,
            east: 10,
            north: 30,
            south: -20
        }
    },
    renderTo: 'viewport-wrapper',
    initComponent: function() {
        var me = this;
        Ext.applyIf(me, {
            width: 1000,
            height: 555
        });
        // иначе не работает расчет высоты лейаутом
        me.items = [
            {
                // Верхняя часть
                xtype: 'container',
                id: 'header',
                height: 95,
                layout: {
                    type: 'border',
                    regionWeights: {
                        west: 20,
                        east: 10,
                        north: -10,
                        south: -20
                    }
                },
                region: 'north',
                items: [
                    {
                        region: 'north',
                        layout: 'absolute',
                        style: {
                            'z-index': 1
                        },
                        height: 60,
                        items: [
                            {
                                xtype: 'container',
                                layout: {
                                    type: 'hbox',
                                    pack: 'center'
                                },
                                items: [
                                    {
                                        xtype: 'toolsmenu',
                                        id: 'tools-menu',
                                        menuConfig: config.menu.tools
                                    }
                                ],
                                style: {
                                    top: '15px'
                                }
                            },
                            {
                                xtype: 'systemmenu',
                                id: 'system-menu',
                                menuConfig: config.menu.system,
                                width: '100%'
                            }
                        ]
                    },
                    {
                        xtype: 'container',
                        id: 'tech-info-container',
                        layout: 'fit',
                        region: 'west',
                        width: 285
                    },
                    {
                        xtype: 'container',
                        id: 'header-right',
                        cls: 'header-right-container',
                        region: 'east',
                        width: 285
                    },
                    {
                        xtype: 'container',
                        id: 'header-center',
                        layout: 'card',
                        region: 'center',
                        margin: '-37 0 0 0'
                    }
                ]
            },
            {
                // Левый блок
                xtype: 'quickslots',
                region: 'west',
                width: 70
            },
            {
                xtype: 'container',
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                region: 'center',
                items: [
                    {
                        // Основное окно игры
                        xtype: 'container',
                        id: 'center',
                        height: 430,
                        layout: 'fit',
                        region: 'center'
                    },
                    {
                        // низ отдан чату
                        xtype: 'chatcontainer',
                        id: 'chat-container',
                        hidden: !ExGods.app.user.isChatOn()
                    },
                    {
                        xtype: 'chatoffpanel',
                        id: 'chat-off-panel',
                        hidden: ExGods.app.user.isChatOn(),
                        height: 56
                    },
                    {
                        xtype: 'announcmentsview'
                    }
                ]
            },
            {
                xtype: 'mainmenu',
                menuConfig: config.menu.mainmenu,
                region: 'east'
            }
        ];
        me.callParent();
    }
});

/**
 * Модель предмета в магазине
 */
Ext.define('ExGods.model.ShopItem', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'count',
            type: 'int'
        },
        {
            name: 'order',
            type: 'int',
            convert: function(v, r) {
                return v || 0;
            }
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'item',
            type: 'auto'
        },
        {
            name: 'params',
            type: 'auto'
        },
        {
            name: 'new_price',
            type: 'auto',
            defaultValue: ''
        },
        {
            name: 'price',
            type: 'auto',
            convert: function(v, rec) {
                if (!v || !v.length) {
                    var proto_id = rec.get('item') ? parseInt(rec.get('item').item) : parseInt(rec.get('kit')),
                        proto = ExGods.app.getItemPrototypesStore().data.getByKey(proto_id) || ExGods.ref('kit_proto').getByKey(proto_id),
                        name, price;
                    if (!proto.get) {
                        name = proto.params.price[0].name;
                        price = proto.params.price[0].value;
                    } else {
                        name = references.get('constants').get('currency').value;
                        price = proto.get('data').price;
                    }
                    return {
                        name: name,
                        value: price
                    };
                }
                return v;
            }
        },
        {
            name: 'shop_id',
            type: 'int'
        },
        {
            name: 'start_count',
            type: 'int'
        },
        {
            // счётчик для корзины
            name: 'basket_count',
            type: 'int'
        },
        {
            // сообщение о недоступности
            name: 'message',
            type: 'string'
        },
        {
            name: 'kit',
            type: 'int'
        },
        {
            name: 'item_proto',
            type: 'auto',
            convert: function(v, rec) {
                var proto;
                if (rec.get('item') && rec.get('item').item) {
                    proto = ExGods.app.getItemPrototypesStore().data.getByKey(parseInt(rec.get('item').item));
                }
                if (rec.get('kit')) {
                    proto = Ext.clone(ExGods.ref('kit_proto').getByKey(parseInt(rec.get('kit'))));
                    // доформировываю до прототипа предмета
                    proto.data = {
                        data: {
                            strict: {
                                level: proto.params.level
                            },
                            stats: {
                                item_grade: '1'
                            }
                        },
                        images: {
                            info: IMAGE_URL + proto.params.image
                        },
                        title: proto.label
                    };
                }
                return proto;
            }
        }
    ],
    getLevel: function() {
        return parseInt(this.data.item_proto.data.data.strict.level);
    },
    getTitle: function() {
        return this.data.item_proto.data.title;
    },
    getImage: function() {
        return this.data.item_proto.data.images.info;
    },
    getGrade: function() {
        return parseInt(this.data.item_proto.data.data.item_grade || 1);
    }
});

/**
 * Хранилище групп гильдии
 */
Ext.define('ExGods.store.ShopItems', {
    extend: Ext.data.Store,
    model: 'ExGods.model.ShopItem',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'order',
            direction: 'DESC'
        },
        {
            sorterFn: function(o1, o2) {
                var level1 = o1.getLevel(),
                    level2 = o2.getLevel();
                if (level1 === level2) {
                    var grade1 = o1.getGrade(),
                        grade2 = o2.getGrade();
                    if (grade1 === grade2) {
                        var title1 = o1.getTitle(),
                            title2 = o2.getTitle();
                        if (title1 === title2)  {
                            return 0;
                        }
                        
                        return title1 < title2 ? 1 : -1;
                    }
                    return grade1 < grade2 ? 1 : -1;
                }
                return level1 < level2 ? 1 : -1;
            }
        }
    ]
});

/**
 * Модель магазина
 */
Ext.define('ExGods.model.Shop', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'blob',
            type: 'auto'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'type',
            type: 'int'
        },
        {
            // предметы в магазине
            name: 'items',
            type: 'auto',
            convert: function(itemsData, record) {
                var data = [];
                if (itemsData) {
                    data = data.concat(itemsData);
                }
                if (record.data.kits) {
                    data = data.concat(record.data.kits);
                }
                record.itemsStore.loadRawData(data);
                return record.itemsStore;
            }
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            // наборы предметов в магазине
            name: 'kits',
            type: 'auto'
        }
    ],
    proxy: 'memory',
    statics: {
        getMissedProtos: function(data) {
            var me = this,
                protos = ExGods.app.getItemPrototypesStore(),
                missedProtos = [],
                protoId, kitProto;
            if (data.items && data.items.length) {
                data.items.forEach(function(item) {
                    var protoId = parseInt(item.item.item);
                    if (!protos.data.getByKey(protoId)) {
                        missedProtos.push(protoId);
                    }
                });
            }
            if (data.kits && data.kits.length) {
                data.kits.forEach(function(item) {
                    var kitProto = ExGods.ref('kit_proto').getByKey(parseInt(item.entry));
                    for (var k = 0; k < kitProto.params.items.length; k++) {
                        var protoId = parseInt(kitProto.params.items[k].item);
                        if (!protos.data.getByKey(protoId)) {
                            missedProtos.push(protoId);
                        }
                    }
                });
            }
            return missedProtos;
        }
    },
    constructor: function(config) {
        this.itemsStore = Ext.create('ExGods.store.ShopItems');
        this.callParent(arguments);
    },
    items: function() {
        return this.itemsStore;
    },
    getIcons: function() {
        return this.get('blob').images;
    },
    getIcon: function(type) {
        return this.getIcons()[type];
    },
    /**
     * Вернет идентификаторы прототипов предметов, которые еще не подгружены
     */
    getMissedProtos: function() {
        var me = this;
        return ExGods.model.Shop.getMissedProtos(me.raw);
    }
});

/**
 * Базовый контроллер, от которого наследуются почти все остальные.
 * В нём собраны общие методы.
 */
Ext.define('ExGods.controller.Base', {
    extend: ExGodsCore.controller.Base
});
// some functions here

/**
 * Общий вид игрового модального (не всегда) окна с оформлением
 */
Ext.define('ExGods.view.CommonWindow', {
    extend: Ext.window.Window,
    alias: 'widget.commonwindow',
    bodyPadding: 10,
    draggable: false,
    modal: true,
    plugins: [
        'skinpaperdeco'
    ],
    resizable: false,
    initComponent: function() {
        var me = this,
            i = 0,
            button;
        if (Ext.isObject(me.buttons)) {
            var buttons = me.buttons.items;
            for (; i < buttons.length; i++) {
                button = buttons[i];
                button.margin = '0 10';
            }
        }
        me.callParent();
    },
    /**
     * Показать маску на компоненте
     */
    mask: function() {
        var me = this;
        if (me.rendered) {
            ExGods.util.Helper.maskElement(me.body);
        }
    },
    /**
     * Убрать маску с компонента
     */
    unmask: function() {
        var me = this;
        if (me.rendered) {
            me.body.unmask();
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: []
        };
    }
});

/**
 * Текстовая кнопка
 */
// Notes: Чтобы кнопку сделать красной нужно определить класс кнопки как cls: 'x-btn-txt-red'
Ext.define('ExGods.view.TextButton', {
    extend: Ext.button.Button,
    alias: 'widget.textbutton',
    config: {
        border: 0,
        minWidth: 100,
        ui: 'txt'
    },
    /**
     * Добавляем прозрачный div поверх кнопки, потому что иногда не срабатывал клик
     * потому, что mousedown происходил по одному элементу (div или text), а mouseup происходил на другом элементе
     * и поэтому не срабатывал mouseclick.
     *
     */
    hoverDiv: '<div style="height: 100%; width: 100%; background-color: black; opacity: 0; position: absolute; top:0; left: 0px;"></div>',
    initComponent: function() {
        var me = this;
        if (me.config.text.length && me.config.text.substr(0, 4) == 'img:') {
            me.textImage = (me.config.text.substr(4, 4) == 'http' ? '' : IMAGE_URL) + me.config.text.substr(4);
            me.config.text = '<div class="text-btn-image" style="background-image:url(' + me.textImage + ')"></div>';
        }
        me.text = me.hoverDiv + me.config.text;
        this.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        if (me.qh)  {
            me.el.set(me.qh);
        }
        
        me.callParent();
    },
    setText: function(text) {
        if (text.length && text.substr(0, 4) == 'img:') {
            text = (text.substr(0, 4) == 'http' ? '' : IMAGE_URL) + text.substr(4);
            text = '<div class="text-btn-image" style="background-image:url(' + text + ')"></div>';
        }
        this.callParent([
            this.hoverDiv + text
        ]);
    },
    getResources: function() {
        var me = this;
        if (me.textImage) {
            return {
                images: [
                    me.textImage
                ]
            };
        }
    }
});

/**
 * Общий контроллер ошибок.
 *
 * Перехватывает ошибки всех AJAX запросов.
 */
Ext.define('ExGods.controller.Error', {
    extend: ExGods.controller.Base,
    views: [
        'CommonWindow',
        'TextButton'
    ],
    refs: [
        {
            /**
             * @method getErrorWindow
             * Окно с ошибкой
             */
            ref: 'errorWindow',
            selector: '#ajax-fail-error'
        },
        {
            /**
             * @method getReportErrorWin
             * Возвращает окно для отправки сообщения об ошибке
             * @return {ExGods.view.ErrorReport}
             */
            ref: 'reportErrorWin',
            selector: '#report-error-window'
        }
    ],
    init: function() {
        var me = this;
        ExGodsCore.AjaxRequest.on({
            requestexception: me.onRequestException,
            jsondecodeerror: me.onDecodeError,
            scope: me
        });
        me.control({
            'errorreport #submit': {
                click: me.onReportErrorSubmit
            },
            'errorreport #reset': {
                click: me.onReportErrorReset
            }
        });
    },
    onLaunch: function() {
        ExGods.Components.addComponentInitializer('error_report', this.initErrorReportComponent, this);
    },
    onRequestException: function(conn, response, options) {
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@error request exception. response: ' + response.status + ' ' + response.statusText);
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@error request exception. response: ' + response.status + ' ' + response.statusText);
        if (response.status !== 0) {
            this.onFailure(response, options);
        }
    },
    /**
     * Обрабатывает HTTP-ошибки AJAX-запросов
     */
    onFailure: function(response, options) {
        var me = this,
            timeNow = new Date(),
            getErrorAutoRequestMessage = function(time, response) {
                var tpl = [
                        '<div>{time}</div>',
                        '<div>url: <b>{url}</b></div>',
                        '<div>status: {status}</div>',
                        '<div>text: {statusText}</div>',
                        '<div>params: {params}</div>',
                        '<div>bindings: {bindings}</div>',
                        '<div>agent: {agent}</div>',
                        '<div>cookie: {cookie}</div>'
                    ];
                var data = {
                        time: Ext.Date.format(time, 'Y:m:d H:i:s'),
                        url: response.request.options.url,
                        status: response.status,
                        statusText: response.statusText,
                        params: (function() {
                            var params = response.request.options.params || {},
                                paramsArr = [];
                            Ext.Object.each(params, function(key) {
                                paramsArr.push(key + '=' + params[key]);
                            });
                            return paramsArr.join(', ');
                        }()),
                        bindings: (function() {
                            var str = '',
                                bindings = ExGods.app.user.get('binding');
                            Ext.Object.each(bindings, function(key) {
                                str += key + ':' + bindings[key] + ' ';
                            });
                            return str;
                        }()),
                        cookie: (function() {
                            var cookie = document.cookie.split(';'),
                                str = '';
                            if (cookie.length) {
                                str = cookie[0];
                                for (var i = 1; i < cookie.length; i++) {
                                    str += '<br/><span style="padding: 0 0 0 38px;">' + cookie[i] + '</span>';
                                }
                            }
                            return str;
                        }()),
                        agent: navigator.userAgent
                    };
                return (new Ext.XTemplate(tpl)).apply(data);
            };
        if (/^\/online_list/.test(options.url)) {
            return;
        }
        // если обращение на /online_list - игнорируем ошибку
        switch (response.status) {
            // если разлогинило
            case 401:
                if (isSocialApp) {
                    window.location.href = '/logout-social.html';
                } else {
                    window.location = '/';
                };
                break;
            // если сервера остановлены
            case 503:
                if (isSocialApp) {
                    window.location = '/stopofwork-vka.html';
                } else {
                    location.reload();
                };
                break;
            // в остальных случаях
            default:
                if (response.request && response.request.options && /cmd=bugs&autorequest=1/.test(response.request.options.url)) {
                    return;
                };
                // не показываю окно, если ошибка возникла на автозапрос об ошибке
                var win = me.getErrorWindow();
                if (win) {
                    win.close();
                };
                Ext.widget('commonwindow', {
                    id: 'ajax-fail-error',
                    html: Ext.String.format(ExGods.getMsgByKey('server_error_alert_text'), response.status, options.url) + '<br />' + response.statusText,
                    autoShow: true,
                    plugins: [
                        'windeco'
                    ],
                    buttonAlign: 'center',
                    buttons: [
                        {
                            xtype: 'textbutton',
                            handler: function(button) {
                                // отправляю запрос об ошибке на клиенте
                                if (response.request && response.request.options && !/cmd=bugs&autorequest=1/.test(response.request.options.url)) {
                                    Ext.Ajax.request({
                                        url: 'game.pl?cmd=bugs&autorequest=1',
                                        params: {
                                            type: 6,
                                            subject: 'Ошибка запроса',
                                            message: getErrorAutoRequestMessage(timeNow, response)
                                        }
                                    });
                                }
                                button.up('commonwindow').close();
                            },
                            text: ExGods.getMsgByKey('close_btn_text')
                        }
                    ]
                });
                ExGods.app.unblock();
                break;
        }
    },
    /**
     * Обрабатывает ошибку в случае, если не пришёл json-ответ
     */
    onDecodeError: function(response, args) {
        Ext.log('onDecodeError');
        if (args.url.indexOf('ping') != -1) {
            window.location = '/main.pl';
        }
    },
    initErrorReportComponent: function(config) {
        var me = this,
            errRep = Ext.widget('errorreport', {
                config: config
            }),
            wnd;
        errRep.on('success_report', function(type) {
            html = type == '2' ? ExGods.getMsgByKey('error_report_success_text') : ExGods.getMsgByKey('error_report_success_complain_text');
            errRep.removeAll();
            errRep.add({
                xtype: 'component',
                padding: '12 18',
                html: html
            });
            errRep.addDocked({
                dock: 'bottom',
                xtype: 'toolbar',
                layout: {
                    pack: 'center'
                },
                margin: '0 0 12',
                items: [
                    {
                        xtype: 'textbutton',
                        dock: 'bottom',
                        cls: 'no_border',
                        width: 120,
                        margin: '0 5',
                        text: ExGods.getMsgByKey('close_btn_text'),
                        handler: function() {
                            wnd.close();
                        }
                    }
                ]
            });
        });
        wnd = Ext.widget('window2', {
            id: 'ERROR_REPORT',
            items: [
                errRep
            ],
            autoShow: false
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
        });
        return wnd;
    },
    onReportErrorSubmit: function(button) {
        var me = this,
            app = me.application,
            form = button.up('form');
        if (form.isValid()) {
            app.block();
            html2canvas(document.getElementById('viewport-wrapper'), {
                //logging:true,
                useCORS: true
            }).then(function(canvas) {
                var screenshot = canvas.toDataURL('image/jpeg', 0.5).replace(/data:image\/jpeg;base64,/, '');
                form.submit({
                    params: {
                        screenshot: screenshot
                    },
                    success: function(form, action) {
                        var json = action.result;
                        app.unblock();
                        button.up('errorreport').fireEvent('success_report', form.getValues().type);
                    },
                    failure: function(form, action) {
                        var json = action.result;
                        app.unblock();
                    }
                });
            });
        }
    },
    /**
     * Очищает форму ошибок
     */
    onReportErrorReset: function(button) {
        button.up('form').down('textareafield').setValue('');
    }
});

/**
 * Базовый класс сервиса
 */
Ext.define('ExGods.service.Base', {
    mixins: {
        observable: Ext.util.Observable,
        loggable: ExGodsCore.util.Loggable,
        ajaxable: ExGodsCore.util.Ajaxable
    },
    logConfig: {
        enabled: {
            info: false,
            error: true,
            warn: true
        },
        prefix: 'Service:'
    },
    inheritableStatics: {
        /**
         * @property Если single, будет создан только один экземпляр сервиса
         */
        single: true,
        /**
         * @property Если true, то сервис может быть проинициализирован многократно (например,
         * каждый раз когда выполняется клиентское действие, связанное с сервисом)
         */
        multipleInit: false,
        /**
         * @property Урл инициализации
         */
        initUrl: '/game.pl?cmd=get_service_data',
        /**
         * @property Урл команд
         */
        commandsUrl: '/map.pl'
    },
    /**
     * @cfg Id сервиса
     */
    id: undefined,
    /**
     * @property Справочная инфомарция сервиса
     */
    info: undefined,
    /**
     * @property Данные сервиса
     */
    data: null,
    /**
     * @property Флаг инициализции
     */
    initialized: false,
    constructor: function(config) {
        this.mixins.observable.constructor.call(this, config);
        this.id = config.id;
        this.info = ExGods.ref('services|' + this.id);
    },
    /**
     * Инициализация сервиса
     */
    init: function(data, callback) {
        var me = this,
            callback = callback || Ext.emptyFn;
        if (me.requestingInit)  {
            return;
        }
        
        if (me.initialized && !Ext.getClass(me).multipleInit) {
            callback(me);
        } else {
            if (me.fireEvent('beforeinit', me)) {
                if (!data && Ext.getClass(me).initUrl) {
                    me.requestingInit = true;
                    me.request({
                        url: Ext.getClass(me).initUrl,
                        params: {
                            service_id: me.id
                        },
                        success: function(json) {
                            if (json.success) {
                                if (json.service) {
                                    me.data = json.service;
                                }
                                me.initialized = true;
                                me.onInit();
                                me.fireEvent('init', me);
                                callback(me);
                            } else {
                                callback({
                                    error: 'Отрицательный ответ от сервера: ' + (json.msg ? json.msg : '')
                                });
                            }
                            me.requestingInit = false;
                        }
                    });
                } else {
                    me.initialized = true;
                    me.data = data;
                    me.onInit();
                    me.fireEvent('init', me);
                    callback(me);
                }
            } else {
                callback({
                    error: 'Ошибка при инициализации сервиса'
                });
            }
        }
    },
    /**
     * @template 
     */
    onInit: function() {},
    //
    /**
     * Обновить данные сервиса
     */
    update: function(data, callback) {
        var me = this,
            oldData = me.data;
        callback = callback || Ext.emptyFn;
        if (!data) {
            me.request({
                url: Ext.getClass(me).initUrl,
                params: {
                    service_id: me.id
                },
                success: function(json) {
                    if (json.success) {
                        if (json.service) {
                            me.data = json.service;
                        }
                        me.onUpdate(me.data, oldData);
                        me.fireEvent('update', me, me.data, oldData);
                        callback(me);
                    } else {
                        callback({
                            error: 'Отрицательный ответ от сервера. ' + (json && json.msg ? json.msg : '')
                        });
                    }
                }
            });
        } else {
            me.data = data;
            me.onUpdate(me.data, oldData);
            me.fireEvent('update', me, me.data, oldData);
            callback(me);
        }
    },
    /**
     * @template
     */
    onUpdate: function(newData, oldData) {},
    //
    /**
     * Выполнить команду сервиса
     */
    command: function(cmd, params, callback, options) {
        var me = this;
        params = params || {};
        params.service_id = me.id;
        options = options || {};
        callback = callback || {};
        if (typeof callback == 'function') {
            callback = {
                callback: callback
            };
        }
        me.request({
            url: (options.url ? options.url : Ext.getClass(me).commandsUrl) + '?cmd=' + cmd,
            queue: options.queue != undefined ? options.queue : true,
            params: params,
            success: {
                beforeKeyHandlers: callback.beforeKeyHandlers,
                afterKeyHandlers: function(json) {
                    if (json.success) {
                        if (json.service) {
                            me.update(json.service);
                        }
                    }
                    if (callback.callback) {
                        callback.callback(json);
                    }
                }
            },
            failure: callback.failure
        });
    }
});

/**
 * Cервис перехода
 */
Ext.define('ExGods.service.Room', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 * Cервис ссылки
 */
Ext.define('ExGods.service.Link', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 * Cервис мирного движения
 */
Ext.define('ExGods.service.MapAction', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    },
    /**
     * @property Модель мирного движения, которое создается после инициализации сервиса
     */
    mapAction: null,
    onInit: function() {
        var me = this;
        if (me.data.map_action.length) {
            me.mapAction = Ext.create('ExGods.model.Action', me.data.map_action[0]);
            me.mapAction.set('service_id', me.id);
        }
    }
});

/**
 *  Cервис телепорта

    Команды:
        teleport

 */
Ext.define('ExGods.service.Teleport', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 * Cервис перехода
 */
Ext.define('ExGods.service.ShowComponent', {
    extend: ExGods.service.Base,
    statics: {
        single: false,
        initUrl: null
    }
});

/**
 *  Cервис умений

    Команды:
        skills_master
        skills_pause
        skills_unpause
        skills_complete
        skills_boost
        skills_boost_complete

 */
Ext.define('ExGods.service.Skills', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  Cервис заданий

    Команды:
        quests_get
        quests_finish
        quests_delete
        quests_reroll
 */
Ext.define('ExGods.service.Quests', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        commandsUrl: '/game.pl'
    }
});

/**
 *  Cервис умений
    
    Команды:
        item_on
        item_off
        item_del
        buy_slot
        protect_slot
        get_item_action
        put_from_store
        remove_from_store

 */
Ext.define('ExGods.service.Inventory', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  Cервис настроек

    Команды:
        save_setting

 */
Ext.define('ExGods.service.Settings', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        commandsUrl: '/game.pl'
    }
});

/**
 *  Cервис групп

    Команды:
        group_info
        join_group
        unjoin_group
        search_group
        kick_user_group
        change_group_creator

 */
Ext.define('ExGods.service.Group', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        commandsUrl: '/game.pl'
    }
});

/**
 *  Cервис локации

    Команды:
        banish_quest_bot
        attack_quest_bot

 */
Ext.define('ExGods.service.Location', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  Cервис спец. предложений

    Команды:
        use_special_deal

 */
Ext.define('ExGods.service.SpecialDeal', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  Cервис сообщений

    Команды:
        messages_remove
        messages_remove_list_rest
        messages_take_attach
        messages_update_state

 */
Ext.define('ExGods.service.Messages', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        commandsUrl: '/game.pl'
    },
    initialized: true,
    data: {
        messages: {
            new_count: 0,
            rest_count: 0
        }
    }
});

/**
 *  Cервис магазина

    Команды:
        shop_buy        

 */
Ext.define('ExGods.service.Shop', {
    extend: ExGods.service.Base,
    statics: {
        single: false,
        multipleInit: false
    }
});

/**
 *  Cервис комнаты трофеев

    Команды:
        fit_mask
        put_on_mask
        buy_mask
        upgrade_mask

 */
Ext.define('ExGods.service.Masks', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис арены

    Команды:
        arena_queue
        arena_unqueue
        arena_accept
        arena_refuse
        arena_revenge
        arena_buy
        arena_get_foes

 */
Ext.define('ExGods.service.Arena', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис арены2

    Команды:
        arena2_search

 */
Ext.define('ExGods.service.Arena2', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    },
    getRewardByPlace: function(place) {
        if (!this.data || !this.data.arena)  {
            return;
        }
        
        place = Number(place);
        var me = this,
            rewards = me.data.arena.reward_list,
            reward = [],
            i = rewards.length;
        while (i--) {
            if (place >= rewards[i].begin_place && place <= rewards[i].end_place) {
                reward = rewards[i].prize;
            }
        }
        return reward;
    }
});

/**
 *  Cервис грабежей

    Команды:
        robbery_start
        robbery_request
        robbery_foe(title)

 */
Ext.define('ExGods.service.Robbery', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис кошелька

    Команды:
        change_real_money_service
        email_assign
        payment_reward

 */
Ext.define('ExGods.service.Payment', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        multipleInit: true,
        commandsUrl: '/game.pl'
    }
});

/**
 *  Cервис логова

    Команды:
        lair_start
        lair_drop_timeout

 */
Ext.define('ExGods.service.Lairs', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис пустоты

    Команды: нет

 */
Ext.define('ExGods.service.Empty', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис набеганий

    Команды:
        banish_bot
        battle_bot_surging

 */
Ext.define('ExGods.service.Surging', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис кузницы

     Команды:
     make
     replay
     finish

 */
Ext.define('ExGods.service.Fucina', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        multipleInit: true
    }
});

/**
 *  Cервис рейтингов

    Команды: 
        ratings_map_action

 */
Ext.define('ExGods.service.Ratings', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис цепочек

    Команды:
    - start_chain
    - surrender_chain

 */
Ext.define('ExGods.service.BattleChains', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  Cервис сундуков

    Команды:
        chest_open
        chest_take
        chest_open_by_key
        chest_take_all
 */
Ext.define('ExGods.service.Chests', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        multipleInit: true
    }
});

/**
 *  Cервис гильдий

    Команды:
        guild_add_user
        create_guild
        search_guild
        callback_bid
        refuse_bid
        confirm_bid
        guilds_requests
        answer_request
        create_request
        leave_guild
        remove_user_from_guild
        change_description
        change_head_guild
        guild_tasks
        guild_task_pcp
        guild_groups
        guild_create_group
        guild_group_info
        guild_join_group
        guild_unjoin_group
        guild_kick_user_group
        guild_change_group_creator
        guild_raids_info
        guild_snet_notice_inactive_sent
 */
Ext.define('ExGods.service.Guilds', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        multipleInit: true
    },
    /**
     * т.к. данные иногда приходят в корне ответа вместе с посторонними ключами типа success - то удаляю лишние ключи
     */
    parseData: function(data) {
        var me = this,
            keys = [
                'bids',
                'guilds',
                'guild',
                'timed',
                'shop_service_id',
                'guild_noob'
            ];
        for (var key in data) {
            if (keys.indexOf(key) == -1)  {
                delete data[key];
            }
            
        }
        if (!data.timed)  {
            data.timed = me.data.timed;
        }
        
        if (!data.shop_service_id)  {
            data.shop_service_id = me.data.shop_service_id;
        }
        
        return data;
    }
});

/**
 *  Cервис рынка

    Команды:
        market_buy_product
        product_from_market
 */
Ext.define('ExGods.service.Market', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис петов

    Команды:
        pets_repair
        pets_on
        pets_live
        pets_off
        pets_off
        charge_trap
        open_trap
        pet_tame
        pet_tame_garanted
        pets_proto
 */
Ext.define('ExGods.service.Pets', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  Cервис команды

    Команды: нет

 */
Ext.define('ExGods.service.Command', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 * Контроллер управляет сервисами
 * 
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.Services', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Services:'
    },
    services: {},
    init: function() {
        var me = this;
        ExGods.Services = me;
        // инициализация сервисов из конфига
        Ext.each(config.services, function(data) {
            var service = me.factory(data.service_id);
            if (!service.error) {
                service.init(data.service);
            } else {
                /***/
                me.log('error', 'Ошибка инициализации сервиса: ' + service.error);
            }
        });
        // Добавляю обработчик ответа от сервера по ключу "services"
        me.addAjaxRequestKeyHandler('services', function(data) {
            me.updateGroupOfServices(data.services);
        }, me);
        me.callParent();
    },
    onLaunch: function() {
        var me = this;
        Ext.each(config.services, function(data) {
            ExGodsCore.AjaxRequest.invokeKeyHandlers(data);
        });
    },
    // обработчик возвращаемых данных
    /**
     * Вернёт экземпляр сервиса по id
     */
    factory: function(serviceId) {
        var me = this,
            info = ExGods.ref('services|' + serviceId),
            serviceClass = me.getServiceClass(serviceId);
        if (info && serviceClass) {
            if (serviceClass.single) {
                if (!me.services[info.proto['package']]) {
                    me.services[info.proto['package']] = Ext.create(serviceClass.getName(), {
                        id: serviceId
                    });
                }
                return me.services[info.proto['package']];
            } else {
                return Ext.create(serviceClass.getName(), {
                    id: serviceId
                });
            }
        } else {
            return {
                error: !info ? 'Не найдена спрвочная информация для сервиса ' + serviceId : 'Не определён класс сервиса ' + info.proto['package']
            };
        }
    },
    /**
     * Вернёт экземпляр глобального сервиса (single) по названию прототипа (package)
     */
    get: function(name) {
        var me = this,
            service = me.services[name];
        if (!service) {
            ExGods.ref('services').each(function(info) {
                if (info.proto['package'] == name) {
                    service = me.factory(info.id);
                }
            });
        }
        return service || {
            error: 'Сервис не найден'
        };
    },
    /**
     * Обновляет данные по группе сервисов
     * @param group Может быть именованой строкой для группы сервисов или непосредственно данными
     */
    updateGroupOfServices: function(group) {
        var me = this,
            _updateServices = function(services) {
                Ext.each(services, function(data) {
                    var service = me.factory(data.service_id);
                    if (!service.error) {
                        service.update(data.service);
                    } else {
                        /***/
                        me.log('error', 'Ошибка инициализации сервиса: ' + service.error);
                    }
                    ExGodsCore.AjaxRequest.invokeKeyHandlers(data);
                });
            };
        // обработчик возвращаемых данных
        if (typeof group == 'string') {
            me.request({
                url: '/game.pl',
                params: {
                    cmd: 'get_service_group_data',
                    group: group
                },
                success: function(json) {}
            });
        } else // считаем, что ответ всегда прийдёт в формате {services: ..},
        // и данные будут обработаны через обработчик возвращаемых данных
        {
            _updateServices(group);
        }
    },
    /**
     * Вернёт класс серсиса
     */
    getServiceClass: function(serviceId) {
        var me = this,
            info = ExGods.ref('services|' + serviceId),
            parts,
            name = '';
        if (info) {
            parts = info.proto['package'].split('_');
            for (var i = 0; i < parts.length; i++) {
                name += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
            }
            return ExGods.service[name];
        }
    }
});

/**
 * Контроллер слоев.
 * Слой - это обертка над Ext.Container, так что слой поддерживает все его методы и настройки
 */
(function() {
    Ext.define('ExGods.controller.Layers', {
        extend: ExGods.controller.Base,
        requires: [],
        // 
        logConfig: {
            enabled: {
                info: true,
                wrap: true,
                error: true
            },
            prefix: 'Layers:'
        },
        /**
     * @property Все слои приложения
     */
        layers: {},
        init: function() {
            var me = this;
            ExGods.Layers = me;
            me.callParent();
        },
        factory: function(config) {
            var me = this;
            if (config.type == 'single') {
                me.layers[config.id] = new SingleLayer(config);
            } else if (config.type == 'stack') {
                me.layers[config.id] = new StackLayer(config);
            } else {
                me.layers[config.id] = new BaseLayer(config);
            }
            return me.layers[config.id];
        },
        get: function(layerName) {
            return this.layers[layerName];
        }
    });
    /*  Internal Layer classes */
    var BaseLayer = Ext.define(null, {
            extend: 'Ext.Container',
            defaultStyles: {
                position: 'absolute',
                width: '100%',
                height: '100%',
                top: 0,
                left: 0
            },
            onRender: function() {
                var me = this;
                me.getEl().applyStyles(me.defaultStyles);
                me.callParent(arguments);
            },
            clear: function() {
                var me = this;
                me.items.each(function(item) {
                    if (item.close) {
                        item.close();
                    } else {
                        item.destroy();
                    }
                });
            }
        });
    var SingleLayer = Ext.define(null, {
            extend: BaseLayer,
            show: function(cmp) {
                var me = this,
                    tries = 200;
                if (me.adding)  {
                    return;
                }
                
                var interval = setInterval(function() {
                        tries--;
                        if (cmp.isVisible()) {
                            me.fireEvent('cmp_visible');
                            clearInterval(interval);
                        } else if (!tries) {
                            clearInterval(interval);
                        }
                    }, 10);
                me.callParent(arguments);
            },
            hide: function() {
                var me = this,
                    hasVisibleItems = me.hasVisibleItems();
                if (me.adding)  {
                    return;
                }
                
                if (!hasVisibleItems)  {
                    me.callParent(arguments);
                }
                
            },
            hasVisibleItems: function() {
                var me = this,
                    hasVisibleItems = false;
                me.items.each(function(item) {
                    hasVisibleItems = hasVisibleItems || item.isVisible();
                });
                return hasVisibleItems;
            },
            add: function(cmp) {
                var me = this;
                me.adding = true;
                me.clear();
                cmp = me.callParent(arguments);
                cmp.on('beforeshow', me.clear, me);
                cmp.on('show', me.show.bind(me, cmp));
                cmp.on('hide', me.hide, me);
                cmp.on('destroy', me.hide, me);
                me.adding = false;
                me.show(cmp);
            }
        });
    var StackLayer = Ext.define(null, {
            extend: BaseLayer,
            _stack: [],
            initComponent: function() {
                var me = this;
                me.callParent();
            },
            add: function(cmp) {
                var me = this;
                cmp = Ext.widget(cmp);
                if (Ext.Array.indexOf(me._stack, cmp) == -1) {
                    me._stack.push(cmp);
                }
                if (me._stack.length == 1) {
                    me._showItem(cmp);
                }
            },
            _showItem: function(cmp) {
                var me = this;
                cmp.on('destroy', me._onDestroy, me, {
                    single: true
                });
                me.superclass.add.apply(this, [
                    cmp
                ]);
                me.show();
            },
            _onDestroy: function(cmp) {
                var me = this;
                me._stack.shift();
                if (me._stack.length) {
                    me._showItem(me._stack[0]);
                } else {
                    me.hide();
                }
            }
        });
})();

/**
 * Контроллер компонентов
 *
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.Components', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            wrap: true,
            error: true
        },
        prefix: 'Components:'
    },
    initializers: {},
    init: function() {
        var me = this;
        ExGods.Components = me;
    },
    // быстрая ссылка
    factory: function(componentId, params) {
        var me = this,
            data = ExGods.ref('client_objects|' + componentId),
            cls, cmp;
        if (data) {
            params = Ext.applyIf(params || {}, data.params);
            if (me.initializers[data.xtype]) {
                cmp = me.initializers[data.xtype].fn.call(me.initializers[data.xtype].scope, params, componentId);
                if (cmp) {
                    return cmp;
                } else {
                    return {
                        error: 'Компонент ' + data.xtype + ' не создан. Что-то с инициализатором'
                    };
                }
            } else {
                cls = Ext.ClassManager.getByAlias(data.xtype);
                if (cls) {
                    return new cls(Ext.apply({
                        id: componentId
                    }, params));
                } else {
                    return {
                        error: 'Класс для компонента "' + data.xtype + '" не найден.'
                    };
                }
            }
        } else {
            return {
                error: 'Не найдена спрвочная информация по компоненту ' + componentId
            };
        }
    },
    /**
     * Создает компонент и показывает его
     */
    createAndShow: function(componentId, params) {
        var me = this,
            cmp;
        cmp = me.factory(componentId, params);
        if (cmp && !cmp.error) {
            if (!cmp.rendered) {
                cmp.show();
            }
        }
        return cmp;
    },
    /**
     * Показывает/скрывает компонент. Если компонент не создан, создастся
     */
    toggle: function(componentId, params) {
        var me = this,
            cmp = Ext.getCmp(componentId);
        if (cmp) {
            if (cmp.isVisible()) {
                cmp.hide();
            } else {
                cmp.show();
            }
        } else {
            cmp = me.factory(componentId, params);
            if (cmp && !cmp.error) {
                if (!cmp.rendered) {
                    cmp.show();
                }
            }
        }
        return cmp;
    },
    addComponentInitializer: function(type, initializer, scope) {
        var me = this;
        me.initializers[type] = {
            fn: initializer,
            scope: scope || this
        };
    }
});

/*
 * Создает и выполняет клиентские действия
 * 
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.ClientActions', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            wrap: true,
            error: true
        },
        prefix: 'ClientActions:'
    },
    init: function() {
        var me = this;
        ExGods.ClientActions = me;
    },
    /**
     * Вернёт экземпляр клиентского действия
     * @param config
     *      actionId - id клиентского действия
     *      src - источник клиенского действия, например "menu" или "chat"
     */
    factory: function(config) {
        var me = this,
            action;
        action = {
            id: config.actionId,
            src: config.src,
            options: config.options || {},
            info: ExGods.ref('client_actions|' + config.actionId),
            doAction: function(callback) {
                me.doAction(this, callback);
            }
        };
        if (action.info) {
            if (action.info.serviceId) {
                action.service = ExGods.Services.factory(action.info.serviceId);
                if (!action.service.error) {
                    // достаю внешнюю ссылку из сервиса, если есть. Она необходима при формировании компонента для действия
                    if (action.service.info.params && action.service.info.params.link) {
                        action.href = action.service.info.params.link;
                        action.hrefTarget = action.service.info.params.target;
                    }
                    return action;
                } else {
                    return {
                        error: 'Ошибка при создании сервиса для клиентского действия: ' + action.service.error
                    };
                }
            }
        } else {
            return {
                error: 'Справочная информация для клиентского действия ' + config.actionId + ' не найдена'
            };
        }
    },
    /**
     * Выполняет клиентское действие
     */
    doAction: function(action, callback) {
        var me = this,
            callback = callback || Ext.emptyFn,
            afterActionAndCallback = function(result) {
                me.afterAction(action, result);
                callback.apply(this, arguments);
            };
        if (me.beforeAction(action) !== false) {
            switch (action.service.info.proto['package']) {
                case 'room':
                    {
                        me.invokeRoomAction(action, afterActionAndCallback);
                        break;
                    };
                case 'link':
                    {
                        me.invokeLinkAction(action, afterActionAndCallback);
                        break;
                    };
                case 'map_action':
                    {
                        me.invokeMapAction(action, afterActionAndCallback);
                        break;
                    };
                case 'show_component':
                    {
                        me.invokeComponentAction(action, function(res) {
                            afterActionAndCallback(res);
                        });
                        break;
                    };
                case 'command':
                    {
                        me.invokeCommandAction(action, afterActionAndCallback);
                        break;
                    };
                default:
                    {
                        if (action.service.info.proto.need_component == 1) {
                            me.invokeComponentAction(action, function(res) {
                                afterActionAndCallback(res);
                            });
                        } else {
                            afterActionAndCallback({
                                error: 'Неизвестный тип клиентского действия'
                            });
                        }
                    };
            }
        }
    },
    /**
     * Перед выполнением действия
     * Если вернуть false действие не выполнится
     */
    beforeAction: function(action) {
        var me = this;
        if (action.src == 'location-object') {
            // достаю из объекта локации маску перехода и показываю ее
            if (action.options.locationObject.interactive.image_mask) {
                me.app.getController('Location').maskLocation(null, {
                    img: action.options.locationObject.interactive.image_mask
                });
            }
        }
    },
    /**
     * После выполнения действия
     */
    afterAction: function(action, result) {
        var me = this;
        if (!result || result.error) {
            me.app.getController('Location').unmaskLocation();
        }
    },
    /**
     * Создает и выполняет действие (синтаксический сахар над factory + doAction)
     */
    createAndInvoke: function(config, onsuccess, onerror) {
        var me = this,
            action = me.factory(config);
        if (!action.error) {
            action.doAction(function(res) {
                if (!res.error) {
                    if (onsuccess) {
                        onsuccess(res);
                    }
                } else {
                    if (onerror) {
                        onerror(res.error);
                    }
                }
            });
        } else {
            if (onerror) {
                onerror(action.error);
            }
        }
    },
    invokeRoomAction: function(action, callback) {
        var me = this,
            locationController = me.app.getController('Location');
        action.service.init(null, function(service) {
            if (!service.error) {
                callback(action);
            } else {
                callback({
                    error: service.error
                });
            }
        });
    },
    invokeLinkAction: function(action, callback) {
        var me = this;
        return;
    },
    // открытие внешней ссылки должно выполняться непосредственно компонентом, по которому жамкнули
    invokeMapAction: function(action, callback) {
        var me = this;
        action.service.init(null, function(service) {
            if (!service.error) {
                if (action.options.selected_target) {
                    service.mapAction.set('selected_target', action.options.selected_target);
                }
                me.app.getController('Action').doAction(service.mapAction, callback);
            } else {
                callback({
                    error: service.error
                });
            }
        });
    },
    invokeCommandAction: function(action, callback) {
        var me = this,
            command = action.service.info.params.command,
            cmd = command ? command.split(':')[0] : null,
            param = command ? command.split(':')[1] : null;
        switch (cmd) {
            case 'show_chat':
                if (!ExGods.app.user.isChatOn()) {
                    ExGods.app.getChatController().chatOn();
                };
                var chatTabs = Ext.getCmp('chat-tab-panel');
                if (param) {
                    chatTabs.setActiveTab(param);
                };
                break;
            default:
                callback({
                    error: 'Неизвестная команда ' + cmd
                });
                break;
        }
    },
    invokeComponentAction: function(action, callback) {
        var me = this,
            component = Ext.getCmp(action.info.componentObjectName);
        if (!component) {
            ExGods.app.block();
            action.service.init(null, function(service) {
                ExGods.app.unblock();
                if (!service.error) {
                    component = ExGods.Components.factory(action.info.componentObjectName, {
                        clientAction: action,
                        service: service
                    });
                    if (component && !component.error) {
                        if (component.autoShow !== false && !component.rendered) {
                            component.show();
                        }
                        callback(action);
                    } else {
                        callback({
                            error: component ? component.error : 'Компонент не создан.'
                        });
                    }
                } else {
                    callback({
                        error: service.error
                    });
                }
            });
        } else {
            if (action.src == 'menu' && component.isVisible()) {
                component.close();
            } else if (component.onClientAction) {
                component.onClientAction(action);
            } else {
                if (!component.isVisible()) {
                    component.show();
                }
            }
            callback(action);
        }
    }
});

/**
 * Контроллер стилей
 */
Ext.define('ExGods.controller.CSS', {
    extend: ExGods.controller.Base,
    init: function() {
        var me = this;
        me.initUserStyles();
        me.initItemsStyles();
        me.initStuffStyles();
    },
    /**
     * @private Динамические стили юзера
     *

        .exg-bgcolor-in-battle

     *
     */
    initUserStyles: function() {
        var me = this,
            constants = ExGods.ref('constants'),
            inBattleRgb = ExGods.util.Helper.hexToRgb(constants.get('bgcolor-in-battle').value),
            opacity = constants.get('bgcolor-opacity').value;
        if (inBattleRgb) {
            Ext.util.CSS.createStyleSheet([
                '.exg-bgcolor-in-battle { background: rgba(' + inBattleRgb.join(',') + ', ' + opacity + ');}'
            ].join(''));
        }
    },
    /**
     * @private Динамические стили предметов

        .item-grade-color-1
        .item-grade-color-2
        .item-grade-color-3
        .item-grade-color-4

     */
    initItemsStyles: function() {
        var me = this,
            styles = [];
        ExGods.ref('constants_list').item_grades.value.forEach(function(item, index) {
            styles.push('.item-grade-color-' + (index + 1) + '{color: ' + item + '}');
        });
        Ext.util.CSS.createStyleSheet(styles.join(''));
    },
    /**
     * @private Динамические стили имущества

        .exg-stuff-decorator-bonusstick-image
        .exg-stuff-decorator-salestick-image
        .exg-stuff-decorator-beststick-image

     */
    initStuffStyles: function() {
        var me = this,
            styles = [],
            images = ExGods.ref('images|common_text_images').image;
        styles.push('.exg-stuff-decorator-bonusstick-image {background-image: url(' + images.bonus_on_items + ')}');
        styles.push('.exg-stuff-decorator-salestick-image {background-image: url(' + images.sale + ')}');
        styles.push('.exg-stuff-decorator-beststick-image {background-image: url(' + images.best + ')}');
        Ext.util.CSS.createStyleSheet(styles.join(''));
    }
});

/**
 * Оформление типа "Кружева"
 */
Ext.define('ExGods.view.plugin.LacePaperDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.lacepaperdeco',
    init: function(cmp) {
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('lace-paper');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="lace-paper-part lace-paper-tl"></div>' + '<div class="lace-paper-part lace-paper-tm"></div>' + '<div class="lace-paper-part lace-paper-tr"></div>' + '<div class="lace-paper-part lace-paper-mr"></div>' + '<div class="lace-paper-part lace-paper-br"></div>' + '<div class="lace-paper-part lace-paper-bm"></div>' + '<div class="lace-paper-part lace-paper-bl"></div>' + '<div class="lace-paper-part lace-paper-ml"></div>' + '<div class="lace-paper-part lace-paper-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'deco/lacepaper/scroll2_top_l.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_top_m.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_top_r.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_center_r.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_bottom_l.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_bottom_m.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_bottom_r.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_center_l.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_center_m.jpg',
                IMAGE_URL + 'deco/lacepaper/bg_table_title_l.jpg',
                IMAGE_URL + 'deco/lacepaper/bg_table_title_r.jpg',
                IMAGE_URL + 'deco/lacepaper/bg_table_title_m.jpg'
            ]
        };
    }
});

/**
 * Новости под чатом
 */
Ext.define('ExGods.view.AnnouncmentsView', {
    extend: Ext.panel.Panel,
    alias: 'widget.announcmentsview',
    data: {
        label: '',
        image: '',
        link: '',
        start_date: ''
    },
    id: 'announcments-view',
    plugins: [
        {
            ptype: 'lacepaperdeco'
        }
    ],
    margin: '0 6 0 6',
    minHeight: 200,
    bodyPadding: '0 0 25 0',
    layout: 'fit',
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<tpl if="label">',
            '<h1 class="paper-title">{label}<span class="date">{[this.printDate(values.start_date)]}</span></h1>',
            '<div class="image">',
            '<img src="' + IMAGE_URL + '{image}"/>',
            '</div>',
            '<a target="_blank" href="{link}">' + ExGods.getMsgByKey('view_anons_more') + '</a>',
            '<tpl else>',
            //
            '</tpl>',
            {
                printDate: function(date) {
                    date = Ext.Date.parse(date, "Y-m-d H:i:s");
                    return Ext.Date.format(new Date(date), "d.m.Y H:i");
                }
            }
        ];
        me.callParent(arguments);
    },
    updateView: function(data) {
        var me = this,
            img,
            _update = function() {
                me.update(data);
                me.fireEvent('viewupdate', me);
            };
        if (data.image) {
            // сначала подгружаю картинку, чтобы ее размеры были известны и лейаут отработал корректно
            img = new Image();
            img.onload = _update;
            img.src = IMAGE_URL + data.image;
        } else {
            _update();
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Контроллер объявлений
 */
Ext.define('ExGods.controller.Announcments', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: true,
            error: true
        },
        prefix: 'Announcments:'
    },
    views: [
        'AnnouncmentsView'
    ],
    refs: [
        {
            ref: 'announcmentsView',
            selector: '#announcments-view'
        }
    ],
    init: function() {
        var me = this;
        me.announcments = [];
        me.current = 0;
        me.startRerollInterval();
        var chatConnection = ExGods.app.getChatConnection();
        chatConnection.addPingParam('announcements_last_time', function() {
            return me.lastTimeUpdate;
        });
        chatConnection.on({
            ping: me.onPing,
            scope: me
        });
        me.control({
            '#announcments-view': {
                afterrender: function() {
                    if (me.announcments.length) {
                        me.updateView();
                    }
                }
            }
        });
        me.callParent(arguments);
    },
    startRerollInterval: function() {
        var me = this;
        me.rerollAnnounceTimer = setInterval(function() {
            if (me.announcments.length) {
                if (me.current >= me.announcments.length - 1) {
                    me.current = 0;
                } else {
                    me.current++;
                }
                me.updateView();
            }
        }, ExGods.ref('constants|announcments_reroll_interval').value);
    },
    updateAnnouncments: function(data, lastTimeUpdate) {
        var me = this;
        me.announcments = data;
        me.lastTimeUpdate = lastTimeUpdate;
        me.current = 0;
        me.updateView();
    },
    updateView: function() {
        var me = this,
            view = me.getAnnouncmentsView(),
            data = me.announcments[me.current];
        if (view && data) {
            view.updateView(data);
        }
    },
    onPing: function(data) {
        var me = this;
        if (data.announcements) {
            me.updateAnnouncments(data.announcements, data.announcements_last_time);
        }
    }
});

/**
 * Модель арены 
 */
Ext.define('ExGods.model.Arena', {
    extend: Ext.data.Model,
    idProperty: 'id',
    fields: [
        {
            // флаг возможности выйти из очереди
            name: 'can_unqueue',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            // порядок сортировки
            name: 'l_order',
            type: 'int'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            // стоимость чтобы встать в очередь в формате имущества
            name: 'stuff_cost',
            type: 'auto'
        },
        {
            // стоимость смены противника 
            name: 'stuff_refuse',
            type: 'auto'
        },
        {
            // максимальный интервал ожидания противника в очереди
            name: 'wait_queue',
            type: 'int'
        },
        {
            // максимальный интервал ожидания начала боя
            name: 'wait_ready',
            type: 'int'
        },
        {
            // время постановки в очередь
            name: 'queue_time',
            type: 'string'
        },
        {
            // время готовности арены (противник подобран, сейчас должен начаться бой)
            name: 'ready_time',
            type: 'string'
        },
        {
            // состояние арены - wait, queue, ready, accept, start
            name: 'state',
            type: 'string',
            convert: function(v, data) {
                if (v) {
                    return v;
                } else {
                    if (data.data.queue_time) {
                        return 'queue';
                    } else if (data.data.ready_time) {
                        return 'ready';
                    } else if (data.data.accepted) {
                        return 'accept';
                    } else {
                        return 'wait';
                    }
                }
            }
        },
        {
            // данные предлагаемого соперника в формате {elo: .., rival:..}
            name: 'info',
            type: 'auto',
            defaultValue: {},
            convert: function(v, r) {
                if (v && v.rival) {
                    var arr_stuff = r.getRivalStuff(v.rival);
                    r.set({
                        'rival_stuff': arr_stuff,
                        'rival_image': r.getUserImages(v.rival)
                    });
                }
                return v;
            }
        },
        {
            name: 'message',
            type: 'string'
        },
        {
            // номер сезона арены
            name: 'season',
            type: 'int'
        },
        {
            // значение рейтинга игрока
            name: 'elo_value',
            type: 'int'
        },
        {
            // дата окончания сезона
            name: 'finish_date',
            type: 'string'
        },
        {
            // рейтинг арены
            name: 'rating_top_list',
            type: 'auto'
        },
        {
            // данные рейтинга для игрока
            name: 'rating_info',
            type: 'auto'
        },
        {
            // список врагов арены
            name: 'foes',
            type: 'auto',
            defaultValue: []
        },
        {
            // данные рейтинга для игрока
            name: 'rank_rewards',
            type: 'auto'
        },
        {
            // данные серии побед
            name: 'series',
            type: 'auto',
            convert: function(v) {
                if (!v) {
                    v = {
                        koef: 0,
                        counter: 0
                    };
                } else if (v.counter == null) {
                    v.counter = 0;
                }
                return v;
            }
        },
        {
            // данные получения наград за лигу (объект, где ключ - уровень лиги, а значение 1 или 0)
            name: 'trophy_reward',
            type: 'auto'
        },
        {
            name: 'shop_service',
            type: 'int'
        },
        {
            name: 'rival_stuff',
            type: 'auto'
        },
        {
            name: 'rival_image',
            type: 'auto'
        }
    ],
    /**
     * Получить изображение противника
     *
     * @param {Object} rival объект противника 
     * return {string} изображение
     */
    getUserImages: function(data) {
        if (typeof data.shape == 'object') {
            if (/^http/.test(data.shape.small)) {
                return [
                    data.shape.small
                ];
            } else {
                return [
                    IMAGE_URL + data.shape.small
                ];
            }
        } else {
            return [
                ExGods.ref('user_shape|' + data.shape).thumb
            ];
        }
    },
    /**
     * Получить стафф для getResources()
     *
     * @param {Object} rival объект противника 
     * return {массив} стафов
     */
    getRivalStuff: function(rival) {
        var stuff_arr = [];
        // Если противник уже найден, то подгружаем и стафф
        if (rival) {
            for (var i = 0; i < rival.slots.length; i++) {
                for (var j = 0; j < rival.slots[i].items.length; j++) {
                    var obj = rival.slots[i].items[j];
                    stuff_arr.push({
                        params: {
                            id: obj.proto_id,
                            quantity: 1
                        },
                        type: 'item'
                    });
                }
            }
            if (rival.mask_proto_id) {
                stuff_arr.push({
                    params: {
                        id: rival.mask_proto_id,
                        quantity: 1
                    },
                    type: 'item'
                });
            }
        }
        return stuff_arr;
    }
});

/**
 * Слот с предметом на арене
 */
(function() {
    Ext.define('ExGods.view.arena.ArenaSlotItems', {
        extend: Ext.panel.Panel,
        alias: 'widget.arenaslotitems',
        cls: 'arena-slots',
        /**
     * @cfg slots Данные слотов (required)
     */
        slots: null,
        initComponent: function() {
            var me = this,
                arena = Ext.getCmp(me.parent_id).arena.data;
            me.slots = arena.info.rival.slots;
            me.items = [
                {
                    xtype: 'container',
                    height: 64,
                    items: [
                        new Slot({
                            slot: me.getSlotByType(2)
                        }),
                        new Slot({
                            slot: me.getSlotByType(5)
                        }),
                        new Slot({
                            slot: me.getSlotByType(1)
                        }),
                        new Slot({
                            slot: me.getSlotByType(8),
                            cls: 'slot last'
                        })
                    ],
                    margin: '0 0 2 0'
                },
                {
                    xtype: 'container',
                    height: 74,
                    items: [
                        new Slot({
                            slot: me.getSlotByType(13)
                        }),
                        new Slot({
                            slot: me.getSlotByType(12)
                        }),
                        new Slot({
                            slot: me.getSlotByType(4)
                        }),
                        new Slot({
                            slot: me.getSlotByType(11),
                            cls: 'slot last'
                        })
                    ]
                }
            ];
            me.callParent(arguments);
        },
        getSlotByType: function(type) {
            var me = this,
                slot;
            Ext.Array.each(me.slots, function(item) {
                if (item.type == type) {
                    slot = item;
                }
            });
            return slot;
        }
    });
    var Slot = Ext.define(null, {
            extend: 'Ext.Component',
            slot: {},
            cls: 'slot',
            initComponent: function() {
                var me = this,
                    info = ExGods.ref('slot_type|' + me.slot.type);
                me.tpl = [
                    '<div class="slot-inner" style="background-image: url(' + info.images.empty + ')">',
                    '<tpl if="item">',
                    '{[ExGods.stuff.StuffManager.image(values.item)]}',
                    '</tpl>',
                    '</div>'
                ];
                me.data = {};
                if (me.slot.items.length) {
                    me.data.item = {
                        type: 'iteminstance',
                        params: {
                            itemModel: new ExGods.model.Item(me.slot.items[0])
                        }
                    };
                }
                me.callParent(arguments);
            }
        });
}());

/**
 * Отображение восстанавливаемого параметра, опционально с кнопкой нажатия textbutton
 */
(function() {
    Ext.define('ExGods.view.TimedTimer', {
        extend: Ext.Component,
        alias: 'widget.timedtimer',
        cls: 'timedtimer',
        /**
     * @cfg
     * Object
     * конфиг для текстовой кнопки
     */
        textbutton: undefined,
        /**
     * @cfg
     * Object
     * конфиг для кнопки покупки
     */
        buybutton: undefined,
        /**
     * @cfg
     * required
     * String
     * название таймеда, который брать
     */
        timed: undefined,
        /**
     * @cfg
     * Number
     * требуемое количество ресурса для активации кнопки
     */
        quantity: 1,
        /**
     * @cfg
     * Boolean
     * проверять ли юзера на наличие таймеда
     * default:true
     */
        checkUser: true,
        width: 85,
        initComponent: function() {
            var me = this,
                proto = ExGods.ref('user_timed|' + me.timed),
                timed = ExGods.app.user.get('timed')[me.timed];
            me.itemId = me.itemId || Ext.id();
            me.html = '<div class="stuff"></div>' + '<div class="stuff-timer"></div>' + '<div class="timedtimer-btn" id="timedtimer-btn-' + me.itemId + '"></div>' + '<div class="timedtimerbuy-btn" id="timedtimerbuy-btn-' + me.itemId + '"></div>' , me.stuff = [
                {
                    params: {
                        id: me.timed,
                        quantity: me.quantity
                    },
                    type: 'timed'
                }
            ];
            if (!proto || !timed) {
                console.error('Недостаточно параметров для отображения');
                me.callParent(arguments);
                return;
            }
            if (proto.price.length)  {
                me.price = proto.price;
            }
            
            me.callParent(arguments);
            me.on('afterrender', function() {
                if (me.textbutton)  {
                    me.renderBtn();
                }
                
                me._printStuff();
                me._setState();
                var user = ExGods.app.getUser();
                me.updateTimed(user.get('timed')[me.timed], true);
                ExGods.app.getUser().on(me.timed + 'changed', function() {
                    me.updateTimed.apply(me, arguments);
                });
            });
        },
        //me.updateData();
        //ExGods.util.Ticker.addListener(me.updateData, me);
        renderBtn: function() {
            var me = this;
            me.textbutton = Ext.widget('textbutton', Ext.apply({
                renderTo: 'timedtimer-btn-' + me.itemId,
                cls: 'x-btn-txt-red double_text_btn' + (me.qh ? ' qh-object' : ''),
                text: ExGods.getMsgByKey('arena_go_battle_btn_title'),
                width: (this.width - 1) + 'px',
                minWidth: (this.width - 1),
                disabled: me.is_disabled || !ExGods.app.user.checkStuff(me.stuff)
            }, me.textbutton));
            me.buybutton = Ext.widget('textbutton', Ext.apply({
                renderTo: 'timedtimerbuy-btn-' + me.itemId,
                cls: 'x-btn-txt-red double_text_btn' + (me.qh ? ' qh-object' : ''),
                text: ExGods.getMsgByKey('arena_go_battle_btn_title'),
                width: (this.width - 1) + 'px',
                minWidth: (this.width - 1),
                hidden: true,
                //disabled:!ExGods.app.user.checkStuff(me.price),
                handler: me.buyTimed.bind(me)
            }, me.buybutton));
            if (me.qh)  {
                me.textbutton.el.set(me.qh);
            }
            
        },
        buyTimed: function(btn) {
            var me = this;
            new BuyTimedConfirmationInner({
                timed: me.timed,
                onSuccess: function() {
                    me._printStuff();
                    me._setState();
                }
            });
        },
        updateTimed: function(timed, value_changed) {
            var me = this,
                time = new Date(timed[3]) - new Date() + 1000;
            //временной лаг
            if (!me.el || !me.el.dom)  {
                return;
            }
            
            var el = me.el.down('.stuff-timer');
            time = Math.max(1, time / 1000);
            if (timed[3] && timed[0] != timed[1]) {
                el.setStyle({
                    opacity: 1
                });
                el.setHTML(ExGods.util.Time.printTime(time, {
                    format: 'twonums'
                }));
            } else {
                el.setStyle({
                    opacity: 0
                });
            }
            if (value_changed) {
                me._printStuff();
                me._setState();
            }
        },
        setDisable: function() {
            this.is_disabled = true;
            this._setState();
        },
        setEnable: function() {
            this.is_disabled = false;
            this._setState();
        },
        updateQuantity: function(quantity) {
            var me = this;
            me.stuff[0].params.quantity = Number(quantity);
            me._printStuff();
            me.textbutton[ExGods.app.user.checkStuff(me.stuff) ? 'enable' : 'disable']();
        },
        onDestroy: function() {
            var me = this;
            //ExGods.util.Ticker.removeListener(me.updateData);
            me.callParent(arguments);
        },
        _printStuff: function() {
            var me = this,
                proto = ExGods.ref('user_timed|' + me.timed),
                timed = ExGods.app.user.get('timed')[me.timed],
                curTimed = Math.floor(timed[0]),
                image = IMAGE_URL + proto.img.img2,
                label = proto.img.label,
                desc = proto.img.desc;
            /**
         * timed - array
         * timed[0] - Math.floor - текущее количество
         * timed[1] - максимальное количество
         * timed[2] - скорость восстановления (не нужно на клиенте)
         * timed[3] - время до +1 (типа 1426066955)
         */
            var html = '<div class="info-box-itembox item exgtip" data-big_stuff_id="' + me.timed + '" data-big_stuff_value="' + curTimed + '" data-big_stuff_type="timed" data-exgtip_type="timed" data-exgtip_value="' + me.timed + '">' + '<div class="item-img" style="background-image:url(' + image + ')">' + '<span class="stack-counter big_counter"><span class="big_counter_mid">' + curTimed + '/' + timed[1] + '</span></span>' + '</div>' + '</div>';
            this.el.down('.stuff').setHTML(html);
        },
        _setState: function() {
            var me = this,
                hasStuff = ExGods.app.user.checkStuff(me.stuff),
                enabled = hasStuff && !me.is_disabled;
            me.textbutton[enabled ? 'enable' : 'disable']();
            if (!hasStuff && me.price) {
                me.textbutton.hide();
                me.buybutton.show();
            } else {
                me.buybutton.hide();
                me.textbutton.show();
            }
            if (me.el) {
                var clsArr = me.el.dom.className.split(' ');
                if (enabled && clsArr.indexOf('disabled') != -1) {
                    me.el.removeCls('disabled');
                } else if (!enabled && clsArr.indexOf('disabled') == -1) {
                    me.el.addCls('disabled');
                }
            }
        },
        getResources: function() {
            var me = this;
            return {
                stuff: me.stuff
            };
        }
    });
    /**
 * Внутренний класс - диалог подтверждения покупки востанавливаемой хар-ки
 */
    var BuyTimedConfirmationInner = Ext.define(null, {
            /**
     * @cfg {String} timed Название характеристики
     */
            timed: '',
            /**
     * @cfg {Function} onSuccess Колбек успешной покупки
     */
            onSuccess: Ext.emptyFn,
            constructor: function(config) {
                var me = this,
                    proto = ExGods.ref('user_timed|' + config.timed);
                if (proto) {
                    if (proto.extra.guild_request_id) {
                        if (ExGods.app.user.get('binding').guild) {
                            ExGods.app.block();
                            ExGods.Services.get('guilds').command('create_request', {
                                type: proto.extra.guild_request_id,
                                only_check: 1
                            }, function(resp) {
                                ExGods.app.unblock();
                                me.showPriceAndRequestConfirmation(proto.extra.guild_request_id, resp, proto.price);
                            });
                        } else {
                            me.showPriceAndRequestConfirmation(proto.extra.guild_request_id, null, proto.price);
                        }
                    } else if (proto.price.length) {
                        me.showPriceConfirmation(proto.price);
                    }
                }
                Ext.apply(me, config || {});
                me.callParent(arguments);
            },
            showPriceConfirmation: function(price) {
                var me = this;
                Ext.widget('confirmdialog', {
                    message: ExGods.app.applyTpl(ExGods.getMsgByKey('buy_timed'), {
                        cost: ExGods.util.Stuff.printStuff(price)
                    }),
                    handler: function() {
                        ExGods.Services.get('inventory').command('buy_timed', {
                            stat_name: me.timed
                        }, function() {
                            me.onSuccess();
                        });
                    }
                });
            },
            showPriceAndRequestConfirmation: function(requestId, requestData, price) {
                var me = this,
                    timerId = 'buy-timed-request-button-timer',
                    timeoutDate, requestBtn, buyBtn, requestBtnText, requestBtnCls, win;
                if (!requestData) {
                    // если не в гильдьии
                    requestBtnText = ExGods.getMsgByKey('buy_timed_request_btn_text_3');
                    requestBtnCls = 'no_border_double double_text';
                } else if (requestData.timeout > 0) {
                    // если в гильдии, но есть таймаут на реквест
                    timeoutDate = Ext.Date.add(new Date(), Ext.Date.SECOND, requestData.timeout);
                    requestBtnText = ExGods.app.applyTpl(ExGods.getMsgByKey('buy_timed_request_btn_text_2'), {
                        counter: ExGods.util.Timers.printTimer('rest', timerId, timeoutDate, {
                            needNormalized: false
                        })
                    });
                    requestBtnCls = 'no_border_double double_text';
                } else {
                    // если в гильдии и нет таймаута на реквест
                    requestBtnText = ExGods.getMsgByKey('buy_timed_request_btn_text_1');
                    requestBtnCls = 'no_border_double double_text';
                }
                requestBtn = Ext.widget('textbutton', {
                    width: 160,
                    cls: requestBtnCls,
                    text: requestBtnText,
                    margin: '0 0 0 10',
                    disabled: (!requestData || requestData.success != 1 || requestData.timeout > 0),
                    handler: function() {
                        ExGods.app.block();
                        ExGods.Services.get('guilds').command('create_request', {
                            type: requestId
                        }, function(resp) {
                            ExGods.app.unblock();
                            win.close();
                            me.onSuccess();
                        });
                    }
                });
                requestBtn.mon(ExGods.util.Timers, timerId + '-expire', function() {
                    requestBtn.setDisabled(false);
                    requestBtn.removeCls('double_text');
                    requestBtn.setText(ExGods.getMsgByKey('buy_timed_request_btn_text_1'));
                });
                buyBtn = Ext.widget('textbutton', {
                    width: 160,
                    cls: 'no_border_double',
                    text: ExGods.app.applyTpl(ExGods.getMsgByKey('buy_timed_buy_btn_text'), {
                        cost: ExGods.util.Stuff.printStuff(price)
                    }),
                    margin: '0 10 0 0',
                    hidden: !price,
                    handler: function() {
                        ExGods.Services.get('inventory').command('buy_timed', {
                            stat_name: me.timed
                        }, function() {
                            win.close();
                            me.onSuccess();
                        });
                    }
                });
                var win = Ext.widget('commonwindow', {
                        width: 450,
                        bodyStyle: 'text-align: center; line-height: 18px; overflow: visible;',
                        bodyPadding: '20 0',
                        buttonAlign: 'center',
                        y: 260,
                        // по высоте центрирую относительно локации
                        html: ExGods.getMsgByKey('buy_timed_with_request'),
                        autoShow: true,
                        buttons: [
                            buyBtn,
                            requestBtn
                        ]
                    });
            }
        });
}());

/**
 * Арена - показывает правила арены и позволяет подобрать себе врага
 */
Ext.define('ExGods.view.arena.Arena', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena',
    plugins: [
        'paperdeco'
    ],
    /**
     * @cfg {Object} arena Данные арены
     */
    arena: {},
    /**
     * @cfg {Object} service Сервис арены
     */
    service: {},
    cls: 'arena arenaview',
    /**
     * @cfg clientObject {Object} Конфигурация компонента из справочника Клиент-Объекты
     */
    clientObject: {},
    //скорость автоматичекого увеличения
    animationSpeed: 1000,
    //ms
    initComponent: function() {
        var me = this;
        me.data = me.arena.data;
        me.tpl = [
            '<div class="section section1">',
            '<div class="paper-title title">',
            '<tpl if="(info && info.rival) || this.isQueueState(values) || !this.hasArenaShop()">',
            '<h4>' + ExGods.getMsgByKey('view_arena_arena_enemy_title') + '</h4>',
            '<tpl else>',
            '<h4>' + ExGods.getMsgByKey('arena_hint_title') + '</h4>',
            '</tpl>',
            '</div>',
            '<div class="content"><div style="text-align: center">',
            '<tpl if="info && info.rival">',
            '<div class="enemy-info">',
            '<div class="exg-share-base-info exg-share-bg-light">',
            '<span>{[ ExGods.printUser(values.info.rival, {fields: "name,rank", maxNameWidth: 112})]}</span>',
            '<span>{[this.printTrophy(values.info.rival.elo || [],true)]}</span>',
            '<span>{[this.printTrophy(values.info.rival.elo_value || 0,true)]}</span>',
            '<div class="image-frame" style="background-image: url({[ this.getUserImage(values.info.rival) ]})"></div>',
            '</div>',
            '<div class="stats-title exg-share-bg-dark">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
            '<div class="stats1 exg-share-bg-light">',
            '{[ ExGods.util.User.printUserStats(values.info.rival.stats.stats, {visibleValue: 1, align: "right", changes: this.getStatsChanges(values.info.rival.stats.stats)}) ]}',
            '</div>',
            '<tpl if="this.getMaskLabel(values.info.rival)">',
            '<div class="stats-title exg-share-bg-dark">{[this.getMaskLabel(values.info.rival)]}</div>',
            '</tpl>',
            '<div class="stats2 exg-share-bg-light">',
            '{[ ExGods.util.User.printUserStats(values.info.rival.stats.stats, {visibleValue: 2, changes: this.getStatsChanges(values.info.rival.stats.stats)}) ]}',
            '</div>',
            '</div>',
            '<tpl elseif="this.isQueueState(values)">',
            '<div class="queue-timer" id="arena-queue-time-{id}">',
            '{[this.printQueuePercent(values)]}',
            '{[this.printQueueTime(values)]}',
            '<div class="queue-separators"></div>',
            '</div>',
            '<tpl elseif="this.hasArenaShop()">',
            '<p class="hint">',
            '{[this.getHint()]}',
            '</p>',
            '<tpl if="this.getHasShopItems().length">',
            '<ul class="shop-items-list exg-share-bg-dark">',
            '<tpl foreach="this.getHasShopItems()">',
            '<li class="shop-items-list-item" data-id="{id}" style="background-image: url(' + IMAGE_URL + '{desc.img});"><div>{[this.printHasItemEndTimed(values.end)]}</div></li>',
            '</tpl>',
            '</ul>',
            '<tpl else>',
            '<div class="no-shop-items exg-share-bg-dark">',
            ExGods.getMsgByKey('arena_has_no_items_text'),
            '</div>',
            '</tpl>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena_show_shop</span>',
            '<span role="arena_id">{id}</span>',
            '<span role="text">',
            ExGods.getMsgByKey('arena_go_shop_btn_title'),
            '</span>',
            '<span role="cls">x-btn-txt double_text_btn goto-shop-btn</span>',
            '<span role="flex:int">1</span>',
            '<span role="margin">3 5 0 0</span>',
            '<span role="width">116px</span>',
            '<span role="disabled:bool">1</span>',
            '</div>',
            '<tpl else>',
            '<div class="queue-timer"></div>',
            '</tpl>',
            '</div>',
            '</div>',
            '</div>',
            '<div class="v-separator"></div>',
            '<div class="section section2" style="height: {[ values.info && values.info.rival ? 165 : 143 ]}px;">',
            '<div class="paper-title title">',
            '<tpl if="info && info.rival">',
            '<h4>' + ExGods.getMsgByKey('view_arena_arena_enemy_equipment') + '</h4>',
            '<tpl else>',
            '<h4>{[this.printArenaTitle(values)]}</h4>',
            '</tpl>',
            '</div>',
            '<div class="content">',
            '<tpl if="info && info.rival">',
            '<tpl if="info.rival.data && info.rival.data.app">',
            '<div class="social-rival-message">' + me.clientObject.social_rival_text + '</div>',
            '<tpl elseif="info.rival.slots">',
            '<div class="slots">',
            '<div class="component">',
            '<span role="xtype">arenaslotitems</span>',
            '<span role="parent_id">' + me.id + '</span>',
            '</div>',
            '</div>',
            '<tpl else>',
            //
            '</tpl>',
            '<tpl else>',
            '<div class="rules">',
            '{[ this.getDescription(values) ]}',
            '</div>',
            '<div class="awards">',
            '{[ this.getAwards(values) ]}',
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            '<tpl if="info && info.rival">',
            '<div class="separator"></div>',
            '<tpl else>',
            '<div class="separator" style="top: 146px;"></div>',
            '<div class="section section3">',
            '{[ this.printSeriesInfo(values) ]}',
            '</div>',
            '</tpl>',
            '<div class="separator separator2"></div>',
            '<div class="section section4">',
            '<tpl if="info && info.rival">',
            '<div class="paper-title title">',
            '<h4>' + ExGods.getMsgByKey('arena_rewards_title') + '</h4>',
            '</div>',
            '</tpl>',
            '<div class="content">',
            '<tpl if="info && info.rival">',
            '<tpl if="info.elo && info.elo.length">',
            '<div class="rewards">',
            '<span class="reward"><strong>' + ExGods.getMsgByKey('view_arena_arena_for_win') + ' </strong><span style="color: #008C00;">{[this.printTrophy("+" + values.info.elo[0].win)]}</span></span>',
            '<span class="reward"><strong>' + ExGods.getMsgByKey('view_arena_arena_for_lose') + ' </strong><span style="color: #ff0000;">{[this.printTrophy(""  + values.info.elo[0].lose)]}</span></span>',
            '</div>',
            '</tpl>',
            '<div class="component">',
            '<span role="xtype">container</span>',
            '<span role="layout">',
            '<span role="type">hbox</span>',
            '<span role="align">middle</span>',
            '</span>',
            '<span role="padding">0 10</span>',
            '<ul role="items">',
            '<li>',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena_accept</span>',
            '<span role="arena_id">{id}</span>',
            '<span role="text">',
            '<tpl if="this.isAcceptState(values)">',
            Ext.String.format(ExGods.getMsgByKey('view_arena_start_text_1'), '<b id="arena-ready-time-{id}">{[this.printReadyTime(values)]}</b>'),
            '<tpl else>',
            Ext.String.format(ExGods.getMsgByKey('view_arena_start_text_2'), '<b id="arena-ready-time-{id}">{[this.printReadyTime(values)]}</b>'),
            '</tpl>',
            '</span>',
            '<span role="cls">x-btn-txt-red no_border_double</span>',
            '<span role="flex:int">1</span>',
            '<span role="margin">0 5 0 0</span>',
            '<span role="disabled:bool">{[this.isAcceptState(values)]}</span>',
            '</li>',
            '<li>',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena_refuse</span>',
            '<span role="arena_id">{id}</span>',
            '<span role="text">' + ExGods.getMsgByKey('view_arena_arena_new_enemy_btn') + ' {[ExGods.util.Stuff.printStuff(values.stuff_refuse)]}</span>',
            '<span role="cls">no_border_double double_text</span>',
            '<span role="disabled:bool">{[this.isAcceptState(values)]}</span>',
            '<span role="flex:int">1</span>',
            '</li>',
            '</ul>',
            '</div>',
            '<tpl else>',
            '<span class="description">' + ExGods.getMsgByKey('arena_go_battle_description') + '</div>',
            '<div class="v-separator"></div>',
            '<tpl if="this.isQueueState(values)">',
            '<div class="component battle-btn">',
            '<tpl else>',
            '<div class="component battle-btn qh-object" data-qh_otype="arena_button_battle" data-qh_oid="1">',
            '</tpl>',
            '<span role="xtype">timedtimer</span>',
            '<span role="timed">{stuff_cost.params.id}</span>',
            '<span role="quantity">{stuff_cost.params.quantity}</span>',
            '<span role="is_disabled:bool">{[this.isQueueState(values) || this.isAcceptState(values)]}</span>',
            '<span role="textbutton">',
            '<span role="action">arena_queue</span>',
            '<span role="arena_id">{id}</span>',
            '</span>',
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            {
                printArenaTitle: function(data) {},
                // var me = this,
                //  tpl = ExGods.getMsgByKey('arena_title'),
                //  dt = ExGods.util.Date.normalizeServerDateTime(data.finish_date);
                // tpl = tpl.replace('{time}', '<span id="arena-finish-season-rest-time-{id}" style="font-weight: bold;">'+
                //      ExGods.util.Time.printRestTime(dt, {format: 'threenums', emptyText: ExGods.getMsgByKey('arena_season_finish_msg'), stringFormat: ExGods.getMsgByKey('view_arena_arenaseasontimeoutformat')}) +
                //  '</span>');
                // return ExGods.app.applyTpl(tpl, data);
                hasArenaShop: function() {
                    return me.service.data.arena_shop && me.service.data.arena_shop.types.length;
                },
                getHint: function() {
                    if (me.service.data.arena_shop.has && me.service.data.arena_shop.has.length && me.service.data.arena_shop.has.length > 6) {
                        return '';
                    } else {
                        return ExGods.getMsgByKey('arena_hint_text');
                    }
                },
                getHasShopItems: function() {
                    if (Ext.isArray(me.service.data.arena_shop.has)) {
                        return me.service.data.arena_shop.has.slice(0, 9);
                    } else {
                        return me.service.data.arena_shop.has;
                    }
                },
                printHasItemEndTimed: function(date) {
                    if (date) {
                        date = ExGods.util.Date.normalizeServerDateTime(date);
                        return '<span class="exg-timer" data-date="' + date + '" data-format="twonums">' + ExGods.util.Time.printRestTime(date, {
                            format: 'twonums'
                        }) + '</span>';
                    }
                },
                getAwards: function(data) {
                    var html = [],
                        trophyRewardsHash = data.trophy_reward || {},
                        rating, lowLevelRating, ratingReward;
                    ExGods.ref('user_trophy').each(function(key, value, myself) {
                        if (value.description.prize) {
                            var reward = '<div class="reward_container nonevented" data-id="' + key + '">' + '<img class="reward_img" src="' + IMAGE_URL + value.description.img + '" />' + '<div class="reward_name">' + '<img src="' + IMAGE_URL + 'icons/' + (trophyRewardsHash[value.level] == "1" ? 'done.png' : 'undone.png') + '"/>' + value.description.label + '</div>' + '</div>';
                            html.push(reward);
                        }
                    });
                    // определяю, в какой рейтинг попадает игрок
                    Ext.Object.each(me.arena.data.rank_rewards, function(key, value, myself) {
                        if (me.arena.data.rating_info && value.start <= me.arena.data.rating_info.rank && me.arena.data.rating_info.rank <= value.end) {
                            rating = {
                                key: key,
                                value: value
                            };
                        }
                        if (!lowLevelRating || lowLevelRating.value.start < value.start) {
                            lowLevelRating = {
                                key: key,
                                value: value
                            };
                        }
                    });
                    rating = rating || lowLevelRating;
                    ratingReward = '<div class="reward_container nonevented rankreward" data-id="' + rating.key + '">' + '<img class="reward_img" src="' + IMAGE_URL + rating.value.image + '" />' + '<div class="reward_name">' + ((me.arena.data.rating_info && (rating.value.start <= me.arena.data.rating_info.rank) && (me.arena.data.rating_info.rank <= rating.value.end)) ? '<img src="' + IMAGE_URL + 'icons/done.png"/>' : '<img src="' + IMAGE_URL + 'icons/undone.png"/>') + rating.value.label + '</div>' + '</div>';
                    html.push(ratingReward);
                    return html.slice(0, 5).join('');
                },
                // max 5 elements
                getDescription: function(data) {
                    return ExGods.app.applyTpl(data.description, {
                        u: ExGods.app.user.data
                    });
                },
                isQueueState: function(data) {
                    return data.state == 'queue';
                },
                isAcceptState: function(data) {
                    return data.state == 'accept';
                },
                printQueueTime: function(data) {
                    var queueDate = ExGods.util.Date.normalizeServerDateTime(data.queue_time),
                        queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), data.wait_queue);
                    x = (queueTime % 9) * 103 + 36 , y = Math.floor(queueTime / 9) * 104 + 36;
                    return '<div class="queue-timer-value" style="background-position:-' + x + 'px -' + y + 'px"></div>';
                },
                printQueuePercent: function(data) {
                    var queueDate = ExGods.util.Date.normalizeServerDateTime(data.queue_time),
                        queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), data.wait_queue);
                    queuePercent = Math.min(Math.floor(queueTime * 100 / data.wait_queue), 100) , x = (queuePercent % 9) * 103 + 10 , y = Math.floor(queuePercent / 9) * 104 + 10;
                    return '<div class="queue-timer-counter" style="background-position:-' + x + 'px -' + y + 'px"></div>';
                },
                printReadyTime: function(data) {
                    var readyDate = ExGods.util.Date.normalizeServerDateTime(data.ready_time),
                        readyTime = Math.max(0, data.wait_ready * 1000 - (Date.now() - readyDate));
                    return ExGods.util.Time.printTime(readyTime / 1000, {
                        format: 'detailed',
                        emptyText: '..'
                    });
                },
                printRestTime: function(data) {
                    var dt = ExGods.util.Date.normalizeServerDateTime(data.finish_date);
                    return ExGods.util.Time.printRestTime(dt, {
                        format: 'threenums',
                        emptyText: ExGods.ref('message_client|arena_season_finish_msg')
                    });
                },
                getMaskLabel: function(data) {
                    var proto = ExGods.app.getItemPrototypesStore().data.getByKey(parseInt(data.mask_proto_id));
                    if (proto) {
                        return Ext.String.htmlEncode(proto.data.title);
                    }
                },
                printSeriesInfo: function(data) {
                    return ExGods.Tooltips.createTip({
                        tag: 'span',
                        type: 'text',
                        value: 'arena-series-descr',
                        html: ExGods.app.applyTpl(ExGods.getMsgByKey('arena_series_str'), data.series)
                    });
                },
                printTrophy: function(num, printDelta) {
                    var user = ExGods.app.getUser(),
                        html = '';
                    if (Ext.isArray(num)) {
                        Ext.Array.each(num, function(el) {
                            for (var key in el) {
                                var eloRef = ExGods.references.get('user_elo').get(key),
                                    userElo = user.get('elo')[key];
                                if (eloRef) {
                                    html += '<span class="trophy-num" style="background-image:url(' + IMAGE_URL + eloRef.image.img_3 + ')">' + el[key] + '</span>';
                                    if (el[key] != userElo && printDelta) {
                                        var cls = el[key] > userElo ? 'up' : 'down',
                                            sign = el[key] > userElo ? '+' : '';
                                        html += '<span class="changes"><small>(</small>' + '<span class="' + cls + '">' + sign + (el[key] - userElo) + '</span><small>)</small></span>';
                                    }
                                }
                            }
                        });
                    } else {
                        var trophy = user.get('hoard').trophy,
                            html = '<span class="trophy-num">' + num + '</span>';
                        if (num != trophy && printDelta) {
                            var cls = num > trophy ? 'up' : 'down',
                                sign = num > trophy ? '+' : '';
                            html += '<span class="changes"><small>(</small>' + '<span class="' + cls + '">' + sign + (num - trophy) + '</span><small>)</small></span>';
                        }
                    }
                    return html;
                },
                getUserImage: function(data) {
                    if (typeof data.shape == 'object') {
                        if (/^http/.test(data.shape.small)) {
                            return data.shape.small;
                        } else {
                            return IMAGE_URL + data.shape.small;
                        }
                    } else {
                        return ExGods.ref('user_shape|' + data.shape).thumb;
                    }
                },
                getStatsChanges: function(stats) {
                    // вернёт разницу в статах
                    var changes = {},
                        myStats = ExGods.app.user.get('stats').stats;
                    Ext.Object.each(stats, function(k, v) {
                        if (typeof myStats[k] != 'undefined') {
                            changes[k] = v - myStats[k];
                        }
                    });
                    return changes;
                }
            }
        ];
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            me.section(1).renderComponents();
            me.section(2).renderComponents();
            me.section(4).renderComponents();
        }, me, {
            single: true
        });
        // клик по картинке купленной услуги
        me.getEl().on('click', function(e) {
            var el = e.getTarget(),
                itemId = el.getAttribute('data-id'),
                itemInfo;
            itemInfo = Ext.Array.findBy(me.service.data.arena_shop.has, function(item) {
                return item.id == itemId;
            });
            Ext.widget('commondetailswindow', {
                itemElement: el,
                data: {
                    label: itemInfo.desc.label,
                    description: itemInfo.desc.description,
                    image: IMAGE_URL + itemInfo.desc.img
                }
            });
        }, me, {
            delegate: '.shop-items-list-item'
        });
        ExGods.util.Ticker.addListener(me.updateQueueTime, me);
        ExGods.util.Ticker.addListener(me.updateReadyTime, me);
        if (me.arena.data.finish_date) {
            ExGods.util.Ticker.addListener(me.updateFinishSeasonTime, me);
        }
        me.on('afterlayout', function() {
            if (this.getEl().down('.reward_container.nonevented')) {
                Ext.Array.each(this.getEl().query('.reward_container.nonevented'), function(item) {
                    var el = Ext.get(item);
                    el.removeCls('nonevented');
                    el.on('click', function() {
                        var item_object = this;
                        if (!el.hasCls('rankreward')) {
                            //если не топ ранга
                            var reward = ExGods.ref('user_trophy|' + item.getAttribute('data-id')).description;
                            var reward_items = reward.prize;
                        } else {
                            var reward = me.arena.data.rank_rewards[item.getAttribute('data-id')];
                            var reward_items = reward.stuff;
                        }
                        ExGods.Resources.loadStuff(reward_items, function() {
                            var wdj = Ext.widget('commondetailswindow', {
                                    itemElement: item_object,
                                    imageSize: 64,
                                    autoShow: false,
                                    data: {
                                        label: reward.label,
                                        description: reward.description,
                                        image: IMAGE_URL + (reward.image || reward.img),
                                        rows: [
                                            {
                                                title: ExGods.getMsgByKey('view_arena_arena_rewards'),
                                                cls: 'stuff-list',
                                                content: '<ul>' + ExGods.stuff.StuffManager.image(reward_items) + '</ul>'
                                            }
                                        ]
                                    }
                                });
                            ExGods.Resources.load(wdj, function() {
                                wdj.show();
                            });
                        });
                    });
                });
            }
        });
    },
    /**
     * @private Вернёт обертку-интерфейс для одной из секции арены
     */
    section: function(sectionIndex) {
        var me = this,
            el = me.getEl().select('.section' + sectionIndex).elements[0],
            // dom el секции
            components = [];
        return {
            setTitle: function(text) {
                Ext.fly(el).select('.title h4').setHTML(text);
                return this;
            },
            setContent: function(html) {
                Ext.fly(el).select('.content').setHTML(html);
                return this;
            },
            renderComponents: function() {
                ExGods.util.Helper.renderComponents(el, me);
                return this;
            },
            destroyComponents: function() {
                ExGods.util.Helper.destroyComponents(el);
                return this;
            }
        };
    },
    update: function(data) {
        var me = this;
        if (me.rendered) {
            me.section(1).destroyComponents();
            me.section(2).destroyComponents();
            me.section(4).destroyComponents();
        }
        me.arena.data = data;
        me.callParent(arguments);
        if (me.rendered) {
            me.section(1).renderComponents();
            me.section(2).renderComponents();
            me.section(4).renderComponents();
        }
    },
    updateQueueTime: function() {
        var me = this,
            viewEl = me.getEl(),
            queueDate, queueTime, queuePercent, el, val_el;
        if (me.arena.data.state == 'queue' && me.arena.data.queue_time) {
            queueDate = ExGods.util.Date.normalizeServerDateTime(me.arena.data.queue_time);
            //queueTime = Math.max(0, me.arena.data.wait_queue*1000 - (Date.now() - queueDate));
            queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), me.arena.data.wait_queue);
            queuePercent = Math.min(Math.floor(queueTime * 100 / me.arena.data.wait_queue), 99);
            if (viewEl) {
                el = viewEl.select('.queue-timer-counter');
                val_el = viewEl.select('.queue-timer-value');
                var x = (queuePercent % 9) * 103 + 10,
                    y = Math.floor(queuePercent / 9) * 104 + 10,
                    val_x = (queueTime % 9) * 103 + 36,
                    val_y = Math.floor(queueTime / 9) * 104 + 36;
                el.setStyle('background-position', '-' + x + 'px -' + y + 'px');
                val_el.setStyle('background-position', '-' + val_x + 'px -' + val_y + 'px');
            }
        }
    },
    updateReadyTime: function() {
        var me = this,
            viewEl = me.getEl(),
            readyDate, readyTime, el;
        if (me.arena.data.state == 'ready') {
            readyDate = ExGods.util.Date.normalizeServerDateTime(me.arena.data.ready_time);
            readyTime = Math.max(0, me.arena.data.wait_ready * 1000 - (Date.now() - readyDate));
            if (viewEl) {
                el = viewEl.select('#arena-ready-time-' + me.arena.data.id);
                el.setHTML(ExGods.util.Time.printTime(readyTime / 1000, {
                    format: 'detailed',
                    emptyText: '..'
                }));
            }
        }
    },
    updateFinishSeasonTime: function() {
        var me = this,
            viewEl = me.getEl(),
            finishDate = ExGods.util.Date.normalizeServerDateTime(me.arena.data.finish_date),
            el;
        if (finishDate && viewEl) {
            el = viewEl.select('#arena-finish-season-rest-time-' + me.arena.data.id);
            el.setHTML(ExGods.util.Time.printRestTime(finishDate, {
                format: 'threenums',
                emptyText: ExGods.ref('message_client|arena_season_finish_msg'),
                stringFormat: ExGods.getMsgByKey('view_arena_arenaseasontimeoutformat')
            }));
        }
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateQueueTime);
        ExGods.util.Ticker.removeListener(me.updateReadyTime);
        ExGods.util.Ticker.removeListener(me.updateFinishSeasonTime);
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [];
        var arr_images = [];
        if (me.data.rival_stuff) {
            stuff_arr = stuff_arr.concat(me.data.rival_stuff);
        }
        for (var i = 0; i < me.data.rank_rewards.length; i++) {
            arr_images.push(me.data.rank_rewards[i].image);
        }
        var img_user_rival = me.data.rival_image || [];
        return {
            stuff: [].concat(me.data.stuff_refuse.stuff).concat([
                me.data.stuff_cost
            ]).concat(stuff_arr),
            images: [
                IMAGE_URL + 'icons/done.png',
                IMAGE_URL + 'icons/undone.png',
                IMAGE_URL + 'btn_wide_standart.png',
                IMAGE_URL + 'button-text-30red.png'
            ].concat(arr_images).concat(ExGods.util.User.getUserStatImages()).concat(img_user_rival)
        };
    }
});

/**
 * Список врагов на арене
 */
Ext.define('ExGods.view.arena.EnemyList', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena_enemylist',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'arena enemy-list',
    itemsPerPage: 3,
    textFilter: '',
    /**
     * @cfg {Array} list Список врагов
     */
    list: null,
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'container',
                layout: 'fit',
                height: 284,
                items: [
                    {
                        itemId: 'list',
                        cls: 'list',
                        tpl: [
                            '<tpl if="list && list.length">',
                            '<tpl for="list">',
                            '<div class="enemy-wrap">',
                            '<div class="paper paper-tl"></div>',
                            '<div class="paper paper-tm"></div>',
                            '<div class="paper paper-tr"></div>',
                            '<div class="paper paper-mr"></div>',
                            '<div class="paper paper-br"></div>',
                            '<div class="paper paper-bm"></div>',
                            '<div class="paper paper-bl"></div>',
                            '<div class="paper paper-ml"></div>',
                            '<div class="paper paper-bg"></div>',
                            '<div class="exg-share-base-info exg-share-bg-light gender-{gender}" style="background-image: url({[ this.getUserImage(values) ]})">',
                            '<span>{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank", maxNameWidth: 84})]}</span>',
                            '<span>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {hoard.level}</span>',
                            '<span>{[ this.printArenaRating(values) ]}</span>',
                            '<div class="image-frame"></div>',
                            '</div>',
                            '<div class="paper-separator" style="position: relative;"></div>',
                            '<h5 class="exg-share-bg-dark">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</h5>',
                            '<div class="stats1">',
                            '{[ ExGods.util.User.printUserStats(values.stats.stats, {visibleValue: 1, align: "right", changes: this.getStatsChanges(values)}) ]}',
                            '</div>',
                            '<div class="paper-separator" style="position: relative;"></div>',
                            '<div class="component">',
                            '<span role="xtype">textbutton</span>',
                            '<span role="cls">x-btn-txt-red no_border_double x-item-disabled ',
                            '<tpl if="can_revenge == 0">',
                            'x-disabled x-btn-disabled x-btn-txt-disabled',
                            '</tpl>',
                            '</span>',
                            '<span role="text">' + ExGods.getMsgByKey('view_arena_enemylist_revenge_btn') + '</span>',
                            '<span role="margin">9 0 0 0</span>',
                            '<span role="action">arena_revenge</span>',
                            '<span role="can_revenge">{can_revenge}</span>',
                            '<span role="arena_id">{parent.arena.id}</span>',
                            '<span role="user_title">{display_title}</span>',
                            '<span role="action">arena_revenge</span>',
                            '</div>',
                            '</div>',
                            '</tpl>',
                            '<tpl else>',
                            '<div class="empty-msg">' + ExGods.ref('message_client|arena_enemylist_empty_msg') + '</div>',
                            '</tpl>',
                            {
                                getUserImage: function(data) {
                                    return ExGods.ref('user_shape|' + data.shape).thumb;
                                },
                                printArenaRating: function(data) {
                                    var user = ExGods.app.getUser(),
                                        ratingName, ratingValue, eloRef, userElo,
                                        html = '';
                                    if (data.elo && data.elo.length) {
                                        ratingName = Object.keys(data.elo[0])[0];
                                        ratingValue = data.elo[0][ratingName];
                                        eloRef = ExGods.references.get('user_elo').get(ratingName);
                                        userElo = user.get('elo')[ratingName];
                                        if (eloRef) {
                                            html += '<span class="trophy-num" data-qtip="' + eloRef.label + '"style="background-image:url(' + IMAGE_URL + eloRef.image.img_3 + ')">' + ratingValue + '</span>';
                                            if (ratingValue != userElo) {
                                                var cls = ratingValue > userElo ? 'up' : 'down',
                                                    sign = ratingValue > userElo ? '+' : '';
                                                html += '<span class="changes"><small>(</small>' + '<span class="' + cls + '">' + sign + (ratingValue - userElo) + '</span><small>)</small></span>';
                                            }
                                        }
                                    }
                                    return html;
                                },
                                getStatsChanges: function(data) {
                                    var changes = {},
                                        myStats = ExGods.app.user.get('stats').stats;
                                    Ext.Object.each(data.stats.stats, function(k, v) {
                                        if (typeof myStats[k] != 'undefined') {
                                            changes[k] = v - myStats[k];
                                        }
                                    });
                                    return changes;
                                }
                            }
                        ],
                        data: {
                            arena: me.arena,
                            list: me.list ? me.list.slice(0, me.itemsPerPage) : null
                        }
                    }
                ]
            }
        ];
        me.plugins = me.plugins || [];
        me.plugins.push({
            ptype: 'pager',
            marginLeft: -27,
            marginRight: -27,
            top: 127,
            textTop: -32,
            textLeft: 249,
            total: Math.ceil((me.list ? me.list.length : 0) / me.itemsPerPage)
        });
        me.listeners = {
            prev: me.updateList,
            next: me.updateList,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me, {
            single: true
        });
    },
    setList: function(list) {
        var me = this;
        // сортирую список по дате добавления - старые вниз, новые вверх
        me.list = Ext.Array.sort(list, function(a, b) {
            if (a.add_time > b.add_time) {
                return -1;
            } else if (b.add_time > a.add_time) {
                return 1;
            } else {
                return 0;
            }
        });
        ExGods.Resources.load({
            list: me.list,
            getResources: me.getResources
        }, function() {
            me.updateList();
        });
    },
    updateList: function() {
        var me = this,
            items = me.filtered || me.list;
        items = items.slice((me.pager.current - 1) * me.itemsPerPage, me.pager.current * me.itemsPerPage);
        me.items.items[0].getComponent('list').update({
            arena: me.arena,
            list: items
        });
        ExGods.util.Helper.renderComponents(me.el, me);
        me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        me.pager.refresh();
    },
    setTextFilter: function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        if (me.textFilter) {
            me.filtered = Ext.Array.filter(me.list, function(item) {
                return (item.display_title).toLowerCase().indexOf(me.textFilter) != -1;
            });
            me.pager.total = Math.ceil(me.filtered.length / me.itemsPerPage);
        } else {
            delete me.filtered;
            me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        }
        me.pager.current = 1;
        me.updateList();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        if (me.list) {
            for (var i = 0; i < me.list.length; i++) {
                arr_images.push(ExGods.ref('user_shape|' + me.list[i].shape).thumb);
            }
        }
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'btn_red_high.png'
            ].concat(arr_images).concat(ExGods.util.User.getUserStatImages())
        };
    }
});

/**
 * Рейтинг на арене
 */
Ext.define('ExGods.view.arena.Rating', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena_rating',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'arena rating',
    itemsPerPage: 7,
    textFilter: '',
    /**
     * @cfg {Object} arena Данные арены
     */
    arena: {},
    /**
     * @cfg {Array} list Рейтинг
     */
    list: [],
    initComponent: function() {
        var me = this;
        // сортирую по ранку
        me.list = Ext.Array.sort(me.list, function(a, b) {
            return a.rank - b.rank;
        });
        me.items = [
            {
                xtype: 'container',
                plugins: [
                    'paperdeco'
                ],
                height: 284,
                items: [
                    {
                        itemId: 'list',
                        tpl: [
                            '<div class="paper-title title">',
                            '<tpl if="arena.season">',
                            '<h4>{[this.applyTitleTpl(values.arena)]}</h4>',
                            '<tpl else >',
                            '<h4>{[this.applyNoSeasonTpl(values.arena)]}</h4>',
                            '</tpl>',
                            '</div>',
                            '<div class="subtitle">{[this.applyTrophyTpl(values.arena)]}</div>',
                            '<div class="separator"></div>',
                            '<tpl if="list.length">',
                            '<table class="list">',
                            '<tpl for="list">',
                            '<tr class="{[ xindex % 2 ? "exg-share-bg-light" : "exg-share-bg-dark" ]}">',
                            '<td class="place-cell">',
                            '<tpl if="rank &gt;= 1 && rank &lt;= 3">',
                            '<div class="place-{rank}"><img width="76" height="24" src="{[ this.getPlaceImage(values.rank) ]}"></div>',
                            '<tpl else>',
                            '<span>{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('rating_place') + '",{place:values.rank})]}</span>',
                            '</tpl>',
                            '</td>',
                            '<td class="username-cell">',
                            '{[ ExGods.printUser(values.info, {fields: "name,rank,level,infoicon", maxNameWidth: 112}) ]}',
                            '</td>',
                            '<td class="count-cell">',
                            '{[this.printTrophy(values.value)]}',
                            '</td>',
                            '</tr>',
                            '</tpl>',
                            '</table>',
                            '<tpl else>',
                            '<div class="empty-msg">' + ExGods.ref('message_client|arena_rating_empty_msg') + '</div>',
                            '</tpl>',
                            {
                                applyTitleTpl: function(arena) {
                                    var strFin = ExGods.getMsgByKey('arena_season_finish_msg'),
                                        restTime = '';
                                    strFin = strFin.replace(/["]/g, "'");
                                    restTime = '<span id="arena-rating-rest-time-' + arena.id + '">' + ExGods.util.Timers.printRestTimer('arena-rating-rest-time-' + arena.id, arena.finish_date, {
                                        format: 'threenums',
                                        emptyText: strFin
                                    }) + '</span>';
                                    code = ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_title'), {
                                        season: arena.season,
                                        time: restTime
                                    });
                                    return code;
                                },
                                applyNoSeasonTpl: function(arena) {
                                    return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_no_season_title'), {
                                        label: arena.label
                                    });
                                },
                                applyTrophyTpl: function(arena) {
                                    if (arena.rating_info && arena.rating_info.value && arena.rating_info.rank) {
                                        var params = {
                                                place: arena.rating_info.rank,
                                                trophy: this.printTrophy(arena.rating_info.value) + Ext.util.Format.plural(arena.rating_info.value, ExGods.getMsgByKey('trophy_name').split(','))
                                            };
                                        if (arena.rating_top_list) {
                                            return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace'), Ext.apply({
                                                time: this.printDate(arena.rating_top_list.info.last_time)
                                            }, params));
                                        } else {
                                            return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace_no_time'), params);
                                        }
                                    } else if ((arena.elo_value || arena.elo_value == 0) && arena.rating_info && arena.rating_info.value != null) {
                                        var trophy = this.printTrophy(arena.rating_info.value) + Ext.util.Format.plural(arena.rating_info.value, ExGods.getMsgByKey('trophy_name').split(','));
                                        return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace_after_season'), {
                                            trophy: trophy
                                        });
                                    } else {
                                        return ExGods.getMsgByKey('view_arena_rating_curplace_no_trophy');
                                    }
                                },
                                printTrophy: function(num) {
                                    return '<span class="trophy-num">' + num + '</span>';
                                },
                                printDate: function(dateStr) {
                                    var dt = ExGods.util.Date.normalizeServerDateTime(dateStr);
                                    return Ext.Date.format(dt, 'd.m.Y H:i');
                                },
                                getPlaceImage: function(rank) {
                                    return ExGods.ref('images|rating_place_icons').image['place' + rank];
                                }
                            }
                        ],
                        data: {
                            arena: me.arena,
                            list: me.list.slice(0, me.itemsPerPage)
                        }
                    }
                ]
            }
        ];
        me.plugins = me.plugins || [];
        me.plugins.push({
            ptype: 'pager',
            marginLeft: -27,
            marginRight: -27,
            top: 127,
            textTop: -32,
            textLeft: 249,
            total: Math.ceil(me.list.length / me.itemsPerPage)
        });
        me.listeners = {
            prev: me.updateList,
            next: me.updateList,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
    },
    updateList: function() {
        var me = this,
            items = me.filtered || me.list;
        items = items.slice((me.pager.current - 1) * me.itemsPerPage, me.pager.current * me.itemsPerPage);
        me.items.items[0].getComponent('list').update({
            arena: me.arena,
            list: items
        });
        me.pager.refresh();
    },
    setTextFilter: function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        if (me.textFilter) {
            me.filtered = Ext.Array.filter(me.list, function(item) {
                return (item.info.display_title).toLowerCase().indexOf(me.textFilter) != -1;
            });
            me.pager.total = Math.ceil(me.filtered.length / me.itemsPerPage);
        } else {
            delete me.filtered;
            me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        }
        me.pager.current = 1;
        me.updateList();
    },
    onDestroy: function() {
        var me = this;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'icons/ico_trophy.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Магазин
 */
Ext.define('ExGods.view.shop.Shop', {
    extend: Ext.view.View,
    alias: 'widget.shop',
    cls: 'shop',
    /**
     * @cfg {Ext.data.Store} store Хранилище предметов магазина (ExGods.model.ShopItem)
     */
    store: null,
    /**
     * @cfg {Boolean} filterByLevel Скрывать предметы, уровень которых больше уровня игрока
     */
    filterByLevel: true,
    /**
     * @cfg {String} textFilterString Строка текста для фильтра по названию предмета
     */
    textFilterString: '',
    /**
     * @cfg {String} emptyText Строка текста когда нет предметов
     */
    emptyText: '',
    height: 290,
    autoRender: true,
    itemSelector: 'li.item',
    deferEmptyText: false,
    initComponent: function() {
        var me = this;
        me.setFilters();
        me.tpl = [
            '<ul class="shop-items" >',
            '<tpl for=".">',
            '<li class="item qh-object {[ values.new_price ? "discounted" : "" ]}" data-qh_otype="{qh_name}" data-qh_oid="{item_id}" {[this.checkIndex(xindex)]} >',
            '<tpl if="values.new_price">' + '<div class="best_choice" style="background-image:url(' + ExGods.ref('images|common_text_images').image.sale + ')"></div>',
            '<tpl else>',
            '<tpl if="values.level == ' + ExGods.app.user.data.hoard.level + '">',
            '<div class="best_choice" style="background-image:url(' + ExGods.ref('images|common_text_images').image.best + ')"></div>',
            '</tpl>',
            '</tpl>',
            '<div class="item-content">',
            '<div class="item_info"></div>',
            '{[this.getTitle(values)]}',
            '{[this.printImage(values)]}',
            '<div class="level">{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('view_shop_shop_itemlvl') + '",{level:values.level})]}</div>',
            '<tpl if="values.count != -1">',
            '<div class="count">{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('view_shop_shop_itemcount') + '",{level:values.level})]}</div>',
            '</tpl>',
            '<div class="price">{price}</div>',
            '<tpl if="new_price">',
            '<div>{new_price}</div>',
            '</tpl>',
            '<div class="component buy_button">',
            '<span role="xtype">textbutton</span>',
            '<span role="disable:bool">true</span>',
            '<span role="cls">no_border</span>',
            '<span role="text">' + ExGods.getMsgByKey('shop_buy_btn_text') + '</span>',
            '<span role="minWidth:int">90</span>',
            '</div>',
            '<div class="x-clear"></div>',
            '</div>',
            '</li>',
            '</tpl>',
            '</ul>',
            '<div class="x-clear"></div>',
            {
                getTitle: function(values) {
                    var html = '<div class="title';
                    if (values.count != -1) {
                        html += ' one_line';
                    }
                    html += '" style="';
                    if (values.grade) {
                        html += 'color:' + ExGods.references.get('constants_list').item_grades.value[Number(values.grade) - 1 || 0];
                    }
                    return html + '"><span>' + values.title + '</span></div>';
                },
                checkIndex: function(index) {
                    var cls = index == 1 ? ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : (index - 1) % 3 === 0 ? ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : '';
                    return cls;
                },
                printImage: function(values) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'shop_stuff',
                        locked: Boolean(values.message),
                        params: {
                            stuff: {
                                params: {
                                    id: values.item_id
                                },
                                type: values.kit ? 'kit' : 'item'
                            }
                        }
                    });
                }
            }
        ];
        me.emptyText = '<div class="empty-text">' + me.emptyText + '</div>';
        me.callParent(arguments);
        me.on({
            beforerefresh: me.onBeforeRefresh,
            refresh: me.onRefresh,
            scope: me
        });
    },
    /**
     * Установить фильтр по уровню
     */
    setFilterByLevel: function(value) {
        var me = this;
        if (me.filterByLevel != value) {
            me.filterByLevel = value;
            me.setFilters();
        }
    },
    /**
     * Установить фильтр по названию
     */
    setTextFilter: function(value) {
        var me = this;
        if (me.textFilterString != value) {
            me.textFilterString = Ext.String.trim(value);
            me.setFilters();
        }
    },
    /**
     * Обновляет элементы хранилища в соответствии с фильтрами
     */
    setFilters: function() {
        var me = this,
            filters = [];
        if (me.filterByLevel) {
            filters.push(new Ext.util.Filter({
                filterFn: function(item) {
                    var level = parseInt(ExGods.app.user.getLevel()),
                        proto = item.data.item_proto;
                    return level >= proto.data.data.strict.level;
                }
            }));
        }
        if (me.textFilterString) {
            filters.push(new Ext.util.Filter({
                filterFn: function(item) {
                    var itemTitle = item.data.item_proto.data.title;
                    return itemTitle.toLowerCase().indexOf(me.textFilterString.toLowerCase()) == -1 ? false : true;
                }
            }));
        }
        me.store.clearFilter();
        me.store.filter(filters);
        me.store.sort();
    },
    // ============= PRIVATES ====================
    /**
     * Готовит предметы к выдаче в шаблон
     */
    prepareData: function(data) {
        var newData = {};
        Ext.Array.each(data, function(item) {
            var proto = item.item_proto;
            var prices = [],
                new_price = [];
            if (data.new_price == '') {
                Ext.Array.each(data.price, function(price, index) {
                    prices.push(ExGods.util.Format.printMoney(price));
                });
            } else {
                Ext.Array.each(data.new_price.old, function(price, index) {
                    prices.push('<span class="old-price-wrap">' + ExGods.util.Format.printMoney(price) + '<span class="old-price-sub">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>');
                });
                Ext.Array.each(data.new_price['new'], function(price, index) {
                    new_price.push(ExGods.util.Format.printMoney(price));
                });
            }
            Ext.apply(newData, {
                count: data.params.unlimit ? '-1' : data.count,
                //image: proto.data.images.info || '',
                level: proto.data.data.strict.level,
                price: prices.join(' '),
                new_price: new_price.join(' '),
                message: data.message,
                title: proto.data.title || proto.label,
                grade: proto.data.data.item_grade || 1,
                item_id: data.kit ? data.kit : proto.data.entry,
                kit: Boolean(data.kit),
                qh_name: data.kit ? 'shop_item_kit' : 'shop_item'
            });
        });
        return newData;
    },
    /**
     * Обработчки "beforerefresh" у dataview
     */
    onBeforeRefresh: function() {
        var me = this;
        if (me.rendered) {
            ExGods.helpme.destroyComponents(me.el, me);
        }
    },
    /**
     * Обработчки "refresh" у dataview
     */
    onRefresh: function() {
        var me = this;
        ExGods.helpme.renderComponents(me.el, me);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var images = ExGods.ref('images|common_text_images').image;
        for (var i = 0; i < images.length; i++) {
            arr_images.push(images[i]);
        }
        for (var i = 0; i < me.store.data.items.length; i++) {
            var imgs = me.store.data.items[i].data.item_proto.data.images;
            for (var it in imgs) {
                arr_images.push(imgs[it]);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.arena.ArenaShop', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena_shop',
    id: 'arena_shop',
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser();
        me.shopView = {
            xtype: 'shop',
            height: 283,
            store: me.store
        };
        me.items = [
            me.shopView
        ];
        me.plugins = [
            {
                ptype: 'pager',
                marginLeft: -27,
                marginRight: -27,
                top: 127,
                textTop: 283,
                textLeft: 237,
                total: Math.ceil(me.store.getCount() / 6)
            }
        ];
        me.mon(me.store, 'datachanged', me.updatePager, me);
        me.on({
            next: me.showNextPage,
            prev: me.showPrevPage,
            scope: me
        });
        me.callParent();
    },
    // =============== PRIVATES ============================
    updateFilters: function(filterName, value) {
        var me = this,
            shopView = me.down('shop');
        if (filterName == 'level') {
            shopView.setFilterByLevel(value);
        } else if (filterName == 'text') {
            shopView.setTextFilter(value);
        }
        me.updatePager();
    },
    updatePager: function() {
        var me = this;
        if (!me.pager) {
            return;
        }
        me.pager.current = 1;
        me.pager.total = Math.ceil(me.store.getCount() / 6);
        me.pager.refresh();
    },
    showNextPage: function() {
        var me = this;
        me.openPage(-1);
        me.pager.refresh();
    },
    showPrevPage: function() {
        var me = this;
        me.openPage(1);
        me.pager.refresh();
    },
    openPage: function(direction) {
        var me = this,
            shopView = me.down('shop');
        ul = shopView.getEl().down('.shop-items') , marginTop = parseInt(ul.getStyle('margin-top').split('p')[0]) , offsetHeight = 282;
        ul.setStyle('margin-top', (marginTop + offsetHeight * direction) + 'px');
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'icons/done.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Контроллер арены
 *
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.Arena', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Arena:'
    },
    models: [
        'Arena'
    ],
    views: [
        'arena.Arena',
        'arena.EnemyList',
        'arena.Rating',
        'arena.ArenaShop'
    ],
    stores: [
        'ShopItems'
    ],
    tooltips: [
        'text'
    ],
    isArenaBattle: false,
    init: function() {
        var me = this;
        me.arenas = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.Arena',
            sorters: {
                property: 'l_order'
            },
            listeners: {
                datachanged: me.onArenasChanged,
                update: me.onArenaUpdate,
                scope: me
            }
        });
        me.arenaShopStore = Ext.create('ExGods.store.ShopItems');
        me.control({
            'textbutton[action="arena_queue"]': {
                click: me.onQueueButtonClick
            },
            'textbutton[action="arena_accept"]': {
                click: me.onAcceptButtonClick
            },
            'textbutton[action="arena_refuse"]': {
                click: me.onRefuseButtonClick
            },
            'textbutton[action="arena_revenge"]': {
                click: me.onRevengeButtonClick
            },
            'textbutton[action="arena_show_shop"]': {
                click: me.onShowShopClick
            },
            'battleresult': {
                close: me.showArena
            }
        });
        me.app.chatcn.on('command_arena', me.onArenaChatCommand, me);
        ExGods.Components.addComponentInitializer('arena', me.initArenaComponent, me);
    },
    /**
     * Создание комопнента для арены
     */
    initArenaComponent: function(config, componentId) {
        var me = this,
            cmp, store,
            items = [],
            icons = ExGods.ref('images|arena_icons').image,
            wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        /***/
        me.log('инициализация компонента "арена"');
        me.arenas.loadRawData(me.service.data.arenas);
        me.arenas.each(function(arena) {
            // табы арены
            items.push({
                xtype: 'arena',
                itemId: 'arena-' + arena.data.id,
                service: me.service,
                arena: arena,
                tabConfig: {
                    tooltip: arena.data.label,
                    icon: icons.arena_tab
                },
                clientObject: config
            });
            // var testData = {"success":1,"rand":0.119676300309074,"service_id":"84","service":{"arenas":[{"rating_top_list":{"success":1,"info":{"ro":"user","last_time":"2014-09-29 10:02:27","id":"16","type":"1","limit":100},"data":{"ranks":[{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"van_guard","display_title":"Валерий Другов","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"772","rank":1},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"Ната1","gender":"2","hoard":{"level":"5","rank":"1"},"online":"1"},"value":"723","rank":2},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"Клод79","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"695","rank":3},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"БешеныйХомяк","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"686","rank":4},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Алгул","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"670","rank":5},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"Полом","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"617","rank":6},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Сламерт","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"564","rank":7},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Ант","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"561","rank":8},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"кирпич","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"540","rank":9},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"хехе","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"522","rank":10},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"оно","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"504","rank":11},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"Луций Громовержец","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"499","rank":12},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"bear","display_title":"Серый волчок","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"485","rank":13},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Сабиночка","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"485","rank":13},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Vitalika","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"484","rank":15},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Varg","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"456","rank":16},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"tato","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"445","rank":17},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Warlk","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"442","rank":18},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Night Angel","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"442","rank":18},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"u001","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"441","rank":20},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Monkli","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"441","rank":20},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"тень","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"440","rank":22},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"ReQuieM","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"439","rank":23},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"хайджи","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"437","rank":24},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"davman","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"436","rank":25},{"info":{"race":"3","binding":{"battle":"1013816200","world":"2","room":"7"},"shape":"boar","display_title":"Барбарелла","gender":"2","hoard":{"level":"5","rank":"1"},"online":"1"},"value":"431","rank":26},{"info":{"race":"2","binding":{"battle":"1013816301","world":"2","room":"6"},"shape":"boar","display_title":"BlackMamba","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"430","rank":27},{"info":{"race":"3","binding":{"battle":"1013817201","world":"2","room":"7"},"shape":"boar","display_title":"XyliganAlex","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"429","rank":28},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Andal","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"429","rank":28},{"info":{"race":"3","binding":{"battle":"1013815500","world":"2","room":"7"},"shape":"boar","display_title":"Невозмутимый","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"426","rank":30},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Smilodon","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"418","rank":31},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"апрй","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"418","rank":31},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"A965","gender":"2","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"413","rank":33},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Игорьпанк","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"412","rank":34},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"AndRe","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"409","rank":35},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Микерин","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"391","rank":36},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"спиридон2014","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"390","rank":37},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"KapaAV","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"387","rank":38},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"kirpich","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"386","rank":39},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Virus1710","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"383","rank":40},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Jeanette","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"383","rank":40},{"info":{"race":"3","binding":{"battle":"1013216900","world":"2","room":"7"},"shape":"boar","display_title":"стрелец","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"378","rank":42},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"vlad","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"375","rank":43},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"pisyuha","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"372","rank":44},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"Силика","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"371","rank":45},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Тролль гнет ель","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"369","rank":46},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Вельга","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"367","rank":47},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Ness","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"366","rank":48},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"del301","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"364","rank":49},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"EvilFila","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"361","rank":50},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"х-АВАНТЮРИСТ-х","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"360","rank":51},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"Hayabusa","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"354","rank":52},{"info":{"race":"2","binding":{"battle":"1013817100","world":"2","room":"7"},"shape":"bear","display_title":"Игорь","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"350","rank":53},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Легкая","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"349","rank":54},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"bear","display_title":"Sykes","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"343","rank":55},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"red bull","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"342","rank":56},{"info":{"race":"3","binding":{"battle":"1013328500","world":"2","room":"6"},"shape":"boar","display_title":"Копченая","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"341","rank":57},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Granddoc","gender":"2","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"341","rank":57},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"КиЛЛеР в Тапках","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"336","rank":59},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"JUNK","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"332","rank":60},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Tarakan","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"328","rank":61},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"van_guard","display_title":"lionel2020","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"327","rank":62},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"kamelot","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"323","rank":63},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"alinth","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"323","rank":63},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"а77","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"315","rank":65},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"AlekseiChe","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"312","rank":66},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Devka","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"311","rank":67},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Soul","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"311","rank":67},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Дельфинка","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"309","rank":69},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"asfagen","gender":"2","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"309","rank":69},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"ВяЛыЙ ПеРеЦ","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"308","rank":71},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"Kowka-misti","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"307","rank":72},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"as_m","display_title":"Dar Veter","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"304","rank":73},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"Злобный Гений","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"303","rank":74},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"vit","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"302","rank":75},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Vasa1880","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"301","rank":76},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"bear","display_title":"LightStar","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"298","rank":77},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Володька","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"297","rank":78},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Кхорр","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"294","rank":79},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Шельга","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"292","rank":80},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"INSANE","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"288","rank":81},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"GRUV","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"286","rank":82},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Kasius","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"283","rank":83},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Zarazka","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"282","rank":84},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"налицио","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"282","rank":84},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"slepok","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"281","rank":86},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Мутный Тони","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"281","rank":86},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"rexwalker","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"280","rank":88},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"as_f","display_title":"Charlene","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"279","rank":89},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Den Desert Eagle","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"279","rank":89},{"info":{"race":"2","binding":{"battle":"1013817300","world":"2","room":"7"},"shape":"bear","display_title":"МУКАЧЕВО","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"276","rank":91},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Тойчик","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"273","rank":92},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Роман","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"270","rank":93},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Русский подорожник","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"270","rank":93},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"alex18181","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"269","rank":95},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"игорян12","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"268","rank":96},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"MaximFB","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"266","rank":97},{"info":{"race":"2","binding":{"battle":"1013815700","world":"2","room":"7"},"shape":"boar","display_title":"desatro","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"266","rank":97},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Живодер","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"265","rank":99},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Wimpex","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"261","rank":100}],"tag":"1","label":"Среди всех"}},"queue_time":null,"id":"3","l_order":"0","wait_queue":"10","elo_value":"281","ready_time":null,"can_unqueue":0,"description":"<strong>Сотня лучших бойцов</strong>, заработавших наибольшее количество трофеев на момент окончания <strong>сезона</strong>, <br /><strong>получит уникальную награду</strong> - <strong>маску Чемпиона</strong>.\n<div style=\"text-align: center;\"><br /> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1368\"><img src=\"http://img.exgods.ru/items/masks/as_assassin_male_1.jpg\" width=\"64\" height=\"64\" alt=\"Убийца Орлов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1369\"><img src=\"http://img.exgods.ru/items/masks/as_berserk_male_1.jpg\" width=\"64\" height=\"64\" alt=\"Берсерк Орлов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1370\"><img src=\"http://img.exgods.ru/items/masks/as_warrior_male_1.jpg\" width=\"64\" height=\"64\" alt=\"Воин Орлов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1379\"><img src=\"http://img.exgods.ru/items/masks/as_assassin_female_1.jpg\" width=\"64\" height=\"64\" alt=\"Убийца Орлов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1380\"><img src=\"http://img.exgods.ru/items/masks/as_berserk_female_1.jpg\" width=\"64\" height=\"64\" alt=\"Берсерк Орлов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1381\"><img src=\"http://img.exgods.ru/items/masks/as_warrior_female_1.jpg\" width=\"64\" height=\"64\" alt=\"Воин Орлов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1376\"><img src=\"http://img.exgods.ru/items/masks/van_assassin_male_1.jpg\" width=\"64\" height=\"64\" alt=\"Убийца Львов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1377\"><img src=\"http://img.exgods.ru/items/masks/van_berserk_male_1.jpg\" width=\"64\" height=\"64\" alt=\"Берсерк Львов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1378\"><img src=\"http://img.exgods.ru/items/masks/van_warrior_male_1.jpg\" width=\"64\" height=\"64\" alt=\"Воин Львов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1382\"><img src=\"http://img.exgods.ru/items/masks/van_assassin_female_1.jpg\" width=\"64\" height=\"64\" alt=\"Убийца Львов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1383\"><img src=\"http://img.exgods.ru/items/masks/van_berserk_female_1.jpg\" width=\"64\" height=\"64\" alt=\"Берсерк Львов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1384\"><img src=\"http://img.exgods.ru/items/masks/van_warrior_female_1.jpg\" width=\"64\" height=\"64\" alt=\"Воин Львов\" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl></div>","wait_ready":"30","elo_level":"1","foes":[{"elo_delta":"-2","elo_value":"723","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":"1","race":"2","add_time":"2014-09-28 18:09:16","shape":"werewolf","display_title":"Ната1","gender":"2","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-14","elo_value":"391","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-16 22:08:51","shape":"boar","display_title":"Микерин","gender":"1","hoard":{"level":"4","rank":"1"}},{"elo_delta":"-12","elo_value":"138","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-20 00:40:45","shape":"nidhegg","display_title":"Shargoh","gender":"1","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-2","elo_value":"670","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"2","add_time":"2014-09-28 00:15:57","shape":"boar","display_title":"Алгул","gender":"1","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-3","elo_value":"442","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-21 17:31:18","shape":"boar","display_title":"Warlk","gender":"1","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-6","elo_value":"383","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"2","add_time":"2014-09-21 14:09:27","shape":"bear","display_title":"Virus1710","gender":"1","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-5","elo_value":"441","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-22 22:11:54","shape":"boar","display_title":"Monkli","gender":"1","hoard":{"level":"4","rank":"1"}},{"elo_delta":"-3","elo_value":"686","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-23 21:47:59","shape":"werewolf","display_title":"БешеныйХомяк","gender":"1","hoard":{"level":"4","rank":"1"}},{"elo_delta":"-4","elo_value":"429","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-25 03:16:15","shape":"bear","display_title":"Andal","gender":"1","hoard":{"level":"4","rank":"1"}}],"finish_date":"2014-09-28 23:59:59","rating_info":{"value":"281","rank":86},"label":"Арена славы","stuff_refuse":{"stuff":[{"params":{"quantity":100,"id":"gold"},"type":"currency"}],"discount":0,"old":[{"params":{"quantity":100,"id":"gold"},"type":"2"}]},"season":"1"}]}};
            // табы списка врагов
            items.push({
                xtype: 'arena_enemylist',
                arena: arena.data,
                tabConfig: {
                    tooltip: ExGods.getMsgByKey('arena_tooltip_enemy_list'),
                    icon: icons.enemy_list_tab
                }
            });
            // табы рейтинга
            if (arena.data.rating_top_list && !Ext.Object.isEmpty(arena.data.rating_top_list.data)) {
                items.push({
                    xtype: 'arena_rating',
                    arena: arena.data,
                    list: arena.data.rating_top_list.data.ranks,
                    tabConfig: {
                        tooltip: ExGods.getMsgByKey('arena_tooltip_rating'),
                        icon: icons.rating_tab
                    }
                });
            }
            // таб магазина
            if (arena.data.shop_service) {
                items.push({
                    xtype: 'arena_shop',
                    shopService: arena.data.shop_service,
                    store: me.arenaShopStore,
                    tabConfig: {
                        tooltip: ExGods.getMsgByKey('arena_tooltip_shop'),
                        icon: icons.arena_shop_tab
                    }
                });
            }
        });
        Ext.apply(config, {
            rightPanelX: 250,
            closeCallback: function() {
                ExGods.loaderCt.loadAndRemove(function() {
                    wnd.close();
                }, {
                    img: config.backgroundImage
                });
            },
            margin: '0 10 10 0',
            items: [
                {
                    xtype: 'skintabpanel',
                    items: items,
                    width: 580,
                    height: 363,
                    y: 10,
                    x: 250,
                    plugins: [
                        'skindeco'
                    ],
                    closable: true,
                    listeners: {
                        beforeclose: {
                            fn: function() {
                                ExGods.loaderCt.loadAndRemove(function() {
                                    wnd.close();
                                }, {
                                    img: config.backgroundImage
                                });
                                return false;
                            }
                        },
                        tabchange: me.onTabChange,
                        scope: me
                    }
                },
                {
                    xtype: 'form',
                    x: 530,
                    y: 20,
                    width: 270,
                    height: 30,
                    layout: {
                        type: 'hbox',
                        pack: 'end'
                    },
                    tbar: {
                        xtype: 'panel',
                        bodyCls: 'parchment-content-nop',
                        bodyPadding: 0,
                        height: 30,
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        margin: '0 0 5 0',
                        defaults: {
                            margin: '0 1'
                        },
                        items: [
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('arena_search_empty_text'),
                                itemId: 'text-search',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: me.filterBySearch,
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            },
                            {
                                xtype: 'checkboxfield',
                                boxLabel: ExGods.getMsgByKey('view_shop_tabs_avail'),
                                checked: true,
                                hidden: true,
                                itemId: 'availability',
                                style: {
                                    color: '#e3ac69'
                                },
                                listeners: {
                                    change: function(f, value) {
                                        me.updateFilters('level', value);
                                    },
                                    scope: me
                                },
                                margin: '0 10 0 0'
                            },
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('view_shop_tabs_seachbyname'),
                                itemId: 'title',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: {
                                        fn: function(f, value) {
                                            me.updateFilters('text', value);
                                        },
                                        buffer: 100
                                    },
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            }
                        ]
                    }
                }
            ]
        });
        var cmp = Ext.apply({
                xtype: 'room'
            }, config);
        //  me.startTimersUpdate(); // выпилено
        wnd = Ext.widget('window1', {
            id: componentId,
            items: [
                cmp
            ],
            autoShow: false,
            /* 
            listeners: {
                close: function() {
                    me.stopTimersUpdate();
                },
                scope: me,
            },
            */
            /**
             * Ресурсы вью предзагрузка
             */
            getResources: function() {
                var me = this;
                var arr_images = [];
                return {
                    images: [
                        icons.arena_tab,
                        icons.arena_shop_tab,
                        icons.rating_tab,
                        icons.enemy_list_tab
                    ].concat(arr_images)
                };
            }
        });
        me.cmp = wnd.down('room');
        me.cmp.getArenaComponent = function(id) {
            if (this.rendered) {
                return this.items.items[0].getComponent('arena-' + id);
            }
        };
        ExGods.app.getController('Location').maskLocation(function() {
            // подгрузка ресурсов
            ExGods.Resources.load(wnd, function() {
                wnd.show();
                ExGods.app.getController('Location').unmaskLocation();
            });
        }, {
            img: config.backgroundImage
        });
        return wnd;
    },
    onArenasChanged: function() {
        var me = this;
        // догружаю прототипы предметов, если нужно
        ExGods.helpme.loadProtos(me.arenas.data, 'items.data.info.rival.slots.items.proto_id|items.data.info.rival.mask_proto_id', function() {
            if (me.cmp && me.cmp.rendered) {
                /***/
                me.log('Данные в хранилище изменились - обновляю компоненты');
                me.arenas.each(function(arena) {
                    var innerCmp = me.cmp.getArenaComponent(arena.get('id'));
                    if (innerCmp) {
                        innerCmp.update(arena.data);
                    } else {
                        /****/
                        me.log('warn', 'Компонент для арены "' + arena.get('id') + '" не найден');
                    }
                });
            }
        });
    },
    onArenaUpdate: function(store, arena) {
        var me = this;
        if (arena.data.state == 'start') {
            // просто блокирую кнопки и жду старта боя  
            me.setButtonsDisable([
                'accept',
                'refuse'
            ], true);
        } else {
            // догружаю прототипы предметов, если нужно
            ExGods.helpme.loadProtos(arena, 'data.info.rival.slots.items.proto_id|data.info.rival.mask_proto_id', function() {
                if (me.cmp && me.cmp.rendered) {
                    ExGods.Resources.load({
                        getResources: function() {
                            var stuff_arr = [];
                            if (arena.data.rival_stuff) {
                                stuff_arr = stuff_arr.concat(arena.data.rival_stuff);
                            }
                            return {
                                stuff: stuff_arr,
                                images: [
                                    arena.data.rival_image
                                ].concat(ExGods.util.User.getUserStatImages())
                            };
                        }
                    }, function() {
                        /***/
                        me.log('Данные по арене "' + arena.get('id') + '" изменились - обновляю компоненту');
                        var innerCmp = me.cmp.getArenaComponent(arena.get('id'));
                        if (innerCmp) {
                            innerCmp.update(arena.data);
                        } else {
                            /****/
                            me.log('warn', 'Компонент для арены "' + arena.get('id') + '" не найден');
                        }
                    });
                }
            });
        }
    },
    onQueueButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('встать в очередь на арену с id-', btn.arena_id);
        delete me.f_arena_queue_success;
        me.service.command('arena_queue', {
            id: btn.arena_id
        }, function(json) {
            if (!me.f_arena_queue_success) {
                if (json.success) {
                    me.arenas.loadRawData(json.arenas);
                }
            }
        });
    },
    onUnQueueButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('выйти из очереди на арену с id-', btn.arena_id);
        me.setButtonsDisable([
            'queue'
        ], true);
        me.service.command('arena_unqueue', {
            id: btn.arena_id
        }, function(json) {
            if (json.success) {
                me.arenas.loadRawData(json.arenas);
            } else {
                me.setButtonsDisable([
                    'queue'
                ], false);
            }
        });
    },
    onAcceptButtonClick: function(btn) {
        var me = this,
            arena;
        /***/
        me.log('принять вызов на арену с id-', btn.arena_id);
        me.setButtonsDisable([
            'accept',
            'refuse'
        ], true);
        me.service.command('arena_accept', {
            id: btn.arena_id
        }, function(json) {
            me.isArenaBattle = me.service.id;
            if (json.success) {
                // меняю статус арены на 'accept'
                arena = me.arenas.getById(btn.arena_id);
                if (arena) {
                    arena.set('state', 'accept');
                }
            } else {
                me.setButtonsDisable([
                    'accept',
                    'refuse'
                ], false);
            }
        });
    },
    onRefuseButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('дайте другого противника на арену с id-', btn.arena_id);
        me.setButtonsDisable([
            'accept',
            'refuse'
        ], true);
        delete me.f_arena_queue_success;
        me.service.command('arena_refuse', {
            id: btn.arena_id
        }, function(json) {
            if (json.success && !me.f_arena_queue_success) {
                me.arenas.loadRawData(json.arenas);
            } else {
                me.setButtonsDisable([
                    'accept',
                    'refuse'
                ], false);
            }
        });
    },
    onRevengeButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('месть на арене с id-', btn.arena_id);
        if (btn.can_revenge == 0)  {
            return;
        }
        
        me.setButtonsDisable([
            'revenge'
        ], true);
        me.service.command('arena_revenge', {
            id: btn.arena_id,
            title: btn.user_title
        }, function(json) {
            if (json.success) {} else // должен стартовать бой
            {
                me.setButtonsDisable([
                    'revenge'
                ], false);
            }
        });
    },
    onArenaChatCommand: function(chatcn, data) {
        var me = this,
            arena;
        /***/
        me.log('пришла команда чата "арена" с данными', data);
        arena = me.arenas.getById(data.body.id);
        if (arena) {
            data.body.data.state = data.body.state;
            Ext.apply(arena.raw, data.body.data);
            arena.setRawData(arena.raw);
            if (arena.get('message')) {
                me.application.fireEvent('logmessage', arena.get('message'));
            }
            /***/
            me.log('состояние арены после обновления - ', arena.get('state'));
            me.f_arena_queue_success = 1;
        }
    },
    onTabChange: function(panel, tab) {
        var me = this,
            form = me.cmp.items.findBy(function(item) {
                return item.xtype == 'form';
            }),
            searchField = form.down('#text-search'),
            shopTitleSearch = form.down('#title'),
            shopAvailability = form.down('#availability');
        if (tab.xtype == 'arena_enemylist' || tab.xtype == 'arena_rating') {
            searchField.el.select('input').elements[0].value = tab.textFilter || '';
            // восстанавливаю значение поиска для текущей вкладки
            searchField.show();
        } else {
            searchField.hide();
        }
        if (tab.xtype == 'arena_shop') {
            shopTitleSearch.el.select('input').elements[0].value = '';
            // восстанавливаю значение поиска для текущей вкладки
            shopTitleSearch.show();
            shopAvailability.show();
        } else {
            shopTitleSearch.hide();
            shopAvailability.hide();
        }
        if (tab.xtype == 'arena_enemylist' && !tab.list) {
            me.loadEnemyList(tab);
        }
        if (tab.xtype == 'arena_shop' && me.arenaShopStore.getCount() == 0) {
            me.updateShop(tab);
        }
    },
    updateFilters: function(filterName, value) {
        var me = this,
            shop = me.cmp.down('arena_shop');
        shop.updateFilters.apply(shop, arguments);
    },
    // подгружаю список врагов арены
    loadEnemyList: function(enemyListView) {
        var me = this;
        me.app.block();
        me.service.command('arena_get_foes', {}, function(resp) {
            me.app.unblock();
            if (resp && resp.result && resp.result.length) {
                enemyListView.setList(resp.result[0].foes);
            }
        });
    },
    updateShop: function(shopView) {
        if (typeof shopView.shopService != 'object') {
            shopView.shopService = ExGods.Services.factory(shopView.shopService);
        }
        shopView.shopService.init(null, function(service) {
            ExGods.helpme.loadProtos(service.data.shops[0].items, 'item.item', function() {
                shopView.store.loadRawData(service.data.shops[0].items);
            });
        });
    },
    filterBySearch: function(searchField) {
        var me = this,
            str = searchField.getValue(),
            tabs = me.cmp.query('tabpanel')[0],
            tab = tabs.getActiveTab();
        if (tab.setTextFilter) {
            tab.setTextFilter(str);
        }
    },
    setButtonsDisable: function(btnNames, disabled) {
        var me = this,
            query;
        if (me.cmp) {
            Ext.Array.each(btnNames, function(btn) {
                query = Ext.ComponentQuery.query('textbutton[action="arena_' + btn + '"]');
                if (query.length) {
                    query[0].setDisabled(disabled);
                }
            });
        }
    },
    onShowShopClick: function(btn) {
        var me = this,
            tabs = me.cmp.down('skintabpanel');
        tabs.setActiveTab('arena_shop');
    },
    showArena: function() {
        var me = this;
        if (me.isArenaBattle && ExGods.app.user.getSetting('reopen_interface') == 1) {
            ExGods.ClientActions.createAndInvoke({
                actionId: me.isArenaBattle
            }, null, function(err) {
                /***/
                me.log('error', err);
            });
            me.isArenaBattle = false;
        }
    },
    // startTimersUpdate: function() {
    //  var me = this,
    //      arenaViewEl,
    //      updateTimer = function(rooEl) {
    //          rootEl.select('.exg-timter').each(function(el) {
    //              if (!el.hasCls('exg-timer-expired')) {
    //                  var date = new Date(el.dom.getAttribute('data-value'));
    //                  var format = el.dom.getAttribute('data-format');
    //                  var restTime = Math.ceil((date - new Date()) / 1000);
    //                  if (restTime > 0) {
    //                      el.setHTML(ExGods.util.Time.printTime(restTime, {
    //                          format: format
    //                      }));
    //                  } else {
    //                      el.addCls('exg-timer-expired');
    //                      me.onTimerExpired();
    //                  }
    //              }
    //          });
    //      };
    //  /****/
    //  me.log('Запускаю обновление таймеров');
    //  me.timersUpdateInterval = setInterval(function() {
    //      if (arenaViewEl) {
    //          updateTimer(arenaViewEl)
    //      } else {
    //          arenaViewEl = me.cmp.getEl();
    //      }
    //  }, 1000);
    // },
    // stopTimersUpdate: function() {
    //  var me = this;
    //  /****/
    //  me.log('Останавливаю обновление таймеров');
    //  clearInterval(me.timersUpdateInterval);
    // },
    // onTimerExpired: function() {
    //  var me = this;
    //  me.service.update(null, function() {
    //      me.arenas.loadRawData(me.service.data.arenas);
    //      me.updateComponents();
    //      ExGods.app.unblock();
    //  });
    // },
    /**
     * Общий метод для обновления всех вью арены
     */
    updateComponents: function() {
        var me = this;
        // обновляю компонент арены
        me.arenas.each(function(arena) {
            var innerCmp = me.cmp.getArenaComponent(arena.get('id'));
            if (innerCmp) {
                innerCmp.update(arena.data);
            }
        });
    },
    /**
     * @private Тестовые данные юзера
     */
    get_user_test_data: function() {
        var u = {
                "msg": "",
                "success": 1,
                "rand": 0.101857223586318,
                "user_info": {
                    "moder": "10",
                    "achievements": [],
                    "binding": {
                        "battle": "0",
                        "world": "1",
                        "room": "1"
                    },
                    "contact": [],
                    "feature": [],
                    "public": {
                        "country": null,
                        "ii": {
                            "width": 150,
                            "date": "2012-11-23 14:40:50",
                            "height": 150
                        },
                        "name": null,
                        "motto": null,
                        "city": null,
                        "about": null,
                        "title": "юзер простой",
                        "birthday": null
                    },
                    "race": "1",
                    "gender": "1",
                    "timed": {
                        "hp": [
                            110,
                            110,
                            1
                        ],
                        "mp": [
                            100,
                            100,
                            5
                        ]
                    },
                    "stats": {
                        "stats": {
                            "stamina": 10,
                            "vitality": 2,
                            "peril": null,
                            "agility": 10,
                            "fury": 10,
                            "spirit": null,
                            "hard": 180,
                            "strength": 5
                        }
                    },
                    "social": {
                        "social_net_id": null,
                        "social_net": null
                    },
                    "can_mentor": null,
                    "can_pupil": "0",
                    "online": "1",
                    "counters": [
                        {
                            "params": {},
                            "entry": "1",
                            "ui": "doll",
                            "title": "Побед на Арене",
                            "conditions": {
                                "cg": "",
                                "c": "",
                                "t": ""
                            },
                            "summ": 9
                        },
                        {
                            "params": {},
                            "entry": "2",
                            "ui": "doll",
                            "title": "Ничьих на Арене",
                            "conditions": null,
                            "summ": 0
                        },
                        {
                            "params": {},
                            "entry": "3",
                            "ui": "doll",
                            "title": "Поражений на Арене",
                            "conditions": null,
                            "summ": 0
                        },
                        {
                            "params": {},
                            "entry": "4",
                            "ui": "doll",
                            "title": "Побед над монстрами",
                            "conditions": null,
                            "summ": 28
                        }
                    ],
                    "ratings": [],
                    "reg_date": "2012-05-30 11:08:03",
                    "title": "юзер простой",
                    "shape": "begin_m",
                    "gender_title": "Мужчина",
                    "slots": [
                        {
                            "name": "Амулет",
                            "ekey": "111",
                            "protect": "0",
                            "type": "13",
                            "items": []
                        },
                        {
                            "name": "Доспех",
                            "ekey": "113",
                            "protect": "0",
                            "type": "5",
                            "items": []
                        },
                        {
                            "name": "Кольцо",
                            "ekey": "114",
                            "protect": "0",
                            "type": "11",
                            "items": []
                        },
                        {
                            "name": "Наплечники",
                            "ekey": "117",
                            "protect": "0",
                            "type": "9",
                            "items": []
                        },
                        {
                            "name": "Оружие",
                            "ekey": "118",
                            "protect": "0",
                            "type": "1",
                            "items": []
                        },
                        {
                            "name": "Перчатки",
                            "ekey": "119",
                            "protect": "0",
                            "type": "10",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "119",
                                    "proto_id": "157",
                                    "param": {
                                        "dur": 78,
                                        "nonbr": 0
                                    },
                                    "item_id": "38"
                                }
                            ]
                        },
                        {
                            "name": "Пояс",
                            "ekey": "120",
                            "protect": "0",
                            "type": "6",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "120",
                                    "proto_id": "80",
                                    "param": {
                                        "dur": 76,
                                        "nonbr": 0
                                    },
                                    "item_id": "39"
                                }
                            ]
                        },
                        {
                            "name": "Сапоги",
                            "ekey": "121",
                            "protect": "0",
                            "type": "8",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "121",
                                    "proto_id": "91",
                                    "param": {
                                        "dur": 76,
                                        "nonbr": 0
                                    },
                                    "item_id": "40"
                                }
                            ]
                        },
                        {
                            "name": "Серьга",
                            "ekey": "122",
                            "protect": "0",
                            "type": "12",
                            "items": []
                        },
                        {
                            "name": "Шлем",
                            "ekey": "124",
                            "protect": "0",
                            "type": "2",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "124",
                                    "proto_id": "113",
                                    "param": {
                                        "dur": 76,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": "0"
                                    },
                                    "item_id": "41"
                                }
                            ]
                        },
                        {
                            "name": "Штаны",
                            "ekey": "125",
                            "protect": "0",
                            "type": "7",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "125",
                                    "proto_id": "168",
                                    "param": {
                                        "dur": 78,
                                        "nonbr": 0
                                    },
                                    "item_id": "42"
                                }
                            ]
                        },
                        {
                            "name": "Щит",
                            "ekey": "126",
                            "protect": "0",
                            "type": "4",
                            "items": []
                        },
                        {
                            "name": "Экипировка",
                            "ekey": "127",
                            "protect": "0",
                            "type": "3",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31507"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31508"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31509"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31515"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31516"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31517"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31518"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31519"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31520"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31521"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31522"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31523"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31533"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31534"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31535"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31536"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31537"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31558"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31559"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31560"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31573"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31574"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31575"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "36495"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "135",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "53133"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "58",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "53134"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56022"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56023"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56024"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56025"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56026"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56027"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56028"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56029"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56030"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "3",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "56031"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "56032"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "20",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "56033"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58289"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58292"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58320"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58428"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58429"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58430"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 37,
                                        "nonbr": 0
                                    },
                                    "item_id": "64144"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 37,
                                        "nonbr": 0
                                    },
                                    "item_id": "64145"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 98,
                                        "nonbr": 0
                                    },
                                    "item_id": "64146"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 37,
                                        "nonbr": 0
                                    },
                                    "item_id": "64147"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 98,
                                        "nonbr": 0
                                    },
                                    "item_id": "64148"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 37,
                                        "nonbr": 0
                                    },
                                    "item_id": "64149"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "64150"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "64151"
                                }
                            ]
                        },
                        {
                            "name": "Боевые артефакты и зелья",
                            "ekey": "128",
                            "protect": "0",
                            "type": "14",
                            "items": []
                        },
                        {
                            "name": "Боевые артефакты и зелья",
                            "ekey": "129",
                            "protect": "0",
                            "type": "14",
                            "items": []
                        },
                        {
                            "name": "Боевые артефакты и зелья",
                            "ekey": "130",
                            "protect": "0",
                            "type": "14",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "130",
                                    "proto_id": "180",
                                    "param": {
                                        "dur": 100,
                                        "item_value": null,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "58336"
                                },
                                {
                                    "action": null,
                                    "slot_id": "130",
                                    "proto_id": "180",
                                    "param": {
                                        "dur": 100,
                                        "item_value": null,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "58337"
                                },
                                {
                                    "action": null,
                                    "slot_id": "130",
                                    "proto_id": "180",
                                    "param": {
                                        "dur": 100,
                                        "item_value": null,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "58338"
                                },
                                {
                                    "action": null,
                                    "slot_id": "130",
                                    "proto_id": "180",
                                    "param": {
                                        "dur": 100,
                                        "item_value": null,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "58339"
                                }
                            ]
                        },
                        {
                            "name": "Кольцо",
                            "ekey": "131",
                            "protect": "0",
                            "type": "11",
                            "items": []
                        },
                        {
                            "name": "Серьга",
                            "ekey": "132",
                            "protect": "0",
                            "type": "12",
                            "items": []
                        }
                    ],
                    "hoard": {
                        "level": "5",
                        "rank": "7"
                    },
                    "display_title": "юзер простой"
                }
            };
        var stats = {
                "success": 1,
                "msg": "",
                "fit": {
                    "summary": {
                        "mass": 0
                    },
                    "rmodif": {
                        "antiabsorption": 0,
                        "mp_speed": 30000,
                        "damage": 0,
                        "mp_max": 0,
                        "antidodge": 0,
                        "dodge": 0,
                        "anticritical": 0,
                        "absorption": 0,
                        "shield_max": 0,
                        "capacity": 0,
                        "shield_speed": 0,
                        "critical": 0,
                        "hp_speed": 30000,
                        "hp_max": 0
                    },
                    "stats": {
                        "damage": 50,
                        "hp": 201,
                        "agility": 5,
                        "shield": 200,
                        "mp": 101,
                        "item_grade": 0,
                        "strength": 5002,
                        "stamina": 5,
                        "weightlift": 25,
                        "fury": 33,
                        "hard": 0,
                        "accuracy": 2
                    },
                    "shape": "boar",
                    "modif": {
                        "antiabsorption": 500200,
                        "mp_speed": 30101,
                        "damage": 50,
                        "mp_max": 101,
                        "antidodge": 500,
                        "dodge": 500,
                        "anticritical": 3300,
                        "absorption": 500,
                        "shield_max": 200,
                        "capacity": 25,
                        "shield_speed": 200,
                        "critical": 3300,
                        "hp_speed": 30201,
                        "hp_max": 201
                    }
                },
                "rand": 0.0935058950703045,
                "service_id": "137"
            };
        u.user_info.stats.stats = stats.fit.stats;
        return u;
    },
    /**
     * Реализация метода источника тултипов
     */
    getTooltipData: function(type, value) {
        var me = this,
            arena = me.arenas.first();
        if (type == 'text') {
            if (value == 'arena-series-descr') {
                return ExGods.app.applyTpl(ExGods.getMsgByKey('arena_series_descr'), arena.data.series);
            }
        }
    }
});

/**
 * Стандартное окно диалога. Не важно с кем предстоит общаться: ботом или предметом
 */
Ext.define('ExGods.view.arena2.Rules', {
    extend: Ext.panel.Panel,
    alias: 'widget.arenarules',
    cls: 'arena-rules',
    layout: 'fit',
    plugins: [
        'paperdeco'
    ],
    padding: '0 10 13',
    margin: 4,
    /**
     * @cfg arena {Object}
     */
    /**
     * @cfg clientConfig {Object}
     */
    initComponent: function() {
        var me = this;
        me.dockedItems = [
            {
                xtype: 'component',
                dock: 'top',
                html: [
                    '<div class="paper-title title">',
                    '<h4>' + me.clientConfig.rules_title + '</h4>',
                    '</div>',
                    '<div class="arena-rules-description">' + me.clientConfig.rules_description + '</div>',
                    '<div class="paper-separator"></div>',
                    '<div class="paper-title arena-rewards-title">',
                    '<h4>' + me.clientConfig.rewards_list_title + '</h4>',
                    '</div>'
                ]
            }
        ];
        me.store = Ext.create('Ext.data.Store', {
            fields: [
                'begin_place',
                'end_place',
                'prize'
            ],
            data: me.arena.reward_list,
            proxy: {
                type: 'memory'
            }
        });
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                items: [
                    {
                        xtype: 'dataview',
                        store: me.store,
                        autoEl: 'ul',
                        cls: 'arena-rules-rewards',
                        itemSelector: '.arena-rules-reward',
                        tpl: [
                            '<tpl for=".">',
                            '<li class="arena-rules-reward">',
                            '<div class="arena-rules-place"{[this.getStyle(values)]}>',
                            '<tpl if="begin_place &gt; 3">',
                            //'<div class="arena-rules-place-text">{[ExGods.app.applyTpl("' + me.clientConfig.rules_place_tpl + '",values)]}</div>',
                            '{[this.printPlace(values)]}',
                            '</tpl>',
                            '</div>',
                            '{[ExGods.stuff.StuffManager.image(values.prize)]}',
                            '</li>',
                            '</tpl>',
                            {
                                getStyle: function(values) {
                                    if (values.begin_place >= 1 && values.begin_place <= 3) {
                                        //для первых 3-х мест отображаю картинку с местом
                                        return ' style="background-image: url(' + ExGods.ref('images|rating_place_icons').image['place' + values.begin_place] + ')"';
                                    }
                                },
                                printPlace: function(values) {
                                    if (values.begin_place != values.end_place) {
                                        return [
                                            ExGods.util.Sprite.printSprite(values.begin_place, 'arena/place_numbers.png', {
                                                width: 10,
                                                height: 24,
                                                indent: '-5px',
                                                cls: 'inlineblock'
                                            }),
                                            '<div class="place-dash"></div>',
                                            ExGods.util.Sprite.printSprite(values.end_place, 'arena/place_numbers.png', {
                                                width: 10,
                                                height: 24,
                                                indent: '-5px',
                                                cls: 'inlineblock'
                                            }),
                                            '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>'
                                        ].join('');
                                    } else {
                                        return ExGods.util.Sprite.printSprite(values.begin_place, 'arena/place_numbers.png', {
                                            width: 10,
                                            height: 24,
                                            indent: '-5px',
                                            cls: 'inlineblock'
                                        }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                                    }
                                }
                            }
                        ]
                    }
                ]
            }
        ];
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [];
        var arr_images = [];
        for (var i = 0; i < me.arena.reward_list.length; i++) {
            for (var j = 0; j < me.arena.reward_list[i].prize.length; j++) {
                stuff_arr.push(me.arena.reward_list[i].prize[j]);
            }
        }
        return {
            stuff: stuff_arr,
            images: [
                IMAGE_URL + 'arena/place_numbers.png',
                IMAGE_URL + ExGods.getMsgByKey('place_img')
            ].concat(arr_images)
        };
    }
});

/**
 * Арена - показывает правила арены и позволяет подобрать себе врага
 */
Ext.define('ExGods.view.arena2.Arena', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena2',
    plugins: [
        'paperdeco'
    ],
    /**
     * @cfg {Object} arena Данные арены
     */
    arena: {},
    /**
     * @cfg {Object} service Сервис арены
     */
    service: {},
    cls: 'arena arenaview arena2',
    /**
     * @cfg clientConfig {Object} Конфигурация компонента из справочника Клиент-Объекты
     */
    clientConfig: {},
    //скорость автоматичекого увеличения
    animationSpeed: 1000,
    //ms
    initComponent: function() {
        var me = this;
        me.data = me.arena;
        me.tpl = [
            '<div class="section section1">',
            '<div class="paper-title title">',
            '<tpl if="this.hasShopItems() || this.hasArenaShop()">',
            '<h4>' + ExGods.getMsgByKey('arena_hint_title') + '</h4>',
            '<tpl else>',
            '<h4>' + me.clientConfig.enemy_search_title + '</h4>',
            '</tpl>',
            '</div>',
            '<div class="content"><div style="text-align: center">',
            '<tpl if="this.isQueueState(values)">',
            '<div class="queue-timer" id="arena2-queue-time">',
            '{[this.printQueuePercent(values)]}',
            '{[this.printQueueTime(values)]}',
            '<div class="queue-separators"></div>',
            '</div>',
            '<tpl elseif="this.hasShopItems() || this.hasArenaShop()">',
            '<p class="hint">',
            ExGods.getMsgByKey('arena_hint_text'),
            '</p>',
            '<tpl if="this.getHasShopItems().length">',
            '<ul class="shop-items-list exg-share-bg-dark">',
            '<tpl foreach="this.getHasShopItems()">',
            '<li class="shop-items-list-item" data-id="{id}" style="background-image: url(' + IMAGE_URL + '{desc.img});"><div>{[this.printHasItemEndTimed(values.end)]}</div></li>',
            '</tpl>',
            '</ul>',
            '<tpl else>',
            '<div class="no-shop-items exg-share-bg-dark">',
            ExGods.getMsgByKey('arena_has_no_items_text'),
            '</div>',
            '</tpl>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena2_show_shop</span>',
            '<span role="text">',
            ExGods.getMsgByKey('arena_go_shop_btn_title'),
            '</span>',
            '<span role="cls">x-btn-text double_text_btn goto-shop-btn</span>',
            '<span role="flex:int">1</span>',
            '<span role="margin">3 5 0 0</span>',
            '<span role="width">116px</span>',
            '<span role="disabled:bool">{[!this.hasArenaShop()]}</span>',
            '</div>',
            '<tpl else>',
            '<div class="queue-timer"></div>',
            '</tpl>',
            '</div>',
            '</div>',
            '</div>',
            '<div class="v-separator"></div>',
            '<div class="section section2" style="height: 179px;">',
            '<div class="paper-title title">',
            '<h4>{[this.printArenaTitle(values)]}</h4>',
            '</div>',
            '<div class="content">',
            '<div>' + me.clientConfig.your_place_title + '</div>',
            '<div class="arena2-current-place exg-share-bg-dark">{[this.printCurrentPlace(values)]}</div>',
            '<tpl if="time_to_reward">',
            '<div>' + me.clientConfig.your_reward_title + '</div>',
            '<div class="exg-share-bg-dark">',
            '{[this.printRewards(values)]}',
            '</div>',
            '<div>{[this.printNextPlace(values)]}</div>',
            '<tpl else>',
            '<div>',
            me.clientConfig.no_rating_description,
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            '<div class="separator separator2"></div>',
            '<div class="section section4">',
            '<div class="content">',
            '<span class="description">' + me.clientConfig.rules_short_description + '</div>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena2_show_rules</span>',
            '<span role="text">',
            me.clientConfig.rules_button_text,
            '</span>',
            '<span role="cls">x-btn-text double_text_btn arena-rules-btn</span>',
            '<span role="flex:int">1</span>',
            '<span role="width">116px</span>',
            '</div>',
            '<div class="v-separator"></div>',
            '<tpl if="this.isQueueState(values)">',
            '<div class="component battle-btn">',
            '<tpl else>',
            '<div class="component battle-btn qh-object" data-qh_otype="arena_button_battle" data-qh_oid="1">',
            '</tpl>',
            '<span role="xtype">timedtimer</span>',
            '<span role="timed">{[this.getTimedName(values)]}</span>',
            '<span role="quantity">{[this.getTimedValue(values)]}</span>',
            '<span role="is_disabled:bool">{[this.isQueueState(values) || values.current_place == 1]}</span>',
            '<span role="textbutton">',
            '<span role="action">arena2_queue</span>',
            '</span>',
            '</div>',
            '</div>',
            '</div>',
            {
                getTimedName: function(values) {
                    var cost = values.cost_battle ? values.cost_battle[0] : undefined;
                    return cost ? cost.params.id : null;
                },
                getTimedValue: function(values) {
                    var cost = values.cost_battle ? values.cost_battle[0] : undefined;
                    return cost ? cost.params.quantity : null;
                },
                printRewards: function(values) {
                    var rewards = me.service.getRewardByPlace(values.current_place);
                    if (rewards) {
                        return ExGods.stuff.StuffManager.image(rewards);
                    }
                },
                printNextPlace: function(values) {
                    if (!values.next_range_place) {
                        return me.clientConfig.next_place_max_text;
                    } else {
                        return ExGods.app.applyTpl(me.clientConfig.next_place_text, {
                            place: values.current_place - values.next_range_place
                        });
                    }
                },
                printCurrentPlace: function(values) {
                    if (values.current_place > 3) {
                        return ExGods.util.Sprite.printSprite(values.current_place, 'arena/place_numbers.png', {
                            width: 10,
                            height: 24,
                            indent: '-5px',
                            cls: 'inlineblock'
                        }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                    } else {
                        return '<img src="' + ExGods.ref('images|rating_place_icons').image['place' + values.current_place] + '" />';
                    }
                },
                printArenaTitle: function(values) {
                    var tpl;
                    if (values.time_to_reward) {
                        tpl = me.clientConfig.time_to_reward_tpl;
                    } else {
                        tpl = me.clientConfig.no_time_to_reward_tpl;
                    }
                    return ExGods.app.applyTpl(tpl, {
                        time: ExGods.util.Timers.printRestTimer('arenatitle', Date.now() + values.time_to_reward * 1000)
                    });
                },
                hasArenaShop: function() {
                    return me.service.data.arena_shop.service_id;
                },
                hasShopItems: function() {
                    return me.service.data.arena_shop.has.length;
                },
                getHasShopItems: function() {
                    return me.service.data.arena_shop.has;
                },
                printHasItemEndTimed: function(date) {
                    if (date) {
                        date = ExGods.util.Date.normalizeServerDateTime(date);
                        return '<span class="exg-timer" data-date="' + date + '" data-format="twonums">' + ExGods.util.Time.printRestTime(date, {
                            format: 'twonums'
                        }) + '</span>';
                    }
                },
                isQueueState: function(data) {
                    return data.status == 'search_process';
                },
                printQueueTime: function(data) {
                    var queueDate = ExGods.util.Date.normalizeServerDateTime(data.search_start),
                        queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), data.search_time);
                    x = (queueTime % 9) * 103 + 36 , y = Math.floor(queueTime / 9) * 104 + 36;
                    return '<div class="queue-timer-value" style="background-position:-' + x + 'px -' + y + 'px"></div>';
                },
                printQueuePercent: function(data) {
                    var queueDate = ExGods.util.Date.normalizeServerDateTime(data.search_start),
                        queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), data.search_time);
                    queuePercent = Math.min(Math.floor(queueTime * 100 / data.search_time), 100) , x = (queuePercent % 9) * 103 + 10 , y = Math.floor(queuePercent / 9) * 104 + 10;
                    return '<div class="queue-timer-counter" style="background-position:-' + x + 'px -' + y + 'px"></div>';
                }
            }
        ];
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me, {
            single: true
        });
        // клик по картинке купленной услуги
        me.getEl().on('click', function(e) {
            var el = e.getTarget(),
                itemId = el.getAttribute('data-id'),
                itemInfo;
            itemInfo = Ext.Array.findBy(me.service.data.arena_shop.has, function(item) {
                return item.id == itemId;
            });
            Ext.widget('commondetailswindow', {
                itemElement: el,
                data: {
                    label: itemInfo.desc.label,
                    description: itemInfo.desc.description,
                    image: IMAGE_URL + itemInfo.desc.img
                }
            });
        }, me, {
            delegate: '.shop-items-list-item'
        });
        ExGods.util.Ticker.addListener(me.updateQueueTime, me);
    },
    update: function(data) {
        var me = this;
        if (me.rendered) {
            ExGods.util.Helper.destroyComponents(me.el);
        }
        me.arena = data;
        me.callParent(arguments);
        if (me.rendered) {
            ExGods.util.Helper.renderComponents(me.el, me);
        }
    },
    updateQueueTime: function() {
        var me = this,
            viewEl = me.getEl(),
            queueDate, queueTime, queuePercent, el, val_el;
        if (me.arena.status == 'search_process') {
            queueDate = ExGods.util.Date.normalizeServerDateTime(me.arena.search_start);
            //queueTime = Math.max(0, me.arena.search_time*1000 - (Date.now() - queueDate));
            queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), me.arena.search_time);
            queuePercent = Math.min(Math.floor(queueTime * 100 / me.arena.search_time), 99);
            if (viewEl) {
                el = viewEl.select('.queue-timer-counter');
                val_el = viewEl.select('.queue-timer-value');
                var x = (queuePercent % 9) * 103 + 10,
                    y = Math.floor(queuePercent / 9) * 104 + 10,
                    val_x = (queueTime % 9) * 103 + 36,
                    val_y = Math.floor(queueTime / 9) * 104 + 36;
                el.setStyle('background-position', '-' + x + 'px -' + y + 'px');
                val_el.setStyle('background-position', '-' + val_x + 'px -' + val_y + 'px');
            }
        }
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateQueueTime);
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [];
        var arr_images = [];
        if (me.data.cost_battle) {
            stuff_arr = stuff_arr.concat(me.data.cost_battle);
        }
        /*
        if (me.data.cost_search) {
            stuff_arr = stuff_arr.concat(me.data.cost_search);
        }
        */
        var places = ExGods.ref('images|rating_place_icons').image;
        for (var i in places) {
            arr_images.push(places[i]);
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [
                IMAGE_URL + 'button-text-30.png',
                IMAGE_URL + 'btn_wide_red.png',
                IMAGE_URL + ExGods.getMsgByKey('place_img')
            ].concat(arr_images)
        };
    }
});

/**
 * Список врагов на арене
 */
Ext.define('ExGods.view.arena2.EnemyList', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena2_enemylist',
    layout: 'hbox',
    cls: 'robbery arena2 enemy-list',
    padding: '0 8',
    initComponent: function() {
        var me = this;
        me.items = [];
        Ext.Array.each(me.arena.enemy.users, function(user) {
            me.items.push({
                xtype: 'arena2_enemy',
                user: user,
                clientConfig: me.clientConfig,
                arena: me.arena,
                service: me.service
            });
        });
        me.dockedItems = [
            {
                dock: 'bottom',
                xtype: 'toolbar',
                layout: {
                    pack: 'center'
                },
                margin: '0 0 8',
                items: [
                    {
                        xtype: 'textbutton',
                        text: me.clientConfig.enemy_list_refresh_btn,
                        action: 'arena2_refresh'
                    }
                ]
            }
        ];
        me.callParent();
    },
    updateView: function(data) {
        var me = this;
        me.arena = data;
        me.removeAll();
        var arr_images = [];
        Ext.Array.each(me.arena.enemy.users, function(user) {
            var img = ExGods.ref('user_shape|' + user.shape).thumb;
            arr_images.push(img);
        });
        var wdgts = [];
        Ext.Array.each(me.arena.enemy.users, function(user) {
            wdgts.push(Ext.widget('arena2_enemy', {
                user: user,
                autoShow: false,
                clientConfig: me.clientConfig,
                arena: me.arena,
                service: me.service
            }));
        });
        ExGods.Resources.load({
            items: {
                items: wdgts
            },
            getResources: function() {
                return {
                    images: [].concat(arr_images)
                };
            }
        }, function() {
            me.add(wdgts);
        });
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: []
        };
    }
});

Ext.define('ExGods.view.arena2.Container', {
    extend: Ext.container.Container,
    alias: 'widget.arena2container',
    id: 'arena2_container',
    layout: 'card'
});

/**
 * Рейтинг на арене
 */
Ext.define('ExGods.view.arena2.Rating', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena_rating2',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'arena rating',
    itemsPerPage: 7,
    textFilter: '',
    /**
     * @cfg {Object} arena Данные арены
     */
    arena: {},
    /**
     * @cfg {Array} list Рейтинг
     */
    list: [],
    initComponent: function() {
        var me = this;
        // сортирую по ранку
        me.list = Ext.Array.sort(me.list, function(a, b) {
            return a.rank - b.rank;
        });
        me.items = [
            {
                xtype: 'container',
                plugins: [
                    'paperdeco'
                ],
                height: 284,
                items: [
                    {
                        itemId: 'list',
                        tpl: [
                            '<div class="paper-title title">',
                            '<tpl if="arena.season">',
                            '<h4>{[this.applyTitleTpl(values.arena)]}</h4>',
                            '<tpl else >',
                            '<h4>{[this.applyNoSeasonTpl(values.arena)]}</h4>',
                            '</tpl>',
                            '</div>',
                            '<div class="subtitle">{[this.applyTrophyTpl(values.arena)]}</div>',
                            '<div class="separator"></div>',
                            '<tpl if="list.length">',
                            '<table class="list">',
                            '<tpl for="list">',
                            '<tr class="{[ xindex % 2 ? "exg-share-bg-light" : "exg-share-bg-dark" ]}">',
                            '<td class="place-cell">',
                            '<tpl if="rank &gt;= 1 && rank &lt;= 3">',
                            '<div class="place-{rank}"><img width="76" height="24" src="{[ this.getPlaceImage(values.rank) ]}"></div>',
                            '<tpl else>',
                            '<span>{[this.printPlace(values.rank)]}</span>',
                            '</tpl>',
                            '</td>',
                            '<td class="username-cell">',
                            '{[ ExGods.printUser(values.info, {fields: "guild,name,rank,level,infoicon", maxNameWidth: 112}) ]}',
                            '</td>',
                            '</tr>',
                            '</tpl>',
                            '</table>',
                            '<tpl else>',
                            '<div class="empty-msg">' + ExGods.ref('message_client|arena_rating_empty_msg') + '</div>',
                            '</tpl>',
                            {
                                applyTitleTpl: function(arena) {
                                    var restTime = '<span id="arena-rating-rest-time-' + arena.id + '">' + ExGods.util.Time.printRestTime(ExGods.util.Date.normalizeServerDateTime(arena.finish_date), {
                                            format: 'threenums',
                                            emptyText: ExGods.getMsgByKey('arena_season_finish_msg')
                                        }) + '</span>';
                                    return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_title'), {
                                        season: arena.season,
                                        time: restTime
                                    });
                                },
                                applyNoSeasonTpl: function(arena) {
                                    return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_no_season_title'), {
                                        label: arena.label
                                    });
                                },
                                applyTrophyTpl: function(arena) {
                                    if (arena.rating_info && arena.rating_info.value && arena.rating_info.rank) {
                                        var params = {
                                                place: arena.rating_info.rank,
                                                trophy: this.printTrophy(arena.rating_info.value) + Ext.util.Format.plural(arena.rating_info.value, ExGods.getMsgByKey('trophy_name').split(','))
                                            };
                                        if (arena.rating_top_list) {
                                            return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace'), Ext.apply({
                                                time: this.printDate(arena.rating_top_list.info.last_time)
                                            }, params));
                                        } else {
                                            return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace_no_time'), params);
                                        }
                                    } else if ((arena.elo_value || arena.elo_value == 0) && arena.rating_info && arena.rating_info.value != null) {
                                        var trophy = this.printTrophy(arena.rating_info.value) + Ext.util.Format.plural(arena.rating_info.value, ExGods.getMsgByKey('trophy_name').split(','));
                                        return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace_after_season'), {
                                            trophy: trophy
                                        });
                                    } else {
                                        return ExGods.getMsgByKey('view_arena_rating_curplace_no_trophy');
                                    }
                                },
                                printTrophy: function(num) {
                                    return '<span class="trophy-num">' + num + '</span>';
                                },
                                printDate: function(dateStr) {
                                    var dt = ExGods.util.Date.normalizeServerDateTime(dateStr);
                                    return Ext.Date.format(dt, 'd.m.Y H:i');
                                },
                                getPlaceImage: function(rank) {
                                    return ExGods.ref('images|rating_place_icons').image['place' + rank];
                                },
                                printPlace: function(place) {
                                    return ExGods.util.Sprite.printSprite(place, 'arena/place_numbers.png', {
                                        width: 10,
                                        height: 24,
                                        indent: '-5px',
                                        cls: 'inlineblock'
                                    }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                                }
                            }
                        ],
                        data: {
                            arena: me.arena,
                            list: me.list.slice(0, me.itemsPerPage)
                        }
                    }
                ]
            }
        ];
        me.plugins = me.plugins || [];
        me.plugins.push({
            ptype: 'pager',
            marginLeft: -27,
            marginRight: -27,
            top: 127,
            textTop: -32,
            textLeft: 249,
            total: Math.ceil(me.list.length / me.itemsPerPage)
        });
        me.listeners = {
            prev: me.updateList,
            next: me.updateList,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        ExGods.util.Ticker.addListener(me.updateRestTime, me);
    },
    updateRestTime: function() {
        if (!this.arena.finish_date) {
            return;
        }
        var me = this,
            viewEl = me.getEl(),
            finishDate = ExGods.util.Date.normalizeServerDateTime(me.arena.finish_date),
            el;
        if (viewEl) {
            el = viewEl.select('#arena-rating-rest-time-' + me.arena.id);
            el.setHTML(ExGods.util.Time.printRestTime(finishDate, {
                format: 'threenums',
                emptyText: ExGods.ref('message_client|arena_season_finish_msg')
            }));
        }
    },
    updateList: function() {
        var me = this,
            items = me.filtered || me.list;
        items = items.slice((me.pager.current - 1) * me.itemsPerPage, me.pager.current * me.itemsPerPage);
        me.items.items[0].getComponent('list').update({
            arena: me.arena,
            list: items
        });
        me.pager.refresh();
    },
    setTextFilter: function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        if (me.textFilter) {
            me.filtered = Ext.Array.filter(me.list, function(item) {
                return (item.info.display_title).toLowerCase().indexOf(me.textFilter) != -1;
            });
            me.pager.total = Math.ceil(me.filtered.length / me.itemsPerPage);
        } else {
            delete me.filtered;
            me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        }
        me.pager.current = 1;
        me.updateList();
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateRestTime);
        me.callParent(arguments);
    }
});

/**
 * Отображение конкретного врага на арене
 */
Ext.define('ExGods.view.arena2.Enemy', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena2_enemy',
    cls: 'arena enemy-info',
    plugins: [
        'paperdeco'
    ],
    height: 274,
    width: 188,
    padding: '7 10',
    initComponent: function() {
        var me = this;
        me.data = me.user;
        me.tpl = [
            '<div class="exg-share-base-info exg-share-bg-light gender-{gender}" style="background-image: url({[ this.getUserImage(values) ]})">',
            '<span>{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank", maxNameWidth: 84})]}</span>',
            '<tpl if="guild">',
            '<span class="bold">[{guild.tag}]</span>',
            '</tpl>',
            //'<div class="arena-enemy-power">{stats.power}</div>',
            '<div class="image-frame"></div>',
            '</div>',
            '<div class="paper-separator"></div>',
            '<h5 class="exg-share-bg-dark">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</h5>',
            '<div class="stats1">',
            '{[ ExGods.util.User.printUserStats(values.stats, {visibleValue: 1, align: "right", changes: this.getStatsChanges(values)}) ]}',
            '</div>',
            '<div class="paper-separator"></div>',
            '<div class="arena-enemy-place">{[this.printPlace(values)]}</div>',
            {
                getUserImage: function(values) {
                    return ExGods.ref('user_shape|' + values.shape).thumb;
                },
                getStatsChanges: function(values) {
                    var changes = {},
                        myStats = ExGods.app.user.get('stats').stats;
                    Ext.Object.each(values.stats, function(k, v) {
                        if (typeof myStats[k] != 'undefined') {
                            changes[k] = v - myStats[k];
                        }
                    });
                    return changes;
                },
                printPlace: function(values) {
                    return ExGods.util.Sprite.printSprite(values.arena2_place, 'arena/place_numbers.png', {
                        width: 10,
                        height: 24,
                        indent: '-5px',
                        cls: 'inlineblock'
                    }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                }
            }
        ];
        me.dockedItems = [
            {
                dock: 'bottom',
                xtype: 'textbutton',
                text: me.clientConfig.attack_btn,
                cls: 'no_border x-btn-txt-red',
                margin: '0 25 15 25',
                action: 'arena2_attack',
                user_title: me.user.display_title
            }
        ];
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var img = ExGods.ref('user_shape|' + me.data.shape).thumb;
        return {
            images: [
                img,
                IMAGE_URL + ExGods.getMsgByKey('place_img')
            ].concat(arr_images)
        };
    }
});

/**
 * Контроллер арены
 *
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.Arena2', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Arena2:'
    },
    models: [
        'Arena'
    ],
    views: [
        'arena2.Arena',
        'arena2.Container',
        'arena2.Rating',
        'arena2.Rules',
        'arena2.EnemyList',
        'arena2.Enemy',
        'arena.ArenaShop'
    ],
    stores: [
        'ShopItems'
    ],
    tooltips: [
        'text'
    ],
    isArenaBattle: false,
    init: function() {
        var me = this;
        me.arenaShopStore = Ext.create('ExGods.store.ShopItems');
        me.control({
            'textbutton[action="arena2_queue"]': {
                click: me.onQueueButtonClick
            },
            'textbutton[action="arena2_attack"]': {
                click: me.onAttackButtonClick
            },
            'textbutton[action="arena2_refresh"]': {
                click: me.onRefreshButtonClick
            },
            'textbutton[action="arena2_show_shop"]': {
                click: me.onShowShopClick
            },
            'textbutton[action="arena2_show_rules"]': {
                click: me.onShowRulesClick
            }
        });
        me.app.chatcn.on('command_refresh_arena2', me.onArenaChatCommand, me);
        ExGods.Components.addComponentInitializer('arena2', me.initArenaComponent, me);
        ExGods.util.Timers.on('arenatitle-expire', me.onTimerExpired, me);
    },
    /**
     * Создание комопнента для арены
     */
    initArenaComponent: function(config, componentId) {
        var me = this,
            items = [],
            wnd,
            icons = ExGods.ref('images|arena_icons').image;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        me.arena = me.service.data.arena;
        me.clientConfig = config;
        // табы арены
        items.push({
            xtype: 'arena2container',
            service: me.service,
            arena: me.arena,
            tabConfig: {
                tooltip: me.arena.label,
                icon: icons.arena_tab
            },
            clientConfig: config
        });
        // табы рейтинга
        if (me.arena.rating_top_list && !Ext.Object.isEmpty(me.arena.rating_top_list.data)) {
            items.push({
                xtype: 'arena_rating',
                arena: me.arena,
                list: me.arena.rating_top_list.data.ranks,
                tabConfig: {
                    tooltip: ExGods.getMsgByKey('arena_tooltip_rating'),
                    icon: icons.rating_tab
                },
                clientConfig: config
            });
        }
        // таб магазина
        if (me.service.data.arena_shop.service_id) {
            items.push({
                xtype: 'arena_shop',
                shopService: me.service.data.arena_shop.service_id,
                store: me.arenaShopStore,
                tabConfig: {
                    tooltip: ExGods.getMsgByKey('arena_tooltip_shop'),
                    icon: icons.arena_shop_tab
                },
                clientConfig: config
            });
        }
        var closeCallback = function() {
                ExGods.loaderCt.loadAndRemove(function() {
                    wnd.close();
                }, {
                    img: config.backgroundImage
                });
            };
        Ext.apply(config, {
            rightPanelX: 250,
            closeCallback: closeCallback,
            margin: '0 10 10 0',
            items: [
                {
                    xtype: 'skintabpanel',
                    items: items,
                    width: 580,
                    height: 363,
                    y: 10,
                    x: 250,
                    plugins: [
                        'skindeco'
                    ],
                    closable: true,
                    listeners: {
                        beforeclose: {
                            fn: function() {
                                closeCallback();
                                return false;
                            }
                        },
                        tabchange: me.onTabChange,
                        scope: me
                    }
                },
                {
                    xtype: 'form',
                    x: 530,
                    y: 20,
                    width: 270,
                    height: 30,
                    layout: {
                        type: 'hbox',
                        pack: 'end'
                    },
                    tbar: {
                        xtype: 'panel',
                        bodyCls: 'parchment-content-nop',
                        bodyPadding: 0,
                        height: 30,
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        margin: '0 0 5 0',
                        defaults: {
                            margin: '0 1'
                        },
                        items: [
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('arena_search_empty_text'),
                                itemId: 'text-search',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: me.filterBySearch,
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            },
                            {
                                xtype: 'checkboxfield',
                                boxLabel: ExGods.getMsgByKey('view_shop_tabs_avail'),
                                checked: true,
                                hidden: true,
                                itemId: 'availability',
                                style: {
                                    color: '#e3ac69'
                                },
                                listeners: {
                                    change: function(f, value) {
                                        me.updateFilters('level', value);
                                    },
                                    scope: me
                                },
                                margin: '0 10 0 0'
                            },
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('view_shop_tabs_seachbyname'),
                                itemId: 'title',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: {
                                        fn: function(f, value) {
                                            me.updateFilters('text', value);
                                        },
                                        buffer: 100
                                    },
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            }
                        ]
                    }
                }
            ]
        });
        var cmp = Ext.apply({
                xtype: 'room'
            }, config);
        wnd = Ext.widget('window1', {
            itemId: componentId,
            items: [
                cmp
            ],
            autoShow: false,
            listeners: {
                close: function() {
                    me.enemiesCard = null;
                    me.searchCard = null;
                },
                scope: me
            }
        });
        me.cmp = wnd.down('room');
        me.cmp.getArenaComponent = function(id) {
            if (this.rendered) {
                return this.items.items[0].getComponent('arena-' + id);
            }
        };
        var all_stuff = Ext.Array.clean(Ext.Array.union(Ext.Array.union.apply(Ext.Array, Ext.Array.map(me.arena.reward_list, function(el) {
                return el.prize;
            })), me.arena.cost_battle, me.arena.cost_search));
        ExGods.app.getController('Location').maskLocation(function() {
            ExGods.helpme.loadProtosFromStuff(all_stuff, function() {
                // подгрузка ресурсов
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    me.updateViews();
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.backgroundImage
        });
        return wnd;
    },
    onQueueButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('встать в очередь на арену с id-', btn.arena_id);
        delete me.f_arena_queue_success;
        me.service.command('arena2_search', {
            id: 2
        }, function(json) {
            if (!me.f_arena_queue_success && json.success) {
                me.arena = json.info;
                me.updateViews();
            }
        });
    },
    onAttackButtonClick: function(btn) {
        var me = this,
            arena;
        /***/
        me.log('принять вызов на арену с id-', btn.arena_id);
        me.setButtonsDisable([
            'attack',
            'refresh'
        ], true);
        me.service.command('arena2_accept', {
            title: btn.user_title
        }, function(json) {
            if (!json.success) {
                me.setButtonsDisable([
                    'attack',
                    'refresh'
                ], false);
            }
        });
    },
    onRefreshButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('дайте другого противника на арену с id-', btn.arena_id);
        me.setButtonsDisable([
            'attack',
            'refresh'
        ], true);
        delete me.f_arena_queue_success;
        me.service.command('arena2_reroll', {}, function(json) {
            if (json.success) {
                me.arena = json.info;
                me.updateViews();
            }
            me.setButtonsDisable([
                'attack',
                'refresh'
            ], false);
        });
    },
    onArenaChatCommand: function(chatcn, data) {
        var me = this;
        /***/
        me.log('пришла команда чата "арена" с данными', data);
        me.service.update(null, function() {
            me.arena = me.service.data.arena;
            me.updateViews();
        });
    },
    onTabChange: function(panel, tab) {
        var me = this,
            searchField = me.cmp.down('#text-search'),
            shopTitleSearch = me.cmp.down('#title'),
            shopAvailability = me.cmp.down('#availability');
        if (tab.xtype == 'arena_rating2') {
            searchField.el.select('input').elements[0].value = tab.textFilter || '';
            // восстанавливаю значение поиска для текущей вкладки
            searchField.show();
        } else {
            searchField.hide();
        }
        if (tab.xtype == 'arena_shop') {
            shopTitleSearch.el.select('input').elements[0].value = '';
            // восстанавливаю значение поиска для текущей вкладки
            shopTitleSearch.show();
            shopAvailability.show();
        } else {
            shopTitleSearch.hide();
            shopAvailability.hide();
        }
        if (tab.xtype == 'arena_shop' && me.arenaShopStore.getCount() == 0) {
            me.updateShop(tab);
        }
    },
    updateViews: function() {
        var me = this;
        if (!me.cmp.down) {
            return;
        }
        var container = me.cmp.down('arena2container');
        if (!container)  {
            return;
        }
        
        //если есть данные по противникам - показываю card противников, иначе поиск
        if (me.arena.enemy.users) {
            me.showEnemiesCard();
        } else {
            me.showSearchCard();
        }
    },
    showSearchCard: function() {
        var me = this,
            container = me.cmp.down('arena2container');
        if (!me.searchCard) {
            me.searchCard = Ext.widget('arena2', {
                service: me.service,
                arena: me.arena,
                autoShow: false,
                clientConfig: me.clientConfig
            });
            ExGods.Resources.load(me.searchCard, function() {
                container.add(me.searchCard);
            });
        } else {
            me.searchCard.update(me.arena);
        }
        container.getLayout().setActiveItem(me.searchCard);
    },
    showEnemiesCard: function() {
        var me = this,
            container = me.cmp.down('arena2container');
        if (!me.enemiesCard) {
            me.enemiesCard = Ext.widget('arena2_enemylist', {
                service: me.service,
                arena: me.arena,
                autoShow: false,
                clientConfig: me.clientConfig
            });
            ExGods.Resources.load(me.enemiesCard, function() {
                container.add(me.enemiesCard);
            });
        } else {
            me.enemiesCard.updateView(me.arena);
        }
        container.getLayout().setActiveItem(me.enemiesCard);
    },
    updateFilters: function(filterName, value) {
        var me = this,
            shop = me.cmp.down('arena_shop');
        shop.updateFilters.apply(shop, arguments);
    },
    updateShop: function(shopView) {
        if (typeof shopView.shopService != 'object') {
            shopView.shopService = ExGods.Services.factory(shopView.shopService);
        }
        shopView.shopService.init(null, function(service) {
            ExGods.helpme.loadProtos(service.data.shops[0].items, 'item.item', function() {
                shopView.store.loadRawData(service.data.shops[0].items);
            });
        });
    },
    filterBySearch: function(searchField) {
        var me = this,
            str = searchField.getValue(),
            tabs = me.cmp.query('tabpanel')[0],
            tab = tabs.getActiveTab();
        if (tab.setTextFilter) {
            tab.setTextFilter(str);
        }
    },
    setButtonsDisable: function(btnNames, disabled) {
        var me = this,
            query;
        if (me.cmp) {
            Ext.Array.each(btnNames, function(btnName) {
                Ext.Array.each(Ext.ComponentQuery.query('textbutton[action="arena2_' + btnName + '"]'), function(btn) {
                    btn.setDisabled(disabled);
                });
            });
        }
    },
    onShowShopClick: function(btn) {
        var me = this,
            tabs = me.cmp.down('skintabpanel');
        tabs.setActiveTab('arena_shop');
    },
    onShowRulesClick: function(btn) {
        var me = this,
            wnd;
        wnd = Ext.widget('window2', {
            width: 540,
            x: 160,
            autoShow: false,
            items: [
                {
                    xtype: 'arenarules',
                    arena: me.arena,
                    clientConfig: me.clientConfig
                }
            ]
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
        });
        return wnd;
    },
    onTimerExpired: function() {
        var me = this;
        me.service.update(null, function() {
            me.arena = me.service.data.arena;
            me.updateViews();
            ExGods.app.unblock();
        });
    },
    /**
     * Общий метод для обновления всех вью арены
     */
    updateComponents: function() {
        var me = this,
            innerCmp = me.cmp.getArenaComponent(me.arena.get('id'));
        if (innerCmp) {
            innerCmp.update(me.arena.data);
        }
    }
});

/**
 * Диалог подтверждения
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGods.view.ConfirmationDialog', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.confirmdialog',
    /**
     * @cfg {String} message Сообщение диалога
     */
    message: '',
    /**
     * @cfg {Array} buttonsText Надписи на кнопках
     */
    buttonsText: null,
    minWidth: 250,
    y: 260,
    // по высоте центрирую относительно локации
    /**
     * @cfg {Function|Object} handler Обработчик положительного ответа - функция или объект вида {fn, scope}
     */
    handler: Ext.emptyFn,
    handler_negative: Ext.emptyFn,
    initComponent: function() {
        var me = this;
        if (!me.buttonsText)  {
            me.buttonsText = ExGods.getMsgByKey('view_confirm_yesno').split(';');
        }
        
        //если есть id подсказки, то добавляем галочку "больше не показывать"
        var bbar_list = me.entry ? {
                layout: 'auto',
                items: {
                    xtype: 'container',
                    autoEl: 'center',
                    defaultType: 'button',
                    items: {
                        xtype: 'checkboxfield',
                        boxLabel: ExGods.getMsgByKey('view_confirm_closehint'),
                        itemId: 'not_show_next_time',
                        margin: '2 2 2 2'
                    }
                }
            } : '';
        Ext.apply(me, {
            autoShow: true,
            html: me.message,
            bodyStyle: 'text-align: center; max-width: 340px; line-height: 18px; overflow: visible;',
            buttonAlign: 'center',
            buttons: {
                defaultType: 'textbutton',
                items: [
                    {
                        text: me.buttonsText[0],
                        cls: 'no_border qh-object',
                        handler: function() {
                            var me = this;
                            //если выбрана галочка "больше не показывать" (подсказку)
                            if (me.down('#not_show_next_time') && me.down('#not_show_next_time').getValue()) {
                                ExGods.app.fireEvent('notshowhint', me.entry);
                            }
                            if (typeof me.handler == 'object') {
                                me.handler.fn.call(me.handler.scope ? me.handler.scope : me);
                            } else {
                                me.handler.call(me);
                            }
                            me.close();
                        },
                        listeners: {
                            render: function() {
                                if (me.quest_helper_id)  {
                                    //добавляем стрелочку
                                    this.el.set({
                                        'data-qh_otype': me.quest_helper_type,
                                        'data-qh_oid': me.quest_helper_id
                                    });
                                }
                                
                            }
                        },
                        scope: me
                    },
                    {
                        handler: function() {
                            //если выбрана галочка "больше не показывать" (подсказку)
                            if (me.down('#not_show_next_time') && me.down('#not_show_next_time').getValue()) {
                                ExGods.app.fireEvent('notshowhint', me.entry);
                            }
                            if (typeof me.handler_negative == 'object') {
                                me.handler_negative.fn.call(me.handler_negative.scope ? me.handler_negative.scope : me);
                            } else {
                                me.handler_negative.call(me);
                            }
                            me.close();
                        },
                        cls: 'x-btn-txt-red no_border',
                        text: me.buttonsText[1]
                    }
                ]
            },
            bbar: bbar_list
        });
        me.callParent();
    }
});

/**
 * Отвечает за выполнение серверных действий
 *
 * Серверным действием является любое действие, реализующее интерфейс ExGods.model.Action,
 * обработка которого подразумевает запрос на сервер на сооветсвующий url.
 * 
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.Action', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'ActionController:'
    },
    models: [
        'Action'
    ],
    views: [
        'ConfirmationDialog'
    ],
    init: function() {},
    //
    /**
     * Выполнить серверное действие
     *
     * @param {ExGods.model.Action} action Модель действия
     * @param {Function} callback Коллбек, при успешном выполнении. Будет вызвана с параметрами:
     *
     *      json {Object} ответ от сервера
     *
     * @param {Object} scope this для коллбека
     */
    doAction: function(action, callback, scope) {
        var me = this,
            target = action.get('target'),
            selectedTarget = action.get('selected_target');
        /**/
        me.log('выполнить действие "' + action.get('label') + '"..', action.data);
        callback = callback || Ext.emptyFn;
        scope = scope || this;
        if (action.isBattleAction() && !me.getUser().isBattle()) {
            /**/
            me.log('warning >> выполнение боевого действия вне боя');
            return;
        }
        if (target) {
            /**/
            me.log('направленное действие с типом цели "' + target + '". Открываю диалог выбора цели..');
            if (selectedTarget) {
                /**/
                me.log('предустановленная цель действия', selectedTarget);
                /**/
                me.log('отправляю запрос на выполнение действия..');
                me.doActionRequest(action, {
                    target: selectedTarget
                }, function(json) {
                    callback.call(scope, json);
                });
            } else if (target == ExGods.model.Action.ONLINE_LIST_TARGET) {
                me.showOnlineListTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log('выбрана цель', selectedTarget);
                    /**/
                    me.log('отправляю запрос на выполнение действия..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.up('window').close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.STRING) {
                me.showStringTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log('выбрана цель', selectedTarget);
                    /**/
                    me.log('отправляю запрос на выполнение действия..');
                    me.doActionRequest(action, {
                        target: null,
                        param: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.ITEM_TARGET) {
                me.showItemTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log('выбрана цель', selectedTarget);
                    /**/
                    me.log('отправляю запрос на выполнение действия..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.ITEM_FILTER_TARGET) {
                me.showItemFilterTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log('выбрана цель', selectedTarget);
                    /**/
                    me.log('отправляю запрос на выполнение действия..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.ITEM_UPGRADED_TARGET) {
                me.showItemUpgradeTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log('выбрана цель', selectedTarget);
                    /**/
                    me.log('отправляю запрос на выполнение действия..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.BLACK_LIST_USER_TARGET) {
                me.showBlackListTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log('выбрана цель', selectedTarget);
                    /**/
                    me.log('отправляю запрос на выполнение действия..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.USER_TARGET) {
                me.showUserTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log('выбрана цель', selectedTarget);
                    /**/
                    me.log('отправляю запрос на выполнение действия..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.CONTEXT_TARGET) {
                me.doActionRequest(action, {}, function(json) {
                    callback.call(scope, json);
                });
            }
        } else {
            /**/
            me.log('ненаправленное действие');
            me.doActionRequest(action, {}, function(json) {
                callback.call(scope, json);
            });
        }
    },
    /**
     * @private
     * Показывает окно выбора пользователя из онлайн-листа для действия
     * @param {ExGods.model.Action} action Модель действия для которого нужно выбрать цель
     * @param {Function} callback Коллбек на выбор цели, в который будет переданы - текущее окно и имя выбранного пользователя
     */
    showOnlineListTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('USER_TARGET_PANEL', {
                source: (action.isBattleAction()) ? 'battle' : 'contacts',
                dead: action.get('dead'),
                side: action.get('side'),
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, action.isBattleAction() ? target.getBattleEkey() : target.get('display_title'));
                    },
                    destroy: function(view) {
                        view.store.destroyStore();
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    /**
     * @private
     * Показывает окно выбора цели (юзера) из black-листа
     * @param {ExGods.model.Action} action Модель действия для которого нужно выбрать цель
     * @param {Function} callback Коллбек на выбор цели, в который будет переданы - текущее окно и выбранная цель ()
     */
    showBlackListTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('USER_TARGET_PANEL', {
                source: 'blacklist',
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, target.get('display_title'));
                    },
                    destroy: function(view) {
                        view.store.destroyStore();
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    // cmp.up('window').mask();
    /**
     * @private
     * Показывает окно ввода имени пользователя для действия
     * @param {ExGods.model.Action} action Модель действия для которого нужно ввести цель
     * @param {Function} callback Коллбек на выбор цели, в который будет переданы - текущее окно и введенная цель (имя пользователя)
     */
    showUserTargetWindow: function(action, callback, scope) {
        var me = this,
            win,
            items = [];
        win = Ext.widget('commonwindow', {
            autoShow: true,
            width: 260,
            y: 150,
            bodyPadding: 0,
            layout: {
                type: 'vbox',
                align: 'stretch'
            },
            title: action.get('label'),
            items: [
                {
                    xtype: 'textfield',
                    emptyText: ExGods.getMsgByKey('user_target_empty_text'),
                    anchor: '100%'
                },
                {
                    xtype: 'textbutton',
                    itemId: 'applyButton',
                    text: ExGods.getMsgByKey('apply_btn_text'),
                    handler: function(btn) {
                        var targetName = Ext.String.trim(win.down('textfield').getValue());
                        if (targetName) {
                            callback.call(scope || me, win, targetName);
                        }
                    },
                    margin: '10 5 0 5',
                    cls: 'no_border'
                }
            ]
        });
    },
    /**
     * @private
     * Показывает окно выбора предмета для действия
     * @param {ExGods.model.Action} action Модель действия для которого нужно выбрать цель
     * @param {Function} callback Коллбек на выбор цели, в который будет переданы - текущее окно и выбранная цель (предмет в слоте в формате "slot_id|item_id")
     */
    showItemTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('ITEM_TARGET_PANEL', {
                source: 'damaged',
                windowTitle: action.data.label,
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, target.get('slot_id') + '|' + target.get('item_id'));
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    showItemFilterTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('ITEM_TARGET_PANEL', {
                source: 'filtered',
                windowTitle: action.data.label,
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                targetParams: action.get('target_params'),
                actionParams: action.get("params"),
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, target.get('slot_id') + '|' + target.get('item_id'));
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    /**
     * @private
     * Показывает окно выбора предмета, который был усилен для действия
     * @param {ExGods.model.Action} action Модель действия для которого нужно выбрать цель
     * @param {Function} callback Коллбек на выбор цели, в который будет переданы - текущее окно и выбранная цель (предмет в слоте в формате "slot_id|item_id")
     */
    showItemUpgradeTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('ITEM_TARGET_PANEL', {
                source: 'upgraded',
                windowTitle: action.data.label,
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, target.get('slot_id') + '|' + target.get('item_id'));
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    /**
     * @private
     * Показывает окно ввода произольной строки
     * @param {ExGods.model.Action} action Модель действия для которого нужно выбрать цель
     * @param {Function} callback Коллбек на выбор цели, в который будет переданы - текущее окно и выбранная цель (предмет в слоте в формате "slot_id|item_id")
     */
    showStringTargetWindow: function(action, callback, scope) {
        var me = this;
        var win = Ext.widget('floatwindow', {
                autoShow: true,
                width: 360,
                height: 150,
                plugins: [
                    'skinpaperdeco'
                ],
                y: 100,
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                items: [
                    {
                        xtype: 'component',
                        cls: 'paper-title',
                        html: action.data.label,
                        margin: '2',
                        style: {
                            'font-weight': 'bold'
                        }
                    },
                    {
                        xtype: 'textfield',
                        padding: '10 20',
                        emptyText: ExGods.getMsgByKey('rename_action_placeholder_text')
                    }
                ],
                dockedItems: {
                    dock: 'bottom',
                    layout: {
                        type: 'hbox',
                        pack: 'center'
                    },
                    defaults: {
                        cls: 'no_border',
                        margin: '0 10'
                    },
                    items: [
                        {
                            xtype: 'textbutton',
                            text: ExGods.getMsgByKey('yes_btn_text'),
                            handler: function() {
                                callback.call(scope || this, win, win.down('textfield').getValue());
                            }
                        },
                        {
                            xtype: 'textbutton',
                            text: ExGods.getMsgByKey('no_btn_text'),
                            cls: 'no_border x-btn-txt-red',
                            handler: function() {
                                win.close();
                            }
                        }
                    ]
                }
            });
    },
    /**
     * @private
     * Запрашивает выполнение действия на сервере
     *
     * @param {ExGods.model.Action} action
     * @param {Object} params Параметры действия
     * @param {Function} callback Коллбек
     * @param {Object} scope this для коллбека
     */
    doActionRequest: function(action, params, callback, scope) {
        var me = this,
            beforeRequest = function(action, callback) {
                callback = callback || Ext.emptyFn;
                if (action.get('images') && action.get('images').special) {
                    locationCtrl.maskLocation(callback, {
                        img: action.get('images').special
                    });
                } else {
                    me.app.block();
                    callback();
                }
            },
            afterRequest = function(json, action, callback) {
                callback = callback || Ext.emptyFn;
                if (action.get('images') && action.get('images').special) {
                    if (locationEntry == me.user.location.get('entry')) {
                        // если локация в ходе выполения действия не изменилась, то снимаю маску. Иначе маска уберается в процессе отрисовки локации
                        locationCtrl.unmaskLocation(callback, {
                            img: action.get('images').special
                        });
                    } else {
                        callback();
                    }
                } else {
                    me.app.unblock();
                    callback();
                }
            },
            doRequest = function(action, params, callback) {
                var requestUrl;
                if (action.isBattleAction()) {
                    requestUrl = 'battle.pl';
                } else if (action.isServiceAction()) {
                    requestUrl = 'map.pl';
                } else {
                    requestUrl = 'map.pl';
                }
                params = params || {};
                if (action.isBattleAction()) {
                    params.cmd = 'battle_item';
                } else if (action.get('type') == 'repair') {
                    params.cmd = 'item_repair';
                } else if (action.isInventoryAction()) {
                    params.cmd = 'item_map_action';
                } else if (action.isLocationAction()) {
                    params.cmd = 'map_action_location';
                } else if (action.isServiceAction()) {
                    params.cmd = 'map_action_service';
                } else {
                    /***/
                    me.log('warn', 'неопределённый тип действия', action.data);
                    return;
                }
                params.service_id = action.get('service_id');
                params.entry = action.get('entry');
                if (action.isBattleAction()) {
                    params.round = me.app.getController('battle.Battle').state.round;
                    if (!action.get('target')) {
                        params.target = me.getUser().getBattleEkey();
                    }
                }
                if (action.get('source') instanceof ExGodsCore.model.Item) {
                    params.item = action.get('source').get('item_id');
                    params.slot = action.get('source').get('slot_id');
                }
                if (action.get('condition_action')) {
                    params.condition_action = action.get('condition_action');
                }
                /**/
                me.log('запрос на сервер..');
                /**/
                me.log('url: ' + requestUrl);
                /**/
                me.log('параметры: ', params);
                beforeRequest(action, function() {
                    me.request({
                        url: requestUrl,
                        params: params,
                        success: function(json) {
                            afterRequest(json, action, function() {
                                if (callback) {
                                    callback(json);
                                }
                                if (action.isBattleAction()) {
                                    // если действие боевое - вызываю обработчик из контроллера боя
                                    me.app.getController('battle.Battle').onItemActionHandler(json);
                                }
                            });
                        }
                    });
                });
            },
            locationCtrl = me.app.getController('Location'),
            locationEntry = me.user.location.get('entry'),
            confirmation = action.get('confirm');
        if (confirmation && confirmation.confirmated) {
            // Если действие требует подтверждения - показываю диалог подтверждения
            Ext.widget('confirmdialog', {
                title: '',
                message: ExGods.app.applyTpl(confirmation.confirmated, action.data),
                handler: Ext.bind(doRequest, scope || me, [
                    action,
                    params,
                    callback
                ]),
                buttonsText: [
                    confirmation.btn_yes ? ExGods.app.applyTpl(confirmation.btn_yes) : ExGods.getMsgByKey('apply_btn_text'),
                    confirmation.btn_no ? ExGods.app.applyTpl(confirmation.btn_no) : ExGods.getMsgByKey('cancel_btn_text')
                ]
            });
        }
        //      } else if (action.hasConfirmation()) {
        //
        //          var hintsController = me.app.getController('Hints'),
        //              hintsArray;
        //          hintsArray = hintsController.getConfirmationHintsFromArray(action.get('hints')); // Подсказка должна быть с типом "С подтверждением" и должна быть прикреплена к шмотке
        //          if (hintsArray.length) {
        //              hintsController.showConfirmations(
        //                  hintsArray,
        //                  function() { doRequest.apply(scope || me, [action, params, callback]); }
        //              );
        //          }
        else if (action.hasCost()) {
            // Если действие платное - показываю диалог подтверждения
            Ext.widget('confirmdialog', {
                title: '',
                message: ExGods.app.applyTpl(ExGods.getMsgByKey('action_cost_confirmation'), action.data),
                handler: Ext.bind(doRequest, scope || me, [
                    action,
                    params,
                    callback
                ])
            });
        } else // buttonsText: ['Применить', 'Отмена']
        {
            doRequest.apply(scope || me, [
                action,
                params,
                callback
            ]);
        }
    }
});

Ext.define('ExGods.view.bank.stuff.BankBonus', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.stuff.decorator.BonusStick);
        return data;
    }
});

/**
 * Отображение вкладки в виде кнопки-картинки на шкуре
 */
Ext.define('ExGods.view.skin.Tab', {
    extend: Ext.tab.Tab,
    alias: 'widget.skintab',
    border: 0,
    counter: 0,
    /**
     * @property {Ext.Element} counterEl
     * Элемент счётчика
     * @private
     */
    height: 49,
    margin: 0,
    padding: 0,
    width: 53,
    ui: 'skin',
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.btnEl.insertHtml('beforeBegin', '<div class="skin-tab-left-border"></div>', true);
        me.btnEl.insertHtml('afterEnd', '<div class="skin-tab-right-border"></div>', true);
        me.counterEl = me.btnEl.insertHtml('beforeEnd', '<div class="counter"></div>', true);
        me.counterEl.setVisibilityMode(Ext.Element.DISPLAY);
        me.counterEl[me.counter ? 'show' : 'hide']();
        if (me.countLabel) {
            me.item.store.on('datachanged', me.onCountChange, me);
            me.onCountChange();
        }
    },
    onCountChange: function(store, filters) {
        var me = this,
            numbers = '',
            qcont = me.btnEl.down('.quantity-container'),
            quantity = me.item.store.data.length.toString();
        for (var i = 0; i < quantity.length; i++) {
            numbers += '<div class="tab-number" style="background-image:url(' + IMAGE_URL + 'quests/tasks_sprite_' + quantity.charAt(i) + '.png)"></div>';
        }
        if (qcont) {
            qcont.destroy();
        }
        me.btnEl.insertHtml('beforeEnd', '<div class="quantity-container" id="quantity-container" style="left:' + me.quantityLeft + 'px">' + numbers + '</div>');
    },
    addCount: function(value) {
        var me = this;
        me.counter += value;
        if (me.counterEl) {
            me.counterEl[me.counter ? 'show' : 'hide']();
            me.counterEl.setHTML(me.counter);
        }
    },
    reset: function() {
        var me = this;
        me.counter = 0;
        if (me.counterEl)  {
            me.counterEl.hide();
        }
        
        var mainMenuCounter = 0;
        me.up().items.each(function(tab) {
            mainMenuCounter += tab.counter;
        });
        if (!mainMenuCounter) {
            var mainMenuBtn = Ext.getCmp('mainmenu-' + me.up('panel').menuId + '-button');
            if (mainMenuBtn) {
                mainMenuBtn.reset();
            }
        }
    }
});

/**
 * Табы на шкуре
 */
Ext.define('ExGods.view.skin.TabPanel', {
    extend: Ext.tab.Panel,
    alias: 'widget.skintabpanel',
    activeTab: 0,
    /**
     * @cfg
     */
    tabUi: 'skin',
    // skin или skintext
    constructor: function(config) {
        var me = this;
        config.tabBar = Ext.apply({
            height: 49,
            layout: {
                align: 'top'
            },
            margin: 0,
            padding: '0 12 0 11',
            ui: 'skin'
        }, config.tabBar || {});
        me.callParent(arguments);
    },
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {};
        }
        Ext.applyIf(item.tabConfig, {
            xtype: 'skintab',
            ui: me.tabUi,
            width: me.cls == 'inventory_tabpanel' ? 120 : me.tabUi == 'skin' ? 53 : 198
        });
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'deco/skin-tabs.png',
                IMAGE_URL + 'deco/skin-tabs.png',
                IMAGE_URL + 'checkbox-checked.png',
                IMAGE_URL + 'checkbox.png',
                IMAGE_URL + 'tab_big_inactive.png',
                IMAGE_URL + 'tab_big_hover.png',
                IMAGE_URL + 'tab_big_active.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Табы кошелька
 */
Ext.define('ExGods.view.bank.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.banktabpanel',
    id: 'bank-tabs',
    tabUi: 'skintext',
    bodyPadding: '0 12 8 5',
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    }
});

/**
 * Модель "Банка". Инкапсулирует в себе все данные связанные с оплатой - текущая валюта игры, курсы обмена и прочее
 */
Ext.define('ExGods.model.Bank', {
    singleton: true,
    /**
     * Вернет курс обмена валюты приложения (кристаллы) на золото
     * @return {Number}
     */
    getGameToGoldCurs: function() {
        return ExGods.references.get('constants').get('game_curs').value;
    },
    /**
     * Вернет курс обмена валюты приложения (кристаллы) на рубли
     * @return {Number}
     */
    getGameToRublesCurs: function() {
        return ExGods.references.get('constants').get('curs').value / 100;
    },
    /**
     * Вернет список допустимых обменов валюты приложения (кристаллы) на реальную валюту (рубли, голоса)
     * @return {Array}
     */
    getRealToGameExchangePresets: function() {
        var presetsRef = ExGods.references.get('payment_preset'),
            result = [],
            curs = this.getGameToRublesCurs();
        return presetsRef.getRange();
    },
    /**
     * Вернет инфу по игровой валюте (кристаллы)
     * @return {Object} Инфа по валюте - image, label
     */
    getGameCuyrrencyInfo: function() {
        var constants = ExGods.references.get('constants'),
            key = constants.get('currency_real').value;
        return ExGods.references.get('user_money').get(key);
    }
});

/**
 * Пополнение банковского счёта
 */
Ext.define('ExGods.view.bank.Replenishment', {
    extend: Ext.container.Container,
    alias: 'widget.bankreplenishment',
    cls: 'bank-replenishment',
    header: false,
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            bank = ExGods.model.Bank,
            gold = ExGods.references.get('user_money').get('gold'),
            coins = ExGods.references.get('user_money').get('coins'),
            presets = me.service.data.payment_preset,
            items = [],
            fields = [
                {
                    name: 'bonus',
                    type: 'auto'
                },
                {
                    name: 'count',
                    type: 'int'
                },
                {
                    name: 'price',
                    type: 'float'
                },
                {
                    name: 'stuff_for_show',
                    type: 'auto'
                },
                {
                    name: 'game_currency',
                    type: 'string'
                },
                {
                    name: 'app',
                    type: 'string'
                },
                {
                    name: 'entry',
                    type: 'string'
                },
                {
                    name: 'order',
                    type: 'int'
                },
                {
                    name: 'special',
                    type: 'int'
                },
                {
                    name: 'description',
                    type: 'auto'
                },
                {
                    name: 'image',
                    type: 'string'
                },
                {
                    name: 'title',
                    type: 'string'
                }
            ];
        me.presetStore = Ext.create('Ext.data.Store', {
            fields: fields,
            data: presets,
            sorters: [
                {
                    property: 'order',
                    direction: 'ASC'
                }
            ]
        });
        me.items = [
            {
                xtype: 'panel',
                x: 0,
                y: 0,
                plugins: [
                    'paperdeco'
                ],
                data: {
                    isSocialApp: isSocialApp,
                    isVK: isVK,
                    isOK: isOK,
                    isMM: isMM,
                    isFB: isFB
                },
                tpl: [
                    '<div class="bank-header">',
                    '<tpl if="!isSocialApp">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('view_bank_repl_count_id') + '",{id:' + user.get('id') + '})]}</div>',
                    '<div>' + ExGods.getMsgByKey('view_bank_on_your_account') + ' <strong id="coins_value">' + Ext.util.Format.number(user.get('money').coins, '0,0') + ' ' + Ext.util.Format.plural(user.get('money').coins, ExGods.getMsgByKey('moneta_name').split(',')) + '</strong></div>',
                    '<div class="titan-button"></div>',
                    '</tpl>',
                    '<tpl if="isVK">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_vk') + '</div>',
                    '</tpl>',
                    '<tpl if="isOK">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_ok') + '</div>',
                    '</tpl>',
                    '<tpl if="isMM">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_mm') + '</div>',
                    '</tpl>',
                    '<tpl if="isFB">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_fb') + '</div>',
                    '</tpl>',
                    '</div>'
                ],
                width: '100%',
                height: isSocialApp ? 100 : 100
            },
            {
                xtype: 'bankpresets',
                store: me.presetStore,
                buy_btn_id: 'bank-buy'
            }
        ];
        me.mon(user, 'moneycoinschanged', function(value) {
            Ext.fly('coins_value').setHTML(Ext.util.Format.number(value, '0,0') + ' ' + Ext.util.Format.plural(value, ExGods.getMsgByKey('moneta_name').split(',')));
        }, me);
        me.callParent();
    },
    getStores: function(presets) {
        var presets_gold = [],
            presets_crystal = [];
        for (var i = 0; i < presets.length; i++) {
            if (presets[i].game_currency == "crystal") {
                presets_crystal.push(presets[i]);
            }
            if (presets[i].game_currency == "gold") {
                presets_gold.push(presets[i]);
            }
        }
        return [
            presets_gold,
            presets_crystal
        ];
    },
    onRender: function() {
        var me = this,
            btnPlace = me.el.down('.titan-button');
        if (btnPlace && !btnPlace.innerHTML) {
            me.processTitanButton(btnPlace, me.service.data.reward_button);
        }
        me.callParent(arguments);
    },
    processTitanButton: function(btnPlace, is_reward) {
        var me = this;
        if (Ext.getCmp('do-replenish')) {
            Ext.getCmp('do-replenish').destroy();
        }
        if (Ext.getCmp('do-get-reward')) {
            Ext.getCmp('do-get-reward').destroy();
        }
        if (is_reward) {
            Ext.widget('textbutton', {
                renderTo: btnPlace,
                cls: 'qh-object no_border_double x-btn-txt-green',
                minWidth: 110,
                text: ExGods.getMsgByKey('view_bank_reward_btn_text'),
                id: 'do-get-reward',
                handler: function() {
                    me.fireEvent('get_reward');
                },
                listeners: {
                    'afterrender': function() {
                        var protectBtn = me.el.down('#do-get-reward');
                        if (protectBtn) {
                            protectBtn.set({
                                'data-qh_otype': 'payment_buy_button',
                                'data-qh_oid': '1'
                            });
                        }
                    }
                }
            });
        } else {
            Ext.widget('textbutton', {
                renderTo: btnPlace,
                cls: 'qh-object no_border_double x-btn-txt-green',
                minWidth: 110,
                href: ExGods.ref('constants|bank_address').value + '/pay/?uid=' + ExGods.app.user.get('id'),
                text: ExGods.getMsgByKey('view_bank_replenishment_btn_text'),
                id: 'do-replenish',
                listeners: {
                    'afterrender': function() {
                        var protectBtn = me.el.down('#do-replenish');
                        if (protectBtn) {
                            protectBtn.set({
                                'data-qh_otype': 'payment_buy_button',
                                'data-qh_oid': '1'
                            });
                        }
                    }
                }
            });
        }
    },
    reloadReplenishment: function(service_data) {
        var me = this;
        me.processTitanButton(me.el.down('.titan-button'), service_data.reward_button);
        me.presetStore.loadRawData(service_data.payment_preset);
    },
    onDestroy: function() {
        var me = this,
            replenish_button = Ext.getCmp('do-replenish'),
            reward_button = Ext.getCmp('do-get-reward');
        if (replenish_button)  {
            replenish_button.destroy();
        }
        
        if (reward_button)  {
            reward_button.destroy();
        }
        
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'npc/human/trader_small.jpg',
                IMAGE_URL + 'button-text-30green.png',
                ExGods.getMsgByKey('view_bank_replenishment_btn_text')
            ].concat(arr_images)
        };
    }
});

/**
 * Обмен кристаллов на золото
 */
Ext.define('ExGods.view.bank.Bonus', {
    extend: Ext.panel.Panel,
    alias: 'widget.bankbonus',
    bodyPadding: '4 4 10 4',
    cls: 'bank-bonus',
    header: false,
    layout: 'anchor',
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            socialNet = user.getSocialNet();
        var items = [];
        items.push({
            xtype: 'component',
            html: [
                '<p style="font-weight: bold;">',
                '<img height="16" src="' + IMAGE_URL + 'icons/' + ((socialNet && ((user.get('payment') != 'vka' && user.get('social').email_assign) || user.get('payment') == 'vka')) ? 'done' : 'undone') + '.png" style="vertical-align: text-bottom;" width="16" /> ',
                ExGods.app.applyTpl(ExGods.getMsgByKey('view_bank_bonus_addsocialtext'), {
                    gold_img: '<img title="' + ExGods.ref('user_money|gold').label + '" src="' + IMAGE_URL + 'currency/gold.png" class="stuff-icon" />'
                }),
                '</p>',
                '<div class="separator"></div>'
            ].join('')
        });
        if (!socialNet) {
            var socialConnect = Ext.widget('component', {
                    data: {
                        referralLink: '/game.pl?cmd=assign_social_net',
                        user: user.data
                    },
                    tpl: [
                        ExGods.app.applyTpl(ExGods.getMsgByKey('view_bank_bonus_socialdescr'), {
                            gold_img: '<img title="' + ExGods.ref('user_money|gold').label + '" src="' + IMAGE_URL + 'currency/gold.png" class="stuff-icon" />'
                        }),
                        '<ul class="social-icons" style="display: inline-block; vertical-align: middle;">',
                        /*'<li>',
                            '<a data-type="fb" class="social-fb" href="{referralLink}&type=fb" data-qtip="Facebook" onclick="return false;"></a>',
                        '</li>',*/
                        '<li>',
                        '<a data-type="vk" class="social-vk" href="{referralLink}&type=vk" data-qtip="ВКонтакте" onclick="return false;"></a>',
                        '</li>',
                        '<li>',
                        '<a data-type="ok" class="social-ok" href="{referralLink}&type=ok" data-qtip="Одноклассники" onclick="return false;"></a>',
                        '</li>',
                        /*'<li>',
                            '<a data-type="tw" class="social-tw" href="{referralLink}&type=tw" data-qtip="Твиттер" onclick="return false;"></a>',
                        '</li>',*/
                        '<li>',
                        '<a data-type="mm" class="social-mm" href="{referralLink}&type=mm" data-qtip="Мой мир" onclick="return false;"></a>',
                        '</li>',
                        '</ul>',
                        '<div class="separator"></div>'
                    ],
                    listeners: {
                        render: function(cmp) {
                            cmp.el.select('li a').each(function(el) {
                                Ext.get(el).on('click', me.onSocialConnectClick, me);
                            });
                        }
                    }
                });
            items.push(socialConnect);
        } else {
            var socialConnect = Ext.widget('component', {
                    data: user.data,
                    tpl: [
                        ExGods.getMsgByKey('view_bank_bonus_acceptedsocial'),
                        '<ul class="social-icons" style="display: inline-block; vertical-align: middle;">',
                        '<li>',
                        '<a class="social-{social.social_net}" href="{[this.getLink(values.social)]}" rel="external" target="_blank"></a>',
                        '</li>',
                        '</ul>',
                        '<div class="separator"></div>',
                        {
                            getLink: function(social) {
                                return ExGods.util.Helper.getUserSocialNetLink(social.social_net, social.social_net_id);
                            }
                        }
                    ]
                });
            items.push(socialConnect);
        }
        var email_assign = user.get('social').email_assign;
        if (!email_assign) {
            var assign = Ext.widget('form', {
                    margin: '0 0 10 14',
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [
                        {
                            xtype: 'textfield',
                            name: 'email',
                            fieldLabel: ExGods.getMsgByKey('view_bank_your_email'),
                            labelWidth: 60,
                            vtype: 'email',
                            width: 300
                        },
                        {
                            xtype: 'textbutton',
                            text: ExGods.getMsgByKey('view_bank_bonus_acceptsocialbtn'),
                            cls: 'no_border',
                            type: 'submit',
                            margin: '0 0 0 12',
                            handler: me.onEmailAssignClick,
                            scope: me
                        },
                        {
                            xtype: 'button',
                            height: 16,
                            hidden: true,
                            icon: IMAGE_URL + 'icons/done.png',
                            itemId: 'sent',
                            ui: 'image',
                            width: 16
                        }
                    ]
                });
            items.push({
                xtype: 'component',
                html: ExGods.app.applyTpl(ExGods.getMsgByKey('view_bank_bonus_emailassign'), {
                    gold_img: '<img title="' + ExGods.ref('user_money|gold').label + '" src="' + IMAGE_URL + 'currency/gold.png" class="stuff-icon" />'
                })
            }, assign);
        } else {
            items.push({
                xtype: 'component',
                html: '<p>' + ExGods.getMsgByKey('view_bank_bonus_emailprefix') + '<a href="mailto:' + email_assign + '">' + email_assign + '</a></p>'
            });
        }
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                bodyPadding: '4 4 10 4',
                items: items
            }
        ];
        me.callParent();
    },
    onSocialConnectClick: function(e, t) {
        Ext.Ajax.request({
            url: t.href,
            success: function(response) {
                var result = Ext.decode(response.responseText, true);
                if (result.success) {
                    window.location = result.redirect;
                }
            }
        });
    },
    onEmailAssignClick: function(button) {
        var me = this,
            panel = button.up('form'),
            form = panel.getForm();
        if (form.isValid()) {
            ExGods.app.getController('Bank').service.command('email_assign', form.getValues(), function(result) {
                panel.down('#sent').show();
            });
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            user = me.user,
            socialNet = user.getSocialNet();
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'icons/done.png',
                IMAGE_URL + 'currency/gold.png',
                IMAGE_URL + 'index/social.png',
                IMAGE_URL + 'icons/' + ((socialNet && ((user.get('payment') != 'vka' && user.get('social').email_assign) || user.get('payment') == 'vka')) ? 'done' : 'undone') + '.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Таблица стоимостей
 */
Ext.define('ExGods.view.bank.Presets', {
    extend: Ext.view.View,
    alias: 'widget.bankpresets',
    cls: 'bank-presets',
    //margin:'17 0 0 22',
    x: 0,
    initComponent: function() {
        var me = this,
            data = [],
            constants = ExGods.references.get('constants'),
            key = constants.get('currency_real').value,
            gold = ExGods.references.get('user_money').get('gold'),
            currency = ExGods.references.get('user_money').get('crystal'),
            protosLoaded = false;
        me.tpl = [
            '<tpl for=".">',
            '<tpl if="xindex &lt; 5">',
            '<div class="bank-preset">',
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="bank-preset-content">',
            '<div class="bank-preset-image" style="background-image: url({[IMAGE_URL + values.image]});"></div>',
            '<span class="label">{title}</span>',
            '<div class="separator"></div>',
            '<div class="price">' + Ext.String.format(ExGods.getMsgByKey('view_bank_preset_price'), '<span>{[this.getGold(values)]}</span>') + '</div>',
            '<div class="separator"></div>',
            '<div class="paper-title"><h4>{[ExGods.getMsgByKey("bank_rewards_title")]}</h4></div>',
            '<div class="stuff">{[this.printStuff(values)]}</div>',
            '</div>',
            '<div class="component">',
            '<span role="xtype">container</span>',
            '<span role="layout">',
            '<span role="type">hbox</span>',
            '<span role="pack">center</span>',
            '</span>',
            '<ul role="items">',
            '<li>',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border qh-object</span>',
            '<span role="text">' + ExGods.getMsgByKey('view_bank_presets_buy_btn') + '</span>',
            '<span role="action">' + me.buy_btn_id + '</span>',
            '<span role="values">{[JSON.stringify(values)]}</span>',
            '<span role="qh:object">{[this.getJSON(values)]}</span>',
            '</li>',
            '<tpl if="this.isGiftable">',
            '<li>',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border x-btn-txt-green gift-btn</span>',
            '<span role="text">img:bank/btn_gift.png</span>',
            '<span role="action">bank-gift</span>',
            '<span role="width:int">34</span>',
            '<span role="minWidth:int">34</span>',
            '<span role="height:int">24</span>',
            '<span role="values">{[JSON.stringify(values)]}</span>',
            '<span role="tooltip">' + ExGods.getMsgByKey('view_bank_gift_btn_tip') + '</span>',
            '</li>',
            '</tpl>',
            '</ul>',
            '</div>',
            '</div>',
            '</tpl>',
            '</tpl>',
            {
                isGiftable: isFB,
                // может быть подарен другу
                printStuff: function(values) {
                    var stuff = me.formStuff(values);
                    if (stuff && stuff.length > 2) {
                        return ExGods.util.Stuff.printStuff(stuff, {
                            display: 'block'
                        });
                    } else {
                        return protosLoaded ? ExGods.stuff.StuffManager.image(stuff) : '';
                    }
                },
                getJSON: function(values) {
                    return JSON.stringify({
                        'data-qh_otype': 'payment_exchange',
                        'data-qh_oid': values.entry
                    });
                },
                getCount: function(values) {
                    var value = values.count,
                        currency = ExGods.references.get('user_money').get(values.game_currency),
                        plurals = values.game_currency == 'gold' ? ExGods.getMsgByKey('gold_name').split(',') : ExGods.getMsgByKey('crystal_name').split(',');
                    return '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + '<strong>' + Ext.util.Format.number(value, '0,0') + '</strong> ' + Ext.util.Format.plural(value, plurals);
                },
                getGold: function(values) {
                    if (values.app != 'fba') {
                        var plurals = values.app == 'sa' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'vka' ? ExGods.getMsgByKey('payment_vka').split(',') : values.app == 'oka' ? ExGods.getMsgByKey('payment_oka').split(',') : values.app == 'mma' ? ExGods.getMsgByKey('payment_mma').split(',') : [
                                '',
                                '',
                                ''
                            ];
                        return '<strong>' + Ext.util.Format.number(values.price, '0,0') + '</strong> ' + Ext.util.Format.plural(values.price, plurals);
                    } else {
                        // для фейсбука пресеты в USD, а показывать стоимость нужно в валюте игрока
                        if (FB.userCurrency) {
                            return '<strong>' + Ext.util.Format.number(values.price * FB.userCurrency.usd_exchange_inverse, '0,0.00') + '</strong> ' + FB.userCurrency.user_currency;
                        } else {
                            return '<strong>' + Ext.util.Format.number(values.price, '0,0.00') + '</strong> USD';
                        }
                    }
                }
            }
        ];
        me.itemSelector = '.bank-preset';
        protosLoaded = true;
        if (me.rendered) {
            me.refresh();
        }
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me, {
            single: true
        });
        me.on('refresh', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me);
    },
    formStuff: function(values) {
        var stuff = [
                {
                    type: 'currency',
                    params: {
                        id: values.game_currency,
                        quantity: values.count
                    }
                }
            ];
        Ext.Array.each(values.bonus, function(bonusArr) {
            Ext.Array.each(bonusArr, function(bonus) {
                stuff.push({
                    type: 'bank_bonus',
                    params: {
                        stuff: bonus
                    }
                });
            });
        });
        return stuff;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var stuffes = [];
        var items = me.store.data.items;
        for (var i = 0; i < items.length; i++) {
            arr_images.push(items[i].data.image);
            var stf = me.formStuff(items[i].data);
            // Здесь стафф bank_bonus заменяется на настоящий стафф
            for (var j = 0; j < stf.length; j++) {
                if (stf[j].type == 'bank_bonus') {
                    stf[j] = stf[j].params.stuff;
                }
            }
            stuffes = stuffes.concat(stf);
        }
        return {
            stuff: stuffes,
            images: [
                IMAGE_URL + 'npc/human/trader_small.jpg',
                IMAGE_URL + 'bank/btn_gift.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Управление банком
 */
Ext.define('ExGods.controller.Bank', {
    extend: ExGodsCore.controller.Base,
    views: [
        'bank.Bonus',
        'bank.Replenishment',
        'bank.Presets',
        'bank.TabPanel',
        'ConfirmationDialog'
    ],
    refs: [
        {
            ref: 'bankMenuBtn',
            selector: '#mainmenu-bank-button'
        }
    ],
    init: function(app) {
        var me = this;
        me.control({
            '#user-finance': {
                iconclick: me.toggleBankServices,
                adddefaultcurrency: me.toggleBankServices,
                addrealcurrency: me.toggleBankServices
            },
            'textbutton[action="bank-buy"]': {
                click: me.onBuyClickBtn
            },
            'textbutton[action="bank-gift"]': {
                click: me.onGiftClickBtn
            },
            'bankreplenishment': {
                get_reward: me.onGetReward
            }
        });
        app.on({
            socialnetassign: me.onSocialNetAssign,
            scope: me
        });
        ExGods.stuff.StuffManager.register({
            'bank_bonus': ExGods.view.bank.stuff.BankBonus
        });
        ExGods.Components.addComponentInitializer('bank', me.initBankComponent, me);
    },
    onGetReward: function() {
        var me = this;
        me.service.command('payment_reward', {}, function(service) {
            Ext.ComponentQuery.query('bankreplenishment')[0].reloadReplenishment(service);
        });
    },
    /**
     * Показывает/скрывает вкладки банка
     */
    toggleBankServices: function(tabId) {
        var me = this,
            bankMenuBtn = me.getBankMenuBtn();
        me.initialTabId = typeof tabId == 'number' ? tabId : 0;
        bankMenuBtn.fireEvent('click', bankMenuBtn);
    },
    onBuyClickBtn: function(btn) {
        var me = this,
            values = JSON.parse(btn.values),
            value, currency, plurals, plurals2;
        if (isSocialApp) {
            me.app.getSocialController().buy(values);
        } else {
            value = values.count;
            currency = ExGods.references.get('user_money').get(values.game_currency);
            plurals = values.game_currency == 'gold' ? ExGods.getMsgByKey('gold_name').split(',') : ExGods.getMsgByKey('crystal_name').split(',') , plurals2 = values.app == 'sa' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'vka' ? ExGods.getMsgByKey('payment_vka').split(',') : values.app == 'oka' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'mma' ? ExGods.getMsgByKey('moneta_name').split(',') : [
                '',
                '',
                ''
            ];
            if (values.app == 'sa' && values.price > ExGods.app.user.get('money').coins) {
                Ext.widget('commonwindow', {
                    autoShow: true,
                    html: '<div style="padding: 10px;">' + ExGods.ref('message_client|not_enough_currency'),
                    minHeight: 150,
                    buttonAlign: 'center',
                    buttons: {
                        items: [
                            {
                                xtype: 'textbutton',
                                cls: 'no_border_double x-btn-txt-green',
                                minWidth: 110,
                                href: ExGods.ref('constants|bank_address').value + '/pay?uid=' + ExGods.app.user.get('id'),
                                text: ExGods.getMsgByKey('view_bank_replenishment_btn_text')
                            }
                        ]
                    }
                });
            } else {
                Ext.widget('confirmdialog', {
                    message: Ext.String.format(ExGods.getMsgByKey('bank_excahnge_confirmation'), '<strong>' + Ext.util.Format.number(values.price, '0,0') + '</strong> ' + Ext.util.Format.plural(values.price, plurals2), '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + '<strong>' + Ext.util.Format.number(value, '0,0') + '</strong> ' + Ext.util.Format.plural(value, plurals)),
                    handler: function() {
                        me.confirmExchange(values.entry);
                    }
                });
            }
        }
    },
    onGiftClickBtn: function(btn) {
        var me = this,
            values = JSON.parse(btn.values);
        if (isSocialApp) {
            me.app.getSocialController().gift(values);
        }
    },
    confirmExchange: function(money) {
        var me = this,
            user = me.getUser();
        ExGods.app.block();
        me.service.command('change_real_money_service', {
            preset: money
        }, function() {
            me.service.update(null, function() {
                var bankreplenishment = Ext.ComponentQuery.query('bankreplenishment')[0];
                if (bankreplenishment) {
                    bankreplenishment.reloadReplenishment(me.service.data);
                }
                ExGods.app.unblock();
            });
        });
    },
    /**
     * Показывает окно привязки к социальной сети
     * @private
     */
    onSocialNetAssign: function() {
        this.toggleBankServices(1);
    },
    initBankComponent: function(config, componentId) {
        var me = this,
            cmp, wnd;
        me.service = config.service;
        cmp = {
            xtype: 'banktabpanel',
            service: me.service,
            activeTab: me.initialTabId,
            items: [
                {
                    xtype: 'bankreplenishment',
                    user: ExGods.app.user,
                    icon: ExGods.ref('images|bank_icons').image.change_icon,
                    service: me.service
                },
                {
                    xtype: 'bankbonus',
                    user: ExGods.app.user,
                    icon: ExGods.ref('images|bank_icons').image.bonus_icon,
                    service: me.service,
                    hidden: isSocialApp
                }
            ]
        };
        delete me.initialTabId;
        wnd = Ext.widget('window2', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ]
        });
        ExGods.app.block();
        ExGods.Resources.load(wnd, function() {
            ExGods.app.unblock();
            wnd.show();
        });
        return wnd;
    }
});

/**
 * Пополнение банковского счёта
 */
Ext.define('ExGods.view.bank.Replenishment2', {
    extend: Ext.container.Container,
    alias: 'widget.bankreplenishment2',
    cls: 'bank-replenishment',
    header: false,
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            bank = ExGods.model.Bank,
            gold = ExGods.references.get('user_money').get('gold'),
            coins = ExGods.references.get('user_money').get('coins'),
            presets = me.service.data.payment_preset,
            items = [],
            fields = [
                {
                    name: 'bonus',
                    type: 'auto'
                },
                {
                    name: 'count',
                    type: 'int'
                },
                {
                    name: 'price',
                    type: 'float'
                },
                {
                    name: 'stuff_for_show',
                    type: 'auto'
                },
                {
                    name: 'game_currency',
                    type: 'string'
                },
                {
                    name: 'app',
                    type: 'string'
                },
                {
                    name: 'entry',
                    type: 'string'
                },
                {
                    name: 'order',
                    type: 'int'
                },
                {
                    name: 'special',
                    type: 'int'
                },
                {
                    name: 'description',
                    type: 'auto'
                },
                {
                    name: 'image',
                    type: 'string'
                },
                {
                    name: 'title',
                    type: 'string'
                }
            ];
        me.presetStore = Ext.create('Ext.data.Store', {
            fields: fields,
            data: presets,
            sorters: [
                {
                    property: 'order',
                    direction: 'ASC'
                }
            ]
        });
        me.items = [
            {
                xtype: 'panel',
                x: 0,
                y: 0,
                plugins: [
                    'paperdeco'
                ],
                data: {
                    isSocialApp: isSocialApp,
                    isVK: isVK,
                    isOK: isOK,
                    isMM: isMM,
                    isFB: isFB
                },
                tpl: [
                    '<div class="bank-header">',
                    '<tpl if="!isSocialApp">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('view_bank_repl_count_id') + '",{id:' + user.get('id') + '})]}</div>',
                    '<div>' + ExGods.getMsgByKey('view_bank_on_your_account') + ' <strong id="coins_value">' + Ext.util.Format.number(user.get('money').coins, '0,0') + ' ' + Ext.util.Format.plural(user.get('money').coins, ExGods.getMsgByKey('moneta_name').split(',')) + '</strong></div>',
                    '</tpl>',
                    '<tpl if="isVK">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_vk') + '</div>',
                    '</tpl>',
                    '<tpl if="isOK">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_ok') + '</div>',
                    '</tpl>',
                    '<tpl if="isMM">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_mm') + '</div>',
                    '</tpl>',
                    '<tpl if="isFB">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_fb') + '</div>',
                    '</tpl>',
                    '</div>'
                ],
                width: '100%',
                height: isSocialApp ? 100 : 100
            },
            {
                xtype: 'bankpresets',
                store: me.presetStore,
                buy_btn_id: 'bank2-buy'
            }
        ];
        me.mon(user, 'moneycoinschanged', function(value) {
            Ext.fly('coins_value').setHTML(Ext.util.Format.number(value, '0,0') + ' ' + Ext.util.Format.plural(value, ExGods.getMsgByKey('moneta_name').split(',')));
        }, me);
        me.callParent();
    },
    reloadReplenishment: function(service_data) {
        var me = this;
        me.presetStore.loadRawData(service_data.payment_preset);
    },
    onDestroy: function() {
        var me = this,
            replenish_button = Ext.getCmp('do-replenish'),
            reward_button = Ext.getCmp('do-get-reward');
        if (replenish_button)  {
            replenish_button.destroy();
        }
        
        if (reward_button)  {
            reward_button.destroy();
        }
        
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'npc/human/trader_small.jpg'
            ].concat(arr_images)
        };
    }
});

/**
 * Управление банком
 */
Ext.define('ExGods.controller.Bank2', {
    extend: ExGodsCore.controller.Base,
    views: [
        'bank.Bonus',
        'bank.Replenishment2',
        'bank.Presets',
        'bank.TabPanel'
    ],
    init: function(app) {
        var me = this;
        me.control({
            'textbutton[action="bank2-buy"]': {
                click: me.onBuyClickBtn
            }
        });
        ExGods.Components.addComponentInitializer('bank2', me.initBank2Component, me);
    },
    onBuyClickBtn: function(btn) {
        var me = this,
            values = JSON.parse(btn.values),
            value, currency, plurals, plurals2;
        if (isSocialApp) {
            me.app.getSocialController().buy(values);
        } else {
            value = values.count;
            currency = ExGods.references.get('user_money').get(values.game_currency);
            plurals = values.game_currency == 'gold' ? ExGods.getMsgByKey('gold_name').split(',') : ExGods.getMsgByKey('crystal_name').split(',') , plurals2 = values.app == 'sa' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'vka' ? ExGods.getMsgByKey('payment_vka').split(',') : values.app == 'oka' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'mma' ? ExGods.getMsgByKey('moneta_name').split(',') : [
                '',
                '',
                ''
            ];
            document.getElementById('modal_price').innerHTML = Ext.String.format(ExGods.getMsgByKey('bank_excahnge_confirmation'), '<strong>' + Ext.util.Format.number(values.price, '0,0') + '</strong> ' + Ext.util.Format.plural(values.price, plurals2), '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + '<strong>' + Ext.util.Format.number(value, '0,0') + '</strong> ' + Ext.util.Format.plural(value, plurals));
            openPaymentWindow({
                uid: ExGods.app.user.get('id'),
                purchase: {
                    amount: value,
                    currency: "RUB",
                    description: values.description
                },
                custom: {
                    preset: values.entry
                }
            });
        }
    },
    initBank2Component: function(config, componentId) {
        var me = this,
            cmp, wnd;
        me.service = config.service;
        cmp = {
            xtype: 'banktabpanel',
            service: me.service,
            activeTab: me.tab_id,
            items: [
                {
                    xtype: 'bankreplenishment2',
                    user: ExGods.app.user,
                    icon: ExGods.ref('images|bank_icons').image.change_icon,
                    service: me.service
                },
                {
                    xtype: 'bankbonus',
                    user: ExGods.app.user,
                    icon: ExGods.ref('images|bank_icons').image.bonus_icon,
                    service: me.service,
                    hidden: isSocialApp
                }
            ]
        };
        delete me.tab_id;
        wnd = Ext.widget('window2', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ],
            listeners: {
                close: function() {
                    var el = document.getElementById('payment_window');
                    if (el)  {
                        el.remove();
                    }
                    
                }
            }
        });
        ExGods.app.block();
        ExGods.Resources.load(wnd, function() {
            ExGods.app.unblock();
            wnd.show();
            me.appendWindowComponent();
        });
        return wnd;
    },
    appendWindowComponent: function() {
        if (document.getElementById('payment_window'))  {
            return;
        }
        
        var el = document.createElement('div');
        el.style.display = 'none';
        el.id = 'payment_window';
        el.className = 'modal-window';
        el.innerHTML = [
            '<div class="window">',
            '<div class="modal_head">',
            '<img src="' + IMAGE_URL + 'bank/logo.png">',
            '<a class="close" onclick="closePaymentWindow();"></a>',
            '</div>',
            '<div layout="row" layout-align="center" class="modal-price" id="modal_price"></div>',
            '<div id="payment_window_iframe" class="payment-window-iframe"></div>',
            '</div>'
        ].join('');
        document.body.appendChild(el);
    }
});

/**
 * Диалог боевой цепочки
 */
Ext.define('ExGods.view.battlechain.Dialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.battlechaindialog',
    id: 'battle-chain-dialog',
    cls: 'bot-dialog',
    bodyPadding: '7 8 0 6',
    /**
     * @cfg chain Данные цепочки
     **/
    initComponent: function() {
        var me = this;
        me.levelInfo = {};
        var chain = me.chain,
            service = me.service,
            levelInfo = me.levelInfo,
            i = chain.levels.length,
            chain_stuff = ExGods.helpme.flatStuff(chain.stuff);
        me.chain_stuff = chain_stuff;
        while (i > 0) {
            i--;
            if (chain.levels[i].level == chain.current_level) {
                levelInfo = chain.levels[i];
                break;
            }
        }
        if (!levelInfo.bot.name_with_level) {
            levelInfo.bot.name_with_level = ExGods.printUser({
                hoard: {
                    level: levelInfo.bot.level
                },
                display_title: levelInfo.bot.label
            }, {
                fields: 'level,name',
                maxNameWidth: '180'
            });
        }
        if (!levelInfo.bot.image) {
            levelInfo.bot.image = ExGodsCore.app.references.get('user_shape').getByKey(levelInfo.bot.shape).full;
        }
        var leftTime = ExGods.util.Date.normalizeServerDateTime(levelInfo.bot.chain_next_time) - Date.now();
        me.levelInfo = levelInfo;
        me.tplForContent = [
            '<div class="paper-title">' + chain.label + '</div>',
            '<div class="description">',
            ExGods.app.applyTpl(chain.desc.description, {
                total: chain.levels.length,
                current: chain.current_level,
                time_to_next: ExGods.util.Time.printRestTime(ExGods.util.Date.normalizeServerDateTime(chain.start_next_time), {
                    format: 'twonums'
                })
            }),
            '</div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('chain_level_loot') + '</div>',
            '<div id="level-rewards" class="npc_stuff_2">',
            //ExGods.stuff.StuffManager.image(levelInfo.bot.stuff),
            '</div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('chain_total_loot') + '</div>',
            '<div id="total-rewards" class="npc_stuff_2">',
            //ExGods.stuff.StuffManager.image(chain_stuff),
            '</div>'
        ].join('');
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                layout: 'absolute',
                height: 370,
                items: [
                    {
                        itemId: 'info',
                        cls: 'dialog-info',
                        style: {
                            borderRight: '1px solid #7d4b2a'
                        },
                        width: 230,
                        height: 350,
                        y: 7,
                        x: 11,
                        tpl: new Ext.XTemplate([
                            '<div class="paper-title">{bot.name_with_level}</div>',
                            '<div class="frame"></div>',
                            '<div class="image bot-info-stats-container" style="background-image: url({bot.image})">',
                            '<tpl if="this.isInfo()">',
                            '<div class="info-top-container">',
                            '<div class="paper paper-tl"></div>',
                            '<div class="paper paper-tm"></div>',
                            '<div class="paper paper-tr"></div>',
                            '<div class="paper paper-mr"></div>',
                            '<div class="paper paper-br"></div>',
                            '<div class="paper paper-bm"></div>',
                            '<div class="paper paper-bl"></div>',
                            '<div class="paper paper-ml"></div>',
                            '<div class="paper paper-bg"></div>',
                            '<div class="avatar-info-container">',
                            '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
                            '<div class="avatar-params stats-list">',
                            '{[ ExGods.util.User.printUserStats(values.bot.stats, {visibleValue: 1, align: "right"}) ]}',
                            '</div>',
                            '<div class="paper-separator"></div>',
                            '<div class="avatar-statsstars">',
                            '{[ ExGods.util.User.printUserStats(values.bot.stats, {visibleValue: 2}) ]}',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</tpl>',
                            '</div>',
                            {
                                isInfo: function() {
                                    return me.isInfo;
                                }
                            }
                        ]),
                        data: levelInfo
                    },
                    {
                        itemId: 'content-container',
                        width: 510,
                        height: 350,
                        style: {
                            borderLeft: '1px solid #7d4b2a'
                        },
                        x: 245,
                        y: 7,
                        items: [
                            {
                                itemId: 'content',
                                cls: 'dialog-content',
                                html: me.tplForContent
                            }
                        ]
                    },
                    {
                        itemId: 'v-separator',
                        width: 10,
                        height: 358,
                        html: '<div class="v-separator"></div>',
                        x: 240,
                        y: 0
                    },
                    {
                        itemId: 'separator',
                        width: 511,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 141
                    },
                    {
                        itemId: 'separator2',
                        width: 511,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 246
                    }
                ]
            },
            {
                xtype: 'container',
                style: {
                    padding: '0 0 0 385px',
                    height: '47px'
                },
                items: [
                    {
                        xtype: 'textbutton',
                        cls: 'qh-object double_text_btn x-btn-txt-red',
                        id: 'chain-attack',
                        margin: '0 0 0 -110',
                        text: 'img:' + ExGods.ref('images|bot_dialog_images').image['text_attack']
                    },
                    {
                        xtype: 'textbutton',
                        cls: 'qh-object double_text_btn double_text',
                        id: 'chain-forfeit',
                        margin: '0 0 0 10',
                        text: 'img:' + ExGods.ref('images|bot_dialog_images').image['text_surrender']
                    }
                ]
            }
        ];
        me.callParent();
        var stuff = (levelInfo.bot.stuff || []).concat(chain_stuff);
        ExGods.util.Helper.loadProtosFromStuff(stuff, function() {
            var update = function() {
                    me.el.down('#level-rewards').update(ExGods.stuff.StuffManager.image(levelInfo.bot.stuff));
                    me.el.down('#total-rewards').update(ExGods.stuff.StuffManager.image(chain_stuff));
                };
            if (me.rendered) {
                update();
            } else {
                me.on('afterrender', update);
            }
        });
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        //ExGods.util.Ticker.addListener(me.updateTime, me);
        me.el.on('click', function() {
            me.isInfo = !me.isInfo;
            me.onInfoChange();
        }, me, {
            delegate: '.info-btn'
        });
    },
    updateTime: function() {
        var me = this,
            time = ExGods.util.Date.normalizeServerDateTime(me.levelInfo.bot.chain_next_time) - Date.now();
        try {
            me.el.down('#chain-timer').setHTML(ExGods.util.Time.printTime(time / 1000));
        } catch (e) {}
        
    },
    onDestroy: function() {
        var me = this;
        //ExGods.util.Ticker.removeListener(me.updateTime);
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        stuff_arr = (me.levelInfo.bot.stuff || []).concat(me.chain_stuff);
        var imgs = ExGods.ref('images|bot_dialog_images').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        return {
            stuff: stuff_arr,
            images: [
                me.levelInfo.bot.image
            ].concat(arr_images)
        };
    }
});

/**
 * Контроллер боевых цепочек
 */
Ext.define('ExGods.controller.BattleChain', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    views: [
        'battlechain.Dialog'
    ],
    stores: [],
    //
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BattleChain:'
    },
    init: function(app) {
        var me = this;
        me.service = ExGods.Services.get('battle_chains');
        me.control({
            '#LOB_BOT_LIST': {
                itemclick: {
                    fn: me.onSurgingBotClick,
                    delay: 0
                }
            },
            '#chain-attack': {
                click: function() {
                    me.service.command('start_chain');
                }
            },
            '#chain-forfeit': {
                click: me.onForfeit
            }
        });
        me.callParent();
    },
    /**
     * Вернет данные по текущей цепочке
     */
    getChain: function() {
        var me = this;
        return ExGods.app.user.location.data.battle_chain;
    },
    /**
     * Вернет данные следующего бота цепочки в формате набегания
     */
    getSurgingChainEntry: function() {
        var me = this,
            chain = me.getChain(),
            entry;
        if (chain) {
            Ext.Array.each(chain.levels, function(data) {
                if (data.level == chain.current_level) {
                    entry = data.bot;
                    entry.count = 1;
                    entry.chain = 1;
                    entry.chain_next_time = chain.start_next_time;
                }
            });
        }
        return entry;
    },
    /**
     * Показать вью цепочки
     */
    showChainDialog: function() {
        var me = this;
        me.chainDialog = Ext.widget('window2', {
            autoShow: false,
            items: [
                {
                    xtype: 'battlechaindialog',
                    chain: me.getChain(),
                    service: me.service
                }
            ],
            closeAction: 'destroy'
        });
        ExGods.Resources.load(me.chainDialog, function() {
            me.chainDialog.show();
        });
    },
    /**
     * @private
     */
    onSurgingBotClick: function(view, item) {
        var me = this;
        if (item.data.chain) {
            me.showChainDialog();
        }
    },
    onForfeit: function() {
        var me = this;
        var dlg = Ext.widget('confirmdialog', {
                autoShow: false,
                message: new Ext.Template(ExGods.ref('message_client|surrender_chain')).apply({}),
                handler: function() {
                    me.service.command('surrender_chain', {}, function(json) {
                        if (json.success) {
                            me.app.getSurgingController().updateStore();
                            me.chainDialog.close();
                            Ext.getCmp('mainmenu').enableMenu();
                        }
                    });
                }
            });
        ExGods.Resources.load(dlg, function() {
            dlg.show();
        });
    }
});

/**
 * Контроллер боя.
 *
 * @author Oleg M.
 */
Ext.define('ExGods.controller.battle.Battle', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Battle:'
    },
    /**
     * @property {Ext.data.Store} list Список участников боя
     */
    list: null,
    /**
     * @property {Object} state Состояние боя
     */
    state: {},
    /**
     * @property {Object} pairs Пары противников в бою. Обновляется с каждым раундом
     */
    pairs: {},
    /**
     * @property {Object} result Результат боя
     */
    result: {},
    /**
     * @property {Object} hints Хинты
     */
    hints: {},
    /**
     * @property {Number} battle_type Тип текущего боя
     */
    battle_type: 0,
    /**
     * @property {Number} ekeys список ID участников боя, для которых нужно запросить display_title
     */
    ekeys: [],
    init: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.factory('battle_no_start', {
            title: 'Начало боя ',
            showInConsole: false
        });
        /*****/
        ExGods.util.RemoteDebug.factory('battle_no_finish', {
            title: 'Окончание боя ',
            showInConsole: false,
            limit: 40
        });
        me.control({
            '#battle-result': {
                afterrender: function() {
                    clearInterval(ExGods.util.RemoteDebug.get('battle_no_finish').interval);
                    ExGods.util.RemoteDebug.get('battle_no_finish').interval = null;
                }
            }
        });
        me.app.getChatConnection().on({
            command_battle_log: me.onBattleLogMessage,
            command_buser: Ext.Function.createBuffered(me.reloadState, 250, me),
            command_battle_exit: me.onBattleExit,
            scope: me
        });
        // быстрая ссылка на контроллер боя
        me.battleView = me.app.getController('battle.BattleView');
        // быстрая ссылка на контроллер анимации
        me.animation = me.app.getController('battle.Animation');
        // быстрая ссылка на контроллер стабильности
        me.stability = me.app.getController('battle.Stability');
        me.list = new Ext.util.MixedCollection();
        me.callParent();
    },
    /**
     * Подгружает данные боя. Генерирует события: 'load_start' и 'start' или 'finish'
     */
    loadStart: function(callback) {
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').clear();
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').clear();
        /*****/
        if (ExGods.util.RemoteDebug.get('battle_no_start').interval) {
            clearInterval(ExGods.util.RemoteDebug.get('battle_no_start').interval);
            ExGods.util.RemoteDebug.get('battle_no_start').interval = null;
        }
        if (ExGods.util.RemoteDebug.get('battle_no_finish').interval) {
            clearInterval(ExGods.util.RemoteDebug.get('battle_no_finish').interval);
            ExGods.util.RemoteDebug.get('battle_no_finish').interval = null;
        }
        /*****/
        (function() {
            var now = new Date();
            var interval = setInterval(function() {
                    if (Ext.getCmp('battle-container') || Ext.getCmp('battle-result') || me.result) {
                        clearInterval(interval);
                    } else if (new Date() - now > 15 * 1000) {
                        ExGods.util.RemoteDebug.get('battle_no_start').send();
                        ExGods.util.RemoteDebug.get('battle_no_start').interval = null;
                        clearInterval(interval);
                    }
                }, 150);
            ExGods.util.RemoteDebug.get('battle_no_start').interval = interval;
        }());
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@battle Загружаю данные боя');
        var me = this,
            _onSuccess = function(data) {
                me.pairs = data.pairs;
                me.battleRequestSuccess(data, function(data) {
                    // создаю список участников
                    if (data.list) {
                        Ext.Array.each(data.list, function(u) {
                            me.list.add(u.battle.ekey, u);
                        });
                    }
                    // накатываю изменения, которые пришли до подгрузки списка
                    if (me.preloadChanges.length) {
                        Ext.Array.each(me.preloadChanges, function(changes) {
                            me.applyChanges(changes, true);
                        });
                    }
                    if (data.hints) {
                        me.hints = {};
                        Ext.Array.each(data.hints, function(hint) {
                            me.hints[hint.key] = hint.hint;
                        });
                    }
                    me.battle_type = data.battle_type;
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_start').log('@battle Список участников создан, генерирую событие "start"');
                    me.started = true;
                    // событие "старт" для окружения
                    /***/
                    me.fireEvent('start', me, me.state);
                    me.battleView.onBattleStart(me, me.state);
                });
            };
        // очищаю данные предыдущего боя
        me.result = null;
        me.resultLoading = false;
        me.list.removeAll();
        me.preloadChanges = [];
        me.pairs = {};
        /***/
        me.fireEvent('load_start', me, me.state);
        me.battleView.onBattleLoadStart(me, me.state);
        /***/
        me.log('Подгружаю данные боя');
        me.request({
            url: 'battle.pl?cmd=battle_list',
            success: function(json) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_start').log('@battle Данные боя: ' + Ext.encode(json));
                if (json && json.success) {
                    _onSuccess(json);
                    if (callback) {
                        callback();
                    }
                } else {
                    /***/
                    me.log('error', 'ошибка при подгрузке данных боя', json);
                }
            }
        });
    },
    /**
     * @private Подгружает результат. Генерирует событие "load_finish" и "finish"
     */
    loadFinish: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Бой закончен (команда чата "finish")');
        /*****/
        if (ExGods.util.RemoteDebug.get('battle_no_finish').interval) {
            clearInterval(ExGods.util.RemoteDebug.get('battle_no_finish').interval);
            ExGods.util.RemoteDebug.get('battle_no_finish').interval = null;
        }
        /*****/
        (function() {
            var now = new Date();
            var interval = setInterval(function() {
                    if (Ext.getCmp('battle-result') || ExGods.app.getController('Viewport').layout == 'main') {
                        clearInterval(interval);
                    } else if (new Date() - now > 20 * 1000) {
                        var emptySide = false;
                        if (me.result && me.result.participant && me.result.participant.length) {
                            me.result.participant.forEach(function(side) {
                                if (side.length === 0) {
                                    emptySide = true;
                                }
                            });
                        }
                        if (!emptySide) {
                            ExGods.util.RemoteDebug.get('battle_no_finish').send();
                        }
                        ExGods.util.RemoteDebug.get('battle_no_finish').interval = null;
                        clearInterval(interval);
                    }
                }, 150);
            ExGods.util.RemoteDebug.get('battle_no_finish').interval = interval;
        }());
        /***/
        me.fireEvent('load_finish');
        me.battleView.onBattleLoadFinish();
        /***/
        me.log('Запрос подтверждения окончания боя');
        me.request({
            url: 'battle.pl?cmd=battle_current',
            success: function(json) {
                if (json && json.success) {
                    me.battleRequestSuccess(json);
                } else {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Ответ сервера !success - ' + Ext.encode(json));
                    /***/
                    me.log('error', 'ошибка при подгрузке данных боя', json);
                }
            }
        });
    },
    /**
     * @private
     * Подгружает данные раунда. События - 'load_round', 'round' или 'finish'
     */
    loadRound: function(roundNum) {
        var me = this,
            triggerRound = function() {
                setTimeout(function() {
                    me.battleView.onBattleRound(me, me.state);
                }, 400);
            };
        /***/
        me.log('Подгружаю данные раунда #', roundNum);
        me.state.round = roundNum;
        /***/
        me.fireEvent('load_round', me);
        me.battleView.onBattleLoadRound(me);
        me.request({
            url: 'battle.pl?cmd=battle_current',
            success: function(json) {
                if (json && json.success) {
                    if (json.battle_in_finish) {
                        /***/
                        me.fireEvent('round', me, me.state);
                        triggerRound();
                    } else {
                        me.battleRequestSuccess(json, function() {
                            /***/
                            me.fireEvent('round', me, me.state);
                            triggerRound();
                        });
                    }
                } else {
                    /***/
                    me.log('error', 'ошибка при подгрузке данных раунда', json);
                }
            }
        });
    },
    /**
     * Подгрузка данных боя
     * @param callback
     * @param force true - запрашивать, даже если уже была попытка запроса
     */
    loadBattleResult: function(callback, force) {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Загружаю данные боя');
        if (!force && me.resultLoading) {
            return;
        }
        // чтобы не запрашивать дважды
        me.resultLoading = true;
        me.request({
            url: 'battle.pl?cmd=battle_result',
            success: function(json) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Данные боя: ' + Ext.encode(json));
                if (!json || !json.success) {
                    // данные уже запрошены ранее, или ошибка сервера
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Данные уже запрошены ранее, или ошибка сервера');
                    callback(null);
                } else if (json.battle_in_finish || json.battle_not_start) {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Данные еще не готовы. жду 5 секунд и перезапрашиваю данные');
                    setTimeout(function() {
                        me.loadBattleResult(callback, true);
                    }, 5000);
                } else {
                    callback(json.battle_result);
                }
            }
        });
    },
    /**
     * Выполение базового действия. Coбытия 'before_kick', 'kick'
     */
    doKick: function(name) {
        var me = this,
            kickInfo;
        if (me.state.can_kick) {
            kickInfo = Ext.Array.findBy(me.state.av_kick, function(item) {
                return item.name == name;
            });
            if (kickInfo && kickInfo.renew) {
                /***/
                me.log('Запрос на выполнение базового действия с рероллом');
                /***/
                me.fireEvent('before_reroll', me);
                me.battleView.onBattleBeforeReroll(me);
                me.battleActionRequest({
                    cmd: 'battle_kick',
                    kick: name,
                    round: me.state.round
                }, function() {
                    /***/
                    me.fireEvent('reroll', me);
                    me.battleView.onBattleReroll(me);
                });
            } else {
                /***/
                me.log('Запрос на выполнение базового действия');
                /***/
                me.fireEvent('before_kick', me);
                me.battleView.onBattleBeforeKick(me);
                me.battleActionRequest({
                    cmd: 'battle_kick',
                    kick: name,
                    round: me.state.round
                }, function() {
                    /***/
                    me.fireEvent('kick', me.state.kick);
                    me.battleView.onBattleKick(me.state.kick);
                });
            }
        }
    },
    /**
     * Выполение моментального действия. Coбытия 'before_prep', 'prep'
     */
    doPrep: function(prepName) {
        var me = this,
            user = me.getUser(),
            refData = ExGods.ref('battle_prep|' + prepName),
            prepData = Ext.Array.findBy(me.state.av_prep, function(prep) {
                return prep.name == prepName;
            }),
            doPrepInner = function(targetEkey) {
                /***/
                me.log('Запрос на выполнение моментального действия');
                /***/
                me.fireEvent('before_prep', me);
                me.battleView.onBattleBeforePrep(me);
                me.battleActionRequest({
                    cmd: 'battle_instant',
                    kick: prepName,
                    target: targetEkey,
                    round: me.state.round
                }, function() {
                    /***/
                    me.fireEvent('prep', me);
                    me.battleView.onBattlePrep(me);
                });
            },
            selectTarget = function(callback) {
                if (prepData.strike) {
                    ExGods.Components.factory('USER_TARGET_PANEL', {
                        windowTitle: refData.label,
                        source: 'battle',
                        side: prepData.strike.side == 0 ? user.getBattleSide() : 2,
                        dead: prepData.strike.is_dead,
                        listeners: {
                            select: function(wnd, rec) {
                                callback(rec.get('battle').ekey);
                                wnd.up().close();
                            }
                        }
                    });
                } else {
                    callback();
                }
            },
            doClientBeforePrep = function(callback) {
                if (prepData.client) {
                    if (prepData.client == 'invite') {
                        me.app.getSocialController().invite(callback);
                    }
                } else {
                    callback();
                }
            };
        if (prepData) {
            // выполняю дейсвтие, соответствующее ключу "client"
            doClientBeforePrep(function() {
                // выбираю цель для предварительного
                selectTarget(function(targetEkey) {
                    doPrepInner(targetEkey);
                });
            });
        }
    },
    /**
     * "Реролл" доступных действий. Coбытия 'before_reroll', 'reroll'
     */
    doReroll: function() {
        var me = this,
            user = me.getUser();
        /***/
        me.log('Запрос на реролл доступных действий');
        /***/
        me.fireEvent('before_reroll', me);
        me.battleView.onBattleBeforeReroll(me);
        me.battleActionRequest({
            cmd: 'battle_reroll',
            kick: name,
            round: me.state.round
        }, function() {
            /***/
            me.fireEvent('reroll', me);
            me.battleView.onBattleReroll(me);
        });
    },
    /**
     * Обработчик боевого движения. Вызывается из контроллера действий (ExGods.controller.Action)
     * Генерирует событие "item"
     */
    onItemActionHandler: function(data) {
        var me = this;
        me.battleRequestSuccess(data);
        /***/
        me.fireEvent('item', me);
        me.battleView.onBattleItem(me);
    },
    onBattleLogMessage: function(chatcn, message) {
        var me = this,
            data = message.body.data;
        /***/
        me.log('Сообщение лога боя с типом ' + data.type, data);
        switch (data.type) {
            case 'start':
                me.loadStart();
                break;
            case 'meddle':
                if (!me.started) {
                    me.loadStart();
                } else {
                    if (!me.list.getByKey(data.user.battle.ekey)) {
                        me.list.add(data.user.battle.ekey, data.user);
                        /***/
                        me.fireEvent('u_add', data.user);
                        me.battleView.onBattleUserAdd(data.user);
                        if (data.user.is_bot) {
                            me.ekeys.push(data.user.battle.ekey);
                            me.updateTitles();
                        }
                    }
                };
                break;
            case 'resurect':
                me.resurectUser(data);
                break;
            case 'finish':
                me.loadFinish();
                break;
            case 'newround':
                if (data.round != 1) {
                    me.loadRound(data.round);
                };
                me.pairs = data.pairs;
                break;
            case 'changes':
                {
                    if (me.started) {
                        me.applyChanges(data);
                    } else {
                        me.preloadChanges.push(data);
                    }
                    break;
                };
        }
        // отлавливаю основные действия юзера и врага и генерирую события "user_kick", "enemy_kick"
        if (me.state.live != "0" && data.turn_name) {
            var u = data.u || data.u1,
                enemyBattleEkey = me.state.enemy;
            if (u && u[2] == me.user.getBattleEkey()) {
                /***/
                me.fireEvent('user_kick', data.turn_name);
                me.battleView.onBattleUserKick(data.turn_name);
            } else if (u && enemyBattleEkey && u[2] == enemyBattleEkey) {
                /***/
                me.fireEvent('enemy_kick', data.turn_name);
                me.battleView.onBattleEnemyKick(data.turn_name);
            }
        }
        // если боевое или предварительное действие совершено над текущим игроком,
        // то перезапрашиваю состояние боя (например, противник выжег ману предварительным и какие-то действия стали недоступны)
        if (data.prepare_name || data.action_id) {
            if (data.u1 && data.u2 && data.u1[2] != me.user.getBattleEkey() && data.u2[2] == me.user.getBattleEkey()) {
                me.reloadState();
            }
        }
    },
    /**
     * @private Обработка сообщения чата "battle_exit" - игрок вышел из боя
     */
    onBattleExit: function() {
        var me = this;
        me.user.loadRemote(function() {
            /***/
            me.fireEvent('exit');
            me.battleView.onBattleExit();
        });
    },
    updateTitles: Ext.Function.createBuffered(function() {
        var me = this;
        if (me.ekeys.length) {
            me.battleActionRequest({
                cmd: 'battle_ut',
                ekeys: Ext.JSON.encode(me.ekeys)
            }, function(data) {
                me.ekeys = [];
                Ext.Object.each(data.list, function(ekey, title) {
                    var user = me.list.getByKey(ekey);
                    if (user) {
                        user.display_title = title;
                        /***/
                        me.fireEvent('u_title', ekey, title);
                        me.battleView.onBattleUserTitle(ekey, title);
                    }
                });
            });
        }
    }, 1000),
    /**
     * @private Обновить состояние боя
     */
    reloadState: function() {
        var me = this;
        /****/
        me.log('Обновляю состояние боя');
        me.request({
            url: 'battle.pl?cmd=battle_current',
            success: function(json) {
                if (json && json.success) {
                    if (json.buser) {
                        // накатываю новое состояние 
                        me.state = Ext.apply(me.state, json.buser);
                        /***/
                        me.fireEvent('state_refresh');
                        me.battleView.onBattleStateRefresh();
                    }
                } else {
                    /***/
                    me.log('error', 'ошибка при подгрузке данных боя', json);
                }
            }
        });
    },
    /**
     * @private Запрос на выполнение какого-либо действия в бою
     */
    battleActionRequest: function(params, callback) {
        var me = this;
        me.request({
            url: 'battle.pl',
            params: params,
            success: function(json) {
                me.battleRequestSuccess(json);
                if (callback) {
                    callback(json);
                }
            }
        });
    },
    /**
     * Воскресить юзера
     */
    resurectUser: function(data) {
        var me = this;
        if (data.user) {
            me.list.each(function(u) {
                if (u.battle.ekey == data.user.battle.ekey) {
                    Ext.apply(u, data.user);
                    /***/
                    me.fireEvent('u_change', u);
                    me.battleView.onBattleUserChange(u);
                }
            });
        }
    },
    /**
     * @private Применяет изменения для участников
     */
    applyChanges: function(data, silent) {
        var me = this,
            _applyChanges = function(u, changes) {
                var prepared = {};
                if (changes.timed) {
                    Ext.apply(u.timed, changes.timed);
                }
                // в изменениях timed приходят частично, поэтому нельзя накатить напрямую changes.timed
                if (changes.aura) {
                    u.aura = changes.aura;
                }
                if (changes.stats) {
                    Ext.apply(u.stats.stats, changes.stats);
                }
                if (changes.died == "1") {
                    u.battle.live = 0;
                    // выставляю признак что убит
                    u.timed.hp[0] = 0;
                    // обнуляю вручную hp когда мёртв
                    u.timed.shield[0] = 0;
                }
                // обнуляю вручную shield когда мёртв
                if (changes.shape) {
                    u.shape = changes.shape;
                }
            };
        /***/
        me.log('Изменения', data);
        me.list.each(function(u) {
            if (data.list[u.battle.ekey]) {
                _applyChanges(u, data.list[u.battle.ekey]);
                if (!silent) {
                    /***/
                    me.fireEvent('u_change', u);
                    me.battleView.onBattleUserChange(u);
                }
            }
        });
    },
    /**
     * Вернёт данные текущего противника
     */
    getEnemy: function() {
        var me = this,
            index;
        if (me.state.enemy) {
            return me.list.findBy(function(u) {
                return u.battle.ekey == me.state.enemy;
            });
        } else {
            return null;
        }
    },
    /**
     * @private Общий обработчик боевых запросов
     */
    battleRequestSuccess: function(json, onActiveBattle) {
        var me = this;
        if (json && json.success) {
            try {
                if (json.buser && json.buser.user) {
                    me.user.set(json.buser.user);
                }
                if (json.buser) {
                    me.state = json.buser;
                    if (json.buser.marks) {
                        /***/
                        me.fireEvent('apply_marks', json.buser.marks);
                        me.battleView.applyMarks(json.buser.marks);
                    }
                }
            } catch (e) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Ошибка обработки ответа боевого запроса ' + e);
            }
            if (json.battle_is_done) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Бой завершен (battle_is_done) ');
                me.loadBattleResult(function(result) {
                    delete me.started;
                    me.result = result;
                    me.battle_type = 0;
                    /***/
                    me.fireEvent('finish', me, me.result);
                    me.battleView.onBattleFinish(me, me.result);
                });
            } else if (json.not_active_battle) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Ответ сервера - not_active_battle');
                /***/
                me.fireEvent('not_active_battle', me);
                me.battleView.onNotActiveBattle(me);
            } else if (json.battle_not_start) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_start').log('@battle Ответ сервера - battle_not_start');
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Ответ сервера - battle_not_start');
            }
            // игнорирую такой тип ответа, ожидая команду чата "start"
            else if (onActiveBattle) {
                onActiveBattle.call(me, json);
            }
        } else {
            /***/
            me.log('error', 'ошибка боевого запроса. параметры', json);
        }
    },
    /**
     * Перезагружает данные боя и обновляет отображение
     */
    restartBattle: function() {
        var me = this;
        me.loadStart();
    }
});

Ext.define('ExGods.view.battle_new.stuff.BattleReward', {
    extend: ExGods.stuff.stuff.Expa,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.stuff.decorator.BonusStick);
        return data;
    }
});

/**
 * Аватар персонажа в бою
 */
Ext.define('ExGods.view.battle_new.Avatar', {
    extend: Ext.Container,
    alias: 'widget.battle_avatar',
    /**
     * @cfg Модель юзера
     */
    user: null,
    layout: 'fit',
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'panel',
                //plugins: ['paperdeco'],
                //padding: '10 18 20 18',
                tpl: [
                    '<div class="battle-avatar-bg">',
                    '<tpl if="display_title">',
                    // если есть данные 
                    '<div class="info-btn-{[this.getSide()]}-container">',
                    '<div class="info-btn"></div>',
                    '</div>',
                    '<tpl if="this.isInfo()">',
                    '<div class="info-top-container">',
                    '<div class="paper paper-tl"></div>',
                    '<div class="paper paper-tm"></div>',
                    '<div class="paper paper-tr"></div>',
                    '<div class="paper paper-mr"></div>',
                    '<div class="paper paper-br"></div>',
                    '<div class="paper paper-bm"></div>',
                    '<div class="paper paper-bl"></div>',
                    '<div class="paper paper-ml"></div>',
                    '<div class="paper paper-bg"></div>',
                    '<div class="avatar-info-container">',
                    '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
                    '<div class="avatar-params stats-list">',
                    '{[ ExGods.util.User.printUserStats(this.getSummaryStats(values), {visibleValue: 1, align: "right"}) ]}',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    '{[ ExGods.util.User.printUserStats(this.getSummaryStats(values), {visibleValue: 2}) ]}',
                    '<tpl if="bot_visible_turns.length || bot_visible_instants.length || bot_visible_battle_actions.length">',
                    '<div class="stats-list like_table">',
                    '<div class="align_middle">',
                    '<tpl if="bot_visible_turns.length">',
                    '<tpl for="bot_visible_turns">',
                    '{[this.printAction("turn", xindex-1)]}',
                    '</tpl>',
                    '</tpl>',
                    '<tpl if="bot_visible_instants.length">',
                    '<tpl for="bot_visible_instants">',
                    '{[this.printAction("prep", xindex-1)]}',
                    '</tpl>',
                    '</tpl>',
                    '<tpl if="bot_visible_battle_actions.length">',
                    '<tpl for="bot_visible_battle_actions">',
                    '{[this.printAction("actions", xindex-1)]}',
                    '</tpl>',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    '<tpl if="bot_visible_turns.length + bot_visible_instants.length + bot_visible_battle_actions.length == 1">',
                    '<div class="paper-separator"></div>',
                    '</tpl>',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    '<tpl if="aura">',
                    '<div class="battle-aura-container">',
                    '{[this.printAuras(values.aura)]}',
                    '</div>',
                    '</tpl>',
                    '<tpl else>',
                    '<tpl if="battle.live">',
                    '<div class="avatar-frame"></div>',
                    '<div class="avatar-image {[this.getSideCls()]}" style="background-image:url({[this.getImage(values.shape)]})"></div>',
                    '<div class="avatar-stats">',
                    '{[ ExGods.util.User.printUserStats(values.stats.stats, {visibleValue: 2}) ]}',
                    '</div>',
                    '<tpl if="aura">',
                    '<div class="battle-aura-container">',
                    '{[this.printAuras(values.aura)]}',
                    '</div>',
                    '</tpl>',
                    '<tpl else>',
                    //юзер мертв
                    '<div class="avatar-frame"></div>',
                    '<div class="avatar-image" style="background-image:url({[this.getImage(values.shape)]})"></div>',
                    '</tpl>',
                    '</tpl>',
                    '<tpl else>',
                    //нет противника
                    '<div class="avatar-frame"></div>',
                    '<div class="avatar-image" style="background-image:url({[this.getImage(values.shape)]})"></div>',
                    '</tpl>',
                    '</div>',
                    {
                        printAuras: function(auras) {
                            var prepared = [],
                                html = '';
                            //aura[0] - aura name
                            //aura[1] - aura steps
                            Ext.Array.each(auras, function(aura) {
                                var i = prepared.length;
                                while (i--) {
                                    if (prepared[i].name == aura[0] && prepared[i].steps == aura[1]) {
                                        prepared[i].count++;
                                        return;
                                    }
                                }
                                prepared.push({
                                    name: aura[0],
                                    steps: aura[1],
                                    count: 1
                                });
                            });
                            Ext.Array.each(prepared, function(aura) {
                                var ref = ExGods.ref('battle_aura|' + aura.name),
                                    img = IMAGE_URL + (ref.params.images.small || ref.params.images.icon),
                                    steps = aura.steps != "0" ? '<div class="battle-aura-counter">' + aura.steps + '</div>' : "",
                                    count = aura.count > 1 ? '<div class="battle-aura-count exg-stuff-decorator-quantity-counter"><span>' + aura.count + '</span></div>' : "";
                                html += [
                                    '<div class="battle-aura" data-qtip="' + ref.label + '" data-aura="' + aura.name + '" style="background-image:url(' + img + ')">',
                                    steps,
                                    count,
                                    '</div>'
                                ].join('');
                            });
                            return html;
                        },
                        getImage: function(shape) {
                            var image;
                            if (!me.isEnemy) {
                                if (me.user.isLiveInBattle()) {
                                    image = me.user.getBattleAvatar();
                                } else {
                                    image = me.getShapeImage('battle_die_shape');
                                }
                            } else {
                                if (me.user) {
                                    if (me.user.isLiveInBattle()) {
                                        image = me.user.getBattleAvatar();
                                    } else {
                                        image = me.getShapeImage('battle_die_shape');
                                    }
                                } else {
                                    image = me.getShapeImage('no_enemy_shape');
                                }
                            }
                            return image;
                        },
                        getSide: function() {
                            return (me.isEnemy) ? 'right' : 'left';
                        },
                        isInfo: function() {
                            return me.isInfo;
                        },
                        getSideCls: function() {
                            return (me.isEnemy) ? 'flip-h' : '';
                        },
                        printAction: function(type, index) {
                            var name, ref_data,
                                turns = me.user.get('bot_visible_turns'),
                                preps = me.user.get('bot_visible_instants'),
                                actions = me.user.get('bot_visible_battle_actions');
                            switch (type) {
                                case 'turn':
                                    {
                                        if (index >= 2 || !turns[index]) {
                                            return;
                                        }
                                        name = turns[index].name;
                                        ref_data = ExGods.ref('battle_turn|' + name);
                                        break;
                                    };
                                case 'prep':
                                    {
                                        if ((turns.length + index) >= 2 || !preps[index]) {
                                            return;
                                        }
                                        name = preps[index].name;
                                        ref_data = ExGods.ref('battle_prep|' + name);
                                        break;
                                    };
                                case 'actions':
                                    {
                                        if ((turns.length + preps.length + index) >= 2 || !actions[index]) {
                                            return;
                                        }
                                        name = actions[index].id;
                                        ref_data = ExGods.ref('battle_actions|' + name);
                                        break;
                                    };
                            }
                            if (ref_data) {
                                return '<div class="paper-separator"></div>' + '<div class="action" id="' + type + '__' + name + '">' + '<img src="' + IMAGE_URL + (type == 'actions' ? ref_data.desc.img : ref_data.desc.images.active) + '">' + '<p>' + ref_data.label + '</p>' + '<div class="notify_i"></div>' + '</div>';
                            } else {
                                return '';
                            }
                        },
                        // вернет статы юзера, некоторые значения которых подменены актуальными данными из timed
                        getSummaryStats: function(u) {
                            var stats = u.stats.stats,
                                timed = me.user.get('timed');
                            Ext.Object.each(stats, function(k, v) {
                                if (k == 'mp' || k == 'hp' || k == 'shield') {
                                    stats[k] = Math.floor(timed[k][0]);
                                }
                            });
                            if (me.isEnemy) {
                                stats['mp'] = "???";
                            }
                            // не показываю уровень маны врага
                            return stats;
                        }
                    }
                ],
                data: me.user ? me.user.data : {}
            }
        ];
        if (me.user) {
            me.setUser(me.user);
        }
        me.callParent(arguments);
        me.on('afterrender', function() {
            me.el.on('click', function() {
                if (me.isInfo) {
                    me.isInfo = false;
                } else {
                    me.isInfo = true;
                }
                me.onUserChange();
                me.fireEvent('viewmodechange', me, me.isInfo);
            }, // выбрасываю событие изменения режима отображения аватара
            me, {
                delegate: '.info-btn'
            });
            me.el.on('click', function(e, el) {
                var aura = ExGods.ref('battle_aura|' + el.dataset.aura);
                Ext.widget('commondetailswindow', {
                    itemElement: el.dom || el,
                    data: {
                        label: aura.label,
                        description: aura.params.description,
                        image: IMAGE_URL + aura.params.images.large
                    }
                });
            }, me, {
                delegate: '.battle-aura'
            });
            me.el.on('click', function(e, el) {
                var cfg = el.id.split('__'),
                    ref = ExGods.ref('battle_' + cfg[0]).get(cfg[1]);
                if (me.actionInfo)  {
                    me.actionInfo.close();
                }
                
                me.actionInfo = Ext.widget('commondetailswindow', {
                    itemElement: this,
                    data: {
                        label: ref.label,
                        image: IMAGE_URL + ((ref.desc.images) ? ref.desc.images.active : ref.desc.img),
                        rows: [
                            {
                                content: ref.prognoz
                            },
                            {
                                content: ref.desc.desc || ref.desc.msg || ''
                            }
                        ]
                    }
                });
                me.actionInfo.on('close', function() {
                    me.actionInfo.destroy();
                    me.actionInfo = false;
                });
                me.actionInfo.setY(Ext.get(el).getY());
                //инфо о действиях только у ботов, в боты всегда справа. Если вдруг что - то ориентироваться по флагу isEnemy
                me.actionInfo.setX(parseInt(Ext.get(el).getX()) - 230);
            }, me, {
                delegate: '.action'
            });
        }, me);
    },
    /**
     * Выставить нового юзера
     */
    setUser: function(user) {
        var me = this;
        if (me.user) {
            me.mun(me.user, 'change', me.onUserChange);
        }
        me.user = user;
        if (me.user) {
            me.mon(me.user, 'change', me.onUserChange, me);
        }
        if (me.rendered) {
            me.items.items[0].update(me.user ? me.user.data : {});
        }
    },
    onUserChange: function() {
        var me = this,
            data = Ext.clone(me.user.data);
        if (me.rendered) {
            me.items.items[0].update(data);
        }
    },
    /**
     * @private
     * Пытается отыскать картинку образа по ключу
     * @return {String} Url картинки образа
     */
    getShapeImage: function(shapeKey) {
        var me = this,
            shape, image;
        shape = ExGods.references.get('constants').get(shapeKey);
        if (shape) {
            shape = ExGods.references.get('user_shape').getByKey(shape.value);
            if (shape) {
                image = shape.battle;
            }
        }
        return image;
    },
    // updateAura:function(aura){
    //  var me = this,
    //      data = me.user.data;
    //  if(me.trueAura){
    //      data.aura = aura;
    //      if(me.rendered){
    //          me.items.items[0].update(data);
    //      }
    //      me.trueAura = false;
    //  }else{
    //      me.trueAura = aura;
    //  }
    // }
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        battle_die_shape = me.getShapeImage('battle_die_shape');
        no_enemy_shape = me.getShapeImage('no_enemy_shape');
        return {
            images: [
                battle_die_shape,
                no_enemy_shape
            ].concat(arr_images)
        };
    }
});

/** Барабан **/
Ext.define('ExGods.view.battle_new.Roller', {
    extend: Ext.Component,
    alias: 'widget.battle_roller',
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BattleRoller:'
    },
    /**
     * Состояние боя
     * @cfg
     */
    state: {},
    animating: false,
    turnHeight: 105,
    // высота ячейки 
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="wrap">',
            '<tpl for="turns">',
            '<div class="slot slot-{[xindex]}">',
            '<div class="turn{[this.getCls(parent.state, values)]}" role="{name}">',
            //'<div class="label ellipsis">{label}</div>',
            '<div class="label ellipsis">{[this.getPrognoz(values,"top")]}</div>',
            '<div class="hidden-empty-border"></div>',
            '<div class="image" style="background-image: url({[this.getImage(values,parent.state)]})">',
            //'<div class="empty-border"></div>',
            '<div class="image-border"></div>',
            '</div>',
            '<div class="prognoz-right">{[this.getPrognoz(values,"right")]}</div>',
            //'<div class="cost ellipsis">{[this.getPrognoz(values,"bottom")]} {[this.getCost(values)]}</div>',
            '<div class="cost ellipsis">{[this.getPrognoz(values,"bottom")]}</div>',
            '<div class="upper-empty-border"></div>',
            '</div>',
            '</div>',
            '</tpl>',
            '<div class="wait-enemy-msg" style="background-image: url(' + ExGods.ref('images|battle_images').image['wait-enemy-msg'] + ')"></div>',
            '<div class="dead-msg" style="background-image: url(' + ExGods.ref('images|battle_images').image['dead-msg'] + ')"></div>',
            '</div>',
            '<div class="cf"></div>',
            '<div id="battle-roller-btn" class="disabled" style="background-image: url(' + ExGods.ref('images|battle_images').image['roller_btn_text'] + ')">',
            '<span>{[ this.printSpriteMoney(values.state.cost_reroll || [],{cls:"battle-roller-cost"}) ]}</span>',
            '</div>',
            {
                getCls: function(state, values) {
                    var cls = '';
                    if (!state.can_kick || !ExGods.app.getUser().checkStuff(values.cost, {
                        activeSlot: true
                    })) {
                        cls = ' disabled';
                    }
                    return cls;
                },
                getPrognoz: function(turn, place) {
                    if (!turn.name || !turn.prognoz)  {
                        return '';
                    }
                    
                    return me.getPrognoz(turn, place);
                },
                getCost: function(turn) {
                    if (!turn.cost)  {
                        return '';
                    }
                    
                    return me.getCost(turn);
                },
                getImage: function(values, state) {
                    if (state.can_kick && ExGods.app.getUser().checkStuff(values.cost, {
                        activeSlot: true
                    })) {
                        return values.images.active;
                    } else {
                        return values.images.passive;
                    }
                },
                printSpriteMoney: function(stuff, opts) {
                    return me.printSpriteMoney(stuff, opts);
                }
            }
        ];
        me.data = me.prepareData();
        me.callParent(arguments);
        me.on('destroy', function() {
            if (me.tooltip)  {
                me.tooltip.close();
            }
            
        });
    },
    afterRender: function() {
        var me = this,
            el = me.getEl();
        me.callParent(arguments);
        if (!me.state.user.battle.live) {
            me.setDead();
            return;
        }
        el.on('click', me.onTurnClick, me, {
            delegate: '.turn'
        });
        el.on('mouseover', me.onTurnMouseOver, me, {
            delegate: '.turn'
        });
        el.on('mouseout', me.onTurnMouseOut, me, {
            delegate: '.turn'
        });
        el.on('click', me.onRerollClick, me, {
            delegate: '#battle-roller-btn'
        });
        el.down('.dead-msg').fadeOut({
            duration: 200
        });
        Ext.Array.each(el.select('.turn').elements, function(turnDom) {
            var turnEl = Ext.get(turnDom),
                img = turnEl.down('.image');
            var interval = setInterval(function() {
                    if (turnEl.dom) {
                        if (me.animating || turnEl.hasCls('disabled'))  {
                            return;
                        }
                        
                        ExGods.helpme.shine(img, 'battle-roller-btn-shine', 19, 62, 25).on('click', function(e) {
                            me.onTurnClick(e, turnEl);
                        });
                    } else {
                        clearInterval(interval);
                    }
                }, 5000);
        });
        if (me.animateOnRender) {
            me.startAnimate(true);
        } else {
            el.select('.turn').show();
            me.disableBtn(false);
        }
        if (!me.state.can_kick || !me.state.av_kick || me.state.av_kick.length == 0) {
            me.waitEnemyTurn(true);
        }
    },
    getPrognoz: function(turn, pos) {
        var ref = ExGods.ref('battle_turn').get(turn.name),
            tpl = ref.desc.prognoz.battle[pos].prognoz_template,
            label = ref.desc.prognoz.battle[pos].prognoz_label,
            template = new Ext.XTemplate(label + ' ' + tpl),
            html = template.apply(turn || {});
        return html;
    },
    getCost: function(turn) {
        var c = turn.cost,
            res = '';
        if (c)  {
            res += ExGods.util.Stuff.printStuff(c);
        }
        
        return res;
    },
    animateSlot: function(slotEl) {
        var me = this,
            cellWidth = 125,
            cellHeight = 109,
            // высота ячейки слота
            elemsConfig = [
                {
                    img: IMAGE_URL + '/battle/roller/start.png',
                    height: 218
                },
                {
                    img: IMAGE_URL + '/battle/roller/loop.png',
                    height: 654
                },
                {
                    img: IMAGE_URL + '/battle/roller/loop.png',
                    height: 654
                },
                {
                    img: IMAGE_URL + '/battle/roller/finish.png',
                    height: 218
                }
            ],
            elems = [],
            move1, move2,
            _posElems = function(elems) {
                for (var i = 1; i < elems.length; i++) {
                    elems[i].top = elems[i - 1].top - elems[i].height;
                }
            },
            _doMove = function(config) {
                var move = {
                        start: Date.parse(new Date()),
                        config: config,
                        distance: 0,
                        speed: config.speed,
                        boost: config.boost,
                        elapsedTime: 0,
                        finish: function() {
                            window.clearInterval(tickerId);
                            this.finished = true;
                        }
                    };
                var tickSize = 10,
                    ticks = 0,
                    tickTime = Date.now();
                var tickerId = window.setInterval(function() {
                        ticks = Math.round((Date.now() - tickTime) / tickSize);
                        for (var i = 0; i < ticks; i++) {
                            if (move.finished) {
                                break;
                            }
                            move.speed += move.boost;
                            move.distance += move.speed;
                            move.elapsedTime += tickSize;
                            Ext.Array.each(config.elems, function(el, index) {
                                el.top += move.speed;
                                el.el.dom.style.top = el.top + 'px';
                                if (config.onElemHide && el.top >= cellHeight) {
                                    config.onElemHide(el, index, config.elems, move);
                                }
                            });
                            if (config.onTick) {
                                config.onTick(move);
                            }
                        }
                        tickTime = Date.now();
                    }, tickSize);
                return move;
            };
        elems.push({
            el: slotEl.down('.turn'),
            top: 0,
            height: cellHeight
        });
        Ext.Array.each(elemsConfig, function(elCfg) {
            var el = slotEl.appendChild({
                    tag: 'div'
                });
            el.applyStyles({
                'background-image': 'url(' + elCfg.img + ')',
                'background-repeat': 'no-repeat',
                'height': elCfg.height + 'px',
                'width': cellWidth + 'px',
                'top': '-1000px',
                'left': '0px',
                'position': 'absolute'
            });
            elems.push({
                el: el,
                height: elCfg.height
            });
        });
        var startMove = function() {
                // скрываю текст
                var params = {
                        to: {
                            opacity: 0
                        },
                        duration: 200
                    };
                // elems[0].el.down('.hidden-empty-border').animate(params);
                // elems[0].el.down('.upper-empty-border').animate(params);
                //elems[0].el.down('.image-border').animate(Ext.apply(params,{
                elems[0].el.down('.cost').animate(params);
                elems[0].el.down('.label').animate(params);
                elems[0].el.down('.prognoz-right').animate(Ext.apply(params, {
                    callback: function() {
                        // начинаю перемещать ленту
                        _posElems(elems);
                        if (!move2) {
                            move1 = _doMove({
                                elems: elems.slice(0, 4),
                                speed: 0,
                                boost: 0.1,
                                // px per tick
                                onTick: function(move) {
                                    if (move.boost && move.distance >= 100) {
                                        move.boost = 0.2;
                                    }
                                    if (move.boost && move.distance >= 300) {
                                        move.boost = 0.4;
                                    }
                                    if (move.boost && move.distance >= 500) {
                                        move.boost = 0;
                                    }
                                },
                                // разогнались до максимума                 
                                onElemHide: function(el, index, elems, move) {
                                    if (index == 2 || index == 3) {
                                        _posElems([
                                            elems[index == 2 ? 3 : 2],
                                            elems[index == 2 ? 2 : 3]
                                        ]);
                                    }
                                }
                            });
                        }
                    }
                }));
                setTimeout(function() {
                    elems[0].el.down('.image').setStyle('opacity', 1);
                }, 700);
            };
        // движение остановки ленты
        var stopMove = function(callback) {
                if (move1) {
                    move1.finish();
                }
                var moveElems = [];
                elems[0].el.show();
                if (elems[2].top > elems[3].top) {
                    moveElems.push(elems[2]);
                    if (elems[3].top >= -elems[3].height) {
                        moveElems.push(elems[3]);
                    }
                } else if (elems[3].top > elems[2].top) {
                    moveElems.push(elems[3]);
                    if (elems[2].top >= -elems[2].height) {
                        moveElems.push(elems[2]);
                    }
                }
                moveElems.push(elems[4]);
                moveElems.push(elems[0]);
                _posElems(moveElems);
                move2 = _doMove({
                    elems: moveElems,
                    speed: move1.speed,
                    boost: -0.1,
                    onTick: function(move) {
                        if (move.speed <= 10) {
                            move.boost = -0.08;
                        }
                        if (move.speed <= 7) {
                            move.boost = -0.05;
                        }
                        if (move.speed <= 5) {
                            move.boost = 0;
                        }
                        var turnEl = move.config.elems[move.config.elems.length - 1],
                            finish = function() {
                                move.finish();
                                var cb = function() {
                                        var animateParams = {
                                                //from: {opacity: 0},
                                                to: {
                                                    opacity: 1
                                                },
                                                duration: 300
                                            };
                                        elems[0].el.down('.label').animate(animateParams);
                                        elems[0].el.down('.prognoz-right').animate(animateParams);
                                        elems[0].el.down('.hidden-empty-border').animate(animateParams);
                                        elems[0].el.down('.upper-empty-border').animate(animateParams);
                                        elems[0].el.down('.image-border').animate(animateParams);
                                        elems[0].el.down('.cost').animate(animateParams);
                                        elems[1].el.remove();
                                        elems[2].el.remove();
                                        elems[3].el.remove();
                                        elems[4].el.remove();
                                        callback();
                                    };
                                if ((Date.parse(new Date()) - move.start) <= 2000) {
                                    turnEl.el.animate({
                                        duration: 350,
                                        from: {
                                            top: turnEl.top
                                        },
                                        to: {
                                            top: 0
                                        },
                                        easing: 'bounceOut',
                                        callback: cb
                                    });
                                } else {
                                    turnEl.el.setTop(0);
                                    cb();
                                }
                            };
                        if (turnEl.top >= 40 || (Date.parse(new Date()) - move.start) > 1000) {
                            finish();
                        }
                    }
                });
            };
        // кручение в самом начале при отрисовке барабана
        var initMove = function(callback) {
                var moveElems = [];
                elems[0].el.show();
                elems[3].top = cellHeight;
                moveElems.push(elems[3]);
                moveElems.push(elems[4]);
                moveElems.push(elems[0]);
                _posElems(moveElems);
                move2 = _doMove({
                    elems: moveElems,
                    speed: 10,
                    boost: -0.09,
                    onTick: function(move) {
                        if (move.speed <= 8) {
                            move.boost = -0.08;
                        }
                        if (move.speed <= 5) {
                            move.boost = -0.05;
                        }
                        if (move.speed <= 3) {
                            move.boost = 0;
                        }
                        if (elems[0].top >= 40) {
                            move.finish();
                            elems[0].el.animate({
                                duration: 350,
                                from: {
                                    top: elems[0].top
                                },
                                to: {
                                    top: 0
                                },
                                easing: 'bounceOut',
                                callback: function() {
                                    var animateParams = {
                                            //from: {opacity: 0},
                                            to: {
                                                opacity: 1
                                            },
                                            duration: 300
                                        };
                                    elems[0].el.down('.label').animate(animateParams);
                                    elems[0].el.down('.prognoz-right').animate(animateParams);
                                    elems[0].el.down('.image-border').animate(Ext.apply(animateParams, {
                                        duration: 500,
                                        delay: 200
                                    }));
                                    elems[0].el.down('.cost').animate(animateParams);
                                    elems[1].el.remove();
                                    elems[2].el.remove();
                                    elems[3].el.remove();
                                    elems[4].el.remove();
                                    callback();
                                }
                            });
                        }
                    }
                });
            };
        return {
            startMove: function() {
                startMove();
            },
            stopMove: function(callback) {
                var minTime = 1000,
                    // минимальное время для старта анимации.               
                    _setTimer = function() {
                        if (!move1 || move1.elapsedTime < minTime) {
                            setTimeout(function() {
                                _setTimer();
                            }, move1 ? minTime - move1.elapsedTime : minTime);
                        } else {
                            stopMove(callback);
                        }
                    };
                _setTimer();
            },
            initMove: function(callback) {
                initMove(callback);
            }
        };
    },
    startAnimate: function(initial) {
        var me = this,
            slotEls = me.getEl().select('.slot');
        /***/
        me.log('начинаю анимацию');
        me.waitEnemyTurn(false);
        me.hidePointer();
        if (me.animating) {
            return;
        }
        me.animating = true;
        me.anims = [];
        Ext.Array.each(me.getEl().select('.slot').elements, function(el) {
            var a = me.animateSlot(Ext.get(el));
            me.anims.push(a);
            setTimeout(function() {
                if (initial) {
                    if (me.state.can_kick) {
                        a.initMove(function() {
                            me.animating = false;
                            if (ExGods.app.getUser().checkStuff(me.state.cost_reroll)) {
                                me.disableBtn(false);
                            }
                        });
                    } else {
                        me.animating = false;
                    }
                } else {
                    a.startMove();
                }
            }, 400 - 400 * Math.random());
        });
    },
    stopAnimate: function(callback) {
        var me = this,
            stopped = 0;
        if (me.stopping) {
            return;
        }
        if (me.animating) {
            me.stopping = true;
            Ext.Array.each(me.anims, function(a) {
                a.stopMove(function() {
                    if (++stopped == me.anims.length) {
                        me.animating = false;
                        me.stopping = false;
                        callback();
                    }
                });
            });
        }
    },
    prepareData: function() {
        var me = this,
            turns = [],
            reference = ExGods.ref('battle_turn');
        Ext.Array.each(me.state.av_kick || [
            {},
            {},
            {}
        ], function(item) {
            var refInfo = reference.get(item.name);
            if (!refInfo) {
                refInfo = {
                    label: '',
                    desc: {
                        desc: '',
                        images: {
                            active: '',
                            passive: ''
                        },
                        prognoz_text: '',
                        prognoz_template: ''
                    }
                };
            }
            turns.push({
                name: refInfo.name,
                label: refInfo.label,
                images: {
                    active: IMAGE_URL + refInfo.desc.images.active,
                    passive: IMAGE_URL + refInfo.desc.images.passive
                },
                prognoz: item.prognoz,
                text: refInfo.desc.prognoz_text,
                template: refInfo.desc.prognoz_template,
                cost: item.cost
            });
        });
        return {
            turns: turns,
            state: me.state
        };
    },
    onTurnClick: function(e, el) {
        var me = this,
            name;
        el = Ext.get(el);
        if (!me.animating && !el.hasCls('disabled')) {
            Ext.each(el.up('#battle-roller').select('.turn').elements, function(turnDom) {
                var animateParams = {
                        to: {
                            opacity: 0
                        },
                        duration: 200
                    };
                if (turnDom == el.dom) {
                    name = el.getAttribute('role');
                    el.down('.cost').animate(animateParams);
                    el.down('.prognoz-right').animate(animateParams);
                    el.down('.label').animate(animateParams);
                    el.down('.image-border').animate(Ext.apply(animateParams, {
                        callback: function() {
                            me.fireEvent('turnclick', name);
                        }
                    }));
                    el.addCls('disabled');
                } else {
                    var turnEl = Ext.get(turnDom);
                    turnEl.down('.image-border').animate(animateParams);
                    turnEl.addCls('disabled');
                }
            });
        }
    },
    onTurnMouseOver: function(e, el) {
        var me = this,
            name = el.getAttribute('role'),
            ref = ExGods.ref('battle_turn').get(name),
            turn = Ext.Array.findBy(me.state.av_kick, function(item) {
                return item.name == name;
            }),
            tpl_buffer = '',
            prognoz_valid = false;
        if (me.tooltip) {
            if (me.tooltip.name == name) {
                return;
            } else {
                me.tooltip.close();
                me.tooltip = false;
            }
        }
        if (me.mouseOverTimeOut) {
            clearTimeout(me.mouseOverTimeOut);
        }
        if (ref.desc.prognoz) {
            tpl_buffer = '<div class="stats-list"><ul class="battle-table-list">';
            for (var key in ref.desc.prognoz.room) {
                var p = ref.desc.prognoz.room[key];
                if (!p.prognoz_label)  {
                    
                    continue;
                }
                
                prognoz_valid = true;
                tpl_buffer += '<li><span class="label">' + p.prognoz_label + '</span>';
                tpl_buffer += '<span class="value">' + p.prognoz_template + '</span></li>';
            }
            tpl_buffer += '</ul></div>';
            tpl_buffer = new Ext.XTemplate(tpl_buffer);
            tpl_buffer = tpl_buffer.apply(turn || {});
        }
        me.mouseOverTimeOut = setTimeout(function() {
            if (Ext.get(el).isVisible(true)) {
                me.tooltip = Ext.widget('commondetailswindow', {
                    itemElement: el.dom || el,
                    name: name,
                    data: {
                        label: ref.label,
                        image: IMAGE_URL + ref.desc.images.active,
                        rows: [
                            {
                                content: prognoz_valid ? tpl_buffer : false
                            },
                            {
                                content: ref.desc.desc
                            }
                        ]
                    }
                });
            }
        }, ExGods.ref('constants|bat_tooltip_delay').value);
    },
    onTurnMouseOut: function(e, el) {
        var me = this,
            rt = Ext.get(e.relatedTarget),
            t = Ext.get(e.target);
        if (!rt || !t)  {
            return;
        }
        
        var oldName = rt.up('.turn') ? rt.up('.turn').getAttribute('role') : rt.getAttribute('role'),
            newName = t.up('.turn') ? t.up('.turn').getAttribute('role') : t.getAttribute('role');
        if (oldName && oldName == newName) {
            return;
        }
        if (me.mouseOverTimeOut) {
            clearTimeout(me.mouseOverTimeOut);
        }
        if (me.tooltip && me.tooltip.close) {
            me.tooltip.close();
            me.tooltip = false;
        }
    },
    onRerollClick: function() {
        var me = this;
        if (me.state.can_reroll && !me.getEl().down('#battle-roller-btn').hasCls('disabled')) {
            me.fireEvent('rerollclick');
        }
    },
    setState: function(state) {
        var me = this,
            slotEls, data, battleview, ekey, buser;
        if (state)  {
            me.state = state;
        }
        
        data = me.prepareData();
        if (me.rendered) {
            slotEls = me.getEl().select('.slot');
            ekey = ExGods.app.getUser().get('battle').ekey;
            battleview = ExGods.app.getBattleBattleViewController();
            buser = battleview.getBattleUser(ekey);
            Ext.Array.each(data.turns, function(turn, index) {
                var turnEl = slotEls.item(index).down('.turn'),
                    enoughStuff = ExGods.app.getUser().checkStuff(turn.cost, {
                        activeSlot: true
                    });
                // Ext.each(turn.cost,function(item){
                //  if(buser.get('timed')[item.params.id] && buser.get('timed')[item.params.id][0] < item.params.quantity) enoughStuff = false;
                // });
                if (turnEl) {
                    turnEl.set({
                        role: turn.name
                    });
                    if (!enoughStuff || battleview.f_wait_kick || battleview.f_start_round_complete) {
                        turnEl.addCls('disabled');
                    } else {
                        turnEl.removeCls('disabled');
                    }
                    turnEl.down('.image').applyStyles({
                        'background-image': 'url(' + (enoughStuff ? turn.images.active : turn.images.passive) + ')'
                    });
                    turnEl.down('.label').setHTML(me.getPrognoz(turn, 'top'));
                    turnEl.down('.prognoz-right').setHTML(me.getPrognoz(turn, 'right'));
                    //turnEl.down('.cost').setHTML(me.getPrognoz(turn,'bottom') + ' ' + me.getCost(turn));
                    turnEl.down('.cost').setHTML(me.getPrognoz(turn, 'bottom'));
                }
            });
            me.disableBtn(!me.state.can_reroll || me.animating || battleview.f_wait_kick || battleview.f_start_round_complete);
            //ставлю новую стоимость реролла
            me.getEl().down('#battle-roller-btn').setHTML(me.printSpriteMoney(me.state.cost_reroll || [], {
                cls: "battle-roller-cost"
            }));
        }
    },
    setDead: function() {
        var me = this;
        Ext.Array.each(me.el.select('.turn').elements, function(turnDom) {
            var turnEl = Ext.get(turnDom);
            turnEl.addCls('disabled');
            turnEl.fadeOut({
                duration: 200
            });
        });
        me.el.down('.dead-msg').fadeIn({
            duration: 200
        });
        me.disableBtn(true);
        me.f_death_blocked = true;
    },
    disableBtn: function(disabled) {
        var me = this;
        if (me.rendered) {
            if (disabled) {
                me.getEl().select('#battle-roller-btn').addCls('disabled');
            } else if (me.state.can_reroll && !me.animating && !me.f_death_blocked && ExGods.app.getUser().checkStuff(me.state.cost_reroll)) {
                me.getEl().select('#battle-roller-btn').removeCls('disabled');
            }
        }
    },
    /**
     * Показать анимацию указателя на доступное действие
     */
    showPointer: function(turn) {
        var me = this,
            container = me.up('#battle-container'),
            isMark = false;
        if (this.is_shown_pointer)  {
            return;
        }
        
        if (!turn && this.is_shown_mark)  {
            return;
        }
        
        if (me.f_death_blocked)  {
            return;
        }
        
        if (!turn) {
            var turns = Ext.select('.turn').elements,
                priorityValue = 0,
                priorityTurns = [];
            Ext.Array.each(turns, function(node, index) {
                if (node.className.split(' ').indexOf('disabled') != -1)  {
                    return;
                }
                
                var priority = me.state.av_kick[index].priority;
                if (priority > priorityValue) {
                    priorityValue = priority;
                    priorityTurns = [
                        node
                    ];
                } else if (priority == priorityValue) {
                    priorityTurns.push(node);
                }
            });
            turn = Ext.get(priorityTurns[Math.floor(Math.random() * priorityTurns.length)]);
        } else {
            isMark = true;
        }
        container.el.select('.finger').remove();
        var style = [
                'left:' + (turn.getX() - container.getX() + 26) + 'px',
                'top:' + (turn.getY() - container.getY() + 20) + 'px'
            ].join(';'),
            html = [
                '<div class="finger" style="' + style + '">',
                '<div class="finger-image"></div>',
                '<div class="finger-text" style="background-image: url(' + ExGods.ref('images|battle_images').image['finger_text'] + ')"></div>',
                '</div>'
            ].join(''),
            animEl = container.el.insertHtml('beforeEnd', html, true),
            img = animEl.down('.finger-image').dom,
            text = animEl.down('.finger-text').dom,
            cycles = ExGods.ref('constants|bat_anim_pointer_cycles').value,
            time_text_shown = ExGods.ref('constants|bat_anim_pointer_text_hidden').value,
            time_text_hidden = ExGods.ref('constants|bat_anim_pointer_text_shown').value,
            time = ExGods.ref('constants|bat_anim_pointer_speed').value,
            deltaOpacity = (time / (time - time_text_hidden - time_text_shown)).toFixed(2),
            startOpacity = (deltaOpacity * (time - time_text_hidden) / time).toFixed(2),
            i = maxI = 51 * cycles,
            showing = true,
            deltaX = 10,
            deltaY = 5,
            timestamp;
        if (!isMark)  {
            me.is_shown_pointer = true;
        }
        
        animEl.on('click', function(e, el) {
            me.onTurnClick(e, turn);
        });
        animEl.on('mouseover', function(e, el) {
            me.onTurnMouseOver(e, turn);
        });
        animEl.on('mouseout', function(e, el) {
            me.onTurnMouseOut(e, turn);
        });
        (function() {
            //меняю текст
            text.style.opacity = startOpacity - Math.abs((i - maxI / (2)) / (maxI / (2))) * deltaOpacity;
            //меняю палец
            img.style.left = (24 + Math.abs(deltaX * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            img.style.top = (-18 - Math.abs(deltaY * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            //запускаю спрайт
            if (i % (maxI / cycles) == maxI / (2 * cycles))  {
                ExGods.helpme.shine(animEl, 'finger-sprite', 34, -62, 25);
            }
            
            if (i > 0) {
                i--;
                var curTime = new Date().getTime();
                if (!me.is_shown_pointer && !timestamp) {
                    timestamp = curTime + time / maxI * i + 100;
                }
                if (timestamp && curTime > timestamp) {
                    animEl.remove();
                    return;
                }
                setTimeout(arguments.callee, time / maxI);
            } else {
                i = maxI;
                if (me.is_shown_pointer) {
                    setTimeout(arguments.callee, time / maxI);
                } else {
                    animEl.remove();
                }
            }
        })();
    },
    /**
     * Скрыть анимацию указателя на доступное действие
     */
    hidePointer: function() {
        this.is_shown_pointer = false;
    },
    /**
     * Перевожу в режим ожидания хода врага
     */
    waitEnemyTurn: function(wait) {
        var me = this,
            el = me.getEl();
        if (!el || me.f_wait_enemy === wait) {
            return;
        } else {
            me.f_wait_enemy = wait;
        }
        if (wait) {
            el.addCls('f-wait-enemy');
            el.down('.wait-enemy-msg').fadeIn({
                duration: 200
            });
            el.select('.turn').addCls('disabled');
            me.disableBtn(true);
        } else {
            el.removeCls('f-wait-enemy');
            el.down('.wait-enemy-msg').fadeOut({
                duration: 200
            });
        }
    },
    applyMarks: function(marks) {
        var me = this,
            time = parseInt(ExGods.ref('constants|bat_anim_pointer_speed').value) + 50,
            battleViewCtrl = ExGods.app.getBattleBattleViewController();
        if (me.marksInterval)  {
            clearInterval(me.marksInterval);
        }
        
        if (marks.length) {
            me.marksInterval = setInterval(function() {
                var nodes = me.getEl().select('.turn'),
                    markNodes = [];
                Ext.Array.each(nodes.elements, function(node) {
                    if (marks.indexOf(node.attributes.role.value) != -1) {
                        markNodes.push(Ext.get(node));
                    }
                });
                if (markNodes.length) {
                    Ext.each(markNodes, function(node) {
                        if (!node.hasCls('disabled') && !me.animating && !battleViewCtrl.f_start_round_complete && ExGods.app.getViewportController().getCenter().isVisible()) {
                            me.hidePointer();
                            me.showPointer(node);
                            me.is_shown_mark = true;
                        }
                    });
                } else {
                    me.is_shown_mark = false;
                }
            }, time);
        } else {
            me.is_shown_mark = false;
        }
    },
    printSpriteMoney: function(stuff, options) {
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        options = options || {};
        var me = this,
            res = [];
        Ext.Array.each(stuff, function(item) {
            res.push(ExGods.util.Sprite.printSprite(item.params.quantity, IMAGE_URL + 'num_combo.png', {
                width: 10,
                height: 16,
                cls: item.params.id + '-sprite' + (options.cls ? ' ' + options.cls : ''),
                tag: options.tag
            }));
        });
        return res.join(' ');
    }
});

/**
 * Интерфейс предварительных действий в бою
 */
Ext.define('ExGods.view.battle_new.PrepActions', {
    extend: Ext.Component,
    alias: 'widget.battle_preps',
    /**
     * @cfg {Object} state Состояние боя
     */
    state: {},
    /**
     * @cfg {ExGods.controller.battle.BattleView} battleView Контроллер BattleView
     */
    battleView: null,
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="left-arrow disabled"></div>',
            '<div class="list-wrap">',
            '<ul class="prep-actions">',
            '<tpl for="values.av_prep">',
            '<li class="prep-action {[this.getPrepCls(values)]}" role="{[values.name]}">',
            //'<div class="label">{[ this.getPrepName(values.name) ]}</div>',
            '<div class="counter">{[ this.getPrepCounterValue() ]}</div>',
            '<div class="image" style="background-image: url({[ this.getPrepImage(values) ]})">',
            '<div class="image-frame"></div>',
            '<div class="svg-frame" id="svg-frame-{[xindex]}"></div>',
            '</div>',
            '<div class="cost">',
            '<tpl if="cost && cost.length">',
            '{[ ExGods.util.Stuff.printStuff(values.cost || []) ]}',
            '<tpl else>',
            ExGods.getMsgByKey('view_battle_prepactions_freeaction'),
            '</tpl>',
            '</div>',
            //'<div class="mask"></div>',
            '</li>',
            '</tpl>',
            '</ul>',
            '</div>',
            '<div class="right-arrow disabled"></div>',
            {
                getPrepCls: function(prepAction) {
                    var cls = '';
                    if (me.isActionDisabled(prepAction)) {
                        cls = 'disabled';
                    }
                    return cls;
                },
                getPrepName: function(name) {
                    var prep = ExGods.ref('battle_prep|' + name);
                    if (prep) {
                        return prep.label;
                    }
                },
                getPrepImage: function(prepAction) {
                    var prep = ExGods.ref('battle_prep|' + prepAction.name);
                    if (me.isActionDisabled(prepAction)) {
                        return IMAGE_URL + prep.desc.images.passive;
                    } else {
                        return IMAGE_URL + prep.desc.images.active;
                    }
                },
                getPrepCounterValue: function(state) {
                    return me.getPrepCounterValue();
                }
            }
        ];
        me.data = me.state;
        me.callParent();
        me.on('destroy', function() {
            if (me.tooltip)  {
                me.tooltip.close();
            }
            
        });
    },
    afterRender: function() {
        var me = this,
            el = me.getEl();
        me.callParent(arguments);
        if (!me.state.user.battle.live) {
            me.setDisabled(true);
            return;
        }
        el.on('click', me.onPrepActsLeftClick, me, {
            delegate: '.left-arrow'
        });
        el.on('click', me.onPrepActsRightClick, me, {
            delegate: '.right-arrow'
        });
        el.on('click', me.onPrepActClick, me, {
            delegate: '.prep-action'
        });
        el.on('mouseover', me.onPrepActMouseOver, me, {
            delegate: '.prep-action'
        });
        el.on('mouseout', me.onPrepActMouseOut, me, {
            delegate: '.prep-action'
        });
        Ext.Array.each(el.select('.prep-action').elements, function(actionDom, index) {
            var actionEl = Ext.get(actionDom),
                img = actionEl.down('.image'),
                data = me.state.av_prep[index];
            if (data.rest && data.cd && parseInt(data.cd) > 1 && data.rest != 0) {
                ExGods.helpme.createSquareTimer(0, parseInt(data.cd), parseInt(data.rest), false, false, 'svg-frame-' + (index + 1), 57);
            }
        });
        var interval = setInterval(function() {
                var els = el.select('.prep-action').elements;
                if (!els.length) {
                    clearInterval(interval);
                    return;
                }
                Ext.Array.each(els, function(actionDom, index) {
                    var actionEl = Ext.get(actionDom),
                        img = actionEl.down('.image');
                    if (actionEl.hasCls('disabled'))  {
                        return;
                    }
                    
                    ExGods.helpme.shine(img, 'battle-roller-btn-shine', 19, 62, 25).on('click', function(e) {
                        me.onPrepActClick(e, actionEl);
                    });
                });
            }, 5000);
        me.doPrepActsOffset(0);
    },
    // вызываю, чтобы блокировать/разблокировать стрелки списка действий
    onPrepActClick: function(e, el) {
        var me = this,
            name;
        el = Ext.get(el);
        name = el.getAttribute('role');
        if (!el.hasCls('disabled')) {
            el.addCls('disabled');
            me.fireEvent('prepclick', name);
        }
    },
    onPrepActMouseOver: function(e, el) {
        var me = this,
            name = el.getAttribute('role'),
            ref = ExGods.ref('battle_prep').get(name),
            prep = Ext.Array.findBy(me.state.av_prep, function(item) {
                return item.name == name;
            }),
            tpl_buffer = '';
        if (me.tooltip) {
            if (me.tooltip.name == name) {
                return;
            } else {
                me.tooltip.close();
                me.tooltip = false;
            }
        }
        if (me.mouseOverTimeOut) {
            clearTimeout(me.mouseOverTimeOut);
        }
        if (ref.desc.prognoz) {
            tpl_buffer = '<div class="stats-list"><ul class="table-list">';
            for (var i = 0; i < ref.desc.prognoz.length; i++) {
                tpl_buffer += '<li><span class="label">' + ref.desc.prognoz[i].prognoz_label + '</span>';
                tpl_buffer += '<span class="value">' + ref.desc.prognoz[i].prognoz_template + '</span></li>';
            }
            tpl_buffer += '</ul></div>';
            tpl_buffer = new Ext.Template(tpl_buffer);
            tpl_buffer = tpl_buffer.apply(prep.prognoz || {});
        }
        me.mouseOverTimeOut = setTimeout(function() {
            if (Ext.get(el).isVisible(true)) {
                me.tooltip = Ext.widget('commondetailswindow', {
                    itemElement: el.dom || el,
                    name: name,
                    data: {
                        label: ref.label,
                        image: IMAGE_URL + ref.desc.images.active,
                        rows: [
                            {
                                content: tpl_buffer
                            },
                            {
                                content: prep.cost && prep.cost.length ? '<div style="clear:both;overflow:hidden">' + ExGods.getMsgByKey('view_battle_prepactions_pricewordintt') + ' <span class="prep-action-stuff" style="float:right; font-weight: bold;">' + ExGods.util.Stuff.printStuff(prep.cost || []) + '</span></div>' : null
                            },
                            {
                                content: ref.desc.desc
                            }
                        ]
                    }
                });
            }
        }, ExGods.ref('constants|bat_tooltip_delay').value);
    },
    onPrepActMouseOut: function(e, el) {
        var me = this,
            newName = Ext.get(e.target).up('.prep-action') ? Ext.get(e.target).up('.prep-action').getAttribute('role') : Ext.get(e.target).getAttribute('role');
        var oldName = undefined;
        var relatedTarget = e.relatedTarget;
        if (relatedTarget) {
            oldName = Ext.get(relatedTarget).up('.prep-action') ? Ext.get(relatedTarget).up('.prep-action').getAttribute('role') : Ext.get(relatedTarget).getAttribute('role');
        }
        if (oldName == newName) {
            return;
        }
        if (me.mouseOverTimeOut) {
            clearTimeout(me.mouseOverTimeOut);
        }
        if (me.tooltip && me.tooltip.close) {
            me.tooltip.close();
            me.tooltip = false;
        }
    },
    onPrepActsLeftClick: function(e, el) {
        var me = this,
            offsetNum = (me.prepActsOffset || 0) - 1;
        me.doPrepActsOffset(offsetNum);
    },
    onPrepActsRightClick: function(e, el) {
        var me = this,
            offsetNum = (me.prepActsOffset || 0) + 1;
        me.doPrepActsOffset(offsetNum);
    },
    // @param offsetNum - номер ячейки, которая будет первая в списке
    doPrepActsOffset: function(offsetNum) {
        var me = this,
            offset, listEl, leftArrEl, rightArrEl;
        me.prepActsOffset = me.prepActsOffset || 0;
        listEl = Ext.select('#battle-prepacts ul').first();
        leftArrEl = Ext.select('#battle-prepacts .left-arrow').first();
        rightArrEl = Ext.select('#battle-prepacts .right-arrow').first();
        // проверяю могу ли сделать сдвиг
        if (offsetNum >= 0 && me.state.av_prep.length - offsetNum >= 4) {
            // 4 - вместимость списка
            offset = offsetNum * 91;
            // 91 - ширина одной ячейки
            listEl.setStyle('left', '-' + offset + 'px');
            me.prepActsOffset = offsetNum;
        }
        if (me.prepActsOffset == 0) {
            leftArrEl.addCls('disabled');
        } else {
            leftArrEl.removeCls('disabled');
        }
        if (me.state.av_prep.length - me.prepActsOffset <= 4) {
            rightArrEl.addCls('disabled');
        } else {
            rightArrEl.removeCls('disabled');
        }
    },
    /**
     * Обновляет счётчики действий.
     * update - флаг, нужно ли апдейтить бом
     */
    updateCounters: function(update) {
        var me = this,
            prepCounterValue = me.getPrepCounterValue();
        if (me.rendered) {
            if (update) {
                me.update(me.state);
            }
            // обновляю счётчики
            if (me.state.can_prep) {
                me.getEl().select('#battle-prepacts .counter').setHTML(prepCounterValue);
            }
            // блокирую недостуные действия
            Ext.Array.each(me.state.av_prep, function(prepAction, index) {
                var el, prep,
                    enoughStuff = me.isEnoughCost(prepAction.cost),
                    el = me.getEl().select('#battle-prepacts li.prep-action').item(index);
                if (me.isActionDisabled(prepAction)) {
                    if (prepAction.cd && parseInt(prepAction.cd) > 1) {
                        ExGods.helpme.createSquareTimer(0, parseInt(prepAction.cd), parseInt(prepAction.rest), false, false, 'svg-frame-' + (index + 1), 57);
                        if (!el.down('.prepact-cd') && prepAction.rest > 0) {
                            var sprite = ExGods.util.Sprite.printSprite(parseInt(prepAction.rest), IMAGE_URL + '/num_combo.png', {
                                    width: 10,
                                    height: 16
                                });
                            el.down('.image').insertHtml('beforeEnd', '<div class="prepact-cd">' + sprite + '</div>');
                        }
                    }
                    if (el) {
                        el.addCls('disabled');
                        prep = ExGods.ref('battle_prep|' + prepAction.name);
                        el.down('.image').applyStyles({
                            'background-image': 'url(' + IMAGE_URL + prep.desc.images.passive + ')'
                        });
                    }
                } else {
                    if (el) {
                        el.removeCls('disabled');
                        prep = ExGods.ref('battle_prep|' + prepAction.name);
                        el.down('.image').applyStyles({
                            'background-image': 'url(' + IMAGE_URL + prep.desc.images.active + ')'
                        });
                    }
                }
            });
        }
    },
    /**
     * Вернёт значение для счётчика предварительных действий
     */
    getPrepCounterValue: function() {
        var me = this,
            startDate, restToPrepare;
        startDate = new Date(me.state.start * 1000 + ExGods.util.Date.serverTimeOffset * 1000);
        restToPrepare = Math.max(me.state.to_prepare - parseInt((Date.now() - startDate) / 1000), 0);
        if (restToPrepare < 10 && restToPrepare > 0) {
            restToPrepare = '<span class="red">' + restToPrepare + '</span>';
        }
        return restToPrepare || 0;
    },
    /**
     * Выставляет новое состояние боя для вьюхи
     */
    setState: function(state) {
        var me = this;
        me.state = state;
        if (me.rendered) {
            me.updateCounters(true);
            me.doPrepActsOffset(me.prepActsOffset || 0);
        }
    },
    /**
     * Блокирует/разблокирует контролы
     */
    setDisabled: function(disabled) {
        var me = this,
            rootEl;
        if (me.rendered) {
            rootEl = me.getEl();
            if (disabled) {
                rootEl.select('.prep-action').addCls('disabled');
                me.actions_disabled = true;
            } else {
                if (me.state.can_prep) {
                    //rootEl.select('.prep-action').removeCls('disabled');
                    me.actions_disabled = false;
                    me.updateCounters();
                }
            }
        }
    },
    applyMarks: function(marks) {
        var me = this,
            nodes = me.getEl().select('#battle-prepacts li.prep-action'),
            markNodes = [],
            time = parseInt(ExGods.ref('constants|bat_anim_pointer_speed').value) + 50;
        Ext.Array.each(nodes.elements, function(node) {
            if (marks.indexOf(node.attributes.role.value) != -1) {
                markNodes.push(Ext.get(node));
            }
        });
        if (me.marksInterval)  {
            clearInterval(me.marksInterval);
        }
        
        if (markNodes.length) {
            me.marksInterval = setInterval(function() {
                Ext.each(markNodes, function(node) {
                    if (node.hasCls('disabled') || !ExGods.app.getViewportController().getCenter().isVisible()) {
                        clearInterval(me.marksInterval);
                    } else {
                        me.showPointer(node);
                    }
                });
            }, time);
        }
    },
    /**
     * Показать анимацию указателя на доступное действие
     */
    showPointer: function(prepact) {
        var me = this,
            container = me.up('#battle-container'),
            style = [
                'left:' + (prepact.getX() - container.getX() + 15) + 'px',
                'top:' + (prepact.getY() - container.getY() + 15) + 'px'
            ].join(';'),
            html = [
                '<div class="finger" style="' + style + '">',
                '<div class="finger-image"></div>',
                '<div class="finger-text"></div>',
                '</div>'
            ].join(''),
            animEl = container.el.insertHtml('beforeEnd', html, true),
            img = animEl.down('.finger-image').dom,
            text = animEl.down('.finger-text').dom,
            cycles = ExGods.ref('constants|bat_anim_pointer_cycles').value,
            time_text_shown = ExGods.ref('constants|bat_anim_pointer_text_hidden').value,
            time_text_hidden = ExGods.ref('constants|bat_anim_pointer_text_shown').value,
            time = ExGods.ref('constants|bat_anim_pointer_speed').value,
            deltaOpacity = (time / (time - time_text_hidden - time_text_shown)).toFixed(2),
            startOpacity = (deltaOpacity * (time - time_text_hidden) / time).toFixed(2),
            i = maxI = 50 * cycles,
            showing = true,
            deltaX = 10,
            deltaY = 5,
            timestamp;
        animEl.on('click', function(e, el) {
            me.onPrepActClick(e, prepact);
        });
        animEl.on('mouseover', function(e, el) {
            me.onPrepActMouseOver(e, prepact);
        });
        animEl.on('mouseout', function(e, el) {
            me.onPrepActMouseOut(e, prepact);
        });
        (function() {
            //меняю текст
            text.style.opacity = startOpacity - Math.abs((i - maxI / (2)) / (maxI / (2))) * deltaOpacity;
            //меняю палец
            img.style.left = (24 + Math.abs(deltaX * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            img.style.top = (-18 - Math.abs(deltaY * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            //запускаю спрайт
            if (i % (maxI / cycles) == maxI / (2 * cycles))  {
                ExGods.helpme.shine(animEl, 'finger-sprite', 34, -62, 25);
            }
            
            if (i > 0) {
                i--;
                var curTime = new Date().getTime();
                if (!timestamp) {
                    timestamp = curTime + time / maxI * i + 100;
                }
                if (timestamp && curTime > timestamp) {
                    animEl.remove();
                    return;
                }
                setTimeout(arguments.callee, time / maxI);
            } else {
                animEl.remove();
            }
        })();
    },
    isActionDisabled: function(prepAction) {
        var me = this;
        return !me.state.can_prep || prepAction.rest > 0 || me.getPrepCounterValue() == 0 || !me.isEnoughCost(prepAction.cost) || me.actions_disabled || (prepAction.max_used > 0 && prepAction.used >= prepAction.max_used) || prepAction.timeout > 0;
    },
    /**
     * Проверяет, может ли игрок выполнить действие по определенной цене
     */
    isEnoughCost: function(cost) {
        var me = this;
        // цена может содержать расходки или восстанавливаемые характеристики.
        // актуальное состояние восстанавливаемых хар-к хранится в данных игрока вью боя, а предметов в глобальном объекте игрока
        return me.battleView.getBattleUser().checkStuff(cost) || ExGods.app.getUser().checkStuff(cost);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.data.av_kick) {
            for (var i = 0; i < me.data.av_kick.length; i++) {
                if (me.data.av_kick[i].cost) {
                    stuff_arr.push(me.data.av_kick[i].cost);
                }
            }
        }
        if (me.data.av_prep) {
            for (var i = 0; i < me.data.av_prep.length; i++) {
                if (me.data.av_prep[i].cost) {
                    for (var j = 0; j < me.data.av_prep[i].cost.length; j++) {
                        stuff_arr.push(me.data.av_prep[i].cost[j]);
                    }
                }
            }
        }
        return {
            stuff: stuff_arr,
            images: [].concat(arr_images)
        };
    }
});

/**
 * Отображает выбранные действия игроков в бою
 */
Ext.define('ExGods.view.battle_new.Choice', {
    extend: Ext.Component,
    alias: 'widget.battle_choice',
    /**
     * @cfg {Object} state Состояние боя
     */
    state: {},
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<tpl if="kick">',
            '<div class="my-kick" style="background-image: url({[ this.getTurnImage(values.kick) ]});"></div>',
            '</tpl>',
            '<tpl if="enemy_kick">',
            '<div class="enemy-kick" style="background-image: url({[ this.getEnemyTurnImage(values.enemy_kick) ]}); left: 108px;"></div>',
            '</tpl>',
            {
                getTurnName: function(name) {
                    var turn = ExGods.ref('battle_turn|' + name);
                    if (turn) {
                        return turn.label;
                    }
                },
                getTurnImage: function(name) {
                    var turn = ExGods.ref('battle_turn|' + name);
                    if (turn) {
                        return IMAGE_URL + turn.desc.images['active'];
                    }
                },
                getEnemyTurnImage: function(name) {
                    var turn = ExGods.ref('battle_turn|' + name);
                    if (turn) {
                        return IMAGE_URL + turn.desc.images['flip'];
                    }
                }
            }
        ];
        me.data = me.state;
        me.callParent();
    },
    setMyChoice: function(kickName) {
        var me = this;
        me.state.kick = kickName;
        me.update(me.state);
    },
    setEnemyChoice: function(kickName, callback) {
        if (!this.state.user.battle.live) {
            callback();
            return;
        }
        var me = this,
            kickEl = me.getEl().down('.enemy-kick'),
            ref_data = ExGods.ref('battle_turn|' + kickName),
            img = ref_data ? IMAGE_URL + ref_data.desc.images['flip'] : '';
        if (!kickEl) {
            kickEl = me.getEl().insertHtml('beforeEnd', '<div class="enemy-kick" style="left: 108px;"></div>', true);
        }
        kickEl.applyStyles({
            'opacity': ExGods.ref('constants|bat_anim_e_choice_opacity').value,
            'background-image': 'url(' + img + ')'
        });
        kickEl.animate({
            to: {
                opacity: 1
            },
            duration: ExGods.ref('constants|bat_anim_e_choice_dur').value,
            callback: function() {
                callback();
            }
        });
    },
    clearChoice: function() {
        var me = this;
        me.state.kick = null;
        me.state.enemy_kick = null;
        me.update(me.state);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.state.kick) {
            var turn = ExGods.ref('battle_turn|' + me.state.kick);
            if (turn) {
                arr_images.push(IMAGE_URL + turn.desc.images['active']);
            }
        }
        if (me.state.enemy_kick) {
            var turn = ExGods.ref('battle_turn|' + me.state.enemy_kick);
            if (turn) {
                arr_images.push(IMAGE_URL + turn.desc.images['flip']);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Список участников в бою
 */
Ext.define('ExGods.view.battle_new.UserList', {
    extend: Ext.panel.Panel,
    alias: 'widget.battle_userlist',
    /**
     * @cfg Хранилище юзеров (required)
     */
    store: null,
    /**
     * @cfg Флаг, показывающий, что список строится для врагов
     */
    isEnemies: false,
    padding: '4px 4px 8px 4px',
    //padding: 4,
    plugins: [
        'skindeco',
        {
            ptype: 'scroller',
            autoHide: true,
            autoRestorePosition: true,
            padding: '28px 5px 0 0'
        }
    ],
    initComponent: function() {
        var me = this;
        me.header = {
            cls: 'battle-group-header',
            style: {
                backgroundImage: 'url(' + ExGods.ref('images|battle_images').image[me.isEnemies ? 'header_opponent' : 'header_ally'] + '),url(' + IMAGE_URL + 'skin-bg.png);'
            }
        };
        me.items = [
            {
                xtype: 'dataview',
                store: me.store,
                autoEl: 'ul',
                cls: 'battle-group-list',
                itemSelector: 'li',
                tpl: [
                    '<tpl for=".">',
                    '<li class="{[this.getCls(values)]}">',
                    '<div class="battle-avatar-lvl-container">',
                    //аватар и лвл
                    '<div class="battle-group-avatar" style="background-image:url({[this.getAvatarImage(values.shape)]})" data-uname="{display_title}"></div>',
                    //аватар
                    '<div class="battle-group-lvl">{[this.getLevel(values.hoard.level)]}</div>',
                    //lvl
                    '</div>',
                    '<div class="battle-nick-timed-container">',
                    //ник и таймед
                    '<p data-qtip="{display_title}">{display_title}</p>',
                    //ник
                    '<div class="battle-group-timed">',
                    //блок таймедов
                    '<div class="sp" data-qtip="' + ExGods.getMsgByKey('view_battle_userlist_sptt') + ' {[ExGods.printNumber(Math.floor(values.timed.shield[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.shield[1], 10000, "0")]}" style="width:{[this.calcBarWidth(values.timed.shield)]}px">',
                    '<span>{[ExGods.printNumber(Math.floor(values.timed.shield[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.shield[1], 10000, "0")]}</span>',
                    '</div>',
                    '<div class="hp" data-qtip="' + ExGods.getMsgByKey('view_battle_userlist_hptt') + ' {[ExGods.printNumber(Math.floor(values.timed.hp[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.hp[1], 10000, "0")]}" style="width:{[this.calcBarWidth(values.timed.hp)]}px">',
                    '<span>{[ExGods.printNumber(Math.floor(values.timed.hp[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.hp[1], 10000, "0")]}</span>',
                    '</div>',
                    '<tpl if="this.isEnemies()">',
                    '<div class="mp" data-qtip="" style="width:0px">',
                    '<span style="margin: -1px;">???</span>',
                    '</div>',
                    '<tpl else>',
                    '<div class="mp" data-qtip="' + ExGods.getMsgByKey('view_battle_userlist_mptt') + ' {[ExGods.printNumber(Math.floor(values.timed.mp[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.mp[1], 10000, "0")]}" style="width:{[this.calcBarWidth(values.timed.mp)]}px">',
                    '<span>{[ExGods.printNumber(Math.floor(values.timed.mp[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.mp[1], 10000, "0")]}</span>',
                    '</div>',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    //ауры
                    '<tpl if="aura">',
                    '<div class="battle-aura-container">',
                    '{[this.printAuras(values.aura)]}',
                    '</div>',
                    '</tpl>',
                    '<tpl if="battle.live == 0">',
                    '<div class="battle-group-dead-mask"></div>',
                    '</tpl>',
                    '</li>',
                    '</tpl>',
                    {
                        getCls: function(data) {
                            var cls = [];
                            if (data.is_bot) {
                                cls.push('bot');
                            }
                            return cls.join(' ');
                        },
                        calcBarWidth: function(param) {
                            return Math.ceil(88 * param[0] / param[1]) || 0;
                        },
                        printAuras: function(auras) {
                            var prepared = [],
                                html = '';
                            //aura[0] - aura name
                            //aura[1] - aura steps
                            Ext.Array.each(auras, function(aura) {
                                var i = prepared.length;
                                while (i--) {
                                    if (prepared[i].name == aura[0] && prepared[i].steps == aura[1]) {
                                        prepared[i].count++;
                                        return;
                                    }
                                }
                                prepared.push({
                                    name: aura[0],
                                    steps: aura[1],
                                    count: 1
                                });
                            });
                            Ext.Array.each(prepared, function(aura) {
                                var ref = ExGods.ref('battle_aura|' + aura.name),
                                    img = IMAGE_URL + (ref.params.images.small || ref.params.images.icon),
                                    steps = aura.steps != "0" ? '<div class="battle-aura-counter">' + aura.steps + '</div>' : "",
                                    count = aura.count > 1 ? '<div class="battle-aura-count exg-stuff-decorator-quantity-counter"><span>' + aura.count + '</span></div>' : "";
                                html += [
                                    '<div class="battle-aura" data-qtip="' + ref.label + '" data-aura="' + aura.name + '" style="background-image:url(' + img + ')">',
                                    steps,
                                    count,
                                    '</div>'
                                ].join('');
                            });
                            return html;
                        },
                        getAvatarImage: function(shape) {
                            return ExGods.references.get('user_shape').getByKey(shape).thumb;
                        },
                        getLevel: function(level) {
                            var result = '';
                            level = level.toString();
                            for (var i = 0; i < level.length; i++) {
                                result += '<img alt="' + level[i] + '" class="number-' + level[i] + '" src="' + Ext.BLANK_IMAGE_URL + '">';
                            }
                            return result;
                        },
                        isEnemies: function() {
                            return me.isEnemies;
                        }
                    }
                ]
            }
        ];
        me.callParent();
        me.store.on('do_refresh', function() {
            if (me.items && me.items.items && me.items.items[0])  {
                me.items.items[0].refresh();
            }
            
        });
        me.on('afterrender', function() {
            // me.el.on('click',function(){
            //  if(me.isInfo){
            //      me.isInfo = false;
            //  }else{
            //      me.isInfo = true;
            //  }
            //  me.onUserChange();
            //  me.fireEvent('viewmodechange', me, me.isInfo); // выбрасываю событие изменения режима отображения аватара
            // },me,{delegate:'.info-btn'});
            me.el.on('click', function(e, el) {
                var aura = ExGods.ref('battle_aura|' + el.dataset.aura);
                var cmp = Ext.widget('commondetailswindow', {
                        autoShow: false,
                        itemElement: el.dom || el,
                        data: {
                            label: aura.label,
                            description: aura.params.description,
                            image: IMAGE_URL + aura.params.images.large
                        }
                    });
                ExGods.Resources.load(cmp, function() {
                    cmp.show();
                });
            }, me, {
                delegate: '.battle-aura'
            });
            me.el.on('click', function(e, el) {
                el = Ext.get(el);
                if (!el.up('li').hasCls('bot')) {
                    ExGods.app.fireEvent('nickinfoclick', el.getAttribute('data-uname'));
                }
            }, me, {
                delegate: '.battle-group-avatar'
            });
        }, me);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            var dt = me.store.data.items[i].data;
            arr_images.push(ExGods.references.get('user_shape').getByKey(dt.shape).thumb);
            if (dt.aura) {
                for (var j = 0; j < dt.aura.length; j++) {
                    var aura = dt.aura[j];
                    if (aura instanceof Array) {} else {
                        aura = [
                            aura
                        ];
                    }
                    for (var k = 0; k < aura.length; k++) {
                        var strct = ExGods.ref('battle_aura|' + aura[k]);
                        if (strct && strct.params) {
                            var imgs = strct.params.images;
                            for (var it in imgs) {
                                arr_images.push(imgs[it]);
                            }
                        }
                    }
                }
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Результаты боя
 */
Ext.define('ExGods.view.battle_new.Result', {
    extend: Ext.container.Container,
    alias: 'widget.battleresult',
    /**
     * @cfg {Object} data Финальные данные боя
     */
    data: {},
    cls: 'battle-result',
    margin: '6px 7px',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    plugins: [
        'paperdeco'
    ],
    initComponent: function() {
        var me = this,
            data = me.config.data.battle_result,
            side = data.user_result.side,
            allies, enemies, akpi, ekpi,
            socialFriend = data.user_result.arena_special_rival;
        for (var i = 0; i < data.participant.length; i++) {
            if (data.participant[i][0].side == side) {
                allies = data.participant[i];
                akpi = data.result.total_kpi[i + 1];
            } else {
                enemies = data.participant[i];
                ekpi = data.result.total_kpi[i + 1];
            }
        }
        var single = (allies.length > 1 || enemies.length > 1) ? false : true,
            can_master = false;
        i = data.user_result.loot ? data.user_result.loot.length : 0;
        while (i--) {
            if (data.user_result.loot[i].is_store) {
                can_master = true;
                break;
            }
        }
        me.items = [
            {
                xtype: 'battleresultside',
                kpi: akpi,
                members: allies,
                enemies: false,
                single: single,
                lose: data.user_result.is_lose,
                margin: '7px 0 7px 11px'
            },
            {
                html: '<div class="v-separator" style="height:400px"></div>'
            },
            {
                xtype: 'battlerewards',
                data: data.user_result,
                flex: 1,
                dockedItems: [
                    {
                        dock: 'bottom',
                        xtype: 'toolbar',
                        layout: {
                            pack: 'center'
                        },
                        margin: '0 0 20',
                        items: [
                            {
                                xtype: 'textbutton',
                                dock: 'bottom',
                                cls: 'no_border',
                                width: 120,
                                margin: '0 5',
                                text: ExGods.getMsgByKey('view_battle_result_closebtn'),
                                handler: function() {
                                    me.fireEvent('close');
                                },
                                hidden: can_master
                            },
                            {
                                xtype: 'textbutton',
                                dock: 'bottom',
                                cls: 'no_border',
                                width: 120,
                                text: ExGods.getMsgByKey('view_battle_result_closebtn'),
                                margin: '0 5',
                                handler: function() {
                                    ExGods.app.getInventoryInventoryController().service.command('put_from_store_loot', {
                                        battle_id: data.battle_id
                                    }, function() {
                                        me.fireEvent('close');
                                    });
                                },
                                hidden: !can_master
                            },
                            {
                                xtype: 'textbutton',
                                dock: 'bottom',
                                itemId: 'loot_manager_btn',
                                cls: 'no_border',
                                width: 120,
                                text: ExGods.getMsgByKey('view_battle_result_masterbtn'),
                                margin: '0 5',
                                hidden: !can_master || !ExGods.app.getUser().getGuild()
                            }
                        ]
                    }
                ]
            },
            {
                html: '<div class="v-separator" style="height:400px"></div>'
            },
            {
                xtype: 'battleresultside',
                kpi: ekpi,
                members: enemies,
                enemies: true,
                single: single,
                lose: !data.user_result.is_lose,
                margin: '7px 11px 7px 0'
            }
        ];
        me.callParent();
        if (socialFriend && isSocialApp) {
            var ref = ExGods.ref('images|vk_battle_result');
            ExGods.app.getSocialController().wallPost({
                message: ref.description,
                image: ref.image.title,
                owner: socialFriend.id
            });
        }
    },
    //пока только для VK
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Модель результатов боя
 */
Ext.define('ExGods.model.BattleResult', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'bot',
            type: 'int'
        },
        {
            name: 'side',
            type: 'string'
        },
        {
            name: 'live',
            type: 'string'
        },
        {
            name: 'user',
            type: 'auto'
        },
        {
            name: 'kpi',
            type: 'int'
        }
    ]
});

/**
 * Хранилище подсказок
 */
Ext.define('ExGods.store.BattleResult', {
    extend: Ext.data.Store,
    model: 'ExGods.model.BattleResult',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'kpi',
            direction: 'DESC'
        }
    ]
});

/**
 * Сторона боя в контейнере результатов боя
 */
Ext.define('ExGods.view.battle_new.ResultSide', {
    extend: Ext.panel.Panel,
    alias: 'widget.battleresultside',
    width: 227,
    cls: 'battle-result-side',
    initComponent: function() {
        var me = this;
        me.store = Ext.create('ExGods.store.BattleResult', {
            data: me.members
        });
        var tpl = [
                '<div class="paper-title">{[this.getTitle()]}</div>',
                '<tpl if="this.isNotSingle()">',
                '<div class="column-titles">',
                '<p style="float:left">' + ExGods.getMsgByKey('view_battle_resultside_membertitle') + '</p>',
                '<p style="float:right">' + ExGods.getMsgByKey('view_battle_resultside_effecttitle') + '</p>',
                '</div>',
                '</tpl>',
                '<table>',
                '<tpl for=".">',
                '<tpl if="this.isNotSingle()">',
                '<tpl if="xindex &lt; 7">',
                '<tr class="{[ xindex % 2 ? "exg-share-bg-dark" : "exg-share-bg-light" ]}">',
                '<td class="base-info" style="background-image: url({[ this.getImage(values.user.shape) ]})">',
                '<span>{[ ExGods.printUser(values.user, {fields: "name,rank", maxNameWidth: 120})]}</span>',
                '<span>{[ ExGods.printUser(values.user, {fields: "level"})]}</span>',
                '<div class="image-frame"></div>',
                '</td>',
                '<td class="kpi">{[this.calcKpi(values)]}</td>',
                '</tr>',
                '</tpl>',
                '<tpl else>',
                '<div class="battle-result-frame"></div>',
                me.lose ? '<div class="battle-result-lose" style="background-image: url({[this.getLoseImage()]})"></div>' : '',
                '<div class="battle-result-avatar {[this.flip()]}" style="background-image: url({[this.getBigImage(values.user.shape)]})">',
                '</div>',
                '</tpl>',
                '</tpl>',
                '</table>',
                {
                    getImage: function(shape) {
                        if (typeof shape == 'object') {
                            return /^http/.test(shape.thumb) ? shape.thumb : IMAGE_URL + shape.thumb;
                        } else {
                            return ExGods.references.get('user_shape').getByKey(shape).thumb;
                        }
                    },
                    getBigImage: function(shape) {
                        if (typeof shape == 'object') {
                            return /^http/.test(shape.large) ? shape.large : IMAGE_URL + shape.large;
                        } else {
                            return ExGods.references.get('user_shape').getByKey(shape).full;
                        }
                    },
                    getLoseImage: function() {
                        return ExGods.references.get('images').get('avatar_ruin').image.avatar_ruin;
                    },
                    getTitle: function(values) {
                        if (me.single) {
                            return ExGods.printUser(me.store.getAt(0).data.user, {
                                fields: "name,rank,level"
                            });
                        } else {
                            return me.enemies ? '<h4>' + ExGods.getMsgByKey('view_battle_resultside_enemytitle') + '</h4>' : '<h4>' + ExGods.getMsgByKey('view_battle_resultside_allytitle') + '</h4>';
                        }
                    },
                    isNotSingle: function() {
                        return !me.single;
                    },
                    flip: function() {
                        return (me.enemies) ? 'flip-h' : '';
                    },
                    calcKpi: function(values) {
                        return Math.round((values.kpi && me.kpi) ? values.kpi * 100 / me.kpi : 0) + '%';
                    }
                }
            ];
        me.items = [
            {
                xtype: 'dataview',
                store: me.store,
                itemSelector: 'tr',
                tpl: tpl
            }
        ];
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            var dt = me.store.data.items[i].data;
            var shp = ExGods.references.get('user_shape').getByKey(dt.user.shape).thumb;
            arr_images.push(shp);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Список наград в результате боя
 */
Ext.define('ExGods.view.battle_new.Rewards', {
    extend: Ext.panel.Panel,
    alias: 'widget.battlerewards',
    cls: 'battle-rewards',
    initComponent: function() {
        var me = this;
        me.data = me.config.data;
        me.loot = [];
        me.loot_group = [];
        me.item_loot = [];
        me.chain_loot = [];
        me.losses = [];
        // сортирую loot на обычный и относящийся к цепочке по ключу "store_source"
        Ext.Array.each(me.data.loot || [], function(item) {
            if (me.data.loot_group && item.store_source == 'loot')  {
                return;
            }
            
            if (item.store_source == 'chain') {
                me.chain_loot.push(item.stuff);
            } else {
                me.loot.push(item.stuff);
            }
        });
        // собираю групповой лут
        Ext.Array.each(me.data.loot_group || [], function(item) {
            me.loot_group.push(item.stuff);
        });
        // потерянные предметы
        if (me.data.item_drop) {
            Ext.Array.each(me.data.item_drop, function(item) {
                me.losses.push({
                    params: {
                        itemModel: Ext.create('ExGods.model.Item', item.item),
                        id: item.proto
                    },
                    type: 'iteminstance'
                });
            });
        }
        // полученные предметы
        if (me.data.item_loot) {
            Ext.Array.each(me.data.item_loot, function(item) {
                me.item_loot.push({
                    params: {
                        itemModel: Ext.create('ExGods.model.Item', item.item),
                        id: item.proto
                    },
                    type: 'iteminstance'
                });
            });
        }
        // полученные награды за сломанные предметы
        if (me.data.break_reward) {
            me.loot = me.loot.concat(ExGods.helpme.flatStuff(me.data.break_reward, {
                flatItems: true
            }));
        }
        // опыт
        if (me.data.get_exp) {
            var expa = {
                    params: {
                        quantity: me.data.get_exp
                    },
                    type: 'expa'
                };
            if (parseInt(me.data.get_exp) > 0) {
                me.loot.push(expa);
            } else {
                me.losses.push(expa);
            }
        }
        // бонусный опыт
        if (me.data.get_exp_add) {
            var expa_add = {
                    params: {
                        quantity: me.data.get_exp_add
                    },
                    type: 'expa_bonus'
                };
            if (parseInt(me.data.get_exp_add) > 0) {
                me.loot.push(expa_add);
            } else {
                me.losses.push(expa_add);
            }
        }
        // трофеи
        if (me.data.get_trophy) {
            var trophy = {
                    params: {
                        quantity: me.data.get_trophy > 0 ? me.data.get_trophy : me.data.get_trophy * -1
                    },
                    type: 'trophy'
                };
            if (parseInt(me.data.get_trophy) > 0) {
                me.loot.push(trophy);
            } else {
                me.losses.push(trophy);
            }
        }
        // если последний бой цепочки (есть ключ battle_chain), то добавляю данные из цепочки
        if (me.data.battle_chain) {
            if (me.data.battle_chain.win_stuff) {
                me.loot = me.loot.concat(ExGods.helpme.flatStuff(me.data.battle_chain.win_stuff));
            } else if (me.data.battle_chain.lose_stuff) {
                me.losses = me.losses.concat(ExGods.helpme.flatStuff(me.data.battle_chain.lose_stuff));
            }
            me.chain_loot = [];
        }
        // весь лут из цепочки должен быть отображен в общих наградах/потерях
        // определяю размер флага в интерфейсе 
        var flagSize = 'normal';
        if (me.losses.length > 4 || (me.loot.length + me.item_loot.length) > 4 || me.chain_loot.length > 4 || me.loot_group.length > 4 || ((me.loot.length + me.item_loot.length) && me.chain_loot.length && me.losses.length)) {
            flagSize = 'short';
        }
        var loot_tpl = [];
        if (me.loot.length || me.item_loot.length)  {
            loot_tpl.push('<div class="paper-title"><h4>' + ExGods.getMsgByKey('view_battle_rewards_rewardstitle') + '</h4></div><div class="item-rewards"></div>');
        }
        
        if (me.chain_loot.length)  {
            loot_tpl.push('<div class="paper-title"><h4>' + ExGods.getMsgByKey('battle_result_chain_loot_title') + '</h4></div><div class="chain-rewards"></div>');
        }
        
        if (me.loot_group.length)  {
            loot_tpl.push('<div class="paper-title"><h4>' + ExGods.getMsgByKey('view_battle_rewards_grouptitle') + '</h4></div><div class="loot-drop"></div>');
        }
        
        if (me.losses.length)  {
            loot_tpl.push('<div class="paper-title"><h4>' + ExGods.getMsgByKey('view_battle_rewards_losstitle') + '</h4></div><div class="item-drop"></div>');
        }
        
        loot_tpl = loot_tpl.join('<div class="battle-rewards-separator"></div>');
        me.tpl = [
            '<div class="battle-flag ' + (flagSize == 'short' ? 'short-flag' : '') + '" style="background-image: url({[this.getFlag(values)]})"></div>',
            '<div class="battle-rewards-separator"></div>',
            loot_tpl,
            {
                getFlag: function(values) {
                    var ret;
                    if (flagSize == 'short') {
                        if (values.is_draw) {
                            ret = ExGods.ref('images|battle_images').image['drawgame_flag_short'];
                        } else if (values.is_lose) {
                            ret = ExGods.ref('images|battle_images').image['defeat_flag_short'];
                        } else {
                            ret = ExGods.ref('images|battle_images').image['victory_flag_short'];
                        }
                    } else {
                        if (values.is_draw) {
                            ret = ExGods.ref('images|battle_images').image['draw_flag'];
                        } else if (values.is_lose) {
                            ret = ExGods.ref('images|battle_images').image['lose_flag'];
                        } else {
                            ret = ExGods.ref('images|battle_images').image['win_flag'];
                        }
                    }
                    return ret;
                },
                getTitle: function(values) {
                    return (drop || values.is_lose) ? ExGods.getMsgByKey('view_battle_rewards_losstitle') : ExGods.getMsgByKey('view_battle_rewards_rewardstitle');
                }
            }
        ];
        me.callParent();
        me.on('afterrender', function() {
            if (me.losses.length)  {
                me.printLootLose();
            }
            
            if (me.loot.length)  {
                me.printLoot();
            }
            
            if (me.loot_group.length)  {
                me.printGroupLoot();
            }
            
            if (me.item_loot.length) {
                me.printItemLoot();
            }
            if (me.chain_loot.length) {
                me.printChainLoot();
            }
        });
    },
    printLoot: function() {
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            i;
        ExGods.util.Helper.loadProtosFromStuff(me.loot, function() {
            me.el.down('.item-rewards').update(ExGods.stuff.StuffManager.image(me.loot));
        });
    },
    printGroupLoot: function() {
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            i;
        ExGods.util.Helper.loadProtosFromStuff(me.loot_group, function() {
            me.el.down('.loot-drop').update(ExGods.stuff.StuffManager.image(me.loot_group));
        });
    },
    printChainLoot: function() {
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            i;
        ExGods.util.Helper.loadProtosFromStuff(me.chain_loot, function() {
            me.el.down('.chain-rewards').update(ExGods.stuff.StuffManager.image(me.chain_loot));
        });
    },
    /**
     * Отображает полученные вещи
     */
    printItemLoot: function() {
        var me = this,
            items = '',
            protos = ExGods.app.getItemPrototypesStore(),
            el = me.el.down('.item-rewards ul');
        if (!el) {
            me.el.down('.item-rewards').update('<ul>');
            el = me.el.down('.item-rewards ul');
        }
        ExGods.util.Helper.loadProtosFromStuff(me.item_loot, function() {
            el.insertHtml('beforeEnd', ExGods.stuff.StuffManager.image(me.item_loot));
        });
    },
    /**
     * Отображаю потерянные вещи (только items)
     */
    printLootLose: function() {
        var me = this,
            items = '',
            protos = ExGods.app.getItemPrototypesStore(),
            rewards = [];
        ExGods.util.Helper.loadProtosFromStuff(me.losses, function() {
            me.el.down('.item-drop').update(ExGods.stuff.StuffManager.image(me.losses));
        });
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.losses && me.losses.length) {
            stuff_arr = stuff_arr.concat(me.losses);
        }
        if (me.loot && me.loot.length) {
            stuff_arr = stuff_arr.concat(me.loot);
        }
        if (me.loot_group && me.loot_group.length) {
            stuff_arr = stuff_arr.concat(me.loot_group);
        }
        if (me.item_loot && me.item_loot.length) {
            stuff_arr = stuff_arr.concat(me.item_loot);
        }
        if (me.chain_loot && me.chain_loot.length) {
            stuff_arr = stuff_arr.concat(me.chain_loot);
        }
        var images__ = ExGods.ref('images|battle_images').image;
        for (var it in images__) {
            arr_images.push(images__[it]);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Контроллер отображения боя.
 */
Ext.define('ExGods.controller.battle.BattleView', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BattleView:'
    },
    views: [
        'battle_new.Avatar',
        'battle_new.UserList',
        'battle_new.Result',
        'battle_new.ResultSide',
        'battle_new.Rewards',
        'battle_new.Roller',
        'battle_new.PrepActions',
        'battle_new.Choice'
    ],
    refs: [
        {
            /**
         * @private
         * @method getBattleChatMessages
         * Получает вкладку чата лога боя
         * @return {ExGods.view.chat.MessageList}
         */
            ref: 'battleChatMessages',
            selector: '#battle-chat-messages'
        },
        {
            /**
         * @private
         * @method getChatContactList
         * Возвращает список контактов во вкладке "Общий"
         */
            ref: 'chatContactList',
            selector: '#chat-contact-list #contact-list'
        },
        {
            /**
         * @private
         * @method getBattleContainer
         * Получет контейнер боя
         * @return {Ext.container.Container}
         */
            ref: 'battleContainer',
            selector: 'battlecontainer'
        },
        {
            /**
         * @method getQuickSlots
         * Возвращает отображение быстрых слотов
         * @return {ExGods.view.QuickSlots}
         */
            ref: 'quickSlots',
            selector: '#quick-slots'
        }
    ],
    /**
     * @property {Number} cur_round Номер текущего раунда, который обрабатывается контроллером
     */
    cur_round: undefined,
    aura: {},
    init: function() {
        var me = this;
        /*me.app.getChatConnection().on({
            command_battle_log: me.onBattleLogMessage,
            scope: me
        });*/
        // me.listen({
        //  controller: {
        //      '#battle.Battle': {
        //          'load_start': me.onBattleLoadStart,
        //          'start': me.onBattleStart,
        //          'not_active_battle': me.onNotActiveBattle,
        //          'u_change': me.onBattleUserChange,
        //          'u_add': me.onBattleUserAdd,
        //          'u_title': me.onBattleUserTitle,
        //          'load_finish': me.onBattleLoadFinish,
        //          'finish': me.onBattleFinish,
        //          'before_reroll': me.onBattleBeforeReroll,
        //          'reroll': me.onBattleReroll,
        //          'before_prep': me.onBattleBeforePrep,
        //          'prep': me.onBattlePrep,
        //          'before_kick': me.onBattleBeforeKick,
        //          'kick': me.onBattleKick,
        //          'user_kick': me.onBattleUserKick,
        //          'enemy_kick': me.onBattleEnemyKick,
        //          'load_round': me.onBattleLoadRound,
        //          'round': {
        //              fn: me.onBattleRound,
        //              delay: 400
        //          },
        //          'item': me.onBattleItem,
        //          'apply_marks':me.applyMarks,
        //          'exit': me.onBattleExit,
        //          'state_refresh': me.onBattleStateRefresh,
        //      },
        //      '#battle.Animation': {
        //          afteranim: me.onAfterAnimation,
        //      }
        //  },
        //  component: {
        //      '#battle-header' : {
        //          showbattle: me.onBattleHeaderShowBattle,
        //          showgroup: me.onBattleHeaderShowGroup
        //      },
        //      '#battle-prepacts': {
        //          prepclick: me.onPrepButtonClick,
        //      },
        //      '#battle-roller': {
        //          turnclick: me.onRollerTurnClick,
        //          rerollclick: me.onRerollButtonClick
        //      }
        //  }
        // });
        me.control({
            '#battle-header': {
                showbattle: me.onBattleHeaderShowBattle,
                showgroup: me.onBattleHeaderShowGroup
            },
            '#battle-prepacts': {
                prepclick: me.onPrepButtonClick
            },
            '#battle-roller': {
                turnclick: me.onRollerTurnClick,
                rerollclick: me.onRerollButtonClick
            }
        });
        // список юзеров первой стороны
        me.allies = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.User',
            sorters: [
                {
                    sorterFn: function() {
                        return me.sortMembers.apply(me, arguments);
                    }
                }
            ]
        });
        // список юзеров второй стороны
        me.enemies = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.User',
            sorters: [
                {
                    sorterFn: function() {
                        return me.sortMembers.apply(me, arguments);
                    }
                }
            ]
        });
        // быстрая ссылка на контроллер боя
        me.battle = me.app.getController('battle.Battle');
        // быстрая ссылка на контроллер анимации
        me.animation = me.app.getController('battle.Animation');
        // быстрая ссылка на контроллер инвентаря
        me.inventory = me.app.getController('inventory.Inventory');
        ExGods.stuff.StuffManager.register({
            'expa_bonus': ExGods.view.battle_new.stuff.BattleReward
        });
        me.callParent(arguments);
    },
    /**
     * Вернёт true, если бой отрисован
     */
    isRendered: function() {
        return this.getBattleContainer() ? true : false;
    },
    /**
    * Повесить обработчик на показ боя
    */
    onRender: function(listener) {
        var me = this;
        me.control({
            '#battle-container': {
                render: listener
            }
        });
    },
    /**
    * Повесить обработчик на удаление боя
    */
    onDestroy: function(listener) {
        var me = this;
        me.control({
            '#battle-container': {
                destroy: listener
            }
        });
    },
    applyMarks: function(marks) {
        var me = this;
        me.marks = marks;
        if (me.getBattleContainer()) {
            var actions = [],
                prepacts = [],
                turns = [],
                items = [];
            Ext.each(marks, function(quest) {
                Ext.each(quest.aims, function(aim) {
                    Ext.each(aim.marks, function(mark) {
                        if (mark.battle_action)  {
                            actions.push(mark.battle_action);
                        }
                        
                        if (mark.instant)  {
                            prepacts.push(mark.instant);
                        }
                        
                        if (mark.main)  {
                            turns.push(mark.main);
                        }
                        
                        if (mark.item)  {
                            items.push(mark.item);
                        }
                        
                    });
                });
            });
            Ext.getCmp('battle-roller').applyMarks(turns);
            Ext.getCmp('battle-prepacts').applyMarks(prepacts);
            me.getQuickSlots().applyMarks(actions, items);
        }
    },
    //пока не знаю что делать с итемами
    onBattleLogMessage: function(chatcn, message) {
        var me = this,
            data = message.body.data,
            chatMessages = me.getBattleChatMessages(),
            tpl, battle_log;
        if (data.message) {
            message.tpl = data.message;
        } else {
            battle_log = ExGods.references.get('battle_log');
            tpl = battle_log.getByKey(data.type + '_' + (data.result || ''));
            if (tpl) {
                message.tpl = tpl.pattern;
            }
        }
        if (chatMessages && message) {
            chatMessages.addMessage(message);
        }
    },
    onBattleLoadStart: function() {
        var me = this;
        if (me.app.getController('Viewport').layout && me.app.getController('Viewport').layout != 'battle') {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Вешаю маску на локацию');
            me.canLayout = false;
            me.app.getController('Location').maskLocation(function() {
                if (me.canLayout) {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Маска показана, данные есть - показываю бой');
                    me.setLayoutAndShow();
                } else {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Маска показана, данных нет - жду');
                    me.canLayout = true;
                }
            });
        } else {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Лейаут уже боевой, маска не нужна');
            me.canLayout = true;
        }
    },
    onBattleStart: function() {
        var me = this,
            side1 = [],
            side2 = [],
            myBattleSide = me.user.getBattleSide();
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Данные боя пришли');
        // заполняю списки участников
        me.battle.list.each(function(u) {
            var u_copy = Ext.clone(u);
            if (u.battle.side == "1") {
                side1.push(u_copy);
            } else {
                side2.push(u_copy);
            }
        });
        me.allies.removeAll();
        me.enemies.removeAll();
        me.allies.loadRawData(myBattleSide == 1 ? side1 : side2);
        me.enemies.loadRawData(myBattleSide == 1 ? side2 : side1);
        me.allies.sort();
        me.enemies.sort();
        me.cur_round = me.battle.state.round;
        me.changes = {};
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Список участников сформирован, текущий раунд - ' + me.cur_round);
        if (me.canLayout) {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Маска показана - показываю бой');
            me.setLayoutAndShow();
        } else {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Маска еще не показана - жду');
            me.canLayout = true;
        }
    },
    setLayoutAndShow: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Меняю лейаут на боевой');
        me.app.getController('Viewport').setLayout('battle', function() {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Лейаут отрисован, отрисовываю компоненты');
            me.resetFlags();
            me.showBattleView();
            me.applyMarks(me.marks);
            me.showHint('start');
            me.inventory.lockNewItemsUpdate();
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView Компоненты отрисованы');
        });
    },
    showBattleView: function() {
        var me = this,
            battleCt = me.getBattleContainer(),
            myBattleSide = me.user.getBattleSide(),
            enemyInfoCmp, enemy;
        /***/
        me.log('показываю бой');
        if (battleCt) {
            battleCt.removeAll();
            enemy = me.getBattleEnemy();
            // добавляю вью боя
            var cntrl_comp = Ext.create({
                    xtype: 'container',
                    layout: {
                        type: 'hbox',
                        align: 'stretch'
                    },
                    items: [
                        {
                            xtype: 'battle_avatar',
                            id: 'battle-avatar',
                            user: me.getBattleUser(me.user.getBattleEkey()),
                            isEnemy: false,
                            width: 218
                        },
                        {
                            xtype: 'container',
                            layout: 'absolute',
                            id: 'battle-central',
                            flex: 1,
                            plugins: [
                                'skindeco'
                            ],
                            items: [
                                {
                                    xtype: 'component',
                                    cls: 'bg',
                                    width: 476,
                                    height: 396,
                                    x: -27,
                                    y: 31,
                                    style: {
                                        'background-image': 'url(' + ExGods.ref('images|battle_images').image['battle_main'] + ')'
                                    }
                                },
                                {
                                    xtype: 'battle_roller',
                                    id: 'battle-roller',
                                    state: Ext.clone(me.battle.state),
                                    animateOnRender: true
                                },
                                {
                                    xtype: 'battle_preps',
                                    id: 'battle-prepacts',
                                    state: Ext.clone(me.battle.state),
                                    battleView: me
                                },
                                {
                                    xtype: 'battle_choice',
                                    id: 'battle-choice',
                                    state: Ext.clone(me.battle.state)
                                }
                            ]
                        },
                        {
                            xtype: 'battle_avatar',
                            id: 'battle-enemy-avatar',
                            user: enemy,
                            isEnemy: true,
                            width: 218
                        }
                    ]
                });
            battleCt.add(cntrl_comp);
            // добавляю вью группы
            var enemy_lst = Ext.create({
                    xtype: 'container',
                    autoShow: false,
                    layout: {
                        type: 'hbox',
                        align: 'stretch'
                    },
                    padding: 2,
                    items: [
                        {
                            xtype: 'battle_userlist',
                            store: me.allies,
                            flex: 1
                        },
                        {
                            xtype: 'battle_userlist',
                            store: me.enemies,
                            isEnemies: true,
                            flex: 1
                        }
                    ]
                });
            ExGods.Resources.load(enemy_lst, function() {
                ExGods.Resources.load(cntrl_comp, function() {
                    battleCt.add(enemy_lst);
                });
            });
            // показываю данные по противнику в правом верхнем углу экрана
            if (enemy) {
                enemyInfoCmp = Ext.getCmp('battle-enemy-info');
                if (enemyInfoCmp) {
                    enemyInfoCmp.setUser(enemy);
                }
            }
            ExGods.util.Ticker.addListener(me.onTick, me);
            battleCt.on('destroy', function() {
                ExGods.util.Ticker.removeListener(me.onTick, me);
            });
            //изменяю шапку
            var userInfo = Ext.getCmp('tech-info'),
                enemyInfo = Ext.getCmp('header-right');
            userInfo.setUser(me.getBattleUser(me.user.getBattleEkey()));
            userInfo.fireEvent('battlestart');
            enemyInfo.addCls('in-battle');
            me.getQuickSlots().setDisabled((battleCt.down('battle_roller').f_wait_enemy) ? true : !me.battle.state.can_item);
            // после смерти игрока блокирую интерфейс
            var user = me.getBattleUser(me.user.getBattleEkey());
            user.on('battlechanged', function() {
                var rollerCmp = Ext.getCmp('battle-roller'),
                    prepActsCmp = Ext.getCmp('battle-prepacts'),
                    headerCmp = Ext.getCmp('battle-header'),
                    choiceCmp = Ext.getCmp('battle-choice');
                if (!user.isLiveInBattle() && !me.battle.result) {
                    // если бой окончен (есть результат), не блокирую
                    headerCmp.setDied(true);
                    rollerCmp.hidePointer();
                    rollerCmp.setDead();
                    prepActsCmp.setDisabled(true);
                    me.getQuickSlots().setDisabled(true);
                }
            });
        } else {
            /***/
            me.log('error', 'Контейнер боя не создан.');
        }
    },
    /**
     * Завершить всю анимацию и показать результат боя
     */
    finishAnimationAndShowResult: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Подписываюсь на окончания анимации');
        me.animation.onAnimationFinish(function() {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Анимация завершена');
            setTimeout(function() {
                me.showResultView();
            }, 2500);
        });
    },
    // чтобы успеть показать аватар смерти
    /**
     * Показать результат боя
     */
    showResultView: function() {
        var me = this,
            viewport = me.app.getController('Viewport'),
            wnd;
        /***/
        me.log('показываю результат боя', me.battle.result);
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Меняю лейаут на основной');
        try {
            viewport.setLayout('main', function() {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Создаю окно результатов');
                //изменяю шапку
                var userInfo = Ext.getCmp('tech-info'),
                    enemyInfo = Ext.getCmp('header-right');
                userInfo.setUser(me.user);
                userInfo.fireEvent('battlefinish', {
                    battle_result: me.battle.result
                });
                enemyInfo.removeCls('in-battle');
                if (me.battle.result) {
                    wnd = Ext.widget('window2', {
                        id: 'battle-result',
                        autoShow: false,
                        items: [
                            {
                                xtype: 'battleresult',
                                data: {
                                    battle_result: me.battle.result
                                },
                                listeners: {
                                    close: function() {
                                        wnd.close();
                                    }
                                }
                            }
                        ]
                    });
                    ExGods.Resources.load(wnd, function() {
                        wnd.show();
                    });
                }
                me.getQuickSlots().setDisabled(false);
                me.inventory.unlockNewItemsUpdate();
                if (!viewport.gameShown) {
                    viewport.on('gameshown', function() {
                        if (wnd && wnd.rendered) {
                            wnd.doLayout();
                        }
                    }, this, {
                        single: true,
                        delay: 200
                    });
                }
            });
        } catch (e) {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Ошибка смены лейаута ' + e);
            /***/
            me.log('error', e);
        }
    },
    getListBySide: function(side) {
        var me = this;
        if (me.user.getBattleSide() == side) {
            return me.allies;
        } else {
            return me.enemies;
        }
    },
    onTick: function() {
        var me = this,
            startDate = new Date(me.battle.state.start * 1000 + ExGods.util.Date.serverTimeOffset * 1000),
            restToRound,
            roller = Ext.getCmp('battle-roller'),
            viewport = ExGods.app.getViewportController();
        // startDate = ExGods.util.Date.normalizeServerDateTime(startDate);
        restToRound = Math.max(me.battle.state.to_round - parseInt((Date.now() - startDate) / 1000), 0);
        // показываю указатель "Нажмите" если до конца раунда осталось менее z-секунд и после реролла прошло более x-секунд
        if (viewport.gameShown && restToRound <= (ExGods.ref('constants|bat_anim_pointer_time').value / 1000) && restToRound > 0 && (!me.rerollTime || (Date.now() - me.rerollTime) > parseInt(ExGods.ref('constants|bat_anim_pointer_speed').value) * 2) && ExGods.app.getViewportController().getCenter().isVisible() && !roller.is_shown_pointer && !me.f_wait_kick && !me.f_start_round_complete && !roller.animating && !Ext.getCmp('battle-prepacts').marksInterval && !me.getQuickSlots().marksInterval && Ext.select('.turn:not([class="turn disabled"])').elements.length) {
            roller.showPointer();
        } else {
            roller.hidePointer();
        }
        try {
            Ext.getCmp('battle-header').setTime(restToRound);
            Ext.getCmp('battle-prepacts').updateCounters();
        } catch (e) {
            /****/
            me.log('error', 'Компоненты боя не созданы');
        }
    },
    /** Обработчики пользовательских действий **/
    onRollerTurnClick: function(name) {
        var me = this;
        me.battle.doKick(name);
    },
    onPrepButtonClick: function(prepName) {
        var me = this;
        me.battle.doPrep(prepName);
    },
    onRerollButtonClick: function(btn) {
        var me = this;
        me.battle.doReroll();
    },
    onBattleHeaderShowBattle: function() {
        var me = this,
            battleCt = me.getBattleContainer();
        if (battleCt) {
            battleCt.getLayout().setActiveItem(0);
            Ext.select('.finger').fadeIn();
        }
    },
    onBattleHeaderShowGroup: function() {
        var me = this,
            battleCt = me.getBattleContainer();
        if (battleCt) {
            battleCt.getLayout().setActiveItem(1);
            Ext.select('.finger').fadeOut();
        }
    },
    /**
     * Вернёт модель игрока в бою по battle ekey. Если ekey не указан, вернет текущего игрока
     */
    getBattleUser: function(ekey) {
        var me = this,
            index;
        ekey = ekey || me.user.getBattleEkey();
        index = me.allies.findBy(function(u) {
            return u.data.battle.ekey == ekey;
        });
        if (index != -1) {
            return me.allies.getAt(index);
        } else {
            index = me.enemies.findBy(function(u) {
                return u.data.battle.ekey == ekey;
            });
            if (index != -1) {
                return me.enemies.getAt(index);
            } else {
                return null;
            }
        }
    },
    /**
     * Вернёт модель текущего врага.
     * Текущего с точки зрения вью, т.к. враг мог поменяться, но вью ешё не отрисовало переход из-за искусственной задержки анимации хода
     */
    getBattleEnemy: function() {
        var me = this,
            enemyAvatarCmp = Ext.getCmp('battle-enemy-avatar');
        if (enemyAvatarCmp) {
            return enemyAvatarCmp.user;
        } else {
            if (me.battle.state.live != "0" && me.battle.state.enemy) {
                return me.getBattleUser(me.battle.state.enemy);
            } else {
                return null;
            }
        }
    },
    /**
     * Обработчик изменений в данных участника боя
     */
    onBattleUserChange: function(data) {
        var me = this;
        data = Ext.clone(data);
        me.changes = me.changes || {};
        if (me.cur_round != me.battle.state.round) {
            me.changes.next = me.changes.next || {};
            me.changes.next[data.battle.ekey] = me.changes.next[data.battle.ekey] || [];
            me.changes.next[data.battle.ekey].push(data);
        } else {
            me.changes[data.battle.ekey] = me.changes[data.battle.ekey] || [];
            me.changes[data.battle.ekey].push(data);
            me.applyChanges(data.battle.ekey, data);
        }
    },
    /**
     * @private Применяет изменения на игрока в бою
     */
    applyChanges: function(ekey, changes) {
        var me = this,
            user = me.getBattleUser(me.user.getBattleEkey()),
            enemy = me.getBattleEnemy(),
            u;
        changes = Ext.clone(changes);
        if (ekey == user.getBattleEkey()) {
            u = user;
        } else if (enemy && ekey == enemy.getBattleEkey()) {
            u = enemy;
        }
        if (u) {
            // Note: таймеды, аура текущего игрока или врага синхронизируются только при завершения раунда
            // остальные данные как обычно
            delete changes.timed;
            delete changes.battle;
            delete changes.aura;
            delete changes.stats;
            u.set(changes);
        } else {
            u = me.getBattleUser(ekey);
            if (u) {
                u.set(changes);
                //принудительно запускаю рефреш вьюшки, т.к. апдейт происходит далеко не всегда после сета модели
                me.allies.fireEvent('do_refresh');
                me.enemies.fireEvent('do_refresh');
            }
        }
    },
    /**
     * @private Применяет изменения следующего раунда
     */
    applyChangesOnNewRound: function() {
        var me = this;
        if (me.changes && me.changes.next) {
            me.changes = me.changes.next;
            me.changes.next = {};
            Ext.Object.each(me.changes, function(k, v) {
                me.applyChanges(k, v[v.length - 1]);
            });
        } else {
            me.changes = {
                next: {}
            };
        }
    },
    /**
     * @private Синхронизирует все пришедшие изменения игрока в бою
     */
    syncChanges: function() {
        var me = this,
            u_ekey = me.user.getBattleEkey(),
            user = me.getBattleUser(me.user.getBattleEkey()),
            enemy = me.getBattleEnemy(),
            e_ekey = enemy ? enemy.getBattleEkey() : null;
        if (me.changes) {
            if (me.changes[u_ekey]) {
                user.set(me.changes[u_ekey][me.changes[u_ekey].length - 1]);
            }
            if (enemy && me.changes[e_ekey]) {
                enemy.set(me.changes[e_ekey][me.changes[e_ekey].length - 1]);
            }
        }
    },
    /**
     * Обработчик появления нового участника боя
     */
    onBattleUserAdd: function(data) {
        var me = this;
        if (me.user.getBattleSide() == data.battle.side) {
            me.allies.loadRawData(Ext.clone(data), true);
        } else {
            me.enemies.loadRawData(Ext.clone(data), true);
        }
    },
    onBattleUserTitle: function(ekey, title) {
        var me = this,
            user = me.allies.getAt(me.allies.findBy(function(user) {
                return user.data.battle.ekey == ekey;
            }));
        if (!user) {
            user = me.enemies.getAt(me.enemies.findBy(function(user) {
                return user.data.battle.ekey == ekey;
            }));
        }
        if (user) {
            user.set('display_title', title);
        }
    },
    onBattleBeforeReroll: function() {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller');
        rollerCmp.disableBtn(true);
        rollerCmp.startAnimate();
        me.rerollTime = Date.now();
    },
    onBattleReroll: function() {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller');
        setTimeout(function() {
            rollerCmp.setState(me.battle.state);
            rollerCmp.stopAnimate(function() {
                rollerCmp.disableBtn(me.f_start_round_complete);
            });
        }, 1000 - (Date.now() - me.rerollTime));
        rollerCmp.disableBtn(me.f_start_round_complete);
    },
    onBattleBeforePrep: function() {
        var me = this,
            prepActsCmp = Ext.getCmp('battle-prepacts');
    },
    // 
    onBattlePrep: function() {
        var me = this,
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            rollerCmp = Ext.getCmp('battle-roller');
        prepActsCmp.setState(me.battle.state);
        rollerCmp.setState(me.battle.state);
    },
    onBattleBeforeKick: function() {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller'),
            prepActsCmp = Ext.getCmp('battle-prepacts');
        prepActsCmp.setDisabled(true);
        rollerCmp.hidePointer();
        rollerCmp.disableBtn(true);
        me.getQuickSlots().setDisabled(true);
        me.setFlag('f_wait_kick', true);
    },
    onBattleKick: function(kickName) {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller'),
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            choiceCmp = Ext.getCmp('battle-choice'),
            headerCmp = Ext.getCmp('battle-header');
        headerCmp.setBlocked(true);
        me.animateKickChoice(kickName, function() {
            setTimeout(function() {
                if (!me.f_enemy_kick && !me.f_start_round_complete) {
                    rollerCmp.waitEnemyTurn(true);
                }
            }, 500);
        });
    },
    // жду ещё чуть чтобы убедиться, что враг не сделал свой ход
    onBattleUserKick: function(kickName) {
        var me = this,
            choiceCmp = Ext.getCmp('battle-choice');
        if (me.f_user_kick) {
            return;
        }
        // уже есть кик от юзера
        me.setFlag('f_user_kick', true);
        if (!me.f_wait_kick) {
            choiceCmp.setMyChoice(kickName);
        }
        me.completeRoundOnKick();
    },
    onBattleEnemyKick: function(kickName) {
        var me = this,
            choiceCmp = Ext.getCmp('battle-choice');
        if (me.f_enemy_kick) {
            return;
        }
        // уже есть кик от врага
        me.setFlag('f_enemy_kick', true);
        if (me.f_wait_kick && !me.f_kick_choice_animated) {
            me.on('kick_choice_animated', function() {
                choiceCmp.setEnemyChoice(kickName, function() {
                    me.setFlag('f_ekick_choice_animated', true);
                    me.fireEvent('ekick_choice_animated');
                });
            }, me, {
                single: true
            });
        } else {
            choiceCmp.setEnemyChoice(kickName, function() {
                me.setFlag('f_ekick_choice_animated', true);
                me.fireEvent('ekick_choice_animated');
            });
        }
        me.completeRoundOnKick();
    },
    onBattleLoadRound: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Подгрузка раунда..Завершаю предыдущий');
        if (!me.f_start_round_complete) {
            if (me.f_wait_kick && !me.f_kick_choice_animated) {
                me.on('kick_choice_animated', function() {
                    me.completeRound();
                }, me, {
                    single: true
                });
            } else {
                me.completeRound();
            }
        }
    },
    onBattleRound: function() {
        var me = this;
        if (me.f_start_round_complete) /* && me.battle.state.live != "0"*/
        {
            // если раунд еще не завершен
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Новый раунд.. Предыдущий еще не завершен - выставляю признак что есть новый');
            me.setFlag('f_show_new_round', true);
        } else {
            me.showNewRound();
        }
    },
    showNewRound: function() {
        var me = this,
            user = me.getBattleUser(me.user.getBattleEkey()),
            rollerCmp = Ext.getCmp('battle-roller'),
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            headerCmp = Ext.getCmp('battle-header'),
            choiceCmp = Ext.getCmp('battle-choice');
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Отрисовка нового раунда');
        me.resetFlags();
        if (me.battle.state.live != "0") {
            // запускаю анимацию барабана и останавливаю после таймаута
            rollerCmp.startAnimate();
            setTimeout(function() {
                rollerCmp.setState(me.battle.state);
                rollerCmp.stopAnimate(function() {
                    rollerCmp.disableBtn(false);
                    prepActsCmp.setDisabled(false);
                });
            }, 1000);
            // обновляю предварителные действия
            prepActsCmp.setState(me.battle.state);
            prepActsCmp.actions_disabled = false;
            choiceCmp.clearChoice();
            // разблокирую таймер в шапке
            headerCmp.setBlocked(false);
            // разблокирую быстрые слоты, если можно их использовать
            if (me.battle.state.can_item) {
                me.getQuickSlots().setDisabled(false);
            }
        } else {
            // умер
            choiceCmp.clearChoice();
        }
        me.allies.sort();
        me.enemies.sort();
        me.updateEnemy();
        //убираю тултипы
        if (prepActsCmp.tooltip) {
            prepActsCmp.tooltip.close();
            prepActsCmp.tooltip = false;
        }
        if (rollerCmp.tooltip) {
            rollerCmp.tooltip.close();
            rollerCmp.tooltip = false;
        }
        me.applyMarks(me.marks);
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Обновляю значение текущего раунда ' + me.battle.state.round);
        me.cur_round = me.battle.state.round;
        me.applyChangesOnNewRound();
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Генерирую событие new_round');
        me.fireEvent('new_round', me, me.battle.state.round);
        me.animation.onBattleViewNewRound(me, me.battle.state.round);
        me.setFlag('f_show_new_round', undefined);
    },
    onBattleLoadFinish: function() {
        var me = this,
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            rollerCmp = Ext.getCmp('battle-roller'),
            quickSlots = me.getQuickSlots();
        if (rollerCmp) {
            if (rollerCmp.mouseOverTimeOut) {
                clearTimeout(rollerCmp.mouseOverTimeOut);
            }
            if (rollerCmp.marksInterval) {
                clearInterval(rollerCmp.marksInterval);
            }
            if (rollerCmp.tooltip) {
                rollerCmp.tooltip.close();
                rollerCmp.tooltip = false;
            }
        }
        if (prepActsCmp) {
            if (prepActsCmp.mouseOverTimeOut) {
                clearTimeout(me.mouseOverTimeOut);
            }
            if (prepActsCmp.marksInterval) {
                clearInterval(prepActsCmp.marksInterval);
            }
            if (prepActsCmp.actionInfo && prepActsCmp.actionInfo.close) {
                prepActsCmp.actionInfo.close();
            }
        }
        if (quickSlots.marksInterval) {
            clearInterval(quickSlots.marksInterval);
        }
    },
    onBattleFinish: function() {
        var me = this;
        if (me.cur_round != me.battle.state.round) {
            // если есть следующий раунд, то показываю его и только после показываю результаты боя
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Есть еще один раунд. Сначала показываю его. Текущий - ' + me.cur_round + ', следующий - ' + me.battle.state.round);
            me.on('new_round', function() {
                me.finishAnimationAndShowResult();
            }, me, {
                single: true
            });
        } else if (me.f_start_round_complete) {
            // если раунд еще не завершен
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Раунд еще не завершен. Выставляю признак - показать результат после раунда');
            me.setFlag('f_show_result', true);
        } else {
            me.finishAnimationAndShowResult();
        }
    },
    onNotActiveBattle: function() {
        var me = this,
            viewport = me.app.getController('Viewport');
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Битва неавктивна. Показываю основой лейаут');
        if (viewport.layout != 'main') {
            viewport.setLayout('main', function() {
                // TODO - вынести этот код во вьюшки, которые должны реагировать на смену лейаута
                //изменяю шапку
                var userInfo = Ext.getCmp('tech-info'),
                    enemyInfo = Ext.getCmp('header-right');
                userInfo.setUser(me.user);
                enemyInfo.removeCls('in-battle');
                me.getQuickSlots().setDisabled(false);
                me.inventory.unlockNewItemsUpdate();
                me.app.getController('Location').unmaskLocation();
            });
        } else {
            me.app.getController('Location').unmaskLocation();
        }
    },
    onBattleItem: function() {
        var me = this;
        me.getQuickSlots().setDisabled(!me.battle.state.can_item);
    },
    onBattleExit: function() {
        var me = this,
            viewport = me.app.getController('Viewport'),
            location = me.app.getController('Location'),
            userInfo = Ext.getCmp('tech-info'),
            enemyInfo = Ext.getCmp('header-right'),
            headerCmp = Ext.getCmp('battle-header');
        headerCmp.setBlocked(true);
        location.maskLocation(function() {
            viewport.setLayout('main', function() {
                //изменяю шапку
                userInfo.setUser(me.user);
                userInfo.fireEvent('battlefinish', {
                    battle_result: me.battle.result
                });
                enemyInfo.removeCls('in-battle');
                me.getQuickSlots().setDisabled(false);
                me.inventory.unlockNewItemsUpdate();
            });
        }, {
            img: me.user.location.data.blob.image
        });
    },
    onBattleStateRefresh: function() {
        var me = this,
            prepActsCmp = Ext.getCmp('battle-prepacts');
        // обновляю компоненты
        if (prepActsCmp && me.isRendered()) {
            prepActsCmp.setState(me.battle.state);
        }
    },
    completeRoundOnKick: function() {
        var me = this,
            enemy = me.getBattleEnemy();
        if (me.f_user_kick && (!enemy || me.f_enemy_kick)) {
            me.setFlag('f_start_round_complete', true);
            if (enemy && !me.f_ekick_choice_animated) {
                me.on('ekick_choice_animated', function() {
                    me.completeRound();
                }, me, {
                    single: true
                });
            } else if (me.f_wait_kick && !me.f_kick_choice_animated) {
                me.on('kick_choice_animated', function() {
                    me.completeRound();
                }, me, {
                    single: true
                });
            } else {
                me.completeRound();
            }
        }
    },
    completeRound: function() {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller'),
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            headerCmp = Ext.getCmp('battle-header');
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Завершаю раунд ' + me.cur_round);
        rollerCmp.disableBtn(true);
        rollerCmp.waitEnemyTurn(false);
        rollerCmp.hidePointer();
        headerCmp.setBlocked(true);
        prepActsCmp.setDisabled(true);
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Проигрываю анимации');
        try {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Обновляю выбор из анимации');
            me.animation.refreshChoiceFromAnimation();
        } catch (e) {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Ошибка при обновлении выбора удара из анимации ' + e);
        }
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Пауза перед анимацией');
        me.waitBeforeAnimations(function() {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Анимация kick1');
            me.animation.animateKick(1, function() {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Анимация kick2');
                me.animation.animateKick(2, function() {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Анимация длящегося1');
                    me.animation.animateMyContinuing(function() {
                        /*****/
                        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Анимация длящегося2');
                        me.animation.animateEnemyContinuing(function() {
                            /*****/
                            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Анимация последняя');
                            me.animation.animateFinal(function() {
                                // синхронизирую данные игроков
                                try {
                                    /*****/
                                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Cинхронизация данных');
                                    me.syncChanges();
                                } catch (e) {
                                    /*****/
                                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Ошибка синхронизации данных игрока ' + e);
                                }
                                /*****/
                                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Пауза перед смертью');
                                me.waitIfDied(function() {
                                    // пауза, если умер кто
                                    /*****/
                                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView После паузы');
                                    if (me.f_show_result) {
                                        /*****/
                                        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Показываю результат');
                                        me.showResultView();
                                    } else if (me.f_show_new_round) {
                                        /*****/
                                        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Показываю новый раунд');
                                        me.showNewRound();
                                    } else {
                                        /*****/
                                        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Сброс флагов. жду');
                                        me.resetFlags();
                                    }
                                });
                            });
                        });
                    });
                });
            });
        });
    },
    updateEnemy: function() {
        var me = this,
            enemyAvatarCmp = Ext.getCmp('battle-enemy-avatar'),
            enemyInfoCmp = Ext.getCmp('battle-enemy-info'),
            curEnemy = me.getBattleEnemy(),
            newEnemyEkey = me.battle.state.enemy,
            enemy;
        if (me.battle.state.live != "0") {
            if (!curEnemy || curEnemy.getBattleEkey() != newEnemyEkey) {
                enemy = me.getBattleUser(newEnemyEkey);
                enemyAvatarCmp.setUser(enemy);
                if (enemy) {
                    enemyInfoCmp.setUser(enemy);
                    enemyInfoCmp.show();
                    if (!curEnemy || curEnemy.getBattleEkey() != newEnemyEkey) {
                        me.showHint('enemy_changed');
                    }
                } else {
                    enemyInfoCmp.hide();
                }
            }
        } else {
            enemyAvatarCmp.setUser(null);
            enemyInfoCmp.hide();
        }
    },
    animateKickChoice: function(kickName, callback) {
        var me = this,
            choiceCmp = Ext.getCmp('battle-choice'),
            _finish = function() {
                choiceCmp.setMyChoice(kickName);
                delete me.kick_choice_animating;
                me.setFlag('f_kick_choice_animated', true);
                callback();
                me.fireEvent('kick_choice_animated');
            };
        if (!me.kick_choice_animating) {
            me.kick_choice_animating = true;
            var dom = undefined;
            try {
                dom = Ext.select('[role=' + kickName + ']').elements[0];
            } catch (e) {
                me.log('warn', 'kickName равен ' + kickName + " бой уже закончен!");
                dom = undefined;
            }
            if (!dom) {
                _finish();
                return;
            }
            var el = Ext.get(dom),
                img = el.down('.image'),
                position = img.getXY(),
                container = me.getBattleContainer().down('#battle-central');
            position[0] -= container.getX();
            position[1] -= container.getY();
            var animEl = container.el.insertHtml('beforeEnd', '<div class="image-animate" style="' + 'top:' + position[1] + 'px;' + 'left:' + position[0] + 'px;' + 'background-image:' + Ext.String.htmlEncode(img.dom.style.backgroundImage) + '"></div>', true);
            el.down('.image').setStyle('opacity', 0);
            animEl.animate({
                to: {
                    top: 216,
                    left: 122,
                    opacity: ExGods.ref('constants|bat_anim_choice1_opacity').value
                },
                duration: ExGods.ref('constants|bat_anim_choice1_dur').value,
                callback: function() {
                    animEl.remove();
                    _finish();
                }
            });
        }
    },
    resetFlags: function() {
        var me = this;
        me.setFlag('f_start_round_complete', undefined);
        me.setFlag('f_wait_kick', undefined);
        me.setFlag('f_kick_choice_animated', undefined);
        me.setFlag('f_ekick_choice_animated', undefined);
        me.setFlag('f_user_kick', undefined);
        me.setFlag('f_enemy_kick', undefined);
        me.setFlag('f_show_new_round', undefined);
        me.setFlag('f_show_result', undefined);
    },
    setFlag: function(f, v) {
        this.log(f + ' = ' + v);
        this[f] = v;
    },
    waitBeforeAnimations: function(callback) {
        var me = this;
        setTimeout(function() {
            callback();
        }, ExGods.ref('constants|bat_anim_delay_before_start').value);
    },
    waitIfDied: function(callback) {
        var me = this,
            user = me.getBattleUser(me.user.getBattleEkey()),
            enemy = me.getBattleEnemy();
        // если игрок или враг умер жду какое-то время, чтобы показалась аватарка поражения и только потом показываю результаты
        if (!user.data.battle.live || (enemy && !enemy.data.battle.live)) {
            setTimeout(function() {
                callback();
            }, 1500);
        } else {
            callback();
        }
    },
    /**
     * Обработчик окончания боевой анимации 
     */
    onAfterAnimation: function(anim) {
        var me = this,
            effect, u,
            _applyEffect = function(u, data, effect) {
                var timed = Ext.clone(u.data.timed),
                    aura = Ext.clone(u.data.aura),
                    stats = Ext.clone(u.data.stats),
                    battle = Ext.clone(u.data.battle);
                Ext.Array.each(effect, function(e) {
                    if (e.stat) {
                        timed[e.stat][0] = e.rest;
                        timed[e.stat][1] = e.max;
                    }
                    if (e.aura) {
                        // ищу в изменениях данные по ауре
                        var found, changes, auraInfo;
                        if (me.changes[u.data.battle.ekey]) {
                            changes = me.changes[u.data.battle.ekey][me.changes[u.data.battle.ekey].length - 1];
                            if (changes.aura) {
                                for (var j = 0; j < changes.aura.length && !found; j++) {
                                    if (changes.aura[j][0] == e.aura) {
                                        found = true;
                                        aura = changes.aura;
                                        // проверяю влияет ли она на статы. и если влияет - обновляю их
                                        auraInfo = ExGods.ref('battle_aura|' + e.aura);
                                        if (auraInfo && auraInfo.params.stats) {
                                            Ext.Array.each(auraInfo.params.stats, function(s) {
                                                stats.stats[s.stat] = changes.stats.stats[s.stat];
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (e.die) {
                        battle.live = 0;
                    }
                });
                u.set({
                    timed: timed,
                    aura: aura,
                    stats: stats,
                    battle: battle
                });
                Ext.getCmp('battle-roller').setState();
            };
        // визуализирую изменения в данных игрока после анимации
        if (anim.data.effect) {
            if (anim.data.effect.u || anim.data.effect.u1) {
                effect = anim.data.effect.u || anim.data.effect.u1;
                if (anim.source == 'me') {
                    u = me.getBattleUser(me.user.getBattleEkey());
                } else if (anim.source == 'enemy') {
                    u = me.getBattleEnemy();
                }
                if (u) {
                    _applyEffect(u, me.battle.list.getByKey(u.data.battle.ekey), effect);
                }
            }
            if (anim.data.effect.u2) {
                effect = anim.data.effect.u2;
                if (anim.dest == 'me') {
                    u = me.getBattleUser(me.user.getBattleEkey());
                } else if (anim.dest == 'enemy') {
                    u = me.getBattleEnemy();
                }
                if (u) {
                    _applyEffect(u, me.battle.list.getByKey(u.data.battle.ekey), effect);
                }
            }
        }
        if (anim.enemy_hint && anim.enemy_anim) {
            ExGods.app.getHintsController().showHints(anim.enemy_hint);
        }
        if (anim.self_hint && anim.self_anim) {
            ExGods.app.getHintsController().showHints(anim.self_hint);
        }
    },
    showHint: function(key) {
        var hint = this.battle.hints[key];
        if (hint)  {
            ExGods.app.getHintsController().showHints(hint);
        }
        
    },
    getResources: function() {
        var me = this,
            images,
            shapes = [
                'battle_die_shape',
                'no_enemy_shape'
            ];
        images = [
            '/battle/roller/start.png',
            '/battle/roller/loop.png',
            '/battle/roller/finish.png',
            '/battle/frm_flash.png'
        ];
        Ext.Array.each(shapes, function(key) {
            var shape = ExGods.references.get('constants').get(key);
            if (shape) {
                info = ExGods.references.get('user_shape').getByKey(shape.value);
                if (info) {
                    images.push(info.battle);
                }
            }
        });
        me.allies.each(function(user) {
            images.push(user.getBattleAvatar());
            images.push(user.getThumb());
            if (user.data.aura) {
                for (var i = 0; i < user.data.aura.length; i++) {
                    images.push((ExGods.ref('battle_aura|' + user.data.aura[i][0]).params.images.small || ExGods.ref('battle_aura|' + user.data.aura[i][0]).params.images.icon));
                }
            }
        });
        me.enemies.each(function(user) {
            images.push(user.getBattleAvatar());
            images.push(user.getThumb());
            if (user.data.aura) {
                for (var i = 0; i < user.data.aura.length; i++) {
                    images.push((ExGods.ref('battle_aura|' + user.data.aura[i][0]).params.images.small || ExGods.ref('battle_aura|' + user.data.aura[i][0]).params.images.icon));
                }
            }
        });
        Ext.Array.each(me.battle.state.av_kick || [], function(item) {
            var info = ExGods.ref('battle_turn|' + item.name);
            if (info && info.desc && info.desc.images) {
                Ext.Object.each(info.desc.images, function(k, v) {
                    images.push(v);
                });
            }
        });
        Ext.Array.each(me.battle.state.av_prep || [], function(item) {
            var info = ExGods.ref('battle_prep|' + item.name);
            if (info && info.desc && info.desc.images) {
                Ext.Object.each(info.desc.images, function(k, v) {
                    images.push(v);
                });
                
            }
        });
        return {
            images: images
        };
    },
    /**
     * Сортировка участников боя. Сперва идут пары, потом беспарные участники
     */
    sortMembers: function(o1, o2) {
        var me = this,
            _pairIndex = function(obj) {
                var index = 0;
                for (var key in me.battle.pairs) {
                    if (me.battle.pairs[key]) {
                        if (key == obj.getBattleEkey() || me.battle.pairs[key] == obj.getBattleEkey()) {
                            return index;
                        }
                        index++;
                    }
                }
                if (!obj.isLiveInBattle()) {
                    return 1000;
                } else {
                    return index;
                }
            };
        return _pairIndex(o1) - _pairIndex(o2);
    }
});

/**
 * Фреймовая анимация
 */
Ext.define('ExGods.view.FramesAnim', {
    // cfg
    renderTo: null,
    images: [],
    frames: [],
    fps: 25,
    flipped: false,
    infinite: false,
    inProgress: false,
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        Ext.apply(me, config || {});
        me.init();
        me.onInit();
    },
    init: function() {
        var me = this,
            ct = Ext.get(me.renderTo);
        ct.insertHtml('beforeEnd', '<div class="frame ' + (me.flipped ? 'flip-h' : '') + '" style="background-repeat: no-repeat; position: absolute;"></div>');
        me.el = Ext.get(ct.down('.frame'));
        me.ctWidth = ct.getWidth();
        me.ctHeight = ct.getHeight();
    },
    start: function() {
        var me = this,
            intervalId;
        if (me.frames && me.frames.length && me.images && me.images.length) {
            me.inProgress = true;
            me.el.applyStyles({
                backgroundImage: 'url(' + (/^http/.test(me.images[0]) ? me.images[0] : IMAGE_URL + me.images[0]) + ')'
            });
            me.frameIndex = 0;
            me.showFrame(me.frameIndex);
            intervalId = setInterval(function() {
                if (me.frames[++me.frameIndex]) {
                    me.showFrame(me.frameIndex);
                } else if (me.infinite) {
                    me.frameIndex = 0;
                } else {
                    clearInterval(intervalId);
                    me.finish();
                }
            }, 1000 / me.fps);
            me.onStart();
        } else {
            me.onStart();
            me.finish();
        }
    },
    finish: function() {
        var me = this;
        me.inProgress = false;
        me.el.remove();
        delete me.el;
        me.onFinish();
    },
    showFrame: function(index) {
        var me = this,
            frameData = me.frames[index],
            prevData = me.frames[index - 1],
            styles = {};
        // выставляю размер фрейма если изменился
        if (!prevData || frameData[2] != prevData[2] || frameData[3] != prevData[3]) {
            styles = {
                width: frameData[2] + 'px',
                height: frameData[3] + 'px'
            };
        }
        // позиционирую если изменились координаты
        if (!prevData || frameData[5] != prevData[5] || frameData[6] != prevData[6]) {
            styles.top = (-frameData[6]) + 'px';
            if (me.flipped) {
                styles.right = (-frameData[5]) + 'px';
            } else {
                styles.left = (-frameData[5]) + 'px';
            }
        }
        me.onProgress(index);
        styles['background-position'] = (-frameData[0]) + 'px ' + (-frameData[1]) + 'px';
        if (me.el && me.el.dom) {
            me.el.applyStyles(styles);
        }
    },
    onInit: function() {},
    //
    onStart: function() {},
    //
    onFinish: function() {},
    //
    /**
     * срабатывает на каждую итерацию анимации
     */
    onProgress: function(index) {}
});
//

/**
 * Панель боевой анимации
 */
Ext.define('ExGods.view.battle_new.AnimationPanel', {
    extend: Ext.Component,
    side: 'left',
    // 'left' or 'right'
    cls: 'battle-anim-panel',
    /**
     * @cfg {Array} Список статов, эффект которых не нужно показывать. Например, ["mp", "hp"]
     */
    hiddenEffects: [],
    initComponent: function() {
        var me = this;
        me.style = {
            position: 'absolute',
            top: 0,
            height: '239px',
            width: '217px'
        };
        me.style[me.side] = '0';
        me.renderTpl = [
            '<div class="anim-panel" style="width:217px; height:239px; position: relative;"></div>',
            '<div class="text-img" style="top: ' + ExGods.ref('constants|bat_anim_text_y_from').value + 'px' + '"></div>'
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
    },
    /**
     * Запускает анимацию
     */
    runAnim: function(anim, target, callback) {
        var me = this,
            el,
            started = 0,
            stopped = 0,
            _afterAnim = function() {
                if (++stopped == started) {
                    callback();
                }
            };
        if (anim.type != 'effect') {
            started++;
            me.runImageAnimation(anim, target, function() {
                _afterAnim();
            });
            if (anim.data.effect) {
                started++;
                me.runEffectAnimation(target == 'self' ? anim.data.effect.u || anim.data.effect.u1 : anim.data.effect.u2, anim.data.result, function() {
                    _afterAnim();
                });
            }
        } else {
            started++;
            me.runEffectAnimation(target == 'self' ? anim.data.effect.u || anim.data.effect.u1 : anim.data.effect.u2, anim.data.result, function() {
                _afterAnim();
            });
        }
        if (!started) {
            callback();
        }
    },
    /**
     * @private
     */
    runImageAnimation: function(anim, target, callback) {
        var me = this,
            ss, bm, animData, animName,
            animationOn = typeof ExGods.app.user.getSetting('animation_on') == 'undefined' || ExGods.app.user.getSetting('animation_on') == "1",
            _animateFrame = function(img) {
                var time1 = ExGods.ref('constants|bat_anim_frame_time1').value,
                    time2 = ExGods.ref('constants|bat_anim_frame_time2').value,
                    getEl = function() {
                        return me.side == 'left' ? Ext.select('#battle-avatar .avatar-frame') : Ext.select('#battle-enemy-avatar .avatar-frame');
                    },
                    el = getEl();
                if (!el)  {
                    return;
                }
                
                el.applyStyles({
                    'background-image': 'url(' + IMAGE_URL + anim.images.aframe + ')'
                });
                el.animate({
                    duration: time1,
                    to: {
                        opacity: 1
                    },
                    callback: function() {
                        setTimeout(function() {
                            el = getEl();
                            if (!el)  {
                                return;
                            }
                            
                            el.animate({
                                duration: time2,
                                to: {
                                    opacity: 0
                                }
                            });
                        }, 1500 - time1 - time2);
                    }
                });
            },
            _animateTextImg = function(img) {
                var getEl = function() {
                        try {
                            return Ext.get(me.getEl().select('.text-img').item(0));
                        } catch (err) {}
                    };
                var el = getEl();
                if (el) {
                    el.applyStyles({
                        'background-image': 'url(' + IMAGE_URL + img + ')',
                        'opacity': 0
                    });
                    el.animate({
                        duration: ExGods.ref('constants|bat_anim_text_time1').value,
                        from: {
                            opacity: 0,
                            top: ExGods.ref('constants|bat_anim_text_y_from').value + 'px'
                        },
                        to: {
                            opacity: 1,
                            top: ExGods.ref('constants|bat_anim_text_y_to').value + 'px'
                        },
                        callback: function() {
                            el = getEl();
                            if (!el)  {
                                return;
                            }
                            
                            el.animate({
                                duration: ExGods.ref('constants|bat_anim_text_time2').value,
                                from: {
                                    opacity: 1
                                },
                                to: {
                                    opacity: 0
                                }
                            });
                        }
                    });
                }
            };
        animName = target == 'self' ? anim.self_anim : anim.enemy_anim;
        animTextImg = target == 'self' ? anim.self_text_img : anim.enemy_text_img;
        animData = ExGods.ref('battle_animations|' + animName);
        if (animData) {
            var spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                    images: animData.images,
                    frames: animData.frames,
                    renderTo: me.getEl().down('.anim-panel'),
                    flipped: (me.side == 'left' && animData.mirror_left || me.side == 'right' && animData.mirror_right)
                });
            if (animationOn) {
                spriteSheet.start();
            }
            if (anim.images && anim.images.aframe) {
                _animateFrame(anim.images.aframe);
            }
            if (animTextImg) {
                _animateTextImg(animTextImg);
            }
            setTimeout(function() {
                callback();
            }, 1500);
        } else // считаем, что анимация длится до 1.5 секунд
        {
            callback();
        }
    },
    runEffectAnimation: function(effect, result, callback) {
        var me = this,
            started = 0,
            _plusOrMinusColor = function(effect) {
                var arithmetic, parametr,
                    indent = '0px';
                if (result == 'add' || effect.make < 0)  {
                    arithmetic = 'plus';
                }
                else {
                    arithmetic = 'minus';
                    indent = '-18px';
                }
                if (effect.stat == 'hp')  {
                    parametr = 'health';
                }
                else if (effect.stat == 'mp') {
                    parametr = 'mana';
                    indent = '-36px';
                } else  {
                    parametr = 'shield';
                }
                
                return {
                    arith: arithmetic,
                    param: parametr,
                    indent: indent
                };
            },
            _showEffect = function(e, callback) {
                var value = Math.abs(e.make || 0);
                var pomColor = _plusOrMinusColor(e);
                if (!value || Ext.Array.indexOf(me.hiddenEffects, e.stat) != -1) {
                    callback();
                    return;
                }
                var div_element = me.getEl().insertHtml('beforeEnd', ExGods.util.Sprite.printSprite(value, IMAGE_URL + '/battle/numbers/num.png', {
                        width: 15,
                        height: 24,
                        indent: pomColor.indent,
                        cls: 'battle_numbers ' + pomColor.arith + ' ' + pomColor.param
                    }));
                Ext.get(div_element).animate({
                    duration: 1800,
                    to: {
                        top: 40,
                        opacity: 1
                    }
                }).animate({
                    duration: 200,
                    to: {
                        opacity: 0
                    },
                    listeners: {
                        afteranimate: function() {
                            if (this.target && this.target.target) {
                                this.target.target.remove();
                            }
                        }
                    }
                });
                setTimeout(function() {
                    callback();
                }, 500);
            },
            _afterEffectShow = function() {
                if (--started == 0) {
                    callback();
                } else {
                    _showEffect(queue.shift(), _afterEffectShow);
                }
            },
            queue = [];
        Ext.Array.each(effect, function(e) {
            if (e.stat) {
                if (started++) {
                    queue.push(e);
                } else {
                    _showEffect(e, _afterEffectShow);
                }
            }
        });
        if (!started) {
            callback();
        }
    },
    /**
     * Метод для теста анимации
     */
    testSpriteSheet: function(images, frames) {
        var me = this,
            spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                images: images,
                frames: frames,
                renderTo: me.getEl().down('.anim-panel'),
                flipped: me.side != 'left'
            });
        spriteSheet.start();
    },
    /**
     * Ресурсы вью предзагрузка
     * Все ресурсы анимации уже загружены другим механизмом.
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Управляет анимацией в бою
 */
Ext.define('ExGods.controller.battle.Animation', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BattleAnimation:'
    },
    refs: [
        {
            ref: 'battleContainer',
            selector: '#battle-container'
        }
    ],
    views: [
        'ExGods.view.battle_new.AnimationPanel'
    ],
    init: function() {
        var me = this;
        me.app.getChatConnection().on({
            command_battle_log: function(cn, message) {
                if (me.enabled) {
                    me.onBattleLogMessage(message.body.data);
                } else {
                    me.hasUnprocessLogMessages.push(message.body.data);
                }
            },
            scope: me
        });
        me.control({
            '#battle-container': {
                render: me.onContainerRender,
                destroy: me.onContainerDestroy
            },
            '#battle-header': {
                showbattle: me.onBattleView,
                showgroup: me.onGroupView
            },
            'battle_avatar': {
                viewmodechange: me.onBattleAvatarModeChange
            }
        });
        me.battle = me.app.getController('battle.Battle');
        me.battleView = me.app.getController('battle.BattleView');
        me.battleView.onRender(function() {
            me.onBattleViewRender();
        });
        me.battleView.onDestroy(function() {
            me.onBattleViewDestroy();
        });
        me.hasUnprocessLogMessages = [];
        me.resurections = [];
        me.callParent();
    },
    onBattleViewRender: function() {
        var me = this;
        me.startWork(true);
    },
    onBattleViewDestroy: function() {
        var me = this;
        me.startWork(false);
    },
    startWork: function(enabled) {
        var me = this;
        me.resurections = [];
        me.kick_animations = [];
        me.continuing_animations = [];
        me.final_animations = [];
        if (me.enabled !== enabled) {
            me.enabled = enabled;
            if (me.enabled) {
                if (me.hasUnprocessLogMessages.length) {
                    setTimeout(function() {
                        for (var i = 0; i < me.hasUnprocessLogMessages.length; i++) {
                            me.onBattleLogMessage(me.hasUnprocessLogMessages[i]);
                        }
                        me.hasUnprocessLogMessages = [];
                    }, ExGods.ref('constants|bat_anim_first_anim_delay').value);
                }
            }
        }
    },
    onBattleViewNewRound: function(view, round) {
        var me = this,
            user = me.app.getController('battle.BattleView').getBattleUser(me.user.getBattleEkey()),
            enemy = me.app.getController('battle.BattleView').getBattleEnemy();
        me.cur_round = round;
        me.kick_animations = [];
        me.continuing_animations = [];
        me.final_animations = [];
        // запускаю анимацию воскрешения
        if (me.resurections.length) {
            me.animateResurections();
        }
        // запускаю анимации, которые уже пришли для раунда, когда предыдущий еще не отыграл
        if (me.next_round_animations.length) {
            Ext.Array.each(me.next_round_animations, function(anim) {
                me.setAnimationSourceDestInfo(anim);
                if (anim.source == 'me' || anim.source == 'enemy' || anim.dest == 'me' || anim.dest == 'enemy') {
                    me.addAnimation(anim);
                }
            });
            me.next_round_animations = [];
        }
        ExGods.Resources.load(me);
    },
    onBattleLogMessage: function(data) {
        var me = this,
            anim;
        anim = me.processLogMessage(data);
        if (anim) {
            me.loadAnimationResources(anim);
            if (anim.data.result == 'resurect') {
                me.resurections.push(anim);
            } else if (me.battle.state.round != me.cur_round) {
                me.next_round_animations.push(anim);
            } else {
                if (anim.source == 'me' || anim.source == 'enemy' || anim.dest == 'me' || anim.dest == 'enemy') {
                    if (anim.type == 'kick') {
                        me.kick_animations.push(anim);
                    } else if (anim.type == 'continuing') {
                        me.continuing_animations.push(anim);
                    } else {
                        if (me.kick_animations.length && !(anim.type == 'effect' && anim.data.type == 'cost')) {
                            me.final_animations.push(anim);
                        } else {
                            me.addAnimation(anim);
                        }
                    }
                }
            }
        }
    },
    /**
     * Выставление источника / получателя анимации
     */
    setAnimationSourceDestInfo: function(anim) {
        var me = this,
            user = me.app.getController('battle.BattleView').getBattleUser(me.user.getBattleEkey()),
            enemy = me.app.getController('battle.BattleView').getBattleEnemy();
        if (anim.data.u) {
            if (anim.data.u[2] == user.getBattleEkey()) {
                anim.source = 'me';
                anim.dest = 'enemy';
            } else if (enemy && anim.data.u[2] == enemy.getBattleEkey()) {
                anim.source = 'enemy';
                anim.dest = 'me';
            } else {}
        } else // ignore
        {
            if (anim.data.u1 && anim.data.u1[2] == user.getBattleEkey()) {
                anim.source = 'me';
                if (anim.data.u2[2] == user.getBattleEkey()) {
                    anim.dest = 'me';
                } else if (enemy && anim.data.u2[2] == enemy.getBattleEkey()) {
                    anim.dest = 'enemy';
                } else {
                    anim.dest = 'other';
                }
            } else if (anim.data.u1 && enemy && anim.data.u1[2] == enemy.getBattleEkey()) {
                anim.source = 'enemy';
                if (anim.data.u2[2] == enemy.getBattleEkey()) {
                    anim.dest = 'enemy';
                } else if (anim.data.u2[2] == user.getBattleEkey()) {
                    anim.dest = 'me';
                } else {
                    anim.dest = 'other';
                }
            } else {
                anim.source = 'other';
                if (anim.data.u2) {
                    if (anim.data.u2[2] == user.getBattleEkey()) {
                        anim.dest = 'me';
                    } else if (enemy && anim.data.u2[2] == enemy.getBattleEkey()) {
                        anim.dest = 'enemy';
                    } else {
                        anim.dest = 'other';
                    }
                } else {
                    anim.dest = 'other';
                }
            }
        }
    },
    processLogMessage: function(data) {
        var me = this,
            anim = {
                data: data,
                images: {}
            },
            ref_data;
        me.setAnimationSourceDestInfo(anim);
        if (data.turn_name) {
            anim.type = 'kick';
        } else if (data.prepare_name) {
            anim.type = 'instant';
        } else if (data.action_id) {
            anim.type = 'action';
        } else if (data.continuing_id) {
            anim.type = 'continuing';
        } else if (data.effect) {
            anim.type = 'effect';
        }
        if (anim.type == 'kick') {
            ref_data = ExGods.ref('battle_turn|' + anim.data.turn_name).desc || {};
            anim.images = ref_data.images;
        } else if (anim.type == 'instant') {
            ref_data = ExGods.ref('battle_prep|' + data.prepare_name) || {};
            anim.images = ref_data.desc ? ref_data.desc.images : {};
            ref_data = ref_data.animation || {};
        } else if (anim.type == 'action') {
            ref_data = ExGods.ref('battle_actions|' + data.action_id).desc || {};
            anim.images = {
                aframe: ref_data.aframe
            };
        } else if (anim.type == 'continuing') {
            ref_data = ExGods.ref('battle_continuing|' + data.continuing_id).desc || {};
            anim.images = {
                aframe: ref_data.animation_frame
            };
        }
        if (ref_data) {
            if (ref_data.a_self && ref_data.a_self[anim.data.result]) {
                anim.self_anim = ref_data.a_self[anim.data.result].name;
                anim.self_text_img = ref_data.a_self[anim.data.result].image;
                anim.self_hint = ref_data.a_self[anim.data.result].hint;
            }
            if (ref_data.a_enemy && ref_data.a_enemy[anim.data.result]) {
                anim.enemy_anim = ref_data.a_enemy[anim.data.result].name;
                anim.enemy_text_img = ref_data.a_enemy[anim.data.result].image;
                anim.enemy_hint = ref_data.a_enemy[anim.data.result].hint;
            }
        }
        // для удара по самому себе (data.u1 == data.u2) убираю u2 из эффекта
        if (anim.data.effect && anim.data.effect.u2 && anim.data.u1 && anim.data.u2 && anim.data.u1[2] == anim.data.u2[2]) {
            anim.data.effect.u1 = anim.data.effect.u2;
            anim.data.effect.u2 = undefined;
        }
        return anim;
    },
    /**
     * @private Подгрузка ресурсов анимации
     */
    loadAnimationResources: function(anim, callback) {
        var me = this,
            images = [],
            data,
            animOn = ExGods.app.user.getSetting('animation_on'),
            callbackInner = function() {
                anim.resource_loaded = true;
                // ставлю метку, что ресурсы анимации загружены
                if (callback) {
                    callback();
                }
            };
        if (typeof animOn == 'undefined' || animOn == "1") {
            // подгружаю только если анимация включена
            if (anim.self_anim) {
                data = ExGods.ref('battle_animations|' + anim.self_anim);
                images = images.concat(data.images);
                images.push(anim.self_text_img);
            }
            if (anim.enemy_anim) {
                data = ExGods.ref('battle_animations|' + anim.enemy_anim);
                images = images.concat(data.images);
                images.push(anim.enemy_text_img);
            }
            ExGods.Resources.loadImages(images, callbackInner);
        } else {
            callbackInner();
        }
    },
    /**
     * @private Проверяет, что все ресурсы анимации загружены.
     * Возможная задержка вызова callback до 1 секунды
     */
    checkAnimationResources: function(anim, callback) {
        var me = this,
            times = 0,
            maxTimes = 10,
            interval;
        callback = callback || Ext.emptyFn;
        if (anim.resource_loaded) {
            callback();
        } else {
            interval = setInterval(function() {
                if (anim.resource_loaded || ++times >= 10) {
                    callback();
                    clearInterval(interval);
                }
            }, 100);
        }
    },
    /**
     * Добавляет анимацию в очередь и запускает 
     */
    addAnimation: function(anim) {
        var me = this;
        /***/
        me.log('Добавляю анимацию в очередь выполнения ' + anim.type, anim);
        me.queue = me.queue || [];
        if (Ext.isArray(anim)) {
            me.queue = me.queue.concat(anim);
        } else {
            me.queue.push(anim);
        }
        me.start();
    },
    /**
     * Запуск анимаций
     */
    start: function() {
        var me = this,
            _runAnim = function() {
                if (me.queue.length) {
                    var anim = me.queue.shift();
                    me.checkAnimationResources(anim, function() {
                        me.runAnim(anim, function() {
                            try {
                                /***/
                                me.fireEvent('afteranim', anim);
                                me.battleView.onAfterAnimation(anim);
                            } catch (e) {
                                /***/
                                me.log('error', 'afteranim event error ', e);
                            }
                            if (anim.callback) {
                                try {
                                    anim.callback();
                                } catch (e) {
                                    /***/
                                    me.log('error', 'anim callback error ', e);
                                }
                            }
                            /****/
                            me.log('Анимация выполнена ' + anim.type, anim);
                            _runAnim();
                        });
                    });
                } else {
                    /***/
                    me.log('Останавливаю очередь анимаций');
                    delete me.started;
                    me.fireEvent('animation_finish');
                }
            };
        if (!me.started) {
            /***/
            me.log('Запускаю очередь анимаций');
            me.started = true;
            _runAnim();
        }
    },
    /**
     * @private
     */
    runAnim: function(anim, callback) {
        var me = this,
            ref_data,
            started = 0,
            _afterAnim = function() {
                if (--started > 0) {} else //
                {
                    callback();
                }
            };
        /***/
        me.log('Выполняю анимацию ' + anim.type, anim);
        callback = callback || Ext.emptyFn;
        if (anim.type == 'effect') {
            if ((anim.data.effect.u || anim.data.effect.u1) && me.canShowAnimation('self', anim)) {
                if (anim.source == 'me') {
                    me.leftPanel.runAnim(anim, 'self', _afterAnim);
                    started++;
                } else if (anim.source == 'enemy') {
                    me.rightPanel.runAnim(anim, 'self', _afterAnim);
                    started++;
                }
            }
            if (anim.data.effect.u2 && me.canShowAnimation('enemy', anim)) {
                if (anim.dest == 'me') {
                    me.leftPanel.runAnim(anim, 'enemy', _afterAnim);
                    started++;
                } else if (anim.dest == 'enemy') {
                    me.rightPanel.runAnim(anim, 'enemy', _afterAnim);
                    started++;
                }
            }
        } else {
            if (anim.self_anim && me.canShowAnimation('self', anim)) {
                if (anim.source == 'me') {
                    me.leftPanel.runAnim(anim, 'self', _afterAnim);
                    started++;
                } else if (anim.source == 'enemy') {
                    me.rightPanel.runAnim(anim, 'self', _afterAnim);
                    started++;
                }
            }
            if (anim.enemy_anim && me.canShowAnimation('enemy', anim)) {
                if (anim.dest == 'me') {
                    me.leftPanel.runAnim(anim, 'enemy', _afterAnim);
                    started++;
                } else if (anim.dest == 'enemy') {
                    me.rightPanel.runAnim(anim, 'enemy', _afterAnim);
                    started++;
                }
            }
        }
        if (!started) {
            callback();
        }
    },
    onContainerRender: function() {
        var me = this,
            container = me.getBattleContainer();
        /****/
        me.log('Контейнер боя создан - создаю панели для анимации');
        me.leftPanel = Ext.create('ExGods.view.battle_new.AnimationPanel', {
            autoShow: false,
            renderTo: container.el
        });
        ExGods.Resources.load(me.leftPanel, function() {
            me.leftPanel.show();
        });
        me.rightPanel = Ext.create('ExGods.view.battle_new.AnimationPanel', {
            renderTo: container.el,
            side: 'right',
            autoShow: false,
            hiddenEffects: [
                'mp'
            ]
        });
        ExGods.Resources.load(me.rightPanel, function() {
            me.rightPanel.show();
        });
        me.next_round_animations = [];
        me.kick_animations = [];
        me.continuing_animations = [];
        me.cur_round = me.battle.state.round;
    },
    onContainerDestroy: function() {
        var me = this;
        /****/
        me.log('Контейнер боя удалён. Удаляю панели анимации');
        me.leftPanel.destroy();
        me.rightPanel.destroy();
    },
    onBattleAvatarModeChange: function(avatar, isInfoMode) {
        var me = this,
            panel;
        /****/
        me.log('Режим отображения аватара изменился - скрываю/показываю панель анимации');
        if (avatar.isEnemy) {
            panel = me.rightPanel;
        } else {
            panel = me.leftPanel;
        }
        if (isInfoMode) {
            panel.hide();
        } else {
            panel.show();
        }
    },
    onBattleView: function() {
        var me = this,
            uAva = Ext.getCmp('battle-avatar'),
            eAva = Ext.getCmp('battle-enemy-avatar');
        if (!uAva.isInfo) {
            me.leftPanel.show();
        }
        if (!eAva.isInfo) {
            me.rightPanel.show();
        }
    },
    onGroupView: function() {
        var me = this;
        me.leftPanel.hide();
        me.rightPanel.hide();
    },
    /**
     * Анимация воскрешения
     */
    animateResurections: function() {
        var me = this,
            enemy = me.battleView.getBattleEnemy(),
            u_ekey = me.user.getBattleEkey(),
            e_ekey = enemy ? enemy.getBattleEkey() : null,
            animated = [],
            anim;
        Ext.Array.each(me.resurections, function(anim) {
            me.setAnimationSourceDestInfo(anim);
            if (anim.source == 'me' || anim.source == 'enemy') {
                me.addAnimation(anim);
                animated.push(anim);
            }
        });
        me.resurections = Ext.Array.difference(me.resurections, animated);
    },
    /**
     * Анимация удара 
     * @param index - 1ый или 2ой удар
     */
    animateKick: function(index, callback) {
        var me = this,
            myKickHasNegativeMake = false;
        Ext.Array.each(me.kick_animations, function(a) {
            if (a.soruce == 'me' && a.data.effect && a.data.effect.u1) {
                Ext.Array.each(a.data.effect.u1, function(effect) {
                    if (effect.make < 0) {
                        myKickHasNegativeMake = true;
                    }
                });
            }
        });
        // определяю последовательность ударов:
        // последним проигрывается удар, у которого есть отрицательный make в эффекте, иначе "мой удар", затем "удар врага"
        if (index == 1 && !myKickHasNegativeMake || index == 2 && myKickHasNegativeMake) {
            me.animateMyKick(callback);
        } else {
            me.animateEnemyKick(callback);
        }
    },
    animateMyKick: function(callback) {
        var me = this,
            anims = [],
            started = 0;
        /***/
        me.log('анимирую мой удар');
        try {
            Ext.Array.each(me.kick_animations, function(a) {
                if (a.source == 'me') {
                    anims.push(a);
                }
            });
            if (anims.length) {
                me.animChoice(anims[0], function() {
                    Ext.Array.each(anims, function(anim) {
                        anim.callback = function() {
                            if (--started == 0) {
                                callback();
                            }
                        };
                        started++;
                        me.addAnimation(anim);
                    });
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', 'Ошибка при анимации моего удара', e);
            callback();
        }
    },
    animateEnemyKick: function(callback) {
        var me = this,
            anims = [],
            started = 0;
        /***/
        me.log('анимирую удар врага');
        try {
            Ext.Array.each(me.kick_animations, function(a) {
                if (a.source == 'enemy') {
                    anims.push(a);
                }
            });
            if (anims.length) {
                me.animChoice(anims[0], function() {
                    Ext.Array.each(anims, function(anim) {
                        anim.callback = function() {
                            if (--started == 0) {
                                callback();
                            }
                        };
                        started++;
                        me.addAnimation(anim);
                    });
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', 'Ошибка при анимации удара врага', e);
            callback();
        }
    },
    animateMyContinuing: function(callback) {
        var me = this,
            anims = [],
            started = 0;
        /***/
        me.log('анимирую моё длящееся');
        try {
            Ext.Array.each(me.continuing_animations, function(a) {
                if (a.dest == 'me') {
                    anims.push(a);
                }
            });
            if (anims.length) {
                Ext.Array.each(anims, function(anim) {
                    anim.callback = function() {
                        if (--started == 0) {
                            callback();
                        }
                    };
                    started++;
                    me.addAnimation(anim);
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', 'Ошибка при анимации моего длящегося', e);
            callback();
        }
    },
    animateEnemyContinuing: function(callback) {
        var me = this,
            anims = [],
            started = 0;
        /***/
        me.log('анимирую длящееся врага');
        try {
            Ext.Array.each(me.continuing_animations, function(a) {
                if (a.dest == 'enemy') {
                    anims.push(a);
                }
            });
            if (anims.length) {
                Ext.Array.each(anims, function(anim) {
                    anim.callback = function() {
                        if (--started == 0) {
                            callback();
                        }
                    };
                    started++;
                    me.addAnimation(anim);
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', 'Ошибка при анимации вражьего длящегося', e);
            callback();
        }
    },
    animateFinal: function(callback) {
        var me = this,
            started = 0;
        /***/
        me.log('анимирую финальную анимацию раунда');
        try {
            if (me.final_animations.length) {
                Ext.Array.each(me.final_animations, function(anim) {
                    anim.callback = function() {
                        if (--started == 0) {
                            callback();
                        }
                    };
                    started++;
                    me.addAnimation(anim);
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', 'Ошибка при анимации финальной анимации', e);
            callback();
        }
    },
    // обновляет иконки выбранных ударов из анимации
    refreshChoiceFromAnimation: function() {
        var me = this,
            choiceCmpEl = Ext.getCmp('battle-choice').getEl(),
            myKickAnimation, enemyKickAnimation, myKickEl, enemyKickEl, kickInfo;
        Ext.Array.each(me.kick_animations, function(a) {
            if (!myKickAnimation && a.source == 'me') {
                myKickAnimation = a;
            } else if (!enemyKickAnimation && a.source == "enemy") {
                enemyKickAnimation = a;
            }
        });
        if (choiceCmpEl) {
            if (myKickAnimation && myKickAnimation.data.turn_name) {
                myKickEl = choiceCmpEl.down('.my-kick');
                kickInfo = ExGods.ref('battle_turn|' + myKickAnimation.data.turn_name);
                if (kickInfo && myKickEl) {
                    myKickEl.setStyle('background-image', 'url(' + IMAGE_URL + kickInfo.desc.images['active'] + ')');
                }
            }
            if (enemyKickAnimation && enemyKickAnimation.data.turn_name) {
                enemyKickEl = choiceCmpEl.down('.enemy-kick');
                kickInfo = ExGods.ref('battle_turn|' + enemyKickAnimation.data.turn_name);
                if (kickInfo && enemyKickEl) {
                    enemyKickEl.setStyle('background-image', 'url(' + IMAGE_URL + kickInfo.desc.images['flip'] + ')');
                }
            }
        }
    },
    // перемещает картинку выбранного удара из слота к аватару
    animChoice: function(anim, callback) {
        var me = this,
            choiceCmpEl = Ext.getCmp('battle-choice') ? Ext.getCmp('battle-choice').getEl() : null,
            started = 0,
            source = anim.source,
            _animChoice = function(target, anim, callback) {
                var kickEl,
                    dest = {
                        y: ExGods.ref('constants|bat_anim_choice2_top').value
                    },
                    animEl;
                if (source == 'me') {
                    kickEl = choiceCmpEl.down('.my-kick');
                } else {
                    kickEl = choiceCmpEl.down('.enemy-kick');
                }
                if ((target == 'self' && source == 'me') || (target == 'enemy' && source == 'enemy')) {
                    dest.x = -272;
                } else {
                    dest.x = 377;
                }
                if (!kickEl) {
                    callback();
                    return;
                }
                animEl = kickEl.parent().insertHtml('afterBegin', '<div style="z-index: 1000; background-image: ' + Ext.String.htmlEncode(kickEl.getStyle('background-image')) + '; left: ' + kickEl.getLocalX() + 'px; top: ' + kickEl.getLocalY() + 'px;"></div>', true);
                kickEl.setStyle('opacity', 0);
                animEl.animate({
                    duration: ExGods.ref('constants|bat_anim_choice2_dur').value,
                    to: {
                        left: dest.x + 'px',
                        top: dest.y + 'px',
                        opacity: ExGods.ref('constants|bat_anim_choice2_opacity').value,
                        width: ExGods.ref('constants|bat_anim_choice2_w').value,
                        height: ExGods.ref('constants|bat_anim_choice2_h').value
                    },
                    listeners: {
                        afteranimate: function() {
                            callback();
                        }
                    }
                });
            },
            _hideChoice = function(callback) {
                var kickEl;
                if (source == 'me') {
                    kickEl = choiceCmpEl.down('.my-kick');
                } else {
                    kickEl = choiceCmpEl.down('.enemy-kick');
                }
                kickEl.animate({
                    duration: 500,
                    from: {
                        opacity: 1
                    },
                    to: {
                        opacity: 0
                    },
                    callback: callback
                });
            },
            _afterAnim = function() {
                if (--started == 0) {
                    callback();
                }
            };
        /***/
        me.log('Анимирую выбор', anim);
        try {
            if (anim.self_anim && me.canShowAnimation('self', anim)) {
                started++;
                _animChoice('self', anim, _afterAnim);
            }
            if (anim.enemy_anim && me.canShowAnimation('enemy', anim)) {
                started++;
                _animChoice('enemy', anim, _afterAnim);
            }
            if (!started) {
                _hideChoice(callback);
            }
        } catch (e) {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Ошибка анимации выбора ' + e);
            callback();
        }
    },
    /**
     * Выполнит функцию после того как текущая очередь анимации опустошится
     */
    onAnimationFinish: function(callback) {
        var me = this;
        if (!me.queue || !me.queue.length) {
            callback();
        } else {
            me.on('animation_finish', callback, me, {
                single: true
            });
        }
    },
    /**
     * @private Проверка "показывать ли анимацию"
     * @param target String Принимает значения "self" or "enemy"
     * @param anim
     */
    canShowAnimation: function(target, anim) {
        var me = this,
            u;
        if (target == 'self' && anim.source == 'me' || target == 'enemy' && anim.dest == 'me') {
            u = me.battleView.getBattleUser(me.user.getBattleEkey());
        } else if (target == 'self' && anim.source == 'enemy' || target == 'enemy' && anim.dest == 'enemy') {
            u = me.battleView.getBattleEnemy();
        }
        return u && u.isLiveInBattle();
    },
    /**
     * Тестовый метод для дизайнеров
     */
    _run_anim: function(side, img_url, data) {
        var me = this,
            panel = side == 'left' ? me.leftPanel : me.rightPanel;
        panel.testSpriteSheet([
            img_url
        ], data);
    },
    getResources: function() {
        var me = this,
            images = [],
            animRef = ExGods.ref('battle_animations'),
            collectTurnImages = function(turnData, arr) {
                if (turnData.desc) {
                    Ext.Object.each(turnData.desc.a_self || {}, function(k, v) {
                        if (v.image) {
                            arr.push(v.image);
                        }
                        if (v.name) {
                            var data = animRef.get(v.name);
                            if (data) {
                                arr.push(data.images[0]);
                            }
                        }
                    });
                    Ext.Object.each(turnData.desc.a_enemy || {}, function(k, v) {
                        if (v.image) {
                            arr.push(v.image);
                        }
                        if (v.name) {
                            var data = animRef.get(v.name);
                            if (data) {
                                arr.push(data.images[0]);
                            }
                        }
                    });
                }
            };
        Ext.Array.each(me.battle.state.av_kick || [], function(item) {
            var info = ExGods.ref('battle_turn|' + item.name);
            if (info) {
                collectTurnImages(info, images);
            }
        });
        Ext.Array.each(me.battle.state.av_prep || [], function(item) {
            var info = ExGods.ref('battle_prep|' + item.name);
            if (info) {
                collectTurnImages(info, images);
            }
        });
        images.push('battle/numbers/num.png');
        return {
            images: images
        };
    }
});

/**
 * Контроллер, отвечающий за стабильность работы интерфейса боя.
 *
 * @author Oleg M.
 */
Ext.define('ExGods.controller.battle.Stability', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'BattleStability:'
    },
    /**
     * @property {Number} roundDelay
     */
    roundDelay: 30 * 1000,
    init: function() {
        var me = this;
        me.listen({
            controller: {
                '#battle.Battle': {
                    'start': me.onBattleStart,
                    'finish': me.onBattleFinish,
                    'load_round': me.onBattleLoadRound
                }
            }
        });
        me.battle = me.app.getController('battle.Battle');
        me.battleView = me.app.getController('battle.BattleView');
        me.callParent();
    },
    onBattleStart: function() {
        var me = this;
        clearTimeout(me.onRoundTimeout);
        me.onRoundTimeout = null;
    },
    onBattleFinish: function() {
        var me = this;
        clearTimeout(me.onRoundTimeout);
        me.onRoundTimeout = null;
    },
    /**
     * @private Обработчик нового раунда
     */
    onBattleLoadRound: function() {
        var me = this;
        if (me.onRoundTimeout) {
            clearTimeout(me.onRoundTimeout);
            me.onRoundTimeout = null;
        }
        // Запускаю таймаут на проверку правильной работы BattleView.
        // Предполагается, что через <this.roundDelay> секунд View должна корректно завершить предыдущий и начать новый раунд. Если это не так - перезагружаю данные и обновляю View
        me.onRoundTimeout = setTimeout(function() {
            if (me.battleView.cur_round != me.battle.state.round) {
                /***/
                me.log('Текущий раунд устарел, перезагружаю данные и обновляю отображение');
                me.battle.restartBattle();
            }
        }, me.roundDelay);
    }
});

/**
 * Контроллер управления группами чата
 */
Ext.define('ExGods.controller.ChatGroup', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    init: function(app) {
        var me = this;
        me.guild_service = ExGods.Services.get('guilds');
        me.control({
            '#guild-group-messages': {
                render: me.onGuildGroupRender,
                destroy: me.onGuildGroupDestroy
            }
        });
        app.getChatConnection().on({
            command_chat_update_group: me.onChatGroupUpdate,
            scope: me
        });
    },
    onGuildGroupRender: function() {
        var me = this;
        me.guild_service.command('guild_groups', {}, function(data) {
            if (data.group)  {
                me.app.getStore('GuildGroupOnlineList').loadRawData(data.group.users);
            }
            
        });
    },
    onGuildGroupDestroy: function() {
        this.app.getStore('GuildGroupOnlineList').removeAll();
    },
    onChatGroupUpdate: function(chatcn, data) {
        if (data.body.group_info) {
            this.app.getStore('GuildGroupOnlineList').loadRawData(data.body.group_info.users);
        }
    }
});

/**
 * Модель уведомления
 *
 * Поле <code>data</code> имеет следующую структуру:
 *
 *      {
 *          body: <текст_письма>
 *          from: <отправитель>
 *          to: <получатель>
 *      }
 * 
 * <code>state</code> состояния письма:
 *
 * - 1 - новое
 * - 2 - прочитанное
 *
 * <code>snet</code> - если 1, то ставить галочку шаринга в социальных сетях
 */
Ext.define('ExGods.model.Notice', {
    extend: Ext.data.Model,
    idProperty: 'letter_id',
    fields: [
        {
            name: 'data',
            type: 'auto',
            convert: function(v) {
                if (v && v.body) {
                    v.body = ExGods.app.applyTpl(v.body);
                }
                return v;
            }
        },
        {
            name: 'letter_id',
            type: 'int'
        },
        {
            name: 'received',
            type: 'date',
            dateFormat: serverDateTimeFormat
        },
        {
            name: 'snet',
            type: 'int',
            convert: function(v, rec) {
                var data = rec.get('data');
                return data ? data.snet : 0;
            }
        },
        {
            name: 'state',
            type: 'int'
        }
    ]
});

/**
 * Хранилище уведомлений
 */
Ext.define('ExGods.store.Notices', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Notice'
});

/**
 * Табы квестов
 */
Ext.define('ExGods.view.notice.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.noticetabpanel',
    tabUi: 'skintext',
    bodyPadding: '0 10 8 8',
    /**
     * @cfg {Object} messages Данные сообщений
     */
    messages: {},
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {};
        }
        Ext.applyIf(item.tabConfig, {
            xtype: 'noticetab',
            quantityLeft: item.quantityLeft || 0,
            item: item,
            messages: me.messages
        });
        me.callParent(arguments);
    }
});

/**
 * Отображение нового уведомления
 */
Ext.define('ExGods.view.notice.Notice', {
    extend: Ext.panel.Panel,
    alias: 'widget.notice',
    id: 'notice',
    margin: '-3px -3px 0 -3px',
    count: 10,
    /**
     * @cfg {Ext.data.Model} group (required)
     * Группа новых уведомлений
     */
    /**
     * @cfg {ExGods.store.Notices} notices (required)
     * Хранилище новых уведомлений
     */
    /**
     * @cfg {Object} messages Данные сообщений
     */
    messages: {},
    bodyPadding: 0,
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            autoHide: true,
            autoRestorePosition: true,
            padding: '3px 3px 0 0'
        }
    ],
    /**
    *  Количество сторов прототипов, которые необходимо загрузить
     */
    loadings: 0,
    /**
     *  Количество сторов прототипов, которые уже загрузились
     */
    loaded: 0,
    /**
     * @cfg {String} social
     * Название социальной сети
     */
    /**
     * Хранилище "сырых" сообщений, которые еще рано добавлять в стор
     */
    rawMails: [],
    /**
     * Количество сообщений, которые осталось подгрузить до пуша из rawMails
     */
    leftToLoad: 0,
    initComponent: function() {
        var me = this,
            notices = me.store,
            notice = me.store.first();
        me.tpl = [
            '<tpl if="empty">',
            '<p class="central-window-empty">{[this.getEmptyText()]}</div>',
            '<tpl else>',
            '<div class="notice-container">',
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="subject"><h4>{data.subject}</h4></div>',
            '<div class="quest-deco-body">',
            '<div class="narrow-column" style="margin:3px 0 15px 6px">',
            '<div class="quest-giver-border">',
            '<div class="quest-giver-image" style="background-image:url({[IMAGE_URL]}{data.image})"></div>',
            '</div>',
            '</div>',
            '<div class="wide-column">',
            '<tpl if="data.attaches && data.attaches.length">',
            '<div style="min-height: 120px">{[ ExGods.util.Helper.processTextWithSmiles( ExGods.app.applyTpl(values.data.body, values) ) ]}</div>',
            '<div class="info-box">',
            '<div class="info-box-bg"></div>',
            '<div class="info-box-tl"></div>',
            '<div class="info-box-t"></div>',
            '<div class="info-box-tr"></div>',
            '<div class="info-box-l"></div>',
            '<div class="info-box-r"></div>',
            '<div class="info-box-bl"></div>',
            '<div class="info-box-b"></div>',
            '<div class="info-box-br"></div>',
            '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_award'] + '"></div>',
            '<div class="info-box-content info-box-rewards">',
            '<ul>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '</ul>',
            '</div>',
            '</div>',
            '<tpl else>',
            '<div style="min-height: 250px">{[ ExGods.util.Helper.processTextWithSmiles( ExGods.app.applyTpl(this.clearDirections(values.data.body), values) ) ]}</div>',
            '</tpl>',
            '<div id="checkbox-place"></div>',
            '<div id="button-place"></div>',
            '</div>',
            '</div>',
            '</div>',
            '</div>',
            '</tpl>',
            {
                getEmptyText: function() {
                    return ExGods.ref('message_client|emptynotices');
                },
                clearDirections: function(text) {
                    return text.replace(/\[#\s([\w\d-_]+)\s#\]/ig, '');
                }
            }
        ] , me.count = parseInt(ExGods.ref('constants').get('max_letter_count').value);
        me.callParent();
        me.on('afterrender', function() {
            if (me.notice) {
                me.getRewards();
            }
        });
        me.on('afterlayout', function() {
            me.scroller.onResize();
        });
    },
    /**
     * Отображает первое (раннее) событие в очереди
     */
    showNext: function(callback) {
        var me = this,
            notice = me.store.first(),
            new_count = parseInt(me.messages.new_count),
            count = me.count;
        //проверяем все ли прототипы загрузились
        if (me.loaded != me.loadings) {
            me.loaded++;
            return;
        }
        if (me.getEl()) {
            me.getEl().unmask();
        }
        if (me.store.count()) {
            var attaches = notice.get('data').attaches;
            me.update(notice.getData());
            me.getRewards();
            // me.checkbox = Ext.widget('checkboxfield', {
            //  name: 'snet',
            //  renderTo:'checkbox-place',
            //  boxLabel: 'Отличная новость',
            //  checked: true,
            //  width: 130
            // });
            Ext.widget({
                xtype: 'textbutton',
                renderTo: 'button-place',
                cls: 'no_border',
                text: (attaches && attaches.length) ? ExGods.getMsgByKey('view_notice_get_attach_text') : ExGods.getMsgByKey('view_notice_read_letter_text'),
                handler: function(button) {
                    me.fireEvent('take', button, me.checkbox);
                }
            });
            if (typeof callback == 'function')  {
                callback();
            }
            
        } else // if (notice.get('snet')) {
        //  me.checkbox.setVisible(true);
        //  me.checkbox.setValue(true);
        // } else {
        //  me.checkbox.setVisible(false);
        //  me.checkbox.setValue(false);
        // }
        {
            if (me.rawMails.length && me.leftToLoad == 0) {
                me.store.loadRawData(me.rawMails);
                me.rawMails = [];
                if (typeof callback == 'function')  {
                    callback();
                }
                
            } else {
                if (me.leftToLoad > 0) {
                    if (me.count < me.leftToLoad) {
                        me.leftToLoad -= me.count;
                    } else {
                        count = me.leftToLoad;
                        me.leftToLoad = 0;
                    }
                }
                me.store.load({
                    params: {
                        start: Math.max(0, new_count - me.count) + 1 + me.rawMails.length,
                        count: count
                    },
                    callback: function(notices) {
                        if (typeof callback == 'function')  {
                            callback();
                        }
                        
                        me.afterNoticeLoad(notices);
                    },
                    scope: me
                });
            }
            
        }
        if (me.rendered) {
            me.scroller.onResize();
        }
    },
    // вызываю пересчет скроллинга после перерисовки контента письма
    /**
     * После загрузки событий просматривает их на наличие незагруженных прототипов
     * и показываем первое событие
     *
     * @param {ExGods.model.Notice[]}
     */
    afterNoticeLoad: function(notices) {
        var me = this,
            i, j,
            protosItem = ExGods.app.getItemPrototypesStore(),
            protosAbility = ExGods.app.getAbilityPrototypesStore(),
            protosFeature = ExGods.app.getFeaturePrototypesStore(),
            itemIds = [],
            abilityIds = [],
            featureIds = [];
        if (me.getEl()) {
            ExGods.util.Helper.maskElement(me.getEl());
        }
        for (i = 0; i < notices.length; i++) {
            var notice = notices[i],
                attaches = notice.get('data').attaches;
            if (attaches.length) {
                for (j = 0; j < attaches.length; j++) {
                    var attach = attaches[j];
                    if (attach.type == 'item' && !protosItem.data.getByKey(parseInt(attach.params.id))) {
                        itemIds.push(parseInt(attach.params.id));
                    }
                    if (attach.type == 'ability' && !protosAbility.data.getByKey(attach.params.id)) {
                        abilityIds.push(attach.params.id);
                    }
                    if (attach.type == 'feature' && !protosFeature.data.getByKey(attach.params.id)) {
                        featureIds.push(attach.params.id);
                    }
                }
            }
        }
        me.loadings = 0;
        if (itemIds.length || abilityIds.length || featureIds.length) {
            me.loaded = 1;
            //один точно должен прогрузиться
            if (itemIds.length)  {
                me.loadings++;
            }
            
            if (abilityIds.length)  {
                me.loadings++;
            }
            
            if (featureIds.length)  {
                me.loadings++;
            }
            
            protosItem.loadNew(itemIds, Ext.Function.bind(me.showNext, me));
            protosAbility.loadNew(abilityIds, Ext.Function.bind(me.showNext, me));
            protosFeature.loadNew(featureIds, Ext.Function.bind(me.showNext, me));
        } else {
            me.loaded = 0;
            //ненадо ждать никого
            if (notices.length) {
                me.showNext();
            } else {
                if (me.getEl()) {
                    me.getEl().unmask();
                }
                me.update({
                    empty: true
                });
                me.doLayout();
            }
        }
    },
    getRewards: function() {
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            rewards = me.store.first().get('data').attaches;
        if (rewards.length) {
            ExGods.app.block();
            ExGods.util.Helper.loadProtosFromStuff(rewards, function() {
                ExGods.app.unblock();
                var rewardsHtml = ExGods.stuff.StuffManager.image(rewards),
                    rewardsEl = document.createElement('div'),
                    ul = me.el && me.el.down('.info-box-rewards ul');
                rewardsEl.innerHTML = rewardsHtml;
                Ext.get(rewardsEl).select('li').addCls('info-box-itembox');
                if (ul) {
                    ul.update(rewardsEl.firstChild.innerHTML);
                    for (var i = rewards.length; i < 7; i++) {
                        ul.insertHtml('beforeEnd', '<li class="info-box-itembox"></li>');
                    }
                }
            });
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.List', {
    extend: Ext.panel.Panel,
    alias: 'widget.baselist',
    itemWidgetName: 'baselistitem',
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            scrollDeltaY: 50,
            autoHide: true,
            autoRestorePosition: true
        }
    ],
    /**
     * true если не надо ставить заглушку
     */
    noEmpty: false,
    emptyTpl: [
        '<div>{text}</div>'
    ],
    emptyData: {
        text: 'empty'
    },
    initComponent: function() {
        var me = this,
            store = me.store,
            items = me.getItems();
        if (!me.items) {
            me.items = [];
        }
        me.items.push({
            xtype: 'container',
            itemId: 'wrap',
            layout: {
                type: 'vbox',
                align: 'stretch'
            },
            items: items
        });
        me.callParent(arguments);
        me.rerender = Ext.Function.createBuffered(me.rerender, 100, me);
        store.on('datachanged', me.rerender, me);
        store.on('update', me.rerender, me);
        me.on('show', me.rerender, me);
    },
    /*
     * прокручивает содержимое до элемента рекорда.
     */
    scrollTo: function(record) {
        var me = this,
            slider = me.down('slider'),
            target = me.getComponent('wrap').getComponent(record.get('proto_id'));
        me.collapseAll();
        if (target) {
            target.expand();
            Ext.Function.createBuffered(function() {
                slider.setValue(slider.maxValue - target.y);
            }, 50)();
        }
    },
    //slider.setValue(slider.maxValue - target.el.getLocalY());
    /*
     * скроллит все вкладки наверх
     */
    scrollToTop: function() {
        this.scroller.scrollToTop();
    },
    /*
     * показывает первую вкладку с верхним положением скролла
     */
    showDefault: function() {
        var me = this;
        me.collapseAll();
        me.scrollToTop();
    },
    /*
     * сворачивает все элементы
     */
    collapseAll: function() {
        var me = this;
        Ext.each(me.getComponent('wrap').items.items, function(item) {
            if (item.isExpanded) {
                item.collapse();
            }
        });
    },
    /*
     * разворачивает все элементы
     */
    expandAll: function() {
        var me = this;
        Ext.each(me.getComponent('wrap').items.items, function(item) {
            if (!item.isExpanded) {
                item.expand();
            }
        });
    },
    /*
     * перерисовывает все итемы внутри панели
     */
    rerender: function() {
        var me = this;
        if (!me.rendered) {
            return;
        }
        me.suspendLayouts();
        me.getComponent('wrap').removeAll();
        me.getComponent('wrap').add(me.getItems());
        me.resumeLayouts(true);
    },
    /**
     * @private
     * добавляет итемы при отрисовке
     */
    getItems: function() {
        var me = this,
            store = me.store,
            items = [];
        if (store.getCount() > 0) {
            store.each(function(record) {
                var item = Ext.apply({
                        xtype: me.itemWidgetConfig.xtype,
                        record: record
                    }, me.itemWidgetConfig);
                items.push(item);
            });
        } else if (!me.noEmpty) {
            items.push({
                xtype: 'component',
                margin: '1px 0 0 0',
                height: 369,
                data: me.emptyData,
                tpl: Ext.create('ExGods.view.Template', me.emptyTpl)
            });
        }
        return items;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var stuff_arr = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            stuff_arr.concat(me.store.data.items[i].data.rewards);
        }
        return {
            stuff: stuff_arr || [],
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.notice.Archive', {
    extend: ExGods.view.List,
    alias: 'widget.noticearchive',
    id: 'notice-archive',
    margin: '-3px -3px 0 -3px',
    count: 5,
    finish: 1,
    start: 1,
    emptyTpl: [
        '<p class="central-window-empty">{text}</p>'
    ],
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            scrollDeltaY: 50,
            autoHide: true,
            autoRestorePosition: true,
            padding: '3px 3px 0 0'
        }
    ],
    /**
     * @cfg {Object} Данные сообщений
     */
    messages: {},
    initComponent: function() {
        var me = this;
        me.itemWidgetConfig = {
            xtype: 'noticelistitem',
            listeners: {
                expand: me.onItemExpand,
                collapse: me.onItemCollapse,
                scope: me
            }
        };
        me.emptyData = {
            text: ExGods.ref('message_client|emptyarchive')
        };
        me.callParent(arguments);
        me.on('render', function() {
            me.loadNotices();
        });
        me.mon(me.store, 'datachanged', function(store) {
            btnPanel = me.getDockedItems('[dock="bottom"]')[0];
            if (store.getCount() > 1 && !btnPanel) {
                me.addDocked({
                    dock: 'bottom',
                    xtype: 'panel',
                    margin: 8,
                    items: [
                        {
                            xtype: 'textbutton',
                            text: ExGods.getMsgByKey('view_notice_archive_deleteall'),
                            id: 'delete-all-notices',
                            cls: 'x-btn-txt-red'
                        }
                    ]
                });
            } else if (store.getCount() <= 1 && btnPanel) {
                me.removeDocked(btnPanel);
            }
        });
        me.on({
            scroll: me.onScroll,
            buffer: 50,
            scope: me
        });
    },
    onItemExpand: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onItemCollapse: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onScroll: function(scroller) {
        var me = this,
            rest_count = me.messages.rest_count;
        if (((scroller && scroller.isBottom()) || !scroller) && me.finish < rest_count) {
            var count = Math.min(me.count, rest_count - me.finish);
            me.loadNotices({
                start: me.finish + 1,
                count: count
            }, me.store.first());
            me.finish += count;
        }
    },
    /**
     * Динамически подгружает сообщения
     *
     * @param {Object} params
     * @param {ExGods.model.Notice} notice
     */
    loadNotices: function(params, notice) {
        var me = this;
        if (!params)  {
            params = {};
        }
        
        Ext.applyIf(params, {
            start: 1,
            count: me.count
        });
        me.store.load({
            params: params,
            addRecords: true,
            scope: me
        });
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        var parent = me.callParent();
        return {
            stuff: [].concat(parent.stuff),
            images: [
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 * Отображение вкладки в виде кнопки-картинки на шкуре
 */
Ext.define('ExGods.view.notice.Tab', {
    extend: ExGods.view.skin.Tab,
    alias: 'widget.noticetab',
    /**
     * @cfg {Object} messages Данные сообщений
     */
    messages: {},
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.counterEl = '';
        // me.btnEl.insertHtml('beforeEnd', '<div class="counter"></div>', true);
        me.item.store.on('datachanged', me.onCountChange, me);
        me.onCountChange();
    },
    onCountChange: function() {
        var me = this,
            numbers = '',
            store = me.item.store,
            param = (me.item.xtype == 'notice') ? 'new_count' : 'rest_count',
            qcont = me.btnEl.down('.quantity-container'),
            count = me.messages[param].toString();
        for (var i = 0; i < count.length; i++) {
            numbers += '<div class="tab-number" style="background-image:url(' + IMAGE_URL + 'quests/tasks_sprite_' + count.charAt(i) + '.png)"></div>';
        }
        if (qcont) {
            qcont.destroy();
        }
        me.btnEl.insertHtml('beforeEnd', '<div class="quantity-container" id="quantity-container" style="left:' + me.quantityLeft + 'px">' + numbers + '</div>');
    }
});

Ext.define('ExGods.view.ListItem', {
    extend: Ext.Component,
    alias: 'widget.baselistitem',
    /*
     * events: 'collapse', 'expand';
     */
    viewChangeSelector: '.view-change-selector',
    isExpanded: false,
    initComponent: function() {
        var me = this;
        me.callParent();
        me.record.listItem = me;
        me.on('afterrender', function() {
            me.el.on('click', function(elem) {
                if (this.getEl().down(me.viewChangeSelector).hasCls('disable'))  {
                    return;
                }
                
                if (me.isExpanded) {
                    me.collapse();
                } else {
                    me.expand();
                }
            }, me, {
                delegate: me.viewChangeSelector
            });
        });
    },
    //возвращает темплейт
    setTpl: function(rawTpl) {
        return Ext.create('ExGods.view.Template', rawTpl);
    },
    //меняет текущее изображение на свернутое изображение
    collapse: function() {
        var me = this;
        me.isExpanded = false;
        me.fireEvent('collapse', me);
    },
    //меняет текущее изображение на развернутое изображение
    expand: function() {
        var me = this;
        me.isExpanded = true;
        me.fireEvent('expand', me);
    }
});

Ext.define('ExGods.view.notice.ListItem', {
    extend: ExGods.view.ListItem,
    alias: 'widget.noticelistitem',
    margin: '0 0 -3px 0',
    initComponent: function() {
        var me = this;
        var expanded = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{data.subject}</h4>',
                '<div class="view-change-selector expanded"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url({[IMAGE_URL]}{data.image})"></div>',
                '</div>',
                '</div>',
                '<div class="wide-column">',
                '<div class="all-text">{[ ExGods.util.Helper.processTextWithSmiles( ExGods.app.applyTpl(this.clearDirections(values.data.body), values) ) ]} </div>',
                '<div id="button-place-{letter_id}"></div>',
                '</div>',
                '</div>',
                {
                    clearDirections: function(text) {
                        return text.replace(/\[#\s([\w\d-_]+)\s#\]/ig, '');
                    }
                }
            ];
        var collapsed = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{data.subject}</h4>',
                '<div class="view-change-selector collapsed"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url({[IMAGE_URL]}{data.image})"></div>',
                '</div>',
                '</div>',
                '<div class="wide-column">',
                '<div class="short-text"><span id="' + me.id + 'text_container" style="display:block">{[ ExGods.util.Helper.processTextWithSmiles( ExGods.app.applyTpl(this.clearDirections(values.data.body), values) ) ]}</span></div>',
                '<div id="button-place-{letter_id}"></div>',
                '</div>',
                '</div>',
                {
                    clearDirections: function(text) {
                        return text.replace(/\[#\s([\w\d-_]+)\s#\]/ig, '');
                    }
                }
            ];
        me.expanded = me.setTpl(expanded);
        me.collapsed = me.setTpl(collapsed);
        me.callParent(arguments);
        me.on('render', function() {
            if (me.record.get('expanded') == true) {
                me.expand();
            } else {
                me.collapse();
            }
            me.el.on('click', function() {
                me.fireEvent('delete', me.record);
            }, me, {
                delegate: '.x-btn-txt'
            });
            //если текст влазит в контейнер .short-text, то ВЫключаем кнопку EXPAND
            if (Ext.get(me.id + 'text_container') && Ext.get(me.id + 'text_container').dom.offsetHeight <= 83) {
                this.getEl().down('.view-change-selector').addCls('disable');
            }
        });
    },
    renderSubmitButton: function() {
        Ext.widget('textbutton', {
            text: ExGods.getMsgByKey('view_notice_listitem_delete'),
            cls: 'x-btn-txt-red no_border',
            margin: '0 0 15 -50',
            renderTo: 'button-place-' + this.record.get('letter_id')
        });
    },
    collapse: function() {
        var me = this;
        me.collapsed.overwrite(me.el, me.record.data);
        me.renderSubmitButton();
        me.record.set('expanded', false);
        me.callParent();
    },
    expand: function() {
        var me = this;
        me.expanded.overwrite(me.el, me.record.data);
        me.renderSubmitButton();
        me.record.set('expanded', true);
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Управление общением пользователя кроме чата:
 * 
 */
Ext.define('ExGods.controller.Communication', {
    extend: ExGodsCore.controller.Base,
    views: [
        'CommonWindow',
        'notice.Archive',
        'notice.Notice',
        'notice.TabPanel',
        'notice.Tab',
        'notice.ListItem'
    ],
    refs: [
        {
            /**
         * @method getCommunicationButton
         * Возвращает кнопку "Общение"
         * @return {ExGods.view.menu.MainMenuButton}
         */
            ref: 'communicationButton',
            selector: '#mainmenu-communication-button'
        },
        {
            /**
         * @method getNotice
         * Возвращает отображение одного (нового) уведомления
         * @return {ExGods.view.notice.Notice}
         */
            ref: 'notice',
            selector: '#notice'
        },
        {
            /**
         * @method getNoticeArchive
         * Возвращает отображение архива уведомления
         * @return {ExGods.view.notice.Archive}
         */
            ref: 'noticeArchive',
            selector: '#notice-archive'
        }
    ],
    init: function(app) {
        var me = this;
        me.service = ExGods.Services.get('messages');
        me.service.on('update', me.onServiceUpdate, me);
        me.control({
            'notice': {
                take: me.onTakeAttachClick
            },
            'noticelistitem': {
                'delete': me.deleteArchiveItem
            },
            '#delete-all-notices': {
                click: me.deleteAll
            }
        });
        // '#notice-archive button[action="clear"]': {
        //  click: me.clearNoticeArchive
        // }
        var icons = ExGods.references.get('images').get('communication_icons').image;
        // хранилище новых уведомлений
        me.newNotices = Ext.create('ExGods.store.Notices', {
            proxy: {
                type: 'ajax',
                url: HOST_URL + '/game.pl?cmd=messages_get_list_new',
                limitParam: false,
                pageParam: false,
                startParam: false,
                reader: {
                    type: 'json',
                    rootProperty: 'letters'
                }
            },
            sorters: [
                {
                    property: 'received',
                    direction: 'ASC'
                },
                {
                    property: 'letter_id',
                    direction: 'ASC'
                }
            ]
        });
        // хранилище архивных уведомлений
        me.archiveNotices = Ext.create('ExGods.store.Notices', {
            proxy: {
                type: 'ajax',
                url: HOST_URL + '/game.pl?cmd=messages_get_list_rest',
                limitParam: false,
                pageParam: false,
                startParam: false,
                reader: {
                    type: 'json',
                    rootProperty: 'letters'
                }
            },
            sorters: [
                {
                    property: 'received',
                    direction: 'DESC'
                },
                {
                    property: 'letter_id',
                    direction: 'DESC'
                }
            ]
        });
        me.newNotices.getProxy().setExtraParam('service_id', me.service.id);
        me.archiveNotices.getProxy().setExtraParam('service_id', me.service.id);
        app.getChatConnection().on({
            command_post: me.onPostCommand,
            //command_contact: me.onContactCommand,
            scope: me
        });
        ExGods.Components.addComponentInitializer('notices', me.initNoticesComponent, me);
    },
    onServiceUpdate: function() {
        var me = this;
        if (me.service.data.messages.new_count != '0') {
            me.getCommunicationButton().reset();
            me.getCommunicationButton().addCount(me.service.data.messages.new_count);
        }
    },
    deleteAll: function(btn, e) {
        var me = this;
        Ext.widget('confirmdialog', {
            message: ExGods.ref('message_client|delete_all_confirm'),
            handler: function() {
                if (me.archiveNotices._doremove)  {
                    return;
                }
                
                me.archiveNotices._doremove = 1;
                me.service.command('messages_remove_list_rest', {}, function(result) {
                    if (result.success) {
                        me.service.data.messages.rest_count = 0;
                        me.archiveNotices.removeAll();
                    }
                    me.archiveNotices._doremove = null;
                });
            }
        });
    },
    deleteArchiveItem: function(message) {
        var me = this;
        if (me.archiveNotices._doremove)  {
            return;
        }
        
        me.archiveNotices._doremove = 1;
        me.service.command('messages_remove', {
            letter_id: message.get('letter_id')
        }, function(result) {
            if (result.success) {
                me.service.data.messages.rest_count--;
                me.archiveNotices.remove(message);
            }
            me.archiveNotices._doremove = null;
        });
    },
    /**
     * Выполняет команды по управлению цепочками писем из чата
     *
     * @param {Object} data Данны вида:
     *
     *      {
     *          body: {
     *              chain: {},
     *              letter: {},
     *              type: 'post'
     *          },
     *          ...
     *      }
     */
    onPostCommand: function(chatcn, data) {
        var me = this,
            app = me.application,
            messageData = data.body.letter;
        if (data.body.remove) {
            var notices = messageData.state == 1 ? me.newNotices : me.archiveNotices,
                notice = notices.data.getByKey(Number(messageData.letter_id));
            if (notice) {
                notices.remove(notice);
                if (notices == me.newNotices) {
                    me.service.data.messages.new_count--;
                } else {
                    me.service.data.messages.rest_count--;
                }
            }
        } else {
            if (me.getNotice()) {
                var count = me.service.data.messages.new_count;
                me.service.data.messages.new_count++;
                if (me.newNotices.count() < count) {
                    me.getNotice().rawMails.push(data.body.letter);
                    me.newNotices.fireEvent('datachanged', me.newNotices);
                } else {
                    me.newNotices.loadRawData([
                        data.body.letter
                    ], true);
                }
                if (me.service.data.messages.new_count == 1) {
                    if (me.getNotice().isVisible()) {
                        me.getNotice().showNext();
                    } else {
                        me.getNotice().on('show', function() {
                            me.getNotice().showNext();
                        }, me, {
                            single: true
                        });
                    }
                }
            } else {
                me.service.data.messages.new_count++;
            }
            me.getCommunicationButton().reset();
            me.getCommunicationButton().addCount(me.service.data.messages.new_count);
        }
    },
    /**
     * Обработка клика по кнопке "Забрать"
     */
    onTakeAttachClick: function(button, checkbox) {
        var me = this,
            app = me.application,
            newNotices = me.newNotices,
            notice = newNotices.first(),
            user = me.getUser();
        // if (checkbox.checked) {
        //  var data = notice.get('data'),
        //      img = data.viral_image || data.image;
        //  if (isSocialApp) {
        //      button.disable();
        //      app.on({
        //          socialwallposted: Ext.Function.pass(me.takeNoticeAttach, [button, checkbox, notice], me),
        //          socialwallcanceled: function() {
        //              button.enable();
        //          },
        //          single: true
        //      })
        //      app.fireEvent('socialwallpost', {
        //          message: data.viral || data.subject,
        //          subject: data.subject,
        //          image_rel: data.image ? data.image : null,
        //          image: img ? IMAGE_URL + img : null
        //      });
        //  } else if (user.getSocialNet()) {
        //      app.fireEvent('socialshare', {
        //          type: user.get('social').social_net,
        //          url: 'http://' + location.host,
        //          image: IMAGE_URL + img || Ext.BLANK_IMAGE_URL,
        //          title: data.subject,
        //          description: data.viral || data.body
        //      });
        //      me.takeNoticeAttach(button, checkbox, notice);
        //  } else {
        //      // переход на привязку ника
        //      Ext.widget('confirmdialog', {
        //          message: ExGods.ref('message_client|socialattachment'),
        //          handler: function() {
        //              app.fireEvent('socialnetassign');
        //          }
        //      });
        //  }
        // } else {
        me.takeNoticeAttach(button, checkbox, notice);
    },
    //}
    takeNoticeAttach: function(button, checkbox, notice) {
        var me = this,
            user = me.getUser(),
            newNotices = me.newNotices;
        button.disable();
        ExGods.app.block();
        me.service.command(notice.get('data').attaches.length ? 'messages_take_attach' : 'messages_update_state', {
            letter_id: notice.get('letter_id')
        }, function(result) {
            notice.set(result.letter);
            if (me.service.data.messages.new_count != 0)  {
                me.service.data.messages.new_count--;
            }
            
            me.service.data.messages.rest_count++;
            me.newNotices.remove(notice);
            me.archiveNotices.add(notice);
            me.getCommunicationButton().reset();
            me.getCommunicationButton().addCount(me.service.data.messages.new_count);
            me.getNotice().showNext(function() {
                //checkbox.setValue(true);
                button.enable();
                ExGods.app.unblock();
            });
        });
    },
    // clearNoticeArchive: function() {
    //  var me = this,
    //      archiveNotices = me.archiveNotices,
    //      service = me.getNotice().service;
    //  me.request({
    //      url: '/game.pl?cmd=messages_remove_list_rest',
    //      params:{
    //          service_id:service.get('id')
    //      },
    //      success: function(result) {
    //          if (result.success) {
    //              var data = service.get('data');
    //              archiveNotices.removeAll();
    //              data.messages.rest_count = 0;
    //              service.set('data',data);
    //          }
    //      }
    //  });
    // },
    /**
     * Инициализация компонента
     */
    initNoticesComponent: function(config) {
        var me = this,
            wnd, cmp,
            fn = function() {
                var tabPanel = this.down('noticetabpanel');
                if (tabPanel && tabPanel.rendered) {
                    if (me.service.data.messages.new_count != 0) {
                        tabPanel.setActiveTab(0);
                    } else {
                        tabPanel.setActiveTab(1);
                    }
                }
            };
        cmp = Ext.widget('noticetabpanel', {
            messages: me.service.data.messages,
            items: [
                {
                    xtype: 'notice',
                    user: ExGods.app.user,
                    store: me.newNotices,
                    social: me.getUser().getSocialNet(),
                    icon: ExGods.ref('images|notice_images').image.new_tab_text,
                    quantityLeft: 105,
                    messages: me.service.data.messages
                },
                {
                    xtype: 'noticearchive',
                    user: ExGods.app.user,
                    store: me.archiveNotices,
                    icon: ExGods.ref('images|notice_images').image.archive_tab_text,
                    quantityLeft: 118,
                    messages: me.service.data.messages
                }
            ]
        });
        wnd = Ext.widget('window2', {
            id: 'NOTICES',
            items: [
                cmp
            ],
            autoShow: false,
            closeAction: 'hide',
            listeners: {
                show: function() {
                    var tabPanel = this.down('noticetabpanel');
                    if (tabPanel && tabPanel.rendered) {
                        tabPanel.items.each(function(item) {
                            item.tab.onCountChange();
                        });
                        fn.call(this);
                    }
                },
                afterrender: fn
            }
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
            cmp.down('notice').showNext(function() {
                cmp.down('notice').leftToLoad = me.service.data.messages.new_count - me.newNotices.count();
            });
        });
        return wnd;
    }
});

/**
 * Выполняет загрузку ресурсов игры
 */
Ext.define('ExGods.controller.Resources', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Resources:'
    },
    /**
     * @property cache Array
     */
    cache: {
        images: []
    },
    init: function() {
        var me = this;
        me.queue = [];
        ExGods.Resources = me;
        // быстрая ссылка
        me.callParent(arguments);
    },
    /**
     * Выполнит загрузку ресурсов
     * @param src Источник ресурсов. В качестве источника может выступать любой объект, реализующий метод getResources или id component'а, реализующий тот же интерфейс
     * @param callback Колбек
     */
    load: function(src, callback) {
        var me = this,
            recources = {},
            started = 0,
            finished = 0,
            checkFinish = function(src) {
                var checkQueue = function() {
                        if (me.queue.length) {
                            var src = me.queue.shift();
                            me.load(src.src, src.callback);
                        }
                    };
                if (++finished >= started) {
                    me.loading = false;
                    var items = [];
                    if (src.items && src.items.items) {
                        items = items.concat(src.items.items);
                    }
                    if (src.dockedItems && src.dockedItems.items) {
                        items = items.concat(src.dockedItems.items);
                    }
                    if (src.plugins && src.plugins.length) {
                        items = items.concat(src.plugins);
                    }
                    me.loadMulti(items, function() {
                        /***/
                        me.log('finish', src);
                        callback();
                        checkQueue();
                    });
                }
            };
        callback = callback || Ext.emptyFn;
        if (me.loading) {
            me.queue.push({
                src: src,
                callback: callback
            });
            return;
        }
        /***/
        me.log('Подгружаю ресурсы', src);
        if (typeof src == 'string') {
            src = Ext.getCmp(src);
            if (!src) {
                /***/
                me.log('warn', '\tКомпонент не найден.', src);
                callback();
                return;
            }
        }
        if (typeof src.getResources == 'function') {
            recources = src.getResources();
            me.loading = true;
            // Заранее определяем сколько стартует
            if (recources && recources.images) {
                started++;
            }
            if (recources && recources.stuff) {
                started++;
            }
            if (recources && recources.images) {
                me.loadImages(recources.images, function() {
                    checkFinish(src);
                });
            }
            if (recources && recources.stuff) {
                me.loadStuff(recources.stuff, function() {
                    checkFinish(src);
                });
            }
        }
        if (!started) {
            checkFinish(src);
        }
    },
    /**
     * Подгрузка ресурсов из нескольких источников
     * @param src Array
     */
    loadMulti: function(src, callback) {
        var me = this,
            loaded = 0,
            onLoad = function() {
                if (++loaded == src.length) {
                    callback();
                }
            };
        if (src.length) {
            for (var i = 0; i < src.length; i++) {
                me.load(src[i], onLoad);
            }
        } else {
            callback();
        }
    },
    /**
     * Подгрузка картинок
     */
    loadImages: function(images, callback) {
        var me = this,
            loaded = 0,
            incCounter = function() {
                if (++loaded == images.length) {
                    callback();
                }
            },
            img;
        if (images.length) {
            for (var i = 0; i < images.length; i++) {
                if (images[i] && images[i] != IMAGE_URL && Ext.Array.indexOf(me.cache.images, images[i]) == -1) {
                    if (images[i].substr && images[i].substr(0, 4) == 'img:') {
                        // проверка, что изображение из справочника
                        images[i] = images[i].substr(4);
                    }
                    img = new Image();
                    img.onload = incCounter;
                    img.onerror = incCounter;
                    img.src = /^http/.test(images[i]) ? images[i] : IMAGE_URL + images[i];
                    me.cache.images.push(images[i]);
                } else {
                    incCounter();
                }
            }
        } else {
            me.imagesloaded = true;
            callback();
        }
    },
    /**
     * Подгрузка имущества
     */
    loadStuff: function(stuff, callback) {
        var me = this,
            itemProtos = me.app.getItemPrototypesStore(),
            featureProtos = me.app.getFeaturePrototypesStore(),
            proto,
            images = [];
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        ExGods.util.Helper.loadProtosFromStuff(stuff, function() {
            Ext.Array.each(stuff, function(item) {
                //ExGods.ref('user_hoard|expa').image_big,
                if (item.type == 'expa') {
                    var obj = ExGods.ref('user_hoard|expa');
                    //images.push(obj.image);
                    images.push(obj.image_big);
                    images.push(obj.image_disabled);
                    return;
                }
                if (item.type == 'currency') {
                    var obj = ExGods.ref('user_money|' + item.params.id);
                    images.push(obj.image);
                    images.push(obj.image_big);
                    images.push(obj.image_disabled);
                    return;
                }
                if (item.type == 'item' || item.type == 'skull_item') {
                    proto = itemProtos.getById(parseInt(item.params.id));
                    if (proto) {
                        for (var key in proto.data.images) {
                            images.push(proto.data.images[key]);
                        }
                    }
                    return;
                }
                if (item.type == 'feature') {
                    proto = featureProtos.getById(item.params.id);
                    if (proto) {
                        for (var key in proto.data.images) {
                            images.push(proto.data.images[key]);
                        }
                    }
                    return;
                }
                if (item.type == 'action') {
                    proto = ExGods.ref('direct_actions|' + item.params.id);
                    if (proto) {
                        images.push(proto.images.simple);
                        images.push(proto.images.special);
                    }
                    return;
                }
                if (item.type == 'ingredients') {
                    proto = ExGods.ref('ingredients|' + item.params.id);
                    if (proto) {
                        images.push(proto.params.images.img_1);
                        images.push(proto.params.images.img_2);
                        images.push(proto.params.images.img_3);
                    }
                    return;
                }
                if (item.type == 'iteminstance') {
                    for (var i = 0; i < item.params.itemModel.data.features.length; i++) {
                        if (item.params.itemModel.data.features[i].images) {
                            var imgs = item.params.itemModel.data.features[i].images;
                            for (var it in imgs) {
                                if (imgs[it]) {
                                    images.push(imgs[it]);
                                }
                            }
                        }
                    }
                    // Прототипы предмета
                    if (item.params.itemModel.data.proto_id) {
                        proto = itemProtos.getById(parseInt(item.params.itemModel.data.proto_id));
                        if (proto) {
                            for (var key in proto.data.images) {
                                images.push(proto.data.images[key]);
                            }
                            if (proto.data.action_full) {
                                for (var i = 0; i < proto.data.action_full.length; i++) {
                                    if (proto.data.action_full[i].images) {
                                        for (var it in proto.data.action_full[i].images) {
                                            images.push(proto.data.action_full[i].images[it]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return;
                }
                if (item.type == 'timed') {
                    proto = ExGods.ref('user_timed|' + item.params.id);
                    if (proto) {
                        images.push(proto.img.img2);
                        images.push(proto.img.stuff);
                        if (proto.price) {
                            for (var i = 0; i < proto.price.length; i++) {
                                if (proto.price[i].type == 'timed') {
                                    me.log('warn', 'В стафе timed есть price где тоже есть timed! :) ');
                                }
                                me.loadStuff(proto.price[i], callback);
                            }
                        }
                    }
                    return;
                }
                me.log('warn', 'Неизвестный тип стафа для предварительной загрузки ресурсов: ' + item.type);
            });
            //console.log('Неизвестный тип: ' + item.type);
            me.loadImages(images, callback);
        });
    }
});

Ext.define('ExGods.view.dialog.stuff.DailyBonus', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.view.dialog.stuff.decorator.Day);
        if (me.stuff.selected) {
            data.decorators.push(ExGods.view.dialog.stuff.decorator.Selected);
        } else if (me.stuff.taken) {
            data.img = me.obj.getDisabledImage();
            data.decorators.push(ExGods.view.dialog.stuff.decorator.Taken);
        }
        return data;
    }
});

Ext.define('ExGods.view.dialog.stuff.Rewards', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.view.dialog.stuff.decorator.RewardFrame);
        return data;
    }
});

/**
 * Добавляет черепа на иконку предмета
 */
Ext.define('ExGods.view.dialog.stuff.decorator.Day', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateBefore: function(data) {
            var label;
            if (data.stuff.fin) {
                label = ExGods.getMsgByKey('daily_bonus_last_reward');
            } else {
                label = ExGods.app.applyTpl(ExGods.getMsgByKey('view_dialog_daily_day'), {
                    day: data.stuff.login_day_index
                });
            }
            return '<div class="label">' + label + '</div>';
        }
    }
});

/**
 * Добавляет черепа на иконку предмета
 */
Ext.define('ExGods.view.dialog.stuff.decorator.Selected', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var label;
            if (data.stuff.fin) {
                label = ExGods.getMsgByKey('daily_bonus_last_reward');
            } else {
                label = ExGods.app.applyTpl(ExGods.getMsgByKey('view_dialog_daily_day'), {
                    day: data.stuff.login_day_index
                });
            }
            return '<div class="selected-frame">' + label + '</div>';
        }
    }
});

/**
 * Добавляет черепа на иконку предмета
 */
Ext.define('ExGods.view.dialog.stuff.decorator.Taken', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="taken-mask" style="background-image:url(' + ExGods.ref('images|daily_bonus').image.achieved + ')"></div>';
        }
    }
});

/**
 * Добавляет черепа на иконку предмета
 */
Ext.define('ExGods.view.dialog.stuff.decorator.RewardFrame', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateBefore: function(data) {
            return '<div class="selected-frame"></div>';
        }
    }
});

/**
 * Диалог о награде
 */
Ext.define('ExGods.view.dialog.RewardsDialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.dialog_rewards',
    defaultConfig: {
        btnText: 'OK',
        btnColor: '',
        backImg: ''
    },
    layout: 'fit',
    bodyPadding: '7 8 4 6',
    cls: 'dialog_rewards',
    /** @cfg */
    config: {},
    stuff: [],
    plugins: [],
    buttonClickHandler: Ext.emptyFn,
    initComponent: function() {
        var me = this;
        me.config = Ext.applyIf(me.config || {}, me.defaultConfig);
        me.items = [
            {
                xtype: 'container',
                layout: 'absolute',
                plugins: [
                    'paperdeco'
                ],
                items: [
                    {
                        xtype: 'component',
                        cls: 'image-wrap',
                        html: '<div class="frame"></div><div class="image" style="background-image: url(' + IMAGE_URL + me.config.backImg + ')"></div>'
                    },
                    {
                        xtype: 'component',
                        width: '100%',
                        y: 269,
                        style: {
                            'text-align': 'center'
                        },
                        html: '<div class="dialog-rewards-stuff"></div>',
                        listeners: {
                            render: me.printRewards,
                            scope: me
                        }
                    }
                ]
            }
        ];
        me.bbar = {
            items: [
                {
                    xtype: 'textbutton',
                    text: me.config.btnText,
                    cls: (me.config.btnColor) ? 'x-btn-txt-' + me.config.btnColor : '',
                    handler: me.buttonClickHandler
                }
            ],
            layout: {
                pack: 'center'
            },
            margin: '-5 0 12 0'
        };
        if (me.stuff.length > 6) {
            me.plugins.push({
                ptype: 'pager',
                marginLeft: -27,
                marginRight: -27,
                top: 286,
                total: Math.ceil(me.stuff.length / 6),
                tpl: []
            });
        }
        me.callParent(arguments);
    },
    printRewards: function() {
        var me = this,
            html = [],
            page = me.pager ? me.pager.current - 1 : 0,
            l = me.stuff.length;
        for (var i = page * 6; i < Math.min(l, (page + 1) * 6); i++) {
            html.push(ExGods.stuff.StuffManager.image(me.stuff[i]));
        }
        html = html.join('<div class="dialog-rewards-ribbon-middle"></div>');
        html = '<div class="dialog-rewards-ribbon-left"></div>' + html;
        html = html + '<div class="dialog-rewards-ribbon-right"></div>';
        me.el.down('.dialog-rewards-stuff').setHTML(html);
    },
    prevPage: function(pager) {
        this.printRewards();
        pager.refresh();
    },
    nextPage: function(pager) {
        this.printRewards();
        pager.refresh();
    }
});

/**
 * Стандартное окно диалога. Не важно с кем предстоит общаться: ботом или предметом
 */
Ext.define('ExGods.view.dialog.Dialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.dialog',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    bodyPadding: '10 9 13 10',
    plugins: [
        'skindeco'
    ],
    /**
     * @cfg {Object}
     *  : title название диалога
     *  : image картинка диалога
     *  : description описание диалога
     *
     */
    info: {},
    /**
     * @cfg {Object} данные для темплейта диалога
     */
    data: '',
    /**
     * @cfg {String/Array} Шаблон для отображения data
     */
    tplForContent: '',
    /**
     * @cfg {Array} actions Массив компонентов-действий диалога (кнопок в общем случае)
     */
    actions: [],
    /**
     * @cfg {Object} Конфиг для контейнера действий диалога
     */
    actionsPanelConfig: {},
    // 
    initComponent: function() {
        var me = this;
        if (me.close_btn_text) {
            me.actions.push({
                anchor: "100%",
                text: me.close_btn_text,
                xtype: "textbutton",
                margin: '0 0 3 0',
                handler: function(button, event) {
                    me.up().closeComponent();
                }
            });
        }
        if (!me.actionsView) {
            me.actionsView = Ext.create('ExGods.view.dialog.DialogActions', {
                actions: me.actions
            });
        }
        me.items = [
            {
                itemId: 'info',
                cls: 'dialog-info',
                plugins: [
                    'parchmentdeco'
                ],
                width: 174,
                tpl: new Ext.Template('<div class="title">{title}</div>', '<div class="parchment-separator"></div>', '<div class="image" style="background-image: url({image})">', '<div class="frame"></div>', '</div>', '<div class="parchment-separator"></div>', '<div class="description">{description}</div>'),
                data: me.info
            },
            {
                itemId: 'content-container',
                bodyPadding: '4 0 4 4',
                flex: 1,
                layout: 'fit',
                margin: '0 0 0 2',
                plugins: [
                    'parchmentdeco'
                ],
                items: [
                    {
                        itemId: 'content',
                        autoScroll: true,
                        cls: 'dialog-content',
                        plugins: [
                            {
                                animate: false,
                                autoHide: false,
                                padding: '14 0 0 0',
                                ptype: 'scroller',
                                scrollDeltaY: 16
                            }
                        ],
                        html: Ext.create('ExGods.view.Template', me.tplForContent).apply(me.data)
                    }
                ],
                dockedItems: [
                    me.actionsView
                ]
            }
        ];
        me.on('afterrender', me.onAfterRender, me);
        me.callParent();
    },
    /**
     * Вернет панель, в которой отображается информация о диалоге - название, картинка и пр.
     * @return {Ext.Panel}
     */
    getInfoPanel: function() {
        return this.getComponent('info');
    },
    /**
     * Вернет панель, в которой отображается текст диалога
     * @return {Ext.Panel}
     */
    getContentPanel: function() {
        var me = this,
            contentCt = me.getComponent('content-container');
        if (contentCt) {
            return contentCt.getComponent('content');
        } else {
            return null;
        }
    },
    /**
     * Обновить инфо диалога
     * @param {Object} data
     */
    setInfo: function(data) {
        var me = this,
            infoPanel = me.getInfoPanel();
        if (infoPanel) {
            infoPanel.update(data);
        }
    },
    /**
     * Обновить текст диалога
     * @param {Object} data Данные, после преобразования в tpl станут html
     */
    setContent: function(data) {
        var me = this,
            contentPanel = me.getContentPanel(),
            text = Ext.create('ExGods.view.Template', me.tplForContent).apply(data);
        if (contentPanel) {
            contentPanel.body.setHTML(text);
            contentPanel.scroller.onResize();
        }
    },
    /**
     * Добавить текст диалога
     * @param {Html} text Добавить текст к уже имеющемуся
     *
     */
    addContent: function(text) {
        var me = this,
            contentPanel = me.getContentPanel();
        if (contentPanel) {
            contentPanel.body.setHTML(contentPanel.body.getHTML() + text);
            contentPanel.scroller.onResize();
            contentPanel.scroller.scrollToBottom();
        }
    },
    /**
     * Обновить диалог
     * @param {Object} newSettings Набор новых данных для диалога
     */
    updateData: function(newSettings) {
        if (newSettings.info)  {
            this.setInfo(newSettings.info);
        }
        
        if (newSettings.data)  {
            this.setContent(newSettings.data);
        }
        
        if (newSettings.actions)  {
            this.actionsView.setActions(newSettings.actions);
        }
        
    },
    /**
     * @private
     */
    onAfterRender: function() {
        var me = this;
    }
});
// вешаем обработчик на клик по элементу диалога
// если клик был по ссылке на предмет - выбрасывает соответствующее событие
//      me.getEl().on('click', function(e, t) {
//          var el = Ext.get(t),
//              item;
//
//          if (item  = e.getTarget('.item')) {
//              ExGods.app.fireEvent('itemclick', {
//                  itemEl: item,
//                  proto_id: parseInt(item.getAttribute('data-proto_id')),
//                  maskCt: el.up('.x-container')
//              });
//          }
//
//      });

/**
 * Окно диалога информация о новом монстре
 */
Ext.define('ExGods.view.dialog.BotInfoDialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.bot_info_dialog',
    layout: 'fit',
    closable: true,
    width: 620,
    height: 430,
    y: 95,
    x: 223,
    plugins: [
        'skindeco'
    ],
    cls: 'bot-dialog',
    bodyPadding: '7 8 4 6',
    initComponent: function() {
        var me = this,
            protos = ExGods.app.getItemPrototypesStore(),
            items = curency = '',
            missedProtos = [],
            stuff_length = me.config.data.description_stuff.length;
        //для тестов можно раскоментить
        //me.config.data.description_stuff = me.config.data.description_stuff.concat(me.config.prize );
        //me.config.data.description_stuff = me.config.data.description_stuff.concat(me.config.prize );
        me.right_width = 350;
        //ширина правой части по умолчанию
        if (stuff_length > 5) {
            //если наград больше пяти, то используем формулы
            me.right_width = stuff_length * 70;
            //для ширины правой части
            me.width = 270 + me.right_width;
            //для всей ширины (левая часть + правая)
            me.x = (1000 - me.width) / 2;
        }
        //отступ слева (ширина экрана - ширина окна и всё деленное на 2)
        var me = this,
            descrHeight = 270,
            bigPrize;
        me.config.data.name_with_level = ExGods.printUser({
            hoard: {
                level: me.config.data.level
            },
            display_title: me.config.data.title
        }, {
            fields: 'level,name',
            maxNameWidth: '180'
        });
        me.config.data.image = ExGodsCore.app.references.get('user_shape').getByKey(me.config.data.shape).full;
        if (me.config.prize) {
            descrHeight = 158;
            bigPrize = [
                '<div class="paper-title">' + ExGods.getMsgByKey('view_dialog_botinfodialog_banish') + '</div>',
                '<div class="npc_stuff_2 npc_bigPrize"></div>'
            ].join('');
        }
        me.tplForContent = [
            '<div class="paper-title">' + ExGods.getMsgByKey('view_dialog_botinfodialog_title') + '</div>',
            '<div class="description" style="height: ' + descrHeight + 'px;">',
            me.config.description,
            '</div>',
            bigPrize,
            '<div class="paper-title">' + ExGods.getMsgByKey('view_dialog_botinfodialog_attack') + '</div>',
            '<div class="npc_stuff_2 npc_bigItems"></div>'
        ].join('');
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                layout: 'absolute',
                height: 418,
                items: [
                    {
                        itemId: 'info',
                        cls: 'dialog-info',
                        style: {
                            borderRight: '1px solid #7d4b2a'
                        },
                        width: 230,
                        height: 399,
                        y: 7,
                        x: 11,
                        tpl: new Ext.Template('<div class="paper-title">{name_with_level}</div>', '<div class="frame"></div>', '<div class="image" style="background-image: url({image})">', '</div>', '<div class="user_stats_image">', ExGods.util.User.printUserStats(me.config.data.stats, {
                            visibleValue: 2
                        }), '</div>'),
                        data: me.config.data
                    },
                    {
                        itemId: 'content-container',
                        width: me.right_width,
                        height: 399,
                        style: {
                            borderLeft: '1px solid #7d4b2a'
                        },
                        x: 245,
                        y: 7,
                        items: [
                            {
                                itemId: 'content',
                                autoScroll: true,
                                cls: 'dialog-content',
                                // plugins: [{
                                //  animate: false,
                                //  autoHide: false,
                                //  padding: '14 0 0 0',
                                //  ptype: 'scroller',
                                //  scrollDeltaY: 16
                                // }],
                                html: me.tplForContent
                            }
                        ]
                    },
                    {
                        itemId: 'v-separator',
                        width: 10,
                        height: 407,
                        html: '<div class="v-separator"></div>',
                        x: 240,
                        y: 0
                    },
                    {
                        itemId: 'separator',
                        width: me.right_width + 1,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 295
                    },
                    {
                        itemId: 'separator-2',
                        width: me.right_width + 1,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 184,
                        hidden: !bigPrize
                    }
                ]
            }
        ];
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.config.data.description_stuff) {
            stuff_arr = stuff_arr.concat(me.config.data.description_stuff);
        }
        if (me.config.data.prize) {
            stuff_arr = stuff_arr.concat(me.config.data.prize);
        }
        return {
            stuff: stuff_arr,
            images: [
                me.config.data.image
            ].concat(arr_images)
        };
    }
});

/**
 * Окно диалога с ботом
 */
Ext.define('ExGods.view.dialog.BotDialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.botdialog',
    cls: 'bot-dialog',
    bodyPadding: '7 8 0 6',
    id: 'BotDialogPanel',
    initComponent: function() {
        var me = this;
        me.tplForContent = [
            '<div class="paper-title">' + me.info.bot_power_text + '</div>',
            '<div class="description">' + me.info.description + '</div>',
            '<div class="separator"></div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('dialog_reward_can') + '</div>',
            '<div class="npc_stuff_2">{[this.methodGetStuff()]}</div>'
        ].join('');
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                layout: 'absolute',
                height: 370,
                items: [
                    {
                        itemId: 'info',
                        cls: 'dialog-info',
                        style: {
                            borderRight: '1px solid #7d4b2a'
                        },
                        width: 230,
                        height: 350,
                        y: 7,
                        x: 11,
                        tpl: new Ext.XTemplate('<div class="paper-title">{name_with_level}</div>', '<div class="frame"></div>', '<div class="image bot-info-stats-container" style="background-image: url({image})">', '<tpl if="this.isInfo()">', '<div class="paper paper-bg"></div>', '<div class="avatar-info-container">', '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>', '<div class="avatar-params stats-list">', '{[ ExGods.util.User.printUserStats(values.stats, {visibleValue: 1, align: "right"}) ]}', '</div>', '<div class="paper-separator"></div>', '<div class="avatar-statsstars">', '{[ ExGods.util.User.printUserStats(values.stats, {visibleValue: 2}) ]}', '</div>', '</div>', '</tpl>', '</div>', {
                            isInfo: function() {
                                return me.isInfo;
                            }
                        }),
                        data: me.info
                    },
                    {
                        itemId: 'content-container',
                        width: 510,
                        height: 350,
                        style: {
                            borderLeft: '1px solid #7d4b2a'
                        },
                        x: 245,
                        y: 7,
                        items: [
                            {
                                itemId: 'content',
                                autoScroll: true,
                                cls: 'dialog-content',
                                tpl: [
                                    me.tplForContent,
                                    {
                                        methodGetStuff: function() {
                                            if (!Ext.isArray(me.info.stuff)) {
                                                me.info.stuff = [
                                                    me.info.stuff
                                                ];
                                            }
                                            var img_stuff_html = Ext.Array.map(me.info.stuff, function(stuff) {
                                                    return ExGods.stuff.StuffManager.image(stuff);
                                                }).join('');
                                            return img_stuff_html;
                                        }
                                    }
                                ],
                                data: {}
                            }
                        ]
                    },
                    {
                        itemId: 'v-separator',
                        width: 10,
                        height: 358,
                        html: '<div class="v-separator"></div>',
                        x: 240,
                        y: 0
                    },
                    {
                        itemId: 'separator',
                        width: 511,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 246
                    }
                ]
            },
            {
                xtype: 'container',
                style: {
                    padding: '0 0 0 385px',
                    height: '47px'
                },
                items: me.actionsView
            }
        ];
        me.callParent();
        me.on('afterrender', function(cmp) {
            var btn = cmp.down('#attack_button');
            if (btn) {
                btn.el.set({
                    'data-qh_otype': 'bot_button_attack',
                    'data-qh_oid': me.speaker.data.bot_type
                });
            }
            btn = cmp.down('#banish_button');
            if (btn) {
                btn.el.set({
                    'data-qh_otype': 'bot_button_banish',
                    'data-qh_oid': me.speaker.data.bot_type,
                    'data-qh_opts': "{&quot;cls&quot;:&quot;flip-h&quot;}"
                });
            }
            me.el.on('click', function() {
                me.isInfo = !me.isInfo;
                me.onInfoChange();
            }, me, {
                delegate: '.info-btn'
            });
        });
    },
    onInfoChange: function() {
        var me = this;
        if (me.rendered) {
            me.down('#info').update(me.info);
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var obj = ExGods.ref('images|bot_dialog_images').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        return {
            stuff: me.info.stuff,
            images: [
                me.info.image,
                IMAGE_URL + 'button-text-30.png',
                // синяя кнопка
                IMAGE_URL + 'btn_wide_red.png'
            ].concat(arr_images)
        };
    }
});

(function() {
    /**
     * Диалог о награде
     */
    Ext.define('ExGods.view.dialog.DailyBonusDialog', {
        extend: Ext.panel.Panel,
        alias: 'widget.dialog_daily_bonus',
        defaultConfig: {
            btnText: 'OK',
            btnColor: '',
            backImg: '',
            selectedIndex: 1
        },
        layout: 'fit',
        bodyPadding: '7 8 4 6',
        cls: 'dialog_daily_bonus',
        /** @cfg */
        config: {},
        rewards: [],
        buttonClickHandler: Ext.emptyFn,
        initComponent: function() {
            var me = this,
                rewardsPanel, currentPage;
            me.config = Ext.applyIf(me.config || {}, me.defaultConfig);
            me.config.selectedIndex = me.rewards.length < me.config.selectedIndex ? me.rewards.length : parseInt(me.config.selectedIndex);
            currentPage = Math.ceil(me.config.selectedIndex / 10);
            rewardsPanel = new RewardsPanel({
                selectedIndex: me.config.selectedIndex,
                totalCount: me.rewards.length,
                rewardsData: me.rewards.slice((currentPage - 1) * 10, (currentPage - 1) * 10 + 10)
            });
            me.items = [
                {
                    xtype: 'container',
                    layout: 'absolute',
                    plugins: [
                        'paperdeco'
                    ],
                    items: [
                        {
                            xtype: 'component',
                            cls: 'image-wrap',
                            html: '<div class="frame"></div><div class="image" style="background-image: url(' + IMAGE_URL + me.config.backImg + ')"></div>'
                        },
                        {
                            xtype: 'component',
                            width: '99%',
                            height: 4,
                            html: '<div class="separator"></div>',
                            x: 4,
                            y: 252
                        },
                        {
                            xtype: 'container',
                            itemId: 'rewardsPanelCt',
                            layout: 'fit',
                            width: '100%',
                            y: 265,
                            x: 15,
                            margin: '-5 0 0 0',
                            items: [
                                rewardsPanel
                            ]
                        },
                        {
                            xtype: 'component',
                            cls: 'title_1',
                            style: {
                                background: 'url(' + ExGods.ref('images|daily_bonus').image.title_1 + ') 50% 4px no-repeat, url(' + IMAGE_URL + 'dialog_daily_bonus/flag1.png) no-repeat 0 0, url(' + IMAGE_URL + 'dialog_daily_bonus/flag3.png) 100% 0 no-repeat'
                            },
                            x: 178,
                            y: 28
                        },
                        {
                            xtype: 'component',
                            cls: 'title_2',
                            style: {
                                backgroundImage: 'url(' + ExGods.ref('images|daily_bonus').image.title_2 + ')'
                            },
                            x: 190,
                            y: 203
                        }
                    ]
                }
            ];
            me.bbar = {
                items: [
                    {
                        xtype: 'textbutton',
                        text: me.config.btnText,
                        cls: (me.config.btnColor) ? 'x-btn-txt-' + me.config.btnColor : '',
                        handler: me.buttonClickHandler
                    }
                ],
                layout: {
                    pack: 'center'
                },
                margin: '-5 0 12 0'
            };
            me.plugins = me.plugins || [];
            me.plugins.push({
                ptype: 'pager',
                marginLeft: -27,
                marginRight: -27,
                top: 304,
                current: currentPage,
                total: Math.ceil(me.rewards.length / 10)
            });
            me.listeners = {
                prev: me.updateRewardsPanel,
                next: me.updateRewardsPanel,
                scope: me
            };
            me.callParent(arguments);
        },
        updateRewardsPanel: function(pager) {
            var me = this,
                rewardsPanel, ct;
            rewardsPanel = new RewardsPanel({
                selectedIndex: me.config.selectedIndex,
                totalCount: me.rewards.length,
                rewardsData: me.rewards.slice((pager.current - 1) * 10, (pager.current - 1) * 10 + 10)
            });
            ct = me.items.items[0].getComponent('rewardsPanelCt');
            ct.removeAll();
            ct.add(rewardsPanel);
            pager.refresh();
        },
        /**
     * Ресурсы вью предзагрузка
     */
        getResources: function() {
            var me = this,
                stuff_arr = [],
                arr_images = [];
            stuff_arr = stuff_arr.concat(me.rewards);
            var imgs = ExGods.ref('images|daily_bonus').image;
            for (var it in imgs) {
                arr_images.push(imgs[it]);
            }
            return {
                stuff: stuff_arr,
                images: [].concat(arr_images)
            };
        }
    });
    /**
     *  Private class
     */
    var RewardsPanel = Ext.define(null, {
            extend: 'Ext.panel.Panel',
            selectedIndex: 1,
            totalCount: 1,
            initComponent: function() {
                var me = this;
                me.config = Ext.applyIf(me.config, {
                    selectedIndex: 1,
                    totalCount: 1
                });
                me.data = me.config.rewardsData;
                me.tpl = [
                    '<div class="daily-rewards">',
                    '<tpl for=".">',
                    '{[this.printReward(values)]}',
                    '</tpl>',
                    '</div>',
                    {
                        printReward: function(values) {
                            return ExGods.stuff.StuffManager.image({
                                type: 'daily_bonus',
                                selected: values.login_day_index == me.config.selectedIndex,
                                taken: values.login_day_index < me.config.selectedIndex,
                                params: {
                                    stuff: Ext.apply({
                                        fin: values.login_day_index == me.config.totalCount
                                    }, values)
                                }
                            });
                        }
                    }
                ];
                me.callParent(arguments);
            },
            afterRender: function() {
                var me = this;
                me.callParent();
                var onClick = function(e, el) {
                        var item = Ext.fly(el).parent().down('.item img');
                        if (item) {
                            item.el.dom.click();
                        }
                    };
                me.el.on('click', onClick, me, {
                    delegate: '.label'
                });
                me.el.on('click', onClick, me, {
                    delegate: '.taken-mask'
                });
                me.el.on('click', onClick, me, {
                    delegate: '.selected-frame'
                });
            }
        });
}());

/**
 * Опции диалога с ботом
 */
Ext.define('ExGods.view.dialog.List', {
    extend: Ext.view.View,
    alias: 'widget.dialoglist',
    autoEl: {
        tag: 'ul',
        cls: 'quest-dialogs parchment-content parchment-content-nop'
    },
    cls: 'parchment-content parchment-content-nop',
    deferInitialRefresh: false,
    dock: 'bottom',
    itemSelector: 'li',
    /**
     * @cfg {ExGods.store.Quests} quests (required)
     * Текущие квесты пользоватея
     */
    style: {
        border: '0 !important'
    },
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<tpl for=".">',
            '<li>',
            '<img src="{[this.getIcon(values.action.qid, values.action, values.image)]}" /> {name}',
            '</li>',
            '</tpl>',
            {
                icons: ExGods.references.get('images').get('dialogue_icons').image,
                quests: me.quests,
                getIcon: function(qid, action, image) {
                    var cmd = action.cmd,
                        src = image,
                        icons = this.icons;
                    if (src)  {
                        return IMAGE_URL + src;
                    }
                    
                    switch (cmd) {
                        case 'check_quest_aims':
                            // Проверка целей квеста
                            src = icons.point;
                            break;
                        case 'list':
                            // Завершение диалога
                            src = icons.dialogue_end;
                            break;
                        case 'point':
                            // Переход на точку
                            src = icons.point;
                            break;
                        case 'prize':
                            // Выдача награды
                            src = icons.give_prize;
                            break;
                        case 'quest':
                            var quests = this.quests.snapshot ? this.quests.snapshot : this.quests.data,
                                quest = quests.getByKey(qid);
                            // Переход на квест
                            src = icons.add_quest;
                            if (quest) {
                                //status = 0 - восклицательный
                                //status = 2 - вопросительный
                                //остальное - диалоговое облачко
                                switch (quest.get('status')) {
                                    case 0:
                                        src = icons.add_quest;
                                        break;
                                    case 2:
                                        src = icons.complete_quest;
                                        break;
                                    default:
                                        src = icons.point;
                                        break;
                                }
                            };
                            break;
                        case 'random_point':
                            // Переход на случайную точку
                            src = icons.make;
                            break;
                        case 'shops':
                            // В магазин
                            src = icons.trade;
                            break;
                        case 'user_handler':
                            // Переход на действия над игроком
                            src = icons.user_actions;
                            break;
                        default:
                            //src = Ext.BLANK_IMAGE_URL;
                            src = icons.point;
                            break;
                    }
                    return src;
                }
            }
        ];
        me.callParent();
    }
});

/**
 * Вьюшка для actions диалога.
 *
 * Используется для отображения actions в Dialog view
 * если инициаторы диалога NPC
 *
 * @author Ветлугин Дмитрий
 *
 */
Ext.define('ExGods.view.dialog.NpcActions', {
    extend: Ext.panel.Panel,
    alias: 'widget.npc_actions',
    itemId: 'npc-actions-container',
    dock: 'bottom',
    margin: '4 0 0 0',
    height: 122,
    style: {
        border: '1px solid #907041 !important'
    },
    plugins: [
        {
            ptype: 'scroller',
            animate: true,
            autoHide: true,
            snap: 'li',
            scrollDeltaY: 24
        }
    ],
    defaults: {
        anchor: '100%'
    },
    layout: 'anchor',
    initComponent: function() {
        var me = this;
        me.callParent();
    },
    /**
     * Проверяет, есть ли среди точек диалога те, которые переводят на бой
     * @private
     *
     * @param {Array} store Массив компонентов действий (кнопок в общем случае)
     *
     * @return {Boolean}
     */
    isBattlePoint: function(store) {
        var index = store.findBy(function(point) {
                if (point.get('action').cmd == 'battle')  {
                    return true;
                }
                
            });
        return index == -1 ? false : true;
    },
    /**
     * Обновить список действий диалога
     * @param {Array} store Массив компонентов действий (кнопок в общем случае)
     */
    setActions: function(store) {
        var me = this;
        me.removeAll();
        if (me.isBattlePoint(store)) {
            var battlePoints = [];
            store.each(function(point) {
                if (point.get('action').cmd == 'battle')  {
                    battlePoints.push({
                        point: point,
                        text: point.get('name'),
                        name: 'action-button',
                        xtype: 'textbutton'
                    });
                }
                
            });
            me.add({
                xtype: 'container',
                defaults: {
                    anchor: '100%'
                },
                items: battlePoints,
                layout: 'anchor'
            });
        } else {
            me.add({
                xtype: 'dialoglist',
                quests: me.quests,
                store: store
            });
        }
    }
});

/**
 * Модель квеста
 */
Ext.define('ExGods.model.Quest', {
    extend: Ext.data.Model,
    idProperty: 'proto_id',
    aimCounterInterval: {},
    statics: {
        /**
         * @property
         * @static
         * Квеста ещё нет у пользователя, ни разу не брал
         */
        VIRGIN: -1,
        /**
         * @property
         * @static
         * Квест неактивен
         */
        NOT_ACTIVE: 0,
        /**
         * @property
         * @static
         * Активный квест (в процессе выполнения)
         */
        ACTIVE: 1,
        /**
         * @property
         * @static
         * Выполнен (не сдан)
         */
        READY_TO_COMPLETE: 2,
        /**
         * @property
         * @static
         * Завершён (сдан)
         */
        COMPLETE: 3,
        /**
         * @property
         * @static
         * Провален
         */
        FAILED: 4,
        /**
         * @property
         * @static
         * Архивный
         */
        ARCHIVE: 5
    },
    fields: [
        {
            name: 'aims',
            type: 'auto',
            convert: function(aims, record) {
                // отсортировать цели квеста по номеру этапа (stage)
                if (aims) {
                    Ext.Array.sort(aims, function(a, b) {
                        var stage1 = parseInt(a.stage);
                        var stage2 = parseInt(b.stage);
                        if (stage1 == stage2) {
                            return 0;
                        }
                        return stage1 > stage2 ? 1 : -1;
                    });
                    Ext.each(aims, function(aim, aim_index) {
                        if (aim.counter) {
                            Ext.each(aim.counter, function(counter, index) {
                                if (counter.type == 1) {
                                    counter.left = parseInt(counter.need) - parseInt(counter.curr);
                                    if (counter.left > 0) {
                                        if (record.aimCounterInterval['aimcounter_' + aim_index + '_' + index]) {
                                            clearInterval(record.aimCounterInterval['aimcounter_' + aim_index + '_' + index]);
                                        }
                                        record.aimCounterInterval['aimcounter_' + aim_index + '_' + index] = setInterval(function() {
                                            counter.left--;
                                            if (counter.left <= 0) {
                                                clearInterval(record.aimCounterInterval['aimcounter_' + aim_index + '_' + index]);
                                            }
                                            record.fireEvent('aimcounter_' + aim_index + '_' + index, counter.left, record);
                                        }, 1000);
                                    }
                                }
                            });
                        }
                    });
                }
                return aims;
            }
        },
        {
            name: 'desc',
            mapping: 'params.desc',
            type: 'string'
        },
        {
            // метка удаляемости квеста
            name: 'droppable',
            mapping: 'params.droppable',
            convert: function(v, rec) {
                var status = rec.get('status');
                return v && (status == ExGods.model.Quest.ACTIVE || status == ExGods.model.Quest.READY_TO_COMPLETE);
            },
            type: 'int'
        },
        {
            name: 'energy',
            mapping: 'params.energy',
            type: 'int'
        },
        {
            name: 'expanded',
            type: 'auto'
        },
        {
            mapping: 'object.data',
            name: 'giver',
            type: 'auto'
        },
        {
            mapping: 'object.object_type',
            name: 'giver_type',
            type: 'auto'
        },
        {
            // рекомендуемый уровень для выполнения квеста
            name: 'level',
            mapping: 'params.level',
            type: 'int'
        },
        {
            // маркеры квеста
            name: 'marks',
            type: 'auto',
            defaultValue: []
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            // номер шаблона бота, который выдал квест
            name: 'object_id',
            type: 'int'
        },
        {
            name: 'proto_id',
            type: 'int'
        },
        {
            name: 'repeat',
            mapping: 'params.repeat',
            type: 'string'
        },
        {
            name: 'random_rewards',
            type: 'auto'
        },
        {
            name: 'reroll_stuff',
            type: 'auto'
        },
        {
            name: 'rewards',
            type: 'auto'
        },
        {
            // текущий этап квеста
            name: 'stage',
            type: 'int'
        },
        {
            /*
         * -1 - квеста ещё нет у пользователя, ни разу не брал
         *  0 - неактивен
         *  1 - активен (в процессе выполнения)
         *  2 - выполнен (не сдан)
         *  3 - завершён (сдан)
         *  4 - провален
         *  5 - архив
         */
            name: 'status',
            type: 'int'
        },
        {
            name: 'story',
            mapping: 'params.story',
            type: 'int'
        },
        {
            mapping: 'params.timeout',
            name: 'timeout',
            type: 'string'
        },
        {
            // время до дропа квеста в секундах
            name: 'timedropfrom',
            type: 'int'
        },
        {
            /*
         * TIMESTAMP первого взятия квеста
         */
            name: 'timeopen',
            type: 'int'
        },
        {
            // оставшееся время блокировки квеста в секундах
            name: 'timerest',
            type: 'int'
        },
        {
            // 0 - объект не отслеживается, 1 - отслеживается
            name: 'traced',
            type: 'int',
            defaultValue: 0
        },
        {
            // параметры
            name: 'params',
            type: 'auto'
        },
        {
            name: 'give_confirm_text',
            type: 'string'
        },
        {
            name: 'take_confirm_text',
            type: 'string'
        }
    ],
    constructor: function(data, id, raw, convertedData) {
        var me = this;
        me.callParent(arguments);
        if (raw || data) {
            me.updateTimerestInterval((raw || data).timerest);
            me.updateDropInterval((raw || data).timedropfrom);
        }
    },
    /**
     * Событие изменения данных пользователя
     * @private
     */
    afterEdit: function() {
        var me = this;
        var changes = me.getChanges();
        // TODO: переделать, попробовать вынести это в хранилище
        me.processChanges(changes);
    },
    processChanges: function(changes) {
        var me = this;
        if (changes.timerest) {
            me.updateTimerestInterval(changes.timerest);
        }
        if (changes.timedropfrom) {
            me.updateDropInterval(changes.timedropfrom);
        }
    },
    updateTimerestInterval: function(timerest) {
        var me = this;
        me.updateInterval = me.updateInterval || {};
        if (me.updateInterval['timerest']) {
            clearInterval(me.updateInterval['timerest']);
            me.updateInterval['timerest'] = 0;
        }
        if (timerest > 0) {
            me.updateInterval['timerest'] = setInterval(function() {
                me.data.timerest--;
                if (me.data.timerest <= 0) {
                    //me.loadRemote();
                    clearInterval(me.updateInterval['timerest']);
                }
            }, 1000);
        }
    },
    updateDropInterval: function(timedropfrom) {
        var me = this,
            i = 0;
        me.updateInterval = me.updateInterval || {};
        if (me.updateInterval['timedropfrom']) {
            clearInterval(me.updateInterval['timedropfrom']);
            me.updateInterval['timedropfrom'] = 0;
        }
        if (timedropfrom > 0) {
            me.updateInterval['timedropfrom'] = setInterval(function() {
                me.data.timedropfrom--;
                if (me.data.timedropfrom <= 0) {
                    for (; i < me.stores.length; i++) {
                        me.stores[i].remove(me);
                    }
                    clearInterval(me.updateInterval['timedropfrom']);
                }
                me.fireEvent('timedropchanged', me.data.timedropfrom, me);
            }, 1000);
        }
    },
    /**
     * Загружает с сервера ВЕСЬ квест по его id
     */
    loadRemote: function() {
        var me = this;
        Ext.Ajax.request({
            url: HOST_URL + '/game.pl?cmd=quest',
            params: {
                qid: me.get('proto_id')
            },
            success: function(response) {
                var result = Ext.decode(response.responseText, true);
                if (result) {
                    me.set(result);
                }
            }
        });
    },
    /*
     * Возращает true, если квест может быть отслежен пользователем
     */
    isTraceable: function() {
        return this.get('params').traced && (this.get('status') == this.self.ACTIVE || this.get('status') == this.self.READY_TO_COMPLETE);
    },
    /**
     * Вернет true, если квест отслеживается
     */
    isTraced: function() {
        var me = this;
        return me.get('proto_id') == ExGods.app.user.get('trace_quest_proto');
    },
    /**
     * Вернет текст подтверждения взятии квеста
     */
    getGiveConfirmation: function() {
        var me = this,
            params = me.get('params');
        if (params.is_give_confirmed == 1) {
            return me.get('give_confirm_text');
        } else {
            return '';
        }
    },
    /**
     * Вернет текст подтверждения сдачи квеста
     */
    getTakeConfirmation: function() {
        var me = this,
            params = me.get('params');
        if (params.is_take_confirmed == 1) {
            return me.get('take_confirm_text');
        } else {
            return '';
        }
    },
    /**
     * Вернёт иконку бота-гивера
     */
    getGiverThumb: function() {
        var me = this,
            shapes = ExGods.references.get('user_shape');
        if (me.data.giver && me.data.giver.shape) {
            return shapes.getByKey(me.data.giver.shape).thumb;
        } else if (me.data.giver && me.data.giver.image_thumb) {
            // если giver предмет
            return IMAGE_URL + me.data.giver.image_thumb;
        } else if (me.data.giver && me.data.giver.icon) {
            // если giver приключение
            return IMAGE_URL + me.data.giver.icon;
        } else if (me.data.params && me.data.params.image) {
            return IMAGE_URL + me.data.params.image;
        } else {
            return Ext.BLANK_IMAGE_URL;
        }
    }
});

/**
 * Список квестов
 */
Ext.define('ExGods.store.Quests', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Quest',
    id: 'quests',
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        /**
         * Удаляем квесты со статусом 3 (выполнены и будут доступны через некоторое время) или 0 (не активен)
         * datachanged срабатывает на добавление и удаление элементов
         */
        me.on('datachanged', function() {
            var records = this.queryBy(function(record, id) {
                    return record.get('status') === 3 || record.get('status') === 0;
                });
            records.each(function(item) {
                me.remove(item);
            }, me);
        });
        /**
         * update срабатывает на изменение параметров элементов
         */
        me.on('update', function() {
            var records = this.queryBy(function(record, id) {
                    return record.get('status') === 3 || record.get('status') === 0;
                });
            records.each(function(item) {
                me.remove(item);
            }, me);
        });
    },
    sorters: [
        {
            sorterFn: function(a, b) {
                var ret = 0;
                if (a.get('story') == 3 && b.get('story') != 3)  {
                    ret = -1;
                }
                
                if (b.get('story') == 3 && a.get('story') != 3)  {
                    ret = 1;
                }
                
                if (!a.get('repeat') && !a.get('timeout') && a.get('story') == 1 && (b.get('repeat') || b.get('timeout') || b.get('story') != 1))  {
                    ret = -1;
                }
                
                if (!b.get('repeat') && !b.get('timeout') && b.get('story') == 1 && (a.get('repeat') || a.get('timeout') || a.get('story') != 1))  {
                    ret = 1;
                }
                
                if (a.get('status') == 2 && b.get('status') != 2)  {
                    ret = -1;
                }
                
                if (b.get('status') == 2 && a.get('status') != 2)  {
                    ret = 1;
                }
                
                return ret;
            }
        }
    ]
});
// proxy: {
//  type: 'ajax',
//  url: '/game.pl?cmd=quests.current',
//  limitParam: false,
//  pageParam: false,
//  startParam: false,
//  reader: {
//      type: 'json',
//      rootProperty: 'quests'
//  }
// }

/**
 * Котроллер диалогов
 *
 * Инициатором диалога может быть бот или предмет.
 */
Ext.define('ExGods.controller.Dialog', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        }
    },
    stores: [
        'Quests'
    ],
    views: [
        'dialog.Dialog',
        'dialog.List',
        'dialog.NpcActions',
        'dialog.BotInfoDialog',
        'dialog.BotDialog',
        'dialog.RewardsDialog',
        'dialog.DailyBonusDialog'
    ],
    refs: [
        {
            /**
         * @method getMain
         * Получет правое окно
         * @return {Ext.container.Container}
         */
            ref: 'main',
            selector: '#main'
        },
        {
            /**
         * @method getDialog
         */
            ref: 'dialog',
            selector: '#npc-dialog'
        },
        {
            /**
         * @method getBanish
         */
            ref: 'banish',
            selector: '#banish_button'
        }
    ],
    /**
     * @property {Object} speaker
     * Собеседник
     */
    popups_enabled: true,
    popups_queue: [],
    init: function() {
        var me = this;
        me.control({
            '#LOB_BOT_LIST': {
                itemclick: {
                    fn: me.onBotClick,
                    delay: 0
                }
            },
            'npc_actions button[name="action-button"]': {
                click: me.onNpcActionButtonClick
            },
            'dialoglist': {
                itemclick: {
                    fn: me.onPointClick,
                    delay: 0
                }
            },
            '#battle-result': {
                destroy: {
                    fn: me.showPopups,
                    delay: 100
                }
            }
        });
        ExGods.stuff.StuffManager.register({
            'daily_bonus': ExGods.view.dialog.stuff.DailyBonus,
            'dialog_rewards': ExGods.view.dialog.stuff.Rewards
        });
        ExGods.Components.addComponentInitializer('dialog', me.initDialogComponent, me);
        ExGods.Components.addComponentInitializer('dialog_rewards', me.initDialogRewardsComponent, me);
        ExGods.Components.addComponentInitializer('dialog_daily_bonus', me.initDialogDailyBonusComponent, me);
        ExGods.Components.addComponentInitializer('dialog_confirm', me.initDialogConfirmComponent, me);
        ExGods.Components.addComponentInitializer('dialog_bot_info', me.initBotInfoComponent, me);
        me.app.getChatConnection().on({
            command_popup: me.onPopupCommand,
            scope: me
        });
    },
    onPopupCommand: function(chatcn, data) {
        var me = this,
            component = ExGods.Components.factory(data.body.popup, {
                popup_params: data.body.params
            });
        if (component && !component.error) {
            if (!me.isBattle()) {
                component.show();
            } else {
                me.popups_queue.push(component);
            }
        }
    },
    isBattle: function() {
        var me = this;
        return me.user.isBattle() || me.app.getController('battle.BattleView').isRendered() || Ext.getCmp('battle-result');
    },
    showPopups: function() {
        var me = this,
            i = me.popups_queue.length;
        while (i--) {
            if (me.popups_queue[i])  {
                me.popups_queue[i].show();
            }
            
            me.popups_queue.splice(i, 1);
        }
    },
    /**
     * @private
     * Обрабатывает клик по боту
     * 
     * @param {Ext.grid.View} view Отображение информации о боте
     * @param {ExGods.model.Monster} bot Запись бота со всей информацией о нём
     */
    onBotClick: function(view, bot) {
        var me = this;
        if (!bot.data.chain) {
            // если не цепочка (цепочка обрабатывается в соотв. контроллере)
            me.showBotDialog({
                image: ExGodsCore.app.references.get('user_shape').getByKey(bot.get('shape')).full,
                description: bot.get('description') || ' ',
                stuff: bot.get('stuff') || ' ',
                stats: bot.get('bot_stats'),
                level: bot.get('level'),
                sec_to_banish: Math.ceil(((bot.data.last_banish + bot.data.cooldown_banish + 1 + ExGods.util.Date.serverTimeOffset) * 1000 - new Date())),
                name_with_level: ExGods.printUser({
                    hoard: {
                        level: bot.get('level')
                    },
                    display_title: bot.get('label')
                }, {
                    fields: 'level,name',
                    maxNameWidth: '180'
                })
            }, false, bot);
        }
    },
    showBotDialog: function(infoData, requestOptions, speaker) {
        var me = this,
            params = {
                ekey: speaker.get('entry')
            },
            source = speaker.get('source'),
            surging = me.app.getController('Surging'),
            location = me.app.getController('Location'),
            callback = function(json) {
                var botList = Ext.getCmp('LOB_BOT_LIST');
                me.dialog.close();
                if (botList && json && json.stuffs) {
                    botList.animatePrize(speaker.get('entry'), json.stuffs, function() {
                        location.unlockUpdate();
                    });
                } else {
                    location.unlockUpdate();
                }
            },
            attackHandlerFn = function() {
                surging.service.command('battle_bot_surging', params, callback);
            },
            surgingHandlerFn = function() {
                location.lockUpdate();
                ExGods.app.block();
                surging.service.command('banish_bot', params, function(json) {
                    ExGods.app.unblock();
                    callback(json);
                });
            },
            bot_power,
            printBotPower = function(stats, level) {
                var userStats = ExGods.app.getUser().get('stats').stats,
                    powers = [],
                    maxStatPower = parseInt(ExGods.ref('constants|max_stat_power').value),
                    minStatPower = parseInt(ExGods.ref('constants|min_stat_power').value),
                    maxLevelPower = parseInt(ExGods.ref('constants|max_level_power').value),
                    minLevelPower = parseInt(ExGods.ref('constants|min_level_power').value),
                    deltaA = stats.agility - userStats.accuracy,
                    deltaB = stats.stamina - userStats.strength,
                    deltaLvl = level - ExGods.app.getUser().get('hoard').level;
                /**
                 * Сравниваем Ловкость монстра и Точность игрока
                 * Разница >= X - сильный монстр
                 * Y <= Разница < X - равный монстр
                 * Разница < Y - слабый монстр
                 * Сравниваем Броню монстра и Силу игрока
                 * Разница >= X - сильный монстр
                 * Y <= Разница < X - равный монстр
                 * Разница < Y - слабый монстр
                 * Сравниваем уровни монстра и игрока
                 * Разница >= M - сильный монстр
                 * N <= Разница < M - равный монстр
                 * Разница < N - слабый монстр
                 * Пишем в интерфейсе самую высокую силу из получившихся.
                 */
                if (deltaA >= maxStatPower) {
                    powers.push(2);
                } else if (deltaA >= minStatPower) {
                    powers.push(1);
                } else {
                    powers.push(0);
                }
                if (deltaB >= maxStatPower) {
                    powers.push(2);
                } else if (deltaB >= minStatPower) {
                    powers.push(1);
                } else {
                    powers.push(0);
                }
                if (deltaLvl >= maxLevelPower) {
                    powers.push(2);
                } else if (deltaLvl >= minLevelPower) {
                    powers.push(1);
                } else {
                    powers.push(0);
                }
                powers = powers.sort();
                var power = bot_power = powers[powers.length - 1];
                if (power == 2) {
                    return '<span style="color:#c6240d">' + ExGods.getMsgByKey('ctrl_dialog_hard_bot') + '</span>';
                } else if (power == 1) {
                    return '<span style="color:#000">' + ExGods.getMsgByKey('ctrl_dialog_normal_bot') + '</span>';
                } else {
                    return '<span style="color:green">' + ExGods.getMsgByKey('ctrl_dialog_easy_bot') + '</span>';
                }
            };
        //если source = quest_... - то бот квестовый - нужно выполнять другие команды
        if (source.substr(0, 5) == 'quest') {
            attackHandlerFn = function() {
                ExGods.Services.get('location').command('attack_quest_bot', params, function(result) {
                    if (result.success) {
                        callback(result);
                    }
                });
            };
            surgingHandlerFn = function() {
                location.lockUpdate();
                ExGods.Services.get('location').command('banish_quest_bot', params, function(result) {
                    if (result.success) {
                        callback(result);
                    }
                });
            };
        }
        var reward_banish = '',
            userMoney = Ext.clone(me.user.get('money'));
        if (speaker.get('reward_banish').length)  {
            reward_banish = '(+ ' + ExGods.util.Stuff.printStuff(speaker.get('reward_banish')[0][0]) + ')';
        }
        
        if (infoData.stats)  {
            infoData.bot_power_text = printBotPower(infoData.stats, infoData.level);
        }
        
        var actionView = [
                {
                    xtype: 'textbutton',
                    cls: 'qh-object double_text_btn x-btn-txt-red',
                    itemId: 'attack_button',
                    margin: '0 0 0 -105',
                    text: speaker.get('battle_id') > 0 ? '<div class="text-btn-image" style="background-image:url(' + ExGods.ref('images|bot_dialog_images').image['text_interfere'] + ')"></div>' : '<div class="text-btn-image" style="background-image:url(' + ExGods.ref('images|bot_dialog_images').image['text_attack'] + ')"></div>',
                    disabled: speaker.get('battle_enable') == 1 ? false : true,
                    handler: bot_power == 2 ? function() {
                        Ext.widget('confirmdialog', {
                            title: '',
                            message: ExGods.ref('message_client|powerful_bot'),
                            handler: attackHandlerFn
                        });
                    } : attackHandlerFn
                },
                {
                    xtype: 'textbutton',
                    margin: '0 0 0 15',
                    text: '<div class="text-btn-image" style="background-image:url(' + ExGods.ref('images|bot_dialog_images').image['text_drive_away'] + ')"></div>',
                    cls: 'qh-object double_text_btn double_text',
                    itemId: 'banish_button',
                    disabled: (infoData.sec_to_banish > 0 || speaker.get('banish_enable') != 1) ? true : false,
                    handler: surgingHandlerFn
                }
            ];
        //      var qh_pointers_attack =
        //          {
        //              xtype: 'container',
        //              html: '<div class="qh-object" data-qh_otype="bot_button_attack" data-qh_oid="'+speaker.data.bot_type+'"></div>',
        //              cls: 'attack_button_pointer_container'
        //          };
        //
        //      var qh_pointers_banish =
        //          {
        //              xtype: 'container',
        //              html: '<div class="qh-object flip-h" data-qh_otype="bot_button_banish" data-qh_oid="'+speaker.data.bot_type+'"></div>',
        //              cls: 'banish_button_pointer_container'
        //          };
        //      var qh_pointers_attack_any =
        //      {
        //          xtype: 'container',
        //          html: '<div class="qh-object" data-qh_otype="bot_button_attack_any" data-qh_oid="1"></div>',
        //          cls: 'attack_button_pointer_container'
        //      };
        //
        //      var qh_pointers_banish_any =
        //      {
        //          xtype: 'container',
        //          html: '<div class="qh-object flip-h" data-qh_otype="bot_button_banish_any" data-qh_oid="1"></div>',
        //          cls: 'banish_button_pointer_container'
        //      };
        if (infoData.sec_to_banish > 0) {
            setTimeout(function() {
                if (me.getBanish())  {
                    me.getBanish().enable();
                }
                
            }, infoData.sec_to_banish);
        }
        var dialogSettings = {
                xtype: 'botdialog',
                info: infoData,
                tplForContent: infoData.greetings_template,
                data: {
                    user: me.getUser().data
                },
                actionsView: actionView,
                id: 'npc-dialog',
                speaker: speaker
            };
        //qh_pointers_attack: qh_pointers_attack,
        //  qh_pointers_banish: qh_pointers_banish,
        //          qh_pointers_attack_any: qh_pointers_attack_any,
        //          qh_pointers_banish_any: qh_pointers_banish_any
        var protos = ExGods.app.getItemPrototypesStore(),
            missedProtos = [];
        for (var i = 0; i < infoData.stuff.length; i++) {
            var type = infoData.stuff[i].type;
            switch (type) {
                case 'item':
                    var proto_id = parseInt(infoData.stuff[i].params.id);
                    item = protos.data.getByKey(proto_id);
                    if (!item) {
                        missedProtos.push(proto_id);
                    };
                    break;
            }
        }
        if (missedProtos.length) {
            ExGods.app.block();
            protos.loadNew(missedProtos, function() {
                ExGods.app.unblock();
                me.dialog = Ext.widget('window2', {
                    autoShow: false,
                    items: [
                        dialogSettings
                    ]
                });
                ExGods.Resources.load(me.dialog, function() {
                    me.dialog.show();
                });
            });
        } else {
            me.dialog = Ext.widget('window2', {
                autoShow: false,
                items: [
                    dialogSettings
                ]
            });
            ExGods.Resources.load(me.dialog, function() {
                me.dialog.show();
            });
        }
    },
    /**
     * Клик по кнопке действия в диалоге с NPC
     */
    onNpcActionButtonClick: function(button) {
        var me = this;
        me.onPointClick(null, button.point);
    },
    initDialogComponent: function(config, componentId) {
        var me = this,
            actions = [];
        for (var i = 1; i < 5; i++) {
            var label = config['btn' + i];
            if (label) {
                var act = config['act' + i];
                var action = {
                        anchor: "100%",
                        text: label,
                        xtype: "textbutton",
                        margin: '0 0 3 0'
                    };
                if (Ext.isObject(act)) {
                    Ext.apply(action, {
                        action: act.id,
                        handler: function() {
                            ExGods.ClientActions.createAndInvoke({
                                actionId: this.action
                            }, null, function(err) {
                                /***/
                                me.log('error', err);
                            });
                        }
                    });
                }
                actions.push(action);
            }
        }
        return Ext.widget('window2', {
            id: componentId,
            items: [
                {
                    xtype: 'dialog',
                    icon: config.icon,
                    itemId: config.itemId,
                    info: {
                        title: config.bot_title,
                        image: config.bot_image,
                        description: config.bot_description
                    },
                    data: {
                        description: config.description
                    },
                    tplForContent: [
                        '<p>{description}</p>'
                    ],
                    actions: actions,
                    close_btn_text: config.close_btn_text
                }
            ]
        });
    },
    initDialogRewardsComponent: function(config, componentId) {
        var me = this,
            bigRewards, wnd,
            rewards = (config.reward || []).concat(config.popup_params || []);
        wnd = Ext.widget('window2', {
            id: componentId,
            layer: 'directions-layer',
            autoShow: false,
            x: 110,
            y: 93
        });
        ExGods.util.Helper.loadProtosFromStuff(rewards, function() {
            var dialog = Ext.widget('dialog_rewards', {
                    config: config,
                    stuff: Ext.Array.map(rewards, function(reward) {
                        return {
                            type: 'dialog_rewards',
                            params: {
                                stuff: reward
                            }
                        };
                    }),
                    buttonClickHandler: function() {
                        wnd.close();
                    }
                });
            wnd.add(dialog);
        });
        return wnd;
    },
    initDialogDailyBonusComponent: function(config, componentId) {
        var me = this,
            bigRewards, wnd,
            stuff = Ext.Array.sort(ExGods.ref('login_days_bonus').getRange(), function(a, b) {
                return a.login_day_index - b.login_day_index;
            });
        wnd = Ext.widget('window2', {
            id: componentId,
            layer: 'directions-layer',
            autoShow: false,
            x: 110,
            y: 93
        });
        ExGods.helpme.loadProtosFromStuff(stuff, function() {
            var dialog = {
                    xtype: 'dialog_daily_bonus',
                    config: config,
                    rewards: stuff,
                    buttonClickHandler: function() {
                        wnd.close();
                    }
                };
            wnd.add(dialog);
            ExGods.Resources.load(wnd, function() {
                wnd.show();
            });
        });
        return wnd;
    },
    initDialogConfirmComponent: function(config, componentId) {
        var me = this,
            wnd, wndConfig,
            getDialogButtons = function(config) {
                var buttons = [];
                if (config.btn1) {
                    buttons.push({
                        xtype: 'textbutton',
                        cls: 'no_border',
                        text: ExGods.app.applyTpl(config.btn1, {
                            u: me.app.user.data
                        }),
                        action: config.act1,
                        handler: doAction,
                        margin: '0 20 0 0'
                    });
                }
                if (config.btn2) {
                    buttons.push({
                        xtype: 'textbutton',
                        cls: 'no_border',
                        text: ExGods.app.applyTpl(config.btn2, {
                            u: me.app.user.data
                        }),
                        action: config.act2,
                        handler: doAction,
                        margin: '0 20 0 0'
                    });
                }
                // кнопка закрытия
                buttons.push({
                    xtype: 'textbutton',
                    text: ExGods.app.applyTpl(config.close_btn_text, {
                        u: me.app.user.data
                    }) || ExGods.getMsgByKey('close_btn_text'),
                    cls: 'x-btn-txt-red no_border',
                    handler: doAction
                });
                return buttons;
            },
            doAction = function(btn) {
                if (btn.action) {
                    ExGods.ClientActions.createAndInvoke({
                        actionId: this.action.id
                    }, function() {
                        wnd.close();
                    }, function(err) {
                        /***/
                        me.log('error', err);
                    });
                } else {
                    wnd.close();
                }
            };
        wndConfig = {
            id: componentId,
            y: config.y || 260,
            width: parseInt(config.width || 320),
            height: parseInt(config.height || 155),
            items: [
                {
                    xtype: 'panel',
                    html: '<div style="padding: 10px 10px 10px 10px; text-align: center;">' + ExGods.app.applyTpl(config.text, {
                        u: me.app.user.data
                    }) + '</div>',
                    buttons: getDialogButtons(config),
                    buttonAlign: 'center'
                }
            ]
        };
        if (config.x) {
            wndConfig.x = config.x;
        }
        wnd = Ext.widget('floatwindow', wndConfig);
        return wnd;
    },
    initBotInfoComponent: function(config, componentId) {
        var dialog = {
                xtype: 'bot_info_dialog',
                config: config
            };
        var panel = Ext.create('Ext.panel.Panel', {
                id: componentId,
                autoShow: false,
                layer: 'directions-layer',
                layout: 'absolute',
                items: [
                    dialog
                ]
            });
        dialog = panel.down('bot_info_dialog');
        ExGods.util.Helper.loadProtosFromStuff(config.data.description_stuff.concat(config.prize || []), function() {
            var update = function() {
                    if (config.prize) {
                        dialog.el.down('.npc_bigPrize').update(ExGods.stuff.StuffManager.image(config.prize));
                    }
                    dialog.el.down('.npc_bigItems').update(ExGods.stuff.StuffManager.image(config.data.description_stuff));
                };
            dialog.on('afterrender', function() {
                update();
            });
            ExGods.Resources.load(panel, function() {
                panel.show();
            });
        });
        dialog.on('close', function() {
            panel.destroy();
        });
        return panel;
    }
});

/**
 * предмет, используемый в магазинах и рынке. По сути отличается отсутствием отображения количества.
 */
Ext.define('ExGods.view.shop.stuff.ShopStuff', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        if (data.decorators) {
            Ext.Array.remove(data.decorators, ExGods.stuff.decorator.Quantity);
        } else  {
            data.decorators = [];
        }
        
        if (me.stuff.locked) {
            data.decorators.push(ExGods.view.shop.stuff.decorator.Locked);
        }
        return data;
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.shop.stuff.decorator.Locked', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var image = ExGods.references.get('images').get('item_locked_status').image['img60'];
            return '<div class="shop-item-locked" style="background-image:url(' + image + ')"></div>';
        }
    }
});

/**
 * комната, фон, кнопка закрыть.
 */
Ext.define('ExGods.view.Room', {
    extend: Ext.panel.Panel,
    alias: 'widget.room',
    plugins: [
        'irondeco'
    ],
    layout: 'absolute',
    x: 5,
    y: 3,
    width: 850,
    height: 420,
    //margin: '0 10 10 0',
    /**
     * @cfg {string} closeCallback (required)
     * Функция, которую нужно вызвать при нажати на кнопку закрыть
     */
    /**
     * @cfg {string} backgroundImage (required)
     * Урл Фоновой картинки, без анкора
     */
    /**
     * @cfg {string} emptySearchText (required)
     * Текст пустого фильтра
     */
    /**
     * @cfg {string} closeText (required)
     * Текст кнопки закрытия
     */
    /**
     * @cfg {string} rightPanelX (required)
     * Отсуп от левого края для центрирования "кнопки закрытия" и "пустого текста" по середине правой панели.
     */
    initComponent: function() {
        var me = this;
        me.style = {
            backgroundImage: "url(" + IMAGE_URL + me.backgroundImage + ")",
            // backgroundSize: "100% auto",
            backgroundRepeat: "no-repeat",
            backgroundPosition: '5px'
        };
        me.items.push(me.initButtonsPanel(), {
            xtype: 'panel',
            layout: 'anchor',
            y: 195,
            x: me.rightPanelX,
            hidden: true,
            itemId: 'search_empty_message',
            style: {
                textAlign: 'center',
                color: '#ECDBC7',
                fontSize: 20
            },
            html: '<div>' + me.emptySearchText + '</div>'
        });
        me.callParent();
    },
    initButtonsPanel: function() {
        var me = this,
            buttons = [];
        if (me.closeText) {
            buttons.push({
                itemId: 'back_in_town',
                text: me.closeText,
                cls: ((me.closeColor) ? 'qh-object x-btn-txt-' + me.closeColor : 'qh-object') + (me.closeBtnUI && me.closeBtnUI == 'stone' ? ' stone_btn' : ''),
                handler: function(btn) {
                    me.closeCallback();
                }
            });
        }
        if (me.buttons) {
            buttons = buttons.concat(me.buttons);
        }
        delete me.buttons;
        return {
            xtype: 'panel',
            layout: 'anchor',
            y: 373,
            x: me.rightPanelX,
            maxWidth: 581,
            cls: 'body_overflow_visible',
            style: {
                textAlign: 'center',
                overflow: 'visible'
            },
            defaults: {
                xtype: 'textbutton',
                height: me.closeBtnUI == 'stone' ? 42 : 30,
                cls: me.closeBtnUI && me.closeBtnUI == 'stone' ? ' stone_btn' : ''
            },
            items: buttons
        };
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + me.backgroundImage,
                me.closeText
            ]
        };
    }
});

/**
 * Вкладки магазина
 *
 * Каждый магазин занимает отдельную вкладку.
 */
Ext.define('ExGods.view.shop.ShopTabs', {
    extend: Ext.container.Container,
    alias: 'widget.shoptabs',
    /**
     * @cfg {ExGods.model.User} user
     * Текущий пользователь
     */
    /**
     * @cfg {} activeShopId ID магазина, вкладка которого должна быть открыта первой
     */
    /**
     * @property {Ext.data.Store} shops
     * Храналище магазинов
     */
    initComponent: function() {
        var me = this;
        me.shops = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.Shop'
        });
        // фильтр доступных предметов
        me.availabilityFilter = new Ext.util.Filter({
            filterFn: function(item) {
                var level = parseInt(me.user.getLevel()),
                    proto = item.data.item_proto;
                return level >= proto.data.data.strict.level;
            }
        });
        me.items = [
            {
                xtype: 'room',
                backgroundImage: me.backImg,
                emptySearchText: me.emptySearchText,
                closeText: me.closeText,
                closeColor: me.closeColor,
                closeCallback: function() {
                    me.fireEvent('close');
                },
                rightPanelX: 250,
                items: [
                    {
                        xtype: 'panel',
                        id: 'shop-window-container',
                        width: 230,
                        height: 380,
                        margin: '15 0 0 5'
                    },
                    {
                        xtype: 'skintabpanel',
                        activeTab: 0,
                        x: 242,
                        y: 10,
                        width: 580,
                        height: 363,
                        closable: true,
                        listeners: {
                            beforeclose: {
                                fn: function() {
                                    me.fireEvent('close');
                                    return false;
                                }
                            }
                        },
                        plugins: [
                            'skindeco',
                            {
                                ptype: 'pager',
                                marginLeft: -27,
                                marginRight: -27,
                                top: 164
                            }
                        ],
                        padding: '0 0 35 0'
                    },
                    {
                        xtype: 'form',
                        x: 530,
                        y: 20,
                        width: 270,
                        height: 30,
                        tbar: {
                            xtype: 'panel',
                            bodyCls: 'parchment-content-nop',
                            bodyPadding: 0,
                            defaults: {
                                margin: '0 1'
                            },
                            height: 30,
                            items: [
                                {
                                    xtype: 'checkboxfield',
                                    boxLabel: ExGods.getMsgByKey('view_shop_tabs_avail'),
                                    checked: true,
                                    itemId: 'availability',
                                    style: {
                                        color: '#e3ac69'
                                    },
                                    listeners: {
                                        change: function() {
                                            me.updateFilters('level');
                                        },
                                        scope: me
                                    },
                                    margin: '0 10 0 0'
                                },
                                {
                                    xtype: 'tbfill'
                                },
                                {
                                    xtype: 'textfield',
                                    emptyText: ExGods.getMsgByKey('view_shop_tabs_seachbyname'),
                                    itemId: 'title',
                                    cls: 'text-search-input',
                                    listeners: {
                                        change: {
                                            fn: function() {
                                                me.updateFilters('text');
                                            },
                                            buffer: 100
                                        },
                                        scope: me
                                    },
                                    padding: 1,
                                    value: ''
                                }
                            ],
                            layout: 'hbox',
                            margin: '0 16 5 0'
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
        Ext.Array.forEach(me.query('#shop-view'), function(cmp) {
            cmp.relayEvents(cmp.up(), [
                'show'
            ]);
        });
        me.mon(me.user, {
            levelchanged: me.onLevelChanged,
            scope: me
        });
    },
    /**
     * Обновить вью в соответствии с данными
     * @param {Object} data Данные магазина
     */
    setData: function(data) {
        var me = this,
            tabsPanel = me.down('skintabpanel'),
            tabs = [],
            activeTab = 0;
        me.shopsData = Ext.clone(data);
        me.shops.loadRawData(data);
        me.shops.each(function(shop, index) {
            if (me.activeShopId == shop.get('entry')) {
                activeTab = index;
            }
            tabs.push({
                padding: '0 0 0 10',
                shop: shop,
                tabConfig: {
                    xtype: 'skintab',
                    icon: IMAGE_URL + shop.getIcon('normal'),
                    tooltip: shop.get('name'),
                    cls: 'qh-object',
                    id: 'shop-tab-' + index
                },
                items: [
                    {
                        xtype: 'shop',
                        itemId: 'shop-view',
                        store: shop.items(),
                        filterByLevel: true,
                        emptyText: me.emptySearchText
                    }
                ]
            });
        });
        ExGods.Resources.load({
            items: {
                items: tabs
            },
            getResources: function() {
                var me = this;
                return {
                    images: []
                };
            }
        }, function() {
            tabsPanel.removeAll();
            tabsPanel.add(tabs);
            tabsPanel.setActiveTab(activeTab);
            Ext.apply(tabsPanel.pager, {
                current: 1,
                currentTab: 0,
                total: Math.ceil(me.shops.first().items().data.items.length / 6),
                //тут надо задать количество страниц во вкладке
                totalTabs: tabsPanel.items.length
            });
            tabsPanel.on('beforetabchange', function(tabPanel, newShop, oldShop) {
                me.clearSearch();
            });
            tabsPanel.on('tabchange', function(tabPanel, newShop, oldShop) {
                me.updatePager();
            });
        });
    },
    /**
     * Очишаем поиск при переключении
     * @private
     */
    clearSearch: function() {
        var me = this;
        if (me.down('#title').getValue()) {
            me.down('#title').setValue('');
            me.updateFilters("text");
        }
    },
    /**
     * Обработчки изменения уровня игрока. Вызывает обновление фильтров
     */
    onLevelChanged: function() {
        var me = this;
        Ext.Array.forEach(me.query('#shop-view'), function(cmp) {
            cmp.setFilters();
        });
    },
    /**
     * Обновляет фильтры у магазинов
     */
    updateFilters: function(filterName) {
        var me = this,
            tab = me.down('skintabpanel').getActiveTab(),
            dataview = tab.down('dataview'),
            store = dataview.getStore(),
            searchText = Ext.String.trim(me.down('#title').getValue()),
            checked = me.down('#availability').getValue(),
            allItemsStore = Ext.create('ExGods.store.ShopItems'),
            allItems = [];
        if (filterName == 'level') {
            Ext.Array.forEach(me.query('#shop-view'), function(cmp) {
                cmp.setFilterByLevel(checked);
            });
        } else if (filterName == 'text') {
            // если есть текстовый фильтр, то нахожу все предметы и показываю их на текущей вкладке, подменяя хранилище магазина.
            // иначе - удаляю фильтрованное хранилище и ставлю оригинальное
            if (searchText) {
                if (!dataview.allItemsStore) {
                    me.shopsData.forEach(function(data) {
                        allItems = allItems.concat(data.items);
                    });
                    allItemsStore.loadRawData(allItems);
                    dataview.originStore = dataview.store;
                    dataview.allItemsStore = allItemsStore;
                    dataview.bindStore(allItemsStore);
                }
            } else {
                if (dataview.allItemsStore) {
                    dataview.allItemsStore = undefined;
                    dataview.bindStore(dataview.originStore);
                }
            }
            dataview.setTextFilter(searchText);
        }
        me.updatePager();
    },
    updatePager: function() {
        var me = this;
        //вычисляем количество страниц (на страницу по 6 вещей, поэтому делим общее кол-во вещей на 6)
        var length = me.down('skintabpanel').getActiveTab().down('dataview').getStore().data.items.length;
        if (length)  {
            var total = Math.ceil(length / 6);
        }
        else  {
            total = 1;
        }
        
        Ext.apply(me.down('skintabpanel').pager, {
            current: 1,
            currentTab: me.down('skintabpanel').items.findIndex('id', me.down('skintabpanel').getActiveTab().id),
            total: total
        });
        me.down('skintabpanel').pager.refresh();
    }
});

/**
 * Управление магазином
 */
Ext.define('ExGods.controller.Shop', {
    extend: ExGodsCore.controller.Base,
    models: [
        'ShopItem'
    ],
    views: [
        'shop.ShopTabs'
    ],
    refs: [
        {
            /**
         * @method getShopTabs
         * Получет главный фрейм
         * @return {Ext.container.Container}
         */
            ref: 'shopTabs',
            selector: 'shoptabs'
        }
    ],
    init: function() {
        var me = this;
        me.control({
            'shop': {
                itemclick: {
                    fn: me.onShopItemClick,
                    delay: 0
                }
            },
            'shoptabs skintabpanel': {
                next: me.showNextPage,
                prev: me.showPrevPage
            }
        });
        me.app.getChatConnection().on({
            scope: me
        });
        ExGods.app.on({
            'quest_finish': me.updateShop,
            scope: me
        });
        ExGods.stuff.StuffManager.register({
            'shop_stuff': ExGods.view.shop.stuff.ShopStuff
        });
        ExGods.Components.addComponentInitializer('shop', me.initShopComponent, me);
    },
    showNextPage: function(pager) {
        if (pager.current > pager.total) {
            this.getShopTabs().clearSearch();
            pager.currentTab++;
            pager.cmp.setActiveTab(pager.currentTab);
            pager.current = 1;
            total = Math.ceil(this.getShopTabs().down('skintabpanel').getActiveTab().down('dataview').getStore().data.length / 6);
            if (!total)  {
                total = 1;
            }
            
            pager.total = total;
        } else {
            this.openPage(+1);
        }
        pager.refresh();
    },
    showPrevPage: function(pager) {
        var me = this;
        if (pager.current < 1) {
            this.getShopTabs().clearSearch();
            pager.currentTab--;
            pager.cmp.setActiveTab(pager.currentTab);
            total = Math.ceil(this.getShopTabs().down('skintabpanel').getActiveTab().down('dataview').getStore().data.length / 6);
            if (!total)  {
                total = 1;
            }
            
            pager.current = total;
            pager.total = total;
            setTimeout(function() {
                me.openLastPage(pager.total);
            }, 0);
        } else {
            this.openPage(-1);
        }
        pager.refresh();
    },
    openPage: function(direction) {
        var ul = this.getShopTabs().down('skintabpanel').getActiveTab().down('dataview').getEl().down('.shop-items'),
            margin_top = parseInt(ul.getStyle('margin-top').split('p')[0]),
            page_height = parseInt(this.getShopTabs().down('skintabpanel').getActiveTab().getEl().getStyle('height').split('p')[0]);
        //сдвигаем список в НАПРАВЛЕНИЕ на длинну ВЫСОТА_СТРАНИЦЫ
        ul.setStyle('margin-top', margin_top + -1 * direction * (page_height - 1) + 'px');
    },
    openLastPage: function(total) {
        var ul = this.getShopTabs().down('skintabpanel').getActiveTab().down('dataview').getEl().down('.shop-items'),
            page_height = this.getShopTabs().down('skintabpanel').getActiveTab().getEl().getStyle('height').split('p')[0];
        //сдвигаем список вверх на ВЫСОТА_СТРАНИЦЫ умноженная на МАКСИМАЛЬНО_СТРАНИЦ
        ul.setStyle('margin-top', -1 * (page_height - 1) * (total - 1) + 'px');
    },
    onShopItemClick: function(itemView, shopItem, itemEl, zero, event) {
        var me = this;
        if (event.getTarget('.x-btn')) {
            if (shopItem.get('params').variable_count) {
                me.showQuantityDialog(shopItem, function(quantity) {
                    me.buyItem(shopItem, quantity, itemView.ownerCt.shopService);
                });
            } else {
                me.buyItem(shopItem, 1, itemView.ownerCt.shopService);
            }
            event.stopPropagation();
        }
    },
    /**
     * Покупка предмета  
     */
    buyItem: function(shopItem, quantity, service) {
        var me = this,
            ask_service = null,
            items = [],
            kits = [],
            proto,
            _buyItem = function() {
                if (shopItem.data.kit) {
                    kits.push({
                        count: quantity,
                        kit: shopItem.get('entry')
                    });
                } else {
                    items.push({
                        count: quantity,
                        item: shopItem.get('entry')
                    });
                }
                ExGods.app.block();
                service.command('shop_buy', {
                    basket: Ext.JSON.encode([
                        {
                            items: items,
                            kits: kits,
                            shop: shopItem.data.shop_id
                        }
                    ])
                }, function(json) {
                    ExGods.app.unblock();
                    if (shopItem.data.params.ask_service) {
                        service.update(null);
                    }
                });
            };
        service = service || me.service;
        quantity = quantity || 1;
        proto = shopItem.data.item_proto;
        if (parseInt(me.getUser().getLevel()) < parseInt(proto.data.data.strict.level)) {
            Ext.widget('confirmdialog', {
                message: ExGods.getMsgByKey("shop_buy_high_level_confirm"),
                handler: function() {
                    _buyItem(shopItem);
                }
            });
        } else {
            _buyItem(shopItem);
        }
    },
    updateShop: function(json) {
        var me = this,
            shopLocation = me.getShopTabs(),
            instances = json.instances;
        if (shopLocation && Ext.isArray(instances)) {
            Ext.Array.each(instances, function(instance) {
                if (instance.type == 'shop') {
                    me.updateShopsItems(instance.data);
                }
            });
        }
    },
    updateShopsItems: function(shopsData) {
        var me = this,
            shops = me.getShopTabs().shops;
        Ext.Array.forEach(shopsData, function(shopData) {
            var shop = shops.getById(parseInt(shopData.entry));
            shop.set('items', shopData.items);
        });
    },
    getMissedProtos: function() {
        var me = this,
            shops = me.service.data.shops,
            missedProtos = [];
        shops.forEach(function(shop) {
            missedProtos = missedProtos.concat(ExGods.model.Shop.getMissedProtos(shop));
        });
        return missedProtos;
    },
    initShopComponent: function(config, componentId) {
        var me = this,
            wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        me.service.on('update', me.onServiceUpdate, me);
        Ext.apply(config, {
            user: me.user,
            listeners: {
                close: {
                    fn: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            wnd.close();
                        }, {
                            img: config.backImg
                        });
                        return false;
                    },
                    single: true
                }
            }
        });
        if (config.clientAction && config.clientAction.options.shop) {
            config.activeShopId = config.clientAction.options.shop.shop_id;
        }
        Ext.Array.forEach(me.service.data.shops, function(shop) {
            Ext.Array.forEach(shop.items, function(item) {
                if (item.discount_ended)  {
                    me.startDiscountTimer(item.discount_ended);
                }
                
            });
        });
        cmp = Ext.apply({
            xtype: 'shoptabs'
        }, config);
        wnd = Ext.widget('window1', {
            id: componentId,
            items: [
                cmp
            ],
            autoShow: false
        });
        cmp = wnd.down('shoptabs');
        cmp.on('destroy', function() {
            clearInterval(me.discountwait);
            delete me.discountwait;
        });
        // подгрузка прототипов предметов и ресурсов
        var protos = ExGods.app.getItemPrototypesStore(),
            missedProtos = me.getMissedProtos();
        ExGods.app.getController('Location').maskLocation(function() {
            protos.loadNew(missedProtos, function() {
                cmp.setData(me.service.data.shops);
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.backImg
        });
        return wnd;
    },
    onServiceUpdate: function() {
        var me = this,
            tabs = me.getShopTabs(),
            panel = tabs ? tabs.down('skintabpanel') : null;
        ExGods.app.getItemPrototypesStore().loadNew(me.getMissedProtos(), function() {
            var shops = me.getShopTabs().shops;
            if (shops && shops.totalCount) {
                Ext.Array.forEach(me.service.data.shops, function(shopData, index) {
                    //допускаю, что индекс магазина, ввиду отсутствия сортировки, всегда верный.
                    var shop = shops.getAt(index);
                    if (shop) {
                        shop.set('items', shopData.items);
                    }
                });
            }
        });
        if (panel) {
            panel.pager.current = 1;
            panel.pager.refresh();
        }
    },
    startDiscountTimer: function(end_time) {
        var me = this;
        me.discountwait = setInterval(function() {
            var currTime = new Date(ExGods.util.Date.normalizeServerDateTime(end_time)) / 1 - new Date() / 1;
            if (currTime < -1) {
                clearInterval(me.discountwait);
                delete me.discountwait;
                me.onRefreshDiscount();
            }
        }, 1000);
    },
    onRefreshDiscount: function() {
        var me = this;
        if (me.service) {
            me.service.update(null, function() {
                ExGods.app.getItemPrototypesStore().loadNew(me.getMissedProtos(), function() {
                    var shops = me.getShopTabs().shops;
                    if (shops && shops.totalCount) {
                        Ext.Array.forEach(me.service.data.shops, function(shopData, index) {
                            //допускаю, что индекс магазина, ввиду отсутствия сортировки, всегда верный.
                            var shop = shops.getAt(index);
                            if (shop)  {
                                shop.set('items', shopData.items);
                            }
                            
                        });
                    }
                });
            });
        }
    },
    /**
     * Показывает диалог выбора кол-ва покупаемого предмета
     */
    showQuantityDialog: function(shopItem, callback) {
        var me = this;
        var cmp = Ext.widget('progressdialog', {
                title: shopItem.getTitle(),
                image: shopItem.getImage(),
                label: ExGods.getMsgByKey('shop_quantity_dialog_input_text'),
                min: 1,
                max: ExGods.ref('constants|shop_max_quantity').value,
                value: 1,
                inputWidth: 75,
                autoShow: false,
                handler: callback,
                buttonsText: [
                    ExGods.getMsgByKey('shop_buy_btn_text'),
                    ExGods.getMsgByKey('shop_quantity_dialog_no_btn_text')
                ],
                value_dependent_text: [
                    Ext.String.format(ExGods.getMsgByKey('shop_quantity_dialog_price_text'), '{[this.printPrice(values)]}'),
                    {
                        printPrice: function(values) {
                            var price = shopItem.get('price');
                            if (Ext.isArray(price)) {
                                price = price[0];
                            }
                            return ExGods.util.Format.printMoney({
                                name: price.name,
                                value: price.value * values.value
                            });
                        }
                    }
                ]
            });
        ExGods.Resources.load(cmp, function() {
            cmp.show();
        });
    }
});

/**
 * Базовый класс для представления сетки элементов
 */
Ext.define('ExGods.view.grid.Grid', {
    extend: Ext.panel.Panel,
    alias: 'widget.exg_grid',
    requires: [],
    //
    /**
     * @cfg {Number} rowsCount Кол-во строк грида    
     */
    rowsCount: 4,
    /**
     * @cfg {Number} columnsCount Кол-во столбцов грида  
     */
    columnsCount: 4,
    /**
      * @cfg {Number} Ширина ячейки
      */
    cellWidth: 64,
    /**
      * @cfg {Number} Высота ячейки
      */
    cellHeight: 64,
    /**
     * @cfg {Ext.data.Store} store Хранилище элементов грида
     */
    store: null,
    /**
     * @cfg {String} itemTpl Шаблон элемента грида
     */
    itemTpl: '',
    /**
     * @cfg {String} itemSelector Селектор элемента грида
     */
    itemSelector: '.exg-grid-item',
    /**
     * Сообщение, которое показывается когда нет элементов 
     */
    emptyText: null,
    /**
     * Конфиг пейджера
     */
    pager: null,
    /**
     * @property itemsView {Ext.view.View} DataView грида
     */
    itemsView: null,
    layout: 'fit',
    initComponent: function() {
        var me = this,
            ct;
        me.cls = me.cls ? me.cls + ' slotsgrid' : 'slotsgrid';
        me.calcWidth();
        me.initItemTemplate();
        me.itemsView = Ext.widget('dataview', {
            collectData: Ext.Function.bind(me.collectData, me),
            itemSelector: me.itemSelector,
            store: me.store,
            emptyText: me.emptyText ? '<div class="exg-grid-empty-msg">' + me.emptyText + '</div>' : '',
            deferEmptyText: false,
            tpl: [
                '<div class="exg-grid-inner" style="width: {[ this.getInnerWidth() ]}px; height: {[ this.getInnerHeight() ]}px;">',
                '<ul class="exg-grid-items">',
                '<tpl for=".">',
                '<li class="exg-grid-item" style="width: ' + me.cellWidth + 'px; height: ' + me.cellHeight + 'px;">',
                '{[ this.printItem(values) ]}',
                '</li>',
                '</tpl>',
                '</ul>',
                '<div class="x-clear"></div>',
                '</div>',
                {
                    getInnerWidth: function() {
                        return me.cellWidth * me.columnsCount;
                    },
                    getInnerHeight: function() {
                        return me.cellHeight * me.rowsCount;
                    },
                    printItem: function(data) {
                        return me.itemTpl.apply(data);
                    }
                }
            ],
            listeners: {
                refresh: function() {
                    var pager = me.getPager();
                    if (pager) {
                        pager.total = me.getTotalPagesCount();
                        if (pager.current > pager.total) {
                            pager.current = pager.total;
                        }
                        pager.cmp.openPage(pager.current);
                        pager.refresh();
                    }
                }
            }
        });
        ct = {
            xtype: 'container',
            layout: 'fit',
            items: me.itemsView,
            plugins: []
        };
        if (me.pager) {
            me.initPager(ct);
        }
        me.items = [
            ct
        ];
        me.callParent();
        me.on({
            show: me.showPager,
            hide: me.hidePager,
            scope: me
        });
        me.relayEvents(me.itemsView, [
            'itemclick',
            'refresh',
            'resize',
            'viewready'
        ]);
    },
    /**
     * Показать пейджер
     */
    showPager: function() {
        var me = this,
            pager = me.getPager();
        if (pager && pager.isVisible()) {
            pager.showArrows();
        }
    },
    /**
     * Скрыть пейджер
     */
    hidePager: function() {
        var me = this,
            pager = me.getPager();
        if (pager) {
            pager.hideArrows();
        }
    },
    /********************** PROTECTED ********************/
    /**
     * Рассчитывает ширину компонента при инициализации. Можно переопределять в произвоздном классе
     */
    calcWidth: function() {
        var me = this;
        me.width = me.cellWidth * me.columnsCount;
    },
    /**
     * Инициализация шаблона для элемента грида
     */
    initItemTemplate: function() {
        var me = this;
        me.itemTpl = new Ext.XTemplate(me.itemTpl);
    },
    /**
     * Вернет объект пейджера
     */
    getPager: function() {
        return this.items.items[0].pager;
    },
    // вернет кол-во страниц 
    getTotalPagesCount: function() {
        var me = this;
        return Math.ceil(me.store.getCount() / (me.rowsCount * me.columnsCount)) || 1;
    },
    /**
     * Стандартный метод DataView. Можно переопределять в произодных классах
     */
    collectData: function(records) {
        var me = this,
            data = [];
        records.forEach(function(record) {
            data.push(record.data);
        });
        return data;
    },
    /**
     * Конфигурирует пейджер
     */
    configPager: function() {
        var me = this;
        me.pager = Ext.apply({
            ptype: 'pager',
            marginLeft: -36,
            marginRight: -36,
            top: (me.rowsCount * me.cellHeight) / 2 - 25,
            /** 25 - половина высоты стрелки пейджера */
            textLeft: me.width / 2 - 112 / 2,
            /* 112 - ширина плашки*/
            textTop: me.cellHeight * me.rowsCount + 8,
            /** 8 - отступ от нижнего края */
            total: me.getTotalPagesCount()
        }, me.pager);
        return me.pager;
    },
    /**
     * Инициализация пейджера
     */
    initPager: function(ct) {
        var me = this;
        ct.plugins.push(me.configPager());
        ct.prevPage = function(pager) {
            ct.openPage(pager.current);
            pager.refresh();
        };
        ct.nextPage = function(pager) {
            ct.openPage(pager.current);
            pager.refresh();
        };
        ct.openPage = function(pageIndex) {
            var ul = me.getEl().down('.exg-grid-items');
            ul.setStyle('margin-top', '-' + ((pageIndex - 1) * me.rowsCount * me.cellHeight) + 'px');
        };
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Грид с подложкой под предметы
 */
Ext.define('ExGods.view.grid.SlotsGrid', {
    extend: ExGods.view.grid.Grid,
    alias: 'widget.slotsgrid',
    cls: 'exg-grid-slots',
    cellWidth: 64,
    cellHeight: 64
});

/**
 * Грид с подложкой под предметы обрамленный фреймом с железкой
 */
Ext.define('ExGods.view.grid.FramedSlotsGrid', {
    extend: ExGods.view.grid.SlotsGrid,
    alias: 'widget.framedslotsgrid',
    /**
     * @cfg headerText {String} Заголовок, отображаемый на железке
     */
    headerText: '',
    initComponent: function() {
        var me = this;
        if (me.plugins) {
            me.plugins.push('inventory_frame');
        } else {
            me.plugins = [
                'inventory_frame'
            ];
        }
        me.callParent(arguments);
    },
    /**
     * @override
     */
    calcWidth: function() {
        var me = this;
        me.callParent(arguments);
        me.width += 20;
    }
});
// 

/**
 * Позволяет добавлять подсветку к элементу вью
 */
Ext.define('ExGods.mixin.Highlightable', {
    /**
     * Включить подсветку
     */
    highlight: function(lightOn) {
        var me = this,
            target = me.getHighlitableTarget();
        if (target) {
            if (lightOn) {
                if (!target.hasCls('exg-highlighted')) {
                    target.addCls('exg-highlighted');
                    target.insertHtml('beforeEnd', '<div class="exg-highlighted-inner"></div>');
                }
            } else if (target.hasCls('exg-highlighted')) {
                target.removeCls('exg-highlighted');
                target.down('.exg-highlighted-inner').remove();
            }
        }
    },
    /**
     * Вернет элемент, который должен быть подсвечен. По дефолту - элемент вьюшки
     */
    getHighlitableTarget: function() {
        var me = this;
        if (me.rendered) {
            return me.getEl();
        }
    }
});

/**
 * Общий слот для предметов
 */
Ext.define('ExGods.view.item.InventorySlot', {
    extend: ExGods.view.grid.FramedSlotsGrid,
    alias: 'widget.iteminventoryslot',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.InventoryDragHighlight,
        ExGods.mixin.Highlightable
    ],
    /**
     * @cfg {ExGods.store.Slots} slots (required)
     * Слоты экипировки, заданий, зелей и артефактов
     */
    /**
     * @cfg {Object} sorter Объект сортировщика инвентаря
     */
    /**
     * @cfg canDragItems Признак, что предметы могут быть переносимы drag-and-drop'ом
     */
    canDragItems: true,
    initComponent: function() {
        var me = this,
            view,
            i = 0;
        me.stuffs = [];
        me.cls += ' inventory-slot';
        me.sorter = me.sorter || new ExGods.view.inventory.InventorySorter({
            user: ExGods.app.user
        });
        me.sorter.on('refresh', function() {
            me.store.sort();
        }, me);
        me.store = Ext.create('Ext.data.Store', {
            model: 'ExGodsCore.model.Item',
            sorters: me.sorter.getSorters()
        });
        var bufferedRefreshSlotItems = Ext.Function.createBuffered(me.refreshSlotItems, 100);
        Ext.Array.each(me.slots, function(slot) {
            me.mon(slot, {
                highlight: me.highlight.bind(me, true),
                unhighlight: me.highlight.bind(me, false),
                scope: me
            });
            me.store.add(slot.get('items').data.items);
            me.mon(slot.items(), 'datachanged', bufferedRefreshSlotItems, me);
            me.mon(slot.items(), 'refresh', bufferedRefreshSlotItems, me);
            var itms = slot.get('items').data.items;
            for (var i = 0; i < itms.length; i++) {
                me.stuffs.push({
                    // добавляем стафф который используется для предзагрузки ресурсов
                    params: {
                        id: itms[i].data.proto_id,
                        quantity: itms[i].data.count
                    },
                    type: 'item'
                });
            }
        });
        me.itemTpl = [
            '{[this.getStuff(values)]}',
            {
                getStuff: function(values) {
                    return ExGods.stuff.StuffManager.image(values);
                }
            }
        ];
        me.callParent();
        me.view = me.down('dataview');
        me.view.slot = me.slot;
        me.view.on('render', me.initDragAndDrop, me);
    },
    collectData: function(records) {
        return Ext.Array.map(records, function(record) {
            return {
                type: 'inventory_item',
                params: {
                    itemModel: record
                }
            };
        });
    },
    /**
     * @private
     * D&D предметов
     */
    initDragAndDrop: function(view) {
        var me = this,
            itemController = ExGods.app.getController('Item');
        if (me.canDragItems) {
            me.initDrag({
                view: view,
                cancelFn: function() {
                    ExGods.app.user.slots().each(function(slot) {
                        if (slot.getSlotType().active == 0)  {
                            slot.fireEvent('unhighlight', slot);
                        }
                        
                    });
                }
            });
        }
        me.initDrop({
            onDrop: function(target, dd, e, data) {
                if (Ext.getClassName(data.item) == 'ExGodsCore.model.Item' && !view.getNode(data.item)) {
                    itemController.takeOff(data.item, data.cancel);
                    return true;
                } else if (Ext.getClassName(data.item) == 'ExGods.model.WareHouseStuff') {
                    ExGods.app.getController('inventory.VirtualStore').doPutItems(data.item, false, data.cancel);
                    return true;
                } else  {
                    return false;
                }
                
            }
        });
        me.initDragHighlight();
    },
    refreshSlotItems: function() {
        var me = this,
            store = me.store;
        store.removeAll();
        Ext.Array.each(me.slots, function(slot) {
            store.add(slot.get('items').data.items);
        });
        store.filter();
        store.sort();
    },
    /**
     * mixin override
     */
    getHighlitableTarget: function() {
        var me = this,
            dataview = me.down('dataview');
        if (dataview.rendered) {
            return dataview.getEl();
        }
    },
    destroy: function() {
        var me = this;
        me.sorter.destroy();
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: me.stuffs || [],
            images: [
                IMAGE_URL + 'pager/btn_left.png',
                IMAGE_URL + 'pager/btn_right.png',
                IMAGE_URL + 'pager/btn_right_bg.png',
                IMAGE_URL + 'pager/btn_left_bg.png',
                IMAGE_URL + 'slots/slot_regular.jpg',
                // Рамки
                IMAGE_URL + 'inventory/frm_top_left.jpg',
                IMAGE_URL + 'inventory/frm_top_center.jpg',
                IMAGE_URL + 'inventory/frm_top_right.jpg',
                IMAGE_URL + 'inventory/frm_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_center.jpg',
                IMAGE_URL + 'inventory/frm_bottom_left.jpg',
                IMAGE_URL + 'inventory/frm_left.jpg',
                IMAGE_URL + 'inventory/frm_top.png',
                IMAGE_URL + 'page_num.png',
                IMAGE_URL + 'button-text-30.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Общий слот для предметов
 */
Ext.define('ExGods.view.item.Slot', {
    alias: 'widget.itemslot',
    extend: Ext.Component,
    mixins: [
        ExGods.mixin.Highlightable
    ],
    cls: 'x-btn itemslot',
    /**
     * @cfg {Object} slot (required)
     * Слот для предметов
     */
    initComponent: function() {
        var me = this;
        me.style = {
            backgroundImage: me.getBackgroundImage()
        };
        me.data = me.prepareData();
        me.tpl = [
            '<tpl if="item">',
            '{[this.getStuff(values.item)]}',
            '</tpl>',
            {
                getStuff: function(item) {
                    return ExGods.stuff.StuffManager.image(item);
                }
            }
        ];
        me.callParent();
        me.mon(me.slot.items(), {
            datachanged: me.updateItem,
            load: me.updateItem,
            scope: me
        });
        me.mon(me.slot, {
            protect: me.updateItem,
            highlight: me.highlight.bind(me, true),
            unhighlight: me.highlight.bind(me, false),
            scope: me
        });
    },
    updateItem: function() {
        var me = this;
        data = me.prepareData();
        me.update(data);
        me.initTooltips();
        me.el.setStyle({
            backgroundImage: me.getBackgroundImage()
        });
    },
    prepareData: function() {
        var me = this,
            item = me.slot.items().data.items[0],
            data = {};
        if (item) {
            me.stuff = {
                // добавляем стафф который используется для предзагрузки ресурсов
                params: {
                    id: item.data.proto_id,
                    quantity: 1
                },
                //title
                type: 'item'
            };
            data.item = {
                type: 'item_slot',
                params: {
                    slot: me.slot,
                    itemModel: item
                }
            };
        }
        return data;
    },
    getRecord: function() {
        return this.slot.items().data.items[0];
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.initTooltips();
        //добавляю эвент click
        me.el.on('click', function(e) {
            me.fireEvent('click', me, me.slot, e);
        });
    },
    getBackgroundImage: function() {
        var me = this,
            background;
        if (me.slot.get('protect')) {
            background = 'url(' + IMAGE_URL + 'slots/new/frm.png), ' + 'url(' + ExGods.ref('slot_type|' + me.slot.get('type')).images.prot + ')';
        } else {
            background = 'url(' + ExGods.ref('slot_type|' + me.slot.get('type')).images.empty + ')';
        }
        return background;
    },
    initTooltips: function() {
        var me = this;
        if (me.slot.items().getCount()) {
            ExGods.Tooltips.removeTip(me.el);
        } else {
            ExGods.Tooltips.makeElementAsTip(me.el, 'slot', me.slot.data.ekey);
        }
    }
});

/**
 * Общий слот для предметов
 */
Ext.define('ExGods.view.item.DollSlot', {
    extend: ExGods.view.item.Slot,
    alias: 'widget.dollslot',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.InventoryDragHighlight
    ],
    cls: 'qh-object active-slot',
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        if (me.user == ExGods.app.user) {
            me.initDrag();
            me.initDragHighlight();
        }
        me.el.set({
            'data-qh_otype': 'active_slot',
            'data-qh_oid': me.slot.get('type')
        });
        if (!me.x) {
            me.el.set({
                'data-qh_opts': '{&quot;cls&quot;:&quot;flip-h&quot;}'
            });
        }
    }
});

/**
 * Сортировщик инвентаря. Сортировка инвентаря определяется настройками пользователя
 * "inventory_sort_by_name", "inventory_sort_by_dur".
 */
Ext.define('ExGods.view.inventory.InventorySorter', {
    extend: Ext.util.Observable,
    /**
     * @cfg {ExGods.model.User} user
     */
    constructor: function() {
        var me = this;
        me.callParent(arguments);
        me.sortByName = parseInt(me.user.getSetting('inventory_sort_by_name') || 0);
        me.sortByDur = parseInt(me.user.getSetting('inventory_sort_by_dur') || 0);
        me.sortFn = function(o1, o2) {
            var proto1 = o1.getProto(),
                proto2 = o2.getProto(),
                dur1 = o1.getDur(),
                dur2 = o2.getDur(),
                id1 = parseInt(o1.data.item_id),
                id2 = parseInt(o2.data.item_id);
            if (me.sortByName && proto1 && proto2) {
                if (proto1.data.title > proto2.data.title) {
                    return 1;
                } else if (proto1.data.title < proto2.data.title) {
                    return -1;
                } else if (!me.sortByDur) {
                    return 0;
                }
            }
            if (me.sortByDur && typeof dur1 != 'undefined' && typeof dur2 != 'undefined') {
                if (dur1 > dur2) {
                    return 1;
                } else if (dur1 < dur2) {
                    return -1;
                } else {
                    return 0;
                }
            }
            return id1 > id2 ? -1 : id1 < id2 ? 1 : 0;
        };
        me.mon(me.user, 'settingschanged', me.onSettingsChanged, me);
    },
    onSettingsChanged: function() {
        var me = this,
            newSortByName = parseInt(me.user.getSetting('inventory_sort_by_name')) || 0,
            newSortByDur = parseInt(me.user.getSetting('inventory_sort_by_dur')) || 0;
        if (me.sortByName != newSortByName || me.sortByDur != newSortByDur) {
            me.sortByName = newSortByName;
            me.sortByDur = newSortByDur;
            me.fireEvent('refresh');
        }
    },
    getSorters: function() {
        var me = this;
        return [
            {
                sorterFn: me.sortFn
            }
        ];
    }
});

/**
 * Управление инвентарём
 */
Ext.define('ExGods.controller.inventory.Inventory', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /**
         * @method getInventoryButton
         */
            ref: 'inventoryButton',
            selector: '#mainmenu-inventory-button'
        },
        {
            /**
         * @method getInventorySlots
         */
            ref: 'inventorySlots',
            selector: '#inventory_slots'
        },
        {
            /**
         * @method getUserStats
         */
            ref: 'userStats',
            selector: '#user_stats'
        },
        {
            /**
         * @method getVirtualStoreBtn
         */
            ref: 'virtualStoreBtn',
            selector: '#virtualStoreBtn'
        }
    ],
    views: [
        'item.InventorySlot',
        'item.DollSlot',
        'inventory.InventorySorter'
    ],
    tooltips: [
        'item',
        'slot'
    ],
    init: function(app) {
        var me = this,
            user = app.user;
        me.service = ExGods.Services.get('inventory');
        user.slots().each(function(slot) {
            if (!slot.getSlotTypeInfo().active) {
                slot.on('newitemsadded', function(slot, ids) {
                    me.incNewItemsCounter(ids.length);
                }, me);
            }
        });
        ExGods.app.getStore('VirtualStore').on({
            //'datachanged': me.onVirtualStoreChanged,
            'newitemsadded': me.onVirtualStoreNewItems,
            scope: me
        });
        me.control({
            'dollslot': {
                click: me.onDollSlotClick,
                scope: me
            }
        });
        ExGods.Components.addComponentInitializer('inventory', me.initInventoryComponent, me);
    },
    initInventoryComponent: function(config) {
        var me = this,
            cmp,
            form_config = [];
        ExGods.app.user.slots().each(function(slot) {
            if (!slot.getSlotTypeInfo().active) {
                form_config.push({
                    boxLabel: slot.data.name,
                    slotType: slot.data.type
                });
            }
        });
        cmp = Ext.widget('skintabpanel', {
            tabUi: 'skintext',
            cls: 'owerflow_visible_panel',
            bodyPadding: '0 11 11',
            items: [
                {
                    icon: ExGods.ref('images|inventory_tabs').image.inventory,
                    layout: 'absolute',
                    items: [
                        {
                            xtype: 'form',
                            x: 395,
                            y: -38,
                            width: 365,
                            height: 30,
                            tbar: {
                                xtype: 'panel',
                                bodyCls: 'parchment-content-nop',
                                defaults: {
                                    xtype: 'checkboxfield',
                                    checked: true,
                                    style: {
                                        color: '#e3ac69'
                                    },
                                    padding: '0 15 0 0',
                                    listeners: {
                                        change: me.onFilterChange,
                                        scope: me
                                    }
                                },
                                items: form_config,
                                layout: 'hbox'
                            }
                        },
                        {
                            xtype: 'button',
                            text: ExGods.getMsgByKey('inventory_params_btn_text'),
                            x: 132,
                            y: 8,
                            width: 104,
                            height: 18,
                            cls: 'inventory-params',
                            style: {
                                'z-index': '999'
                            },
                            handler: function() {
                                if (me.getUserStats().isVisible()) {
                                    me.getUserStats().hide();
                                    this.removeCls('opened');
                                } else {
                                    me.getUserStats().show();
                                    this.addClass('opened');
                                }
                            }
                        },
                        {
                            xtype: 'userstats',
                            user: ExGods.app.user,
                            itemId: 'user_stats',
                            hidden: true,
                            width: 225,
                            style: {
                                'z-index': '999'
                            },
                            x: 72,
                            y: 32
                        },
                        {
                            xtype: 'dollpanel',
                            user: ExGods.app.user
                        },
                        me.createInventorySlotsView(),
                        {
                            xtype: 'container',
                            layout: {
                                type: 'hbox',
                                pack: 'center'
                            },
                            width: 340,
                            height: 80,
                            x: 405,
                            y: 330,
                            items: [
                                {
                                    xtype: 'textbutton',
                                    text: ExGods.getMsgByKey('text_storage_img'),
                                    cls: 'inventory-virtual-store-btn',
                                    itemId: 'virtualStoreBtn',
                                    width: 120,
                                    margin: '0 5',
                                    handler: function(btn) {
                                        btn.disable();
                                        ExGods.Components.factory("VIRTUAL_STORE");
                                        var counterEl = btn.el.down('.newitems-counter');
                                        if (counterEl) {
                                            counterEl.remove();
                                        }
                                    },
                                    listeners: {
                                        afterrender: function(btn) {
                                            if (me.newItemsVirtualStoreCount) {
                                                me.incNewItemsVirtualStoreCounter(me.newItemsVirtualStoreCount);
                                            }
                                            if (me.newItemsLootCount) {
                                                me.incNewLootCounter(me.newItemsLootCount);
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    ]
                },
                {
                    icon: ExGods.ref('images|inventory_tabs').image.raids,
                    layout: 'absolute',
                    items: [
                        {
                            xtype: 'guildraids',
                            store: ExGods.app.getGuildRaidsStore(),
                            show_rewards: true
                        }
                    ]
                }
            ],
            listeners: {
                destroy: function(cmp) {
                    var items = Ext.ComponentQuery.query('parchmentwindow');
                    items.forEach(function(item) {
                        item.close();
                    });
                },
                beforetabchange: function(tabpanel, newTab) {
                    var guildraids = newTab.down('guildraids');
                    if (!guildraids)  {
                        return;
                    }
                    
                    if (me.achievements_requesting) {
                        return false;
                    } else if (me.achievements_requested) {
                        guildraids.show();
                        me.achievements_requested = false;
                    } else {
                        me.achievements_requesting = true;
                        me.request({
                            url: '/game.pl',
                            params: {
                                cmd: 'guild_raid_achievements'
                            },
                            success: function(data) {
                                if (data.achievements) {
                                    me.user.setRaidAchievements(data.achievements);
                                }
                                me.achievements_requesting = false;
                                me.achievements_requested = true;
                                tabpanel.setActiveTab(newTab);
                            }
                        });
                        return false;
                    }
                },
                tabchange: function(tabpanel, newTab) {
                    me.getInventorySlots().setVisible(Boolean(newTab.down('#inventory_slots')));
                }
            }
        });
        var wnd = Ext.widget('window2', {
                id: 'INVENTORY',
                items: [
                    cmp
                ],
                closeAction: 'hide',
                autoShow: false,
                listeners: {
                    render: function() {
                        me.getInventorySlots().show();
                        me.getInventoryButton().reset();
                    },
                    show: function() {
                        me.getInventorySlots().show();
                        this.down('skintabpanel').setActiveTab(0);
                        if (cmp.down('#loot_manager_btn'))  {
                            cmp.down('#loot_manager_btn').setDisabled(ExGods.app.getStore('Loot').getCount() === 0);
                        }
                        
                        me.getInventoryButton().reset();
                    },
                    hide: function() {
                        me.getInventorySlots().hide();
                        this.down('guildraids').hide();
                    }
                }
            });
        ExGods.app.block();
        ExGods.Resources.load(wnd, function() {
            wnd.show();
            ExGods.app.unblock();
        });
        return wnd;
    },
    createInventorySlotsView: function(config) {
        var me = this,
            cmp,
            notActiveSlots = [];
        ExGods.app.user.slots().each(function(slot) {
            if (!slot.getSlotTypeInfo().active) {
                notActiveSlots.push(slot);
            }
        });
        return Ext.widget('iteminventoryslot', Ext.apply({
            headerText: ExGods.getMsgByKey('inventory_title_text'),
            itemId: 'inventory_slots',
            slots: notActiveSlots,
            user: ExGods.app.user,
            rowsCount: 4,
            columnsCount: 5,
            x: 400,
            y: 22,
            pager: {
                marginLeft: -37,
                marginRight: -39,
                textTop: 270,
                textLeft: 104
            }
        }, config));
    },
    /**
     * Блокирует визуализацию изменений счетчика новых предметов
     */
    lockNewItemsUpdate: function() {
        var me = this;
        me.f_locked_new_items_update = true;
    },
    unlockNewItemsUpdate: function() {
        var me = this,
            inventoryCmp = Ext.getCmp('INVENTORY');
        if (me.newItemsCount && (!inventoryCmp || !inventoryCmp.isVisible())) {
            me.getInventoryButton().addCount(me.newItemsCount);
        }
        me.newItemsCount = 0;
        me.f_locked_new_items_update = false;
    },
    onFilterChange: function(field) {
        var me = this,
            values = [],
            store = me.getInventorySlots().store,
            protos = ExGods.app.getItemPrototypesStore(),
            all_checked = true;
        Ext.Array.each(field.up().up().query('checkboxfield'), function(checkBox) {
            if (checkBox.getValue()) {
                values.push(checkBox.slotType);
            } else  {
                all_checked = false;
            }
            
        });
        store.removeFilter('user_filter');
        if (!all_checked) {
            store.addFilter(Ext.util.Filter({
                filterFn: function(rec) {
                    var proto = protos.getById(rec.get('proto_id')) || protos.data.getByKey(rec.data.stuff.params.id);
                    if (!proto)  {
                        return false;
                    }
                    
                    var slotType = proto.getTypeInfo().slot_off;
                    return values.indexOf(slotType) != -1;
                },
                id: 'user_filter'
            }));
        }
    },
    /**
     * @private Обработчик изменения данных виртуального хранилища
     */
    onVirtualStoreChanged: function(virtualStore) {
        var me = this,
            cmp = Ext.getCmp('INVENTORY'),
            btn = me.getVirtualStoreBtn();
        if (cmp && btn) {
            // блокирую кнопку "хранилище" в рюкзаке
            btn.setDisabled(virtualStore.getCount() == 0);
        }
    },
    /**
     * @private Обработчик добавления новых записей виртуального хранилища
     */
    onVirtualStoreNewItems: function(virtualStore, newItems) {
        var me = this,
            newItemsCount = newItems.length,
            i = newItemsCount,
            el;
        me.incNewItemsCounter(newItemsCount);
        me.incNewItemsVirtualStoreCounter(newItemsCount);
        while (i--) {
            el = virtualStore.getById(newItems[i]);
            if (el) {
                newItemsCount--;
            }
        }
        me.incNewLootCounter(newItemsCount);
    },
    onDollSlotClick: function(cmp, slot, e) {
        var me = this;
        //если есть предмет - то сработает обработчик клика по стаффу
        if (slot.items().getCount())  {
            return;
        }
        
        me.app.getItemController().showSlotWindow(slot, cmp.el);
    },
    /**
     * Инкрементирует счетчик новых предметов на кнопке меню "рюкзак"
     */
    incNewItemsCounter: function(count) {
        var me = this,
            inventoryCmp = Ext.getCmp('INVENTORY'),
            virtualStoreCmp = Ext.getCmp('VIRTUAL_STORE'),
            fucinaCmp = Ext.getCmp('FUCINA');
        if (me.f_locked_new_items_update) {
            me.newItemsCount = (me.newItemsCount || 0) + count;
            return;
        }
        if ((!inventoryCmp || !inventoryCmp.isVisible()) && (!fucinaCmp || !fucinaCmp.isVisible()) && (!virtualStoreCmp || !virtualStoreCmp.isVisible())) {
            me.getInventoryButton().addCount(count);
        }
    },
    /**
     * Инкрементирует счетчик новых предметов на кнопке "хранилище"
     */
    incNewItemsVirtualStoreCounter: function(count) {
        var me = this,
            cmp = Ext.getCmp('INVENTORY'),
            cmp2 = Ext.getCmp('VIRTUAL_STORE'),
            virtualStoreBtn = me.getVirtualStoreBtn();
        if (cmp2) {
            return;
        }
        // Вью хранилища активно
        if (cmp && virtualStoreBtn) {
            counterEl = virtualStoreBtn.el.down('.newitems-counter');
            if (!counterEl) {
                counterEl = virtualStoreBtn.el.insertHtml('beforeEnd', '<div class="newitems-counter"></div>', true);
            }
            counterEl.setHTML((parseInt(counterEl.getHTML()) || 0) + count);
        } else {
            me.newItemsVirtualStoreCount = (me.newItemsVirtualStoreCount || 0) + count;
        }
    },
    /**
     * Инкрементирует счетчик новых предметов на кнопке лута
     */
    incNewLootCounter: function(count) {
        var me = this,
            cmp = Ext.getCmp('INVENTORY');
        if (cmp && cmp.down('#loot_manager_btn') && cmp.down('#loot_manager_btn').el) {
            var lootBtn = cmp.down('#loot_manager_btn');
            counterEl = lootBtn.el.down('.newitems-counter');
            if (!counterEl) {
                counterEl = lootBtn.el.insertHtml('beforeEnd', '<div class="newitems-counter"></div>', true);
            }
            counterEl.setHTML((parseInt(counterEl.getHTML()) || 0) + count);
            lootBtn.enable();
        } else {
            me.newItemsLootCount = (me.newItemsLootCount || 0) + count;
        }
    },
    /**
     * Реализация метода источника тултипов
     */
    getTooltipData: function(type, value) {
        var me = this,
            data;
        value = value.split('|');
        if (type == 'item' && (value[1] == 'user_info' && !Ext.getCmp('user-info'))) {
            me.user.slots().each(function(slot) {
                slot.items().each(function(item) {
                    if (item.data.item_id == value[0]) {
                        data = {
                            item: item
                        };
                        data.tooltipText = me.user.isBattle() ? ExGods.getMsgByKey('tooltip_text_battle') : ExGods.getMsgByKey('tooltip_text');
                    }
                });
            });
        } else if (type == 'slot') {
            me.user.slots().each(function(slot) {
                if (slot.data.ekey == value[0]) {
                    data = {
                        slot: slot
                    };
                    data.tooltipText = !slot.data.protect ? ExGods.getMsgByKey('tooltip_text') : '';
                }
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.inventory.stuff.VirtualStoreStuff', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.sourceModel = me.stuff.sourceModel;
        data.decorators.push(ExGods.view.inventory.stuff.decorator.Timer);
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent(),
            destinations = me.stuff.sourceModel.get('destinations');
        data.buttons = [];
        if (destinations.indexOf('inventory') != -1) {
            data.buttons.push({
                text: ExGods.getMsgByKey('virtual_store_get_btn_text'),
                action: 'get_virtual_store_stuff'
            }, {
                text: ExGods.getMsgByKey('virtual_store_get_all_btn_text'),
                action: 'get_all_virtual_store_stuff',
                hidden: data.stuff.params.quantity <= 1
            }, {
                text: ExGods.getMsgByKey('virtual_store_drop_btn_text'),
                action: 'drop_virtual_store_stuff'
            }, {
                text: ExGods.getMsgByKey('virtual_store_drop_all_btn_text'),
                action: 'drop_all_virtual_store_stuff',
                hidden: data.stuff.params.quantity <= 1
            });
        }
        if (destinations.indexOf('guild_store') != -1) {
            data.buttons.push({
                text: ExGods.getMsgByKey('virtual_store_puton_guild_store_btn_text'),
                action: 'guild_virtual_store_stuff'
            }, {
                text: ExGods.getMsgByKey('virtual_store_puton_guild_store_all_btn_text'),
                action: 'guild_all_virtual_store_stuff',
                hidden: data.stuff.params.quantity <= 1
            });
        }
        if (destinations.indexOf('group') != -1) {
            data.buttons.push({
                text: ExGods.getMsgByKey('virtual_store_puton_group_btn_text'),
                action: 'group_virtual_store_stuff'
            });
        }
        if (ExGods.app.getController('Market').isCanSellStuff(data.stuff)) {
            data.buttons.push({
                text: ExGods.getMsgByKey('put_on_market_btn_text'),
                action: 'put_to_market'
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.inventory.stuff.WareHouseStuff', {
    extend: ExGods.stuff.stuff.ItemInstance,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        me.replaceQuantityDecorator(data.decorators);
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        return Ext.apply(data, {
            buttons: [
                {
                    text: ExGods.getMsgByKey('virtual_store_get_btn_text'),
                    action: 'get_warehouse_item'
                }
            ]
        });
    },
    /**
     * Заменяет стандартный декоратор кол-ва
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.inventory.stuff.decorator.WareHouseQuantity);
    }
});

Ext.define('ExGods.view.inventory.stuff.Ingredient', {
    extend: ExGods.stuff.stuff.Ingredient,
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        if (ExGods.app.getController('Market').isCanSellStuff({
            type: 'ingredients',
            params: data.stuff.params
        })) {
            data.buttons = [
                {
                    text: ExGods.getMsgByKey('put_on_market_btn_text'),
                    action: 'put_to_market'
                }
            ];
        }
        return data;
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.inventory.stuff.decorator.Timer', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var expire_date = data.sourceModel.get('expire_date');
            return expire_date ? ExGods.util.Timers.printTimer('rest', 'virtual-store-item', expire_date, {
                needNormalized: true
            }) : '';
        }
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.inventory.stuff.decorator.WareHouseQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getQuantity: function(data) {
            var quantity = data.itemModel.getQuantity();
            return quantity > 1 ? quantity : false;
        }
    }
});

/**
 * Диалог с прогресс баром
 *
 * @author Max Dvortsov
 */
Ext.define('ExGods.view.ProgressDialog', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.progressdialog',
    autoShow: true,
    width: 350,
    bodyPadding: 5,
    y: 200,
    // по высоте центрирую относительно локации
    plugins: [
        'skindeco'
    ],
    cls: 'progress-dialog',
    /**
     * @cfg {Array} buttonsText Надписи на кнопках
     */
    buttonsText: null,
    /**
     * @cfg {String} title Заголовок окна
     */
    title: '',
    /**
     * @cfg {String} description Описание окна
     */
    description: '',
    /**
     * @cfg {String} label Текст перед полем ввода
     */
    label: '',
    /**
     * @cfg {Number} value Стартовое значение поля ввода
     */
    value: 1,
    /**
     * @cfg {Number} min Минимальное значение
     */
    min: 1,
    /**
     * @cfg {Number} max Максимальное значение
     */
    max: 2,
    /**
     * @cfg {Number} increment Шаг слайдера
     */
    increment: 1,
    /**
     * @cfg {Number} inputWidth Ширина поля ввода
     */
    inputWidth: 100,
    /**
     * @cfg {String} image Картинка для отображения
     */
    /**
     * @cfg {Number|Object} item если нет картинки, можно передать item как объект стаффа или айди прототипа
     */
    /**
     * @cfg {String} value_dependent_text - Шаблон текста со значением зависимым от значения компонента
     */
    value_dependent_text: '',
    /**
     * @cfg {Function|Object} handler Обработчик положительного ответа - функция или объект вида {fn, scope}
     */
    handler: Ext.emptyFn,
    handler_negative: Ext.emptyFn,
    initComponent: function() {
        var me = this;
        if (me.value_dependent_text) {
            me.value_dependent_text = new Ext.XTemplate(me.value_dependent_text);
        }
        var innerPanelCfg = {
                plugins: [
                    'paperdeco'
                ],
                width: me.width - 10,
                padding: '0 0 20',
                tpl: [
                    '<tpl if="title">',
                    '<div class="paper-title"><h4>{title}</h4></div>',
                    '</tpl>',
                    '<tpl if="description">',
                    '<div class="progress-description">{description}</div>',
                    '</tpl>',
                    '<div class="progress-core">',
                    '<tpl if="this.isImage()">',
                    '<div class="progress-dialog-image"{[this.getImageStyle()]}></div>',
                    '</tpl>',
                    '<div class="progress-dialog-container">',
                    '<div class="progress-dialog-input">',
                    '<div class="progress-dialog-input-label">{label}</div>',
                    '<div class="progress-dialog-input-field"></div>',
                    '</div>',
                    '<div class="progress-dialog-bar"></div>',
                    '</div>',
                    '</div>',
                    '<tpl if="value_dependent_text">',
                    '<div class="progress-dialog-comission">',
                    '{[ this.getValueDependant() ]}',
                    '</div>',
                    '</tpl>',
                    {
                        isImage: function() {
                            return me.image || me.item;
                        },
                        getImageStyle: function() {
                            var image = me.getImage();
                            if (image && image != true) {
                                return ' style="background-image:url(' + image + ')"';
                            } else  {
                                return '';
                            }
                            
                        },
                        getValueDependant: function() {
                            return me.value_dependent_text.apply({
                                value: me.getValue()
                            });
                        }
                    }
                ],
                data: {
                    title: me.title,
                    description: me.description,
                    label: me.label,
                    value: me.value,
                    value_dependent_text: me.value_dependent_text
                }
            };
        //кнопки
        if (!me.buttonsText)  {
            me.buttonsText = ExGods.getMsgByKey('view_confirm_yesno').split(';');
        }
        
        Ext.apply(me, {
            buttonAlign: 'center',
            buttons: {
                margin: '-5 0 15 0',
                defaults: {
                    xtype: 'textbutton',
                    width: 130
                },
                items: [
                    {
                        text: me.buttonsText[0],
                        cls: 'qh-object',
                        handler: function() {
                            if (typeof me.handler == 'object') {
                                me.handler.fn.call(me.handler.scope ? me.handler.scope : me, me.getValue());
                            } else {
                                me.handler.call(me, me.getValue());
                            }
                            me.close();
                        },
                        listeners: {
                            render: function() {
                                if (me.quest_helper_id)  {
                                    //добавляем квест хелпер
                                    this.el.set({
                                        'data-qh_otype': me.quest_helper_type,
                                        'data-qh_oid': me.quest_helper_id
                                    });
                                }
                                
                            }
                        }
                    },
                    {
                        text: me.buttonsText[1],
                        cls: 'x-btn-txt-red',
                        handler: function() {
                            if (typeof me.handler_negative == 'object') {
                                me.handler_negative.fn.call(me.handler_negative.scope ? me.handler_negative.scope : me, me.getValue());
                            } else {
                                me.handler_negative.call(me, me.getValue());
                            }
                            me.close();
                        }
                    }
                ]
            }
        });
        me.items = [
            innerPanelCfg
        ];
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.slider = Ext.widget('exg_slider', {
            width: 188,
            value: me.getValue(),
            increment: me.increment,
            minValue: me.min,
            maxValue: me.max,
            renderTo: me.el.down('.progress-dialog-bar'),
            listeners: {
                change: me.onSliderChange,
                scope: me
            }
        });
        me.input = Ext.widget('numberfield', {
            value: me.getValue(),
            width: me.inputWidth,
            padding: 2,
            renderTo: me.el.down('.progress-dialog-input-field'),
            hideTrigger: true,
            listeners: {
                change: me.onInputChange,
                scope: me
            }
        });
    },
    onDestroy: function() {
        var me = this;
        me.slider.destroy();
        me.input.destroy();
        me.callParent();
    },
    onSliderChange: function(slider, value) {
        this.setValue(value);
    },
    onInputChange: Ext.Function.createBuffered(function(slider, value) {
        if (value || value == 0) {
            this.setValue(value);
            this.slider.setValue(this.value);
        }
    }, 1000),
    /**
     * Метод находит картинку по стаффу, айди стаффа или просто картинке
     */
    getImage: function() {
        var me = this,
            image, missed, proto, id,
            protos = ExGods.app.getItemPrototypesStore();
        if (me.image) {
            image = me.image;
        } else if (me.item) {
            id = typeof me.item == 'object' ? me.item.params.id : me.item;
            proto = protos.data.getByKey(id);
            if (proto) {
                image = proto.get('images').info;
            } else {
                missed = id;
            }
        }
        if (image) {
            return image.substr(0, 4) == 'http' ? image : IMAGE_URL + image;
        } else if (missed) {
            protos.loadNew([
                missed
            ], function() {
                me.el.down('.progress-dialog-image').setStyle({
                    backgroundImage: 'url(' + protos.data.getByKey(missed).get('images').info + ')'
                });
            });
            return true;
        } else  {
            return false;
        }
        
    },
    getValue: function() {
        return this.value;
    },
    setValue: function(value) {
        var me = this;
        value = Math.max(me.min, Math.min(me.max, value));
        //меняю инпут
        me.input.setValue(value);
        //меняю зависимое значение
        if (me.value_dependent_text && me.el) {
            me.el.down('.progress-dialog-comission').setHTML(me.value_dependent_text.apply({
                value: value
            }));
        }
        me.value = value;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var img = me.getImage();
        if (img === true || img == false) {
            img = undefined;
        } else {
            arr_images.push(img);
        }
        if (me.buttonsText) {
            arr_images = arr_images.concat(me.buttonsText);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Виртуальное хранилище имущества персонажа
 */
Ext.define('ExGods.view.inventory.VirtualStoreView', {
    extend: ExGods.view.grid.FramedSlotsGrid,
    alias: 'widget.virtualstoreview',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.InventoryDragHighlight
    ],
    /**
     * @cfg store Стор с элементами имущества виртуального хранилища
     **/
    /**
     * @cfg can_drag По умолчанию true, если false - предметы нельзя перемещать
     */
    can_drag: true,
    initComponent: function() {
        var me = this;
        me.cls += ' virtual-store';
        me.itemTpl = [
            '{[ExGods.stuff.StuffManager.image(values)]}'
        ];
        me.callParent();
        me.view = me.down('dataview');
        me.view.on('render', function() {
            if (me.can_drag)  {
                me.initDragAndDrop();
            }
            
        });
        me.mon(me.store, {
            highlight: me.highlight,
            unhighlight: me.unhighlight,
            scope: me
        });
    },
    collectData: function(records) {
        var me = this,
            data = [],
            protos = ExGods.app.getItemPrototypesStore();
        Ext.Array.each(records, function(rec) {
            if (rec.data.entries && rec.data.entries[0]) {
                data.push({
                    type: 'warehouse_stuff',
                    params: {
                        itemModel: rec
                    }
                });
            } else {
                data.push({
                    type: 'virtual_store_stuff',
                    sourceModel: rec,
                    params: {
                        stuff: {
                            params: {
                                id: rec.data.stuff.params.id,
                                quantity: rec.data.stuff.params.quantity
                            },
                            type: rec.data.stuff.type
                        }
                    }
                });
            }
        });
        me.itemsTotalCount = data.length;
        return data;
    },
    /**
     * @override
     */
    getTotalPagesCount: function() {
        var me = this;
        return Math.ceil(me.itemsTotalCount / (me.rowsCount * me.columnsCount)) || 1;
    },
    highlight: function() {
        if (this.el && !this.el.down('.virtual-store-highlight')) {
            this.down('dataview').el.insertHtml('beforeEnd', '<div class="virtual-store-highlight"></div>');
        }
    },
    unhighlight: function() {
        if (this.el && this.el.down('.virtual-store-highlight')) {
            this.el.down('.virtual-store-highlight').remove();
        }
    },
    /**
     * @private
     * D&D предметов
     */
    initDragAndDrop: function() {
        var me = this;
        me.initDrag({
            view: me.view,
            cancelFn: function() {
                ExGods.app.user.slots().each(function(slot) {
                    if (slot.getSlotType().active == 0)  {
                        slot.fireEvent('unhighlight', slot);
                    }
                    
                });
            }
        });
        me.initDrop({
            onDrop: function(target, dd, e, data) {
                if (Ext.getClassName(data.item) == 'ExGodsCore.model.Item' && ExGods.app.getItemPrototypesStore().data.getByKey(data.item.get('proto_id')).canPutInWareHouse()) {
                    me.fireEvent('put_to_warehouse', data.item, data.cancel);
                } else  {
                    return false;
                }
                
            }
        });
        me.initDragHighlight();
    }
});

/**
 * Виртуальное хранилище ингредиентов персонажа
 */
Ext.define('ExGods.view.inventory.Ingredients', {
    extend: ExGods.view.grid.FramedSlotsGrid,
    alias: 'widget.ingredientsview',
    /**
     * @cfg place - proto.place ингредиента
     **/
    initComponent: function() {
        var me = this;
        me.store = Ext.create('Ext.data.Store', {
            fields: [
                {
                    name: 'type',
                    type: 'string'
                },
                {
                    name: 'group',
                    type: 'string'
                },
                {
                    name: 'params',
                    type: 'auto'
                }
            ],
            sorters: [
                {
                    property: 'group',
                    direction: 'DESC'
                }
            ]
        });
        me.loadData();
        me.itemTpl = [
            '{[ExGods.stuff.StuffManager.image(values)]}'
        ];
        me.callParent();
        me.mon(ExGods.app.user, 'ingredientschanged', me.loadData, me);
        me.mon(me.store, {
            highlight: me.highlight,
            unhighlight: me.unhighlight,
            scope: me
        });
    },
    loadData: function() {
        var me = this,
            data = [];
        Ext.Array.each(ExGods.app.user.data.ingredients, function(ingredient) {
            var proto = ExGods.ref('ingredients|' + ingredient.name);
            if (proto.place == me.place) {
                data.push({
                    type: 'user_ingredient',
                    group: proto.group,
                    params: {
                        id: ingredient.name,
                        quantity: ingredient.value
                    }
                });
            }
        });
        me.store.loadRawData(data);
    },
    highlight: function() {
        if (!this.el.down('.slotsgrid-highlight')) {
            this.down('dataview').el.insertHtml('beforeEnd', '<div class="slotsgrid-highlight"></div>');
        }
    },
    unhighlight: function() {
        if (this.el.down('.slotsgrid-highlight')) {
            this.el.down('.slotsgrid-highlight').remove();
        }
    }
});

/**
 * Дефолтный слайдер
 */
Ext.define('ExGods.view.Slider', {
    extend: Ext.panel.Panel,
    alias: 'widget.exg_slider',
    useTips: false,
    width: 188,
    height: 22,
    /**
     * @cfg {Number} value Стартовое значение
     */
    value: 1,
    /**
     * @cfg {Number} minValue Минимальное значение
     */
    minValue: 1,
    /**
     * @cfg {Number} maxValue Максимальное значение
     */
    maxValue: 2,
    /**
     * @cfg {Number} increment Шаг слайдера
     */
    increment: 1,
    /**
     * @cfg {Number} upperScale шаг шкалы сверху. Если 0 - не рисуем
     */
    upperScale: 0,
    /**
     * @cfg {String} title заголовок слайдера
     */
    title: 0,
    /**
     * @cfg {Boolean} disabled
     */
    disabled: false,
    initComponent: function() {
        var me = this;
        me.cls = me.cls ? me.cls + ' exg-slider-bar' : 'exg-slider-bar';
        me.html = [
            '<div class="exg-slider-arrow left-arrow"></div>',
            '<div class="exg-slider-arrow right-arrow"></div>',
            '<div class="exg-slider-bar-slider"></div>'
        ];
        if (me.title || me.upperScale) {
            var html = [];
            if (me.title) {
                html.push('<div class="exg-slider-title">' + me.title + '</div>');
                delete me.title;
            }
            if (me.upperScale) {
                me.upperScale = Math.ceil(me.upperScale);
                var i = me.minValue,
                    left;
                html.push('<div class="exg-slider-scale">');
                while (i < me.maxValue) {
                    left = Math.floor((me.width - 42 - /*ширина стрелок*/
                    28) * /*ширина слайдера*/
                    (i - me.minValue) / (me.maxValue - me.minValue));
                    html.push('<p style="left:' + left + 'px">' + Math.floor(i) + '</p>');
                    i += me.upperScale;
                }
                html.push('<p style="left:' + (me.maxValue == 1 ? 0 : me.width - 42 - 28) + 'px">' + me.maxValue + '</p>');
                html.push('</div>');
            }
            me.dockedItems = [
                {
                    dock: 'top',
                    xtype: 'component',
                    height: 20,
                    html: html.join('')
                }
            ];
            me.height += 21;
        }
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.slider = Ext.widget('slider', {
            useTips: me.useTips,
            width: me.width - 54,
            ui: 'default',
            value: me.value,
            increment: me.increment,
            minValue: me.minValue,
            maxValue: me.maxValue,
            disabled: me.disabled,
            renderTo: me.el.down('.exg-slider-bar-slider')
        });
        me.relayEvents(me.slider, [
            'change'
        ]);
        //обработчик клика по левой стрелке
        me.el.on('click', function() {
            me.setValue(me.getValue() - me.increment);
        }, me, {
            delegate: '.left-arrow'
        });
        //обработчик клика по правой стрелке
        me.el.on('click', function() {
            me.setValue(me.getValue() + me.increment);
        }, me, {
            delegate: '.right-arrow'
        });
        me.callParent();
    },
    setValue: function(value, animate) {
        this.value = value;
        return this.slider.setValue(value, animate);
    },
    getValue: function() {
        return this.slider.getValue();
    },
    /**
     * override
     */
    disable: function() {
        this.addCls('disabled');
        if (this.slider) {
            this.slider.disable();
        }
    },
    /**
     * override
     */
    enable: function() {
        this.removeCls('disabled');
        if (this.slider) {
            this.slider.enable();
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'scrollbar/hor_arrow_bottom.png',
                IMAGE_URL + 'scrollbar/hor_arrow_top.png',
                IMAGE_URL + 'scrollbar/hor_bg_bottom.png',
                IMAGE_URL + 'scrollbar/hor_bg_top.png',
                IMAGE_URL + 'scrollbar/hor_bg_midle.png',
                IMAGE_URL + 'scrollbar/hor_thumb_new.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Модель предмета
 */
Ext.define('ExGods.model.Item', {
    extend: ExGodsCore.model.Item
});

/**
 * Модель имущества в вируальном хранилище
 */
Ext.define('ExGods.model.VirtualStoreStuff', {
    extend: ExGods.model.Item,
    idProperty: 'entry',
    fields: [
        {
            // идентификатор записи виртуального хранилища, к которому принадлежит имущество (не уникальный, т.к. в одной записи могут быть несколько stuffs)
            name: 'entry',
            type: 'auto'
        },
        {
            // время добавления записи в хранилище
            name: 'add_time',
            type: 'string'
        },
        {
            // дата истечения срока жизни имущества в хранилище. Производная от add_time. Не нормализованная
            name: 'expire_date',
            type: 'auto',
            mapping: 'add_time',
            convert: function(v, r) {
                if (!v)  {
                    return v;
                }
                
                var dt = ExGods.util.Date.parseString(v);
                dt = Ext.Date.add(dt, Ext.Date.MINUTE, ExGods.ref('constants|user_store_live').value);
                ExGods.util.Ticker.addListener(r.onTick, r);
                return dt;
            }
        },
        {
            name: 'source_id',
            type: 'string'
        },
        {
            name: 'source_name',
            type: 'string'
        },
        {
            // список возможных получателей имущества записи
            name: 'destinations',
            type: 'auto'
        },
        {
            // параметры
            name: 'params',
            type: 'auto'
        },
        {
            // индекс имущества в записе хранилища, для которого определена эта модель
            name: 'index',
            type: 'auto'
        },
        {
            // имущество
            name: 'stuff',
            type: 'auto',
            convert: function(v, r) {
                r.set('proto_id', v.params.id);
                return v;
            }
        },
        {
            //для имущества со склада - entry предметов, которые лежат
            name: 'entries',
            type: 'auto'
        }
    ],
    onTick: function() {
        if (this.isExpired()) {
            ExGods.util.Ticker.removeListener(this.onTick, this);
            var i = this.stores.length;
            while (i--) {
                this.stores[i].remove(this);
            }
        }
    },
    isExpired: function() {
        if (!this.data.expire_date)  {
            return false;
        }
        
        var expireDate = ExGods.util.Date.normalizeServerDateTime(this.data.expire_date);
        var now = new Date();
        if (expireDate <= now) {
            return true;
        } else {
            return false;
        }
    }
});

/**
 * Стор виртуального хранилища
 */
Ext.define('ExGods.store.VirtualStore', {
    extend: Ext.data.Store,
    model: 'ExGods.model.VirtualStoreStuff',
    proxy: 'memory',
    id: 'VirtualStore',
    entries: [],
    filters: [
        function(item) {
            return !item.isExpired() && [
                'item',
                'currency'
            ].indexOf(item.data.stuff.type) != -1;
        }
    ],
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        me.on('datachanged', me.onDataChanged, me);
    },
    onDataChanged: function() {
        var me = this,
            oldEntries = me.entries,
            newItems;
        me.entries = [];
        // собираю новые entries и если были добавлены новые записи выбрасываю соотв. событие
        me.each(function(item) {
            // В записи стора мы добавляем одну запись на каждую реальную сущность предмета
            // если зельев 1 в количестве 5, то реально зелей 5, а не 1.
            var cnt = item.data.stuff.params.quantity;
            for (var j = 0; j < cnt; j++) {
                me.entries.push(item.data.entry);
            }
        });
        newItems = Ext.Array.difference(me.entries, oldEntries);
        if (!me.new_items_block && newItems.length) {
            me.fireEvent('newitemsadded', me, newItems);
        }
    },
    checkExpired: function() {
        var me = this,
            expired = [];
        me.each(function(item) {
            if (item.isExpired()) {
                expired.push(item);
            }
        });
        if (expired.length) {
            me.filter();
        }
    },
    blockNewItemsEvent: function() {
        var me = this;
        me.new_items_block = true;
        setTimeout(function() {
            me.new_items_block = false;
        }, 0);
    }
});

/**
 * Модель имущества в вируальном хранилище
 */
Ext.define('ExGods.model.WareHouseStuff', {
    extend: ExGods.model.VirtualStoreStuff,
    fields: [
        {
            //для имущества со склада - entry предметов, которые лежат
            name: 'entries',
            type: 'auto'
        },
        {
            name: 'items',
            type: 'auto'
        }
    ],
    isWareHouse: function() {
        return this.get('entries') && this.get('entries').length;
    },
    getQuantity: function() {
        var count = 0;
        Ext.Array.each(this.get('items'), function(el) {
            var quantity = el.param ? Number(el.param.count) : 1;
            count += quantity || 1;
        });
        return count;
    },
    isExpired: function() {
        var me = this,
            expire_str = me.data.param ? me.data.param.expire_str : undefined,
            proto = me.getProto(),
            validto = proto ? proto.data.data.validto : undefined,
            expire_date,
            now = new Date();
        if (expire_str) {
            expire_str = ExGods.util.Date.parseString(expire_str) || Infinity;
        } else  {
            expire_str = Infinity;
        }
        
        if (validto) {
            validto = ExGods.util.Date.parseString(validto) || Infinity;
        } else  {
            validto = Infinity;
        }
        
        if (expire_str !== Infinity || validto !== Infinity) {
            expire_date = ExGods.util.Date.normalizeServerDateTime(new Date(Math.min(expire_str, validto)));
        }
        return expire_date && expire_date <= now;
    }
});

/**
 * Стор виртуального хранилища
 */
Ext.define('ExGods.store.WareHouse', {
    extend: Ext.data.Store,
    model: 'ExGods.model.WareHouseStuff',
    proxy: 'memory',
    id: 'WareHouse',
    sorters: [
        {
            sorterFn: function(m1, m2) {
                if (m1.get('expire_date') && m2.get('expire_date')) {
                    return m1.get('expire_date') > m2.get('expire_date') ? -1 : 1;
                } else if (m1.get('expire_date')) {
                    return -1;
                } else if (m2.get('expire_date')) {
                    return 1;
                } else  {
                    return 0;
                }
                
            }
        }
    ],
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        ExGods.app.getStore('VirtualStore').on('datachanged', me.updateVirtualStoreRecords, me);
    },
    updateVirtualStoreRecords: function() {
        var me = this,
            toRemove = [],
            data = [];
        me.each(function(rec) {
            if (!rec.isWareHouse()) {
                toRemove.push(rec);
            }
        });
        me.remove(toRemove);
        ExGods.app.getStore('VirtualStore').each(function(rec) {
            data.push(Ext.clone(rec.raw));
        });
        me.superclass.loadRawData.call(me, data, true);
    },
    /**
     * Собираю дату из предметов виртуального хранилища и склада
     * Подгружаю недостающие прототипы предметов
     */
    loadRawData: function(data, append, cb) {
        var me = this;
        var stuff = Ext.Array.map(data, function(el) {
                return {
                    params: {
                        id: el.proto_id,
                        quantity: 1
                    },
                    type: 'item'
                };
            });
        ExGods.helpme.loadProtosFromStuff(stuff, function() {
            data = me.prepareWareHouseItems(data);
            if (!append) {
                me.removeAll();
                ExGods.app.getStore('VirtualStore').each(function(rec) {
                    data.push(rec.raw);
                });
            }
            me.superclass.loadRawData.call(me, data, true);
            if (cb)  {
                cb();
            }
            
        });
    },
    /**
     * @private Подготавливает данные сервера для загрузки в виртуальный стор
     */
    prepareWareHouseItems: function(data) {
        var me = this,
            preparedData = [],
            stackData = {},
            protos = ExGods.app.getItemPrototypesStore().data;
        Ext.Array.each(data, function(el) {
            var proto = protos.getByKey(el.proto_id),
                stuffEl = {
                    params: {
                        id: el.proto_id,
                        quantity: 1
                    },
                    type: 'item'
                },
                cfg = {
                    stuff: stuffEl,
                    entries: [
                        el.entry
                    ],
                    items: [
                        el
                    ],
                    param: el.param,
                    proto_id: el.proto_id,
                    features: el.features
                };
            if (proto.get('data') && proto.get('data').stack) {
                if (stackData[el.proto_id]) {
                    stackData[el.proto_id].entries.push(el.entry);
                    stackData[el.proto_id].items.push(el);
                } else {
                    stackData[el.proto_id] = cfg;
                }
            } else {
                preparedData.push(cfg);
            }
        });
        Ext.Object.each(stackData, function(proto_id, el) {
            preparedData.push(el);
        });
        return preparedData;
    },
    checkExpired: function() {
        var me = this,
            expired = [];
        me.each(function(item) {
            if (item.isExpired()) {
                expired.push(item);
            }
        });
        if (expired.length) {
            me.remove(expired);
        }
    }
});

/**
 * Контроллер виртуального хранилища
 */
Ext.define('ExGods.controller.inventory.VirtualStore', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /** getInventoryItemsView */
            ref: 'inventoryItemsView',
            selector: '#inventory_slots'
        },
        {
            /** getVirtualStoreView */
            ref: 'virtualStoreView',
            selector: '#virtual_store_view'
        },
        {
            /** getEssenceView */
            ref: 'essenceView',
            selector: '#essence_view'
        },
        {
            /** getIngredientsView */
            ref: 'ingredientsView',
            selector: '#ingredients_view'
        }
    ],
    views: [
        'item.InventorySlot',
        'inventory.VirtualStoreView',
        'inventory.Ingredients',
        'ProgressDialog',
        'ExGods.view.Slider'
    ],
    stores: [
        'VirtualStore',
        'WareHouse'
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'VirtualStore:'
    },
    tooltips: [
        'item'
    ],
    init: function(app) {
        var me = this;
        me.virtualStore = ExGods.app.getStore('VirtualStore');
        me.wareHouseStore = ExGods.app.getStore('WareHouse');
        me.listen({
            component: {
                '#virtual_store_view dataview': {
                    itemdblclick: me.onItemDblClick
                },
                'virtualstoreview': {
                    put_to_warehouse: me.putToWareHouse
                }
            }
        });
        ExGods.util.Timers.on('virtual-store-item-expire', me.onTimerExpired, me);
        me.startExpireMonitor();
        me.inventory = me.app.getController('inventory.Inventory');
        ExGods.stuff.StuffManager.register({
            'warehouse_stuff': {
                classObj: ExGods.view.inventory.stuff.WareHouseStuff,
                listeners: {
                    get_warehouse_item: me.onGetWareHouseItemClick,
                    scope: me
                }
            },
            'virtual_store_stuff': {
                classObj: ExGods.view.inventory.stuff.VirtualStoreStuff,
                listeners: {
                    get_virtual_store_stuff: me.onGetVirtualStoreStuffClick,
                    drop_virtual_store_stuff: me.onDropVirtualStoreStuffClick,
                    get_all_virtual_store_stuff: me.onGetAllVirtualStoreStuffClick,
                    drop_all_virtual_store_stuff: me.onDropAllVirtualStoreStuffClick,
                    guild_virtual_store_stuff: me.onGuildVirtualStoreStuffClick,
                    guild_all_virtual_store_stuff: me.onGuildAllVirtualStoreStuffClick,
                    group_virtual_store_stuff: me.onGroupVirtualStoreStuffClick,
                    put_to_market: me.onPutToMarketClick,
                    scope: me
                }
            },
            'user_ingredient': {
                classObj: ExGods.view.inventory.stuff.Ingredient,
                listeners: {
                    put_to_market: me.onIngredientPutToMarketClick,
                    scope: me
                }
            }
        });
        ExGods.Components.addComponentInitializer('virtual_store', me.initVirtualStoreComponent, me);
    },
    initVirtualStoreComponent: function(config) {
        var me = this,
            notActiveSlots = [],
            filterItems = [],
            fucinaFilterItems = [],
            homeFilterItems = [],
            win, cmp,
            stuff = [],
            defaults = {
                xtype: 'checkboxfield',
                checked: true,
                style: {
                    color: '#e3ac69'
                },
                padding: '0 15 0 0'
            },
            showInventory = function() {
                if (Ext.getCmp('INVENTORY')) {
                    Ext.getCmp('INVENTORY').show();
                } else {
                    ExGods.Components.factory("INVENTORY");
                }
            };
        ExGods.references.get('ingredients').each(function(k, v) {
            if (v.place == 'fucina' && fucinaFilterItems.indexOf(v.group) == -1) {
                fucinaFilterItems.push(v.group);
            } else if (v.place == 'home' && homeFilterItems.indexOf(v.group) == -1) {
                homeFilterItems.push(v.group);
            }
        });
        fucinaFilterItems = Ext.Array.map(fucinaFilterItems, function(v) {
            return Ext.apply({
                boxLabel: v,
                slotType: v
            }, defaults, {
                listeners: {
                    change: me.onFucinaFilterChange,
                    scope: me
                }
            });
        });
        homeFilterItems = Ext.Array.map(homeFilterItems, function(v) {
            return Ext.apply({
                boxLabel: v,
                slotType: v
            }, defaults, {
                listeners: {
                    change: me.onHomeFilterChange,
                    scope: me
                }
            });
        });
        ExGods.app.user.slots().each(function(slot) {
            if (!slot.getSlotTypeInfo().active) {
                notActiveSlots.push(slot);
                filterItems.push({
                    boxLabel: slot.data.name,
                    slotType: slot.data.type
                });
            }
        });
        var dubl = Ext.getCmp('VIRTUAL_STORE');
        if (dubl) {
            dubl.close();
        }
        
        win = Ext.widget('window2', {
            id: 'VIRTUAL_STORE',
            autoShow: false,
            items: [],
            closeAction: 'destroy'
        });
        me.inventoryItemsView = me.inventory.createInventorySlotsView();
        cmp = Ext.widget('skintabpanel', {
            cls: 'owerflow_visible_panel',
            bodyPadding: '0 11 11',
            items: [
                {
                    icon: ExGods.ref('images|virtual_store_images').image.vstore_tab,
                    layout: 'absolute',
                    items: [
                        {
                            xtype: 'form',
                            x: 395,
                            y: -38,
                            width: 365,
                            height: 30,
                            tbar: {
                                xtype: 'panel',
                                bodyCls: 'parchment-content-nop',
                                defaults: {
                                    xtype: 'checkboxfield',
                                    checked: true,
                                    style: {
                                        color: '#e3ac69'
                                    },
                                    padding: '0 15 0 0',
                                    listeners: {
                                        change: me.onFilterChange,
                                        scope: me
                                    }
                                },
                                items: filterItems,
                                layout: 'hbox'
                            }
                        },
                        me.inventoryItemsView,
                        {
                            xtype: 'virtualstoreview',
                            itemId: 'virtual_store_view',
                            rowsCount: 4,
                            columnsCount: 5,
                            x: 16,
                            y: 22,
                            store: me.wareHouseStore,
                            pager: {
                                marginLeft: -39,
                                marginRight: -37,
                                textTop: 270,
                                textLeft: 104
                            },
                            headerText: ExGods.getMsgByKey('virtual_store_title_text'),
                            listeners: {
                                destroy: function() {
                                    me.wareHouseStore.clearFilter();
                                }
                            }
                        },
                        {
                            xtype: 'container',
                            layout: {
                                type: 'hbox',
                                pack: 'center'
                            },
                            width: 340,
                            height: 80,
                            x: 405,
                            y: 330,
                            items: [
                                {
                                    xtype: 'textbutton',
                                    text: config.rucksack_btn_text,
                                    width: 120,
                                    handler: showInventory
                                }
                            ]
                        }
                    ],
                    listeners: {
                        show: function() {
                            this.down('iteminventoryslot').show();
                            this.down('virtualstoreview').show();
                        },
                        hide: function() {
                            this.down('iteminventoryslot').hide();
                            this.down('virtualstoreview').hide();
                        }
                    }
                },
                {
                    icon: ExGods.ref('images|virtual_store_images').image.fucina_tab,
                    items: [
                        {
                            xtype: 'form',
                            x: 210,
                            y: -38,
                            width: 392,
                            height: 30,
                            items: fucinaFilterItems,
                            style: {
                                zIndex: 10
                            },
                            layout: {
                                type: 'hbox',
                                pack: 'end'
                            }
                        },
                        {
                            xtype: 'form',
                            x: 600,
                            y: -68,
                            width: 132,
                            height: 21,
                            tbar: {
                                xtype: 'textfield',
                                cls: 'text-search-input',
                                emptyText: ExGods.getMsgByKey('ingredients_input_empty'),
                                listeners: {
                                    change: me.onFucinaFilterChange,
                                    scope: me
                                },
                                value: ''
                            }
                        },
                        {
                            xtype: 'ingredientsview',
                            itemId: 'ingredients_view',
                            rowsCount: 4,
                            columnsCount: 11,
                            x: 16,
                            y: -29,
                            place: 'fucina',
                            headerText: ExGods.getMsgByKey('ingredients_title_text'),
                            pager: {
                                marginLeft: -39,
                                marginRight: -39,
                                textTop: 272,
                                textLeft: 295
                            }
                        }
                    ],
                    buttons: {
                        padding: '0 0 10',
                        defaults: {
                            xtype: 'textbutton',
                            width: 120
                        },
                        items: [
                            {
                                text: config.rucksack_btn_text,
                                margin: '0 123 0 0',
                                handler: showInventory
                            }
                        ]
                    },
                    listeners: {
                        show: function() {
                            this.down('ingredientsview').show();
                        },
                        hide: function() {
                            this.down('ingredientsview').hide();
                        }
                    }
                },
                {
                    icon: ExGods.ref('images|virtual_store_images').image.essence_tab,
                    items: [
                        {
                            xtype: 'form',
                            x: 210,
                            y: -38,
                            width: 392,
                            height: 30,
                            items: homeFilterItems,
                            style: {
                                zIndex: 10
                            },
                            layout: {
                                type: 'hbox',
                                pack: 'end'
                            }
                        },
                        {
                            xtype: 'form',
                            x: 600,
                            y: -68,
                            width: 132,
                            height: 21,
                            tbar: {
                                xtype: 'textfield',
                                cls: 'text-search-input',
                                emptyText: ExGods.getMsgByKey('home_input_empty'),
                                listeners: {
                                    change: me.onHomeFilterChange,
                                    scope: me
                                },
                                value: ''
                            }
                        },
                        {
                            xtype: 'ingredientsview',
                            itemId: 'essence_view',
                            rowsCount: 4,
                            columnsCount: 11,
                            x: 16,
                            y: -29,
                            place: 'home',
                            headerText: ExGods.getMsgByKey('home_title_text'),
                            pager: {
                                marginLeft: -39,
                                marginRight: -39,
                                textTop: 272,
                                textLeft: 295
                            }
                        }
                    ],
                    buttons: {
                        padding: '0 0 10',
                        defaults: {
                            xtype: 'textbutton',
                            width: 120
                        },
                        items: [
                            {
                                text: config.rucksack_btn_text,
                                margin: '0 123 0 0',
                                handler: showInventory
                            }
                        ]
                    },
                    listeners: {
                        show: function() {
                            this.down('ingredientsview').show();
                        },
                        hide: function() {
                            this.down('ingredientsview').hide();
                        }
                    }
                }
            ]
        });
        if (ExGods.app.getStore('Loot').getCount()) {
            cmp.add({
                icon: ExGods.ref('images|virtual_store_images').image.lm_tab,
                layout: 'fit',
                itemId: 'lm_container',
                items: [
                    {
                        xtype: 'lmcontainer'
                    }
                ],
                buttonAlign: 'center',
                buttons: {
                    padding: '0 0 10',
                    defaults: {
                        xtype: 'textbutton',
                        width: 120
                    },
                    items: [
                        {
                            text: config.take_all_btn_text,
                            itemId: 'self_loot_btn',
                            margin: '0 136 0 0'
                        },
                        {
                            text: config.rucksack_btn_text,
                            margin: '0 0 0 136',
                            handler: showInventory
                        }
                    ]
                },
                listeners: {
                    show: function() {
                        this.down('lootslots').show();
                    },
                    hide: function() {
                        this.down('lootslots').hide();
                    }
                }
            });
            ExGods.app.getStore('Loot').each(function(rec) {
                stuff.push(rec.get('stuff'));
            });
            var cmp_ = cmp.down('lmcontainer');
            ExGods.Resources.load(cmp_, function() {
                cmp.setActiveTab('lm_container');
            });
        }
        win.add(cmp);
        me.inventory.service.command('get_warehouse', {}, function(data) {
            if (data.success) {
                ExGods.helpme.loadProtosFromStuff(stuff, function() {
                    me.wareHouseStore.loadRawData(data.warehouse, false, function() {
                        ExGods.Resources.load(me, function() {
                            Ext.getCmp('INVENTORY').down('#virtualStoreBtn').enable();
                            win.show();
                        });
                    });
                });
            } else {
                win.close();
                Ext.getCmp('INVENTORY').down('#virtualStoreBtn').enable();
            }
        });
        return win;
    },
    onGetWareHouseItemClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.params.itemModel);
        win.close();
    },
    onGetVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.sourceModel, 1, function() {
            win.close();
        });
    },
    onDropVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doRemoveItems(data.stuff.sourceModel, 1, function() {
            win.close();
        });
    },
    onGetAllVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.sourceModel, null, function() {
            win.close();
        });
    },
    onDropAllVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doRemoveItems(data.stuff.sourceModel, null, function() {
            win.close();
        });
    },
    onGuildVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.sourceModel, 1, function() {
            win.close();
        }, {
            destination: 'guild_store'
        });
    },
    onGuildAllVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.sourceModel, null, function() {
            win.close();
        }, {
            destination: 'guild_store'
        });
    },
    onGroupVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutOnGroup(data.stuff.sourceModel, 1, function() {
            win.close();
        });
    },
    onPutToMarketClick: function(data, btn, win) {
        var me = this,
            marketController = me.app.getController('Market'),
            market_item = marketController.getMarketItemInfo(data.stuff);
        me.app.getController('Market').putStoreStuffToMarket(Ext.apply({
            entry: market_item.entry
        }, data.stuff));
    },
    onIngredientPutToMarketClick: function(data, btn, win) {
        var me = this,
            marketController = me.app.getController('Market'),
            stuff = {
                type: 'ingredients',
                params: data.stuff.params
            },
            market_item = marketController.getMarketItemInfo(stuff);
        me.app.getController('Market').putInventoryStuffToMarket(Ext.apply({
            entry: market_item.entry
        }, stuff));
    },
    /**
     * @private Обработка двойного клика в dataview
     */
    onItemDblClick: function(view, item, itemEl) {
        var me = this;
        me.preventClick = true;
        me.doPutItems(item);
    },
    onFilterChange: function(field) {
        this.filterVirtualStore(this.getInventoryItemsView().store, field);
        this.filterVirtualStore(this.getVirtualStoreView().store, field);
    },
    onFucinaFilterChange: function(field) {
        this.filterStore(this.getIngredientsView().store, field);
    },
    onHomeFilterChange: function(field) {
        this.filterStore(this.getEssenceView().store, field);
    },
    filterStore: function(store, field) {
        var me = this,
            values = [],
            text = '';
        Ext.Array.each(field.up().up().query('checkboxfield'), function(checkBox) {
            if (checkBox.getValue()) {
                values.push(checkBox.slotType);
            }
        });
        var textfield = field.up('form').up().down('textfield');
        if (textfield)  {
            text = textfield.getValue().toLowerCase();
        }
        
        store.removeFilter('user_filter');
        store.addFilter(Ext.util.Filter({
            filterFn: function(rec) {
                var title = rec.get('title');
                if (!title) {
                    var ingredient = ExGods.ref('ingredients|' + rec.get('params').id);
                    if (ingredient)  {
                        title = ingredient.label;
                    }
                    
                }
                return values.indexOf(rec.get('group')) != -1 && (!title || !text || title.toLowerCase().indexOf(text) != -1);
            },
            id: 'user_filter'
        }));
    },
    filterVirtualStore: function(store, field) {
        var me = this,
            values = [],
            protos = ExGods.app.getItemPrototypesStore(),
            all_checked = true;
        Ext.Array.each(field.up().up().query('checkboxfield'), function(checkBox) {
            if (checkBox.getValue()) {
                values.push(checkBox.slotType);
            } else  {
                all_checked = false;
            }
            
        });
        if (store.id == 'VirtualStore') {
            store.blockNewItemsEvent();
        }
        store.removeFilter('user_filter');
        if (!all_checked) {
            store.addFilter(Ext.util.Filter({
                filterFn: function(rec) {
                    var proto = protos.getById(rec.get('proto_id')) || protos.data.getByKey(rec.data.stuff.params.id);
                    if (!proto)  {
                        return false;
                    }
                    
                    var slotType = proto.getTypeInfo().slot_off;
                    return values.indexOf(slotType) != -1;
                },
                id: 'user_filter'
            }));
        }
    },
    /**
     * Забрать элементы имущества из записи хранилища
     * @param record Модель имещества виртуального хранилища или склада
     * @param quantity Кол-во элементов. Если не указано = забрать всё
     * @param callback 
     * @param opts Опции
     *      destination - куда передать предмет
     *      title - юзерский display_title, если destination == "group"
     */
    doPutItems: function(record, quantity, callback, opts) {
        var me = this;
        opts = opts || {};
        //если предмет со склада - другая команда
        if (Ext.getClassName(record) == 'ExGods.model.WareHouseStuff' && record.isWareHouse()) {
            me.putFromWareHouse(record, callback);
        } else {
            if (!quantity) {
                quantity = record.data.stuff.params.quantity;
            }
            me.app.block();
            me.inventory.service.command('put_from_store', {
                entry: record.data.entry,
                destination: opts.destination || 'inventory',
                title: opts.title || undefined,
                index: record.data.index + 1,
                // required 1 based
                quantity: quantity
            }, function(json) {
                me.app.unblock();
                if (callback) {
                    callback();
                }
            });
        }
    },
    /**
     * Забрать всё имущество из виртуального хранилища
     */
    doPutAllItems: function() {
        var me = this,
            entries = [],
            finished = 0,
            onRequest = function(json) {
                if (++finished == entries.length || json.success != 1) {
                    ExGods.app.unblock();
                    me.virtualStore.resumeEvents(true);
                } else {
                    putOnItem(entries[finished]);
                }
            },
            putOnItem = function(entry) {
                me.inventory.service.command('put_from_store', {
                    entry: entry,
                    destination: 'inventory'
                }, function(json) {
                    onRequest(json);
                });
            };
        me.virtualStore.suspendEvents(true);
        me.virtualStore.each(function(item) {
            entries.push(item.data.entry);
        });
        entries = Ext.Array.unique(entries);
        if (entries.length) {
            ExGods.app.block();
            putOnItem(entries[0]);
        }
    },
    /**
     * Передать имущество игроку из группы
     * @param virtualStoreStuff Модель имещества виртуального хранилища
     * @param quantity Кол-во элементов. Если не указано = забрать всё
     */
    doPutOnGroup: function(virtualStoreStuff, quantity, callback) {
        var me = this,
            store;
        if (virtualStoreStuff.data.params && virtualStoreStuff.data.params.users) {
            ExGods.Components.factory('USER_TARGET_PANEL', {
                users: virtualStoreStuff.data.params.users,
                listeners: {
                    select: function(panel, record) {
                        me.doPutItems(virtualStoreStuff, quantity, callback, {
                            destination: 'group',
                            title: record.data.display_title
                        });
                        win.close();
                    }
                }
            });
        }
    },
    /**
     * Удалить элементы имущества из записи хранилища
     * @param virtualStoreStuff Модель имещества виртуального хранилища
     * @param quantity Кол-во элементов. Если не указано = удалить всё
     */
    doRemoveItems: function(virtualStoreStuff, quantity, callback) {
        var me = this;
        if (!quantity) {
            quantity = virtualStoreStuff.data.stuff.params.quantity;
        }
        me.app.block();
        me.inventory.service.command('remove_from_store', {
            entry: virtualStoreStuff.data.entry,
            index: virtualStoreStuff.data.index + 1,
            // required 1 based
            quantity: quantity
        }, function(json) {
            me.app.unblock();
            if (callback) {
                callback();
            }
        });
    },
    /**
     * Положить предмет на склад
     */
    putToWareHouse: function(item, negative_cb) {
        var me = this,
            ids = item.get('stack_ids'),
            l = item.get('count') || 1,
            proto = ExGods.app.getItemPrototypesStore().data.getByKey(item.get('proto_id')),
            cost = proto.getWareHouseCost(),
            msgCfg = {
                cost: {
                    name: cost.currency,
                    value: cost.value
                },
                item: {
                    id: item.get('proto_id'),
                    title: proto.get('title')
                }
            },
            callback = function(data) {
                if (data.success) {
                    me.wareHouseStore.loadRawData(data.warehouse, false, function() {
                        me.app.unblock();
                    });
                } else  {
                    me.app.unblock();
                }
                
            };
        negative_cb = negative_cb || Ext.emptyFn;
        if (l > 1) {
            var cmp = Ext.widget('progressdialog', {
                    title: proto.get('title'),
                    item: item.get('proto_id'),
                    description: ExGods.app.applyTpl(ExGods.getMsgByKey('ctrl_virtstore_progressdesc'), msgCfg),
                    label: ExGods.getMsgByKey('ctrl_virtstore_progresslabel'),
                    value: l,
                    min: 1,
                    max: l,
                    inputWidth: 38,
                    handler: function(value) {
                        if (item.isExpired())  {
                            return;
                        }
                        
                        me.app.block();
                        me.inventory.service.command('put_to_warehouse_some', {
                            item_proto: item.get('proto_id'),
                            slot: item.get('slot_id'),
                            count: value
                        }, callback);
                    },
                    handler_negative: negative_cb,
                    value_dependent_text: [
                        Ext.String.format(ExGods.getMsgByKey('ctrl_virtstore_progresstpl'), '{[ExGods.printMoney({name:"' + cost.currency + '",value:this.calcValue(values)})]}'),
                        {
                            calcValue: function(values) {
                                return Math.ceil(values.value * cost.value);
                            }
                        }
                    ],
                    buttonsText: [
                        ExGods.getMsgByKey('warehouse_confirm_yes'),
                        ExGods.getMsgByKey('warehouse_confirm_no')
                    ],
                    listeners: {
                        close: negative_cb
                    }
                });
            ExGods.Resources.load(cmp, function() {
                cmp.show();
            });
        } else {
            Ext.widget('confirmdialog', {
                message: ExGods.app.applyTpl(ExGods.getMsgByKey('ctrl_virtstore_warehouseconfirm'), msgCfg),
                handler: function() {
                    if (item.isExpired())  {
                        return;
                    }
                    
                    me.app.block();
                    if (proto.isStack()) {
                        me.inventory.service.command('put_to_warehouse_some', {
                            item_proto: item.get('proto_id'),
                            slot: item.get('slot_id'),
                            count: 1
                        }, callback);
                    } else {
                        me.inventory.service.command('put_to_warehouse', {
                            item: item.get('item_id'),
                            slot: item.get('slot_id')
                        }, callback);
                    }
                },
                handler_negative: negative_cb,
                listeners: {
                    close: negative_cb
                }
            });
        }
    },
    /**
     * забрать предмет со склада
     */
    putFromWareHouse: function(item, negative_cb) {
        var me = this,
            ids = item.get('entries'),
            l = item.getQuantity(),
            proto_id = item.get('stuff').params.id,
            proto = ExGods.app.getItemPrototypesStore().data.getByKey(proto_id),
            msgCfg = {
                item: {
                    id: proto_id,
                    title: proto.get('title')
                }
            },
            callback = function(data) {
                if (data.success) {
                    me.wareHouseStore.loadRawData(data.warehouse, false, function() {
                        me.app.unblock();
                    });
                } else  {
                    me.app.unblock();
                }
                
            };
        negative_cb = negative_cb || Ext.emptyFn;
        if (l > 1) {
            var cmp = Ext.widget('progressdialog', {
                    title: proto.get('title'),
                    item: proto_id,
                    description: ExGods.app.applyTpl(ExGods.getMsgByKey('ctrl_virtstore_out_progressdesc'), msgCfg),
                    label: ExGods.getMsgByKey('ctrl_virtstore_progresslabel'),
                    value: l,
                    min: 1,
                    max: l,
                    autoShow: false,
                    inputWidth: 38,
                    handler: function(value) {
                        me.app.block();
                        me.inventory.service.command('put_from_warehouse_some', {
                            item_proto: proto_id,
                            count: value
                        }, callback);
                    },
                    handler_negative: negative_cb,
                    buttonsText: [
                        ExGods.getMsgByKey('warehouse_confirm_yes'),
                        ExGods.getMsgByKey('warehouse_confirm_no')
                    ],
                    listeners: {
                        close: negative_cb
                    }
                });
            ExGods.Resources.load(cmp, function() {
                cmp.show();
            });
        } else {
            Ext.widget('confirmdialog', {
                message: ExGods.app.applyTpl(ExGods.getMsgByKey('ctrl_virtstore_out_warehouseconfirm'), msgCfg),
                handler: function() {
                    me.app.block();
                    if (proto.isStack()) {
                        me.inventory.service.command('put_from_warehouse_some', {
                            item_proto: proto_id,
                            count: 1
                        }, callback);
                    } else {
                        me.inventory.service.command('put_from_warehouse', {
                            entry: item.get('entries')
                        }, callback);
                    }
                },
                handler_negative: negative_cb,
                listeners: {
                    close: negative_cb
                }
            });
        }
    },
    /**
     * @private Обработчик истечения таймера имущества
     */
    onTimerExpired: function() {
        var me = this;
        me.virtualStore.filter();
    },
    /**
     * @private Запускает цикл отслеживаения истекших записей
     */
    startExpireMonitor: function() {
        var me = this;
        setInterval(function() {
            me.virtualStore.checkExpired();
            me.wareHouseStore.checkExpired();
        }, 1000);
    },
    /**
     * Ресурсы контроллера
     */
    getResources: function() {
        var me = this,
            stuff = [];
        me.virtualStore.each(function(record) {
            stuff = stuff.concat(record.data.stuff);
        });
        return {
            stuff: stuff
        };
    },
    /**
     * Реализация метода источника тултипов
     */
    getTooltipData: function(type, value) {
        var me = this,
            data;
        if (type == 'item') {
            me.wareHouseStore.each(function(rec) {
                if (rec.get('entries').indexOf(value) != -1) {
                    data = {
                        item: rec,
                        tooltipText: ExGods.getMsgByKey('tooltip_text')
                    };
                }
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.inventory.stuff.InventoryItem', {
    extend: ExGods.stuff.stuff.ItemInstance,
    /**
     * override
     */
    getDblClickAction: function() {
        var inventoryCmp = Ext.getCmp('INVENTORY');
        if (inventoryCmp && inventoryCmp.isVisible()) {
            return 'put_on';
        } else {
            return 'put_to_warehouse';
        }
    },
    getImageData: function() {
        var me = this,
            data = me.callParent();
        me.replaceQuantityDecorator(data.decorators);
        data.decorators.push(ExGods.view.inventory.stuff.decorator.QuestHelper, ExGods.view.item.stuff.decorator.CriticalDurability);
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent(),
            user = ExGods.app.getUser(),
            slot_on = references.get('item_type').getByKey(data.protoModel.get('type')).slot_on,
            actions = data.protoModel.get('action_full'),
            param = data.itemModel.get('param'),
            inventoryCmp = Ext.getCmp('INVENTORY');
        data.buttons = [];
        if (inventoryCmp && inventoryCmp.isVisible()) {
            if (user.slots().findExact('type', slot_on) != -1) {
                data.buttons.push({
                    action: 'put_on',
                    cls: 'qh-object no_border',
                    text: ExGods.getMsgByKey('put_on_item'),
                    qh: {
                        'data-qh_otype': 'inventory_item_button_puton',
                        'data-qh_oid': data.protoModel.get('entry')
                    }
                });
            }
        } else if (data.protoModel.canPutInWareHouse()) {
            data.buttons.push({
                action: 'put_to_warehouse',
                text: ExGods.getMsgByKey('put_to_warehouse_btn')
            });
        }
        if (!user.isChain()) {
            Ext.Array.each(data.protoModel.get('condition_actions'), function(action) {
                if (action.type != 'battle') {
                    data.buttons.push({
                        action_data: action,
                        actionType: 'condition_actions',
                        action: 'item_action',
                        text: action.label
                    });
                }
            });
            Ext.Array.each(actions, function(action) {
                switch (action.type) {
                    case 'dialog':
                        data.buttons.push({
                            action_data: action,
                            actionType: action.type,
                            action: 'item_action',
                            text: action.label,
                            value: action.entry
                        });
                        break;
                    case 'map':
                        data.buttons.push({
                            action_data: action,
                            action: 'item_action',
                            actionType: action.type,
                            text: ExGods.app.applyTpl(action.label, param) + (action.costs && action.costs.length ? ' (' + ExGods.util.Stuff.printStuff(action.costs, {
                                delimiter: ',&nbsp;'
                            }) + ')' : ''),
                            value: action.entry,
                            cls: 'qh-object no_border do-map-action',
                            id: 'map-action_' + action.entry,
                            qh: {
                                'data-qh_otype': 'map_action',
                                'data-qh_oid': action.entry
                            }
                        });
                        break;
                    case 'sale':
                        if (!parseInt(data.itemModel.getProto().get('param').nonsale)) {
                            var currency = ExGods.references.get('user_money').getByKey('gold'),
                                price = data.itemModel.calcPrice(action.cost, false, true),
                                priceAll = data.itemModel.calcPrice(action.cost, true, true),
                                text, textAll;
                            if (price === "0") {
                                text = ExGods.getMsgByKey('drop_item_single');
                            } else {
                                text = ExGods.getMsgByKey('sell_item_for') + ' ' + '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + price + '';
                            }
                            if (priceAll === "0") {
                                textAll = ExGods.getMsgByKey('drop_item_all');
                            } else {
                                textAll = ExGods.getMsgByKey('sell_items_for') + ' ' + '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + priceAll + '';
                            }
                            data.buttons.push({
                                action_data: action,
                                actionType: 'sell',
                                action: 'item_action',
                                text: text
                            });
                            if (data.itemModel.get('count') > 1) {
                                data.buttons.push({
                                    action_data: action,
                                    actionType: 'sellAll',
                                    action: 'item_action',
                                    text: textAll
                                });
                            }
                        };
                        break;
                    default:
                        break;
                }
            });
        }
        return data;
    },
    /**
     * Заменяет стандартный декоратор кол-ва
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.inventory.stuff.decorator.InventoryItemQuantity);
    },
    /**
     * override
     */
    details: function(config) {
        var me = this,
            data = me.getDetailsData(),
            condition_action = data.protoModel.raw.condition_action,
            user = ExGods.app.getUser(),
            method = ExGods.stuff.stuff.ItemInstance.prototype.details.bind(me, config);
        if (config.tooltip) {
            //для тултипа просто выводим инфо
            return method();
        } else {
            ExGods.app.getFeaturePrototypesStore().loadNew(data.itemModel.data.param.features, function() {
                // если юзер не в цепочке - подгружаем доп. действия с предметом, иначе они не нужны
                if (!user.isChain() && condition_action && condition_action.length && user.userVersion != data.protoModel.get('condition_actions_version')) {
                    ExGods.Services.get('inventory').command('get_item_action', {
                        proto_id: data.protoModel.get('entry')
                    }, function(json) {
                        data.protoModel.set({
                            'condition_actions': json.result,
                            'condition_actions_version': user.userVersion
                        });
                        method();
                    });
                } else {
                    method();
                }
            });
        }
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.inventory.stuff.decorator.InventoryItemQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getQuantity: function(data) {
            var quantity = data.itemModel.get('count');
            return quantity > 1 ? quantity : false;
        }
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.inventory.stuff.decorator.QuestHelper', {
    extend: ExGods.stuff.Decorator,
    statics: {
        getCls: function(data) {
            return 'qh-object';
        },
        getAttributes: function(data) {
            var str = 'data-qh_oid="' + data.itemModel.get('proto_id') + '" data-qh_otype="inventory_item"',
                inventoryCmp = Ext.getCmp('INVENTORY');
            if (inventoryCmp) {
                var store = inventoryCmp.down('iteminventoryslot').store,
                    index = store.indexOf(data.itemModel);
                if (!index % 5) {
                    str += ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"';
                }
            }
            return str;
        }
    }
});

Ext.define('ExGods.view.item.stuff.ItemSlot', {
    extend: ExGods.stuff.stuff.ItemInstance,
    /**
     * override
     */
    getDblClickAction: function() {
        if (!ExGods.app.getUser().isBattle()) {
            return 'take_off';
        } else {
            return false;
        }
    },
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.unshift(ExGods.view.item.stuff.decorator.Protect);
        data.decorators.push(ExGods.view.inventory.stuff.decorator.QuestHelper, ExGods.view.item.stuff.decorator.CriticalDurability);
        me.replaceQuantityDecorator(data.decorators);
        return data;
    },
    /**
     * Заменяет стандартный декоратор кол-ва
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.inventory.stuff.decorator.InventoryItemQuantity);
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent(),
            user = ExGods.app.getUser(),
            protect_price = ExGods.Services.get('inventory').data.next_price_protect,
            slot = data.stuff.params.slot;
        Ext.Array.insert(data.blocks, 3, [
            ExGods.stuff.block.item.Description
        ]);
        //если слот не юзера - кнопки не отображаем
        if (!user.slots().getById(Number(slot.data.ekey)) || user.isBattle()) {
            return data;
        }
        data.buttons = [];
        if (slot.get('protect') != '1' && protect_price) {
            data.buttons.push({
                action: 'item_action',
                actionType: 'protect_actions',
                text: ExGods.getMsgByKey('protect_slot_for') + ' ' + ExGods.util.Stuff.printStuff(protect_price),
                slot: slot,
                cls: 'qh-object no_border',
                qh: {
                    'data-qh_otype': 'protect_slot_button',
                    'data-qh_oid': slot.get('type')
                }
            });
        }
        if (!user.isBattle()) {
            data.buttons.push({
                action: 'take_off',
                text: ExGods.getMsgByKey('take_off_item')
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.item.stuff.RepairItem', {
    extend: ExGods.stuff.stuff.ItemInstance,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.view.item.stuff.decorator.CriticalDurability);
        return data;
    }
});

Ext.define('ExGods.view.item.stuff.QuickSlot', {
    extend: ExGods.view.item.stuff.ItemSlot,
    /**
     * override
     */
    details: function(config) {
        var me = this,
            user = ExGods.app.getUser(),
            itemModel = me.stuff.params.itemModel,
            protoModel = itemModel.getProto(),
            condition_action = protoModel.raw.condition_action,
            actions = protoModel.get('action_full');
        doAction = function() {
            var done = false;
            Ext.Array.each(protoModel.get('condition_actions'), function(action) {
                if (action.type == 'battle') {
                    ExGods.app.getItemController().doAction(me, {
                        action_data: action
                    });
                    done = true;
                }
            });
            if (!done && actions[0]) {
                ExGods.app.getItemController().doAction(me, {
                    action_data: actions[0]
                });
            }
        };
        if (user.isBattle() && !config.tooltip) {
            if (Ext.getCmp('quick-slots').isDisabled())  {
                return false;
            }
            
            if (condition_action && condition_action.length && user.userVersion != protoModel.get('condition_actions_version')) {
                ExGods.Services.get('inventory').command('get_item_action', {
                    proto_id: protoModel.get('entry')
                }, function(json) {
                    protoModel.set({
                        'condition_actions': json.result,
                        'condition_actions_version': user.userVersion
                    });
                    doAction();
                });
            } else {
                doAction();
            }
            return false;
        } else {
            return me.callParent(arguments);
        }
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.item.stuff.decorator.Protect', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var protect = data.stuff.params.slot.get('protect');
            return protect ? '<div class="slot-protect"></div>' : '';
        }
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.item.stuff.decorator.CriticalDurability', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var critical = data.itemModel.hasCriticalDurability(),
                img = ExGods.references.get('images').get('item_critical_status').image['img60'];
            return critical ? '<div class="item-critical" style="background-image: url(' + img + ')"></div>' : '';
        }
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.item.stuff.decorator.QuestHelper', {
    extend: ExGods.stuff.Decorator,
    statics: {
        getCls: function(data) {
            return 'qh-object';
        },
        getAttributes: function(data) {
            var slotType = data.stuff.params.slot.get('type'),
                str = 'data-qh_oid="' + slotType + '" data-qh_otype="active_slot"';
            if ([
                1,
                2,
                5,
                8
            ].indexOf(slotType) != -1) {
                str += ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"';
            }
            return str;
        }
    }
});

/**
 * Created by dvetlugin on 25.03.14.
 */
/**
  *
 * ExGods.view.plugin.ExtraParchmentDeco
 */
Ext.define('ExGods.view.plugin.ExtraParchmentDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.extraparchmentdeco',
    init: function(cmp) {
        cmp.addClsWithUI('extraparchment');
        if (cmp.isPanel) {
            if (!cmp.title)  {
                cmp.title = ' ';
            }
            
            Ext.override(cmp, {
                addTool: function(tools) {
                    var i = 0;
                    tools = [].concat(tools);
                    for (; i < tools.length; i++) {
                        tools[i].height = 31;
                        tools[i].width = 32;
                    }
                    this.callParent(arguments);
                }
            });
        }
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header)  {
            cmp.header.setHeight(0);
        }
        
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'shop/detail_bottom.png',
                IMAGE_URL + 'shop/detail_middle.png',
                IMAGE_URL + 'shop/detail_separator.png'
            ]
        };
    }
});

/**
 * Окно для выбора элемента (цели) из списка элементов
 */
Ext.define('ExGods.view.TargetWindow', {
    extend: Ext.panel.Panel,
    alias: 'widget.targetwindow',
    /**
     * @cfg {String} windowTitle заголовок окна
     */
    windowTitle: '',
    /**
     * @cfg {Ext.data.Store} store Хранилище элементов списка (required)
     */
    store: null,
    cls: 'target-window',
    /**
     * @cfg {String} itemTpl Шаблон элемента списка (required)
     * Это может быть скомпилированный Ext.XTemplate или строка/массив
     */
    itemTpl: null,
    /**
     * @cfg {String} searchField Название свойста элемента, по которому будет осуществляться поиск.
     */
    searchField: '',
    /**
     * @cfg {Boolean} singleBtn Показывать только одну кнопку внизу, иначе показывать кнопку для каждого элемента списка
     */
    singleBtn: true,
    buttonAlign: 'center',
    constrain: true,
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    height: 370,
    width: 260,
    initComponent: function() {
        var me = this;
        /**
         * @cfg {String} emptyText Дефолтный текст для пустого списка
         */
        me.emptyText = me.emptyText || ExGods.getMsgByKey('view_target_empty');
        /**
         * @cfg {String} searchEmptyText Дефолтный текст строки поиска
         */
        me.searchEmptyText = me.searchEmptyText || ExGods.getMsgByKey('view_target_searchempty');
        /**
         * @cfg {String} buttonText Текст кнопки выбора элемента
         */
        me.buttonText = me.buttonText || ExGods.getMsgByKey('target_window_button_text');
        // me.addEvents(
        //  *
        //   * @event select
        //   * Выкидываю это событие, когда пользователь сделал выбор. нажав на кнопку выбора
        //   * @param {ExGods.view.TargetWindow} this
        //   * @param {Ext.data.Model} selectedRecord Выбор пользователя
        //  'select'
        // );
        if (!(me.itemTpl instanceof Ext.XTemplate)) {
            me.itemTpl = Ext.create('Ext.XTemplate', me.itemTpl);
        }
        Ext.apply(this, {
            items: [
                {
                    xtype: 'container',
                    plugins: [
                        'paperdeco'
                    ],
                    layout: 'anchor',
                    items: [
                        {
                            xtype: 'component',
                            height: 24,
                            cls: 'paper-title',
                            html: me.windowTitle,
                            hidden: !me.windowTitle,
                            style: {
                                'text-align': 'center',
                                'position': 'relative',
                                'margin': '7px 11px -5px 11px',
                                'font-weight': 'bold'
                            }
                        },
                        {
                            xtype: 'textfield',
                            padding: '10 20 14 16',
                            itemId: 'search',
                            anchor: '100%',
                            emptyText: me.searchEmptyText,
                            height: 22,
                            fieldStyle: {
                                position: 'relative',
                                height: '22px'
                            },
                            hidden: me.searchField ? false : true,
                            listeners: {
                                change: me.onSearchFieldChange,
                                scope: me
                            }
                        }
                    ]
                },
                {
                    xtype: 'viewpanel',
                    itemId: 'listPanel',
                    flex: 1,
                    plugins: [
                        {
                            ptype: 'scroller',
                            animate: true,
                            autoHide: true,
                            scrollDeltaY: 26,
                            snap: 'li.item'
                        }
                    ],
                    store: me.store,
                    viewConfig: {
                        itemSelector: 'li.item',
                        tpl: [
                            '<tpl if="this.isEmpty()">',
                            '<div style="text-align: center; color: rgb(236, 219, 199); padding-top: 10%;">' + me.emptyText + '</div>',
                            '<tpl else>',
                            '<ul class="items">',
                            '<tpl for=".">',
                            '<li class="item">',
                            '{[this.getItemHtml(values)]}',
                            '</li>',
                            '</tpl>',
                            '</ul>',
                            '</tpl>',
                            {
                                isEmpty: function() {
                                    return me.store.getCount() === 0;
                                },
                                getItemHtml: function(data) {
                                    return me.itemTpl.apply(data);
                                }
                            }
                        ],
                        listeners: {
                            itemclick: {
                                fn: me.onTargetClick,
                                delay: 0,
                                scope: me
                            },
                            selectionchange: me.onSelectionChange,
                            refresh: me.onViewRefresh,
                            scope: me
                        }
                    }
                }
            ]
        });
        if (me.clientActions) {
            for (var i = 0; i < me.clientActions.length; i++) {
                me.items.push(me.clientActions[i]);
            }
        }
        me.callParent();
    },
    onViewRefresh: function(view) {
        var me = this;
        if (me.singleBtn && !me.getComponent('applyButton')) {
            me.add({
                xtype: 'textbutton',
                itemId: 'applyButton',
                text: me.buttonText,
                handler: Ext.Function.bind(me.onButtonClick, me),
                margin: '10 5 0 5',
                disabled: true,
                cls: me.buttonCls || 'no_border'
            });
        } else {
            me.store.each(function(record) {
                var node = view.getNode(record);
                if (node) {
                    Ext.widget('textbutton', {
                        renderTo: node,
                        text: me.buttonText,
                        handler: function() {
                            me.onTargetSelect(record);
                        },
                        cls: me.buttonCls || 'no_border'
                    });
                }
            });
        }
    },
    /**
     * @private
     */
    onSearchFieldChange: function(field, newValue) {
        var me = this;
        me.store.clearFilter();
        if (newValue) {
            me.store.filter({
                anyMatch: true,
                property: me.searchField,
                value: newValue
            });
            if (me.store.count() == 1) {
                me.getComponent('listPanel').getView().select(0);
            } else {
                me.getComponent('listPanel').getView().getSelectionModel().deselectAll();
            }
            field.focus();
        } else {
            me.getComponent('listPanel').getView().getSelectionModel().deselectAll();
        }
    },
    /**
     * @private
     */
    onTargetClick: function(view, record, node, index, event) {
        var me = this;
        me.down('#search').setRawValue(record.get(me.searchField));
    },
    /**
     * @private
     */
    onSelectionChange: function(view, selected) {
        var me = this,
            btns = me.query('textbutton');
        Ext.each(btns, function(btn) {
            btn.setDisabled(selected.length == 0);
        });
    },
    /**
     * @private
     */
    onButtonClick: function(button, event) {
        var me = this,
            selection = me.getComponent('listPanel').getView().getSelectionModel().getSelection();
        if (selection.length) {
            me.onTargetSelect(selection[0]);
        }
    },
    /**
     * @private
     */
    onTargetSelect: function(target) {
        this.fireEvent('select', this, target);
    }
});

/**
 * Окно с выбором цели-юзера
 */
Ext.define('ExGods.view.user.TargetWindow', {
    extend: ExGods.view.TargetWindow,
    alias: 'widget.usertargetwindow',
    /**
     * @cfg {Array} users Массив моделей ExGods.model.BasicUser или сырые данные пользователей, из которых нужно выбрать цель
     */
    users: null,
    cls: 'target-window user-target-window',
    padding: '10 10 15 10',
    buttonCls: ' ',
    //нужна простая кнопка - поэтому пробел.
    width: 350,
    initComponent: function() {
        var me = this;
        Ext.apply(this, {
            store: me.store || me.initStore(),
            itemTpl: me.getItemTpl(),
            searchField: 'display_title'
        });
        me.callParent();
    },
    /**
     * @private
     * Создает хранилище юзеров-целей
     */
    initStore: function() {
        var me = this,
            store;
        store = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.BasicUser'
        });
        if (me.users && me.users.length) {
            if (me.users[0].display_title) {
                // если это сырые данные
                store.loadRawData(me.users);
            } else {
                store.loadRecords(me.users);
            }
        }
        return store;
    },
    getItemTpl: function() {
        return [
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="target-user">',
            '<div class="exg-share-base-info exg-share-bg-light gender-{gender}" style="background-image: url({[ this.getUserImage(values) ]})">',
            '<span>{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank", maxNameWidth: 228})]}</span>',
            '<span>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {hoard.level}</span>',
            '<div class="image-frame"></div>',
            '</div>',
            '</div>',
            {
                getUserImage: function(values) {
                    var model = Ext.create('ExGods.model.User', values);
                    return model.getShape().thumb;
                }
            }
        ];
    },
    /**
     * @private
     */
    onTargetClick: function(view, record, node, index, event) {
        var me = this;
        me.callParent(arguments);
        view.getSelectionModel().preventFocus = true;
        // иначе Ext скроллит body
        if (event.target.className.indexOf(' info-icon ') != -1 && view.up('window'))  {
            view.up('window').close();
        }
        
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        /* 
        Компонент user_target_panel много где используется там надо 
        везде ресурсы подгружать 

        var wnd = ExGods.Components.factory('USER_TARGET_PANEL'....

    

        debugger
        var str = me.store || me.initStore();

        var model = Ext.create('ExGods.model.User', str);
        var shape = model.getShape().thumb;
        */
        return {
            images: [].//IMAGE_URL + 'icons/stats/ico_injury16.png',
            concat(arr_images)
        };
    }
});

/**
 * Хранилище предметов в слоте
 */
Ext.define('ExGods.store.Items', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Item',
    proxy: 'memory',
    /**
     * Добавляет в хранилище новые предметы попутно группируя их
     */
    insert: function(index, records) {
        var me = this,
            sync = false,
            i, record, len;
        var newRecords = [];
        records = [].concat(records);
        for (i = 0 , len = records.length; i < len; i++) {
            record = me.createModel(records[i]);
            record.set(me.modelDefaults);
            // reassign the model in the array in case it wasn't created yet
            records[i] = record;
            // обработка стековых предметов
            var proto_id = record.get('proto_id');
            var proto = ExGods.app.getItemPrototypesStore().data.getByKey(proto_id);
            if (proto.isStack()) {
                var searchIndex = me.data.findIndexBy(function(dataRecord) {
                        if (dataRecord.get('proto_id') == proto_id)  {
                            return true;
                        }
                        
                    });
                var item_id = record.get('item_id');
                if (searchIndex != -1) {
                    var cur_rec = me.data.getAt(searchIndex);
                    cur_rec.get('stack_ids').push(item_id);
                    cur_rec.data.count += record.get('param').count || 1;
                    records = Ext.Array.erase(records, i, 1);
                    i--;
                    len -= 1;
                } else {
                    record.set('stack_ids', [
                        item_id
                    ]);
                    record.set('count', record.get('param').count || 1);
                    me.data.insert(index + i, record);
                    record.join(me);
                    newRecords.push(record);
                }
            } else {
                me.data.insert(index + i, record);
                record.set('count', record.get('param').count || 1);
                record.join(me);
                newRecords.push(record);
            }
            // END: обработка стековых предметов
            sync = sync || record.phantom === true;
        }
        if (me.snapshot) {
            me.snapshot.addAll(newRecords);
        }
        me.fireEvent('add', me, newRecords, index);
        me.fireEvent('datachanged', me);
        if (me.autoSync && sync) {
            me.sync();
        }
    }
});

/**
 * Управление предметами. Обработка кликов по предметам и осуществелие действий над предметами (надевание, снятие, продажа и пр.)
 */
Ext.define('ExGods.controller.Item', {
    extend: ExGods.controller.Base,
    stores: [
        'Items',
        'Quests'
    ],
    views: [
        'user.TargetWindow'
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Item:'
    },
    /**
     * @property {Boolean} afterDrop
     * @private
     * Флаг, указывающий, что предмет только после дропа, чтобы избежать срабатывания клика, если предмет отпустили внутри его же слота
     */
    afterDrop: false,
    /**
     * @property {Number}
     * Максимальное кол-во предметов в стеке, с которым можно выполнять серверные операции (продать например)
     */
    MAX_STACK_OPERATION_SIZE: 100,
    init: function(app) {
        var me = this;
        me.InventoryService = ExGods.Services.get('inventory');
        me.control({
            'shop': {
                itemclick: me.onShopItemClick
            },
            '#do-protect-slot': {
                click: me.onProtectSlotBtnClick
            }
        });
        app.on({
            itemclick: me.showItemWindow,
            scope: me
        });
        ExGods.stuff.StuffManager.register({
            'inventory_item': {
                classObj: ExGods.view.inventory.stuff.InventoryItem,
                listeners: {
                    item_action: me.onItemActionClick,
                    put_on: me.doPutOn,
                    put_to_warehouse: function(data) {
                        var item = data.stuff.params.itemModel;
                        me.app.getInventoryVirtualStoreController().putToWareHouse(item);
                    },
                    scope: me
                }
            },
            'item_slot': {
                classObj: ExGods.view.item.stuff.ItemSlot,
                listeners: {
                    item_action: me.onItemActionClick,
                    take_off: me.doTakeOff,
                    scope: me
                }
            },
            'quick_slot': {
                classObj: ExGods.view.item.stuff.QuickSlot,
                listeners: {
                    item_action: me.onItemActionClick,
                    take_off: me.doTakeOff,
                    scope: me
                }
            },
            'repair_item': ExGods.view.item.stuff.RepairItem
        });
        ExGods.Components.addComponentInitializer('item_target_panel', me.initItemTargetPanelComponent, me);
        //удаляем предметы с просроченной датой
        setInterval(function() {
            me.getUser().slots().each(function(slot) {
                slot.checkExpired(function(items) {});
            });
        }, //
        1000);
    },
    onItemActionClick: function(data, btn, win) {
        var me = this;
        switch (btn.actionType) {
            case 'puton':
                me.doPutOn.apply(me, arguments);
                break;
            case 'takeoff':
                me.doTakeOff.apply(me, arguments);
                break;
            case 'battle':
            case 'map':
            case 'condition_actions':
                me.doAction.apply(me, arguments);
                break;
            case 'dialog':
                me.showDialog.apply(me, arguments);
                break;
            case 'sell':
                me.doSell.apply(me, arguments);
                break;
            case 'sellAll':
                me.doSellAll.apply(me, arguments);
                break;
            case 'protect_actions':
                me.doProtectActions.apply(me, arguments);
                break;
            default:
                break;
        }
    },
    onProtectSlotBtnClick: function(btn) {
        var me = this;
        me.doProtectActions(null, btn, btn.up('window'));
    },
    doPutOn: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            user = me.getUser();
        if (!item)  {
            return;
        }
        
        me.putOn(item, function() {
            if (win)  {
                win.close();
            }
            
        });
    },
    /**
     * Надевает предмет на персонажа
     *
     * @param {ExGods.view.TextButton/Object} button
     */
    putOn: function(item, callback, targetSlot) {
        var me = this,
            user = me.getUser(),
            params = {
                item: item.get('item_id'),
                slot: item.get('slot_id')
            };
        if (targetSlot) {
            params.slot_to = targetSlot.get('ekey');
        }
        me.app.block();
        me.InventoryService.command('item_on', params, function(json) {
            if (!json.user) {
                var items = user.slots().data.getByKey(item.get('slot_id')).get('items');
                items.fireEvent('refresh', items);
            }
            me.app.unblock();
            if (callback)  {
                callback();
            }
            
            me.user.fireEvent('item_on');
        });
    },
    doTakeOff: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            user = me.getUser();
        if (!item)  {
            return;
        }
        
        me.takeOff(item, function() {
            if (win)  {
                win.close();
            }
            
        });
    },
    /**
     * Снимает предмет с персонажа
     *
     * @param {ExGods.view.TextButton/Object} button
     */
    takeOff: function(item, callback) {
        var me = this,
            user = me.getUser();
        if (!item)  {
            return;
        }
        
        me.app.block();
        me.InventoryService.command('item_off', {
            slot: item.get('slot_id')
        }, function(json) {
            if (!json.user) {
                var items = user.slots().data.getByKey(item.get('slot_id')).get('items');
                items.fireEvent('refresh', items);
            }
            me.app.unblock();
            if (callback)  {
                callback();
            }
            
            me.user.fireEvent('item_off');
        });
    },
    /**
     * Продаёт предмет
     *
     */
    doSell: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            action = btn.action_data,
            price = item.calcPrice(action.cost, false, false),
            text;
        if (price == 0) {
            text = ExGods.getMsgByKey('inventory_confirm_drop_item');
        } else {
            text = Ext.String.format(ExGods.getMsgByKey('inventory_confirm_sell_item'), ExGods.util.Stuff.printStuff({
                type: 'currency',
                params: {
                    quantity: price,
                    id: 'gold'
                }
            }));
        }
        me.showActionConfirmation(text, {
            handler: function() {
                me.app.block();
                me.InventoryService.command('item_del', {
                    item: item.get('item_id'),
                    slot: item.get('slot_id')
                }, function() {
                    me.app.unblock();
                    win.close();
                });
            }
        });
    },
    /**
     * Продаёт все предметы в стеке
     *
     */
    doSellAll: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            action = btn.action_data,
            itemsInStack = item.get('stack_ids'),
            priceAll = item.calcPrice(action.cost, true, false, me.MAX_STACK_OPERATION_SIZE),
            operateItems = [];
        if (!itemsInStack) {
            me.log('warn', 'Пустой itemsInStack, возможно ошибка в справочниках при выдаче не стекового предмета с количеством больше 1!');
            return;
        }
        if (itemsInStack.length > me.MAX_STACK_OPERATION_SIZE) {
            operateItems = itemsInStack.slice(0, me.MAX_STACK_OPERATION_SIZE);
        } else if (item.get('count') > 1 && !itemsInStack) {
            operateItems = [
                item.get('item_id')
            ];
        } else {
            operateItems = itemsInStack;
        }
        if (priceAll == 0) {
            text = ExGods.getMsgByKey('inventory_confirm_drop_all_items');
        } else {
            text = Ext.String.format(ExGods.getMsgByKey('inventory_confirm_sell_all_items'), ExGods.util.Stuff.printStuff({
                type: 'currency',
                params: {
                    quantity: priceAll,
                    id: 'gold'
                }
            }));
        }
        me.showActionConfirmation(text, {
            handler: function() {
                me.app.block();
                me.InventoryService.command('item_del', {
                    items: operateItems,
                    slot: item.get('slot_id')
                }, function() {
                    me.app.unblock();
                    win.close();
                });
            }
        });
    },
    /**
     * Выполняет действие предмета
     *
     * @param {ExGods.view.TextButton} button Нажатая кнопка с действием, которое требуется совершить
     */
    doAction: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            action = Ext.create('ExGods.model.Action', Ext.clone(btn.action_data));
        action.set({
            'source': item,
            'service_id': me.InventoryService.id
        });
        if (action.get('type') == 'map' || !action.get('type')) {
            action.set('type', 'map.inventory');
        }
        // уточняю тип действия, как действие из инвентаря
        me.application.getController('Action').doAction(action, function(json) {
            if (win)  {
                win.close();
            }
            
            if (Ext.getCmp('itemtargetpanel')) {
                Ext.getCmp('itemtargetpanel').closeComponent();
            }
        }, me);
    },
    /**
     * Выполняет мирное действие на предмете
     *
     * @param {ExGods.view.TextButton} button Нажатая кнопка с действием, которое требуется совершить
     */
    doProtectActions: function(data, btn, win) {
        var me = this;
        me.showActionConfirmation(new Ext.XTemplate(ExGods.ref('message_client|confirm_buy_slot')).apply({
            cost: ExGods.util.Stuff.printStuff(me.InventoryService.data.next_price_protect)
        }), {
            handler: function() {
                me.app.block();
                me.InventoryService.command('protect_slot', {
                    slot: btn.slot.get('ekey')
                }, function() {
                    me.app.unblock();
                    win.close();
                });
            }
        });
    },
    showSlotWindow: function(slot, el) {
        var me = this,
            description, buttons,
            user = me.getUser(),
            protect_price = ExGods.Services.get('inventory').data.next_price_protect;
        if (slot.get('protect')) {
            description = [
                '<div style="background: url(' + IMAGE_URL + '/icons/done.png) 0 0 no-repeat; padding-left: 20px;" >',
                ExGods.ref('message_client|slot_protected'),
                '</div>'
            ].join('');
        } else {
            description = ExGods.ref('message_client|slot_not_protected');
            if (user.slots().getById(Number(slot.data.ekey)) && !user.isBattle()) {
                buttons = [
                    {
                        text: ExGods.getMsgByKey('protect_slot_for') + ' ' + ExGods.util.Stuff.printStuff(protect_price),
                        cls: 'qh-object no_border',
                        id: 'do-protect-slot',
                        slot: slot,
                        qh: {
                            'data-qh_otype': 'protect_slot_button',
                            'data-qh_oid': slot.get('type')
                        }
                    }
                ];
            }
        }
        if (me.slotWindow)  {
            me.slotWindow.close();
        }
        
        me.slotWindow = Ext.widget('commondetailswindow', {
            data: {
                label: slot.get('name'),
                image: ExGods.ref('slot_type|' + slot.get('type')).images.empty,
                description: description
            },
            buttons: buttons,
            itemElement: el
        });
    },
    /**
     * Показывает окно диалога с предметом
     *
     * @param {ExGods.view.TextButton} button Нажатая кнопка с действием, которое требуется совершить
     */
    showDialog: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            proto = item.getProto(),
            slot = me.user.slots().data.getByKey(item.get('slot_id'));
        win.close();
        // TODO: избавиться от необходимости инициализировать контроллер, сделать через события приложения <code>app.fireEvent()</code>
        var controller = me.application.getController('Dialog');
        controller.init();
        var dialog = controller.show({
                title: proto.get('title'),
                image: proto.get('images').info || Ext.BLANK_IMAGE_URL,
                description: proto.get('data').description
            }, {
                url: '/dialogs.pl?cmd=list',
                params: {
                    item: item.get('item_id'),
                    slot: item.get('slot_id')
                }
            }, item);
    },
    /**
     * Обрабатывает клик по предмету в магазине
     *
     * @param {Ext.view.View} itemView
     * @param {ExGods.model.ShopItem} shopItem
     * @param {Ext.Element} itemEl
     */
    onShopItemClick: function(itemView, shopItem, itemEl, zero, event) {
        var me = this;
        if (!event.getTarget('.x-btn')) {
            Ext.get(itemEl).down('.exg-stuff-imaged').dom.click();
        }
    },
    /**
     * Функция обработки клика по предмету, неважно, где этот предмет располагается.
     * Все данные беруться из контекста.
     *
     * @param {Object} options
     *
     * - **item** : ExGods.model.Item
     *
     * Предмет пользователя, который необходимо показать
     *
     * - **proto_id** : Number
     *
     * Прототип предмета, который необходимо показать
     *
     * - **quantity** : Number
     *
     * Количество (по идее не нужно)
     *
     * - **itemEl** : Number
     *
     * DOM элемент, около которого показать окно
     *
     * @private
     */
    showItemWindow: function(options) {
        var me = this,
            protos = me.application.getItemPrototypesStore(),
            stuffMgr = ExGods.stuff.StuffManager,
            fn = function() {
                var cfg = {
                        params: {
                            id: options.proto_id,
                            quantity: options.quantity || 1
                        },
                        type: options.type
                    };
                if (options.item) {
                    cfg.params.itemModel = options.item;
                }
                var obj = stuffMgr.factory(cfg);
                if (obj) {
                    return obj.details({
                        clickedEl: options.itemEl,
                        tooltip: options.tooltip
                    });
                }
            };
        if (!options.item) {
            protos.loadNew([
                options.proto_id
            ], fn);
        } else {
            return fn();
        }
    },
    /**
     * @private
     * Показывает окошко подтверждения с кнопками "Да"/"Нет"
     *
     * @param {String} message Сообщение диалога (required)
     * @param {Object} options Опции:
     *
     *     handler {Function} - коллбек, при положительном ответе
     *     buttonsText {Array} - текст кнопок
     *
     * @author Олег Михайлов
     */
    showActionConfirmation: function(message, options) {
        var me = this,
            config = options || {};
        config.message = message;
        config.handler = {
            fn: options.handler,
            scope: me
        };
        Ext.widget('confirmdialog', config);
    },
    initItemTargetPanelComponent: function(config, componentId) {
        var me = this,
            items = [],
            actions = [],
            cmp, wnd,
            checkFilterSlot = function(slot) {
                var map_action = (config.action.params && typeof config.action.params.map_action == 'object') ? config.action.params.map_action[0] : undefined,
                    filter_slots = (map_action && map_action.target_params && map_action.target_params.filter_slots) ? map_action.target_params.filter_slots : undefined,
                    type = slot.get('type'),
                    valid = false;
                if (filter_slots) {
                    Ext.each(filter_slots, function(fslot) {
                        if (fslot.slot == type)  {
                            valid = true;
                        }
                        
                    });
                } else {
                    valid = true;
                }
                return valid;
            };
        switch (config.source) {
            case 'damaged':
                // выбираю предметы, для ремонта
                me.getUser().slots().each(function(slot) {
                    slot.items().each(function(item) {
                        if (item.isDamaged() && checkFilterSlot(slot)) {
                            items.push(item);
                        }
                    });
                });
                break;
            case 'upgraded':
                // выбираю усиленные предметы
                me.getUser().slots().each(function(slot) {
                    slot.items().each(function(item) {
                        if (item.isUpgraded() && checkFilterSlot(slot)) {
                            items.push(item);
                        }
                    });
                });
                break;
            case 'filtered':
                var filters = {},
                    item_proto = ExGods.app.getItemPrototypesStore(),
                    tp = config.targetParams;
                Ext.Array.each(tp.filter_list, function(f) {
                    switch (f.filter_type) {
                        case 'ilist':
                            if (!filters.items)  {
                                filters.items = [];
                            }
                            ;
                            filters.items = filters.items.concat(Ext.Array.map(f.filter_data.items, function(item) {
                                return Number(item.item);
                            }));
                            break;
                        case 'itype':
                            if (!filters.types)  {
                                filters.types = [];
                            }
                            ;
                            filters.types = filters.types.concat(Ext.Array.map(f.filter_data.types, function(type) {
                                return Number(type.type);
                            }));
                            break;
                        case 'igrade':
                            filters.grade = parseInt(f.filter_data.item_grade) || 1;
                            break;
                        case 'ibreak':
                            filters.broken = parseInt(f.filter_data.item_break) || 0;
                            break;
                        case 'irepair':
                            filters.repair = parseInt(f.filter_data.item_repair) || 0;
                            break;
                        case 'itemp':
                            filters.temp = parseInt(f.filter_data.item_temp) || 0;
                            break;
                        case 'iupgrade':
                            filters.upgrade = parseInt(f.filter_data.item_upgrade) || 0;
                            break;
                    }
                });
                // выбираю предметы по фильтру
                me.getUser().slots().each(function(slot) {
                    slot.items().each(function(item) {
                        var pid = item.get("proto_id"),
                            proto = item_proto.getById(pid);
                        if ((filters.items == undefined || filters.items.indexOf(pid) != -1) && (filters.types == undefined || filters.types.indexOf(proto.get("type")) != -1) && (filters.grade == undefined || (proto.get('data').item_grade || 1) == filters.grade) && (filters.broken == undefined || item.isDamaged() == !!filters.broken) && (filters.repair == undefined || !parseInt(item.get('param').nonrep) == !!filters.repair) && (filters.temp == undefined || Boolean(item.get('param').expire_str) == Boolean(filters.temp)) && (filters.upgrade == undefined || !!item.get('param').upgrades == !!filters.upgrade)) {
                            items.push(item);
                        }
                    });
                });
                // сортирую по уровню прочности (менее прочные наверху)
                items = Ext.Array.sort(items, function(a, b) {
                    return a.getDur() - b.getDur();
                });
                break;
            default:
                break;
        }
        for (var i = 1; i < 5; i++) {
            var label = config['btn' + i];
            if (label) {
                var act = config['act' + i];
                var clientAction = {
                        text: label,
                        xtype: "textbutton",
                        margin: '3 5 0 5',
                        disabled: true
                    };
                if (Ext.isObject(act)) {
                    Ext.apply(clientAction, {
                        clientAction: act.id,
                        handler: function() {
                            var selection = button.up().down('viewpanel').getView().getSelectionModel().getSelection();
                            if (selection.length) {
                                ExGods.ClientActions.createAndInvoke({
                                    actionId: this.clientAction,
                                    selected_target: selection[0]
                                }, function() {
                                    wnd.close();
                                }, function(err) {
                                    /***/
                                    me.log('error', err);
                                });
                            }
                        }
                    });
                }
                actions.push(clientAction);
            }
        }
        cmp = Ext.widget('itemtargetwindow', {
            windowTitle: config.windowTitle,
            items: items,
            action: config.action,
            singleBtn: false,
            buttonCls: 'item-button no_border',
            clientActions: actions,
            listeners: config.listeners || [],
            emptyText: config.emptyText
        });
        cmp.on('destroy', function() {
            wnd.close();
        });
        wnd = Ext.widget('floatwindow', {
            id: componentId,
            autoShow: true,
            plugins: [
                'skindeco'
            ],
            width: 360,
            height: 360,
            y: 100,
            items: [
                cmp
            ]
        });
        return wnd;
    }
});

/**
 * Управление подсказками
 */
Ext.define('ExGods.controller.Hints', {
    extend: ExGods.controller.Base,
    /**
     * @private
     */
    init: function(app) {
        var me = this;
        app.on({
            notshowhint: me.onNotShowHint,
            scope: me
        });
    },
    onLaunch: function(app) {},
    /**
     * Готовит блок подсказок к показу
     *
     * @param {Ext.Component} cmp
     * @param {Object} options
     */
    prepareHints: function(cmp, options) {
        var me = this,
            app = me.application,
            blocks = options.blocks;
        if (blocks.length) {
            var block = blocks.shift();
            if (app.gameStarted) {
                me.showHints(block, blocks);
            } else {
                app.on('gamestarted', function() {
                    me.showHints(block, blocks);
                }, me, {
                    single: true
                });
            }
        } else {
            app.fireEvent('hintsshowed');
        }
    },
    /**
     * Показывает блок подсказок
     * name - идентификатор хинта
     * startIndex - индекс массива, с которого показывать хинты
     */
    showHints: function(name, startIndex) {
        var me = this,
            refData = ExGods.references.get('user_hint').get(name),
            i = startIndex || 0;
        if (refData && refData.length && refData[i]) {
            var tips = [],
                user = me.getUser(),
                read_hints = user.get('read_hints'),
                new_read_hints = [],
                block = refData[i],
                tip;
            i++;
            Ext.Array.each(block.data, function(hint) {
                if (!Ext.Array.contains(read_hints, hint.id)) {
                    if (hint.is_main != 0) {
                        var main_tip = Ext.widget('direction', {
                                is_main: true,
                                layer: 'directions-layer',
                                config: {
                                    x: hint.coords.x,
                                    y: hint.coords.y,
                                    label: hint.label,
                                    text: hint.text,
                                    close_btn: 1,
                                    btn: {
                                        text: ExGods.getMsgByKey('close_btn_text'),
                                        handler: function() {
                                            main_tip.close();
                                        }
                                    }
                                },
                                listeners: {
                                    close: function() {
                                        Ext.Array.forEach(tips, function(tip) {
                                            if (tip != main_tip) {
                                                tip.close();
                                            }
                                        });
                                        Ext.getBody().unmask();
                                        me.request({
                                            url: '/game.pl?cmd=read_hints',
                                            params: {
                                                hints: new_read_hints
                                            },
                                            success: function(json) {
                                                if (json.success) {
                                                    ExGods.app.getUser().set('read_hints', json.read_hints);
                                                }
                                            }
                                        });
                                        me.showHints(name, i);
                                    }
                                }
                            });
                        tips.push(main_tip);
                        main_tip.show();
                    } else {
                        tips.push(Ext.create('Ext.window.Window', {
                            autoShow: true,
                            draggable: false,
                            header: false,
                            html: hint.text,
                            plugins: [
                                'hintdeco'
                            ],
                            resizable: false,
                            shadow: 'frame',
                            renderTo: 'viewport',
                            minHeight: 0,
                            width: hint.coords.width,
                            height: hint.coords.height,
                            x: hint.coords.x,
                            y: hint.coords.y
                        }));
                    }
                    new_read_hints.push(hint.id);
                }
            });
            if (tips.length)  {
                Ext.getBody().mask().setStyle('opacity', 0.15);
            }
            
        }
    },
    // var closer = Ext.create('Ext.window.Window', {
    //  autoShow: true,
    //  draggable: false,
    //  header: false,
    //  html: block.description,
    //  plugins: ['hintdeco'],
    //  resizable: false,
    //  renderTo: 'viewport',
    //  shadow: 'frame',
    //  minWidth: 120,
    //  minHeight: 0,
    //  width: block.coords.width,
    //  height: block.coords.height,
    //  x: block.coords.x,
    //  y: block.coords.y,
    //  buttonAlign: 'center',
    //  buttons: [{
    //      xtype: 'textbutton',
    //      text: 'Закрыть',
    //      handler: function() {
    //          Ext.Array.forEach(tips, function(tip) {
    //              tip.close();
    //          });
    //          Ext.getBody().unmask();
    //          me.request({
    //              url: '/game.pl?cmd=read_hints',
    //              params: {
    //                  hints: new_read_hints
    //              },
    //              success:function(json){
    //                  if(json.success){
    //                      ExGods.app.getUser().set('read_hints',json.read_hints);
    //                  }
    //              }
    //          });
    //          me.showHints(name,i);
    //      }
    //  }]
    // });
    // tips.push(closer);
    /**
     * Показывает подсказку по ID
     */
    showHintById: function(hintId) {
        var me = this,
            name, index;
        ExGods.references.get('user_hint').each(function(blockName, items) {
            Ext.Array.each(items, function(item) {
                Ext.Array.each(item.data, function(hint, i) {
                    if (hintId == hint.id) {
                        name = blockName;
                        index = i;
                    }
                });
            });
        });
        if (name) {
            me.showHints(name, index);
        }
    },
    /**
     * Функция пока нигде не используется и нужня для ресета хинтов через консоль
     */
    resetHints: function() {
        this.request({
            url: '/game.pl?cmd=reset_all_hints',
            success: function(json) {
                if (json.success) {
                    ExGods.app.getUser().set('read_hints', json.read_hints);
                }
            }
        });
    },
    onNotShowHint: function(hint_id) {
        ExGods.app.getController('Base').request({
            url: '/game.pl?cmd=read_interface',
            params: {
                id: hint_id
            },
            success: function(json) {
                ExGods.app.user.set('read_hints', json.read_hints);
            }
        });
    },
    /**
     * Фильтрует хинты, получаем только хитны "С подтверждением"
     * @param allHints все хинты локации
     * @returns {Array} хинты с типом "С подтверждением"
     */
    getConfirmationHintsFromArray: function(allHints) {
        var result_array = [];
        if (allHints) {
            Ext.Array.forEach(allHints, function(hints_data_element) {
                var hint = ExGods.references.get('user_hint').getById(parseInt(hints_data_element.entry));
                if (hint) {
                    Ext.Array.forEach(hint.data.data, function(hint_data_element) {
                        if (hint_data_element.type && hint_data_element.type == 'confirm' && !Ext.Array.contains(ExGods.app.user.get('read_hints'), hint_data_element.id)) {
                            result_array.push({
                                hint_text: hint_data_element.text,
                                entry: hints_data_element.entry
                            });
                        }
                    });
                }
            });
        }
        return result_array;
    },
    showConfirmations: function(hints_array, callback) {
        var agree_count = 0;
        Ext.widget('confirmdialog', {
            title: '',
            message: hints_array[0].hint_text,
            entry: hints_array[0].entry,
            handler: function() {
                //если количество положительных ответов равно количеству подсказок, то делаем действие
                if (agree_count == hints_array.length - 1) {
                    callback();
                }
            }
        });
        for (var i = 1; i < hints_array.length; i++) {
            Ext.widget('confirmdialog', {
                title: '',
                message: hints_array[i].hint_text,
                entry: hints_array[i].entry,
                handler: function() {
                    agree_count++;
                }
            });
        }
    }
});

/**
 * Mixin, флаги
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGods.util.Flags', {
    set_f: function(f, v) {
        var me = this;
        me['f_' + f] = v;
        if (me.log) {
            me.log('f_' + f, v);
        }
    },
    get_f: function(f) {
        var me = this;
        return me['f_' + f];
    },
    if_f: function(f, fn, else_fn) {
        var me = this;
        if (me['f_' + f]) {
            fn();
        } else if (else_fn) {
            else_fn();
        }
    },
    if_not_f: function(f, fn) {
        var me = this;
        if (!me['f_' + f]) {
            fn();
        }
    }
});

/**
 * Панел с Ext.view.View внутри.
 * Очень распространён в игре, особенно, когда нужна прокрутка содержимого.
 */
Ext.define('ExGods.view.ViewPanel', {
    extend: Ext.panel.Panel,
    alias: 'widget.viewpanel',
    hasView: false,
    initComponent: function() {
        var me = this,
            view;
        me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store');
        me.bodyCls = me.bodyCls || '';
        me.bodyCls += (' ' + me.extraBodyCls);
        me.cls = me.cls || '';
        me.cls += (' ' + me.extraBaseCls);
        if (!me.hasView) {
            me.viewConfig = me.viewConfig || {};
            view = me.getView();
            me.items = [
                view
            ];
            me.hasView = true;
            me.relayEvents(view, [
                'itemclick',
                'refresh',
                'resize',
                'viewready'
            ]);
        }
        delete me.autoScroll;
        me.callParent();
    },
    getStore: function() {
        return this.store;
    },
    getView: function() {
        var me = this;
        if (!me.view) {
            me.view = Ext.ComponentManager.create(Ext.apply({}, me.viewConfig, {
                store: me.store,
                panel: me,
                autoShow: false,
                xtype: 'dataview'
            }));
        }
        return me.view;
    },
    isViewReady: function() {
        var me = this;
        return me.getView().viewReady;
    },
    bindStore: function(store) {
        var me = this;
        me.store = store;
        me.getView().bindStore(store);
    },
    onDestroy: function() {
        var me = this;
        me.callParent();
        me.bindStore(null);
    }
});

/**
 * Список NPC в локации
 */
Ext.define('ExGods.view.location.lob.BotsList', {
    extend: ExGods.view.ViewPanel,
    alias: 'widget.locationbots',
    cls: 'location-bot-list',
    /**
     * @cfg clientObject {Object} Конфигурация компонента из справочника Клиент-Объекты
     */
    clientObject: {},
    /**
     * @cfg locationObject {Object} Данные из справочника объектов локации
     */
    locationObject: {},
    closeAction: 'hide',
    flex: 1,
    header: false,
    cooldowns: {},
    cooldowns_delays: {},
    // время задержки отрисовки таймеров
    width: 90,
    height: 358,
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    initComponent: function() {
        var me = this;
        me.viewConfig = {
            itemSelector: 'li.bot',
            prepareData: Ext.Function.bind(me.prepareData, me),
            tpl: [
                '<div class="location-header" style="margin:0 auto; margin-bottom: -2px;"><div class="location-header-title creatures" style="background-image:url(' + ExGods.ref('images|location_images').image['monsters_title'] + ');"></div></div>',
                '<ul class="bot-list">',
                '<tpl for=".">',
                '<tpl if="values.wait">' + '<div id="surging_image"></div>' + '<div id="surging_wait">{[this.createSurgingWaitTimer(values)]}</div>' + '<tpl else>' + '<li class="bot <tpl if="values.hostile">bot-hostile</tpl> qh-object"',
                'data-qh_otype="bot" data-qh_oid="{bot_type}" data-qtip="{display_title}">',
                '<div class="image qh-object" data-qh_otype="bot_any" data-qh_oid="1" style="background-image: url({images.thumb}), url({toughness.image})"></div>',
                '<div id="bot_{entry}" class="timer{[this.checkVisible(values)]}">{[this.createTimer(values)]}</div>',
                '<span class="level" style="color: #feefb4; bottom: 4px">{level}</span>',
                '<tpl if="chain_next_time">',
                '{[ ExGods.util.Timers.printTimer("rest", "", values.chain_next_time, {needNormalized: true}) ]}',
                '</tpl>',
                '</li>',
                '</tpl>' + '</tpl>',
                '</ul>',
                {
                    createTimer: function(data) {
                        var timeLeft = me.calcLeftTime(data);
                        if (timeLeft) {
                            var arr = [],
                                s = 52,
                                //длина стороны квадрата в пикселях;
                                tickTime = Math.round((data.cooldown_banish * 1000 - (me.cooldowns_delays[data.entry] || 0)) / 360),
                                curTime = new Date(),
                                intervalFn = me.cooldowns[data.entry],
                                //timeLeft = me.calcLeftTime(data),
                                i = Math.ceil(361 - timeLeft * 360 / data.cooldown_banish / 1000),
                                x, y, i, poly, time, ticks;
                            if (intervalFn) {
                                clearInterval(intervalFn);
                            }
                            for (; i < 361; i++) {
                                if (i <= 45) {
                                    x = Math.round(s / 2 + s * i / 90);
                                    y = 0;
                                } else if (i > 45 && i <= 135) {
                                    x = s;
                                    y = Math.round(s * (i - 45) / 90);
                                } else if (i > 135 && i <= 225) {
                                    x = Math.round(s * (90 - (i - 135)) / 90);
                                    y = s;
                                } else if (i > 225 && i <= 315) {
                                    x = 0;
                                    y = Math.round(s * (90 - (i - 225)) / 90);
                                } else if (i > 315) {
                                    x = Math.round(s * (i - 315) / 90);
                                    y = 0;
                                }
                                arr.push([
                                    x,
                                    y
                                ]);
                            }
                            if (arr.length) {
                                arr.push([
                                    s / 2,
                                    s / 2
                                ]);
                            } else  {
                                return;
                            }
                            
                            me.cooldowns[data.entry] = setInterval(function() {
                                var el = Ext.get('bot_' + data.entry);
                                if (arr.length) {
                                    if (el) {
                                        if (el.down('svg')) {
                                            poly.plot(arr);
                                        } else {
                                            var svg = SVG('bot_' + data.entry).size(s, s);
                                            poly = svg.polygon(arr).fill('black').opacity(0.5);
                                        }
                                    }
                                    time = new Date();
                                    ticks = Math.round((time - curTime) / tickTime);
                                    curTime = time;
                                    arr.splice(0, ticks);
                                } else {
                                    clearInterval(me.cooldowns[data.entry]);
                                    delete me.cooldowns[data.entry];
                                    delete me.cooldowns_delays[data.entry];
                                    if (el)  {
                                        el.remove();
                                    }
                                    
                                }
                            }, tickTime);
                        }
                    },
                    checkVisible: function(data) {
                        return (me.calcLeftTime(data)) ? ' ' : ' hidden';
                    },
                    createSurgingWaitTimer: function(data) {
                        if (me.surgingwait) {
                            clearInterval(me.surgingwait);
                            delete me.surgingwait;
                        }
                        
                        var time = data.wait;
                        me.surgingwait = setInterval(function() {
                            var el = Ext.get('surging_wait');
                            var el_img = Ext.get('surging_image');
                            var currTime = time - new Date() / 1000;
                            if (currTime > 1) {
                                if (el)  {
                                    el.setHTML(ExGods.app.applyTpl(ExGods.getMsgByKey('view_location_bots_morein'), {
                                        time: ExGods.util.Time.printTime(currTime, {
                                            format: 'short'
                                        })
                                    }));
                                }
                                
                            } else {
                                ExGods.app.getChatConnection().ping();
                                clearInterval(me.surgingwait);
                                delete me.surgingwait;
                                ExGods.app.getSurgingController().surging_wait = 0;
                                if (el)  {
                                    el.remove();
                                }
                                
                                if (el_img)  {
                                    el_img.remove();
                                }
                                
                            }
                        }, 1000);
                        return ExGods.app.applyTpl(ExGods.getMsgByKey('view_location_bots_morein'), {
                            time: ExGods.util.Time.printTime(time - new Date() / 1000, {
                                format: 'short'
                            })
                        });
                    }
                }
            ],
            getResources: function() {
                me;
                var arr_images = [],
                    shapeRef = ExGods.ref('user_shape');
                if (me.store.removed) {
                    for (var i = 0; i < me.store.removed.length; i++) {
                        var item = me.store.removed[i].data;
                        if (item.shape) {
                            var shape = shapeRef.getByKey(item.shape);
                            arr_images.push(shape.thumb);
                        }
                    }
                }
                return {
                    images: [].concat(arr_images),
                    stuff: []
                };
            }
        };
        me.callParent();
        //me.store.on('stateschanged', me.onStatesChanged, me);
        me.on('removed', function() {
            if (me.surgingwait) {
                clearInterval(me.surgingwait);
                delete me.surgingwait;
            }
            
        }, me);
    },
    //me.store.on('datachanged',me.showHideCmp,me);
    //me.on('afterrender',me.showHideCmp,me);
    showHideCmp: function() {
        var me = this;
        if (!me.rendered)  {
            return;
        }
        
        if (me.store.data.length && !me.isVisible()) {
            me.show();
        }
        if (!me.store.data.length && me.isVisible()) {
            me.hide();
        }
    },
    /**
     * @private
     * Добавляет необходимые данные для шаблона.
     *
     * Проверяется состояние бота (которое приходит от сервера):
     *
     * - 1 - Задание выполнено
     * - 2 - Есть новое задание от бота
     */
    prepareData: function(data, recordIndex, record) {
        var me = this,
            toughnessImages = ExGods.ref('images|bot_toughness_images').image,
            toughnessColor = {
                green: '6eff42',
                yellow: 'ffef42',
                red: 'ff3c3c'
            };
        if (data.wait) {
            return {
                wait: data.wait
            };
        }
        return {
            images: ExGodsCore.app.references.get('user_shape').getByKey(data.shape),
            display_title: data.label,
            level: data.count,
            last_banish: record.data.last_banish,
            cooldown_banish: record.data.cooldown_banish,
            bot_type: data.bot_type,
            entry: data.entry,
            hostile: true,
            toughness: {
                image: toughnessImages[data.toughness],
                color: toughnessColor[data.toughness]
            },
            chain: data.chain,
            chain_next_time: data.chain_next_time
        };
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        // чтобы квест маркер был виден
        me.getEl().setStyle({
            overflow: 'visible'
        });
        me.body.el.setStyle({
            overflow: 'visible'
        });
    },
    calcLeftTime: function(record, useDelay) {
        var me = this,
            end_sec_time, ret;
        end_sec_time = record.last_banish + record.cooldown_banish + ExGods.util.Date.serverTimeOffset;
        ret = end_sec_time * 1000 - new Date().getTime();
        if (!me.cooldowns_delays[record.entry] && ret > 0) {
            me.cooldowns_delays[record.entry] = record.cooldown_banish * 1000 - ret;
        }
        ret += (me.cooldowns_delays[record.entry] || 0);
        return ret > 0 ? ret : 0;
    },
    /**
     * Анимирует получение приза на аватарке бота
     */
    animatePrize: function(botEntry, stuff, callback) {
        var me = this,
            record = me.store.getById(botEntry),
            recordEl, index, currency, ct;
        if (record) {
            recordEl = me.view.getNode(record);
        }
        if (recordEl) {
            index = me.view.indexOf(recordEl);
            ct = this.getEl().insertHtml('beforeEnd', '<div style="position: absolute; width: 82px; height: 82px; top: ' + (42 + index * 82) + 'px;"></div>', true);
            ct.on('click', function() {
                recordEl.click();
            });
            el = ExGods.helpme.animateCurrency(ct, stuff, function() {
                if (callback) {
                    ct.remove();
                    callback();
                }
            }, 'prize-anim');
            if (el) {
                el.applyStyles({
                    left: Math.max(41 - el.getWidth() / 2, 0) + 'px'
                });
            } else // центровка, 41 - половина ширины ячейки
            {
                if (callback) {
                    ct.remove();
                    callback();
                }
            }
        } else {
            if (callback) {
                callback();
            }
        }
    },
    /**
     * Стандартная функция обработки клика для компонента, используемого как объект локации
     */
    locationObjectClickHandler: function() {
        return false;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            imgs;
        imgs = ExGods.ref('images|bot_toughness_images').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Объект локации - вход в сервис. Отображается как картинка с текстом на локации
 */
Ext.define('ExGods.view.location.lob.ServiceEnter', {
    extend: Ext.Component,
    alias: 'widget.serviceenter',
    /**
     * @cfg clientObject {Object} Конфигурация компонента из справочника Клиент-Объекты
     */
    clientObject: {},
    /**
     * @cfg locationObject {Object} Данные из справочника объектов локации
     */
    locationObject: {},
    cls: 'location-service-enter-view',
    initComponent: function() {
        var me = this;
        me.height = me.locationObject.interactive.h;
        me.width = me.locationObject.interactive.w;
        me.tpl = [
            '<div class="light-img" style="background-image: url(' + IMAGE_URL + '{lightImg});"></div>',
            '<div class="image" style="{[ values.image ? "background-image: url("+ values.image +")" : "" ]};"></div>',
            '<tpl if="masked">',
            '<tpl if="Ext.isChrome">',
            '<div class="image-mask" style="{[ values.image ? "-webkit-mask-image: url("+ values.image +")" : "" ]};"></div>',
            '</tpl>',
            '</tpl>'
        ];
        me.data = {
            lightImg: me.clientObject.lightImg,
            masked: me.clientObject.masked
        };
        me.callParent(arguments);
    },
    /**
     * Обновить данные сервиса (text, image)
     */
    setServiceData: function(data) {
        var me = this;
        me.serviceData = data;
        if (!me.rendered) {
            me.update({
                lightImg: me.clientObject.lightImg,
                image: me.serviceData.image ? IMAGE_URL + me.serviceData.image : Ext.BLANK_IMAGE_URL,
                masked: me.clientObject.masked
            });
        } else {
            me.getEl().down('.image').setStyle('background-image', 'url(' + (me.serviceData.image ? IMAGE_URL + me.serviceData.image : Ext.BLANK_IMAGE_URL) + ')');
            if (me.clientObject.masked) {
                if (Ext.isChrome) {
                    me.getEl().down('.image-mask').setStyle('-webkit-mask-image', 'url(' + (me.serviceData.image ? IMAGE_URL + me.serviceData.image : Ext.BLANK_IMAGE_URL) + ')');
                }
            }
        }
        if (me.ownerCt) {
            me.ownerCt.titleComponent.show();
        }
        ExGods.Resources.load(me, function() {
            me.show();
        });
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        // скрываю заголовок компонента объекта локации пока компонент не отрисован
        if (!me.isVisible()) {
            me.ownerCt.titleComponent.hide();
        }
    },
    overListener: function() {
        var me = this,
            maskEl = me.el.down('.image-mask'),
            lightImg = me.el.down('.light-img');
        if (lightImg) {
            lightImg.setStyle('opacity', 1);
        }
        if (maskEl && me.clientObject.masked) {
            maskEl.setStyle('opacity', 0);
        }
    },
    leaveListener: function() {
        var me = this,
            maskEl = me.el.down('.image-mask'),
            lightImg = me.el.down('.light-img');
        if (lightImg) {
            lightImg.setStyle('opacity', 0);
        }
        if (maskEl && me.clientObject.masked) {
            maskEl.setStyle('opacity', 0.3);
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        var img = me.data.lightImg;
        if (me.data.image) {
            arr_images.push(me.data.image);
        }
        return {
            stuff: [],
            images: [
                IMAGE_URL + img
            ].concat(arr_images)
        };
    }
});

/**
 * Модель локации
 */
Ext.define('ExGods.model.Location', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    proxy: 'memory',
    fields: [
        {
            name: 'action',
            type: 'auto'
        },
        {
            // параметры локации
            name: 'blob',
            convert: function(v) {
                if (v) {
                    // преобразую объекты локации в более удобный вид - каждый объект локации однозначно связан с одним интерактивом
                    v.objects = (function() {
                        var objects = [];
                        Ext.Array.each(v.objects || [], function(item) {
                            var interactive = item.interactive;
                            Ext.Array.each(interactive, function(interactiveItem) {
                                var itemClone = Ext.clone(item);
                                itemClone.interactive = interactiveItem;
                                objects.push(itemClone);
                            });
                        });
                        return objects;
                    }());
                }
                return v;
            }
        },
        {
            // идентификатор комнаты в чате
            name: 'chat_room_name',
            type: 'string'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            // название комнаты
            name: 'name',
            type: 'string'
        },
        {
            name: 'prototype',
            type: 'auto'
        },
        {
            // id мира локации
            name: 'world',
            type: 'int'
        },
        {
            // квестовые боты
            name: 'quest_bots',
            type: 'auto'
        },
        {
            // бот в боевой цепочке
            name: 'battle_chain',
            type: 'auto'
        }
    ],
    /**
     * Возвращает адрес картинки локации
     * @return {String} Адрес картинки
     */
    getThumb: function() {
        return this.get('blob').thumb ? IMAGE_URL + this.get('blob').thumb : Ext.BLANK_IMAGE_URL;
    },
    /**
     * Возвращает название локации
     * @return {String} Название локации
     */
    getName: function() {
        return this.get('name');
    },
    /**
     * Возвращает адрес картинки локации
     * @return {String} Адрес картинки
     */
    getImage: function() {
        return IMAGE_URL + this.get('blob').image || Ext.BLANK_IMAGE_URL;
    },
    getType: function() {
        return this.get('prototype').type;
    },
    /**
     * Вернет массив интерактивных объектов локации
     * @return {Array} Массив объектов вида:
     *      {
     *          type - тип объета,
     *          params_type - параметры объекта 
     *          interactive - параметры для отображения
     *          description - текстовое описание 
     *      }
     */
    getObjects: function() {
        return this.get('blob').objects || [];
    },
    /**
     * Вернет прототип локации
     * @return {Object}
     */
    getProto: function() {
        var me = this,
            proto = me.get('prototype');
        if (typeof proto == "object") {
            return proto;
        } else {
            return ExGods.references.get('prototypes_rooms').get(parseInt(proto, 10));
        }
    },
    /**
     * Вернет true, если локация опасна
     */
    isDanger: function() {
        var me = this;
        return this.getProto().blob.danger === "1";
    },
    /**
     * Вернёт мир, к которой привязана локация
     */
    getWorld: function() {
        var me = this,
            worlds = ExGods.app.getWorldsStore();
        return worlds.getById(me.get('world'));
    },
    afterEdit: function(modifiedFields) {
        var me = this;
        /**
         * @event locationchanged Глобальное событие - изменение локации
         */
        me.fireEvent('locationchanged');
        Ext.Array.each(modifiedFields, function(key) {
            /**
             * Выбрасываю событие изменения модели для каждого поля
             */
            me.fireEvent(key + 'changed', me, me.get(key));
        });
    }
});

/**
 * Объект локации - кнопка "Закрыть локацию"
 */
Ext.define('ExGods.view.location.lob.CloseButton', {
    extend: Ext.Component,
    alias: 'widget.closelocationbtn',
    /**
     * @cfg clientObject {Object} Конфигурация компонента из справочника Клиент-Объекты
     */
    clientObject: {},
    /**
     * @cfg locationObject {Object} Данные из справочника объектов локации
     */
    locationObject: {},
    cls: 'location-close-button',
    initComponent: function() {
        var me = this;
        me.width = me.clientObject.width || 114;
        me.height = me.clientObject.height || 40;
        me.style = {
            backgroundImage: 'url(' + IMAGE_URL + me.clientObject.backImg + ')'
        };
        me.tpl = '<div class="button"></div>';
        me.data = {};
        me.callParent(arguments);
    },
    /**
     * Стандартная функция обработки клика для компонента, используемого как объект локации
     */
    locationObjectClickHandler: function(e) {
        var me = this;
        if (e.getTarget('.button')) {
            return true;
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + me.clientObject.backImg
            ]
        };
    }
});

/**
 * Базовый класс объекта локации
 */
Ext.define('ExGods.view.location.LocationObject', {
    extend: Ext.container.Container,
    alias: 'widget.locationobject',
    /**
     * @cfg {Object} Данные объекта локации
     */
    objData: {},
    cls: 'location-object',
    overCls: 'location-object-over',
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: {
            info: false,
            wrap: true,
            error: true
        },
        prefix: 'LocationObject:'
    },
    initComponent: function() {
        var me = this;
        me.innerComponent = me.initInnerComponent();
        me.innerComponent.on('afterrender', me.onAfterRender, me);
        me.titleComponent = me.initTitleComponent();
        Ext.apply(me, {
            x: me.objData.interactive.x,
            y: me.objData.interactive.y,
            width: me.objData.interactive.w,
            height: me.objData.interactive.h,
            style: {
                'z-index': me.objData.interactive.z || 0
            },
            items: [
                me.titleComponent,
                me.innerComponent
            ]
        });
        me.callParent(arguments);
    },
    /**
     * @template
     * Инициализирует внутренний компонент объекта.
     * @return {Ext.Component}
     */
    initInnerComponent: function() {},
    //
    /**
     * Вернет текст названия объекта, который будет отображаться в виде всплывающей плашки над объектом
     */
    getTitleText: function() {
        var me = this;
        if (typeof me.innerComponent.getTitleText == 'function') {
            return me.innerComponent.getTitleText();
        } else {
            return me.objData.interactive.params_display.label;
        }
    },
    /**
     * Вернет текст тултипа объекта
     * @return {Object} Объект вида {title: <String>, text: <String>}
     */
    getTooltipText: function() {
        var me = this;
        if (typeof me.innerComponent.getTooltipText == 'function') {
            return me.innerComponent.getTooltipText();
        } else if (me.objData.interactive.description) {
            return {
                title: me.objData.description,
                text: me.objData.interactive.description
            };
        }
    },
    /**
     * @template
     * Вернет dom-элемент для стандартной анимации свечения объекта локации
     * @return {Ext.dom.Element} DOM-элемент, который нужно анимировать или null, если анимация не требуется
     */
    getAnimationTarget: function() {},
    //
    /**
     *  Обработчик клика по объекту локации
     */
    locationObjectClickHandler: function() {
        var me = this;
        if (me.objData.client_action && me.objData.client_action.id) {
            ExGods.ClientActions.createAndInvoke({
                actionId: me.objData.client_action.id,
                src: 'location-object',
                options: {
                    locationObject: me.objData
                }
            }, null, function(err) {
                /****/
                me.log('error', err);
            });
        }
    },
    /**
     * Инициализация компонента заголовка
     */
    initTitleComponent: function() {
        var me = this,
            title = me.getTitleText(),
            titleWidth = 105,
            topOffset = me.objData.interactive.params_display.d ? me.objData.interactive.params_display.d : me.objData.interactive.h / 2 - 28,
            scrollingTime = parseFloat(ExGods.ref('constants|animate_scrolling_time').value),
            scrollingDistance = parseFloat(ExGods.ref('constants|animate_scrolling_distance').value),
            onOver = function() {
                var el = me.titleComponent.getEl();
                el.stopAnimation();
                el.animate({
                    duration: scrollingTime,
                    to: {
                        'top': topOffset - scrollingDistance
                    }
                });
            },
            onLeave = function() {
                var el = me.titleComponent.getEl();
                el.stopAnimation();
                el.animate({
                    duration: scrollingTime,
                    to: {
                        'top': topOffset
                    }
                });
            };
        if (title) {
            me.addOnOverListener(onOver);
            me.addOnLeaveListener(onLeave);
            return Ext.widget('component', {
                autoEl: 'span',
                cls: 'location-object-title',
                tpl: [
                    '<span class="location-object-title-inner">{title}</span>'
                ],
                data: {
                    title: title
                },
                style: {
                    'left': ((me.objData.interactive.w - titleWidth) / 2 - 30) + 'px',
                    'top': topOffset + 'px'
                }
            });
        }
    },
    onAfterRender: function() {
        var me = this;
        me.tuneQuestHelperOptions(me.getEl());
        if (me.getTooltipText()) {
            me.createTooltip();
        }
        if (me.getAnimationTarget()) {
            me.startAnimation();
        }
        me.getEl().on('click', function(e) {
            me.onClick(e);
        });
    },
    /**
     * @private Стандартная анимация свечения 
     */
    startAnimation: function() {
        var me = this,
            animTarget = me.getAnimationTarget(),
            tickSize = 100,
            time_to_show = parseFloat(ExGods.ref('constants|animate_to_show').value),
            time_on_peak = parseFloat(ExGods.ref('constants|animate_on_peak').value),
            time_to_hide = parseFloat(ExGods.ref('constants|animate_to_hide').value),
            time_pause = parseFloat(ExGods.ref('constants|animate_pause').value),
            max_intensity = parseFloat(ExGods.ref('constants|animate_intensity').value),
            phases = [
                {
                    dur: time_to_show,
                    opacity: 0,
                    tick: function() {
                        setOpacity(this, this.opacity + (max_intensity / (time_to_show / tickSize)));
                    },
                    finish: function() {
                        setOpacity(this, max_intensity);
                    }
                },
                {
                    dur: time_on_peak,
                    tick: Ext.emptyFn,
                    finish: Ext.emptyFn
                },
                {
                    dur: time_to_hide,
                    tick: function() {
                        setOpacity(this, this.opacity - (max_intensity / (time_to_hide / tickSize)));
                    },
                    finish: function() {
                        setOpacity(this, 0);
                    }
                },
                {
                    dur: time_pause,
                    tick: Ext.emptyFn,
                    finish: function() {
                        stopAnim = overed ? true : false;
                        setOpacity(this, 0);
                    }
                }
            ],
            setOpacity = function(phase, opacity) {
                if (!stopAnim) {
                    phase.opacity = opacity;
                    animTarget.dom.style.opacity = opacity;
                }
            },
            currentPhase = 0,
            spentTime = 0,
            stopAnim = false,
            overed = false,
            rootEl = me.getEl(),
            onOver = function() {
                overed = true;
                stopAnim = true;
                animTarget.stopAnimation();
                animTarget.setStyle('background-position', '0px 100%');
                animTarget.animate({
                    duration: 400,
                    to: {
                        'opacity': 1
                    }
                });
            },
            onLeave = function() {
                overed = true;
                stopAnim = true;
                animTarget.animate({
                    duration: 400,
                    to: {
                        'opacity': 0
                    },
                    callback: function() {
                        overed = false;
                    }
                });
                animTarget.setStyle('background-position', '0px 0px');
            };
        if (animTarget) {
            me.animationInterval = setInterval(function() {
                try {
                    phases[currentPhase].tick();
                    spentTime += tickSize;
                    if (spentTime >= phases[currentPhase].dur) {
                        phases[currentPhase].finish();
                        var opacity = phases[currentPhase].opacity;
                        spentTime = 0;
                        currentPhase = phases.length - 1 == currentPhase ? 0 : currentPhase + 1;
                        phases[currentPhase].opacity = opacity;
                    }
                } catch (e) {}
            }, //
            tickSize);
            me.addOnOverListener(onOver);
            me.addOnLeaveListener(onLeave);
        }
    },
    /**
     * @private
     */
    stopAnimation: function() {
        var me = this;
        if (me.animationInterval) {
            clearInterval(me.animationInterval);
            me.animationInterval = null;
        }
    },
    /**
     * @private Настраивает dom-элемент, как объект для квест-хелпера
     */
    tuneQuestHelperOptions: function(el) {
        var me = this,
            pointerHeight = 46,
            locationViewWidth = 860,
            _getOptions = function(data) {
                var options = {
                        style: '',
                        cls: ''
                    };
                options.style += 'top:' + (data.interactive.h / 2 - pointerHeight / 2) + 'px;';
                if (data.interactive.x < locationViewWidth / 2) {
                    options.cls = 'flip-h';
                    options.style += 'left:' + (data.interactive.w - 10) + 'px;';
                } else {
                    options.style += 'left:-60px;';
                }
                return Ext.String.htmlEncode(Ext.encode(options));
            };
        el.set({
            'data-qh_otype': 'iobject',
            'data-qh_oid': me.objData.id || me.objData.description,
            'data-qh_opts': _getOptions(me.objData)
        });
        el.addCls('qh-object');
    },
    /**
     * @private
     */
    createTooltip: function() {
        var me = this,
            title = me.getTooltipText().title,
            text = me.getTooltipText().text;
        me.tooltip = Ext.create('Ext.tip.ToolTip', {
            target: me.getEl(),
            maxWidth: parseInt(ExGods.ref('constants|tooltip_max_width').value),
            cls: 'paperdeco-tooltip',
            plugins: [
                'paperdeco'
            ],
            html: '<div class="paper-title ellipsis">' + title + '</div>' + '<div class="tooltip-paper-body">' + text + '</div>'
        });
    },
    /**
     * @private
     */
    addOnOverListener: function(listener) {
        var me = this,
            rootEl = me.getEl();
        if (!rootEl) {
            me.on('afterrender', function() {
                me.addOnOverListener(listener);
            }, me, {
                single: true
            });
            return;
        }
        if (!me.overListeners) {
            me.overListeners = [];
            rootEl.on('mouseenter', function() {
                me.overListeners.forEach(function(listener) {
                    listener.call(me);
                });
                if (!me.leaveDetectInterval) {
                    me.leaveDetectInterval = setInterval(function() {
                        if (!rootEl.hasCls('location-object-over')) {
                            if (me.leaveListeners) {
                                me.leaveListeners.forEach(function(listener) {
                                    listener.call(me);
                                });
                            }
                            clearInterval(me.leaveDetectInterval);
                            me.leaveDetectInterval = null;
                        }
                    }, 100);
                }
            });
        }
        me.overListeners.push(listener);
    },
    /**
     * @private
     */
    addOnLeaveListener: function(listener) {
        var me = this;
        if (!me.leaveListeners) {
            me.leaveListeners = [];
        }
        me.leaveListeners.push(listener);
    },
    /**
     * @private
     */
    onClick: function(e) {
        var me = this,
            win;
        if (me.objData.view_message) {
            win = Ext.widget('commonwindow', {
                autoShow: true,
                closeAction: 'destroy',
                buttonAlign: 'center',
                minWidth: 250,
                y: 260,
                buttons: {
                    defaultType: 'textbutton',
                    items: [
                        {
                            handler: function() {
                                win.destroy();
                            },
                            text: ExGods.getMsgByKey('close_btn_text')
                        }
                    ]
                }
            });
            win.update(me.objData.view_message);
        } else {
            me.locationObjectClickHandler(e);
        }
    },
    /**
     * @private
     */
    onDestroy: function() {
        var me = this;
        if (me.leaveDetectInterval) {
            clearInterval(me.leaveDetectInterval);
        }
        if (me.tooltip) {
            me.tooltip.destroy();
            me.tooltip = null;
        }
        me.stopAnimation();
    }
});

/**
 * Объекта локации "Картинка"
 */
Ext.define('ExGods.view.location.LocationObjectImage', {
    extend: ExGods.view.location.LocationObject,
    alias: 'widget.locationobjectimage',
    cls: 'location-object location-object-image',
    /**
     * @override
     * Инициализирует внутренний компонент объекта.
     * @return {Ext.Component}
     */
    initInnerComponent: function() {
        var me = this;
        return Ext.widget('component', {
            cls: 'location-object-inner',
            autoEl: 'a',
            layout: 'absolute',
            width: me.objData.interactive.w,
            height: me.objData.interactive.h,
            style: {
                backgroundImage: 'url(' + IMAGE_URL + me.objData.interactive.params_display.image + ')'
            }
        });
    },
    /**
     * @override
     * Вернет dom-элемент для стандартной анимации свечения объекта локации
     * @return {Ext.dom.Element} DOM-элемент, который нужно анимировать или null, если анимация не требуется
     */
    getAnimationTarget: function() {
        var me = this;
        return me.innerComponent.getEl();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        var image = IMAGE_URL + me.objData.interactive.params_display.image;
        return {
            images: [
                image
            ].concat(arr_images)
        };
    }
});

/**
 * Объекта локации "Кнопка"
 */
Ext.define('ExGods.view.location.LocationObjectButton', {
    extend: ExGods.view.location.LocationObject,
    alias: 'widget.locationobjectbutton',
    cls: 'location-object location-object-button',
    /**
     * @override
     * Инициализирует внутренний компонент объекта.
     * @return {Ext.Component}
     */
    initInnerComponent: function() {
        var me = this,
            config = {},
            cls = 'location-object-inner ',
            text = me.objData.interactive.params_display.label;
        config.text = text;
        if (me.objData.interactive.params_display.style == "double") {
            cls += 'double_text_btn double_text ';
            config.minWidth = 88;
        }
        if (me.objData.interactive.params_display.color) {
            cls += 'x-btn-txt-' + me.objData.interactive.params_display.color;
        }
        if (me.objData.interactive.w) {
            config.minWidth = me.objData.interactive.w;
        }
        if (cls) {
            config.cls = cls;
        }
        return Ext.widget('textbutton', config);
    },
    /**
     * @override
     */
    getTitleText: function() {},
    // без заголовка
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Объекта локации "Компонент"
 */
Ext.define('ExGods.view.location.LocationObjectComponent', {
    extend: ExGods.view.location.LocationObject,
    alias: 'widget.locationobjectcomponent',
    cls: 'location-object location-object-component',
    /**
     * @override
     * Инициализирует внутренний компонент объекта.
     * @return {Ext.Component}
     */
    initInnerComponent: function() {
        var me = this,
            config = {
                locationObject: me.objData
            },
            info, cmp;
        ExGods.ref('client_objects').each(function(item) {
            if (item.id == me.objData.interactive.params_display.component_params.id) {
                info = item;
            }
        });
        if (info && info.name) {
            cmp = ExGods.Components.factory(info.name, config);
        }
        if (!cmp.error) {
            if (cmp.overListener) {
                me.addOnOverListener(function() {
                    cmp.overListener();
                });
            }
            if (cmp.leaveListener) {
                me.addOnLeaveListener(function() {
                    cmp.leaveListener();
                });
            }
            return cmp;
        } else {
            me.log('error', '@initInnerComponent Ошибка при создании компонента: ' + cmp.error);
        }
    },
    /**
     * @override
     * Обработчик клика по объекту локации
     */
    locationObjectClickHandler: function() {
        var me = this;
        if (typeof me.innerComponent.locationObjectClickHandler == 'function') {
            if (me.innerComponent.locationObjectClickHandler.apply(me.innerComponent, arguments) === true) {
                me.callParent(arguments);
            }
        } else {
            me.callParent(arguments);
        }
    },
    /**
     * @override
     * Вернет dom-элемент для стандартной анимации свечения объекта локации
     * @return {Ext.dom.Element} DOM-элемент, который нужно анимировать или null, если анимация не требуется
     */
    getAnimationTarget: function() {
        var me = this;
        if (typeof me.innerComponent.getAnimationTarget == 'function') {
            return me.innerComponent.getAnimationTarget();
        }
    }
});
/**
     * Ресурсы вью предзагрузка не требуется
     */

/**
 * Отображение локации
 */
Ext.define('ExGods.view.location.Location', {
    extend: Ext.panel.Panel,
    alias: 'widget.locationview',
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: {
            info: true,
            wrap: false,
            error: false
        },
        prefix: 'LocationView:'
    },
    /**
     * @cfg location {ExGodsCore.model.Location}
     * Объект локации
     */
    bodyPadding: 0,
    header: false,
    layout: 'absolute',
    margin: '3 5 7 5',
    plugins: [
        'irondeco'
    ],
    height: 412,
    itemsToDraw: [],
    initComponent: function() {
        var me = this;
        me.location = me.user.location;
        me.mon(me.location, 'locationchanged', me.drawLocation, me);
        me.callParent();
        me.drawLocation();
    },
    drawLocation: function() {
        var me = this,
            items;
        items = [
            {
                xtype: 'image',
                anchor: '100% 100%',
                src: me.location.getImage()
            }
        ];
        Ext.Array.each(me.location.getObjects(), function(item) {
            if (item.interactive.view == 'image') {
                items.push(Ext.widget({
                    xtype: 'locationobjectimage',
                    autoShow: false,
                    objData: item
                }));
            } else if (item.interactive.view == 'button') {
                items.push(Ext.widget({
                    xtype: 'locationobjectbutton',
                    autoShow: false,
                    objData: item
                }));
            } else if (item.interactive.view == 'component') {
                items.push({
                    // для locationobjectcomponent не требуется предварительная загрузка изображений
                    xtype: 'locationobjectcomponent',
                    autoShow: false,
                    objData: item
                });
            } else {}
        });
        //
        me.itemsToDraw = items;
        if (!me.loaderCt || !me.loaderCt.animating) {
            ExGods.Resources.load({
                items: {
                    items: me.itemsToDraw
                },
                getResources: function() {
                    var image_fon = me.location.getImage();
                    return {
                        images: [
                            image_fon
                        ]
                    };
                }
            }, function() {
                me.redrawItems();
            });
        }
    },
    /**
     * @private
     */
    redrawItems: Ext.Function.createBuffered(function() {
        var me = this;
        if (!me.itemsToDraw.length)  {
            return;
        }
        
        me.removeAll();
        if (me.el && ExGods.loaderCt.isVisible()) {
            ExGods.loaderCt.addLoadRemover();
        }
        me.add(me.itemsToDraw);
        me.itemsToDraw = [];
    }, 200),
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            imgs;
        imgs = ExGods.ref('images|location_images').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        return {
            images: [
                // Дополнительные изображения локации
                IMAGE_URL + 'locations/header_on_location.png',
                IMAGE_URL + 'locations/header_on_location.png',
                IMAGE_URL + 'locations/header_on_location.png',
                IMAGE_URL + 'locations/header_on_location.png',
                IMAGE_URL + 'locations/text_1.png',
                IMAGE_URL + 'locations/text_3.png',
                IMAGE_URL + 'locations/text_2.png',
                IMAGE_URL + 'locations/text_1_hover.png',
                IMAGE_URL + 'locations/text_3_hover.png',
                IMAGE_URL + 'locations/text_2_hover.png',
                IMAGE_URL + 'interface/quest_helper/item.png'
            ].concat(arr_images)
        };
    }
});

/**
 * модель монстра в локации
 *
 */
Ext.define('ExGods.model.Monster', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'banish_enable',
            type: 'string'
        },
        {
            name: 'battle_enable',
            type: 'string'
        },
        {
            name: 'bot_stats',
            type: 'auto'
        },
        {
            name: 'bot_type',
            type: 'auto'
        },
        {
            name: 'cooldown_banish',
            type: 'auto'
        },
        {
            name: 'count',
            type: 'auto'
        },
        {
            name: 'gender',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'auto'
        },
        {
            name: 'last_banish',
            type: 'auto'
        },
        {
            name: 'shape',
            type: 'auto'
        },
        {
            name: 'description',
            type: 'auto'
        },
        {
            name: 'greetings_template',
            type: 'auto'
        },
        {
            name: 'battle_id',
            type: 'int'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'stuff',
            type: 'auto'
        },
        {
            name: 'source',
            type: 'string'
        },
        {
            name: 'toughness',
            type: 'string'
        },
        {
            name: 'reward_banish',
            type: 'auto'
        },
        {
            name: 'level',
            type: 'auto'
        },
        {
            name: 'wait',
            type: 'int'
        },
        {
            // признак цепочки
            name: 'chain',
            type: 'auto'
        },
        {
            // время старта следующего боя цепочки
            name: 'chain_next_time',
            type: 'auto'
        }
    ]
});

/**
 * Список всех ботов
 */
Ext.define('ExGods.store.Monster', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Monster',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'entry',
            direction: 'DESC'
        }
    ],
    constructor: function() {
        var me = this;
        me.callParent(arguments);
    }
});

/**
 * Управление локацией
 */
Ext.define('ExGods.controller.Location', {
    extend: ExGodsCore.controller.Base,
    mixins: [
        ExGods.util.Flags
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Location:'
    },
    models: [
        'BasicUser',
        'Location',
        'World'
    ],
    stores: [
        'Monster'
    ],
    views: [
        'location.Location',
        'location.lob.BotsList',
        'location.lob.CloseButton',
        'location.lob.ServiceEnter'
    ],
    refs: [
        {
            /**
         * @method getLocationHeader
         * Получет отображение центрального контейнера шапки
         * @return {Ext.container.Container}
         */
            ref: 'locationHeader',
            selector: '#location-header'
        },
        {
            /**
         * @method getLocationInfo
         * Получет отображение панели информации о локации
         * @return {Ext.panel.Panel}
         */
            ref: 'locationInfo',
            selector: '#location-info'
        },
        {
            /**
         * @method getHeaderRightInfo
         * Возвращает контейнер в правом верхнем углу, где содержится
         * краткая информация о финансах или противнике
         * @return {Ext.container.Container}
         */
            ref: 'headerRightInfo',
            selector: '#header-right'
        },
        {
            /**
         * @method getLocationContainer
         * Возвращает контейнер для локации
         * @return {ExGods.view.location.Container}
         */
            ref: 'locationContainer',
            selector: '#location-container'
        },
        {
            ref: 'questButton',
            selector: '#mainmenu-quests-button'
        }
    ],
    //сервисы текущей локации
    locationServices: [],
    init: function(app) {
        var me = this,
            user = me.getUser(),
            worlds = app.getWorldsStore();
        me.service = ExGods.Services.get('location');
        me.service.on('update', me.onServiceUpdate, me);
        // Добавляю обработчик ответа от сервера по ключу "location"
        me.addAjaxRequestKeyHandler('location', function(data) {
            me.service.update(data);
        }, me);
        // загружаем список миров
        worlds.loadRawData(config.references.worlds);
        me.user.location = Ext.create('ExGods.model.Location', Ext.clone(me.service.data.location));
        me.user.location.on('locationchanged', me.onLocationChange, me);
        me.control({
            '#location-container locationbots': {
                afterrender: me.locationBotsRefresh
            }
        });
        user.location.on({
            'entrychanged': me.onLocationEntryChange,
            scope: me
        });
        me.app.chatcn.on('command_location', me.onLocationCommand, me);
        ExGods.Components.addComponentInitializer('bot_list', me.initBotsListComponent, me);
        ExGods.Components.addComponentInitializer('close_location_button', me.initCloseLocationButtonComponent, me);
        ExGods.Components.addComponentInitializer('location_service_enter', me.initLocationServiceEnterComponent, me);
        me.callParent(arguments);
    },
    /**
     * срабатывает на команду command_location из чата
     */
    onLocationCommand: function(chatcn, data) {
        this.updateLocation();
    },
    /**
     * @private
     */
    onLocationChange: function() {
        var me = this,
            headerCt = me.getLocationHeader(),
            viewport = me.app.getController('Viewport'),
            chatCt = me.app.getController('Chat'),
            cb = function() {
                // обновляю заголовок локации
                if (headerCt) {
                    headerCt.items.items[0].update({
                        location: me.user.location.get('name'),
                        world: me.user.location.getWorld().get('title')
                    });
                }
                //обновляю название вкладки чата (название вкладки чата = название локации)
                if (chatCt)  {
                    chatCt.getChannelByType('location').setTitle(me.user.location.get('name'));
                }
                
            };
        if (viewport.layout == 'main') {
            cb();
        }
    },
    /**
     * Запрашивает данные по локации и обновляет её
     */
    updateLocation: function() {
        var me = this;
        /***/
        me.log('Запрос на обновление локации..');
        me.service.update(null, function() {});
    },
    //          
    onServiceUpdate: function(service, newData, oldData) {
        var me = this;
        if (!ExGods.helpme.isEqual(newData.location, oldData.location)) {
            me.user.location.setRawData(Ext.clone(newData.location));
        }
    },
    /**
     * @private
     * Срабатывает, когда у пользователя меняется локация (user->binding->room)
     */
    onLocationEntryChange: function() {
        var me = this,
            viewport = me.app.getController('Viewport'),
            container = me.getLocationContainer(),
            view = (container) ? container.down('locationview') : null,
            cb = function() {
                viewport.closeAllWindows();
                //обновляю компонент ботов
                me.locationBotsRefresh();
            };
        ExGods.Resources.load('location-container', function() {
            if (viewport.layout == 'main') {
                var loader = (view) ? view.loaderCt : null;
                if (loader) {
                    if (loader.animating) {
                        loader.on('animation_complete', function() {
                            cb();
                        }, {
                            single: true
                        });
                    } else {
                        cb();
                    }
                } else {
                    cb();
                }
            }
        });
    },
    /**
     * обновляю хранилище ботов
     */
    locationBotsRefresh: function() {
        //компонент уже создан при конфигурировании локации. В этом методе добавляем только элементы в стор.
        var me = this,
            surging = me.app.getSurgingController();
        if (surging) {
            surging.updateStore();
        }
    },
    /**
     * Блокирует обновление локации
     */
    lockUpdate: function() {
        var me = this;
        me.set_f('lock_update', true);
        me.user.location.suspendEvents(true);
    },
    /**
     * Снимает блокировку на обновление и обновляет локацию
     */
    unlockUpdate: function() {
        var me = this;
        if (me.isLocked()) {
            me.set_f('lock_update');
            me.user.location.resumeEvents(true);
            me.app.getSurgingController().updateStore();
        }
    },
    isLocked: function() {
        var me = this;
        return me.get_f('lock_update');
    },
    /**
     * Вешает маску затемнения на локацию
     */
    maskLocation: function(callback, options) {
        var me = this,
            locationCt = Ext.getCmp('location-container');
        callback = callback || Ext.emptyFn;
        options = options || {};
        ExGods.loaderCt.addLoader(callback, options);
    },
    unmaskLocation: function(callback, options) {
        var me = this,
            locationCt = Ext.getCmp('location-container');
        callback = callback || Ext.emptyFn;
        options = options || {};
        ExGods.loaderCt.addLoadRemover(callback, options);
    },
    /**
     * Вернёт сервисы, привязанные к локации по названию прототипа.
     */
    getBindableServices: function(protoName) {
        var me = this,
            objects = me.service.data.location.blob.objects || [],
            services = [],
            service;
        for (var i = 0; i < objects.length; i++) {
            if (objects[i].client_action && objects[i].client_action.id) {
                service = ExGods.Services.factory(objects[i].client_action.id);
                if (!service.error && service.info.proto['package'] == protoName) {
                    services.push(service);
                } else if (service.error) {
                    /***/
                    me.log('error', 'Ошибка при получении сервиса локации ', service.error);
                }
            }
        }
        return services;
    },
    /**
     * Инициализатор компонента "bot_list"
     */
    initBotsListComponent: function(config) {
        var me = this,
            cmp;
        cmp = Ext.widget('locationbots', {
            id: 'LOB_BOT_LIST',
            user: me.user,
            store: ExGods.app.getMonsterStore(),
            clientObject: config,
            locationObject: config.locationObject,
            autoShow: false
        });
        ExGods.Resources.load(cmp, function() {
            cmp.show();
        });
        return cmp;
    },
    /**
     * Инициализатор компонента "close_location_button"
     */
    initCloseLocationButtonComponent: function(config) {
        var me = this,
            btn = Ext.widget('closelocationbtn', {
                clientObject: config,
                autoShow: false,
                locationObject: config.locationObject
            });
        ExGods.Resources.load(btn, function() {
            btn.show();
        });
        return btn;
    },
    /**
     * Инициализатор компонента "location_service_enter"
     */
    initLocationServiceEnterComponent: function(config) {
        var me = this,
            service = ExGods.Services.factory(config.locationObject.client_action.id),
            cmp,
            loadServiceData = function(callback) {
                if (service && !service.error) {
                    service.command('get_service_show', {}, function(resp) {
                        if (resp && resp.service) {
                            callback(resp.service);
                        }
                    }, {
                        url: 'game.pl'
                    });
                } else {
                    /****/
                    me.log('error', '@initLocationServiceEnterComponent Ошибка при инициализации компонента', service.error);
                }
            };
        cmp = Ext.widget('serviceenter', {
            clientObject: config,
            locationObject: config.locationObject,
            hidden: true,
            autoShow: false
        });
        // при обновлении сервиса локации - перезапрашиваю данные для компонентов
        cmp.mon(me.service, 'update', function() {
            if (cmp.rendered) {
                loadServiceData(function(data) {
                    cmp.setServiceData(data);
                });
            }
        }, me, {
            delay: 300
        });
        // задержка, чтобы удостовериться, что компонент все еще отрисован после обновления локации
        loadServiceData(function(data) {
            cmp.setServiceData(data);
        });
        return cmp;
    }
});

/**
 * Контроллер логирования действий пользователя, для отображения в шапке и
 * возможно в отдельной вкладке чата
 */
Ext.define('ExGods.controller.Log', {
    extend: ExGods.controller.Base,
    init: function() {
        Ext.Ajax.on('requestcomplete', this.onRequestComplete, this);
    },
    onRequestComplete: function(conn, response, options) {
        var me = this,
            result = Ext.decode(response.responseText, true);
        if (result && result.msg && typeof result.msg == 'string') {
            // проверяем на наличие указаний-директив от сервера в сообщении
            var text = me.application.getController('Direction').processText(result.msg);
            me.application.fireEvent('logmessage', text);
        }
    }
});

/**
 * Модель продаваемого на рынке имущества
 */
Ext.define('ExGods.model.MarketItem', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            // уровень имущества. Для предмета - это уровень предмета, для ингредиентов - всегда 1
            // виртуальное поле, используется для фильтрации
            name: 'level',
            type: 'int'
        },
        {
            // тип имущества. Для инргидиентов - fucina или home. Для предметов - item1, item2, item3, item4 (для каждого грейда)
            // виртуальное поле, используется для фильтрации
            name: 'type',
            type: 'string'
        },
        {
            // уровень грейда предмета. Для ингредиентов - всегда 1
            name: 'grade',
            type: 'int'
        },
        {
            // картинка имущества
            name: 'image',
            type: 'string'
        },
        {
            // цена в формате валюты (name, value)
            name: 'price',
            type: 'auto'
        },
        {
            // кол-во продаваемых предметов.
            name: 'quantity',
            type: 'int'
        },
        {
            name: 'max_price',
            type: 'int'
        },
        {
            name: 'min_price',
            type: 'int'
        },
        {
            // данные имущества в формате имущества
            name: 'stuff',
            type: 'auto'
        },
        {
            // дата выставления имущества на рынок
            name: 'create_date',
            type: 'string'
        }
    ]
});

/**
 * Комбобокс на коже с пергаментной подложкой списка
 */
Ext.define('ExGods.view.parchment.Combo', {
    extend: Ext.form.field.ComboBox,
    alias: 'widget.parchmentcombo',
    cls: 'parchment-combo',
    initComponent: function() {
        var me = this;
        me.listConfig = Ext.applyIf(me.listConfig || {}, {
            cls: 'parchment-combo-bound-list',
            minWidth: 140,
            afterRender: function() {
                var me = this;
                me.superclass.afterRender.apply(me, arguments);
                me.el.insertHtml('afterBegin', '<div class="paper paper-tl"></div>' + '<div class="paper paper-tm"></div>' + '<div class="paper paper-tr"></div>' + '<div class="paper paper-mr"></div>' + '<div class="paper paper-br"></div>' + '<div class="paper paper-bm"></div>' + '<div class="paper paper-bl"></div>' + '<div class="paper paper-ml"></div>' + '<div class="paper paper-bg"></div>');
            },
            setXY: function(pos) {
                var me = this;
                pos[0] = pos[0] - 5;
                // семщаю список на 5 px влево
                me.superclass.setXY.call(me, pos);
            }
        });
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'deco/paper/paper_top_left.png',
                IMAGE_URL + 'deco/paper/paper_top_middle.png',
                IMAGE_URL + 'deco/paper/paper_top_right.png',
                IMAGE_URL + 'deco/paper/paper_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_middle.png',
                IMAGE_URL + 'deco/paper/paper_bottom_left.png',
                IMAGE_URL + 'deco/paper/paper_left.png',
                IMAGE_URL + 'deco/paper/paper_center_tile.png',
                IMAGE_URL + 'deco/paper/paper_top_left.png',
                IMAGE_URL + 'btn_close.png',
                IMAGE_URL + 'close.png',
                IMAGE_URL + 'deco/paper/paper_separator_top.png',
                IMAGE_URL + 'deco/paper/paper_separator_vertical.png',
                IMAGE_URL + 'deco/paper/paper_separator_left.png',
                IMAGE_URL + 'deco/paper/paper_separator_right.png',
                IMAGE_URL + 'deco/paper/paper_separator_horisontal.png',
                IMAGE_URL + 'deco/paper/header_left.png',
                IMAGE_URL + 'deco/paper/header_right.png',
                IMAGE_URL + 'deco/paper/header_middle.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Cетка элементов на пергаментной подложке
 */
Ext.define('ExGods.view.grid.ParchmentGrid', {
    extend: ExGods.view.grid.Grid,
    alias: 'widget.exg_parchment_grid',
    cls: 'exg-grid-parchment',
    cellWidth: 186,
    cellHeight: 140,
    /**
     * Инициализация шаблона для элемента грида
     * @override
     */
    initItemTemplate: function() {
        var me = this;
        // оборачиваю шаблон предмета в пергамент
        if (Ext.isArray(me.itemTpl)) {
            me.itemTpl.unshift('<div class="exg-grid-parchment-item-wrap"><div class="exg-grid-parchment-info-icon"></div>');
            if (typeof me.itemTpl[me.itemTpl.length - 1] == 'object') {
                Ext.Array.insert(me.itemTpl, me.itemTpl.length - 1, [
                    '</div>'
                ]);
            } else {
                me.itemTpl.push('</div>');
            }
        } else {
            me.itemTpl = '<div class="exg-grid-parchment-item-wrap"><div class="exg-grid-parchment-info-icon"></div>' + me.itemTpl + '</div>';
        }
        me.callParent(arguments);
    }
});

/**
 * Предметы на рынке
 */
Ext.define('ExGods.view.market.Items', {
    extend: ExGods.view.grid.ParchmentGrid,
    alias: 'widget.marketitems',
    /**
     * @cfg service {ExGods.service.Market} service
     */
    service: null,
    /**
     * @cfg clientObject {Object} Конфигурация компонента из справочника Клиент-Объекты
     */
    clientObject: {},
    cls: 'market-items',
    initComponent: function() {
        var me = this;
        // настройки грида
        me.rowsCount = 2;
        me.columnsCount = 3;
        me.itemTpl = [
            '<div class="{[this.getCls(values)]}">',
            '<div class="title ellipsis">{[ this.printTitle(values) ]}</div>',
            '<div class="quantity">{[ this.printQuantity(values) ]}</div>',
            '<div class="image">{[ this.printImage(values) ]}</div>',
            '<div class="level">{[ this.printLevel(values) ]}</div>',
            '<div class="price">{[ this.printPrice(values) ]}</div>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border</span>',
            '<span role="action">market-buy</span>',
            '<span role="width:int">90</span>',
            '<span role="minWidth:int">90</span>',
            '<span role="margin">8 0 0 8</span>',
            '<span role="entry">{entry}</span>',
            '<span role="price">{price.value}</span>',
            '<span role="confirm">{[ this.getConfirmText(values) ]}</span>',
            '<span role="confirm2_tpl">{[ this.getConfirm2Tpl() ]}</span>',
            '<span role="disabled:bool">{[ values.quantity > 0 ? false : true ]}</span>',
            '<span role="text">' + me.clientObject.buy_btn_text + '</span>',
            '</div>',
            '</div>',
            {
                getCls: function(values) {
                    var cls = '';
                    if (values.quantity == 0) {
                        cls = 'disabled';
                    }
                    return cls;
                },
                printTitle: function(values) {
                    return '<span class="item-grade-color-' + values.grade + '">' + values.title + '</span>';
                },
                printQuantity: function(values) {
                    if (values.quantity > 0) {
                        return Ext.String.format(me.clientObject.items_count_text, values.quantity);
                    } else {
                        return me.clientObject.no_item_count_text;
                    }
                },
                printImage: function(values) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'shop_stuff',
                        params: {
                            stuff: values.stuff
                        }
                    });
                },
                printLevel: function(values) {
                    return Ext.String.format(me.clientObject.item_level_text, values.level);
                },
                printPrice: function(values) {
                    if (values.quantity > 0) {
                        return ExGods.util.Format.printMoney(values.price);
                    } else {
                        // рассчитаваю среднюю цену
                        // var avr = Math.round((values.max_price - values.min_price)/2);
                        // return ExGods.util.Format.printMoney({name: values.price.name, value: avr});
                        return '&nbsp;';
                    }
                },
                getConfirmText: function(values) {
                    if (values.price) {
                        return Ext.String.format(me.clientObject.buy_confirm, ExGods.util.Stuff.printStuff({
                            type: 'currency',
                            params: {
                                id: values.price.name,
                                quantity: values.price.value
                            }
                        }));
                    } else {
                        return '';
                    }
                },
                getConfirm2Tpl: function(values) {
                    return me.clientObject.buy_confirm2;
                }
            }
        ];
        me.emptyText = me.clientObject.empty_items_text;
        me.pager = {
            marginRight: -27,
            marginLeft: -36,
            textTop: -32,
            textLeft: 237
        };
        me.initStore();
        me.initFilters();
        me.callParent(arguments);
        // отрисовка встроенных компонентов
        me.itemsView.on('refresh', function(view) {
            ExGods.helpme.renderComponents(view.getEl(), me);
        });
        me.itemsView.on('beforedestroy', function(view) {
            ExGods.helpme.destroyComponents(view.getEl());
        });
        me.mon(me.service, 'update', me.onServiceUpdate, me);
    },
    /**
     * Выставить значение фильтра и отфильтровать вью
     */
    setFilter: function(type, value) {
        var me = this;
        if (type == 'text') {
            me.setTextFilter(value);
        } else if (type == 'avail') {
            me.setAvailFilter(value);
        } else if (type == 'level') {
            me.setLevelFilter(value);
        } else if (type == 'type') {
            me.setTypeFilter(value);
        }
    },
    /**
     * Применить фильтры
     */
    applyFilters: function() {
        var me = this,
            filters = [];
        for (var filterName in me.filters) {
            if (me.filters.hasOwnProperty(filterName)) {
                filters.push(me.filters[filterName]);
            }
        }
        me.store.clearFilter();
        me.store.filter(filters);
    },
    /**
     * Сбросить фильтры
     */
    clearFilters: function() {
        var me = this;
        me.store.clearFilter();
    },
    /****************** PRIVATES ******************/
    // инициализация хранилища рынка
    initStore: function() {
        var me = this,
            data = [],
            getMinPrice = function(prices) {
                var result = {
                        value: undefined,
                        type: ''
                    };
                prices.forEach(function(price) {
                    if (result.value == undefined) {
                        result = price;
                    } else if (parseInt(price.value) < parseInt(result.value)) {
                        result = price;
                    }
                });
                return result;
            };
        ExGods.ref('market').each(function(entry, item) {
            var proto, marketItem;
            marketItem = {
                entry: entry,
                min_price: item.min_price,
                max_price: item.max_price,
                stuff: item.stuff,
                price: item.price
            };
            if (me.service.data.market && me.service.data.market[entry]) {
                marketItem.quantity = me.service.data.market[entry].price.length;
                marketItem.price = getMinPrice(me.service.data.market[entry].price);
            } else {
                marketItem.quantity = 0;
            }
            if (marketItem.stuff.type == 'item') {
                proto = ExGods.app.getItemPrototypesStore().data.getByKey(parseInt(marketItem.stuff.params.id));
                if (proto) {
                    marketItem.type = 'item';
                    marketItem.title = proto.data.title;
                    marketItem.level = proto.data.data.strict.level;
                    marketItem.grade = parseInt(proto.data.data.item_grade || 0) || 1;
                    marketItem.image = proto.data.images.info;
                }
                data.push(marketItem);
            } else if (marketItem.stuff.type == 'ingredients') {
                proto = ExGods.ref('ingredients|' + marketItem.stuff.params.id);
                if (proto) {
                    marketItem.type = proto.place;
                    marketItem.title = proto.label;
                    marketItem.level = 1;
                    marketItem.grade = 1;
                    marketItem.image = IMAGE_URL + proto.params.images.img_1;
                }
                data.push(marketItem);
            } else {}
        });
        //
        if (!me.store) {
            me.store = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.MarketItem',
                data: data,
                sorters: [
                    {
                        // сортирую по наличию (в наличии наверху)
                        sorterFn: function(o1, o2) {
                            if (o1.data.quantity == 0) {
                                return 1;
                            } else if (o2.data.quantity == 0) {
                                return -1;
                            } else {
                                return 0;
                            }
                        }
                    }
                ]
            });
        } else {
            me.store.loadRawData(data);
        }
    },
    initFilters: function() {
        var me = this;
        me.filters = {};
        me.setAvailFilter(true);
        me.applyFilters();
    },
    // обновляю данные хранилища при обновлении данных сервиса
    onServiceUpdate: function() {
        var me = this;
        me.initStore();
    },
    setTextFilter: function(value) {
        var me = this;
        value = Ext.String.trim(value);
        if (value) {
            me.filters['text'] = new Ext.util.Filter({
                filterFn: function(item) {
                    var itemTitle = item.data.title;
                    return itemTitle.toLowerCase().indexOf(value.toLowerCase()) == -1 ? false : true;
                }
            });
        } else {
            delete me.filters['text'];
        }
    },
    setLevelFilter: function(value) {
        var me = this;
        if (value && value != 0) {
            me.filters['level'] = new Ext.util.Filter({
                filterFn: function(item) {
                    return item.data.level == value;
                }
            });
        } else {
            delete me.filters['level'];
        }
    },
    setTypeFilter: function(value) {
        var me = this;
        if (value && value != 'all') {
            me.filters['type'] = new Ext.util.Filter({
                filterFn: function(item) {
                    if (/^item/.test(value)) {
                        var parts = value.split('_');
                        // item_1 or item_2 or .. где число - уровень грейда
                        return item.data.type == 'item' && item.data.grade == parts[1];
                    } else {
                        return item.data.type == value;
                    }
                }
            });
        } else {
            delete me.filters['type'];
        }
    },
    setAvailFilter: function(value) {
        var me = this;
        if (value) {
            if (!me.filters['avail']) {
                me.filters['avail'] = new Ext.util.Filter({
                    filterFn: function(item) {
                        return item.data.quantity > 0;
                    }
                });
            }
        } else {
            delete me.filters['avail'];
        }
    }
});

/**
 * Мои предметы на рынке
 */
Ext.define('ExGods.view.market.MyItems', {
    extend: ExGods.view.grid.ParchmentGrid,
    alias: 'widget.marketmyitems',
    /**
     * @cfg service {ExGods.service.Market} service
     */
    service: null,
    /**
     * @cfg clientObject {Object} Конфигурация компонента из справочника Клиент-Объекты
     */
    clientObject: {},
    cls: 'market-items market-my-items',
    initComponent: function() {
        var me = this;
        // настройки грида
        me.rowsCount = 2;
        me.columnsCount = 3;
        me.itemTpl = [
            '<div>',
            '<div class="title ellipsis">{[ this.printTitle(values) ]}</div>',
            '<div class="timer">{[ this.printTimer(values) ]}</div>',
            '<div class="image">{[ this.printImage(values) ]}</div>',
            '<div class="level">{[ this.printLevel(values) ]}</div>',
            '<div class="price">{[ this.printPrice(values) ]}</div>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border</span>',
            '<span role="action">market-cancel</span>',
            '<span role="entry">{entry}</span>',
            '<span role="confirm">' + me.clientObject.cancel_confirm + '</span>',
            '<span role="text">' + me.clientObject.cancel_btn_text + '</span>',
            '<span role="width:int">90</span>',
            '<span role="minWidth:int">90</span>',
            '<span role="margin">8 0 0 8</span>',
            '</div>',
            '</div>',
            {
                printTitle: function(values) {
                    return '<span class="item-grade-color-' + values.grade + '">' + values.title + '</span>';
                },
                printImage: function(values) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'shop_stuff',
                        params: {
                            stuff: values.stuff
                        }
                    });
                },
                printLevel: function(values) {
                    return Ext.String.format(me.clientObject.item_level_text, values.level);
                },
                printPrice: function(values) {
                    return ExGods.util.Format.printMoney(values.price);
                },
                printTimer: function(values) {
                    var dt = ExGods.util.Date.normalizeServerDateTime(values.create_date);
                    return Ext.String.format(me.clientObject.drop_cooldown_text, ExGods.util.Timers.printRestTimer('market-my-items-timer', Ext.Date.add(dt, Ext.Date.HOUR, me.service.data.ttl)));
                }
            }
        ];
        me.emptyText = me.clientObject.empty_my_items_text;
        me.pager = {
            marginRight: -27,
            marginLeft: -36,
            textTop: -32,
            textLeft: 237
        };
        me.initStore();
        me.initFilters();
        me.callParent(arguments);
        // отрисовка встроенных компонентов
        me.itemsView.on('refresh', function(view) {
            ExGods.helpme.renderComponents(view.getEl(), me);
        });
        me.itemsView.on('beforedestroy', function(view) {
            if (view.getEl()) {
                ExGods.helpme.destroyComponents(view.getEl());
            }
        });
        me.mon(me.service, 'update', me.onServiceUpdate, me);
    },
    /**
     * Выставить значение фильтра и отфильтровать вью
     */
    setFilter: function(type, value) {
        var me = this;
        if (type == 'text') {
            me.setTextFilter(value);
        } else if (type == 'level') {
            me.setLevelFilter(value);
        } else if (type == 'type') {
            me.setTypeFilter(value);
        }
    },
    /**
     * Применить фильтры
     */
    applyFilters: function() {
        var me = this,
            filters = [];
        for (var filterName in me.filters) {
            if (me.filters.hasOwnProperty(filterName)) {
                filters.push(me.filters[filterName]);
            }
        }
        me.store.clearFilter();
        me.store.filter(filters);
    },
    /****************** PRIVATES ******************/
    getMarketItem: function(me) {
        var data = [];
        me.service.data.user_product.forEach(function(item) {
            var refData = ExGods.ref('market|' + item.ref_entry),
                marketItem;
            if (refData) {
                marketItem = {
                    entry: item.entry,
                    min_price: refData.min_price,
                    max_price: refData.max_price,
                    stuff: refData.stuff,
                    price: {
                        name: item.currency,
                        value: item.price
                    },
                    create_date: item.create_date
                };
                if (marketItem.stuff.type == 'item') {
                    proto = ExGods.app.getItemPrototypesStore().data.getByKey(parseInt(marketItem.stuff.params.id));
                    if (proto) {
                        marketItem.type = 'item';
                        marketItem.title = proto.data.title;
                        marketItem.level = proto.data.data.strict.level;
                        marketItem.grade = (parseInt(proto.data.data.item_grade || 0)) + 1;
                        marketItem.image = proto.data.images.info;
                    }
                    data.push(marketItem);
                } else if (marketItem.stuff.type == 'ingredients') {
                    proto = ExGods.ref('ingredients|' + marketItem.stuff.params.id);
                    if (proto) {
                        marketItem.type = proto.place;
                        marketItem.title = proto.label;
                        marketItem.level = 1;
                        marketItem.grade = 1;
                        marketItem.image = IMAGE_URL + proto.params.images.img_1;
                    }
                    data.push(marketItem);
                } else {}
            }
        });
        //
        return data;
    },
    // инициализация хранилища моих товаров
    initStore: function() {
        var me = this,
            data = [];
        var me = this,
            data = [],
            getMinPrice = function(prices) {
                var result = {
                        value: 0,
                        type: ''
                    };
                prices.forEach(function(price) {
                    if (price.value >= result.value) {
                        result = price;
                    }
                });
                return result;
            };
        data = me.getMarketItem(me);
        if (!me.store) {
            me.store = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.MarketItem',
                data: data,
                sorters: [
                    {
                        // сортирую по дате добавления 
                        sorterFn: function(o1, o2) {
                            if (o1.data.create_date < o2.data.create_date) {
                                return -1;
                            } else if (o1.data.create_date > o2.data.create_date) {
                                return 1;
                            } else {
                                return 0;
                            }
                        }
                    }
                ]
            });
        } else {
            me.store.loadRawData(data);
        }
    },
    // обновляю данные хранилища при обновлении данных сервиса
    onServiceUpdate: function() {
        var me = this;
        me.initStore();
    },
    initFilters: function() {
        var me = this;
        me.filters = {
            // фильтр просроченных предметов
            'expired': function(item) {
                var dt = ExGods.util.Date.normalizeServerDateTime(item.data.create_date);
                return Ext.Date.add(dt, Ext.Date.HOUR, me.service.data.ttl) > new Date();
            }
        };
    },
    // me.applyFilters();
    // обновляю данные хранилища при обновлении данных сервиса
    onServiceUpdate: function() {
        var me = this;
        me.initStore();
    },
    setTextFilter: function(value) {
        var me = this;
        value = Ext.String.trim(value);
        if (value) {
            me.filters['text'] = new Ext.util.Filter({
                filterFn: function(item) {
                    var itemTitle = item.data.title;
                    return itemTitle.toLowerCase().indexOf(value.toLowerCase()) == -1 ? false : true;
                }
            });
        } else {
            delete me.filters['text'];
        }
    },
    setLevelFilter: function(value) {
        var me = this;
        if (value && value != 0) {
            me.filters['level'] = new Ext.util.Filter({
                filterFn: function(item) {
                    return item.data.level == value;
                }
            });
        } else {
            delete me.filters['level'];
        }
    },
    setTypeFilter: function(value) {
        var me = this;
        if (value && value != 'all') {
            me.filters['type'] = new Ext.util.Filter({
                filterFn: function(item) {
                    if (/^item/.test(value)) {
                        var parts = value.split('_');
                        // item_1 or item_2 or .. где число - уровень грейда
                        return item.data.type == 'item' && item.data.grade == parts[1];
                    } else {
                        return item.data.type == value;
                    }
                }
            });
        } else {
            delete me.filters['type'];
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            data;
        data = me.getMarketItem(me);
        for (var i = 0; i < data.length; i++) {
            itm = data[i];
            if (itm.image) {
                arr_images.push(itm.image);
            }
            if (itm.stuff) {
                stuff_arr.push(itm.stuff);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Рынок
 */
Ext.define('ExGods.view.market.Market', {
    extend: Ext.container.Container,
    alias: 'widget.market',
    /**
     * @cfg clientObject {Object} Конфигурация компонента из справочника Клиент-Объекты
     */
    clientObject: {},
    /**
     * @cfg service {ExGods.service.Market} Сервис рынка
     */
    service: null,
    initComponent: function() {
        var me = this;
        me.itemsView = Ext.widget('marketitems', {
            tabConfig: {
                icon: IMAGE_URL + me.clientObject.items_tab_img,
                tooltip: me.clientObject.items_tab_tip
            },
            service: me.service,
            clientObject: me.clientObject,
            listeners: {
                activate: me.onViewActivate,
                scope: me
            }
        });
        me.myItemsView = Ext.widget('marketmyitems', {
            tabConfig: {
                icon: IMAGE_URL + me.clientObject.my_items_tab_img,
                tooltip: me.clientObject.my_items_tab_tip
            },
            service: me.service,
            clientObject: me.clientObject,
            listeners: {
                activate: me.onViewActivate,
                scope: me
            }
        });
        me.items = [
            {
                xtype: 'room',
                backgroundImage: me.clientObject.back_img,
                emptySearchText: me.clientObject.search_placeholder_text,
                closeText: me.clientObject.close_btn_text,
                closeColor: me.clientObject.close_btn_color,
                closeCallback: function() {
                    me.fireEvent('close');
                },
                rightPanelX: 250,
                items: [
                    {
                        xtype: 'skintabpanel',
                        activeTab: 0,
                        x: 242,
                        y: 10,
                        width: 580,
                        height: 363,
                        closable: true,
                        plugins: [
                            'skindeco'
                        ],
                        padding: '0 0 0 0',
                        defaults: {
                            padding: '0 0 0 10'
                        },
                        items: [
                            me.itemsView,
                            me.myItemsView
                        ],
                        listeners: {
                            beforeclose: {
                                fn: function() {
                                    me.fireEvent('close');
                                    return false;
                                }
                            }
                        }
                    },
                    {
                        xtype: 'panel',
                        x: 357,
                        y: 20,
                        width: 433,
                        height: 30,
                        itemId: 'filters',
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        style: {
                            'z-index': 1
                        },
                        items: [
                            me.initAvailCheckbox(),
                            me.initLevelFilter(),
                            me.initTypeFilter(),
                            me.initSearchField()
                        ]
                    }
                ],
                buttons: [
                    {
                        text: me.clientObject.refresh_btn_text,
                        handler: function() {
                            me.fireEvent('reload', me);
                        },
                        hidden: true
                    }
                ]
            }
        ] , me.callParent(arguments);
    },
    /************** PRIVATES *****************/
    initAvailCheckbox: function() {
        var me = this;
        me.availCheckbox = Ext.widget('checkbox', {
            boxLabel: me.clientObject.avail_checkbox_text,
            checked: true,
            style: {
                color: '#e3ac69'
            },
            listeners: {
                change: function() {
                    me.updateFilters('avail', me.availCheckbox.getValue());
                }
            },
            margin: '0 8 0 0'
        });
        return me.availCheckbox;
    },
    initLevelFilter: function() {
        var me = this,
            data = [];
        // Первым элементом идет "Все уровни"
        data.push([
            0,
            me.clientObject.level_filter_all_text
        ]);
        // Далее все уровни из справочника
        ExGods.ref('user_level').each(function(item) {
            data.push([
                item.level,
                Ext.String.format(me.clientObject.level_filter_level_text, item.level)
            ]);
        });
        me.levelFilter = Ext.widget('parchmentcombo', {
            store: Ext.create('Ext.data.ArrayStore', {
                fields: [
                    {
                        name: 'value',
                        mapping: 0,
                        type: 'int'
                    },
                    {
                        name: 'label',
                        mapping: 1
                    }
                ],
                data: data
            }),
            displayField: 'label',
            valueField: 'value',
            queryMode: 'local',
            triggerAction: 'all',
            editable: false,
            value: 0,
            width: 110,
            margin: '3 8 0 0',
            listeners: {
                change: function() {
                    me.updateFilters('level', me.levelFilter.getValue());
                }
            }
        });
        return me.levelFilter;
    },
    initTypeFilter: function() {
        var me = this,
            data = [];
        // Первым элементом идет "Все типы"
        data.push([
            'all',
            me.clientObject.types_filter_all_text
        ]);
        // Далее для ингридиентов кузницы и комнаты трофеев
        data.push([
            'fucina',
            me.clientObject.types_filter_fucina_text
        ]);
        data.push([
            'home',
            me.clientObject.types_filter_home_text
        ]);
        // Далее для каждого грейда предметов
        data.push([
            'item_1',
            me.clientObject.types_filter_grade1_text
        ]);
        data.push([
            'item_2',
            me.clientObject.types_filter_grade2_text
        ]);
        data.push([
            'item_3',
            me.clientObject.types_filter_grade3_text
        ]);
        data.push([
            'item_4',
            me.clientObject.types_filter_grade4_text
        ]);
        me.typeFilter = Ext.widget('parchmentcombo', {
            autoShow: false,
            xtype: 'combobox',
            store: Ext.create('Ext.data.ArrayStore', {
                fields: [
                    {
                        name: 'value',
                        mapping: 0
                    },
                    {
                        name: 'label',
                        mapping: 1
                    }
                ],
                data: data
            }),
            displayField: 'label',
            valueField: 'value',
            queryMode: 'local',
            triggerAction: 'all',
            editable: false,
            value: 'all',
            width: 110,
            margin: '3 0 0 0',
            listeners: {
                change: function() {
                    me.updateFilters('type', me.typeFilter.getValue());
                    setTimeout(function() {
                        me.searchField.focus();
                    }, 0);
                }
            }
        });
        // снимаю фокус с поля кобмобокса, чтобы правильно отработал text-overflow
        ExGods.Resources.load(me.typeFilter, function() {
            me.typeFilter.show();
        });
        return me.typeFilter;
    },
    initSearchField: function() {
        var me = this;
        me.searchField = Ext.widget('textfield', {
            emptyText: me.clientObject.search_placeholder_text,
            itemId: 'title',
            width: 100,
            cls: 'text-search-input',
            listeners: {
                change: {
                    fn: function() {
                        me.updateFilters('text', me.searchField.getValue());
                    },
                    buffer: 100
                },
                scope: me
            },
            padding: 1,
            value: ''
        });
        return me.searchField;
    },
    updateFilters: function(type, value) {
        var me = this,
            view = me.itemsView.isVisible() ? me.itemsView : me.myItemsView;
        view.setFilter(type, value);
        if (type == 'text') {
            // текстовый поиск осуществляется по всем предметам, включая недоступные
            // для этого отключаем все отслальные фильтры и включаем их назад, если поле поиска пустое
            if (Ext.String.trim(value)) {
                view.setFilter('avail', false);
                view.setFilter('level', 0);
                view.setFilter('type', 'all');
            } else {
                view.setFilter('avail', me.availCheckbox.getValue());
                view.setFilter('level', me.levelFilter.getValue());
                view.setFilter('type', me.typeFilter.getValue());
            }
        }
        view.applyFilters();
    },
    /**
     * Обработчик активации вкладки
     */
    onViewActivate: function(view) {
        var me = this;
        // показываю/скрываю чекбокс Доступные
        if (view == me.itemsView) {
            me.availCheckbox.show();
        } else {
            me.availCheckbox.hide();
        }
        // Выставляю значения по умолчанию в полях фильтра
        me.suspendEvents();
        me.availCheckbox.setValue(true);
        me.levelFilter.setValue(0);
        me.typeFilter.setValue('all');
        me.searchField.setValue('');
        me.resumeEvents();
        // фильтрую по умолчанию
        view.setFilter('avail', true);
        view.setFilter('level', 0);
        view.setFilter('type', 'all');
        view.setFilter('text', '');
        view.applyFilters();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + me.clientObject.my_items_tab_img,
                IMAGE_URL + me.clientObject.back_img,
                IMAGE_URL + me.clientObject.items_tab_img,
                me.clientObject.close_btn_text
            ]
        };
    }
});

/**
 * Контроллер рынка
 */
Ext.define('ExGods.controller.Market', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Market:'
    },
    views: [
        'market.Market'
    ],
    models: [
        'MarketItem'
    ],
    init: function() {
        var me = this;
        me.listen({
            component: {
                'textbutton[action="market-buy"]': {
                    click: me.onBuyBtnClick
                },
                'textbutton[action="market-cancel"]': {
                    click: me.onCancelBtnClick
                },
                'marketitems dataview': {
                    itemclick: me.onMarketItemClick
                },
                'marketmyitems dataview': {
                    itemclick: me.onMarketItemClick
                }
            }
        });
        ExGods.Components.addComponentInitializer('market', me.initMarketComponent, me);
        ExGods.util.Timers.on('market-my-items-timer-expire', me.onMyItemsTimerExpire, me);
    },
    /**
     * Проверяет, можно ли продать это имущество
     * @param stuff {Mixed} Объект имущества. Если это массив - то проверяет только первый элемент имущества
     */
    isCanSellStuff: function(stuff) {
        var me = this;
        return this.getMarketItemInfo(stuff) ? true : false;
    },
    /**
     * Проверяет, можно ли продать этот предмет
     * @param item {Object} Данные предмета
     */
    isCanSellItem: function(item) {
        var me = this;
        return this.isCanSellStuff({
            type: 'item',
            params: {
                id: item.proto_id
            }
        });
    },
    /**
     * Вернёт справочную информацию продаваемого имущества на рынке.
     * @param stuff {Mixed} Объект имущества. Если это массив - то проверяет только первый элемент имущества
     */
    getMarketItemInfo: function(stuff) {
        var me = this,
            result;
        stuff = Ext.isArray(stuff) ? stuff[0] : stuff;
        ExGods.ref('market').each(function(entry, item) {
            if (stuff.type == item.stuff.type && stuff.params.id == item.stuff.params.id) {
                result = item;
            }
        });
        return result;
    },
    /**
     * Выставить на продажу имущество из инвентаря
     * @param stuff {Mixed} Имущество
     * @param source {String} Источник ("inventory" или "source")
     */
    putStuffToMarket: function(stuff, source) {
        var me = this,
            marketItemInfo = me.getMarketItemInfo(stuff),
            getPriceInfo = function(entry, callback) {
                me.request({
                    url: 'map.pl?cmd=market_get_info&entry=' + marketItemInfo.entry,
                    success: function(resp) {
                        if (resp.success) {
                            callback(resp.info);
                        }
                    }
                });
            },
            showPutOnDialog = function(stuff, priceInfo, callback) {
                // определяю информацию о прототипе (картинка, название, etc)
                var image, title, proto;
                if (stuff.type == 'item') {
                    proto = ExGods.app.getItemPrototypesStore().data.getByKey(stuff.params.id);
                    if (proto) {
                        image = proto.data.images.on;
                        title = proto.data.title;
                    }
                } else if (stuff.type == 'ingredients') {
                    proto = ExGods.ref('ingredients|' + stuff.params.id);
                    if (proto) {
                        image = IMAGE_URL + proto.params.images.img_1;
                        title = proto.label;
                    }
                }
                var cmp = Ext.widget('progressdialog', {
                        title: title,
                        image: image,
                        autoShow: false,
                        label: Ext.String.format(ExGods.getMsgByKey('put_on_market_input_label'), '<img src="' + ExGods.ref('user_money|' + marketItemInfo.price.name).image + '">'),
                        min: priceInfo.min_price,
                        max: priceInfo.max_price,
                        value: Math.ceil(priceInfo.min_price + (priceInfo.max_price - priceInfo.min_price) / 2),
                        inputWidth: 75,
                        handler: callback,
                        buttonsText: [
                            ExGods.getMsgByKey('put_on_market_confirm_yes'),
                            ExGods.getMsgByKey('put_on_market_confirm_no')
                        ],
                        value_dependent_text: [
                            Ext.String.format(ExGods.getMsgByKey('put_on_market_comission_text'), '{[this.printComission(values)]}'),
                            {
                                printComission: function(values) {
                                    return ExGods.util.Format.printMoney({
                                        name: marketItemInfo.price.name,
                                        value: Math.round(values.value * priceInfo.comission / 100)
                                    });
                                }
                            }
                        ]
                    });
                ExGods.Resources.load(cmp, function() {
                    cmp.show();
                });
            };
        if (marketItemInfo) {
            me.app.block();
            getPriceInfo(marketItemInfo.entry, function(priceInfo) {
                me.app.unblock();
                showPutOnDialog(stuff, priceInfo, function(price) {
                    me.app.block();
                    if (source == 'inventory') {
                        ExGods.Services.get('inventory').command('put_from_inventory_market', {
                            entry: marketItemInfo.entry,
                            price: price
                        }, function(resp) {
                            me.app.unblock();
                            if (Ext.getCmp('MARKET')) {
                                me.service.update();
                            }
                        });
                    }
                    // перезапрашиваю данные сервиса, чтобы отобразить продаваемый предмет
                    else if (source == 'store') {
                        ExGods.Services.get('inventory').command('put_from_store_market', {
                            entry: stuff.entry,
                            price: price,
                            index: 1
                        }, function(resp) {
                            me.app.unblock();
                            if (Ext.getCmp('MARKET')) {
                                me.service.update();
                            }
                        });
                    }
                });
            });
        }
    },
    // перезапрашиваю данные сервиса, чтобы отобразить продаваемый предмет  
    /**
     * Выставить на продажу имущество из инвентаря
     * @param stuff {Mixed} Имущество
     */
    putInventoryStuffToMarket: function(stuff) {
        return this.putStuffToMarket(stuff, 'inventory');
    },
    /**
     * Выставить на продажу имущество из временного хранилища
     * @param stuff {Mixed} Имущество
     */
    putStoreStuffToMarket: function(stuff) {
        return this.putStuffToMarket(stuff, 'store');
    },
    /**
     * Иициализатор компонента "market"
     */
    initMarketComponent: function(config) {
        var me = this,
            wnd,
            loadProtosInner = function(callback) {
                var stuff = [];
                ExGods.ref('market').each(function(entry, item) {
                    stuff.push(item.stuff);
                });
                ExGods.helpme.loadProtosFromStuff(stuff, callback);
            };
        if (Ext.getCmp('MARKET')) {
            return;
        }
        me.service = config.service;
        wnd = Ext.widget('window1', {
            id: 'MARKET',
            autoShow: false,
            items: []
        });
        me.getController('Location').maskLocation(function() {
            // подгружаю прототипы имущества, продаваемого на рынке
            loadProtosInner(function() {
                // создаю компоненту и добавляю его в окно
                wnd.add({
                    xtype: 'market',
                    service: config.service,
                    clientObject: config,
                    listeners: {
                        reload: function() {
                            me.onMarketReloadClick();
                        },
                        close: {
                            fn: function() {
                                ExGods.loaderCt.loadAndRemove(function() {
                                    wnd.close();
                                }, {
                                    img: config.back_img
                                });
                                return false;
                            },
                            single: true
                        }
                    }
                });
                // подгрузка ресурсов
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    me.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.back_img
        });
        return wnd;
    },
    /**
     * Обработчик клика по кнопке "Купить"
     */
    onBuyBtnClick: function(btn) {
        var me = this,
            afterBuyInner = function(resp) {
                if (resp.success == 1) {
                    // обновляю данные сервиса
                    me.service.update(null, function() {
                        me.app.unblock();
                    });
                } else if (resp.not_min_price) {
                    // если покупка не удалась по причине неминимальной цены - обновляю данные сервиса и предлагаю купить юзеру продукт по новой цене, если он есть
                    me.service.update(null, function() {
                        me.app.unblock();
                        if (me.service.data.market && me.service.data.market[btn.entry] && me.service.data.market[btn.entry].price.length) {
                            var minPrice = {
                                    value: undefined,
                                    type: ''
                                };
                            me.service.data.market[btn.entry].price.forEach(function(price) {
                                if (minPrice.value == undefined) {
                                    minPrice = price;
                                } else if (parseInt(price.value) < parseInt(minPrice.value)) {
                                    minPrice = price;
                                }
                            });
                            Ext.widget('confirmdialog', {
                                title: '',
                                message: Ext.String.format(btn.confirm2_tpl, ExGods.util.Format.printMoney(minPrice)),
                                handler: function() {
                                    me.doBuyItem(btn.entry, minPrice.value, afterBuyInner);
                                }
                            });
                        }
                    });
                } else {
                    me.app.unblock();
                }
            };
        if (btn.confirm) {
            Ext.widget('confirmdialog', {
                title: '',
                message: btn.confirm,
                handler: function() {
                    me.doBuyItem(btn.entry, btn.price, afterBuyInner);
                }
            });
        } else {
            me.doBuyItem(btn.entry, btn.price, afterBuyInner);
        }
    },
    /**
     * Обработчик клика по кнопке "Отмена"
     */
    onCancelBtnClick: function(btn) {
        var me = this;
        if (btn.confirm) {
            Ext.widget('confirmdialog', {
                title: '',
                message: btn.confirm,
                handler: function() {
                    me.doCancelItem(btn.entry);
                }
            });
        } else {
            me.doCancelItem(btn.entry);
        }
    },
    /**
     * Покупка предмета
     */
    doBuyItem: function(entry, price, callback) {
        var me = this;
        me.app.block();
        me.service.command('market_buy_product', {
            entry: entry,
            price: price
        }, function(resp) {
            if (callback) {
                callback(resp);
            }
        });
    },
    /**
     * Снятие предмета с продаж 
     */
    doCancelItem: function(entry) {
        var me = this;
        me.app.block();
        me.service.command('product_from_market', {
            entry: entry
        }, function(resp) {
            if (resp.success) {
                me.service.update(null, function() {
                    me.app.unblock();
                });
            } else // обновляю данные сервиса
            {
                me.app.unblock();
            }
        });
    },
    /**
     * Обработчик клика по предмету на рынке
     */
    onMarketItemClick: function(view, item, itemEl, f, e) {
        var me = this;
        if (e.getTarget('.x-btn') || e.getTarget('.exg-stuff-imaged')) {
            return true;
        }
        Ext.get(itemEl).down('.exg-stuff-imaged').dom.click();
    },
    /**
     * Обработчик кнопки Обновить.
     * Обновляет данные рынка и сохраняем время последнего обновления.
     */
    onMarketReloadClick: function() {
        var me = this;
        if (me.reloadTime) {
            if (new Date() - me.reloadTime <= me.service.data.ttl_refresh_button * 1000) {
                return;
            }
        }
        // время до слудующего обновления еще не истекло
        me.reloadTime = new Date();
        me.service.update();
    },
    /**
     * Обработчик истечения таймера во вкладке "Мои лоты"
     */
    onMyItemsTimerExpire: function(el) {
        var me = this;
        Ext.get(el).setHTML('...');
        // обновляю данные сервиса
        me.service.update(null);
    }
});

/**
 * стафф показыается в интерфейсе апгрейда масок. Показывает количество с учетом текущего количества у юзера
 */
Ext.define('ExGods.view.mask.stuff.UpgradeStuff', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        me.replaceQuantityDecorator(data.decorators);
        return data;
    },
    /**
     * Заменяет стандартный декоратор кол-ва
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.mask.stuff.decorator.UpgradeQuantity);
    }
});

/**
 * Добавляет таймер оставшегося времени
 */
Ext.define('ExGods.view.mask.stuff.decorator.UpgradeQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getCls: function(data) {
            var userQuantity = this.getUserQuantityOfStuff(data),
                requiredQuantity = data.stuff.params.quantity || 0;
            if (!data.resultInfo && requiredQuantity > userQuantity) {
                return 'upgrade-stuff-decorator-quantity-red';
            } else {
                return 'upgrade-stuff-decorator-quantity-green';
            }
        },
        /**
         * @override
         */
        getQuantity: function(data) {
            var userQuantity, requiredQuantity;
            userQuantity = this.getUserQuantityOfStuff(data);
            requiredQuantity = data.stuff.params.quantity || 0;
            if (data.stuff.type == 'currency') {
                return requiredQuantity;
            } else {
                return userQuantity + '/' + requiredQuantity;
            }
        },
        /**
         * Вернет текущее кол-во ресурсов юзера по типу ресурса      
         */
        getUserQuantityOfStuff: function(data) {
            var userQuantity = 0;
            if (data.stuff.type == 'currency') {
                userQuantity = ExGods.app.user.get('money')[data.stuff.params.id];
            } else if (data.stuff.type == 'item') {
                userQuantity = ExGods.app.user.slots().getItemCount(data.stuff.params.id);
            } else if (data.stuff.type == 'ingredients') {
                userQuantity = ExGods.app.user.getIngredientCountByName(data.stuff.params.id);
            }
            return userQuantity;
        }
    }
});

/**
 * Модель маска в каталоге масок
 */
Ext.define('ExGods.model.Mask', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'enabled',
            type: 'int'
        },
        {
            name: 'g_order',
            type: 'int'
        },
        {
            name: 'group',
            type: 'auto'
        },
        {
            name: 'groupDur',
            type: 'int'
        },
        {
            name: 'has',
            type: 'auto'
        },
        {
            name: 'id',
            type: 'auto'
        },
        {
            name: 'slot_on',
            type: 'auto'
        },
        {
            name: 'message',
            type: 'string'
        },
        {
            name: 'item',
            type: 'auto',
            convert: function(v, r) {
                r.calcGroupDur(v);
                return ExGods.app.getItemPrototypesStore().data.getByKey(v).data;
            }
        },
        {
            name: 'item_price',
            type: 'auto'
        },
        {
            name: 'next_upgrade_price',
            type: 'auto'
        },
        {
            name: 'discount_ended',
            type: 'auto'
        },
        {
            name: 'params',
            type: 'auto'
        },
        {
            name: 'l_order',
            type: 'auto'
        },
        {
            name: 'battle_turns',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'auto'
        },
        {
            name: 'achievements',
            type: 'auto'
        },
        {
            name: 'next_enabled',
            type: 'int'
        },
        {
            name: 'next_message',
            type: 'string'
        },
        {
            name: 'current_upgrade',
            type: 'auto'
        },
        {
            name: 'next_battle_turns',
            type: 'auto'
        },
        {
            name: 'next_upgrade',
            type: 'auto'
        },
        {
            name: 'type',
            type: 'string'
        }
    ],
    calcGroupDur: function(item_id) {
        var me = this,
            durability = 0;
        item_id = item_id || me.get('item').entry;
        ExGods.app.user.slots().each(function(slot) {
            slot.get('items').each(function(item) {
                if (item.get('proto_id') == item_id && item.get('groupdur')) {
                    durability += item.get('groupdur');
                }
            });
        });
        me.set('groupDur', durability);
    }
});

/**
 * Окно апгрейда маски
 */
Ext.define('ExGods.view.mask.UpgradeWindow', {
    extend: Ext.panel.Panel,
    alias: 'widget.upgrademask',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    margin: '10 14 0',
    initComponent: function() {
        var me = this,
            maskGrade;
        if (me.currentFitMask.item) {
            maskGrade = me.currentFitMask.item.data.item_grade;
        }
        me.items = [
            {
                xtype: 'upgradeavatar',
                mask: me.currentFitMask.current_upgrade || Ext.apply({
                    label: me.currentFitMask.label
                }, me.currentFitMask.params),
                maskGrade: maskGrade || 0,
                localUserData: me.localUser.data
            },
            {
                xtype: 'upgradeprogress',
                mask: me.currentFitMask
            },
            {
                xtype: 'upgradeavatar',
                mask: me.currentFitMask.next_upgrade,
                maskGrade: (maskGrade || 0) + 1,
                compareMask: me.currentFitMask,
                localUserData: me.upgradeFitData,
                compareUserData: me.localUser.data
            }
        ];
        me.callParent();
    }
});

/**
 * Отображение характеристик маски и поьзователя
 */
Ext.define('ExGods.view.mask.MaskStats', {
    extend: Ext.panel.Panel,
    alias: 'widget.maskstats',
    id: 'user-mask-stats',
    cls: 'user-mask-stats',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    width: 218,
    height: 370,
    plugins: [
        'extraparchmentdeco'
    ],
    mass_data: {},
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    /**
     * @cfg {ExGods.model.Mask} mask (required)
     * Маска
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            mask = me.mask;
        me.items = [
            {
                xtype: 'component',
                data: me.prepareData(user.data.stats, mask),
                flex: 1,
                tpl: [
                    '<tpl if="values.name_black">' + '<h6 class="mask_title ellipsis" style="color: black; background: none;">{name_black}</h6>',
                    '<div class="ellipsis" style="text-align: center; font-weight: bold; margin: 0 8px; padding-bottom: 2px;">{groupName}</div>',
                    '<tpl else>' + '<h6 class="mask_title ellipsis">{name}</h6>',
                    '<div class="ellipsis" style="text-align: center; font-weight: bold; margin: 0 8px; padding-bottom: 2px; background: rgba(113, 172, 25, 0.33);">{groupName}</div>',
                    '</tpl>' + '<tpl if="this.checkWindow()">',
                    '<div class="user_stats_image">' + '{user_stats_image}' + '</div>' + '</tpl>',
                    '<div class="parchment-separator"></div>',
                    '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
                    '<div class="stats-list">' + '{user_stat}' + '</div>' + '<div class="parchment-separator"></div>' + '<div class="paper-title">' + ExGods.getMsgByKey('view_mask_stats_battleactions') + '</div>',
                    '<div class="stats-list like_table even">' + '<div class="align_middle">' + '<tpl if="actions.length">',
                    '<tpl for="actions">',
                    '<tpl if="xindex < 4">',
                    '<div class="action {[ parent.actions.length == 1 ? "single" : ""]}" data-id="{id}" data-type="{type}" data-qtip="{title}">',
                    '<div class="notify_i"></div>',
                    '<img height="52" width="52" src="{img}">',
                    '<strong>{title}</strong>',
                    '</div>',
                    '</tpl>',
                    '</tpl>',
                    '<tpl else>',
                    '{description}',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    '<div class="parchment-separator"></div>',
                    '<div class="paper-title">' + ExGods.getMsgByKey('view_mask_stats_conds') + '</div>',
                    '<div class="stats-list description2 like_table ">' + '<div class="align_middle">{description2}</div>' + '</div>',
                    {
                        hasDur: function(dur) {
                            return dur > 0;
                        },
                        checkWindow: function() {
                            return me.id == 'user-mask-stats-window';
                        }
                    }
                ]
            }
        ];
        this.dockedItems = [
            {
                xtype: 'panel',
                dock: 'bottom',
                margin: '0 0 30 0',
                style: {
                    textAlign: 'center',
                    overflow: 'visible'
                },
                items: [
                    {
                        xtype: 'panel',
                        html: '',
                        height: 15,
                        style: {
                            'margin-bottom': '3px'
                        }
                    },
                    {
                        xtype: 'textbutton',
                        text: mask && mask.item_price['new'] ? mask.item_price.discount ? ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_salebtntext'), {
                            price: ExGods.util.Format.printMoney(mask.item_price['old']),
                            discount_price: ExGods.util.Format.printMoney(mask.item_price['new'])
                        }) : ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_nosalebtntext'), {
                            price: ExGods.util.Format.printMoney(mask.item_price['new'])
                        }) : '',
                        action: 'buy-mask',
                        cls: 'qh-object no_border_double double_text ' + (mask.item_price.discount ? 'x-btn-txt-green' : ''),
                        //disabled: true,
                        width: 160,
                        margin: '0'
                    }
                ]
            }
        ];
        //id: 'put-mask'
        me.callParent();
        me.on('afterrender', function() {
            me.controlDetailedWindow();
            var button = this.dockedItems.last().items.items[1];
            var text = this.dockedItems.last().items.items[0];
            if (!mask.params.is_buyable || !mask.item_price['new'] || !mask.item_price['new'][0].value || mask.has) {
                button.hide();
                text.hide();
            } else {
                if (mask.item_price.discount == 0) {
                    text.hide();
                } else {
                    me.startDiscountTimer(mask);
                    text.show();
                    if (me.id == 'user-mask-stats')  {
                        me.dockedItems.last().el.setStyle('top', '293px');
                    }
                    else  {
                        me.dockedItems.last().el.setStyle('top', '340px');
                    }
                    
                }
            }
        });
        me.on('afterlayout', function() {
            var text = this.dockedItems.last().items.items[0];
            if (text.isVisible()) {
                if (me.id == 'user-mask-stats')  {
                    me.dockedItems.last().el.setStyle('top', '293px');
                }
                else  {
                    me.dockedItems.last().el.setStyle('top', '340px');
                }
                
            }
        });
        me.on('destroy', function() {
            clearInterval(me.discountwait);
            delete me.discountwait;
        });
    },
    controlDetailedWindow: function() {
        var me = this;
        this.getEl().on('click', function(e, el) {
            var id = el.getAttribute('data-id'),
                type = el.getAttribute('data-type'),
                info = ExGods.ref(type + '|' + id),
                maskData = me.mask.data ? me.mask.data : me.mask;
            if (info) {
                if (type == 'battle_turn' && maskData.battle_turns) {
                    // ищем инфо по стоимости использования для основного действия
                    Ext.Array.each(maskData.battle_turns, function(item) {
                        if (item.name == id) {
                            info.cost = ExGods.util.Stuff.printStuff(item.cost);
                        }
                    });
                }
                if (type == 'battle_turn') {
                    info.turn_type = ExGods.getMsgByKey('masks_turn_type_name');
                } else if (type == 'battle_prep') {
                    info.turn_type = ExGods.getMsgByKey('masks_prep_type_name');
                } else if (type == 'battle_actions') {
                    info.turn_type = ExGods.getMsgByKey('masks_action_type_name');
                }
                Ext.widget('commondetailswindow', {
                    itemElement: el,
                    data: {
                        label: info.label,
                        image: IMAGE_URL + (info.desc.images ? info.desc.images['active'] : info.desc.img),
                        rows: [
                            {
                                content: info.turn_type
                            },
                            {
                                content: info.cost ? '<div style="clear:both">' + ExGods.getMsgByKey('view_battle_prepactions_pricewordintt') + ' <span style="float:right; font-weight: bold;">' + info.cost + '</span></div>' : ''
                            },
                            {
                                content: info.desc.desc || info.desc.description
                            }
                        ]
                    }
                });
            }
        }, me, {
            delegate: '.action'
        });
    },
    startDiscountTimer: function(mask) {
        var me = this;
        var text = me.dockedItems.last().items.items[0];
        var restTime = (ExGods.util.Date.normalizeServerDateTime(mask.discount_ended) - new Date()) / 1000 + 1;
        if (text.getEl())  {
            text.getEl().setHTML(ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_saletpl'), {
                discount: mask.item_price.discount,
                time: ExGods.util.Time.printTime(restTime, {
                    format: 'twonums'
                })
            }));
        }
        
        clearInterval(me.discountwait);
        delete me.discountwait;
        me.discountwait = setInterval(function() {
            var currTime = (ExGods.util.Date.normalizeServerDateTime(mask.discount_ended) - new Date()) / 1000 + 1;
            if (currTime < 1) {
                clearInterval(me.discountwait);
                delete me.discountwait;
                if (me.id == 'user-mask-stats')  {
                    //перезагружаем 1 раз. на тот случай если открыто окно со всеми масками
                    ExGods.app.getController('Masks').reloadMaskService();
                }
                
                var button = me.dockedItems.last().items.items[1];
                button.removeCls('x-btn-txt-green');
                button.setText(Ext.String.format(ExGods.getMsgByKey('view_masks_buy_btn_text'), ExGods.util.Format.printMoney(mask.item_price['old'])));
                text.getEl().setHTML(ExGods.getMsgByKey('view_masks_stats_nosale'));
                if (me.id == 'user-mask-stats')  {
                    me.dockedItems.last().el.setStyle('top', '293px');
                }
                else  {
                    me.dockedItems.last().el.setStyle('top', '340px');
                }
                
            } else {
                text.getEl().setHTML(ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_saletpl'), {
                    discount: mask.item_price.discount,
                    time: ExGods.util.Time.printTime(currTime, {
                        format: 'twonums'
                    })
                }));
            }
        }, 1000);
    },
    updateUserStats: function(user, mask) {
        var me = this;
        me.mask = mask;
        this.show();
        //меняем кнопку на Надеть / Купить в зависимости от маски
        var button = this.dockedItems.last().items.items[1];
        var text = this.dockedItems.last().items.items[0];
        this.dockedItems.last().el.setStyle('top', '306px');
        if (mask.data.has) {
            button.hide();
            text.hide();
        } else {
            if (mask.data.params.is_buyable && mask.data.item_price['new'] && mask.data.item_price['new'][0].value) {
                button.action = "buy-mask";
                button.removeCls('x-btn-txt-green');
                button.show();
                if (mask.data.item_price.discount) {
                    button.addCls('x-btn-txt-green');
                    button.setText(ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_salebtntext'), {
                        price: ExGods.util.Format.printMoney(mask.data.item_price['old']),
                        discount_price: ExGods.util.Format.printMoney(mask.data.item_price['new'])
                    }));
                    this.startDiscountTimer(mask.data);
                    text.show();
                    if (this.id == 'user-mask-stats')  {
                        this.dockedItems.last().el.setStyle('top', '293px');
                    }
                    else  {
                        this.dockedItems.last().el.setStyle('top', '340px');
                    }
                    
                } else {
                    button.setText(Ext.String.format(ExGods.getMsgByKey('view_masks_buy_btn_text'), ExGods.util.Format.printMoney(mask.data.item_price['new'])));
                    text.hide();
                }
            } else {
                button.hide();
                text.hide();
            }
        }
        var data = this.prepareData(user, mask.data);
        this.items.first().update(data);
    },
    /**
     * Преобразовывает данные о пользователе в удобный вид для шаблона
     *
     * @param {Object} data Данные модели {ExGods.model.User}
     * @return {Object}
     */
    prepareData: function(user, mask) {
        if (!mask) {
            this.hide();
            return;
        }
        var me = this,
            preparedData = {
                name: [],
                user_stat: [],
                description: [],
                user_stats_image: [],
                groupDur: [],
                dur: [],
                description2: [],
                actions: []
            },
            params = mask.current_upgrade || mask.params;
        if (mask.item.data) {
            var label = mask.current_upgrade ? mask.current_upgrade.label : (mask.label || mask.item.title);
            preparedData[mask.has ? 'name' : 'name_black'] = label;
            preparedData.description = params.description1;
            preparedData.groupDur = mask.groupDur;
            preparedData.dur = mask.item.param.dur * mask.has;
            preparedData.nonbr = mask.item.param.nonbr;
            preparedData.groupName = mask.group;
            preparedData.mask_id = mask.id;
            if (params.battle_instants && params.battle_instants.length) {
                Ext.Array.each(params.battle_instants, function(item) {
                    var id = item.name,
                        info = ExGods.ref('battle_prep|' + id);
                    preparedData.actions.push({
                        id: id,
                        type: 'battle_prep',
                        title: info.label,
                        img: IMAGE_URL + info.desc.images['active'],
                        desc: info.desc.desc
                    });
                });
            }
            if (params.battle_turns && params.battle_turns.length) {
                Ext.Array.each(params.battle_turns, function(item) {
                    var id = item.name,
                        info = ExGods.ref('battle_turn|' + id);
                    preparedData.actions.push({
                        id: id,
                        type: 'battle_turn',
                        title: info.label,
                        img: IMAGE_URL + info.desc.images['active'],
                        desc: info.desc.desc
                    });
                });
            }
            if (params.battle_actions && params.battle_actions.length) {
                Ext.Array.each(params.battle_actions, function(item) {
                    var id = item.id,
                        info = ExGods.ref('battle_actions|' + id);
                    preparedData.actions.push({
                        id: id,
                        type: 'battle_actions',
                        title: info.label,
                        img: IMAGE_URL + info.desc.img,
                        desc: info.desc.description
                    });
                });
            }
            // сортирую действия по типу: "основное, предварительное, расходка"
            preparedData.actions = Ext.Array.sort(preparedData.actions, function(a, b) {
                if (a.type == b.type) {
                    return 0;
                } else if (a.type == 'battle_turn') {
                    return -1;
                } else if (a.type == 'battle_actions') {
                    return 1;
                } else if (b.type == 'battle_turn') {
                    return 1;
                } else {
                    return -1;
                }
            });
            if (params.is_buyable && mask.item_price['new'] && mask.item_price['new'][0].value && !mask.has)  {
                preparedData.description2 = '';
            }
            else {
                if (mask.achievements.length) {
                    Ext.Array.each(mask.achievements, function(ach1) {
                        if (ach1) {
                            if (ach1.value && !ach1.datefinish) {
                                var stage_max;
                                Ext.Array.each(ach1.stages, function(stage) {
                                    if (ach1.value < stage.value && !stage_max)  {
                                        stage_max = stage.value;
                                    }
                                    
                                });
                            }
                            preparedData.description2 += '<img style="margin: 2px 4px -4px -4px;" src="' + IMAGE_URL + 'icons/' + ((ach1.datefinish || (ach1.value && !stage_max)) ? '' : 'un') + 'done.png" />';
                            preparedData.description2 += ach1.description;
                            if (stage_max)  {
                                preparedData.description2 += ' (' + ach1.value + '/' + stage_max + ')';
                            }
                            
                            preparedData.description2 += '<br/>';
                        }
                    });
                } else {
                    preparedData.description2 = '<img style="margin: 2px 4px -4px -4px;" src="' + IMAGE_URL + 'icons/' + (mask.has ? 'done.png' : 'undone.png') + '" />' + params.description2;
                }
            }
            me.show();
        } else {
            me.hide();
        }
        var preparedChanges = {};
        Ext.each(config.references.user_stat, function(item) {
            if (item.visible == 1 && !item.param.fill) {
                var curStat = user.stats[item.name],
                    wasStat = ExGods.app.user.data.stats.stats[item.name],
                    changes = parseInt(curStat) - parseInt(wasStat),
                    className = '';
                preparedChanges[item.name] = changes;
            }
        });
        preparedData.user_stat = ExGods.util.User.printUserStats(user.stats, {
            visibleValue: 1,
            changes: preparedChanges,
            align: 'right'
        });
        preparedData.user_stats_image = ExGods.util.User.printUserStats(user.stats, {
            visibleValue: 2
        });
        return preparedData;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            maskData, params;
        mask_data = me.mask.data ? me.mask.data : me.mask;
        params = mask_data.current_upgrade || mask_data.params;
        Ext.Array.each(params.battle_instants, function(item) {
            var id = item.name,
                info = ExGods.ref('battle_prep|' + id);
            for (var it in info.desc.images) {
                arr_images.push(info.desc.images[it]);
            }
        });
        Ext.Array.each(params.battle_turns, function(item) {
            var id = item.name,
                info = ExGods.ref('battle_turn|' + id);
            for (var it in info.desc.images) {
                arr_images.push(info.desc.images[it]);
            }
        });
        Ext.Array.each(params.battle_actions, function(item) {
            var id = item.id,
                info = ExGods.ref('battle_actions|' + id);
            arr_images.push(info.desc.img);
        });
        Ext.Array.each(mask_data.battle_turns, function(item) {
            if (item.cost) {
                stuff_arr.push(item.cost);
            }
        });
        return {
            stuff: stuff_arr,
            images: [].concat(arr_images)
        };
    }
});

/**
 * Отображение характеристик маски и поьзователя
 */
Ext.define('ExGods.view.mask.MaskStatsStars', {
    extend: Ext.panel.Panel,
    alias: 'widget.maskstats_onlystars',
    id: 'user-mask-stats-stars',
    cls: 'user-mask-stats-stars',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    width: 235,
    height: 65,
    style: {
        'z-index': 5
    },
    mass_data: {},
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    /**
     * @cfg {ExGods.model.Mask} mask (required)
     * Маска
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            mask = me.mask;
        me.items = [
            {
                xtype: 'component',
                data: me.prepareData(user.data.stats, mask),
                flex: 1,
                tpl: [
                    '<div class="user_stats_image">' + '{user_stats_image}' + '</div>'
                ]
            }
        ];
        me.callParent();
    },
    updateUserStats: function(user, mask) {
        this.show();
        var data = this.prepareData(user, mask.data);
        this.items.first().update(data);
    },
    /**
     * Преобразовывает данные о пользователе в удобный вид для шаблона
     *
     * @param {Object} data Данные модели {ExGods.model.User}
     * @return {Object}
     */
    prepareData: function(user, mask) {
        if (!mask) {
            this.hide();
            return;
        }
        var me = this,
            preparedData = {
                name: [],
                user_stat: [],
                description: [],
                user_stats_image: [],
                groupDur: [],
                dur: [],
                description2: []
            };
        preparedData.user_stats_image = ExGods.util.User.printUserStats(user.stats, {
            visibleValue: 2
        });
        return preparedData;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        arr_images = arr_images.concat(ExGods.util.User.getUserStatImages());
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Кукла пользователя
 */
Ext.define('ExGods.view.mask.MaskAvatar', {
    extend: Ext.panel.Panel,
    alias: 'widget.maskavatar',
    layout: 'absolute',
    x: 5,
    y: 22,
    style: {
        'float': 'left'
    },
    /**
     * @cfg {ExGods.model.User} user (required)
     */
    nextAnimated: false,
    initComponent: function() {
        var me = this,
            user = me.user;
        if (me.cls != 'avatar') {
            me.plugins = [
                'inventory_frame'
            ];
        }
        me.callParent();
        me.avatar = me.initAvatar();
        me.add(me.avatar);
        me.mon(user, 'shapechanged', me.setAvatar, me);
    },
    initAvatar: function(invisible) {
        return Ext.widget('component', {
            style: this.getAvatarStyle(invisible),
            height: 410,
            width: 440,
            x: 0,
            y: 0
        });
    },
    /**
     * Меняет аватар пользователя
     */
    setAvatar: function() {
        var me = this;
        if (me.nextAnimated) {
            var avatar = me.initAvatar(true);
            me.add(avatar);
            me.avatar.el.animate({
                to: {
                    opacity: 0
                },
                duration: 1500
            });
            avatar.el.animate({
                to: {
                    opacity: 1
                },
                duration: 1500,
                callback: function() {
                    me.avatar.el.setStyle(me.getAvatarStyle());
                    avatar.destroy();
                    me.nextAnimated = false;
                }
            });
        } else {
            var speed = parseInt(ExGods.ref('constants|mask_house_change_speed').value),
                wait = parseInt(ExGods.ref('constants|mask_house_change_wait_time').value);
            me.avatar.el.animate({
                duration: speed,
                to: {
                    opacity: 0
                },
                listeners: {
                    afteranimate: function() {
                        me.avatar.el.setStyle(me.getAvatarStyle(true));
                    }
                }
            }).animate({
                delay: wait,
                duration: speed,
                to: {
                    opacity: 1
                }
            });
        }
    },
    /**
     * @private
     * Вернет стили для элемента аватарки
     */
    getAvatarStyle: function(invisible) {
        return {
            background: 'url(' + this.user.getAvatar() + ') no-repeat 50% 50%',
            position: 'absolute',
            opacity: invisible ? 0 : 1
        };
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                me.user.getAvatar()
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.Tape', {
    extend: ExGods.view.ViewPanel,
    alias: 'widget.exg_tape',
    /**
     * itemTpl
     */
    itemTpl: [],
    /**
     * cellWidth
     */
    cellWidth: 64,
    /**
     * cellHeight
     */
    cellHeight: 64,
    /**
     * viewConfig
     */
    viewConfig: null,
    /**
     * startRecord {Number|Record} индекс элемента или модель
     */
    startRecord: 0,
    /**
     * scrollDuration
     */
    scrollDuration: 300,
    initComponent: function() {
        var me = this;
        me.initTemplates();
        me.viewConfig = Ext.apply({
            collectData: Ext.Function.bind(me.collectData, me),
            itemSelector: 'exg-tape-item',
            store: me.store,
            tpl: [
                '<div class="exg-tape-inner" style="width: {[ this.getInnerWidth() ]}px; height: {[ this.getInnerHeight() ]}px;">',
                '<ul class="exg-tape-items">',
                '<tpl for=".">',
                '<li class="exg-tape-item" style="width: ' + me.cellWidth + 'px; height: ' + me.cellHeight + 'px;">',
                '{[ this.printItem(values) ]}',
                '</li>',
                '</tpl>',
                '</ul>',
                '<div class="x-clear"></div>',
                '</div>',
                {
                    getInnerWidth: function() {
                        return me.cellWidth;
                    },
                    getInnerHeight: function() {
                        return me.cellHeight * me.store.getCount();
                    },
                    printItem: function(data) {
                        return me.itemTpl.apply(data);
                    }
                }
            ]
        }, me.viewConfig);
        me.callParent();
        me.on('viewready', function() {
            me.setActiveEl(me.startRecord, {
                silent: true
            });
        }, me, {
            single: true
        });
        me.mon(me.store, 'update', Ext.Function.createBuffered(function() {
            me.store.sort();
            me.getView().refresh();
            me.setActiveEl(null, {
                animate: true,
                silent: true,
                forced: true
            });
        }, 100));
    },
    onRender: function() {
        var me = this;
        me.el.insertHtml('beforeEnd', '<div class="exg-tape-top"></div>');
        me.el.insertHtml('beforeEnd', '<div class="exg-tape-bottom"></div>');
        me.callParent();
        //click
        me.el.on('click', function() {
            me.scrollTop(null, function() {
                me.hoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) - 1));
            });
        }, me, {
            delegate: '.exg-tape-top'
        });
        me.el.on('click', function() {
            me.scrollBottom(null, function() {
                me.hoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) + 1));
            });
        }, me, {
            delegate: '.exg-tape-bottom'
        });
        //hover
        me.el.on('mouseover', function() {
            me.hoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) - 1));
        }, me, {
            delegate: '.exg-tape-top'
        });
        me.el.on('mouseout', function() {
            me.unhoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) - 1));
        }, me, {
            delegate: '.exg-tape-top'
        });
        me.el.on('mouseover', function() {
            me.hoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) + 1));
        }, me, {
            delegate: '.exg-tape-bottom'
        });
        me.el.on('mouseout', function() {
            me.unhoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) + 1));
        }, me, {
            delegate: '.exg-tape-bottom'
        });
        //scroll
        var wheelScroller = function(e) {
                e.preventDefault();
                if (e.detail > 0 || e.wheelDelta < 0) {
                    //крутим вниз
                    me.scrollBottom();
                } else {
                    // крутим вверх
                    me.scrollTop();
                }
            };
        me.getEl().dom.addEventListener('mousewheel', wheelScroller, false);
        me.getEl().dom.addEventListener('DOMMouseScroll', wheelScroller, false);
    },
    hoverRecord: function(record) {
        if (record) {
            this.getNodeByRecord(record).addCls('hover');
        }
    },
    unhoverRecord: function(record) {
        if (record) {
            this.getNodeByRecord(record).removeCls('hover');
        }
    },
    getNodeByRecord: function(record) {
        return this.getView().getNodeByRecord(record);
    },
    onSelect: function(view, model, index) {
        var me = this;
        me.fireEvent('select', me, view, model, index);
    },
    scrollTop: function(el, callback) {
        var me = this,
            model = me.getRecord(el),
            index = me.getIndex(model);
        if (index == -1) {
            return;
        }
        me.setActiveEl(--index, {
            animate: true,
            callback: callback || Ext.emptyFn
        });
    },
    scrollBottom: function(el, callback) {
        var me = this,
            model = me.getRecord(el),
            index = me.getIndex(model);
        if (index == -1) {
            return;
        }
        me.setActiveEl(++index, {
            animate: true,
            callback: callback || Ext.emptyFn
        });
    },
    /**
     * выставляет активный элемент
     * el {Number|Record|HTML|Ext.dom.Element} индекс элемента, модель, dom или Ext.dom.Element
     * opts
     *  - animate {Boolean} анимировать ли прокрутку
     *  - callback {Function}
     *  - silent {Boolean} если true - не вызывать эвент "select"
     *  - forced {Boolean} если true - сработает даже если текущая модель не изменилась. Нужно чтобы изменить селект при пересортировке
     */
    setActiveEl: function(el, opts) {
        var me = this,
            model = me.getRecord(el),
            index = me.getIndex(model),
            view = me.getView(),
            cb = function() {
                if (!opts.silent) {
                    me.onSelect(view, model, index);
                }
                if (opts.callback)  {
                    opts.callback();
                }
                
            };
        opts = opts || {};
        if (!model)  {
            return false;
        }
        
        if (me.activeEl == model && !opts.forced)  {
            return false;
        }
        
        me.activeEl = model;
        var margin = Math.floor(me.getHeight() / 2 - me.cellHeight / 2) - index * me.cellHeight;
        view.el.stopAnimation();
        if (opts.animate) {
            view.el.animate({
                duration: me.scrollDuration,
                to: {
                    marginTop: margin + 'px'
                },
                callback: cb
            });
        } else {
            view.el.setStyle({
                marginTop: margin + 'px'
            });
            cb();
        }
    },
    /**
     * вернет модель из стора/проверит на наличие
     * el {Number|Record|HTML|Ext.dom.Element} индекс элемента, модель, dom или Ext.dom.Element
     */
    getRecord: function(el) {
        var me = this,
            index, model,
            view = me.getView();
        if (!el && el !== 0)  {
            return me.activeEl;
        }
        
        if (typeof el == 'number') {
            index = el;
            model = me.store.getAt(el);
        } else if (el.isModel) {
            model = el;
            index = me.store.indexOf(model);
        } else {
            el = Ext.get(el);
            model = view.getRecord(el);
            index = me.store.indexOf(model);
        }
        if (!model || index == -1) {
            return;
        }
        return model;
    },
    getActiveEl: function() {
        var me = this;
        return me.activeEl;
    },
    /**
     * вернет индекс модели в сторе
     * если модель не передана - вернет индекс текущей модели
     */
    getIndex: function(model) {
        var me = this,
            index = me.store.indexOf(model || me.getActiveEl());
        return index == -1 ? false : index;
    },
    /**
     * Инициализация шаблонов элементов ленты и элемента селектора
     */
    initTemplates: function() {
        var me = this;
        me.itemTpl = new Ext.XTemplate(me.itemTpl);
        me.selectorTpl = new Ext.XTemplate(me.selectorTpl);
    },
    /**
     * Стандартный метод DataView. Можно переопределять в произодных классах
     */
    collectData: function(records) {
        var me = this,
            data = [];
        records.forEach(function(record) {
            data.push(record.data);
        });
        return data;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            parent, items,
            arr_images = [];
        if (me.store) {
            items = me.store.data.items;
            for (var i = 0; i < items.length; i++) {
                if (items[i].data.item && items[i].data.item.images) {
                    for (var it in items[i].data.item.images) {
                        var img = items[i].data.item.images[it];
                        arr_images.push(img);
                    }
                }
            }
        }
        return {
            stuff: [],
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.mask.Tape', {
    extend: ExGods.view.Tape,
    alias: 'widget.masktape',
    cls: 'mask-items',
    bodyStyle: {
        overflow: 'visible'
    },
    cellWidth: 86,
    cellHeight: 82,
    initComponent: function() {
        var me = this;
        me.itemTpl = [
            '<div class="qh-object item {[this.getClass(values)]}" data-qh_otype="maskobject" data-qh_oid="{id}" id="maskid-{id}" data-qtip="{[this.getEscapedTitle(values)]}" >',
            '<div class="mask_frm"></div>',
            '<img class="image" src="{[this.getImage(values)]}" width="50" height="50">',
            '<div class="sticker"{[ this.getStickerStyle(values) ]}></div>',
            '<tpl if="values.has && this.checkDur(values)">',
            '<div class="dur">{groupDur}</div>',
            '</tpl>',
            '</div>',
            {
                getClass: function(values) {
                    return values.has ? ' has' : '';
                },
                checkDur: function(values) {
                    return values.item.param.nonbr == 0;
                },
                getEscapedTitle: function(values) {
                    return Ext.String.htmlEncode(values.item.title);
                },
                getImage: function(values) {
                    return values.has ? values.item.images.on : values.item.images.off;
                },
                getStickerStyle: function(values) {
                    var style = '';
                    if (values.params.toughness == 'red') {
                        var images = ExGods.ref('images|masks_images').image,
                            image = values.has ? images.trophies_rare : images.trophies_rare_bw;
                        style = ' style="background-image: url(' + image + ')"';
                    }
                    return style;
                }
            }
        ];
        me.scrollDuration = ExGods.ref('constants|mask_scroll_time').value * 1000;
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.printSelector();
    },
    printSelector: function() {
        var me = this;
        me.el.insertHtml('beforeEnd', '<div class="mask_selected_frame"></div>');
    },
    /**
     * override
     */
    getNodeByRecord: function(record) {
        return this.el.down('#maskid-' + record.get('id'));
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var parent = me.callParent();
        var images_trophies = ExGods.ref('images|masks_images').image;
        for (var it in images_trophies) {
            arr_images.push(images_trophies[it]);
        }
        return {
            stuff: [].concat(parent.stuff),
            images: [
                IMAGE_URL + 'mask/mask_select.png'
            ].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 * Окно в котором маски отображаются таблицей
 */
Ext.define('ExGods.view.mask.CentralWindowMasks', {
    extend: Ext.panel.Panel,
    alias: 'widget.centralwindowmasks',
    bodyPadding: '7 8 0 6',
    config: {
        plugins: []
    },
    blocksPerPage: 3,
    masksInBlock: 5,
    initComponent: function() {
        var me = this;
        me.store = ExGods.app.getStore('Masks');
        me.maskGroups = me.store.getGroups();
        me.currentMask = me.store.getCurrent() || me.store.getAt(0);
        me.mon(me.store, {
            datachanged: me.updateMasks,
            update: me.updateMasks,
            scope: me
        });
        me.items = [
            {
                xtype: 'panel',
                layout: 'absolute',
                height: 415,
                items: [
                    {
                        xtype: 'maskstats',
                        itemId: 'user-mask-stats-window',
                        id: 'user-mask-stats-window',
                        user: me.user,
                        mask: me.currentMask.data,
                        closable: false,
                        x: 6,
                        y: 0,
                        height: 415
                    },
                    {
                        xtype: 'container',
                        itemId: 'masksWindow',
                        itemSelector: 'li',
                        x: 222,
                        y: 4,
                        width: 529,
                        height: 383,
                        html: me.prepareMasksHtml(me.maskGroups),
                        style: {
                            'overflow': 'hidden'
                        },
                        padding: '0 0 32 0'
                    },
                    {
                        xtype: 'form',
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        bodyPadding: '0 15 0 0',
                        margin: '-3 0 0 0',
                        defaults: {
                            xtype: 'checkboxfield',
                            checked: true,
                            style: {
                                color: '#e3ac69'
                            },
                            padding: '0 15 0 0',
                            listeners: {
                                change: me.onFilterChange,
                                scope: me
                            }
                        },
                        items: me.getTypeFilters()
                    }
                ]
            }
        ];
        me.initPager();
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.openPage(1);
        me.el.on('click', function(e, dom) {
            var id = dom.id.split('_')[1],
                rec = me.store.findRecord('id', id);
            me.fireEvent('itemclick', me, rec, dom);
        }, me, {
            delegate: '.mask-item'
        });
    },
    setMask: function(mask) {
        var me = this;
        me.el.down('#maskid_' + me.currentMask.get('id')).removeCls('mask_fit');
        me.el.down('#maskid_' + mask.get('id')).addCls('mask_fit');
        me.currentMask = mask;
        me.down('maskstats').updateUserStats(Ext.apply({
            shape: me.user.get('shape')
        }, me.user.get('stats')), mask);
    },
    onFilterChange: function() {
        var me = this;
        me.updateMasks();
        me.openPage(1);
        me.pager.refresh();
    },
    updateMasks: function() {
        var me = this,
            form = me.down('form'),
            view = me.down('#masksWindow'),
            types = [],
            filtered = [];
        // достаю типы
        form.items.each(function(item) {
            if (item.checked) {
                types.push(item.boxLabel);
            }
        });
        Ext.Array.each(me.maskGroups, function(group) {
            if (types.indexOf(group.type) != -1) {
                filtered.push(group);
            }
        });
        view.el.setHTML(me.prepareMasksHtml(filtered));
        me.pager.total = Math.ceil(filtered.length / me.blocksPerPage) || 1;
        me.openPage(me.pager.current);
        me.pager.refresh();
    },
    /**
     * @private
     */
    getTypeFilters: function() {
        var me = this,
            types = [],
            filters = [];
        Ext.Array.each(me.maskGroups, function(group) {
            Ext.Array.each(group.records, function(record) {
                var type = record.get('type');
                if (type && Ext.Array.indexOf(types, type) == -1) {
                    types.push(type);
                    filters.push({
                        boxLabel: type
                    });
                }
            });
        });
        return filters;
    },
    /**
     * @private
     */
    prepareMasksHtml: function(groups) {
        var me = this,
            masks_html = '<ul class="mask-items window_mask" style="padding: 0 0 0 8px">',
            getStickerStyle = function(values) {
                var style = '';
                if (values.params.toughness == 'red') {
                    var images = ExGods.ref('images|masks_images').image,
                        image = values.has ? images.trophies_rare : images.trophies_rare_bw;
                    style = ' style="background-image: url(' + image + ')"';
                }
                return style;
            };
        Ext.Array.each(groups, function(group) {
            masks_html += '<div class="mask_window_container"><div class="mask_window-header">' + group.name + '<div class="mask_group_text">' + group.name + '</div></div>';
            Ext.Array.each(group.records, function(mask, i) {
                var has = mask.get('has'),
                    item = mask.get('item'),
                    id = mask.get('id'),
                    cls = '';
                if (has)  {
                    cls += ' has';
                }
                
                if (me.currentMask == mask)  {
                    cls += ' mask_fit';
                }
                
                if (i >= me.masksInBlock)  {
                    return;
                }
                
                if (i > 0 && i < me.masksInBlock) {
                    masks_html += '<div class="mask-arrow' + (has ? '' : ' disabled') + '"></div>';
                }
                masks_html += '<li class="qh-object mask-item item ' + mask.get('params').toughness + cls + '" id="maskid_' + id + '" data-qh_otype="maskobject" data-qh_oid="' + id + '" ' + (i < 1 ? 'data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : '') + '>' + '<div class="mask_frm"></div>' + '<img class="image" src="' + item.images[has ? 'on' : 'off'] + '" width="50" height="50">' + (has && !item.param.nonbr ? '<div class="dur">' + mask.get('groupDur') + '</div>' : '') + '<div class="sticker"' + getStickerStyle(mask.data) + '></div>' + '<div class="notify_i"></div>' + '<div class="x-clear"></div>' + '</li>';
                if (i == group.records.length - 1 && group.records.length < me.masksInBlock) {
                    for (var i = 0; i < me.masksInBlock - group.records.length; i++) {
                        masks_html += '<div class="mask-arrow disabled"></div>';
                        masks_html += '<li>' + '<div class="mask_frm"></div>' + '<img class="image" src="' + IMAGE_URL + 'locations/monster_absent.jpg" width="50" height="50">' + '<div class="x-clear"></div>' + '</li>';
                    }
                }
            });
            masks_html += '</div>';
        });
        masks_html += '</ul>';
        return masks_html;
    },
    /**
     * Инициализация пейджера
     */
    initPager: function() {
        var me = this;
        me.config.plugins.push({
            ptype: 'pager',
            marginLeft: -29,
            marginRight: -29,
            top: 185,
            current: 1,
            currentTab: 0,
            total: Math.ceil(me.maskGroups.length / me.blocksPerPage),
            totalTabs: 1,
            textLeft: 435,
            textTop: -36
        });
        me.prevPage = function(pager) {
            me.openPage(pager.current);
            pager.refresh();
        };
        me.nextPage = function(pager) {
            me.openPage(pager.current);
            pager.refresh();
        };
        me.openPage = function(pageIndex) {
            var me = this;
            me.pager.current = pageIndex;
            pageIndex--;
            //для удобства расчета, т.к. страницы начинаются с 1, а массив с 0
            els = me.getEl().select('.mask_window_container');
            els.setStyle('display', 'none');
            var i = els.elements.length;
            while (i--) {
                els.elements[i].style.display = Math.floor(i / me.blocksPerPage) == pageIndex ? 'block' : 'none';
            }
        };
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        Ext.Array.each(me.maskGroups, function(group) {
            Ext.Array.each(group.records, function(mask, i) {
                var item = mask.get('item');
                for (var it in item.images) {
                    arr_images.push(item.images[it]);
                }
            });
        });
        var images_trophies = ExGods.ref('images|masks_images').image;
        for (var it in images_trophies) {
            arr_images.push(images_trophies[it]);
        }
        return {
            images: [
                IMAGE_URL + 'locations/monster_absent.jpg',
                IMAGE_URL + 'locations/monster_frame_green.png',
                IMAGE_URL + 'mask/header_class.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Аватар
 */
Ext.define('ExGods.view.mask.UpgradeAvatar', {
    extend: Ext.Component,
    alias: 'widget.upgradeavatar',
    width: 234,
    height: 404,
    cls: 'upgrade-avatar',
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="avatar" style="background-image:url({[this.getImage(values.user)]})"></div>',
            '<h1>{mask.label}</h1>',
            '<div class="avatar-bg"></div>',
            '<div id="upgrade-mask-preps">',
            '<tpl for="mask.battle_instants">',
            '<div class="ability-img prep-link" data-prep_name="{name}" style="background:url({[this.getPrepImage(values.name)]})">',
            '<div class="notify_i"></div>',
            '</div>',
            '</tpl>',
            '</div>',
            '<div class="info-top-container">',
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="avatar-info-container">',
            '{[ ExGods.util.User.printUserStats(values.user.stats.stats, {visibleValue: 2}) ]}',
            '<div class="paper-separator"></div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
            '<div class="avatar-params stats-list">',
            '<tpl if="compareUser">',
            '{[ ExGods.util.User.printUserStats(values.user.stats.stats, {visibleValue: 1, changes:this.prepareChanges(values), align: "right"}) ]}',
            '<tpl else>',
            '{[ ExGods.util.User.printUserStats(values.user.stats.stats, {visibleValue: 1, align: "right"}) ]}',
            '</tpl>',
            '</div>',
            '<div class="paper-separator"></div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('view_mask_stats_battleactions') + '</div>',
            '<tpl if="mask.battle_turns">',
            '<div class="stats-list like_table">',
            '<div class="align_middle">',
            '<tpl for="mask.battle_turns">',
            '<div class="action turn-link" id="turn__{name}" data-turn_name="{name}">',
            '<img src="{[this.getTurnImage(values.name)]}">',
            '<p>{[this.getTurnLabel(values.name)]}</p>',
            '<div class="notify_i"></div>',
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            '<div class="upgrade-mask-params-btn inventory-params noselect">' + ExGods.getMsgByKey('inventory_params_btn_text') + '</div>',
            {
                prepareChanges: function(values) {
                    var changes = {};
                    Ext.Object.each(values.user.stats.stats, function(k, v) {
                        changes[k] = parseInt(v) - parseInt(values.compareUser.stats.stats[k]);
                    });
                    return changes;
                },
                getImage: function(user) {
                    return ExGods.ref('user_shape|' + user.shape).full;
                },
                getPrepImage: function(name) {
                    return IMAGE_URL + ExGods.ref('battle_prep').get(name).desc.images.active;
                },
                getTurnImage: function(name) {
                    return IMAGE_URL + ExGods.ref('battle_turn').get(name).desc.images.active;
                },
                getTurnLabel: function(name) {
                    return ExGods.ref('battle_turn').get(name).label;
                }
            }
        ];
        me.data = {
            user: me.localUserData,
            mask: me.mask,
            compareUser: me.compareUserData
        };
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.maskGradeLine = Ext.widget('maskgradeline', {
            renderTo: me.getEl(),
            maskGrade: me.maskGrade
        });
        me.el.on('click', function() {
            var el = me.el.down('.info-top-container'),
                btn = me.el.down('.upgrade-mask-params-btn');
            if (el.isVisible()) {
                el.hide();
                btn.removeCls('opened');
            } else {
                el.show();
                btn.addCls('opened');
            }
        }, me, {
            delegate: '.upgrade-mask-params-btn'
        });
    },
    onDestroy: function() {
        var me = this;
        me.maskGradeLine.destroy();
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        arr_images.push(ExGods.ref('user_shape|' + me.data.user.shape).full);
        for (var it in me.data.mask.battle_instants) {
            var name = me.data.mask.battle_instants[it].name;
            var btl = ExGods.ref('battle_prep').get(name).desc.images;
            for (var it in btl) {
                arr_images.push(btl[it]);
            }
        }
        for (var it in me.data.mask.battle_turns) {
            var name = me.data.mask.battle_turns[it].name;
            var btl = ExGods.ref('battle_turn').get(name).desc.images;
            for (var it in btl) {
                arr_images.push(btl[it]);
            }
        }
        return {
            images: [
                IMAGE_URL + 'mask/trophy_mask_frm.png',
                IMAGE_URL + 'battle/peril-ico.png',
                IMAGE_URL + 'battle/peril-trafaret.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Процесс апгрейда
 */
Ext.define('ExGods.view.mask.UpgradeProgress', {
    extend: Ext.Component,
    alias: 'widget.upgradeprogress',
    width: 294,
    height: 404,
    margin: '0 -7',
    y: 12,
    style: {
        zIndex: 1,
        overflow: 'hidden'
    },
    cls: 'upgrade-progress',
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="progress-bg"></div>',
            '<div id="anim-progress"></div>',
            '<div class="upper-progress-bg"></div>',
            '<div class="ingredients">',
            '<tpl for="next_upgrade_price">',
            '{[ this.printStuff(values) ]}',
            '</tpl>',
            '</div>',
            '<div id="upgrade-button-place"></div>',
            {
                printStuff: function(data) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'upgrade_stuff',
                        params: {
                            stuff: data
                        }
                    });
                }
            }
        ];
        me.data = me.mask;
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.btn = Ext.widget('textbutton', {
            text: ExGods.getMsgByKey('view_masks_improve_btn_text'),
            cls: 'double_text_btn',
            disabled: !me.mask.next_enabled || !me.mask.has || !me.isEnoughtResources(),
            width: 116,
            handler: function() {
                if (me.mask.next_message) {
                    ExGods.app.getViewportController().onLogMessage(me.currentFitMask.next_message);
                } else {
                    me.fireEvent('upgrade', {
                        id: me.mask.id,
                        item: me.mask.next_upgrade.item.id,
                        from_item: me.mask.item.entry,
                        btn: me.btn
                    }, me.startAnimate.bind(me));
                }
            },
            renderTo: 'upgrade-button-place'
        });
    },
    startAnimate: function() {
        var spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                images: [
                    'mask/upgarade_mask.png'
                ],
                frames: [
                    [
                        0,
                        0,
                        42,
                        37,
                        0,
                        66.45,
                        57.45
                    ],
                    [
                        42,
                        0,
                        42,
                        37,
                        0,
                        66.45,
                        57.45
                    ],
                    [
                        84,
                        0,
                        145,
                        42,
                        0,
                        66.45,
                        61.45
                    ],
                    [
                        229,
                        0,
                        145,
                        42,
                        0,
                        66.45,
                        61.45
                    ],
                    [
                        374,
                        0,
                        213,
                        49,
                        0,
                        66.45,
                        64.45
                    ],
                    [
                        587,
                        0,
                        283,
                        293,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        0,
                        293,
                        283,
                        293,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        283,
                        293,
                        283,
                        293,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        566,
                        293,
                        283,
                        293,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        0,
                        586,
                        283,
                        296,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        283,
                        586,
                        283,
                        296,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        566,
                        586,
                        283,
                        296,
                        0,
                        66.45,
                        67.45
                    ]
                ],
                renderTo: this.getEl().down('#anim-progress'),
                finish: function() {
                    this.inProgress = false;
                }
            });
        //fps:1
        spriteSheet.start();
        return spriteSheet;
    },
    getResources: function() {
        return [
            IMAGE_URL + 'mask/upgarade_mask.png'
        ];
    },
    /**
     * Проверка на достаточное кол-во ресурсов для апгрейда
     */
    isEnoughtResources: function() {
        var me = this;
        return ExGods.app.getUser().checkStuff(me.mask.next_upgrade_price);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        for (var i = 0; i < me.data.next_upgrade_price.length; i++) {
            var stuff_ = me.data.next_upgrade_price[i];
            stuff_arr.push(stuff_);
        }
        return {
            stuff: stuff_arr,
            images: [
                IMAGE_URL + 'mask/trophy_improvemask_bg.png',
                IMAGE_URL + 'mask/trophy_improvemask_top.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Полоска, отображающая грейд маски (черепки)
 */
Ext.define('ExGods.view.mask.MaskGradeLine', {
    extend: Ext.Component,
    alias: 'widget.maskgradeline',
    cls: 'mask-grade-line',
    /**
     * @cfg {Object} maskProto Данные прототипа маски
     */
    /**
      * @cfg {Number} maskGrade Уровень грейда маски
      */
    width: 86,
    initComponent: function() {
        var me = this,
            user = me.user;
        if (me.maskProto) {
            me.data = me.maskProto;
        } else {
            me.data = {
                data: {
                    item_grade: me.maskGrade
                }
            };
        }
        me.tpl = [
            '<tpl if="data.item_grade">',
            '{[ this.getCherepoks(values) ]}',
            '</tpl>',
            {
                getCherepoks: function(values) {
                    var html = '';
                    for (var i = 0; i < values.data.item_grade; i++) {
                        html += '<div></div>';
                    }
                    return html;
                }
            }
        ];
    }
});

/**
 * Управление инвентарём
 */
Ext.define('ExGods.controller.Masks', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /**
         * @method getMasksWindow
         * Возвращает кнопку "Общение"
         * @return {ExGods.view.menu.MainMenuButton}
         */
            ref: 'masksWindow',
            selector: '#masksWindow'
        },
        {
            /**
         * @method getTape
         * Возвращает панель масок
         * @return {Ext.panel}
         */
            ref: 'tape',
            selector: '#maskTape'
        },
        {
            /**
         * @method getAvailability
         * Возвращает чекбокс "доступные"
         * @return {Ext.form.field.Checkbox}
         */
            ref: 'availability',
            selector: '#availability'
        },
        {
            /**
         * @method getSearchEmptyMessage
         * Возвращает надпись, когда нет масок
         * @return {Ext.panel}
         */
            ref: 'searchEmptyMessage',
            selector: '#search_empty_message'
        },
        {
            /**
         * @method getUserMaskStats
         * Возвращает контейнер информации о маске
         * @return {Ext.panel}
         */
            ref: 'userMaskStats',
            selector: '#user-mask-stats'
        },
        {
            /**
         * @method getUserMaskStatsWindow
         * Возвращает контейнер информации о маске из окна "все маски"
         * @return {Ext.panel}
         */
            ref: 'userMaskStatsWindow',
            selector: '#user-mask-stats-window'
        },
        {
            /**
         * @method getMaskContainer
         * Возвращает контйнер в котором лежат маски
         * @return {ExGods.view.ViewPanel}
         */
            ref: 'maskContainer',
            selector: '#mask-container'
        },
        {
            /**
         * @method getUserMaskStatsStars
         * Возвращает контейнер "статы звездочками" под картинкой маски
         * @return {ExGods.view.mask.MaskStatsStars}
         */
            ref: 'userMaskStatsStars',
            selector: '#user-mask-stats-stars'
        },
        {
            /**
         * @method getBackInTown
         * Возвращает кнопку "В город"
         */
            ref: 'backInTown',
            selector: '#back_in_town'
        },
        {
            /**
         * @method getUpgradeMaskWnd
         * Возвращает окно "Апгрейд"
         */
            ref: 'upgradeMaskWnd',
            selector: 'upgrademask'
        },
        {
            /**
         * @method getCentralWindowMasks
         * Возвращает окно масок по группам
         */
            ref: 'centralWindowMasks',
            selector: 'centralwindowmasks'
        },
        {
            /**
         * @method getUpgradeBtn
         * Возвращает кнопку "Апгрейд"
         */
            ref: 'upgradeBtn',
            selector: '#upgrade-mask-btn'
        }
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Masks:'
    },
    models: [
        'Mask'
    ],
    views: [
        'mask.MaskStats',
        'mask.MaskAvatar',
        'mask.MaskStatsStars',
        'mask.CentralWindowMasks',
        'mask.UpgradeWindow',
        'mask.UpgradeAvatar',
        'mask.UpgradeProgress',
        'mask.MaskGradeLine',
        'mask.Tape'
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Masks:'
    },
    init: function(app) {
        var me = this,
            user = app.user;
        me.store = me.app.getMasksStore();
        me.control({
            'button[action="buy-mask"]': {
                click: me.buyMask
            },
            'upgradeprogress': {
                upgrade: me.onUpgrade
            },
            'masktape': {
                select: me.onMaskSelect
            },
            'centralwindowmasks': {
                itemclick: me.onCentralWindowItemClick
            }
        });
        ExGods.stuff.StuffManager.register({
            'upgrade_stuff': ExGods.view.mask.stuff.UpgradeStuff
        });
        me.fitMask = Ext.Function.createBuffered(me.fitMask, ExGods.ref('constants|mask_fit_time').value * 1000);
        ExGods.Components.addComponentInitializer('masks', me.initMasksComponent, me);
    },
    reloadMaskService: function(data) {
        var me = this;
        if (me.service) {
            me.service.update(data || null, function() {
                ExGods.helpme.loadProtos(me.service.data.masks, 'item', function() {
                    me.store.loadRawData(me.service.data.masks);
                    //ищу текущую маску из новых записей хранилища
                    me.currentFitMask = me.store.findRecord('id', me.currentFitMask.get('id'));
                    me.updateViews();
                });
            });
        }
    },
    initMasksComponent: function(config) {
        var me = this;
        if (Ext.getCmp('MASKS')) {
            return;
        }
        me.service = config.service;
        me.localUser = Ext.create('ExGods.model.User', Ext.clone(ExGods.app.user.raw));
        me.cmp = Ext.create('ExGods.view.Room', {
            cls: 'masks',
            backgroundImage: config.backImg,
            emptySearchText: config.emptySearchText,
            closeText: config.closeText,
            fitText: config.fitText,
            closeColor: config.closeColor,
            parent: me,
            closeCallback: Ext.Function.bind(me.checkFitOnClose, me, []),
            rightPanelX: 715,
            margin: '0 10 10 0',
            closable: true,
            items: [
                {
                    xtype: 'component',
                    margin: '0 0 0 722',
                    html: '<div class="mask_header" style="background: url(' + ExGods.ref('images|masks_images').image['header_trophy_text'] + ');"></div>'
                }
            ],
            listeners: {
                beforeclose: {
                    fn: function() {
                        me.checkFitOnClose(true);
                        return false;
                    }
                }
            }
        });
        wnd = Ext.widget('window1', {
            id: 'MASKS',
            autoShow: false,
            items: [
                me.cmp
            ]
        });
        me.maskImage = config.backImg;
        ExGods.app.getController('Location').maskLocation(function() {
            // подгрузка ресурсов
            ExGods.helpme.loadProtos(me.service.data.masks, 'item', function() {
                me.store.loadRawData(me.service.data.masks);
                me.currentFitMask = me.store.getCurrent();
                var currentFitMask = me.currentFitMask || me.store.getAt(0);
                me.cmp.add({
                    xtype: 'maskstats',
                    itemId: 'user-mask-stats',
                    closeAction: 'hide',
                    user: me.localUser,
                    mask: currentFitMask.data,
                    closable: false,
                    x: 10,
                    y: 6
                }, {
                    xtype: 'maskstats_onlystars',
                    itemId: 'user-mask-stats-stars',
                    closeAction: 'hide',
                    user: me.localUser,
                    mask: currentFitMask.data,
                    closable: false,
                    x: 321,
                    y: 347
                }, {
                    xtype: 'maskavatar',
                    user: me.localUser,
                    cls: 'avatar',
                    x: 205,
                    y: 0,
                    width: 440
                }, {
                    xtype: 'masktape',
                    itemId: 'maskTape',
                    x: 615,
                    y: 40,
                    width: 225,
                    height: 325,
                    store: me.store,
                    startRecord: currentFitMask
                }, {
                    height: 30,
                    x: 60,
                    y: 375,
                    width: 110,
                    xtype: 'textbutton',
                    text: config.text_trophy_all,
                    cls: 'get_all_masks_btn',
                    handler: function(btn) {
                        var wnd = Ext.widget('window2', {
                                autoShow: false,
                                items: [
                                    {
                                        xtype: 'centralwindowmasks',
                                        user: me.localUser
                                    }
                                ]
                            });
                        ExGods.Resources.load(wnd, function() {
                            wnd.show();
                        });
                    }
                }, {
                    height: 30,
                    x: 615,
                    y: 373,
                    width: 110,
                    xtype: 'textbutton',
                    text: config.text_improve,
                    id: 'upgrade-mask-btn',
                    cls: 'qh-object',
                    hidden: !currentFitMask.data.next_upgrade,
                    handler: function() {
                        if (me.sendingFitRequest) {
                            var interval = setInterval(function() {
                                    if (me.sendingFitRequest)  {
                                        return;
                                    }
                                    
                                    me.showMaskUpgradeWnd();
                                    clearInterval(interval);
                                }, 100);
                        } else  {
                            me.showMaskUpgradeWnd();
                        }
                        
                    }
                });
                ExGods.Resources.load(wnd, function() {
                    var fn = function() {
                            ExGods.app.getController('Location').unmaskLocation();
                        },
                        mask;
                    wnd.show();
                    me.setUpgradeMaskQH();
                    if (config.clientAction && config.clientAction.options.mask_id) {
                        var ids = Ext.isArray(config.clientAction.options.mask_id) ? config.clientAction.options.mask_id : [
                                config.clientAction.options.mask_id
                            ],
                            i = ids.length;
                        while (i--) {
                            mask = me.store.findRecord('id', ids[i]);
                            if (mask)  {
                                break;
                            }
                            
                        }
                    }
                    if (!mask && !me.store.getCurrent()) {
                        mask = me.store.getAt(0);
                    }
                    if (mask) {
                        setTimeout(function() {
                            me.getTape().setActiveEl(mask, {
                                silent: true
                            });
                            me.fitMask(mask, fn);
                        }, 0);
                    } else  {
                        fn();
                    }
                    
                });
            });
        }, {
            img: me.maskImage
        });
        return wnd;
    },
    onMaskSelect: function(tape, dataview, record, index) {
        var me = this;
        me.fitMask(record);
    },
    onCentralWindowItemClick: function(centralwindow, record, dom) {
        var me = this;
        me.getTape().setActiveEl(record);
        me.fitMask(record);
    },
    /**
     * Xclicked - флаг, что кликнули на крестик
     */
    checkFitOnClose: function(Xclicked) {
        var me = this,
            prevent_close = false,
            closeWindow = function() {
                if (prevent_close)  {
                    return;
                }
                
                me.getTape().setActiveEl(me.store.getCurrent(), {
                    animate: true,
                    silent: true,
                    forced: true,
                    callback: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            Ext.getCmp('MASKS').close();
                        }, {
                            img: me.maskImage
                        });
                    }
                });
            };
        if (me.store.canFitAndUse(me.currentFitMask)) {
            //убираем стрелочку quest helpera когда открывается окно
            me.setBackInTownQH(false);
            if (Xclicked) {
                Ext.widget('confirmdialog', {
                    quest_helper_id: me.currentFitMask.get('id'),
                    quest_helper_type: 'room_mask',
                    message: ExGods.ref('message_client|check_on_fit_message'),
                    handler: function(btn) {
                        prevent_close = true;
                        me.putMask(function() {
                            prevent_close = false;
                            closeWindow();
                        });
                    },
                    listeners: {
                        close: closeWindow
                    }
                });
            } else {
                Ext.widget('confirmdialog', {
                    quest_helper_id: me.currentFitMask.get('id'),
                    quest_helper_type: 'room_mask',
                    message: ExGods.ref('message_client|check_on_fit_message_no_close'),
                    handler: function(btn) {
                        me.putMask();
                    }
                });
            }
        } else  {
            closeWindow();
        }
        
    },
    setBackInTownQH: function(enable) {
        var me = this,
            protectBtn = me.getBackInTown(),
            canFitAndUse = me.store.canFitAndUse(me.currentFitMask),
            closeText = me.cmp.closeText,
            fitText = me.cmp.fitText;
        if (protectBtn) {
            if (enable) {
                protectBtn.el.set({
                    'data-qh_otype': 'room_mask',
                    'data-qh_oid': me.currentFitMask.get('id')
                });
                protectBtn.setText(canFitAndUse ? fitText : closeText);
                protectBtn.fitEnabled = canFitAndUse;
            } else {
                protectBtn.el.set({
                    'data-qh_otype': 'empty'
                });
            }
        }
    },
    setUpgradeMaskQH: function() {
        var me = this,
            upgradeBtn = me.getUpgradeBtn();
        if (upgradeBtn && upgradeBtn.isVisible() && me.currentFitMask) {
            upgradeBtn.el.set({
                'data-qh_otype': 'room_mask_button_uluchshit',
                'data-qh_oid': me.currentFitMask.get('id')
            });
        }
    },
    fitMask: function(record, callback) {
        var me = this,
            tape = me.getTape();
        if (me.currentFitMask == record)  {
            return;
        }
        
        me.sendingFitRequest = true;
        me.service.command('fit_mask', {
            id: record.get('id'),
            item: record.get('item').entry
        }, function(resp) {
            //значит уже одеваем другую маску
            if (record != tape.getActiveEl())  {
                return;
            }
            
            var avtImg = ExGods.references.get('user_shape').getByKey(resp.fit.shape);
            ExGods.Resources.load({
                getResources: function() {
                    return {
                        images: [
                            avtImg.avatar
                        ]
                    };
                }
            }, function() {
                me.localUser.set({
                    stats: resp.fit,
                    shape: resp.fit.shape
                });
                me.currentFitMask = record;
                me.updateViews();
                me.sendingFitRequest = false;
                if (callback)  {
                    callback(resp);
                }
                
            });
        });
    },
    updateViews: function() {
        var me = this,
            record = me.currentFitMask,
            user = me.localUser,
            stats = user.get('stats'),
            centralwindow = me.getCentralWindowMasks(),
            userMaskStats = me.getUserMaskStats(),
            index;
        if (!userMaskStats) {
            return;
        }
        me.store.each(function(rec, i) {
            if (rec == record) {
                index = i;
            }
        });
        me.setQuestHelperVisibility(index);
        userMaskStats.updateUserStats(stats, record);
        me.getUserMaskStatsStars().updateUserStats(stats, record);
        if (centralwindow) {
            centralwindow.updateMasks();
            centralwindow.setMask(record);
        }
        me.setBackInTownQH(true);
        var upgradeBtn = me.getUpgradeBtn();
        if (upgradeBtn) {
            if (record.get('next_upgrade')) {
                if (record.get('next_enabled')) {
                    upgradeBtn.enable();
                } else {
                    upgradeBtn.disable();
                }
                upgradeBtn.show();
            } else {
                upgradeBtn.hide();
                upgradeBtn.disable();
            }
        }
        me.setUpgradeMaskQH();
    },
    showMaskUpgradeWnd: function() {
        var me = this,
            wnd;
        if (!me.currentFitMask.get('next_upgrade'))  {
            return;
        }
        
        //может возникнуть ошибка если при прокнутке на маску, 
        //которую нельзя улучшить, не успеет исчезнуть кнопка "улучшить"
        //от предыдущей маски
        var itemId = me.currentFitMask.get('next_upgrade').item.id;
        me.sendingFitRequest = true;
        me.service.command('fit_mask', {
            id: me.currentFitMask.get('id'),
            item: itemId
        }, function(resp) {
            me.sendingFitRequest = false;
            wnd = Ext.widget('window2', {
                autoShow: false,
                items: [
                    {
                        xtype: 'upgrademask',
                        localUser: me.localUser,
                        currentMask: me.store.getCurrent(),
                        currentFitMask: me.currentFitMask.data,
                        upgradeFitData: {
                            stats: resp.fit,
                            shape: resp.fit.shape
                        },
                        service: me.service
                    }
                ]
            });
            ExGods.Resources.load(wnd, function() {
                wnd.show();
            });
        });
    },
    setQuestHelperVisibility: function(index) {
        if (!ExGods.app.getQuestHelperController().room_mask)  {
            return;
        }
        
        var me = this,
            btn = Ext.get(Ext.select('.get_all_masks_btn').elements[0]),
            el, pointer_el;
        me.store.each(function(record) {
            el = Ext.get('maskid-' + record.get('id'));
            //если отрисована такая маска и она есть в квестовых указателях
            if (el && Ext.Array.indexOf(ExGods.app.getQuestHelperController().room_mask, record.get('id')) != -1) {
                if ([
                    index - 1,
                    index,
                    index + 1
                ].indexOf(record.index) != -1) {
                    el.removeCls('qh-off');
                    //маркера на элементе не будет видно
                    btn.removeCls('qh-object');
                    if (btn.el.down('.qh-pointer')) {
                        btn.el.down('.qh-pointer').hide();
                    }
                    if (el.down('.qh-pointer')) {
                        el.down('.qh-pointer').setVisible(record.index != index);
                    }
                } else {
                    el.addCls('qh-off');
                    //маркера на элементе будет видно
                    btn.addCls('qh-object');
                    btn.set({
                        'data-qh_otype': 'maskobject',
                        'data-qh_oid': record.get('id'),
                        'data-qh_opts': '{&quot;cls&quot;:&quot;flip-h&quot;}'
                    });
                    if (btn.el.down('.qh-pointer')) {
                        btn.el.down('.qh-pointer').show();
                    }
                }
            }
        });
    },
    putMask: function(cb) {
        var me = this,
            tapeCmp = me.getTape();
        me.service.command('put_on_mask', {
            id: me.currentFitMask.get('id'),
            item: me.currentFitMask.get('item').entry
        }, function(resp) {
            if (resp.success) {
                me.store.loadRawData(resp.masks);
                // Обновляем текущий активный элемент вьюшки тэйпа
                // чтобы прокрутка могла помнить какой элемент стора активен
                tapeCmp.activeEl = tapeCmp.store.getCurrent();
                me.localUser.set({
                    stats: ExGods.app.user.data.stats,
                    shape: ExGods.app.user.data.shape
                });
                me.updateViews();
            }
            if (cb)  {
                cb(resp);
            }
            
        });
    },
    buyMask: function() {
        var me = this;
        Ext.widget('confirmdialog', {
            message: new Ext.Template(ExGods.ref('message_client|buy_mask')).apply({
                cost: ExGods.util.Format.printMoney(me.currentFitMask.data.item_price['new'])
            }),
            handler: function() {
                me.service.command('buy_mask', {
                    id: me.currentFitMask.get('id')
                }, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.currentFitMask.set('has', 1);
                    me.currentFitMask.calcGroupDur();
                    me.updateViews();
                });
            }
        });
    },
    onUpgrade: function(params, startCallback) {
        var me = this,
            curMask = me.currentFitMask.data;
        Ext.widget('confirmdialog', {
            message: ExGods.app.applyTpl(ExGods.ref('message_client|upgrade_mask')),
            handler: function() {
                var upgraded_mask,
                    wnd = me.getUpgradeMaskWnd(),
                    data = wnd.upgradeFitData,
                    avatar = Ext.getCmp('MASKS').down('maskavatar'),
                    spriteSheet = startCallback();
                params.btn.disable();
                delete params.btn;
                me.service.command('upgrade_mask', params, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    ExGods.helpme.loadProtos(resp.masks, 'item', function() {
                        me.store.loadRawData(resp.masks);
                        upgraded_mask = me.store.findRecord('id', me.currentFitMask.get('id'));
                        var callback = function() {
                                setTimeout(function() {
                                    me.currentFitMask = upgraded_mask;
                                    avatar.nextAnimated = true;
                                    me.localUser.set(data);
                                    if (me.store.getCurrent() == me.currentFitMask) {
                                        me.user.set(data);
                                    }
                                    me.updateViews();
                                    if (wnd.up())  {
                                        wnd.up().close();
                                    }
                                    
                                }, ExGods.ref('constants|upgrade_mask_animation_delay').value);
                            };
                        if (spriteSheet.inProgress) {
                            spriteSheet.finish = callback;
                        } else  {
                            callback();
                        }
                        
                    });
                });
            }
        });
    }
});

/**
 * Управление локацией, соседними локациями, списком ботов в локации и пользователей в чате.
 */
Ext.define('ExGods.controller.OnlineList', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'OnlineList:'
    },
    models: [
        'BasicUser'
    ],
    refs: [
        {
            /**
             * @method getChatList
             * Возвращает отображение списка контактов в чате
             * @return {Ext.view.View}
             */
            ref: 'chatList',
            selector: '#chat-contact-list'
        }
    ],
    /**
     * @property {ExGodsCore.model.Location} location
     * Текущая локация
     */
    /**
     * @property {ExGods.store.Locations} locations
     * Хранилище локаций
     */
    /**
     * @property {Ext.container.Container} locationContainer
     * Контейнер, в котором находится сама локация, список соседних и список ботов
     */
    /**
     * @property {ExGods.model.World} world
     * Текущий мир
     */
    /**
     * @property {ExGods.store.Users} worldOnlineStore
     * Хранилище онлайн пользователей во всем мире
     */
    init: function(app) {
        var me = this,
            user = me.getUser();
        me.chatContacts = app.getChatContactsStore();
        me.control({
            '#chat-tab-panel': {
                tabchange: me.onChatTabChange
            }
        });
        // переключение вкладок чата
        //      user.on({
        //          worldchanged: me.onWorldChanged,
        //          scope: me
        //      });
        user.location.on({
            idchanged: me.onLocationIdChanged,
            scope: me
        });
        // каждые 15 секунд обновляем список пользователей
        me.onlineListTask = {
            interval: 15 * 1000,
            run: me.getOnlineList,
            stopped: true,
            scope: me
        };
        Ext.TaskManager.start(me.onlineListTask);
    },
    //      me.worldOnlineStore = Ext.create('ExGodsCore.store.ChatContacts', {
    //          proxy: {
    //              type: 'ajax',
    //              url: '/online_list/w/' + me.getWorld().get('entry') + '/',
    //
    //              reader: {
    //                  type: 'json',
    //                  root: 'user_list'
    //              },
    //
    //              limitParam: false,
    //              pageParam: false,
    //              startParam: false,
    //              sortParam: false
    //          }
    //      });
    // каждые 15 секунд обновляем список пользователей в мире
    //      me.worldOnlineTask = Ext.TaskManager.newTask({
    //          interval: 15 * 1000,
    //          fireOnStart: true,
    //          run: function(store, user) {
    //
    //              me.scroller.catchPosition();
    //              debugger
    //
    //              store.load({
    //                  url: '/online_list/w/' + user.getWorld() + '/'
    //              });
    //
    //              setTimeout(function(){
    //                  me.updateLayout();
    //                  me.scroller.restorePosition();
    //              },0);
    //
    //          },
    //          args: [me.worldOnlineStore, user]
    //      });
    /**
     * @private
     * Обрабатывает смену вкладок чата. Включает/выключает поел вводи и
     * кнопку отправки
     */
    onChatTabChange: function(tabPanel, newCard) {
        var me = this,
            chatList = me.getChatList();
        if (newCard.channelType.world) {}
        //chatList.bindStore(me.worldOnlineStore);
        else if (newCard.channelType.battle) {
            chatList.bindStore(ExGods.app.getController('battle.BattleView').allies);
        } else if (newCard.channelType.location || newCard.channelType.group) {
            chatList.bindStore(me.chatContacts);
        }
    },
    //      if (newCard.channelType.world) {
    //          //me.worldOnlineTask.start();
    //      } else {
    //          me.worldOnlineTask.stop();
    //      }
    /**
     * @private Обработчик изменения ID локации
     */
    onLocationIdChanged: function() {
        var me = this;
        if (me.onlineListTask.stopped) {
            /***/
            me.log('Запускаю обновлялку онлайн-листа');
            Ext.TaskManager.start(me.onlineListTask);
        } else {
            /***/
            me.log('ID локации изменилось - обновляю онлайн-лист');
            me.getOnlineList();
        }
    },
    onWorldChanged: function() {
        var me = this;
    },
    //      if (!me.worldOnlineTask.stopped) {
    //          me.worldOnlineTask.restart();
    //      }
    /**
     * Получает список пользователей/ботов/NPC в локации
     * В данных по онлайн списка может присутствовать ключ next
     * это означает что список не полный и необходимо подгрузить остаток по ключу
     * который идентичен оригинальному но номер комнаты расширен -<next>
     * 
     * например при получении списка /online_list/6/ вернуло 
     * {
     * success => 1,
     * user_list => [..],
     * next => 1,
     * }
     * необходимо получить следующую часть по урлу /online_list/6-1/
     * в котором также может быть поле next, если его нет, то эта часть последняя
     */
    getOnlineList: function(cnt, next_part) {
        var me = this,
            user = me.getUser(),
            chat_room_name = user.location.get('chat_room_name');
        if (next_part) {
            chat_room_name += '-' + next_part;
        }
        me.request({
            url: '/online_list/' + chat_room_name + '/',
            method: 'GET',
            queue: false,
            success: function(result) {
                var userList = result.user_list,
                    users = me.getBasicUserModel().proxy.reader.read(userList).records,
                    chatContacts = [],
                    type, user, i;
                for (i = 0; i < users.length; i++) {
                    user = users[i];
                    type = user.getType();
                    if (type == 'user') {
                        chatContacts.push(user);
                    }
                }
                me.getChatList().scroller.catchPosition();
                //me.chatContacts.removeAll();
                me.chatContacts.loadData(chatContacts, Boolean(next_part));
                me.getChatList().scroller.restorePosition();
                if (result.next_part) {
                    me.getOnlineList(0, result.next_part);
                }
            }
        });
    }
});

/**
 * Управляет лоадером начальной загрузки приложения
 */
Ext.define('ExGods.controller.Preloader', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'PreloaderCtrl:'
    },
    /**
     * Вернет объект лоадера. После загрузки объект уничтожается, так что проверяйте на null
     */
    getLoaderObject: function() {
        return exGodsLoader;
    },
    init: function() {
        var me = this;
        me.app.on({
            gamestarted: function() {
                this.setProgress([
                    82,
                    99
                ], 'старт игры', 400);
            },
            scope: me
        });
        me.app.getChatConnection().on({
            beforeconnect: me.setProgress.bind(me, [
                40,
                53
            ], 'перед коннекцией к чату', 400),
            connect: me.setProgress.bind(me, [
                53,
                71
            ], 'коннект к чату', 400),
            presenceinit: me.setProgress.bind(me, [
                71,
                82
            ], 'присутствие чата подтверждено сервером', 400),
            scope: me
        });
    },
    /**
     * @private Выставляет процент загрузки лоадера
     * @param {Array} percents Процент загрузки от-до
     * @param {String} msg Сообщение для дебага
     * @param {Number} animationSpeed Скорость тика лоадера
     */
    setProgress: function(percents, msg, animationSpeed) {
        var me = this,
            loader = me.getLoaderObject();
        if (loader) {
            if (msg) {
                /***/
                me.log('info', msg + ' - ' + percents.join(' - ') + '%');
            }
            if (animationSpeed) {
                loader.animationSpeed = animationSpeed;
            }
            loader.setPercentage(percents[0], percents[1]);
        }
    }
});

/**
 * Панель с заголовком рейтинга
 */
Ext.define('ExGods.view.ratings.TitlePanel', {
    extend: Ext.panel.Panel,
    alias: 'widget.ratings_title',
    plugins: [
        'paperdeco'
    ],
    height: 100,
    cls: 'title',
    /**
     * @cfg Данные рейтинга
     */
    rating: {},
    initComponent: function() {
        var me = this,
            btnText = me.rating.action;
        me.user = ExGods.app.user;
        me.items = [
            {
                layout: {
                    type: 'hbox'
                },
                items: [
                    {
                        xtype: 'panel',
                        flex: 1,
                        tpl: [
                            '<div class="exg-share-base-info" style="background-image: url({[ this.getUserImage(values.user) ]})">',
                            '<span>{[ ExGods.printUser(values.user, {fields: "name,level"})]}</span>',
                            '<span>',
                            '<tpl if="rating.rank">',
                            '<strong>{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('rating_place') + '",{place:values.rating.rank})]} </strong>',
                            '{[this.printValue(values.rating)]}',
                            '<tpl else>',
                            '<strong>' + ExGods.ref('message_client|ratings_no_rank') + '</strong>',
                            '</tpl>',
                            '</span>',
                            '<span>{rating.description}</span>',
                            '<div class="image-frame"></div>',
                            '</div>',
                            {
                                getUserImage: function(user) {
                                    return ExGods.ref('user_shape|' + user.shape).thumb;
                                },
                                printValue: function(rating) {
                                    if (rating.value || rating.value === 0) {
                                        return '(<span class="rating-value" style="background-image: url(' + IMAGE_URL + rating.value_image + ')">' + rating.value + '</span>)';
                                    } else  {
                                        return '';
                                    }
                                    
                                }
                            }
                        ],
                        data: {
                            user: me.user.data,
                            rating: me.rating
                        }
                    },
                    {
                        xtype: 'textbutton',
                        cls: 'no_border_double x-btn-txt-green',
                        text: btnText.length <= 18 ? btnText : '<span style="white-space: normal; line-height: 11px; display: block;">' + btnText + '</span>',
                        width: 150,
                        margin: '30 30 0 0',
                        handler: function() {
                            me.fireEvent('do_action');
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                ExGods.ref('user_shape|' + me.user.data.shape).thumb,
                IMAGE_URL + me.rating.value_image,
                IMAGE_URL + 'btn_green_high.png',
                IMAGE_URL + 'icons/level.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Список рейтинга
 */
Ext.define('ExGods.view.ratings.List', {
    extend: Ext.panel.Panel,
    alias: 'widget.ratings_list',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'ratings-list',
    itemsPerPage: 7,
    textFilter: '',
    /**
     * @cfg {Array} rating Рейтинг
     */
    rating: {},
    height: 266,
    initComponent: function() {
        var me = this;
        // сортирую по ранку
        me.list = Ext.Array.sort(me.rating.top_list ? me.rating.top_list.data.ranks : [], function(a, b) {
            return a.rank - b.rank;
        });
        me.items = [
            {
                xtype: 'container',
                plugins: [
                    'paperdeco'
                ],
                height: 240,
                padding: '0 0 10 0',
                items: [
                    {
                        itemId: 'list',
                        tpl: [
                            '<tpl if="list.length">',
                            '<table class="list">',
                            '<tpl for="list">',
                            '<tr class="{[ xindex % 2 ? "exg-share-bg-light" : "exg-share-bg-dark" ]}">',
                            '<td class="place-cell">',
                            '<tpl if="rank &gt;= 1 && rank &lt;= 3">',
                            '<div class="place-{rank}"><img width="76" height="24" src="{[ this.getPlaceImage(values.rank) ]}"></div>',
                            '<tpl else>',
                            '<span>{[this.printPlace(values.rank)]}</span>',
                            '</tpl>',
                            '</td>',
                            '<td class="username-cell">',
                            '{[ ExGods.printUser(values.info, {fields: "name,rank,level,infoicon,guild"}) ]}',
                            '</td>',
                            '<td class="count-cell">',
                            '{[this.printValue(values.value)]}',
                            '</td>',
                            '</tr>',
                            '</tpl>',
                            '</table>',
                            '<tpl else>',
                            '<div class="empty-msg">' + ExGods.ref('message_client|ratings_empty_list') + '</div>',
                            '</tpl>',
                            {
                                printValue: function(value) {
                                    if (value || value === 0) {
                                        return '<span class="rating-value" style="background-image: url(' + IMAGE_URL + me.rating.value_image + ')">' + value + '</span>';
                                    } else  {
                                        return '';
                                    }
                                    
                                },
                                getPlaceImage: function(rank) {
                                    return ExGods.ref('images|rating_place_icons').image['place' + rank];
                                },
                                printPlace: function(place) {
                                    return ExGods.util.Sprite.printSprite(place, 'arena/place_numbers.png', {
                                        width: 10,
                                        height: 24,
                                        indent: '-5px',
                                        cls: 'inlineblock'
                                    }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                                }
                            }
                        ],
                        data: {
                            list: me.list.slice(0, me.itemsPerPage)
                        }
                    }
                ]
            }
        ];
        me.plugins = me.plugins || [];
        me.plugins.push({
            ptype: 'pager',
            marginLeft: -27,
            marginRight: -27,
            top: 84,
            textTop: -24,
            textLeft: 326,
            total: Math.ceil(me.list.length / me.itemsPerPage)
        });
        me.listeners = {
            prev: me.updateList,
            next: me.updateList,
            scope: me
        };
        me.callParent();
    },
    updateList: function() {
        var me = this,
            items = me.filtered || me.list;
        items = items.slice((me.pager.current - 1) * me.itemsPerPage, me.pager.current * me.itemsPerPage);
        me.items.items[0].getComponent('list').update({
            arena: me.arena,
            list: items
        });
        me.pager.refresh();
    },
    setTextFilter: function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        if (me.textFilter) {
            me.filtered = Ext.Array.filter(me.list, function(item) {
                return (item.info.display_title).toLowerCase().indexOf(me.textFilter) != -1;
            });
            me.pager.total = Math.ceil(me.filtered.length / me.itemsPerPage);
        } else {
            delete me.filtered;
            me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        }
        me.pager.current = 1;
        me.updateList();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        arr_images.concat(ExGods.ref('images|rating_place_icons').image);
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Контроллер рейтингов
 *
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.Ratings', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: true,
            error: true
        },
        prefix: 'Ratings:'
    },
    views: [
        'ExGods.view.ratings.TitlePanel',
        'ExGods.view.ratings.List'
    ],
    init: function() {
        var me = this;
        me.control({});
        //
        ExGods.Components.addComponentInitializer('ratings', me.initRatingsComponent, me);
    },
    initRatingsComponent: function(config) {
        var me = this,
            win = Ext.getCmp('RATINGS'),
            tabs = [];
        me.service = config.service;
        ExGods.app.block();
        Ext.Array.each(me.service.data.ratings, function(data) {
            tabs.push({
                tabConfig: {
                    xtype: 'skintab',
                    icon: IMAGE_URL + data.tab_image,
                    tooltip: data.description
                },
                items: [
                    {
                        xtype: 'ratings_title',
                        rating: data,
                        listeners: {
                            do_action: function() {
                                me.doRatingAction(data);
                                win.close();
                            }
                        }
                    },
                    {
                        xtype: 'ratings_list',
                        rating: data
                    }
                ]
            });
        });
        if (win)  {
            win.close();
        }
        
        win = Ext.widget('window2', {
            id: "RATINGS",
            autoShow: false,
            items: [
                {
                    layout: 'absolute',
                    items: [
                        {
                            xtype: 'skintabpanel',
                            tabUi: 'skintext',
                            items: tabs,
                            bodyPadding: '1 11 0 9',
                            cls: 'ratings',
                            listeners: {
                                tabchange: me.onTabChange
                            }
                        },
                        {
                            xtype: 'textfield',
                            x: 606,
                            y: 11,
                            width: 132,
                            height: 21,
                            style: {
                                'z-index': 1
                            },
                            emptyText: ExGods.ref('message_client|ratings_search_placeholder'),
                            itemId: 'text-search',
                            cls: 'text-search-input',
                            listeners: {
                                change: me.filterBySearch,
                                scope: me
                            },
                            value: ''
                        }
                    ]
                }
            ],
            /**
             * Ресурсы вью предзагрузка
             */
            getResources: function() {
                var arr_images = [];
                Ext.Array.each(me.service.data.ratings, function(data) {
                    arr_images.push(data.tab_image);
                });
                return {
                    images: [].concat(arr_images)
                };
            }
        });
        ExGods.Resources.load(win, function() {
            win.show();
            ExGods.app.unblock();
        });
        return win;
    },
    filterBySearch: function(searchField) {
        var me = this,
            str = searchField.getValue(),
            list = Ext.getCmp('RATINGS').down('skintabpanel').getLayout().getActiveItem().down('ratings_list');
        if (list.setTextFilter) {
            list.setTextFilter(str);
        }
    },
    onTabChange: function(tabPanel, newCard, oldCard) {
        var me = this,
            searchField = tabPanel.up().down('#text-search'),
            listNew = newCard.down('ratings_list'),
            listOld = oldCard.down('ratings_list');
        searchField.setValue('');
        listNew.setTextFilter('');
        listNew.pager.hidden = 0;
        listNew.pager.refresh();
        listOld.pager.hidden = 1;
        listOld.pager.refresh();
    },
    doRatingAction: function(ratingData) {
        var me = this;
        me.service.command('ratings_map_action', {
            id: ratingData.id,
            tag: ratingData.tag,
            period: ratingData.period
        });
    }
});

/**
 * Модель грабежа 
 */
Ext.define('ExGods.model.Robbery', {
    extend: Ext.data.Model,
    requesting: false,
    fields: [
        {
            // флаг возможности найти кого грабить. Пока не обрабатывать.
            name: 'can_request',
            type: 'int'
        },
        {
            // флаг возможности начать бой. Пока не обрабатывать.
            name: 'can_start',
            type: 'int'
        },
        {
            //флаг возможности отменить поиск
            name: 'can_reject',
            type: 'int'
        },
        {
            // время ожидания противника
            name: 'to_request',
            type: 'int'
        },
        {
            // время старта ожидания противника
            name: 'time_request',
            type: 'auto',
            convert: function(v, rec) {
                if (v) {
                    v = ExGods.util.Date.normalizeUnixTime(v);
                }
                return v;
            }
        },
        {
            //время ожидания решения по бою
            name: 'to_assign',
            type: 'int'
        },
        {
            // время старта ожидания решения по бою
            name: 'time_assign',
            type: 'auto',
            convert: function(v, rec) {
                if (v) {
                    v = ExGods.util.Date.normalizeUnixTime(v);
                }
                return v;
            }
        },
        {
            // список противников кому мстить
            name: 'foe_list',
            type: 'auto',
            convert: function(v, rec) {
                /*** test ***/
                // for(var i = 0; i < 21; i++){
                //  var q = Ext.clone(v[0]);
                //  q.display_title += i;
                //  v.push(q);
                // }
                /*** end test ***/
                ExGods.app.getStore('RobberyFoe').loadRawData(v);
                return v;
            }
        },
        {
            //список целей для грабежа
            name: 'list',
            type: 'auto',
            convert: function(v, rec) {
                //пока мы находим только 1 противника - переделываю массив в хеш из первого элемента
                return v ? v[0] : v;
            }
        },
        {
            //количество попыток поставиться в очередь, видимо
            name: 'count',
            type: 'int'
        },
        {
            //требуемое имущество для еначала поиска
            name: 'request_stuff',
            type: 'auto',
            defaultValue: ''
        },
        {
            //гарантированная награда за грабеж
            name: 'reward',
            type: 'auto',
            defaultValue: ''
        },
        {
            //требуемое имущество для реролла
            name: 'next_stuff',
            type: 'auto',
            defaultValue: ''
        },
        {
            //описание грабежа и маски
            name: 'desc',
            type: 'auto',
            defaultValue: ''
        }
    ]
});

/**
 * Отображение конкретного врага на арене
 */
Ext.define('ExGods.view.robbery.Foe', {
    extend: Ext.panel.Panel,
    alias: 'widget.robbery_foe',
    cls: 'enemy-info',
    plugins: [
        'paperdeco'
    ],
    height: 284,
    width: 188,
    padding: '0 10',
    initComponent: function() {
        var me = this;
        me.data = me.record.data;
        if (me.data.reward)  {
            me.data.reward.splice(2, me.data.reward.length - 1);
        }
        
        me.tpl = [
            '<div class="paper-title title">',
            '<h4>{[ExGods.ref("message_client|robbery_foe_title")]}</h4>',
            '</div>',
            '<div class="exg-share-base-info exg-share-bg-light gender-{gender}" style="background-image: url({shape})">',
            '<span>{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank", maxNameWidth: 84})]}</span>',
            '<span>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {hoard.level}</span>',
            '<tpl if="reward_extra">',
            '<span class="top_sto">{[ExGods.ref("message_client|robbery_topsto")]}</span>',
            '<div class="topsto_icon"></div>',
            '</tpl>',
            '<div class="image-frame"></div>',
            '</div>',
            '<div class="paper-separator"></div>',
            '<h5 class="exg-share-bg-dark">' + ExGods.getMsgByKey('view_battle_rewards_rewardstitle') + '</h5>',
            '<div class="foe-reward">',
            '<tpl if="reward">',
            '{[ExGods.stuff.StuffManager.image(values.reward_extra ? values.reward.concat(values.reward_extra) : values.reward)]}',
            '<tpl elseif="reward_extra">',
            '{[ExGods.stuff.StuffManager.image(values.reward_extra)]}',
            '<tpl else>',
            '{[ExGods.ref("message_client|robbery_empty_foe_reward")]}',
            '</tpl>',
            '</div>'
        ];
        me.dockedItems = [
            {
                dock: 'bottom',
                xtype: 'textbutton',
                text: ExGods.getMsgByKey('view_robbery_revenge'),
                cls: 'x-btn-txt-red no_border_double',
                margin: '0 25 35 25',
                action: 'robbery_revenge',
                itemId: 'revenge',
                can_revenge: !!me.data.online,
                disabled: !me.data.online,
                user_title: me.data.display_title
            }
        ];
        me.callParent(arguments);
    },
    getResources: function() {
        return {
            images: [
                this.record.get('shape')
            ]
        };
    }
});

/**
 * Список врагов на арене
 */
Ext.define('ExGods.view.robbery.EnemyList', {
    extend: Ext.container.Container,
    alias: 'widget.robbery_enemylist',
    layout: 'hbox',
    cls: 'robbery enemy-list',
    padding: '0 8 0 8',
    itemsPerPage: 3,
    textFilter: '',
    initComponent: function() {
        var me = this;
        me.store = ExGods.app.getStore('RobberyFoe');
        me.store.on('filterchange', me.renderFoes, me);
        me.plugins = [
            {
                ptype: 'pager',
                marginLeft: -31,
                marginRight: -31,
                top: 127,
                textTop: -32,
                textLeft: 235,
                hidden: me.store.getCount() > me.itemsPerPage ? 0 : 1,
                total: Math.ceil(me.store.getCount() / me.itemsPerPage)
            }
        ];
        me.listeners = {
            prev: me.setPagerFilter,
            next: me.setPagerFilter,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.setPagerFilter();
    },
    setPagerFilter: function() {
        var me = this,
            curPage = me.pager.current;
        me.store.removeFilter('pager');
        me.store.addFilter(Ext.util.Filter({
            filterFn: function(item) {
                var i = me.store.indexOf(item);
                //item.index не работает, т.к. после отмены фильтрации index почему-то не перезаписывается
                return i >= (curPage - 1) * me.itemsPerPage && i < curPage * me.itemsPerPage;
            },
            id: 'pager'
        }));
    },
    onDestroy: function() {
        var me = this;
        me.store.removeFilter('pager');
        me.callParent(arguments);
    },
    renderFoes: Ext.Function.createBuffered(function() {
        var me = this;
        me.removeAll();
        me.store.each(function(el) {
            me.add(Ext.widget('robbery_foe', {
                record: el
            }));
        });
        if (!me.store.getTotalCount()) {
            me.add(Ext.widget('panel', {
                width: '100%',
                height: '100%',
                html: '<div class="robbery-foe-empty">' + ExGods.ref('message_client|robbery_foe_empty_text') + '</div>'
            }));
        }
        me.pager.hidden = me.pager.total > 1 ? 0 : 1;
        me.pager.refresh();
    }, 200),
    setTextFilter: Ext.Function.createBuffered(function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        me.store.removeFilter('pager');
        if (me.textFilter) {
            me.store.removeFilter('pager');
            me.store.addFilter(Ext.util.Filter({
                filterFn: function(item) {
                    return item.get('display_title').toLowerCase().indexOf(me.textFilter) != -1;
                },
                id: 'text'
            }));
        } else {
            me.store.removeFilter('text');
        }
        me.pager.total = Math.ceil(me.store.getCount() / me.itemsPerPage);
        me.pager.current = 1;
    }, 500),
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Модель врага в списке врагов грабежей 
 */
Ext.define('ExGods.model.RobberyFoe', {
    extend: Ext.data.Model,
    fields: [
        {
            // Время добавления во враги
            name: 'add_time',
            type: 'string'
        },
        {
            // Месторасположение врага
            name: 'binding',
            type: 'auto'
        },
        {
            // Ник
            name: 'display_title',
            type: 'string'
        },
        {
            // Пол
            name: 'gender',
            type: 'string'
        },
        {
            // Накопительные
            name: 'hoard',
            type: 'auto'
        },
        {
            // Флаг онлайн
            name: 'online',
            type: 'int'
        },
        {
            // Раса
            name: 'race',
            type: 'string'
        },
        {
            // Список наград за отмщение
            name: 'reward',
            type: 'auto'
        },
        {
            // Дополнительные награды за отмщение
            name: 'reward_extra',
            type: 'auto'
        },
        {
            // Картинка
            name: 'shape',
            type: 'string',
            convert: function(v, rec) {
                var shape = ExGods.ref('user_shape|' + v);
                return shape ? shape.thumb : v;
            }
        }
    ]
});

/**
 * Арена - показывает правила арены и позволяет подобрать себе врага
 */
Ext.define('ExGods.view.robbery.EnemyInfo', {
    extend: Ext.panel.Panel,
    alias: 'widget.robbery_enemy',
    initComponent: function() {
        var me = this;
        me.data = me.config.data;
        me.groupLoot();
        me.data.list.loot = me.loot;
        ExGods.helpme.loadProtos(me.loot, 'params.id', function() {
            me.protosLoaded = true;
            me.addLoot();
        });
        me.tpl = [
            //лутинфо сначала, потому что float:right, чтобы в информации о противнике отобразить сепараторы выше вертикального сепаратора
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="robbery-enemy">',
            '<div class="loot-info">',
            '<div class="paper-title title">',
            '<h4>{[ExGods.ref("message_client|robbery_rewards_title")]}</h4>',
            '</div>',
            '<p class="description exg-share-bg-light">{[ExGods.ref("message_client|robbery_enemy_desc")]}</p>',
            '<div class="loot exg-share-bg-dark">{[ExGods.stuff.StuffManager.image(values.reward || [])]}</div>',
            '<div class="exg-share-bg-dark" id="robbery-text-buttons"></div>',
            '</div>',
            '<div class="v-separator"></div>',
            '<div class="enemy">',
            '<div class="paper-title title">',
            '<h4>{[ExGods.ref("message_client|robbery_enemy_title")]}</h4>',
            '</div>',
            '<div class="exg-share-base-info exg-share-bg-light" style="background-image: url({[ this.getUserImage(values.list) ]})">',
            '<span>{[ ExGods.printUser(values.list, {fields: "name,rank", maxNameWidth: 112})]}</span>',
            '<span>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {list.hoard.level}</span>',
            '<div class="image-frame"></div>',
            '</div>',
            '<div class="paper-separator"></div>',
            '<h5 class="exg-share-bg-dark">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</h5>',
            '<div class="stats1 exg-share-bg-light">',
            '{[ ExGods.util.User.printUserStats(values.list.stats.stats, {visibleValue: 1, align: "right", changes: this.getStatsChanges(values.list.stats.stats)}) ]}',
            '</div>',
            '<div class="paper-separator"></div>',
            '<h5 class="exg-share-bg-dark">{[this.getMask(values.list.mask_proto_id)]}</h5>',
            '<div class="stats2 exg-share-bg-light">',
            '{[ ExGods.util.User.printUserStats(values.list.stats.stats, {visibleValue: 2, changes: this.getStatsChanges(values.list.stats.stats)}) ]}',
            '</div>',
            '</div>',
            '</div>',
            {
                getMask: function(proto_id) {
                    var proto = ExGods.app.getItemPrototypesStore().findRecord('entry', proto_id);
                    if (proto)  {
                        return proto.get('title');
                    }
                    
                },
                getUserImage: function(data) {
                    return ExGods.ref('user_shape|' + data.shape).thumb;
                },
                getStatsChanges: function(stats) {
                    // вернёт разницу в статах
                    var changes = {},
                        myStats = ExGods.app.user.get('stats').stats;
                    Ext.Object.each(stats, function(k, v) {
                        if (typeof myStats[k] != 'undefined') {
                            changes[k] = v - myStats[k];
                        }
                    });
                    return changes;
                }
            }
        ];
        me.callParent();
    },
    groupLoot: function(data) {
        var me = this,
            loot = {};
        data = data || me.data;
        me.loot = [];
        me.protosLoaded = false;
        Ext.Array.each(data.list.loot, function(item) {
            if (loot[item.proto_id]) {
                loot[item.proto_id].params.quantity++;
            } else {
                loot[item.proto_id] = {
                    params: {
                        id: item.proto_id,
                        quantity: 1
                    },
                    item: item,
                    type: 'item'
                };
            }
        });
        Ext.Object.each(loot, function(k, v) {
            me.loot.push(v);
        });
    },
    afterRender: function() {
        var me = this;
        me.renderButtons();
        me.addLoot();
        me.callParent(arguments);
    },
    //ExGods.util.Ticker.addListener(me.updateAssignTime, me);
    addLoot: function() {
        var me = this;
        if (!me.protosLoaded || !me.rendered)  {
            return;
        }
        
        var loot = (me.loot.length || me.robbery.get('reward').length) ? ExGods.stuff.StuffManager.image((me.robbery.get('reward') || []).concat(me.loot)) : '<div class="robbery-enemy-empty">' + ExGods.ref('message_client|robbery_enemy_empty_reward') + '</div>';
        me.el.down('.loot').dom.innerHTML = loot;
    },
    renderButtons: function() {
        var me = this,
            time_assign = me.robbery.get('time_assign'),
            to_assign = me.robbery.get('to_assign'),
            time = Math.max(0, to_assign * 1000 - (Date.now() - time_assign)),
            stuff = me.robbery.get('next_stuff').stuff,
            fn = function() {
                me.accept_task.disable();
                me.decline_task.disable();
            };
        var cfg = [
                {
                    text: ExGods.getMsgByKey('view_robbery_startbattle'),
                    // через <span id="robbery-assign-time">'+ExGods.util.Time.printTime(time/1000, {format: 'detailed', emptyText: '..'})+'</span>',
                    cls: 'qh-object x-btn-txt-red no_border_double',
                    itemId: 'accept_task',
                    width: 160,
                    renderTo: 'robbery-text-buttons',
                    listeners: {
                        click: fn
                    }
                },
                {
                    text: ExGods.getMsgByKey('view_robbery_newsearch') + ' ' + ExGods.util.Stuff.printStuff(stuff),
                    disabled: !ExGods.app.getUser().checkStuff(stuff),
                    cls: 'no_border_double',
                    itemId: 'decline_task',
                    width: 160,
                    style: {
                        'float': 'right'
                    },
                    renderTo: 'robbery-text-buttons',
                    listeners: {
                        click: fn
                    }
                }
            ];
        Ext.Array.each(cfg, function(params) {
            me[params.itemId] = Ext.widget('textbutton', params);
            me[params.itemId].el.set({
                'data-qh_otype': 'robbery_button_battle',
                'data-qh_oid': '1'
            });
        });
    },
    updateAssignTime: function() {
        var me = this,
            time_assign = me.robbery.get('time_assign'),
            to_assign = me.robbery.get('to_assign'),
            time = Math.max(0, to_assign * 1000 - (Date.now() - time_assign));
        try {
            me.el.down('#robbery-assign-time').setHTML(ExGods.util.Time.printTime(time / 1000, {
                format: 'detailed',
                emptyText: '..'
            }));
        } catch (e) {}
        
    },
    onDestroy: function() {
        var me = this;
        //ExGods.util.Ticker.removeListener(me.updateAssignTime);
        me.callParent(arguments);
    },
    updateData: function(data) {
        var me = this;
        me.groupLoot(data);
        data.list.loot = me.loot;
        me.update(data);
        me.renderButtons();
        ExGods.helpme.loadProtos(me.loot, 'params.id', function() {
            me.protosLoaded = true;
            me.addLoot();
        });
    }
});

/**
 * Грабежи - показывает правила грабежей и позволяет подобрать себе врага
 */
Ext.define('ExGods.view.robbery.Search', {
    extend: Ext.panel.Panel,
    alias: 'widget.robbery_search',
    cls: 'robbery-search',
    loading: false,
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser();
        var masksTpl = [
                '<div class="masks-tpl">',
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title title">',
                '<h4>{desc.title}</h4>',
                '</div>',
                '<p class="description">{desc.desc}</p>',
                '<div class="masks-container exg-share-bg-dark">',
                '<div class="masks">{[this.printMasks(values.desc.masks)]}</div>',
                '</div>',
                '</div>'
            ];
        var searchTpl = [
                '<div class="search-tpl">',
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<tpl if="time_request">',
                '<div class="robbery-nums"><div class="nums">{[this.printQueueNums(values)]}</div></div>',
                '<div class="robbery-queue">',
                '<div class="robbery-timer" style="width:{[this.printQueueTime(values)]}px"></div>',
                '</div>',
                '<tpl else>',
                '<div class="first-page-text">{[ExGods.ref("message_client|robbery_first_page")]}</div>',
                '</tpl>',
                '</div>',
                '<div class="timed-place" id="timed-place"></div>'
            ];
        var tplFunctions = [
                {
                    printQueueNums: function(data) {
                        var to_request = parseInt(data.to_request, 10),
                            time = Math.max(0, to_request * 1000 - (Date.now() - data.time_request)) / 1000;
                        return ExGods.util.Time.printTime(time, {
                            format: 'bignums'
                        });
                    },
                    printQueueTime: function(data) {
                        var to_request = parseInt(data.to_request, 10),
                            time = Math.max(0, to_request * 1000 - (Date.now() - data.time_request)) / 1000,
                            percent = time / to_request;
                        return data.time_request ? Math.round((1 - percent) * 232) : 0;
                    },
                    //return ExGods.util.Time.printTime(time, {format: 'detailed', emptyText: '..'})
                    printMasks: function(masks) {
                        var masksHtmls = [],
                            store = ExGods.app.getItemPrototypesStore();
                        Ext.Array.each(masks, function(mask) {
                            var proto = store.findRecord('entry', mask.params.id);
                            masksHtmls.push('<div class="info-box-itembox item exgtip" data-proto_id="' + mask.params.id + '" data-exgtip_type="proto_item" data-exgtip_value="' + mask.params.id + '" id="maskid_' + mask.params.id + '">' + '<div class="mask_frm"></div>' + '<img class="image on" src="' + proto.get('images').on + '" width="50" height="50">' + '<div class="notify_i"></div>' + '<div class="x-clear"></div>' + '</div>');
                        });
                        return masksHtmls.join('<div class="arrow"></div>');
                    },
                    printTimed: function(request_stuff) {
                        var type;
                        Ext.Array.each(request_stuff, function(item) {
                            if (item.type == 'timed')  {
                                type = item.params.id;
                            }
                            
                        });
                        var timed = ExGods.app.user.get('timed')[type],
                            time = timed ? timed[3] : undefined;
                        if (!time)  {
                            return '';
                        }
                        
                        time = new Date(time) - new Date();
                        return ExGods.util.Time.printTime(time / 1000, {
                            format: 'threenums'
                        });
                    },
                    checkOpacity: function(request_stuff) {
                        var type;
                        Ext.Array.each(request_stuff, function(item) {
                            if (item.type == 'timed')  {
                                type = item.params.id;
                            }
                            
                        });
                        var timed = ExGods.app.user.get('timed')[type],
                            time = timed ? timed[3] : undefined;
                        return (type && time) ? '' : ' style="opacity:0"';
                    }
                }
            ];
        me.tpl = masksTpl.concat(searchTpl).concat(tplFunctions);
        me.data = me.config.data;
        me.callParent();
        me.mon(me.robbery, 'update', function(data) {
            me.timedtimer.setEnable();
            me.cancelbtn.disable();
            me.timedtimer[data.time_request ? 'hide' : 'show']();
            me.cancelbtn[data.time_request ? 'show' : 'hide']();
        });
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.renderBtns();
        ExGods.util.Ticker.addListener(me.updateQueueTime, me);
    },
    renderBtns: function() {
        var me = this,
            timed,
            quantity = 1;
        try {
            timed = me.robbery.get('request_stuff')[0].params.id;
            quantity = me.robbery.get('request_stuff')[0].params.quantity;
        } catch (e) {}
        
        me.timedtimer = Ext.widget('timedtimer', {
            renderTo: 'timed-place',
            textbutton: {
                itemId: 'get_task',
                listeners: {
                    click: function() {
                        me.timedtimer.setDisable();
                    }
                }
            },
            qh: {
                'data-qh_otype': 'robbery_button_battle',
                'data-qh_oid': '1'
            },
            timed: timed,
            quantity: quantity,
            hidden: !!me.robbery.get('time_request')
        });
        me.cancelbtn = Ext.widget('textbutton', {
            renderTo: 'timed-place',
            text: ExGods.getMsgByKey('view_robbery_search_cancelbtntext'),
            cls: 'double_text_btn',
            itemId: 'cancel_search',
            hidden: !me.robbery.get('time_request'),
            disabled: true,
            listeners: {
                click: function() {
                    this.disable();
                }
            }
        });
    },
    updateQueueTime: function() {
        var me = this,
            viewEl = me.getEl(),
            time_request = me.robbery.get('time_request'),
            to_request = me.robbery.get('to_request'),
            can_reject = me.robbery.get('can_reject'),
            type, timed,
            time = 0,
            el, nums, percent;
        if (time_request && viewEl) {
            el = viewEl.down('.robbery-timer');
            nums = viewEl.down('.nums');
            time = Math.max(0, to_request * 1000 - (Date.now() - time_request)) / 1000;
            width = Math.round((1 - time / to_request) * 232);
            if (time === 0)  {
                me.robbery.set('time_request', 0);
            }
            
            if (el)  {
                el.animate({
                    width: width
                });
            }
            
            if (nums)  {
                nums.setHTML(ExGods.util.Time.printTime(time, {
                    format: 'bignums'
                }));
            }
            
            //разблокирую кнопку, если прошло нужное время
            if (can_reject && time < to_request - can_reject && !me.robbery.requesting) {
                me.cancelbtn.enable();
            }
        }
    },
    updateData: function(data) {
        var me = this;
        me.update(data);
        ExGods.Resources.load(me, function() {
            me.renderBtns();
        });
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateReadyTime);
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            store = ExGods.app.getItemPrototypesStore();
        var stdRbr = me.robbery.get('request_stuff');
        stuff_arr = stuff_arr.concat(stdRbr);
        stuff_arr = stuff_arr.concat(me.data.reward);
        if (me.data.desc.img) {
            arr_images.push(me.data.desc.img);
        }
        Ext.Array.each(me.data.desc.masks, function(mask) {
            var proto = store.findRecord('entry', mask.params.id);
            var imgs = proto.get('images');
            for (var it in imgs) {
                arr_images.push(imgs[it]);
            }
        });
        return {
            images: [
                stdRbr
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.store.RobberyFoe', {
    extend: Ext.data.Store,
    model: 'ExGods.model.RobberyFoe',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            sorterFn: function(a, b) {
                return a.add_time > b.add_time;
            }
        }
    ]
});

/**
 * Контроллер грабежей
 *
 * @author Максим Дворцов
 *
 */
Ext.define('ExGods.controller.Robbery', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: false,
            error: false
        },
        prefix: 'Robbery:'
    },
    models: [
        'Robbery',
        'RobberyFoe'
    ],
    stores: [
        'RobberyFoe'
    ],
    views: [
        'robbery.EnemyList',
        'robbery.EnemyInfo',
        'robbery.Search',
        'robbery.Foe',
        'TimedTimer'
    ],
    refs: [
        {
            /**
         * @method getRobberySearch
         */
            ref: 'robberySearch',
            selector: 'robbery_search'
        },
        {
            /**
         * @method getRobberyContainer
         */
            ref: 'robberyContainer',
            selector: '#robbery'
        }
    ],
    loadingMasks: false,
    isRobberyBattle: false,
    init: function() {
        var me = this;
        me.control({
            '#accept_task': {
                click: me.onAcceptButtonClick
            },
            '#decline_task': {
                click: me.onDeclineTaskClick
            },
            '#get_task': {
                click: me.onGetTaskClick
            },
            '#cancel_search': {
                click: me.onCancelSearchClick
            },
            'textbutton[action="robbery_revenge"]': {
                click: me.onRevengeButtonClick
            },
            'battleresult': {
                close: me.showRobbery
            }
        });
        me.app.chatcn.on('command_robbery', me.onRobberyChatCommand, me);
        me.app.chatcn.on('robbery', me.onRobberyChatCommand, me);
        ExGods.Components.addComponentInitializer('robbery', me.initRobberyComponent, me);
    },
    /**
     * Создание комопнента для грабежей
     */
    initRobberyComponent: function(config, componentId) {
        var me = this,
            cmp,
            icons = ExGods.ref('images|robbery_icons').image,
            data = config.service.data.robbery,
            wnd;
        /*** test user data***/
        // var json = '{"battle_id":"1000181900","time_assign":1425639565,"count":1,"to_assign":45,"message":"нашли цель для грабежа","list":[{"loot":[{"features":[],"action":null,"slot_id":"3063","param":{"features":[],"dur":1,"item_value":null,"nonrep":"1","nonbr":"1","nonsale":"1"},"proto_id":"1343","item_id":"13129"},{"features":[],"action":null,"slot_id":"3064","param":{"features":[],"dur":17,"item_value":null,"taxable":null,"nonrep":"1","nonbr":"0","nonsale":"0"},"proto_id":"1398","item_id":"13184"}],"mask_proto_id":"1343","stats":{"stats":{"damage":15,"hp":34,"agility":0,"shield":43,"mp":100,"strength":0,"stamina":0,"fury":9,"accuracy":0}},"is_bot":0,"mask_id":"9","race":"2","shape":"as_m","hoard":{"level":"2","rank":null},"gender":"1","display_title":"exorel"}]}'
        // data = Ext.apply(data,JSON.parse(json));
        // data.time_assign = parseInt(Date.now()/1000) + 360;
        /*** end test ***/
        me.service = config.service;
        me.service.on('update', me.onServiceUpdate, me);
        me.robbery = Ext.create('ExGods.model.Robbery', data);
        /***/
        me.log('инициализация компонента "Грабежи"', data);
        Ext.apply(config, {
            rightPanelX: 177,
            closeCallback: function() {
                ExGods.loaderCt.loadAndRemove(function() {
                    wnd.close();
                }, {
                    img: config.backgroundImage
                });
            },
            margin: '0 10 10 0',
            items: [
                {
                    xtype: 'skintabpanel',
                    items: [
                        {
                            xtype: 'container',
                            itemId: 'robbery',
                            layout: 'fit',
                            margin: '0 8 8 8',
                            style: {
                                position: 'relative'
                            },
                            tabConfig: {
                                //tooltip: arena.data.label,
                                tooltip: ExGods.getMsgByKey('robbery_search_tooltip'),
                                icon: icons.search_tab
                            }
                        },
                        {
                            xtype: 'robbery_enemylist',
                            robbery: me.robbery.data,
                            tabConfig: {
                                tooltip: ExGods.getMsgByKey('robbery_enemy_list_tooltip'),
                                icon: icons.foes_tab
                            }
                        }
                    ],
                    width: 580,
                    height: 363,
                    y: 10,
                    x: 250,
                    plugins: [
                        'skindeco'
                    ],
                    closable: true,
                    listeners: {
                        beforeclose: {
                            fn: function() {
                                ExGods.loaderCt.loadAndRemove(function() {
                                    wnd.close();
                                }, {
                                    img: config.backgroundImage
                                });
                                return false;
                            }
                        },
                        tabchange: me.onTabChange,
                        scope: me
                    }
                },
                {
                    xtype: 'form',
                    x: 645,
                    y: 20,
                    width: 152,
                    height: 30,
                    tbar: {
                        xtype: 'panel',
                        bodyCls: 'parchment-content-nop',
                        bodyPadding: 0,
                        defaults: {
                            margin: '0 1'
                        },
                        height: 30,
                        items: [
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('robbery_search_empty_text'),
                                itemId: 'text-search',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: me.filterBySearch,
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            }
                        ],
                        layout: 'hbox',
                        margin: '0 0 5 0'
                    }
                }
            ]
        });
        me.cmp = Ext.apply({
            xtype: 'room'
        }, config);
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            items: [
                me.cmp
            ],
            getResources: function() {
                return {
                    images: [
                        config.backgroundImage
                    ]
                };
            }
        });
        me.cmp = wnd.down('room');
        me.cmp.on('render', function() {
            if (me.loadingMasks) {
                me.on('masks_loaded', me.setState, me, {
                    single: true
                });
            } else  {
                me.setState();
            }
            
        }, me);
        me.loadingMasks = true;
        ExGods.app.getController('Location').maskLocation(function() {
            ExGods.helpme.loadProtos(data.desc.masks.concat(data.request_stuff || []).concat(data.reward || []).concat(data.reward_extra || []), 'params.id', function() {
                me.loadingMasks = false;
                me.fireEvent('masks_loaded');
                // подгрузка ресурсов
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.backgroundImage
        });
        return wnd;
    },
    setState: function() {
        var me = this,
            data = me.robbery.data,
            container = me.getRobberyContainer();
        if (!container)  {
            return;
        }
        
        if (data.list) {
            ExGods.app.getItemPrototypesStore().loadNew([
                data.list.mask_proto_id
            ], function() {
                if (me.robbery_search)  {
                    container.remove(me.robbery_search);
                }
                
                if (me.robbery_enemyinfo) {
                    me.robbery_enemyinfo.updateData(data);
                } else {
                    me.robbery_enemyinfo = container.add(Ext.widget('robbery_enemy', {
                        data: data,
                        robbery: me.robbery,
                        listeners: {
                            destroy: function() {
                                me.robbery_enemyinfo = undefined;
                            }
                        }
                    }));
                }
            });
        } else {
            if (me.robbery_enemyinfo)  {
                container.remove(me.robbery_enemyinfo);
            }
            
            if (me.robbery_search) {
                me.robbery_search.updateData(data);
            } else {
                var srch = Ext.widget('robbery_search', {
                        data: data,
                        autoShow: false,
                        robbery: me.robbery,
                        listeners: {
                            destroy: function() {
                                me.robbery_search = undefined;
                            }
                        }
                    });
                ExGods.Resources.load(srch, function() {
                    me.robbery_search = container.add(srch);
                });
            }
        }
    },
    onGetTaskClick: function() {
        var me = this;
        me.robbery.requesting = true;
        me.service.command('robbery_request', {}, function(json) {
            me.robbery.requesting = false;
            if (json.next_stuff) {
                me.robbery.set('next_stuff', json.next_stuff);
            }
        });
    },
    onCancelSearchClick: function() {
        var me = this;
        me.robbery.requesting = true;
        if (me.robbery.get('can_reject')) {
            me.service.command('robbery_reject', {}, function() {});
        }
    },
    //me.robbery.requesting = false;
    onDeclineTaskClick: function() {
        this.robbery.set('list', undefined);
        this.onGetTaskClick();
    },
    onAcceptButtonClick: function(btn) {
        var me = this;
        me.service.command('robbery_start', {}, function(json) {
            if (json.success) {
                me.isRobberyBattle = me.service.id;
            }
        });
    },
    onRevengeButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('месть за грабеж');
        me.robbery.requesting = true;
        me.setButtonsDisable([
            'revenge'
        ], true);
        me.service.command('robbery_foe', {
            title: btn.user_title
        }, function(json) {
            if (json.success) {} else // должен стартовать бой
            {
                me.setButtonsDisable([
                    'revenge'
                ], false);
            }
            me.robbery.requesting = false;
        });
    },
    onRobberyChatCommand: Ext.Function.createBuffered(function(chatcn, data) {
        var me = this,
            search = me.getRobberySearch();
        data = data.body.data;
        /***/
        me.log('пришла команда чата "грабежи" с данными', data);
        var keys = Ext.Object.getKeys(data);
        //если robbery нет, значит компонент еще не открывали, и сервис еще не приходил
        if (me.robbery) {
            if (keys.length == 1 && keys[0] == 'message') {
                me.robbery.requesting = true;
                me.service.update();
            } else {
                me.onServiceUpdate(me.service, data);
            }
        }
        if (data.message) {
            me.app.getViewportController().onLogMessage(data.message);
        }
    }, 300),
    onServiceUpdate: function(service, data) {
        var me = this;
        data = data.robbery ? data.robbery : data;
        if (!data.time_request)  {
            data.time_request = 0;
        }
        
        if (!data.list)  {
            data.list = undefined;
        }
        
        if (!data.time_assign)  {
            data.time_assign = 0;
        }
        
        if (me.robbery) {
            me.robbery.set(data);
            me.robbery.requesting = false;
            me.robbery.fireEvent('update', data);
        }
        me.setState();
    },
    onTabChange: function(panel, tab) {
        var me = this,
            searchField = me.cmp.down('#text-search');
        if (tab.xtype == 'robbery_enemylist') {
            searchField.el.select('input').elements[0].value = tab.textFilter || '';
            // восстанавливаю значение поиска для текущей вкладки
            searchField.show();
        } else {
            searchField.hide();
        }
    },
    showRobbery: function() {
        var me = this;
        if (me.isRobberyBattle && ExGods.app.user.getSetting('reopen_interface') == 1) {
            ExGods.ClientActions.createAndInvoke({
                actionId: me.isRobberyBattle
            }, null, function(err) {
                /***/
                me.log('error', err);
            });
            me.isRobberyBattle = false;
        }
    },
    filterBySearch: function(searchField) {
        var me = this,
            str = searchField.getValue(),
            tabs = me.cmp.query('tabpanel')[0],
            tab = tabs.getActiveTab();
        if (tab.setTextFilter) {
            tab.setTextFilter(str);
        }
    },
    setButtonsDisable: function(btnNames, disabled) {
        var me = this,
            query;
        if (me.cmp) {
            Ext.Array.each(btnNames, function(btn) {
                Ext.Array.each(Ext.ComponentQuery.query('#' + btn), function(btn) {
                    if (!btn.can_revenge)  {
                        return;
                    }
                    
                    btn[disabled ? 'disable' : 'enable']();
                });
            });
        }
    }
});

/**
 * Просмотр пользовательских настроек
 */
Ext.define('ExGods.view.user.Settings', {
    extend: Ext.panel.Panel,
    alias: 'widget.usersettings',
    padding: '0 10 13 5',
    plugins: [
        'scroller'
    ],
    cls: 'user_settings',
    initComponent: function() {
        var me = this,
            ourUserModel = ExGods.app.user,
            arrayOfCat = me.arrayOfCat,
            formForTabPanel = [],
            checkboxCount = 0;
        for (var j = 0; j < arrayOfCat.groups.length; j++) {
            checkboxCount = 0;
            var arrayOfGroups = {
                    xtype: 'form',
                    defaults: {
                        labelAlign: 'right',
                        labelWidth: 180,
                        width: 550,
                        msgTarget: 'under'
                    },
                    costs: [],
                    buttonAlign: 'center',
                    items: []
                };
            if (j != 0)  {
                arrayOfGroups.items.push({
                    xtype: 'label',
                    isFormField: false,
                    html: [
                        '<div class="parchment-separator"></div>',
                        '<div class="paper-title"><b>' + arrayOfCat.groups[j].nameGroup + '</b></div>'
                    ]
                });
            }
            else  {
                arrayOfGroups.items.push({
                    xtype: 'label',
                    isFormField: false,
                    html: [
                        '<div class="paper-title"><b>' + arrayOfCat.groups[j].nameGroup + '</b></div>'
                    ]
                });
            }
            
            var next_change, setting;
            //Пребераем все параметры в пределах одной группы
            for (var k = 0; k < arrayOfCat.groups[j].data.length; k++) {
                next_change = undefined;
                setting = ourUserModel.get('settings')[arrayOfCat.groups[j].data[k].name];
                if (setting && setting.next_change) {
                    next_change = ExGods.util.Date.normalizeServerDateTime(setting.next_change);
                    if (next_change <= new Date()) {
                        next_change = undefined;
                    }
                }
                switch (arrayOfCat.groups[j].data[k].type) {
                    case 'list':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 20 10 200',
                                xtype: 'radiogroup',
                                fieldLabel: arrayOfCat.groups[j].data[k].label,
                                allowBlank: false,
                                columns: 1,
                                layout: 'vbox',
                                labelAlign: 'top',
                                vertical: true,
                                name: arrayOfCat.groups[j].data[k].name,
                                items: (function(variants) {
                                    var items = [];
                                    Ext.Array.each(variants, function(variant, index) {
                                        items.push({
                                            boxLabel: variant.label,
                                            inputValue: variant.value,
                                            name: arrayOfCat.groups[j].data[k].name,
                                            checked: (ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name) == variant.value ? true : false)
                                        });
                                    });
                                    return items;
                                }(arrayOfCat.groups[j].data[k].defaultItem.list))
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                    case 'combo':
                        var store = Ext.create('Ext.data.Store', {
                                fields: [
                                    'label',
                                    'value'
                                ],
                                data: arrayOfCat.groups[j].data[k].defaultItem.combo
                            });
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 20 10 110',
                                width: 500,
                                labelWidth: 250,
                                xtype: 'combo',
                                ui: 'guild',
                                fieldLabel: arrayOfCat.groups[j].data[k].label,
                                store: store,
                                queryMode: 'local',
                                valueField: 'value',
                                displayField: 'label',
                                name: arrayOfCat.groups[j].data[k].name,
                                value: ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name)
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                    case 'flag':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 15 12 204',
                                xtype: 'checkboxfield',
                                inputValue: '1',
                                uncheckedValue: '0',
                                boxLabel: arrayOfCat.groups[j].data[k].label,
                                name: arrayOfCat.groups[j].data[k].name,
                                checked: +ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name, arrayOfCat.groups[j].data[k].name)
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        checkboxCount++;
                        break;
                    case 'volume':
                    case 'number':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 20',
                                xtype: 'numberfield',
                                hideTrigger: true,
                                fieldLabel: arrayOfCat.groups[j].data[k].label,
                                name: arrayOfCat.groups[j].data[k].name,
                                value: +ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name, arrayOfCat.groups[j].data[k].name)
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                    case 'string':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 20',
                                xtype: 'textfield',
                                fieldLabel: arrayOfCat.groups[j].data[k].label,
                                name: arrayOfCat.groups[j].data[k].name,
                                value: ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name, arrayOfCat.groups[j].data[k].name)
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                    case 'passwd':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 10 0 75',
                                xtype: 'fieldcontainer',
                                name: arrayOfCat.groups[j].data[k].name,
                                defaults: {
                                    labelAlign: 'right',
                                    labelWidth: 180,
                                    width: 475
                                },
                                items: [
                                    {
                                        xtype: 'textfield',
                                        margin: '10',
                                        fieldLabel: ExGods.getMsgByKey('view_user_settings_oldpass'),
                                        name: 'current',
                                        isFormField: false,
                                        inputType: 'password'
                                    },
                                    {
                                        xtype: 'textfield',
                                        margin: '10',
                                        fieldLabel: ExGods.getMsgByKey('view_user_settings_newpass'),
                                        name: 'new',
                                        isFormField: false,
                                        inputType: 'password'
                                    },
                                    {
                                        xtype: 'textfield',
                                        margin: '10',
                                        fieldLabel: ExGods.getMsgByKey('view_user_settings_newpassconfirm'),
                                        name: 'new2',
                                        isFormField: false,
                                        inputType: 'password',
                                        msgTarget: 'under',
                                        fieldStyle: 'margin-bottom: 10px'
                                    },
                                    // чтобы немного сместить сообщение об ошибке (см. markInvalid у fielfcontainer)
                                    {
                                        xtype: 'hidden',
                                        name: arrayOfCat.groups[j].data[k].name,
                                        getSubmitValue: function() {
                                            var me = this,
                                                fieldCt = me.up('fieldcontainer'),
                                                value = [];
                                            fieldCt.items.each(function(item) {
                                                if (item != me && item.getValue) {
                                                    value.push(item.getValue());
                                                }
                                            });
                                            return value;
                                        }
                                    }
                                ],
                                markInvalid: function(msg) {
                                    var lastField = this.query('[name="new2"]')[0];
                                    lastField.markInvalid(msg);
                                    // используем последнее поле в форме для показа ошибки.
                                    lastField.inputEl.removeCls('x-form-invalid-field');
                                }
                            };
                        // при этом само поле не маркаем, т.к ошибка относиться ко всей форме
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                }
                if (next_change) {
                    arrayOfGroups.items.push({
                        xtype: 'displayfield',
                        fieldLabel: '',
                        value: ExGods.app.applyTpl(ExGods.getMsgByKey('setting_comment'), {
                            time: ExGods.util.Timers.printRestTimer('setting-next-change-' + arrayOfCat.groups[j].data[k].name, next_change)
                        }),
                        name: 'comment',
                        margin: '10 20 10 110',
                        width: 500,
                        labelWidth: 0,
                        fieldStyle: {
                            textAlign: 'center'
                        }
                    });
                }
            }
            arrayOfGroups.buttons = [
                {
                    xtype: 'textbutton',
                    cls: 'no_border',
                    action: 'save',
                    text: arrayOfGroups.costs.length ? ExGods.app.applyTpl(ExGods.getMsgByKey('settings_cost_btn_msg'), {
                        costs: arrayOfGroups.costs
                    }) : ExGods.getMsgByKey('settings_free_btn_msg'),
                    margin: '0 0 20 0',
                    costs: arrayOfGroups.costs
                }
            ];
            if (arrayOfCat.groups[j].data.length == checkboxCount) {
                // группу из чекбоксов размещаем по два в строку
                var items = arrayOfGroups.items;
                arrayOfGroups.items = [
                    items[0]
                ];
                // label
                for (var i = 0; i < checkboxCount; i += 2) {
                    if (items[i + 2]) {
                        items[i + 1].width = items[i + 2].width = 335;
                        items[i + 1].style = {
                            'text-align': 'right'
                        };
                        items[i + 2].style = {
                            'text-align': 'left'
                        };
                        items[i + 1].margin = '10 30 12 0';
                        items[i + 2].margin = '10 0 12 30';
                        arrayOfGroups.items.push({
                            xtype: 'panel',
                            layout: 'hbox',
                            width: 700,
                            items: [
                                items[i + 1],
                                items[i + 2]
                            ]
                        });
                    } else {
                        items[i + 1].width = 700;
                        items[i + 1].style = {
                            'text-align': 'center'
                        };
                        items[i + 1].margin = '10 0 12 0';
                        arrayOfGroups.items.push({
                            xtype: 'panel',
                            layout: 'hbox',
                            width: 700,
                            items: [
                                items[i + 1]
                            ]
                        });
                    }
                }
            }
            var formWihtParchmentdeco = {
                    xtype: 'form',
                    margin: '0',
                    items: arrayOfGroups
                };
            //                  plugins: [
            //                      {
            //                          //ptype: 'parchmentdeco',
            //                      }
            //                  ]
            formForTabPanel.push(formWihtParchmentdeco);
        }
        //вкладываю panel потому что scroller работает только с panel
        me.items = {
            xtype: 'panel',
            header: false,
            autoScroll: true,
            items: formForTabPanel,
            bodyPadding: '7 10 13 10',
            plugins: [
                'paperdeco'
            ]
        };
        arrayOfGroups.costs = undefined;
        me.callParent(arguments);
        ourUserModel.on('setting_change', function(name, value) {
            var el = me.down('[name="' + name + '"]');
            if (el && el.setValue)  {
                el.setValue(value);
            }
            
        });
    },
    //Функция для "фильтрации" затрат, если id затрат в пределах 
    //одной гуппе будут повторяться, то они будут сложены
    addToCotst: function(costs, arrayOfCosts) {
        //Идем по всем затратам
        for (var i = 0; i < costs.length; i++) {
            for (var x = 0; x < arrayOfCosts.length; x++) {
                if (costs[i].name === arrayOfCosts[x].name) {
                    arrayOfCosts[x].value = arrayOfCosts[x].value + costs[i].value;
                    break;
                }
            }
            //Не нашли добавляем затраты.
            if (x === arrayOfCosts.length) {
                arrayOfCosts.push(Ext.clone(costs[i]));
            }
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [
                IMAGE_URL + 'shop/btn_buy.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Контроллер настроек юзера
 */
Ext.define('ExGods.controller.Settings', {
    extend: ExGodsCore.controller.Base,
    views: [
        'user.Settings'
    ],
    init: function(app) {
        var me = this;
        me.control({
            'usersettings button[action="save"]': {
                click: me.isCostSetting
            }
        });
        me.service = ExGods.Services.get('settings');
        ExGods.Components.addComponentInitializer('settings', me.initSettingsComponent, me);
    },
    /**
     * @private
     */
    createSettingsTabPanel: function(arrayOfCat) {
        //items далее будут использованы как items для tabPanel
        var items = [];
        // usersettings - form с редактируемыми параметрами и кноркой Сохранить
        for (var i = 0; i < arrayOfCat.length; i++) {
            var panel = {
                    xtype: 'usersettings',
                    arrayOfCat: arrayOfCat[i],
                    tabConfig: {
                        icon: ExGods.ref('images|settings_images').image.tab,
                        tooltip: arrayOfCat[i].cat
                    },
                    getResources: function() {
                        var me = this,
                            arr_images = [];
                        var images_ = ExGods.ref('images|settings_images').image;
                        for (var i in images_) {
                            arr_images.push(images_[i]);
                        }
                        return {
                            stuff: [],
                            images: [
                                IMAGE_URL + 'shop/btn_buy.png'
                            ].concat(arr_images)
                        };
                    }
                };
            items.push(panel);
        }
        var tabPanel = {
                xtype: 'skintabpanel',
                tabUi: 'skintext',
                id: 'settings-tabs',
                items: items
            };
        return tabPanel;
    },
    isCostSetting: function(button) {
        var me = this;
        if (button.costs.length) {
            // Если действие платное - показываю диалог подтверждения
            Ext.widget('confirmdialog', {
                message: ExGods.app.applyTpl(ExGods.getMsgByKey('settings_cost_confirmation'), button),
                handler: function() {
                    me.saveSettingsFromForm(button);
                }
            });
        } else {
            //Если пользователь подтвердил что заплатит, вызываем метод для сохранения
            me.saveSettingsFromForm(button);
        }
    },
    saveSettingsFromForm: function(button) {
        var me = this,
            settings = button.up('form').getValues(),
            form = button.up('form'),
            panel = button.up('usersettings'),
            user = this.getUser();
        ExGods.util.Helper.maskElement(panel.getEl());
        me.saveSettings(settings, function(json) {
            var errors = [];
            Ext.iterate(json.result || {}, function(key, value) {
                errors.push(value);
            });
            if (errors.length) {
                me.application.fireEvent('logmessage', errors.join(', '));
            } else {
                me.application.fireEvent('logmessage', ExGods.app.applyTpl(ExGods.getMsgByKey('settings_are_applied')));
            }
            me.fireEvent('settings_saved', json.result);
            panel.getEl().unmask();
        });
    },
    saveSettings: function(settings, cb) {
        var user = this.getUser(),
            me = this;
        me.service.command('save_setting', {
            setting: Ext.encode(settings)
        }, function(result) {
            if (result.success) {
                if (cb) {
                    cb(result);
                }
            }
        });
    },
    initSettingsComponent: function(config, componentId) {
        var me = this,
            wnd;
        // Берем свойства пользователя из справочника
        var me = this,
            settings = me.service.data.settings;
        arrayOfCat = [] , user = me.getUser() , panel = Ext.getCmp('settings') , //Функция для сортировки параметров по группам и категориям
        //для дольнейшего отображения их в form
        splitIntoCat = function(array, item) {
            //Создаю категорию.
            var user = ExGods.app.user,
                data = {
                    label: item.label,
                    defaultItem: item['default'],
                    type: item.type,
                    name: item.name,
                    entry: item.entry,
                    costs: item.params.costs
                },
                group = {
                    nameGroup: item.group,
                    data: [
                        data
                    ]
                },
                obj = {
                    cat: item.cat,
                    groups: [
                        group
                    ]
                };
            //Пробегаем по параметрам и проверяем соответствуют ли они имеющимся
            //категориям, если нет добанляется категория с этим параметром
            for (var i = 0; i < array.length; i++) {
                if (item.cat === array[i].cat) {
                    //Проверяем существует ли такая группа, если существует, добавляем параметр в группу,
                    //если нет, добавляем группу и параметр
                    for (var j = 0; j < array[i].groups.length; j++) {
                        if (item.group === array[i].groups[j].nameGroup) {
                            array[i].groups[j].data.push(data);
                            return true;
                        }
                    }
                    array[i].groups.push(group);
                    return true;
                }
            }
            array.push(obj);
        };
        if (panel) {
            panel.hide();
        }
        //Сортируем параметры по настройке "Порядок"
        settingsAsArray = settings.sort(function(a, b) {
            return (a.order - b.order);
        });
        // разбиваем на категории
        Ext.Array.each(settingsAsArray, function(item) {
            //Проверка на сушкствоване этого параметра у юзера
            if (user.data.settings[item.name]) {
                splitIntoCat(arrayOfCat, item);
            }
        });
        panel = me.createSettingsTabPanel(arrayOfCat);
        wnd = Ext.widget('window2', {
            id: componentId,
            closeAction: 'hide',
            items: [
                panel
            ],
            autoShow: false
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
        });
        return wnd;
    }
});

/**
 * Интерфейс крнтроллера соц. сети
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGods.mixin.Sociable', {
    /**
     * @property initialized {Boolean} Признак инициализации
     */
    initialized: false,
    /**
     * Инициализация SDK соц.сети
     */
    initSDK: function() {
        var me = this;
        me.initialized = true;
        me.callParent(arguments);
    },
    /**
     * Функция шаринга в социальных сетях
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          url: <ссылка для шары>,
     *          image: <url сопроводительной картинки>,
     *          title: <заголовок>,
     *          description: <описание>
     *      }
     */
    share: function(obj) {},
    // 
    /**
     * Функция покупки в социальных сетях
     *
     * @param {Number} Сумма покупки
     */
    buy: function(preset) {},
    // 
    /**
     * Функция постинга в социальные сети
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          image: <url сопроводительной картинки>,
     *          message: <описание>
     *          owner: <id пользователя на чью стену делать пост. Если нет, то пост будет на моей стене>
     *      }
     */
    wallPost: function(obj) {},
    //
    /**
     * метод поста на стену без добавления фотографий
     */
    simpleWallPost: function(obj) {},
    //
    /**
     * Пригласить друга в игру
     */
    invite: function(callback) {},
    //
    /**
     * Подарок френду
     */
    gift: function(preset) {},
    //
    /**
     * Проверяет, может ли пользователь использовать промо предложение 
     */
    isCanUsePromo: function(callback) {
        callback(false);
    },
    /**
     * Покупка пресета как промо-продукта
     * @param presetEntry {Number}
     * @param callback {Function} Колбек. 
     */
    usePromo: function(presetEntry, callback) {},
    //
    /**
     * Проверяет, может ли пользователь отправить сообщение другому юзеру соц.сети (не обязательно другу)
     */
    isCanSendUserToUserMessage: function() {
        return false;
    },
    /**
     * Отправить сообщение пользователю от другого пользователя (не обязательно друга)
     * @param to {Array} Список ids получателей
     * @param message {String}
     * @param callback {Function} 
     */
    sendUserToUserMessage: function(to, message, callback) {},
    //
    /**
     * Обновить размер фрейма
     */
    setSize: function(width, height) {}
});
//

/**
 * Реализация методов соц.функций для VK
 */
Ext.define('ExGods.controller.social.VK', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'VK:'
    },
    /**
     * Инициализация контроллера. Здесь же происходит инициализация SDK соц.сети
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: '//vk.com/js/api/xd_connection.js?2',
            onLoad: function() {
                VK.init(function() {
                    me.initialized = true;
                });
            }
        });
    },
    /**
     * Функция шаринга в социальных сетях
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          url: <ссылка для шары>,
     *          image: <url сопроводительной картинки>,
     *          title: <заголовок>,
     *          description: <описание>
     *      }
     */
    share: function(obj) {
        var url = 'http://vkontakte.ru/share.php?' + Ext.Object.toQueryString(obj);
        window.open(url, 'share', 'width=600,height=400');
    },
    /**
     * Функция покупки в социальных сетях
     *
     * @param {Number} Сумма покупки
     */
    buy: function(preset) {
        var me = this,
            app = me.application,
            user = app.user;
        function onOrderSuccess() {
            VK.removeCallback('onOrderSuccess', onOrderSuccess);
            me.request({
                url: '/game.pl?cmd=money&item=1',
                method: 'POST'
            });
        }
        VK.addCallback('onOrderSuccess', onOrderSuccess);
        function onOrderCancel() {
            VK.removeCallback('onOrderCancel', onOrderCancel);
        }
        VK.addCallback('onOrderCancel', onOrderCancel);
        // окно с зачислением votes
        VK.callMethod('showOrderBox', {
            type: 'item',
            item: preset.entry
        });
    },
    /**
     * Функция постинга в социальные сети
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          image: <url сопроводительной картинки>,
     *          message: <описание>
     *          owner: <id пользователя на чью стену делать пост. Если нет, то пост будет на моей стене>
     *      }
     */
    wallPost: function(obj, callback) {
        var me = this,
            user = me.user;
        VK.api('photos.getWallUploadServer', function(result) {
            me.request({
                url: '/vka.pl',
                params: {
                    cmd: 'wallupload',
                    url: result.response.upload_url,
                    image: obj.image
                },
                success: function(result) {
                    VK.api('photos.saveWallPhoto', result.response, function(result) {
                        var photo = result.response[0].id;
                        var params = {
                                message: obj.message + ' http://vk.com/app' + config.user.payment_app + '_' + user.get('social').social_net_id + '#msg_id' + getUID(),
                                attachments: photo
                            };
                        if (obj.owner)  {
                            params.owner_id = obj.owner;
                        }
                        
                        VK.api('wall.post', params, function(result) {
                            if (result.response && result.response.post_id) {
                                if (callback) {
                                    callback();
                                }
                            } else {}
                        });
                    });
                }
            });
        });
    },
    // me.application.fireEvent('socialwallcanceled');
    /**
     * метод поста на стену без добавления фотографий
     */
    simpleWallPost: function(obj, callback) {
        var me = this,
            user = me.user;
        var params = {
                message: obj.message + ' http://vk.com/app' + config.user.payment_app + '_' + user.get('social').social_net_id + '#msg_id' + getUID()
            };
        if (obj.owner)  {
            params.owner_id = obj.owner;
        }
        
        VK.api('wall.post', params, function(result) {
            if (result.response && result.response.post_id) {
                if (callback) {
                    callback();
                }
            } else {}
        });
    },
    // me.application.fireEvent('socialwallcanceled');
    /**
     * Пригласить друга в игру
     */
    invite: function(callback) {
        var me = this,
            allFriends, appFriends, noAppFriends,
            userList = [],
            onListLoad = function() {
                if (allFriends && appFriends) {
                    cleanList();
                    prepareUsersFromFriends();
                    showDialog();
                }
            },
            cleanList = function() {
                for (var i = 0; i < allFriends.length; i++) {
                    if (appFriends.indexOf(allFriends[i].uid) != -1) {
                        allFriends[i] = null;
                    }
                }
                noAppFriends = Ext.Array.clean(allFriends);
            },
            prepareUsersFromFriends = function() {
                var defaults = {
                        hoard: me.user.data.hoard
                    };
                noAppFriends.forEach(function(friend) {
                    userList.push(Ext.apply({}, {
                        display_title: friend.first_name + ' ' + friend.last_name,
                        shape: {
                            small: friend.photo_50
                        },
                        gender: friend.sex == 1 ? 2 : 1,
                        social: friend.uid
                    }, defaults));
                });
            },
            showDialog = function() {
                ExGods.Components.factory('USER_TARGET_PANEL', {
                    windowTitle: ExGods.getMsgByKey('invite_friends_window_title'),
                    users: userList,
                    listeners: {
                        select: function(wnd, rec) {
                            // пост на стену друга
                            me.wallPost({
                                image: IMAGE_URL + ExGods.getMsgByKey('invite_friends_image_url'),
                                message: ExGods.getMsgByKey('invite_friends_message'),
                                owner: rec.data.social
                            }, function() {
                                if (callback) {
                                    callback();
                                }
                            });
                            wnd.up().close();
                        }
                    }
                });
            };
        // получаю список друзей
        VK.api('friends.get', {
            fields: 'nickname, domain, sex, photo_50'
        }, function(result) {
            if (result.response && Ext.isArray(result.response)) {
                allFriends = result.response;
                onListLoad();
            }
        });
        // получаю список друзей, у которых установлено приложение
        VK.api('friends.getAppUsers', {}, function(result) {
            if (result.response && Ext.isArray(result.response)) {
                appFriends = result.response;
                onListLoad();
            }
        });
    },
    /**
     * Подарок френду
     */
    gift: function(preset) {},
    //
    /**
     * Обновить размер фрейма
     */
    setSize: function(width, height) {
        VK.callMethod("resizeWindow", width, height);
    }
});

/**
 * Реализация методов соц.функций для OK
 */
Ext.define('ExGods.controller.social.OK', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'OK:'
    },
    /**
     * Инициализация SDK соц.сети
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: config.user.apiserver + 'js/fapi5.js',
            onLoad: function() {
                FAPI.init(config.user.apiserver, config.user.apiconnection, function() {
                    FAPI.Client.initialize();
                    FAPI.PrepareStreamPublish = function(message) {
                        var rm = message.message;
                        if (rm.length > 99) {
                            rm = rm.substr(0, 96) + " ...";
                        }
                        var params = {
                                "application_key": config.user.payment_app,
                                "session_key": config.user.payment_key,
                                "format": 'JSON',
                                "method": "stream.publish",
                                "message": message.subject,
                                attachment: Ext.encode({
                                    "caption": rm,
                                    "media": [
                                        {
                                            //"href": "link",
                                            "src": "/" + message.image_rel,
                                            "type": "image"
                                        }
                                    ]
                                })
                            };
                        var sig = FAPI.Util.calcSignature(params, config.user.secret_key);
                        FAPI.PrepareStreamPublish.params4send = params;
                        return sig;
                    };
                    FAPI.PrepareStreamPublish.params4send = {};
                    self.API_callback = function(method, result, data) {
                        if (method == 'showConfirmation' && result == 'ok') {
                            //FAPI.PrepareStreamPublish.params["resig"] = data;
                            FAPI.Client.call(FAPI.PrepareStreamPublish.params4send, function(status, data, error) {
                                if (status == 'ok') {
                                    me.application.fireEvent('socialwallposted');
                                } else {
                                    console.log("status: ", status);
                                    console.log("data: ", data);
                                    console.log("error: ", error);
                                }
                            }, // ПОЛУЧАЮ ОШИБКУ (ЕЕ ТЕКСТ НИЖЕ)
                            data);
                        }
                    };
                    me.initialized = true;
                }, function(error) {
                    alert("API initialization failed");
                });
            }
        });
    },
    /**
     * Функция шаринга в социальных сетях
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          url: <ссылка для шары>,
     *          image: <url сопроводительной картинки>,
     *          title: <заголовок>,
     *          description: <описание>
     *      }
     */
    share: function(obj) {
        var url = 'http://www.odnoklassniki.ru/dk?st.cmd=addShare&st.s=1000&st._surl=' + encodeURIComponent('http://' + location.host + '/ok.pl?title=' + obj.title + '&description=' + obj.description + '&image=' + obj.image + '&url=' + obj.url);
        window.open(url, 'share', 'width=600,height=400');
    },
    /**
     * Функция покупки в социальных сетях
     *
     * @param {Number} Сумма покупки
     */
    buy: function(preset) {
        var me = this,
            app = me.application,
            user = app.user,
            plurals = preset.game_currency == 'gold' ? ExGods.getMsgByKey('gold_name').split(',') : ExGods.getMsgByKey('crystal_name').split(',');
        FAPI.UI.showPayment(Ext.util.Format.number(preset.count, '0,0') + ' ' + Ext.util.Format.plural(preset.count, plurals), '', preset.entry, preset.price, null, null, 'ok', 'true');
    },
    /**
     * Функция постинга в социальные сети
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          image: <url сопроводительной картинки>,
     *          message: <описание>
     *      }
     */
    wallPost: function(obj) {
        var me = this,
            user = me.user;
        if (obj.owner) {
            FAPI.UI.showInvite(obj.message, '', obj.owner);
        } else {
            var sig = FAPI.PrepareStreamPublish(obj);
            FAPI.UI.showConfirmation('stream.publish', Ext.String.format(ExGods.getMsgByKey("social_ok_confirm_text"), obj.subject), sig);
        }
    },
    /**
     * метод поста на стену без добавления фотографий
     */
    simpleWallPost: function(obj) {
        var me = this,
            user = me.user;
        if (obj.owner) {
            FAPI.UI.showInvite(obj.message, false, obj.owner);
        } else {
            var sig = FAPI.PrepareStreamPublish(obj);
            FAPI.UI.showConfirmation('stream.publish', Ext.String.format(ExGods.getMsgByKey("social_ok_confirm_text"), obj.subject), sig);
        }
    },
    /**
     * Пригласить друга в игру
     */
    invite: function(callback) {},
    //
    /**
     * Подарок френду
     */
    gift: function(preset) {},
    //
    /**
     * Обновить размер фрейма
     */
    setSize: function(width, height) {
        FAPI.UI.setWindowSize(width, height);
    }
});

/**
 * Реализация методов соц.функций для MM
 */
Ext.define('ExGods.controller.social.MM', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'MM:'
    },
    /**
     * Инициализация SDK соц.сети
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: 'https://connect.mail.ru/js/loader.js',
            onLoad: function() {
                mailru.loader.require('api', function() {
                    mailru.app.init(config.user.payment_key);
                    me.initialized = true;
                });
            }
        });
    },
    /**
     * Функция шаринга в социальных сетях
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          url: <ссылка для шары>,
     *          image: <url сопроводительной картинки>,
     *          title: <заголовок>,
     *          description: <описание>
     *      }
     */
    share: function(obj) {
        var url = 'http://connect.mail.ru/share?' + Ext.Object.toQueryString(obj);
        window.open(url, 'share', 'width=600,height=400');
    },
    /**
     * Функция покупки в социальных сетях
     *
     * @param {Number} Сумма покупки
     */
    buy: function(preset) {
        var me = this,
            app = me.application,
            user = app.user;
        mailru.events.listen(mailru.app.events.incomingPayment, function(event) {
            // эта функция будет вызываться после совершения оплаты
            me.request({
                url: '/game.pl?cmd=money&item=1',
                method: 'POST'
            });
        });
        mailru.app.payments.showDialog({
            service_id: preset.entry,
            service_name: Ext.util.Format.money(preset.count, 'crystal'),
            mailiki_price: preset.price
        });
    },
    /**
     * Функция постинга в социальные сети
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          image: <url сопроводительной картинки>,
     *          message: <описание>
     *      }
     */
    wallPost: function(obj) {
        var me = this,
            user = me.user;
        mailru.events.remove(mailru.common.events.streamPublish);
        mailru.events.listen(mailru.common.events.streamPublish, function(event) {
            switch (event.status) {
                case 'publishSuccess':
                    // me.application.fireEvent('socialwallposted'); // если нужен ответ - использовать callback
                    break;
                case 'publishFail':
                    // me.application.fireEvent('socialwallcanceled');
                    break;
                case 'closed':
                    // me.application.fireEvent('socialwallcanceled');
                    break;
                default:
                    break;
            }
            
        });
        mailru.common.stream.post({
            title: obj.subject,
            text: obj.message,
            img_url: obj.image,
            action_links: [
                {
                    text: ExGods.getMsgByKey('social_link_title'),
                    href: '1'
                }
            ]
        });
    },
    /**
     * метод поста на стену без добавления фотографий
     */
    simpleWallPost: function(obj) {
        var me = this,
            user = me.user;
        mailru.events.remove(mailru.common.events.streamPublish);
        mailru.events.listen(mailru.common.events.streamPublish, function(event) {
            switch (event.status) {
                case 'publishSuccess':
                    // me.application.fireEvent('socialwallposted'); // если нужен ответ - использовать callback
                    break;
                case 'publishFail':
                    // me.application.fireEvent('socialwallcanceled');
                    break;
                case 'closed':
                    // me.application.fireEvent('socialwallcanceled');
                    break;
                default:
                    break;
            }
            
        });
        if (obj.owner) {
            mailru.common.guestbook.post({
                uid: obj.owner,
                title: obj.subject,
                text: obj.message,
                action_links: [
                    {
                        text: ExGods.getMsgByKey('social_link_title'),
                        href: '1'
                    }
                ]
            });
        } else {
            mailru.common.stream.post({
                title: obj.subject,
                text: obj.message,
                action_links: [
                    {
                        text: ExGods.getMsgByKey('social_link_title'),
                        href: '1'
                    }
                ]
            });
        }
    },
    /**
     * Пригласить друга в игру
     */
    invite: function(callback) {},
    //
    /**
     * Подарок френду
     */
    gift: function(preset) {},
    //
    /**
     * Обновить размер фрейма
     */
    setSize: function(width, height) {
        mailru.app.utils.setHeight(height);
    }
});

/**
 * Добавление рамки для изображения о вознаграждении за выставление рейтинга
 */
Ext.define('ExGods.view.social.socialVoting.stuff.RewardsVote', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.view.dialog.stuff.decorator.RewardFrame);
        return data;
    }
});

/**
 * Диалог о голосовании
 *
 * @author Дмитрий Белоновский
 */
Ext.define('ExGods.view.social.socialVoting.Vote', {
    extend: Ext.panel.Panel,
    alias: 'widget.socialvotingpanel',
    id: 'VotePanelFB',
    /** @cfg */
    clientConfig: {},
    stuff: [],
    plugins: [],
    initComponent: function() {
        var me = this;
        me.clientConfig.you_get_reward;
        if (me.myParams.hasVoted) {
            me.hasVoted = me.myParams.hasVoted;
        }
        if (me.myParams.curVote) {
            me.curVote = me.myParams.curVote;
        }
        me.config = Ext.applyIf(me.clientConfig || {}, me.defaultConfig);
        me.items = [
            {
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                plugins: [
                    'paperdeco'
                ],
                padding: "0 0 0 0",
                margin: '7 8 4 6 ',
                items: [
                    {
                        width: '100%',
                        height: 130,
                        style: {
                            'text-align': 'center'
                        },
                        data: {},
                        tpl: [
                            '<div class="socialVoteBlock">',
                            '<div class="socialVoteBlock-content">',
                            '<div class="dialog-rewards-stuff">',
                            '<div class="paper-title"><h4>' + me.clientConfig.vote_text + '</h4></div>',
                            '<div class="stuff">' + '<div class="quest-giver-border">',
                            '<div class="quest-giver-image" style="background-image:url(' + IMAGE_URL + me.clientConfig.img_in_descr + '); "></div>',
                            '</div>',
                            '<p class="vote-game-text">' + me.clientConfig.description + '</p>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>'
                        ]
                    },
                    {
                        width: '100%',
                        height: 210,
                        id: 'socialVoteRewardBlock',
                        style: {
                            'text-align': 'center'
                        },
                        listeners: {
                            render: function() {
                                /// Функция добавляет классы для звездочек 
                                //  и выводит текст
                                function setCurSelectedRatingVote(data_id, force) {
                                    if (force != true) {
                                        if (me.hasVoted && me.hasVoted === true) {
                                            return;
                                        }
                                    }
                                    for (var i = 0; i <= 4; i++) {
                                        if (i <= data_id) {
                                            Ext.get('social-vote-star' + i).addCls('social-vote-star-on');
                                        } else {
                                            Ext.get('social-vote-star' + i).removeCls('social-vote-star-on');
                                        }
                                    }
                                    if (data_id == 0) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_terrible);
                                    }
                                    if (data_id == 1) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_bad);
                                    }
                                    if (data_id == 2) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_normal);
                                    }
                                    if (data_id == 3) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_good);
                                    }
                                    if (data_id == 4) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_great);
                                    }
                                }
                                
                                Ext.query('.social-vote-star').forEach(function(dom) {
                                    setCurSelectedRatingVote(me.curVote, true);
                                    el = Ext.get(dom);
                                    el.on('mouseenter', function(e, target) {
                                        if (me.hasVoted && me.hasVoted === true) {
                                            return;
                                        }
                                        setCurSelectedRatingVote(target.getAttribute("data-id"));
                                    });
                                    el.on('click', function(e, target) {
                                        if (me.hasVoted && me.hasVoted === true) {
                                            return;
                                        }
                                        me.curVote = target.getAttribute("data-id");
                                    });
                                });
                                // При выходе мыши из блока со звездочками, указывается
                                // текущее количество выбранных звездочек
                                Ext.get('social-vote-star-wrpr').on('mouseleave', function(e, target) {
                                    if (me.hasVoted && me.hasVoted === true) {
                                        return;
                                    }
                                    setCurSelectedRatingVote(me.curVote);
                                });
                            },
                            afterrender: function() {
                                var me_xtype = this,
                                    socialVoteBtn = 0,
                                    socialVoteTakeRewardBtn = 0;
                                ExGods.util.Helper.renderComponents(me_xtype.el, me_xtype);
                                socialVoteBtn = Ext.getCmp('socialVoteBtn');
                                socialVoteTakeRewardBtn = Ext.getCmp('socialVoteTakeRewardBtn');
                                if (me.hasVoted == true) {
                                    socialVoteBtn.setDisabled(1);
                                    socialVoteTakeRewardBtn.setDisabled(0);
                                    Ext.get('voteHaveVotedImg').addCls('voteHaveVotedImgOk');
                                }
                                // Управляем кнопками
                                socialVoteBtn.on('click', function() {
                                    if (this.isDisabled() || (me.hasVoted && me.hasVoted === true)) {
                                        return;
                                    }
                                    if (me.curVote >= 3) {
                                        var cmpFB = Ext.widget('socialvotingpanelFBWindow', {
                                                clientConfig: me.clientConfig,
                                                myParams: {
                                                    hasVoted: true,
                                                    curVote: me.curVote,
                                                    clientConfig: me.clientConfig,
                                                    componentId: me.componentId
                                                }
                                            });
                                        var wnd = Ext.widget('window2', {
                                                id: 'socialvotingpanelFBWindowId',
                                                cls: 'votingWindowFB',
                                                width: 828,
                                                height: 416,
                                                autoShow: false,
                                                items: [
                                                    cmpFB
                                                ]
                                            });
                                        var VotePanelFBImage = Ext.getCmp('VotePanelFBImage');
                                        ExGods.Resources.load(VotePanelFBImage, function() {
                                            wnd.show();
                                            Ext.get('floaterBlockFBAnim').show();
                                        });
                                    } else // показываем летающий блок после загрузки всего
                                    {
                                        me.hasVoted = true;
                                        Ext.getCmp('socialVoteBtn').setDisabled(1);
                                        Ext.get('voteHaveVotedImg').addCls('voteHaveVotedImgOk');
                                        Ext.getCmp('socialVoteTakeRewardBtn').setDisabled(0);
                                    }
                                });
                                // Событие закрытие окна при клике на кнопку забрать награду
                                if (socialVoteTakeRewardBtn) {
                                    socialVoteTakeRewardBtn.on('click', function() {
                                        var args = Array.prototype.concat.apply([
                                                'onTakeRewardButton',
                                                me_xtype,
                                                me
                                            ], arguments);
                                        me_xtype.fireEvent.apply(me_xtype, args);
                                    });
                                }
                            },
                            beforedestroy: function() {
                                var me = this;
                                ExGods.util.Helper.destroyComponents(me.el);
                            }
                        },
                        data: {},
                        tpl: [
                            '<div class="paper-separator paper-separator-voting"></div>',
                            '<div class="socialVoteBlock">',
                            '<div class="socialVoteBlock-content">',
                            '<div class="dialog-rewards-stuff">',
                            '<div class="paper-title">',
                            '<h4>' + '{[this.methodGetImgRewardText()]}',
                            '</h4>',
                            '</div>',
                            '<div class="stuff">',
                            '<div class="social-vote-block-wrapper social-vote-block-wrapper1">',
                            '<div class="social-vote-block-bottom-top">',
                            '<div id="social-vote-star-wrpr" class="social-vote-star-wrpr">',
                            '<span id="social-vote-star0" class="social-vote-star " data-id="0"></span>',
                            '<span id="social-vote-star1" class="social-vote-star " data-id="1"></span>',
                            '<span id="social-vote-star2" class="social-vote-star " data-id="2"></span>',
                            '<span id="social-vote-star3" class="social-vote-star " data-id="3"></span>',
                            '<span id="social-vote-star4" class="social-vote-star" data-id="4"></span>',
                            '</div>',
                            '<span id="social-vote-status-text" class="social-vote-status-text">' + me.clientConfig.status_great + '</span>',
                            '</div>',
                            '<div class="social-vote-block-bottom-bottom">',
                            '<div class="component">',
                            '<span role="xtype">textbutton</span>',
                            '<span role="id">socialVoteBtn</span>',
                            '<span role="text">',
                            me.clientConfig.you_vote,
                            '</span>',
                            '<span role="cls">double_text_btn social-vote-btn</span>',
                            '<span role="flex:int">1</span>',
                            '<span role="margin">3 5 0 0</span>',
                            '</div>',
                            '<div id="voteHaveVotedImg" class="vote-have-voted-img"></div>',
                            '</div>',
                            '</div>',
                            '<div class="social-vote-block-wrapper social-vote-block-wrapper2">',
                            '<div class="social-voting-arror-right"></div>',
                            '</div>',
                            '<div class="social-vote-block-wrapper social-vote-block-wrapper3">',
                            '<div class="social-vote-block-bottom-top social-vote-block-bottom-top-right">',
                            '<div class="social-vote-block-right-img">',
                            '{[this.methodGetImgReward()]}',
                            '</div>',
                            '</div>',
                            '<div class="social-vote-block-bottom-bottom">',
                            '<div class="component">',
                            '<span role="xtype">textbutton</span>',
                            '<span role="id">socialVoteTakeRewardBtn</span>',
                            '<span role="text">',
                            me.clientConfig.you_get_reward,
                            '</span>',
                            '<span role="cls">double_text_btn social-vote-btn</span>',
                            '<span role="flex:int">1</span>',
                            '<span role="margin">3 5 0 0</span>',
                            '<span role="disabled:bool">1</span>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>',
                            {
                                methodGetImgReward: function() {
                                    if (!Ext.isArray(me.clientConfig.reward)) {
                                        me.clientConfig.reward = [
                                            me.clientConfig.reward
                                        ];
                                    }
                                    var img_stuff_html = Ext.Array.map(me.clientConfig.reward, function(stuff) {
                                            return ExGods.stuff.StuffManager.image({
                                                type: 'dialog_social_vote',
                                                params: {
                                                    stuff: stuff
                                                }
                                            });
                                        }).join('');
                                    return img_stuff_html;
                                },
                                methodGetImgRewardText: function() {
                                    var img_stuff_html = ExGods.app.applyTpl(me.clientConfig.vote_and_get_rewards, {
                                            reward: ExGods.stuff.StuffManager.print(me.clientConfig.reward)
                                        });
                                    return img_stuff_html;
                                }
                            }
                        ]
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            stuff: me.clientConfig.reward,
            images: [
                IMAGE_URL + 'dialog_vote/star_big_empty.png',
                IMAGE_URL + 'dialog_vote/star_big.png',
                IMAGE_URL + 'mask/arrow.png',
                IMAGE_URL + 'icons/undone.png',
                IMAGE_URL + 'icons/done.png',
                IMAGE_URL + 'dialog/item_slot.png',
                // рамка у стафа
                IMAGE_URL + me.clientConfig.img_in_descr,
                me.clientConfig.you_vote,
                me.clientConfig.you_get_reward
            ]
        };
    }
});

/**
 * Диалог о голосовании, вывод картинки фейсбука
 *
 * @author Дмитрий Белоновский
 */
Ext.define('ExGods.view.social.socialVoting.VoteFBLink', {
    extend: Ext.panel.Panel,
    alias: 'widget.socialvotingpanelFBWindow',
    id: 'VotePanelFBImage',
    /** @cfg */
    clientConfig: {},
    stuff: [],
    plugins: [],
    initComponent: function() {
        var me = this;
        hasVoted = false;
        me.config = Ext.applyIf(me.clientConfig || {}, me.defaultConfig);
        // Летающий блок, запоминаем чтобы затем отключить при закрытии
        me.floaterBlock = Ext.create('Ext.Component', {
            x: 715,
            y: 400,
            autoShow: false,
            id: 'floaterBlockFBAnim',
            renderTo: Ext.getBody(),
            html: '<div class="socialVoteFacebook"></div>',
            style: 'position:absolute; z-index: 3333 ; display: none',
            listeners: {
                render: function() {
                    var me_xtype = this;
                    me_xtype.el.on('click', function() {
                        var args = Array.prototype.concat.apply([
                                'click',
                                me_xtype,
                                me
                            ], arguments);
                        me_xtype.fireEvent.apply(me_xtype, args);
                    });
                }
            }
        });
        me.items = [
            {
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                padding: "0 0 0 0",
                margin: '7 8 4 6 ',
                items: [
                    {
                        xtype: 'component',
                        height: 500,
                        html: '<div id="votingWindowFBGrandImageId" class="votingWindowFBGrandImage"></div>',
                        id: 'votingWindowFBGrandImageIdClc',
                        listeners: {
                            render: function() {
                                var me_xtype = this;
                                me_xtype.el.on('click', function() {
                                    var args = Array.prototype.concat.apply([
                                            'click',
                                            me_xtype,
                                            me
                                        ], arguments);
                                    me_xtype.fireEvent.apply(me_xtype, args);
                                });
                            },
                            destroy: function() {
                                var me_xtype = this;
                                var args = Array.prototype.concat.apply([
                                        'onDestroyWnd',
                                        me_xtype,
                                        me
                                    ], arguments);
                                me_xtype.fireEvent.apply(me_xtype, args);
                            }
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'dialog_vote/fb_bg.png',
                IMAGE_URL + 'dialog_vote/fb_rate_popup.png'
            ]
        };
    }
});

/**
 * Реализация методов соц.функций для FB
 */
Ext.define('ExGods.controller.social.FB', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'FB:'
    },
    views: [
        'ExGods.view.social.socialVoting.Vote',
        'social.socialVoting.VoteFBLink'
    ],
    init: function() {
        var me = this;
        ExGods.stuff.StuffManager.register({
            'dialog_social_vote': ExGods.view.social.socialVoting.stuff.RewardsVote
        });
        me.control({
            '#votingWindowFBGrandImageIdClc': {
                click: me.onimageFBClick,
                onDestroyWnd: me.onDestroyWndFB
            },
            '#floaterBlockFBAnim': {
                click: me.onimageFBClick
            },
            '#socialVoteRewardBlock': {
                onTakeRewardButton: me.onTakeRewardButtonFB
            }
        });
        ExGods.Components.addComponentInitializer('social_voting', me.initSocialVoteComponent, me);
    },
    /**
     * Инициализация системы голосования в соц сетях
     */
    initSocialVoteComponent: function(config, componentId) {
        var me = this;
        var myParams = {
                hasVoted: false,
                curVote: 4
            };
        //config.reward = config.reward[0]; // 1 вещь приходит
        //config.reward.pop();              // 2 вещи приходят
        me.FBVoteParams = myParams;
        var wnd = me.createVoteWindow(config, componentId, myParams);
        //подгрузить стафф из клиентконфиг
        //ExGods.util.Helper.loadProtosFromStuff(config.reward, function() {    
        //wnd.show();
        //});
        var pnlRes = Ext.getCmp('VotePanelFB');
        // подгрузка прототипов предметов
        // подгрузка ресурсов
        ExGods.Resources.load(pnlRes, function() {
            wnd.show();
        });
        return wnd;
    },
    /**
     * Инициализация SDK соц.сети
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: 'https://connect.facebook.net/en_EN/sdk.js',
            onLoad: function() {
                FB.init({
                    appId: config.social.fba,
                    version: config.social.fba_version,
                    status: true,
                    cookie: true
                });
                FB.Event.subscribe('auth.authResponseChange', function() {
                    // загружаю валюту игрока
                    FB.api('/me/?fields=currency', function(data) {
                        if (!data || data.error) {} else //
                        {
                            FB.userCurrency = data.currency;
                        }
                    });
                });
                // загружаю скрипт app events отдела оперирования
                Ext.Loader.loadScript({
                    url: 'https://api.mkt.2rll.net/static/fb_log_event.js',
                    onLoad: function() {
                        InitAppLogEvent(config.social.fba);
                    }
                });
                me.initialized = true;
            }
        });
    },
    /**
     * Клик по картинке фейсбука
     * запуск окна с переданными параметрами
     *
     * @param {Object} thisCls указатель this на xtype компонент
     * @param {Object} meView указатель this на вьюшку
     */
    onimageFBClick: function(thisCls, meView) {
        var me = this;
        // Участок кода где будет само голосование в facebook
        // ...
        //
        window.open(meView.myParams.clientConfig.linkFB, '_blank');
        this.onDestroyWndFB(thisCls, meView);
        var wndSc = Ext.getCmp('socialvotingpanelFBWindowId');
        wndSc.close();
        var myParams = {
                hasVoted: true,
                curVote: meView.myParams.curVote
            };
        var wnd = me.createVoteWindow(meView.myParams.clientConfig, meView.myParams.componentId, myParams);
        wnd.show();
    },
    /**
     * Обработчик забрать награду, после голосования.
     * Игрок получает 100 кристаллов
     *
     * @param {Object} thisCls указатель this на xtype компонент
     * @param {Object} meView указатель this на вьюшку
     */
    onTakeRewardButtonFB: function(thisCls, meView) {
        var me = this;
        // Блокирование кнопки повтора
        Ext.getCmp('socialVoteTakeRewardBtn').setDisabled(1);
        ExGods.Services.get('special_deal').command('use_special_deal', {
            specialdeal: meView.clientConfig.special_deal_name,
            action: meView.clientConfig.special_deal_action
        }, function(data) {
            if (data.success) {
                // Закрытие окна после положительного ответа сервера
                var wnd_ = Ext.getCmp('SOCIAL_VOTE');
                wnd_.close();
            } else {
                // При неудаче запроса, кнопка разблокируется
                Ext.getCmp('socialVoteTakeRewardBtn').setDisabled(0);
            }
        });
    },
    /**
     * Клик по закрытию фейсбука
     *
     * @param {Object} thisCls указатель this на xtype компонент
     * @param {Object} meView указатель this на вьюшку
     *
     */
    onDestroyWndFB: function(thisCls, meView) {
        if (meView.floaterBlock) {
            meView.floaterBlock.destroy();
        }
    },
    /**
     * Функция создания окна для голосования
     *
     * @param {Object} config Объект с информацией сервиса
     * @param {string} componentId ид компонента справочника
     * @param {Object} myParams объект с параметрами окна
     *
     */
    createVoteWindow: function(config, componentId_, myParams_) {
        var cmp = Ext.widget('socialvotingpanel', {
                clientConfig: config,
                componentId: componentId_,
                myParams: myParams_
            });
        var wnd = Ext.widget('window2', {
                id: componentId_,
                cls: 'votingWindow',
                width: 566,
                height: 356,
                autoShow: false,
                items: [
                    cmp
                ]
            });
        return wnd;
    },
    /**
     * Функция шаринга в социальных сетях
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          url: <ссылка для шары>,
     *          image: <url сопроводительной картинки>,
     *          title: <заголовок>,
     *          description: <описание>
     *      }
     */
    share: function(obj) {
        FB.ui(obj);
    },
    /*, callback*/
    /**
     * Функция покупки в социальных сетях
     *
     * @param {Number} Сумма покупки
     */
    buy: function(preset) {
        var me = this;
        FB.ui({
            method: 'pay',
            action: 'purchaseitem',
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&preset_id=' + preset.entry + '&r=' + Math.random(),
            quantity: 1
        }, function(data) {});
    },
    //
    /**
     * Функция постинга в социальные сети
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          image: <url сопроводительной картинки>,
     *          message: <описание>
     *          owner: <id пользователя на чью стену делать пост. Если нет, то пост будет на моей стене>
     *      }
     */
    wallPost: function(obj) {
        var me = this,
            feedData = {
                method: 'feed',
                link: 'https://apps.facebook.com/' + config.social.fba + '/',
                picture: obj.image,
                caption: obj.subject,
                description: obj.message
            };
        if (obj.owner) {
            feedData.to = obj.owner;
        }
        FB.ui(feedData, function(response) {});
    },
    //
    /**
     * метод поста на стену без добавления фотографий
     */
    simpleWallPost: function(obj) {
        var me = this,
            user = me.user;
        FB.ui({
            method: 'feed',
            link: location.href,
            caption: obj.subject,
            description: obj.message
        }, function(response) {});
    },
    //
    /**
     * Пригласить друга в игру
     */
    invite: function(callback) {
        var me = this;
        // запрашиваю список друзей
        FB.api("/me/invitable_friends", function(response) {
            if (response && !response.error) {
                // для каждого френда создаю юзера
                var users = [],
                    defaults = {
                        hoard: me.user.data.hoard
                    };
                response.data.forEach(function(friendData) {
                    users.push(Ext.apply({}, {
                        display_title: friendData.name,
                        shape: {
                            small: friendData.picture.data.url
                        },
                        social: friendData.id
                    }, defaults));
                });
                // показываю список юзеров в окне выбора игрока
                ExGods.Components.factory('USER_TARGET_PANEL', {
                    componentCls: 'fb-invite-list',
                    windowTitle: ExGods.getMsgByKey('invite_friends_window_title'),
                    users: users,
                    listeners: {
                        select: function(wnd, rec) {
                            // приглашаю друга
                            FB.ui({
                                method: 'apprequests',
                                message: ExGods.getMsgByKey('invite_friends_message'),
                                to: rec.data.social
                            }, function(response) {
                                if (response && response.error_code) {} else //
                                {
                                    callback();
                                }
                            });
                            wnd.up().close();
                        }
                    }
                });
            } else {
                /***/
                me.log('error', 'Ошибка при подгрузке списка друзей для инвайта', response);
            }
        });
    },
    /**
     * Подарок френду
     */
    gift: function(preset) {
        var me = this;
        FB.ui({
            method: 'gift',
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&gift=1&preset_id=' + preset.entry + '&r=' + Math.random()
        }, function(data) {});
    },
    //
    /**
     * Проверяет, может ли пользователь использовать промо предложение 
     */
    isCanUsePromo: function(callback) {
        var me = this;
        // запрашиваю user access token 
        FB.getLoginStatus(function(response) {
            if (response.status === 'connected') {
                // запрашиваю поле is_eligible_promo
                me.request({
                    url: 'https://graph.facebook.com/me?fields=is_eligible_promo&access_token=' + response.authResponse.accessToken,
                    success: function(response) {
                        if (response && response.is_eligible_promo) {
                            callback(true);
                        } else {
                            callback(false);
                        }
                    },
                    failure: function() {
                        callback(false);
                    }
                });
            } else {
                /***/
                me.log('error', 'Не могу получить access token пользователя', response);
                callback(false);
            }
        });
    },
    /**
     * Покупка пресета как промо-продукта
     * @param presetEntry {Number}
     * @param callback {Function} Колбек. 
     */
    usePromo: function(presetEntry, callback) {
        var me = this;
        FB.ui({
            action: 'payer_promotion',
            method: 'payer_promotion',
            quantity: 1,
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&preset_id=' + presetEntry + '&r=' + Math.random()
        }, function() {
            if (callback) {
                callback();
            }
        });
    },
    /**
     * Проверяет, может ли пользователь отправить сообщение другому юзеру соц.сети (не обязательно другу)
     */
    isCanSendUserToUserMessage: function() {
        return true;
    },
    /**
     * Отправить сообщение пользователю от другого пользователя (не обязательно друга)
     * @param to {Array} Список ids получателей
     * @param message {String}
     * @param callback {Function} 
     */
    sendUserToUserMessage: function(to, message, callback) {
        FB.ui({
            method: 'apprequests',
            message: message,
            to: to.join(',')
        }, function(response) {
            if (response && !response.error) {
                callback();
            } else {
                /***/
                me.log('error', 'Ошибка отправки сообщения', response);
            }
        });
    },
    /**
     * Обновить размер фрейма
     */
    setSize: function(width, height) {
        FB.Canvas.setSize({
            width: width,
            height: height
        });
    }
});

/**
 * Реализация методов соц.функций для KG
 */
Ext.define('ExGods.controller.social.KG', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'KG:'
    },
    /**
     * Инициализация контроллера. Здесь же происходит инициализация SDK соц.сети
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: 'https://cdn1.kongregate.com/javascripts/kongregate_api.js?2',
            onLoad: function() {
                console.log('load before');
                kongregateAPI.loadAPI(function() {
                    console.log('load after');
                    me.KG = kongregateAPI.getAPI();
                });
            }
        });
    },
    /**
     * Функция шаринга в социальных сетях
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          url: <ссылка для шары>,
     *          image: <url сопроводительной картинки>,
     *          title: <заголовок>,
     *          description: <описание>
     *      }
     */
    share: function(obj) {
        FB.ui(obj);
    },
    /*, callback*/
    /**
     * Функция покупки в социальных сетях
     *
     * @param {Number} Сумма покупки
     */
    buy: function(preset) {},
    // var me = this;
    // FB.ui({
    //  method: 'pay',
    //  action: 'purchaseitem',
    //  product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&preset_id=' + preset.entry + '&r=' + Math.random(),
    //  quantity: 1
    // },
    // function(data) {
    //  //
    // });
    //debugger
    /**
     * Функция постинга в социальные сети
     *
     * @param {Object} obj Объект с информацией для шаринга
     *
     *      {
     *          image: <url сопроводительной картинки>,
     *          message: <описание>
     *          owner: <id пользователя на чью стену делать пост. Если нет, то пост будет на моей стене>
     *      }
     */
    wallPost: function(obj) {
        var me = this,
            feedData = {
                method: 'feed',
                link: 'https://apps.facebook.com/' + config.social.fba + '/',
                picture: obj.image,
                caption: obj.subject,
                description: obj.message
            };
        if (obj.owner) {
            feedData.to = obj.owner;
        }
        FB.ui(feedData, function(response) {});
    },
    //
    /**
     * метод поста на стену без добавления фотографий
     */
    simpleWallPost: function(obj) {
        var me = this,
            user = me.user;
        FB.ui({
            method: 'feed',
            link: location.href,
            caption: obj.subject,
            description: obj.message
        }, function(response) {});
    },
    //
    /**
     * Пригласить друга в игру
     */
    invite: function(callback) {
        var me = this;
        // запрашиваю список друзей
        FB.api("/me/invitable_friends", function(response) {
            if (response && !response.error) {
                // для каждого френда создаю юзера
                var users = [],
                    defaults = {
                        hoard: me.user.data.hoard
                    };
                response.data.forEach(function(friendData) {
                    users.push(Ext.apply({}, {
                        display_title: friendData.name,
                        shape: {
                            small: friendData.picture.data.url
                        },
                        social: friendData.id
                    }, defaults));
                });
                // показываю список юзеров в окне выбора игрока
                ExGods.Components.factory('USER_TARGET_PANEL', {
                    componentCls: 'fb-invite-list',
                    windowTitle: ExGods.getMsgByKey('invite_friends_window_title'),
                    users: users,
                    listeners: {
                        select: function(wnd, rec) {
                            // приглашаю друга
                            FB.ui({
                                method: 'apprequests',
                                message: ExGods.getMsgByKey('invite_friends_message'),
                                to: rec.data.social
                            }, function(response) {
                                if (response && response.error_code) {} else //
                                {
                                    callback();
                                }
                            });
                            wnd.up().close();
                        }
                    }
                });
            } else {
                /***/
                me.log('error', 'Ошибка при подгрузке списка друзей для инвайта', response);
            }
        });
    },
    /**
     * Подарок френду
     */
    gift: function(preset) {
        var me = this;
        FB.ui({
            method: 'gift',
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&gift=1&preset_id=' + preset.entry + '&r=' + Math.random()
        }, function(data) {});
    },
    //
    /**
     * Проверяет, может ли пользователь использовать промо предложение 
     */
    isCanUsePromo: function(callback) {
        var me = this;
        // запрашиваю user access token 
        FB.getLoginStatus(function(response) {
            if (response.status === 'connected') {
                // запрашиваю поле is_eligible_promo
                me.request({
                    url: 'https://graph.facebook.com/me?fields=is_eligible_promo&access_token=' + response.authResponse.accessToken,
                    success: function(response) {
                        if (response && response.is_eligible_promo) {
                            callback(true);
                        } else {
                            callback(false);
                        }
                    },
                    failure: function() {
                        callback(false);
                    }
                });
            } else {
                /***/
                me.log('error', 'Не могу получить access token пользователя', response);
                callback(false);
            }
        });
    },
    /**
     * Покупка пресета как промо-продукта
     * @param presetEntry {Number}
     * @param callback {Function} Колбек. 
     */
    usePromo: function(presetEntry, callback) {
        var me = this;
        FB.ui({
            action: 'payer_promotion',
            method: 'payer_promotion',
            quantity: 1,
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&preset_id=' + presetEntry + '&r=' + Math.random()
        }, function() {
            if (callback) {
                callback();
            }
        });
    },
    /**
     * Проверяет, может ли пользователь отправить сообщение другому юзеру соц.сети (не обязательно другу)
     */
    isCanSendUserToUserMessage: function() {
        return true;
    },
    /**
     * Отправить сообщение пользователю от другого пользователя (не обязательно друга)
     * @param to {Array} Список ids получателей
     * @param message {String}
     * @param callback {Function} 
     */
    sendUserToUserMessage: function(to, message, callback) {
        FB.ui({
            method: 'apprequests',
            message: message,
            to: to.join(',')
        }, function(response) {
            if (response && !response.error) {
                callback();
            } else {
                /***/
                me.log('error', 'Ошибка отправки сообщения', response);
            }
        });
    },
    /**
     * Обновить размер фрейма
     */
    setSize: function(width, height) {
        FB.Canvas.setSize({
            width: width,
            height: height
        });
    }
});

/**
 * Управление звуками.
 */
Ext.define('ExGods.controller.Sound', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Sound:'
    },
    music: true,
    sound: true,
    fadeTime: 2000,
    playing: {},
    init: function(app) {
        var me = this;
        me.music = !!parseInt(me.user.getSetting('music'));
        me.sound = !!parseInt(me.user.getSetting('sound'));
        me.fadeTime = parseInt(ExGods.ref('constants|fade_music_time').value);
        me.user.location.on('entrychanged', me.setMusic, me);
        me.app.on('gamestarted', me.setMusic, me);
        me.app.getBattleBattleController().on('start', function() {
            try {
                me.setMusic();
            } catch (e) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_start').log('@battle Ошибка проигрывания музыки ' + e);
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle Ошибка проигрывания музыки ' + e);
            }
        }, me);
        me.app.getSettingsController().on('settings_saved', function() {
            var music = !!parseInt(me.user.getSetting('music')),
                sound = !!parseInt(me.user.getSetting('sound'));
            me.volume();
            if (music != me.music)  {
                me.toggleMusic();
            }
            
            if (sound != me.sound)  {
                me.toggleSound();
            }
            
        }, me);
        setTimeout(function() {
            Ext.getCmp('tech-info').on('battlefinish', me.setMusic, me);
        }, 0);
        if (/*@cc_on!@*/
        false) {
            // check for Internet Explorer
            document.onfocusin = me.setMusic.bind(me);
            document.onfocusout = me.forseClearMusic.bind(me);
        } else {
            window.onfocus = me.setMusic.bind(me);
            window.onblur = me.forseClearMusic.bind(me);
        }
    },
    /**
     * Воспроизвожу музыку
     */
    setMusic: function() {
        var me = this,
            battle_type = me.app.getBattleBattleController().battle_type,
            soundName = battle_type ? ExGods.references.get('battle_types').get(battle_type).params.images.sound : me.user.location.get('blob').sound,
            sound = ExGods.references.get('sounds').get(soundName),
            repeatFn = function() {
                if (sound.pause) {
                    /***/
                    me.log('Вешаю таймаут на рестарт воспроизведения');
                    me.playing.timeout = setTimeout(function() {
                        /***/
                        me.log('Начинаю проигрывать после рестарта');
                        if (sound.fading)  {
                            me.play(sound.audio, 0, true, true);
                        }
                        else  {
                            me.play(sound.audio);
                        }
                        
                    }, sound.pause * 1000);
                } else {
                    /***/
                    me.log('Воспроизвожу сразу');
                    if (sound.fading)  {
                        me.play(sound.audio, 0, true, true);
                    }
                    else  {
                        me.play(sound.audio);
                    }
                    
                }
            };
        try {
            me.clearMusic(function() {
                if (sound && me.music) {
                    me.play(sound.audio, 0, false, true);
                    me.fadeIn(sound.audio);
                    if (sound.fading) {
                        me.setTimeoutOnFading(sound.audio);
                    }
                    /***/
                    me.log('Начинаю проигрывать музыку');
                    me.playing.music = sound.audio;
                    sound.audio.onended = repeatFn;
                }
            });
        } catch (e) {
            /***/
            me.log('error', 'Ошибка воспроизведения звука ', e);
        }
    },
    /**
     * отменяет воспроизведение текущей музыки
     */
    clearMusic: function(cb) {
        var me = this,
            audio = me.playing.music;
        if (audio) {
            audio.onended = null;
            if (!audio.paused) {
                me.fadeOut(audio, function() {
                    audio.pause();
                    /***/
                    me.log('Музыка остановлена, таймаут очищен');
                    if (cb)  {
                        cb();
                    }
                    
                });
            } else if (cb)  {
                cb();
            }
            
            clearTimeout(me.playing.timeout);
        } else if (cb)  {
            cb();
        }
        
    },
    /**
     * Моментально отменяет воспроизведение текущей музыки
     */
    forseClearMusic: function() {
        var me = this,
            audio = me.playing.music;
        if (audio) {
            audio.onended = null;
            if (!audio.paused) {
                audio.pause();
                /***/
                me.log('Музыка остановлена моментально');
            }
            clearTimeout(me.playing.timeout);
        }
    },
    /**
     * проигрывает звук с начала
     * audio - tag audio
     * volume - громкость 0-100
     * fading - воспроизводить ли затухание в конце и в начале
     * isMusic - флаг, музыка ли это или просто звук
     */
    play: function(audio, volume, fading, isMusic) {
        var me = this;
        if (!me.sound && !isMusic)  {
            return;
        }
        
        if (!me.music && isMusic)  {
            return;
        }
        
        audio.currentTime = 0;
        clearTimeout(audio.fadingTimeout);
        me.volume(typeof volume == 'number' ? volume : me.user.getSetting('volume'), audio);
        try {
            audio.play();
        } catch (e) {}
        
        if (fading) {
            me.fadeIn(audio);
            me.setTimeoutOnFading(audio);
        }
    },
    /**
     * задает громкость
     */
    volume: function(value, audio) {
        audio = audio || this.playing.music;
        value = typeof value == 'number' ? value : this.user.getSetting('volume');
        if (audio) {
            audio.volume = parseInt(value) / 100;
        }
    },
    /**
     * Включает/выключает все звуки
     */
    toggleSound: function(state) {
        var me = this;
        me.sound = state || !me.sound;
        var value = parseInt(new Number(me.sound));
        me.user.setSetting('sound', value);
        ExGods.app.getSettingsController().saveSettings({
            sound: value
        });
    },
    // if(me.sound){
    //  me.setMusic();
    // }else{
    //  me.clearMusic();
    // }
    /**
     * Включает/выключает музыку локации
     */
    toggleMusic: function(state) {
        var me = this;
        me.music = state || !me.music;
        var value = parseInt(new Number(me.music));
        me.user.setSetting('music', value);
        ExGods.app.getSettingsController().saveSettings({
            music: value
        });
        if (me.music) {
            me.setMusic();
        } else {
            me.clearMusic();
        }
    },
    isSoundOff: function() {
        return !this.sound;
    },
    isMusicOff: function() {
        return !this.music;
    },
    fadeIn: function(audio, cb) {
        /***/
        this.log('fading in');
        this.fade(audio, true, cb);
    },
    fadeOut: function(audio, cb) {
        /***/
        this.log('fading out');
        this.fade(audio, false, cb);
    },
    fade: function(audio, increase, cb) {
        var me = this,
            settingVolume = parseInt(me.user.getSetting('volume'));
        clearInterval(audio.fadingInterval);
        audio.fadingInterval = setInterval(function() {
            if (increase) {
                if (audio.volume < settingVolume / 100) {
                    audio.volume = Math.min(audio.volume + 0.01, settingVolume / 100);
                } else {
                    clearInterval(audio.fadingInterval);
                    if (cb)  {
                        cb();
                    }
                    
                }
            } else {
                if (audio.volume != 0) {
                    audio.volume = Math.max(audio.volume - 0.01, 0);
                } else {
                    clearInterval(audio.fadingInterval);
                    if (cb)  {
                        cb();
                    }
                    
                }
            }
        }, me.fadeTime / settingVolume);
    },
    setTimeoutOnFading: function(audio) {
        var me = this;
        audio.fadingTimeout = setTimeout(me.fadeOut.bind(me, audio), audio.duration * 1000 - me.fadeTime - 50);
        /*лаг небольшой*/
        audio.onpause = function() {
            clearTimeout(audio.fadingTimeout);
        };
    }
});

Ext.define('ExGods.model.SpecialDeal', {
    extend: Ext.data.Model,
    idProperty: 'label',
    fields: [
        {
            name: 'actions',
            type: 'auto'
        },
        {
            name: 'time',
            type: 'number'
        },
        {
            name: 'ended',
            type: 'date',
            convert: function(v, rec) {
                if (v) {
                    v = Ext.Date.parse(v, 'YmdHis') || Ext.Date.parse(v, 'Y-m-d H:i:s');
                    var calcTime = function() {
                            return Math.floor(Math.max((ExGods.util.Date.normalizeServerDateTime(v).getTime() - new Date().getTime()) / 1000 + 2, 0));
                        },
                        time = calcTime();
                    rec.set('time', time);
                    if (time > 0) {
                        var _onTick = function() {
                                var time = calcTime();
                                if (time > 1) {
                                    rec.set('time', --time);
                                    rec.fireEvent('timechanged', time, rec);
                                } else {
                                    ExGods.util.Ticker.removeListener(rec.timer);
                                    rec.fireEvent('removed');
                                    var i = rec.stores.length;
                                    while (i > 0) {
                                        i--;
                                        rec.stores[i].remove(rec);
                                    }
                                }
                            };
                        setTimeout(function() {
                            rec.timer = ExGods.util.Ticker.addListener(_onTick, rec);
                            _onTick();
                        }, 0);
                    }
                }
                return v;
            }
        },
        {
            name: 'params',
            type: 'auto'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'value',
            type: 'number'
        },
        {
            name: 'expanded',
            type: 'boolean'
        }
    ]
});

Ext.define('ExGods.view.special_deal.Item', {
    extend: Ext.Component,
    alias: 'widget.specialdealitem',
    height: 302,
    margin: '5px 4px -3px',
    style: {
        position: 'relative',
        overflow: 'hidden'
    },
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<tpl if="title">',
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="paper-title">',
            '<h4>{title}</h4>',
            '</div>',
            '<div class="deal-big-image" style="background-image:url({[IMAGE_URL + values.params.image2]})">',
            '<div class="deal-big-image-border"></div>',
            '</div>',
            '<div class="deal-info">',
            '<p>{[new Ext.XTemplate(values.params.description).apply()]}</p>',
            '<div id="button-place">',
            '<tpl if="time">',
            '<p class="deal-info-timer">' + ExGods.getMsgByKey('view_specialdeal_item_rest') + ' <span class="dropdown">{[Ext.util.Format.countdown(values.time,{format:"threenums"})]}</span></p>',
            '</tpl>',
            '<tpl for="actions">',
            '<div id="button-place-{[xindex]}"></div>',
            '</tpl>',
            '</div>',
            '</div>',
            '<tpl else>',
            '<p class="central-window-empty deal-empty">{emptyText}</p>',
            '</tpl>'
        ];
        me.callParent(arguments);
    },
    setRecord: function(record, currentRecord) {
        var me = this;
        //если есть текущий рекорд - то отписываю его от обновления
        if (currentRecord) {
            currentRecord.un('timechanged', me.formatTime, me);
        }
        if (record) {
            me.update(record.data);
            if (me.rendered) {
                me.renderSubmitButton(record);
            } else {
                me.on('afterrender', me.renderSubmitButton.bind(me, record), me, {
                    single: true
                });
            }
            record.on('timechanged', me.formatTime, me);
            me.mon(record.store, 'remove', function(store, removedRecord) {
                if (removedRecord.id == record.id) {
                    record.un('timechanged', me.formatTime, me);
                }
            });
        } else {
            me.update({
                emptyText: me.emptyText
            });
        }
    },
    formatTime: function(time, record) {
        var me = this;
        if (me.el) {
            var dropdown = me.el.down('.dropdown');
            if (dropdown) {
                if (time > 0) {
                    dropdown.update(Ext.util.Format.countdown(time, {
                        format: 'threenums'
                    }));
                }
            }
        }
    },
    renderSubmitButton: Ext.Function.createBuffered(function(record) {
        var me = this,
            params = {},
            renderInner = function(text) {
                Ext.each(record.get('actions'), function(action, i) {
                    if (action.hidden != 1) {
                        Ext.widget('textbutton', {
                            cls: 'no_border_double x-btn-text-green',
                            style: {
                                margin: '0 -50px',
                                left: '50%'
                            },
                            text: text ? text : action.label_button,
                            action: action,
                            data: record.data,
                            renderTo: 'button-place-' + (i + 1)
                        }).on('click', function(cmp) {
                            me.fireEvent('btnclick', cmp);
                        });
                    }
                });
            };
        if (!me.isVisible())  {
            return;
        }
        
        if (record.data.params.promo && isSocialApp) {
            ExGods.app.getSocialController().isCanUsePromo(function(canUse) {
                renderInner(canUse ? ExGods.getMsgByKey('view_specialdeal_use_promo_btn_text') : null);
            });
        } else {
            renderInner();
        }
    }, // if(action.desc_button){
    //  var tpl = new Ext.XTemplate('<p class="deal-btn-desc">'+action.desc_button+'</p>');
    //  tpl.append(me.el.down('#button-place-'+(i+1)),{});
    // }
    // .el.set({
    //  'data-qh_otype':'tutorial_quests',
    //  'data-qh_oid':'1',
    //  'data-qh_opts': "{&quot;cls&quot;:&quot;flip-h&quot;}"
    // });
    300),
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        // на случай если геймдизайнеры не заполнили картинки надо проверять вообще есть ли параметры
        if (me.data.params) {
            if (me.data.params.image) {
                arr_images.push(me.data.params.image);
            }
            if (me.data.params.image2) {
                arr_images.push(me.data.params.image2);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.special_deal.List', {
    extend: Ext.view.View,
    alias: 'widget.specialdeallist',
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<ul class="deal-items">',
            '<tpl for=".">',
            '<li class="deal-item">',
            '<div class="item_info deal-info-btn"></div>',
            '<div class="deal-image" style="background-image:url({[IMAGE_URL + values.params.image]})"></div>',
            '<tpl if="time">',
            '<div class="deal-timer">',
            '<span class="dropdown">{[Ext.util.Format.countdown(values.time,{format:"short"})]}</span>',
            '</div>',
            '</tpl>',
            '</li>',
            '</tpl>',
            '</ul>'
        ];
        me.itemSelector = 'li';
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var i = 0; i < me.dataSource.data.items.length; i++) {
            arr_images.push(me.dataSource.data.items[i].data.params.image);
            arr_images.push(me.dataSource.data.items[i].data.params.image2);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Контроллер специальных предложений
 */
Ext.define('ExGods.controller.SpecialDeal', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: false,
        prefix: 'SpecialDealController:'
    },
    models: [
        'SpecialDeal'
    ],
    views: [
        'special_deal.List',
        'special_deal.Item',
        'TextButton'
    ],
    refs: [
        {
            ref: 'mainMenu',
            selector: '#mainmenu'
        },
        {
            /**
         * @method getDealContainer
         */
            ref: 'dealContainer',
            selector: '#specialdealcontainer'
        }
    ],
    //текущее раскрытое спецпредложение
    shownRecord: false,
    init: function() {
        var me = this;
        me.service = ExGods.Services.get('special_deal');
        me.service.on('update', me.onServiceUpdate, me);
        me.app.getSpecialDealsStore().loadRawData(me.service.data.special_deal);
        me.control({
            'specialdealitem': {
                btnclick: me.onActionClick
            },
            '#specialdealcontainer': {
                prev: me.setPager.bind(me, -1),
                next: me.setPager.bind(me, 1)
            },
            'specialdeallist': {
                itemclick: me.setRecord
            }
        });
        me.app.chatcn.on('command_refresh_special_deal', me.requestDeals, me);
        ExGods.Components.addComponentInitializer('special_deal', me.initSpecialDealComponent, me);
    },
    onLaunch: function() {
        this.resetDealTimer();
    },
    onServiceUpdate: function() {
        var me = this,
            deals = me.service.data.special_deal;
        //q = [];
        //if(deals.length)
        //q = deals.concat([deals[0],Ext.apply(Ext.clone(deals[0]),{title:'qq',name:'qq',ended:'2014-10-15 13:39:29'}),deals[0],deals[0],deals[0],deals[0]])
        me.app.getSpecialDealsStore().loadRawData(deals);
        me.resetDealTimer();
    },
    onActionClick: function(cmp) {
        var me = this,
            conf = cmp.action.confirm,
            store = me.app.getSpecialDealsStore(),
            useSpecialDeal = function() {
                me.service.command('use_special_deal', {
                    specialdeal: cmp.config.data.name,
                    action: cmp.action.action
                }, function(data) {
                    if (data.specialdeal) {
                        store.loadRawData(data.special_deal);
                        me.resetViews();
                    }
                });
            },
            okHandler = function() {
                if (cmp.config.data.params.promo && isSocialApp) {
                    me.app.getSocialController().isCanUsePromo(function(canUse) {
                        if (canUse) {
                            me.app.getSocialController().usePromo(cmp.config.data.params.promo, function() {
                                me.service.update(null, function() {
                                    me.resetViews(true);
                                });
                            });
                        } else {
                            useSpecialDeal();
                        }
                    });
                } else {
                    useSpecialDeal();
                }
            };
        if (conf && conf.confirmated) {
            Ext.widget('confirmdialog', {
                message: new Ext.XTemplate(conf.confirmated).apply(),
                buttonsText: [
                    conf.btn_yes || ExGods.getMsgByKey('yes_btn_text'),
                    conf.btn_no || ExGods.getMsgByKey('no_btn_text')
                ],
                handler: okHandler
            });
        } else {
            okHandler();
        }
    },
    requestDeals: function() {
        var me = this;
        me.service.update(null, function() {
            me.resetViews();
        });
    },
    resetViews: function(opening) {
        var me = this,
            cmp = me.getDealContainer(),
            store = me.app.getSpecialDealsStore(),
            record;
        if (cmp) {
            me.currentStartIndex = 0;
            me.setPager();
            record = store.getAt(0);
            if (opening || !me.checkExisitingActiveRecord()) {
                cmp.down('specialdealitem').setRecord(record, me.shownRecord);
            }
            me.shownRecord = record || false;
        }
        me.resetDealTimer();
    },
    setRecord: function(dataview, record, dom, index, e) {
        var me = this,
            cmp = me.getDealContainer();
        if (!me.shownRecord || !record || me.shownRecord.get('name') != record.get('name')) {
            cmp.down('specialdealitem').setRecord(record, me.shownRecord);
        }
        me.shownRecord = record;
    },
    checkExisitingActiveRecord: function() {
        var me = this,
            cmp = me.getDealContainer(),
            valid = false,
            store = me.app.getSpecialDealsStore();
        if (!me.shownRecord)  {
            return valid;
        }
        
        store.each(function(rec) {
            if (rec.get('name') == me.shownRecord.get('name'))  {
                valid = true;
            }
            
        });
        return valid;
    },
    setPager: function(sign) {
        var me = this,
            cmp = me.getDealContainer(),
            store = me.app.getSpecialDealsStore();
        if (cmp) {
            sign = sign || 0;
            me.currentStartIndex += sign;
            cmp.pager.refresh();
            store.clearFilter();
            store.addFilter(me._filter);
        }
    },
    /**
     * @private
     * Запускает таймер до конца ближайшего специального предложения (отображается на пункте "Специальные предложения" основного меню)
     */
    setDealTimer: function() {
        var me = this,
            store = ExGods.app.getSpecialDealsStore(),
            time = Infinity,
            rec;
        store.each(function(item) {
            var left = item.get('time');
            if (left > 0 && left < time) {
                time = left;
                rec = item;
            }
        });
        if (rec) {
            ExGods.util.Helper.startMenuTimer('mainmenu-special_deal-button', 'deal-timer', rec.get('ended'));
        }
        setTimeout(function() {
            var btn = Ext.getCmp('mainmenu-special_deal-button');
            if (store.getCount()) {
                btn.disabledByController = false;
                btn.enable();
            } else {
                btn.disabledByController = true;
                btn.disable();
            }
            if (ExGods.app.user.isBattle()) {
                me.getMainMenu().disableMenu();
            }
        }, 0);
    },
    unsetDealTimer: function() {
        ExGods.util.Helper.stopMenuTimer('deal-timer');
    },
    resetDealTimer: function() {
        this.unsetDealTimer();
        this.setDealTimer();
    },
    initSpecialDealComponent: function(config) {
        var me = this,
            store = me.app.getSpecialDealsStore(),
            cmp,
            wnd = Ext.getCmp('SPECIAL_DEAL');
        ExGods.app.block();
        me.currentStartIndex = 0;
        me._filter = Ext.util.Filter({
            filterFn: function(rec) {
                return store.indexOf(rec) >= me.currentStartIndex && store.indexOf(rec) < me.currentStartIndex + 4;
            },
            id: '_filter'
        });
        store.addFilter(me._filter);
        cmp = {
            xtype: 'container',
            id: 'specialdealcontainer',
            plugins: [
                {
                    ptype: 'pager',
                    marginLeft: -27,
                    marginRight: -27,
                    hidden: 1,
                    top: 335
                }
            ],
            service: me.service,
            items: [
                {
                    xtype: 'specialdealitem',
                    emptyText: config.emptyText,
                    service: me.service
                },
                {
                    xtype: 'specialdeallist',
                    store: store,
                    service: me.service
                }
            ],
            onDestroy: function() {
                this.mun(store, 'datachanged');
                this.callParent(arguments);
            }
        };
        if (wnd)  {
            wnd.close();
        }
        
        wnd = Ext.widget('window2', {
            id: 'SPECIAL_DEAL',
            items: [
                cmp
            ],
            autoShow: false
        });
        cmp = wnd.down('container');
        cmp.mon(store, 'datachanged', function() {
            cmp.pager.total = store.totalCount - 3;
            cmp.pager.hidden = store.totalCount > 4 ? 0 : 1;
            if (!cmp.pager.hidden)  {
                cmp.pager.showArrows();
            }
            else  {
                cmp.pager.hideArrows();
            }
            
            me.resetDealTimer();
        });
        cmp.mon(store, 'remove', function(store, record) {
            if (me.shownRecord.id == record.id) {
                me.resetViews();
            } else {
                me.resetDealTimer();
            }
        });
        me.service.update(null, function() {
            me.resetViews(true);
            ExGods.Resources.load(wnd, function() {
                wnd.show();
                ExGods.app.unblock();
            });
        });
        return wnd;
    }
});

/**
 * Управление набеганием ботов
 */
Ext.define('ExGods.controller.Surging', {
    extend: ExGodsCore.controller.Base,
    mixins: [
        ExGods.util.Flags
    ],
    views: [],
    //
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Surging'
    },
    stores: [
        'Monster'
    ],
    init: function() {
        var me = this;
        me.app.getChatConnection().on({
            command_surging_update: me.onSurgingUpdate,
            command_update_surging_service: me.onUpdateSurgingService,
            command_surging_update_wait: me.onSurginWait,
            scope: me
        });
        ExGods.app.user.location.on({
            'locationchanged': me.onLocationChange,
            //'entrychanged' : me.onLocationEntryChange,
            scope: me
        });
        ExGods.app.getBattleBattleController().on('finish', function() {
            ExGods.app.getChatConnection().ping();
        });
        me.initService();
        me.callParent(arguments);
    },
    initService: function() {
        var me = this,
            service,
            _bindEvents = function(service) {
                service.on('init', me.onServiceInit, me);
                service.on('update', me.onServiceUpdate, me);
            };
        _unbindEvents = function(service) {
            service.un('init', me.onServiceInit, me);
            service.un('update', me.onServiceUpdate, me);
        };
        service = me.app.getController('Location').getBindableServices('surging');
        if (service && service.length) {
            service = service[0];
            if (!me.service || me.service.id != service.id) {
                if (me.service) {
                    _unbindEvents(me.service);
                }
                _bindEvents(service);
                me.service = service;
                me.service.init();
            }
        } else {
            if (me.service) {
                _unbindEvents(me.service);
                me.service = null;
            }
        }
    },
    onServiceInit: function() {
        var me = this;
        me.updateStore();
    },
    onServiceUpdate: function() {
        var me = this;
        me.updateStore();
    },
    onLocationChange: function() {
        var me = this,
            waitEl = document.getElementById('surging_wait'),
            imageEl = document.getElementById('surging_image');
        me.initService();
        if (!me.service) {
            me.getMonsterStore().removeAll();
        }
        delete me.surging_wait;
        if (waitEl)  {
            waitEl.remove();
        }
        
        if (imageEl)  {
            imageEl.remove();
        }
        
        ExGods.app.getChatConnection().ping();
    },
    updateStore: function() {
        var me = this,
            store = me.getMonsterStore(),
            quest_bots = me.user.location.get('quest_bots'),
            battle_chain = me.app.getController('BattleChain').getSurgingChainEntry();
        if (!me.app.getController('Location').isLocked()) {
            store.removeAll();
            ExGods.Resources.load(me, function() {
                store.removeAll();
                if (quest_bots && quest_bots.length) {
                    store.add(quest_bots);
                }
                if (battle_chain) {
                    store.add(Ext.clone(battle_chain));
                }
                if (me.service && me.service.data && me.service.data.surging) {
                    store.add(me.service.data.surging);
                }
                if (me.surging_wait && !store.data.length) {
                    store.add({
                        'wait': me.surging_wait
                    });
                }
            });
        }
    },
    // if (store.getCount() && !Ext.getCmp('LOB_BOT_LIST')) {                   
    //  ExGods.Components.factory('LOB_BOT_LIST', {
    //      x: 757,
    //  });
    // }
    onSurgingUpdate: function(chatcn, data) {
        var me = this;
        /***/
        me.log('Команда чата "обновить данные сервиса набеганий"', data);
        if (me.service) {
            me.service.update({
                surging: data.body.surging
            });
        }
    },
    onUpdateSurgingService: function() {
        var me = this;
        /***/
        me.log('Команда чата "запросить данные сервиса набеганий"');
        if (me.service) {
            me.service.update();
        }
    },
    onSurginWait: function(chatObj, data) {
        var me = this;
        if (data.body.wait)  {
            me.surging_wait = data.body.wait + new Date() / 1000 + 1;
        }
        else if (data.body.wait == 0)  {
            ExGods.app.getChatConnection().ping();
        }
        
        if (!me.app.getController('Location').isLocked()) {
            me.updateStore();
        }
    },
    getResources: function() {
        var me = this,
            images = [],
            stuff = [],
            shapeRef = ExGods.ref('user_shape');
        if (me.service && me.service.data && me.service.data.surging && me.service.data.surging.length) {
            Ext.Array.each(me.service.data.surging, function(item) {
                var shape = shapeRef.getByKey(item.shape);
                if (shape) {
                    images.push(shape.thumb);
                    images.push(shape.full);
                }
                if (item.reward_banish && item.reward_banish.length) {
                    for (var i = 0; i < item.reward_banish.length; i++) {
                        stuff = stuff.concat(item.reward_banish[i]);
                    }
                }
                if (item.stuff && item.stuff.length) {
                    stuff = stuff.concat(item.stuff);
                }
            });
        }
        return {
            images: images,
            stuff: stuff
        };
    }
});

/**
 * Телепорт
 */
Ext.define('ExGods.view.teleport.Teleport', {
    extend: Ext.panel.Panel,
    alias: 'widget.teleport',
    header: false,
    ui: 'teleport',
    /**
     * @property {Object} positions
     * Кординаты расположения миров на карте
     */
    positions: {
        world_cradle: {
            x: 28,
            y: 153
        },
        world_eagle: {
            x: 104,
            y: 19
        },
        world_lion: {
            x: 176,
            y: 197
        },
        world_volcano: {
            x: 239,
            y: 68
        },
        world_dust: {
            x: 0,
            y: 0
        }
    },
    layout: 'absolute',
    margin: '0 10 10 0',
    x: 5,
    y: 3,
    plugins: [
        'irondeco'
    ],
    /**
     * @cfg {ExGods.store.Locations} locations
     * Локации
     */
    /**
     * @cfg {ExGods.model.User} user
     * Пользователь
     */
    /**
     * @cfg {ExGods.store.Worlds} worlds
     * Миры
     */
    /**
     * @cfg {ExGods.store.Worlds} backImg
     * Фон
     */
    initComponent: function() {
        var me = this;
        me.store = Ext.create('Ext.data.Store', {
            fields: [
                {
                    name: 'conditions',
                    type: 'auto'
                },
                {
                    name: 'entry',
                    type: 'int'
                },
                {
                    name: 'name',
                    type: 'string'
                },
                {
                    name: 'price',
                    type: 'auto'
                },
                {
                    name: 'rid',
                    type: 'int'
                },
                {
                    name: 'wid',
                    type: 'int'
                }
            ],
            groupField: 'wid'
        });
        me.style = {
            overflow: 'visible',
            backgroundImage: "url(" + IMAGE_URL + me.backImg + ")",
            backgroundRepeat: "no-repeat",
            backgroundPosition: '5px 5px'
        };
        me.callParent();
        me.on('afterrender', function(cmp) {
            var mapActionBtns = cmp.el.query('.world');
            if (mapActionBtns) {
                mapActionBtns.forEach(function(bnt) {
                    cmp.el.down('#' + bnt.id).set({
                        'data-qh_otype': 'world',
                        'data-qh_oid': bnt.id.split('_')[1]
                    });
                });
            }
        });
    },
    /**
     * Обновить вью в соответствии с данными
     * @param {Object} data Данные телепорта
     */
    setData: function(data) {
        var me = this,
            items = [];
        me.store.loadRawData(data.blob);
        items.push({
            width: 575,
            height: 354,
            margin: '0 0 0 0',
            x: 4,
            y: -1,
            style: {
                backgroundImage: "url(" + ExGods.ref('images|teleport_images').image.bg + ")",
                backgroundRepeat: "no-repeat"
            }
        });
        me.worlds.each(function(world) {
            if (!world.isVisible())  {
                return;
            }
            
            var blob = world.get('blob'),
                position = me.positions[world.get('name')],
                menu = [],
                worldItems;
            worldItems = me.store.queryBy(function(item) {
                return item.data.wid == world.get('entry');
            });
            if (worldItems.length) {
                worldItems.each(function(room) {
                    menu.push({
                        action: 'teleport',
                        locationEntry: room.get('entry'),
                        teleportEntry: parseInt(data.entry),
                        text: '<span class="teleport-destination"><span class="label">' + room.get('name') + '</span></span>'
                    });
                });
            }
            items.push({
                xtype: 'button',
                cls: 'qh-object world',
                icon: world.getImage(),
                pressed: world.get('entry') == me.world.get('entry') ? true : false,
                text: ' ',
                // иначе будет ошибка на iPad. TODO: разобраться с этим
                tooltip: !isMobile ? world.get('title') : undefined,
                world: world,
                id: 'world_' + world.get('entry'),
                width: 160,
                height: 150,
                x: position ? position.x : 0,
                y: position ? position.y : 0,
                menu: menu.length ? {
                    bodyPadding: '0 17 0 18',
                    closable: true,
                    closeAction: 'hide',
                    cls: 'teleport-menu',
                    defaults: {
                        border: 0
                    },
                    items: menu,
                    padding: 0,
                    plugins: [
                        'windeco'
                    ],
                    showSeparator: false,
                    width: 200,
                    height: 172,
                    showBy: function(cmp, pos, off) {
                        var me = this,
                            teleport = this.up('teleport');
                        if (me.floating && cmp) {
                            me.show();
                            // Align to Component or Element using setPagePosition because normal show
                            // methods are container-relative, and we must align to the requested element
                            // or Component:
                            // me.setPagePosition(me.el.getAlignToXY(cmp.el || cmp, pos || me.defaultAlign, off));
                            // me.setVerticalPosition();
                            var position = me.el.getAlignToXY(teleport.el || teleport, pos || me.defaultAlign, off);
                            position[0] += 240;
                            position[1] -= 270;
                            me.setPagePosition(position);
                        }
                        return me;
                    }
                } : undefined,
                listeners: {
                    menushow: function(button) {
                        ExGods.util.Helper.maskElement(button.up().el);
                    },
                    menuhide: function(button) {
                        button.up().el.unmask();
                    }
                }
            });
        });
        me.removeAll();
        me.add({
            xtype: 'panel',
            plugins: [
                'skindeco'
            ],
            itemId: 'teleports-container',
            cls: 'panel_with_teleports',
            closable: true,
            width: 580,
            height: 355,
            margin: '0 0 0 0',
            x: 245,
            y: 15,
            items: items,
            listeners: {
                beforeclose: {
                    fn: function() {
                        me.close();
                        return false;
                    }
                }
            }
        }, {
            xtype: 'panel',
            layout: 'anchor',
            y: 372,
            style: {
                textAlign: 'center'
            },
            margin: '0 0 0 250',
            items: [
                {
                    height: 30,
                    xtype: 'textbutton',
                    text: me.closeText,
                    cls: (me.closeColor) ? 'x-btn-txt-' + me.closeColor : '',
                    handler: function(btn) {
                        me.close();
                    }
                }
            ]
        });
    },
    getResources: function() {
        var me = this,
            images = [];
        images.push(IMAGE_URL + '/teleport_map.png');
        images.push(me.backImg);
        var imgs_ = ExGods.ref('images|teleport_images').image;
        for (var it in imgs_) {
            images.push(imgs_[it]);
        }
        me.worlds.each(function(world) {
            images.push(world.getImage());
        });
        return {
            images: images
        };
    }
});

/**
 * Телепорт
 */
Ext.define('ExGods.view.teleport.TeleportWithTimed', {
    extend: Ext.panel.Panel,
    alias: 'widget.teleport_with_timed',
    /**
     * @cfg service Данные сервиса телепортов
     */
    cls: 'teleport-with-timed',
    /**
      * @property {Object} selectedItem Данные выбранного телепорта
      */
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'component',
                autoEl: 'ul',
                cls: 'teleports-list',
                tpl: [
                    '<tpl for=".">',
                    '<li style="background-image: url(' + IMAGE_URL + '{image})" class="{[ values.message ? "disabled" : "" ]}" data-index="{[ xindex ]}">',
                    '<div class="title">',
                    '<div>&nbsp;</div>',
                    '<span>{[ values.name.toUpperCase() ]}</span>',
                    '</div>',
                    '</li>',
                    '</tpl>'
                ],
                data: me.service.teleports.blob,
                height: 226,
                listeners: {
                    afterrender: me.onListRendered,
                    scope: me
                }
            },
            {
                xtype: 'container',
                layout: {
                    type: 'hbox',
                    align: 'stretch'
                },
                flex: 1,
                margin: '0 0 4 0',
                items: [
                    {
                        xtype: 'panel',
                        plugins: [
                            'paperdeco'
                        ],
                        width: 451,
                        margin: '0 0 0 13',
                        layout: 'fit',
                        items: [
                            {
                                xtype: 'component',
                                cls: 'description',
                                itemId: 'teleportDescription',
                                tpl: [
                                    '<tpl if="item">',
                                    '<div class="paper-title">' + ExGods.getMsgByKey('teleport_with_timed_title') + '<div>',
                                    '<div class="stuff-list">',
                                    '{[ ExGods.stuff.StuffManager.image(values.item.description_stuff) ]}',
                                    '</div>',
                                    '<tpl else>',
                                    '<p>' + (me.clientConfig.teleport_select_desc || ExGods.getMsgByKey("teleport_with_timed_description")) + '</p>',
                                    '</tpl>'
                                ],
                                data: {}
                            }
                        ]
                    },
                    {
                        xtype: 'timedtimer',
                        itemId: 'timedTimer',
                        timed: me.service.teleports.blob[0].price[0].params.id,
                        quantity: me.service.teleports.blob[0].price[0].params.quantity,
                        is_disabled: true,
                        width: 100,
                        textbutton: {
                            cls: 'x-btn-txt double_text_btn',
                            text: me.clientConfig.teleportBtnText,
                            handler: function() {
                                me.fireEvent('teleport-gogo', me, me.selectedItem);
                            }
                        },
                        buybutton: {
                            cls: 'x-btn-txt double_text_btn',
                            text: me.clientConfig.teleportBtnText
                        },
                        margin: '5 0 0 4'
                    }
                ]
            }
        ];
        me.callParent();
    },
    /**
     * @private
     */
    onListRendered: function(listView) {
        var me = this;
        listView.el.on('click', function(e, el) {
            var descr = me.down('#teleportDescription'),
                timedTimer = me.down('#timedTimer'),
                item;
            el = Ext.get(el);
            if (!el.hasCls('disabled') && !el.hasCls('selected')) {
                item = me.service.teleports.blob[el.dom.getAttribute('data-index') - 1];
                listView.el.select('li').removeCls('selected');
                el.addCls('selected');
                descr.update({
                    item: item
                });
                timedTimer.setEnable();
                me.selectedItem = item;
            }
        }, me, {
            delegate: 'li'
        });
    },
    /**
     * Ресурсы вью
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            images = [];
        Ext.Array.each(me.service.teleports.blob, function(item) {
            images.push(item.image);
            if (item.description_stuff) {
                stuff_arr = stuff_arr.concat(item.description_stuff);
            }
            if (item.price) {
                stuff_arr = stuff_arr.concat(item.price);
            }
        });
        return {
            stuff: stuff_arr,
            images: images
        };
    }
});

/**
 * Контроллер телепорта
 */
Ext.define('ExGods.controller.Teleport', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Teleport:'
    },
    views: [
        'ConfirmationDialog',
        'teleport.Teleport',
        'teleport.TeleportWithTimed'
    ],
    stores: [
        'Quests'
    ],
    refs: [
        {
            /**
         * @private
         * @method getLocationView
         * Получает вьюшку локации
         * @return {ExGods.view.location.Location}
         */
            ref: 'locationView',
            selector: 'locationview'
        }
    ],
    init: function() {
        var me = this;
        me.listen({
            component: {
                'teleport #teleports-container button': {
                    click: me.checkTeleport
                },
                'teleport menuitem[action="teleport"]': {
                    click: me.teleport
                }
            }
        });
        ExGods.Components.addComponentInitializer('teleport', me.initTeleportComponent, me);
        ExGods.Components.addComponentInitializer('teleport_with_timed', me.initTeleportWithTimedComponent, me);
    },
    /**
     * Проверяет возможность телепортации
     */
    checkTeleport: function(button) {
        var me = this;
        if (button.pressed)  {
            return false;
        }
        
        if (!button.menu) {
            me.application.fireEvent('logmessage', 'В ' + button.world.get('title') + ' невозможно попасть при помощи этого Портала');
            return false;
        } else {
            // Временный хак, пока не будет сделано оформление меню телепорта
            button.menu.hide();
            Ext.widget('confirmdialog', {
                message: Ext.String.format(ExGods.getMsgByKey('teleport_confirm_tp'), button.world.get('title')),
                handler: function() {
                    var menuItem = button.menu.items.first();
                    me.teleport(menuItem.locationEntry);
                }
            });
        }
    },
    /**
     * Осуществляет телепортацию
     * 
     * @param {String} locationEntry
     */
    teleport: function(locationEntry) {
        var me = this;
        /***/
        me.log('Выполняю запрос на телепортацию');
        ExGods.app.getController('Location').maskLocation(function() {
            //ExGods.app.block();
            me.service.command('teleport', {
                teleport_id: me.service.data.teleports.entry,
                entry: locationEntry
            }, {
                beforeKeyHandlers: function(json) {
                    //ExGods.app.unblock();
                    if (json.success) {
                        /***/
                        me.log('телепорт осуществлён.');
                        me.fireEvent('teleport', me);
                    }
                    // выкидываю событие телепортации
                    if (!json.success || json.msg) {
                        // снимаю маску сам если ответ от сервера отрицательный. Иначе маска снимится при переирсовке локации
                        ExGods.app.getController('Location').unmaskLocation();
                    }
                }
            });
        }, {
            img: me.maskImage
        });
    },
    /**
     * Иициализатор компонента "teleport"
     */
    initTeleportComponent: function(config, componentId) {
        var me = this,
            cmp, wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        Ext.apply(config, {
            user: me.getUser(),
            world: me.getWorld(),
            worlds: me.app.getWorldsStore(),
            listeners: {
                beforeclose: function() {
                    ExGods.loaderCt.loadAndRemove(function() {
                        wnd.close();
                    }, {
                        img: me.maskImage
                    });
                    return false;
                }
            }
        });
        cmp = Ext.apply({
            xtype: 'teleport'
        }, config);
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ]
        });
        cmp = wnd.down('teleport');
        cmp.setData(me.service.data.teleports);
        cmp.mon(me, 'teleport', function() {
            wnd.destroy();
        });
        me.maskImage = config.backImg;
        ExGods.app.getController('Location').maskLocation(function() {
            // подгрузка ресурсов
            ExGods.Resources.load(wnd, function() {
                wnd.show();
                ExGods.app.getController('Location').unmaskLocation();
            });
        }, {
            img: me.maskImage
        });
        return wnd;
    },
    /**
     * Иициализатор компонента "teleport_with_timed" - телепорт с таймедом
     */
    initTeleportWithTimedComponent: function(config, componentId) {
        var me = this,
            cmp, wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        me.clientConfig = config;
        cmp = {
            xtype: 'room',
            rightPanelX: 245,
            margin: '0 10 10 0',
            backgroundImage: config.backImg,
            closeText: config.closeText,
            closeColor: config.closeColor,
            closeCallback: function() {
                wnd.close();
            },
            items: [
                {
                    xtype: 'teleport_with_timed',
                    width: 579,
                    height: 353,
                    y: 15,
                    x: 245,
                    plugins: [
                        'skindeco'
                    ],
                    closable: true,
                    teleportBtnText: config.teleportBtnText,
                    clientConfig: me.clientConfig,
                    service: me.service.data,
                    listeners: {
                        beforeclose: {
                            fn: function() {
                                wnd.close();
                                return false;
                            },
                            single: true
                        },
                        'teleport-gogo': function(view, data) {
                            me.teleport(data.entry);
                        },
                        scope: me
                    }
                }
            ]
        };
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ],
            listeners: {
                beforeclose: {
                    fn: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            wnd.close();
                        }, {
                            img: me.maskImage
                        });
                        return false;
                    },
                    single: true
                }
            }
        });
        cmp = wnd.down('room');
        cmp.mon(me, 'teleport', function() {
            wnd.destroy();
        });
        me.maskImage = config.backImg;
        ExGods.app.getController('Location').maskLocation(function() {
            // подгрузка прототипов предметов
            var stuff = [];
            Ext.Array.each(me.service.data.teleports.blob, function(item) {
                stuff = stuff.concat(item.description_stuff);
            });
            ExGods.helpme.loadProtosFromStuff(stuff, function() {
                // подгрузка ресурсов
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: me.maskImage
        });
        return wnd;
    }
});

/**
 * Контроллер меню tools
 *
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.ToolsMenu', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: true,
            error: true
        },
        prefix: 'ToolsMenu:'
    },
    refs: [
        {
            ref: 'toolsMenu',
            selector: '#tools-menu'
        }
    ],
    init: function() {
        var me = this;
        me.listen({
            controller: {
                '#Settings': {
                    settings_saved: me.refreshView
                }
            },
            component: {
                '#tools-menu': {
                    afterrender: me.refreshView
                },
                '#tools-menu button': {
                    click: me.onMenuButtonClick,
                    langselect: me.onLangSelect
                }
            }
        });
        me.viewportController = me.app.getViewportController();
        me.soundController = me.app.getSoundController();
        me.callParent(arguments);
    },
    onMenuButtonClick: function(button) {
        var me = this;
        switch (button.action) {
            case 'fullscreen':
                // Для перечисленных браузеров, реализуется отдельный нативный клик во вьюшке 
                // чтобы работало корректно
                if (!Ext.browser.is.IE11 && !Ext.browser.is.Safari) {
                    me.viewportController.doFullscreen();
                };
                break;
            case 'music_off':
                me.soundController.toggleMusic();
                break;
            case 'sound_off':
                me.soundController.toggleSound();
                break;
        }
        me.refreshView();
    },
    /**
     * Обработчик смены языка
     */
    onLangSelect: function(lang) {
        var me = this;
        ExGods.app.getSettingsController().saveSettings({
            language: lang
        });
    },
    refreshView: function() {
        var me = this,
            toolsMenu = me.getToolsMenu();
        if (toolsMenu) {
            toolsMenu.items.each(function(btn) {
                if (btn.action == 'music_off') {
                    if (me.soundController.isMusicOff()) {
                        btn.addCls('state2');
                    } else {
                        btn.removeCls('state2');
                    }
                } else if (btn.action == 'sound_off') {
                    if (me.soundController.isSoundOff()) {
                        btn.addCls('state2');
                    } else {
                        btn.removeCls('state2');
                    }
                } else if (btn.action == 'lang_select') {
                    btn.setLang(ExGods.app.user.getSetting('language'));
                }
            });
        }
    }
});

/**
 * Контроллер быстрых подсказок (tooltips)
 *
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.TooltipManager', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'TooltipManager:'
    },
    sources: {},
    init: function() {
        var me = this;
        ExGods.Tooltips = me;
        // alias
        me.callParent(arguments);
    },
    onLaunch: function() {
        var me = this;
        new Ext.tip.ToolTip({
            cls: 'exgtip-dummy',
            target: Ext.getBody(),
            delegate: '.exgtip',
            renderTo: Ext.getBody(),
            listeners: {
                beforeshow: function(tip) {
                    me.showTooltip(tip.triggerElement);
                    return true;
                },
                hide: function() {
                    if (me.tipWindow) {
                        me.tipWindow.close();
                        me.tipWindow = null;
                    }
                }
            }
        });
        // пробегаю по всем контроллерам в поисках источников тултипов
        me.app.controllers.each(function(item) {
            if (item.tooltips && item.tooltips.length) {
                item.tooltips.forEach(function(type) {
                    me.register(item, type);
                });
            }
        });
    },
    /**
     * Регистрирует источник данных тултипов.
     * Источник должен реализовать метод getTooltipData(type, value) для предоставения информации подсказки
     */
    register: function(src, type) {
        var me = this;
        if (!me.sources[type]) {
            me.sources[type] = [
                src
            ];
        } else if (me.sources[type].indexOf(src) == -1) {
            me.sources[type].push(src);
        }
    },
    /**
     * Создаст тултип в виде строки
     * @param {Object} config :
     *   {String} type Тип сущности, для которой показывать тултип
     *   {String} value Значение сущности, которое ее идентифицирует
     *   {String} tag Какой тег использовать для тултипа
     *   {String} html Внутренности тултипа
     *   {String} cls Класс тултипа 
     * return {String} 
     */
    createTip: function(config) {
        var me = this,
            tpl = [
                '<{tag} class="exgtip {cls}" data-exgtip_type="{type}" data-exgtip_value="{value}" >',
                '{html}',
                '</{tag}>'
            ];
        config.tag = config.tag || 'div';
        config.cls = config.cls || '';
        config.html = config.html || '';
        return ExGods.app.applyTpl(tpl.join(''), config);
    },
    /**
     * Сделает дом-элемент тултипом
     * @param {Ext.dom.Element/HTMLElement} target Dom элемент
     * @param {String} type Тип сущности, для которой показывать тултип
     * @param {Mixed} value Значение сущности, которое ее идентифицирует
     * return {String|Ext.dom.Element} 
     */
    makeElementAsTip: function(target, type, value) {
        var me = this;
        target = Ext.get(target);
        if (target && target.dom) {
            target.addCls('exgtip');
            target.dom.setAttribute('data-exgtip_type', type);
            target.dom.setAttribute('data-exgtip_value', value);
            return target;
        }
    },
    /**
     * Удаляет структуру тултипа из элемента
     */
    removeTip: function(el) {
        var me = this;
        el = Ext.get(el);
        if (el) {
            el.removeCls('exgtip');
            el.dom.removeAttribute('data-exgtip_type');
            el.dom.removeAttribute('data-exgtip_value');
        }
    },
    /**
     * @private
     */
    showTooltip: function(triggerElement) {
        var me = this,
            data, type, value, tooltip;
        type = triggerElement.getAttribute('data-exgtip_type');
        value = triggerElement.getAttribute('data-exgtip_value');
        if (!me.canTooltipShow(type, value)) {
            return;
        }
        if (!(data = me.getData(type, value))) {
            /***/
            me.log('warn', 'Данные тултипа не определены', type, value);
            return;
        }
        if (me.tipWindow) {
            me.tipWindow.close();
            me.tipWindow = null;
        }
        if (type == 'text') {
            tooltip = me.createTextTooltip(triggerElement, data);
        } else if (type == 'item') {
            tooltip = me.createItemTooltip(triggerElement, data);
        } else if (type == 'proto_item') {
            tooltip = me.createProtoItemTooltip(triggerElement, data);
        } else if (type == 'ingredient' || type == 'currency' || type == 'timed') {
            tooltip = me.createCommonTooltip(triggerElement, data);
        } else if (type == 'slot') {
            tooltip = me.createSlotTooltip(triggerElement, data);
        } else if (type == 'quest') {
            tooltip = me.createQuestTooltip(triggerElement, data);
        } else if (type == 'monster') {
            tooltip = me.createMonsterTooltip(triggerElement, data);
        } else if (type == 'stuff') {
            tooltip = me.createStuffTooltip(triggerElement, data);
        } else {
            /***/
            me.log('warn', 'Неизвестный тип тултипа ', type);
            return;
        }
        me.tipWindow = tooltip;
    },
    /**
     * @private Ищет данные тултипа по всем зарегистрированным источникам
     */
    getData: function(type, value) {
        var me = this,
            data;
        if (me.sources[type] && me.sources[type].length) {
            for (var i = 0; i < me.sources[type].length && !data; i++) {
                if (typeof me.sources[type][i].getTooltipData == 'function') {
                    data = me.sources[type][i].getTooltipData(type, value);
                } else {
                    /***/
                    me.log('warn', 'Источник тултипа с типом ' + type + ' должен реализовать метод getTooltipData', me.sources[type][i]);
                }
            }
        }
        return data;
    },
    /**
     * @private
     */
    createTextTooltip: function(triggerElement, data) {
        var me = this;
        return Ext.widget('parchmentwindow', {
            closable: false,
            itemElement: triggerElement,
            html: data,
            bodyPadding: 15
        });
    },
    /**
     * @private
     */
    createItemTooltip: function(triggerElement, data) {
        var me = this;
        return me.app.getItemController().showItemWindow({
            item: data.item,
            proto_id: data.proto.data.id,
            itemEl: triggerElement,
            tooltip: true
        });
    },
    /**
     * @private
     */
    createProtoItemTooltip: function(triggerElement, data) {
        var me = this;
        me.app.getItemController().showItemWindow({
            proto_id: data.proto.data.id,
            itemEl: triggerElement,
            tooltip: true
        });
    },
    /**
     * @private
     */
    createCommonTooltip: function(triggerElement, data) {
        var me = this;
        return Ext.widget('commondetailswindow', {
            closable: false,
            imageSize: 64,
            data: data,
            itemElement: triggerElement
        });
    },
    /**
     * @private
     */
    createSlotTooltip: function(triggerElement, data) {
        var description,
            rows = [];
        if (data.slot.get('protect')) {
            description = [
                '<div style="background: url(' + IMAGE_URL + '/icons/done.png) 0 0 no-repeat; padding-left: 20px;" >',
                ExGods.ref('message_client|slot_protected'),
                '</div>'
            ].join('');
        } else {
            description = ExGods.ref('message_client|slot_not_protected');
        }
        if (data.tooltipText) {
            rows.push({
                content: [
                    '<div class="description-block parchment-content">',
                    '<ul class="table-list">',
                    '<li style="text-align: center;">' + data.tooltipText + '</li>',
                    '</ul>',
                    '</div>'
                ].join('')
            });
        }
        return Ext.widget('commondetailswindow', {
            closable: false,
            data: {
                label: data.slot.get('name'),
                image: ExGods.ref('slot_type|' + data.slot.get('type')).images.empty,
                description: description,
                rows: rows
            },
            itemElement: triggerElement
        });
    },
    /**
     * @private
     */
    createQuestTooltip: function(triggerElement, quest) {
        var me = this,
            printQuestAims = function(quest) {
                var tpl = [
                        '<ul style="padding-bottom: 5px;">',
                        '<tpl for="aims">',
                        '<tpl if="this.getImage(values)">',
                        '<li style="background-image: url({[this.getImage(values)]});background-repeat: no-repeat; padding: 0 0 2px 20px;">{name} {[this.getCounters(values)]}</li>',
                        '<tpl else>',
                        '<li style="padding: 0 0 2px 0;">{name} {[this.getCounters(values)]}</li>',
                        '</tpl>',
                        '</tpl>',
                        '</ul>',
                        {
                            getImage: function(aim) {
                                var images = ExGods.ref('images|quest_icons').image,
                                    src,
                                    title = '';
                                switch (quest.data.status) {
                                    case 1:
                                    case 4:
                                        src = images['aim_' + (aim.done ? 'done' : 'undone')];
                                        break;
                                    case 2:
                                    case 3:
                                    case 5:
                                        src = images['aim_done'];
                                        break;
                                    default:
                                        break;
                                }
                                
                                return src;
                            },
                            getCounters: function(aim) {
                                var html = '';
                                if (aim.counter && aim.counter.length && (quest.data.status == 1 || quest.data.status == 2 || quest.data.status == 4)) {
                                    Ext.Array.forEach(aim.counter, function(counter, index) {
                                        if (counter.type != 1) {
                                            html = '(' + counter.curr + '/' + counter.need + ')';
                                        }
                                    });
                                }
                                return html;
                            }
                        }
                    ];
                tpl = new Ext.XTemplate(tpl);
                return tpl.applyTemplate(quest.data);
            };
        return Ext.widget('commondetailswindow', {
            closable: false,
            data: {
                label: quest.data.name,
                image: quest.getGiverThumb(),
                rows: [
                    {
                        content: printQuestAims(quest)
                    }
                ]
            },
            itemElement: triggerElement
        });
    },
    /**
     * @private
     */
    createStuffTooltip: function(triggerElement, stuffObj) {
        return stuffObj.details({
            clickedEl: triggerElement,
            tooltip: true
        });
    },
    /**
     * @private
     */
    canTooltipShow: function(type, value) {
        var me = this,
            cmp;
        if (!type || !value) {
            return false;
        }
        if ([
            'item',
            'slot',
            'proto_item',
            'ingredient',
            'currency',
            'timed',
            'stuff'
        ].indexOf(type) != -1) {
            cmp = Ext.ComponentQuery.query('parchmentwindow');
            if (cmp.length > 1 || (cmp.length == 1 && cmp[0] != me.tipWindow)) {
                return false;
            }
        }
        return true;
    }
});

/**
 * Табы квестов
 */
Ext.define('ExGods.view.quest.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.questtabpanel',
    tabUi: 'skintext',
    bodyPadding: '0 10 8 8',
    initComponent: function() {
        var me = this;
        me.callParent();
        var style = {
                color: '#cd9c64',
                margin: '9px'
            };
        me.down('tabbar').add([
            {
                dock: 'top',
                xtype: 'checkbox',
                boxLabel: ExGods.getMsgByKey('view_quest_tabpanel_story'),
                name: 'story',
                style: style,
                checked: true
            },
            {
                dock: 'top',
                xtype: 'checkbox',
                boxLabel: ExGods.getMsgByKey('view_quest_tabpanel_daily'),
                name: 'daily',
                style: style,
                checked: true
            }
        ]);
        me.on('afterrender', function() {
            var count = ExGods.app.getUser().availableQuestsStore.getCount();
            if (count > 0) {
                me.setActiveTab('available_quests');
            } else {
                me.setActiveTab('active_quests');
            }
        });
    },
    //      me.on('show',function(){
    //          ExGods.app.getQuestController().getQuestButton().reset();
    //      });
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {};
        }
        Ext.applyIf(item.tabConfig, {
            quantityLeft: item.quantityLeft || 0,
            countLabel: true,
            item: item
        });
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.quest.NewList', {
    extend: ExGods.view.List,
    alias: 'widget.questnewlist',
    margin: '-3px -3px 0 -3px',
    cls: 'questnewlist',
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            scrollDeltaY: 50,
            autoHide: true,
            autoRestorePosition: true,
            padding: '3px 3px 0 0'
        }
    ],
    emptyTpl: [
        '<p class="central-window-empty">{text}</p>'
    ],
    initComponent: function() {
        var me = this;
        me.itemWidgetConfig = {
            xtype: 'questlistitem',
            autoShow: false,
            listeners: {
                expand: me.onItemExpand,
                collapse: me.onItemCollapse,
                scope: me
            }
        };
        me.emptyData = {
            text: ExGods.getMsgByKey('view_quest_newlist_emptytext')
        };
        me.noQuestsChecked = ExGods.ref('message_client|noquestschecked');
        me.callParent(arguments);
    },
    onItemExpand: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onItemCollapse: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onRender: function() {
        var me = this;
        me.checkboxes = me.up().query('checkbox');
        if (!me.skipFilter) {
            Ext.each(me.checkboxes, function(item) {
                me.onCheckBoxChange(item, item.checked);
                item.on('change', me.onCheckBoxChange, me);
            });
        } else {
            Ext.each(me.checkboxes, function(item) {
                item.hide();
            });
        }
        me.callParent(arguments);
    },
    onShow: function() {
        var me = this;
        Ext.each(me.checkboxes, function(item) {
            if (me.skipFilter) {
                item.hide();
            } else {
                item.show();
            }
        });
        me.callParent(arguments);
    },
    onCheckBoxChange: function(checkbox, checked) {
        var me = this;
        if (!checked) {
            if (me.store.filters.length == 1) {
                me.emptyData.text = me.noQuestsChecked;
            } else {
                me.emptyData.text = me.emptyText;
            }
            switch (checkbox.name) {
                case 'story':
                    me.store.addFilter(Ext.util.Filter({
                        filterFn: function(item) {
                            return item.data.repeat;
                        },
                        // в сюжет - всё, что не имеет повторения
                        id: checkbox.name
                    }));
                    break;
                case 'daily':
                    me.store.addFilter(Ext.util.Filter({
                        filterFn: function(item) {
                            return !item.data.repeat;
                        },
                        // в ежедневные - повторяемые задания
                        id: checkbox.name
                    }));
                    break;
            }
        } else {
            me.emptyData.text = me.emptyText;
            me.store.removeFilter(checkbox.name);
        }
        if (me.items) {
            me.collapseAll();
        }
        if (me.scroller && me.scroller.scrollEl) {
            me.scrollToTop();
            me.scroller.onResize();
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var obj = ExGods.references.get('images').get('quest_icons').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        obj = ExGods.ref('images|common_text_images').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        var parent = me.callParent();
        return {
            stuff: [].concat(parent.stuff),
            images: [
                IMAGE_URL + 'quests/bg.png',
                IMAGE_URL + 'quests/top_1.png',
                IMAGE_URL + 'quests/top_2.png',
                IMAGE_URL + 'quests/top_3.png',
                IMAGE_URL + 'quests/side_left.png',
                IMAGE_URL + 'quests/side_right.png',
                IMAGE_URL + 'quests/bottom_1.png',
                IMAGE_URL + 'quests/bottom_2.png',
                IMAGE_URL + 'quests/bottom_3.png',
                IMAGE_URL + 'quests/item_box.jpg',
                IMAGE_URL + 'quests/button_task_close.png',
                IMAGE_URL + 'scrollbar/thumb.png',
                IMAGE_URL + 'scrollbar/bg_midle.png',
                IMAGE_URL + 'scrollbar/bg_top.png',
                IMAGE_URL + 'scrollbar/bg_bottom.png',
                IMAGE_URL + 'shop/btn_buy.png',
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 * Cписок квестов
 */
Ext.define('ExGods.view.quest.Column', {
    extend: Ext.panel.Panel,
    alias: 'widget.questcolumn',
    flex: 1,
    layout: 'card',
    header: false,
    cls: 'location-quest-column',
    // plugins: ['skinparchmentdeco'],
    /**
     * @cfg {Ext.data.Store} store (required)
     * Хранилище квестов
     */
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    initComponent: function() {
        var me = this;
        var questsTpl = new Ext.XTemplate('<div class="location-header" style="margin:0 0 -4px 1px"><div class="location-header-title quests" style="background-image:url(' + ExGods.ref('images|location_images').image.quests_title + ');"></div></div>', '<ul class="quests">', '<tpl for=".">', '<tpl if="xindex &lt; 5">', '<li class="quest {[values.params.is_tutorial ? "tutorial" : ""]} {[values.status ==2 ? "finish" : values.status ==  1 ? "active" : ""]} exgtip" style="cursor: pointer;margin-left:0px" data-exgtip_type="quest" data-exgtip_value="{proto_id}">', '<div class="quest-giver-border">', '<div class="quest-giver-image" style="background-image:url({[this.getThumb(values)]})">', '<div class="quest-giver-sign" {[this.getStatusIcon(values)]}"></div>', '</div>', '</div>', '</li>', '</tpl>', '</tpl>', '</ul>', {
                shapes: ExGods.references.get('user_shape'),
                getThumb: function(values) {
                    var quest = me.store.getById(parseInt(values.proto_id));
                    return quest.getGiverThumb();
                },
                getStatusIcon: function(values) {
                    var icon = '';
                    switch (values.status) {
                        case 0:
                        case 3:
                            if (values.params.story == 3) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_green.png';
                            } else if (values.params.repeat) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_blue.png';
                            } else {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_yellow.png';
                            };
                            break;
                        case 2:
                            if (values.params.story == 3) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_green.png';
                            } else if (values.params.repeat) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_blue.png';
                            } else {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_yellow.png';
                            };
                            break;
                    }
                    if (icon) {
                        return 'style="background-image:url(' + icon + ')"';
                    }
                }
            });
        me.initStore();
        me.quests = Ext.widget('viewpanel', {
            layout: 'absolute',
            store: me.store,
            bodyStyle: {
                overflow: 'visible'
            },
            viewConfig: {
                itemSelector: 'li.quest',
                tpl: questsTpl,
                listeners: {
                    refresh: me.onViewRefresh,
                    scope: me
                }
            }
        });
        // me.quests.relayEvents(me, ['show']);
        me.items = [
            me.quests
        ];
        me.energyCounter = Ext.widget('component', {
            margin: '0 0 0 4',
            position: 'absolute',
            width: 80
        });
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent();
        // чтобы квест маркер на квесты был виден
        me.getEl().setStyle({
            overflow: 'visible'
        });
        me.body.el.setStyle({
            overflow: 'visible'
        });
        me.ownerCt.getEl().setStyle({
            overflow: 'visible'
        });
    },
    /**
     * Собираю стор компонента из сторов с квестами, подписываюсь на их изменения
     */
    initStore: function() {
        var me = this,
            available = me.user.availableQuestsStore,
            questsStore = ExGods.app.getStore('Quests');
        me.store = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.Quest'
        });
        var loadStore = function(store) {
                var me = this,
                    add = false;
                if (questsStore.totalCount) {
                    var collection = questsStore.queryBy(function(record, id) {
                            var status = record.get('status');
                            return status == 0 || status == 2;
                        });
                    me.store.loadRecords(collection.items);
                    add = true;
                }
                if (available.totalCount) {
                    me.store.loadRecords(available.data.items, {
                        addRecords: add
                    });
                    add = true;
                }
                if (questsStore.totalCount) {
                    var collection = questsStore.queryBy(function(record, id) {
                            var status = record.get('status');
                            return status != 0 && status != 2;
                        });
                    me.store.loadRecords(collection.items, {
                        addRecords: add
                    });
                }
            };
        loadStore.call(me);
        me.mon(available, 'datachanged', loadStore, me);
        me.mon(available, 'update', loadStore, me);
        me.mon(questsStore, 'datachanged', loadStore, me);
        me.mon(questsStore, 'update', loadStore, me);
    },
    bindStore: function(store) {
        this.quests.bindStore(store);
    },
    /**
     * @private
     */
    onViewRefresh: function(view, opts) {
        var me = this;
        view.getStore().each(function(record) {
            if (record.get('status') == ExGods.model.Quest.COMPLETE && record.get('timerest') > 0) {
                me.updateQuestTimer(record);
            }
        });
    },
    /**
     * @private
     * Обновить таймер для квеста
     *
     * @param {ExGods.model.Quest} quest
     */
    updateQuestTimer: function(quest) {
        var me = this,
            qid = quest.getId(),
            timerest = quest.get('timerest'),
            timers = me._timers || {},
            node = me.quests.getView().getNode(quest);
        if (timers[qid]) {
            window.clearInterval(timers[qid]);
            timers[qid] = 0;
        }
        timers[qid] = window.setInterval(function() {
            if (timerest-- >= 0) {
                if (node) {
                    Ext.fly(node).select('.countdown').setHTML(Ext.util.Format.countdown(timerest));
                }
            } else {
                window.clearInterval(timers[qid]);
                timers[qid] = 0;
            }
        }, 1000);
        me._timers = timers;
    },
    onDestroy: function() {
        var me = this;
        me.store.clearFilter();
        me.callParent(arguments);
    },
    /**
     * Стандартная функция обработки клика для компонента, используемого как объект локации
     */
    locationObjectClickHandler: function(e) {
        return false;
    }
});

/**
 * Плагин добавляющий оформление пергамента (новый)
 *
 * Замена ExGods.view.plugin.ParchmentDeco
 */
Ext.define('ExGods.view.plugin.SimpleParchmentDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.simpleparchmentdeco',
    init: function(cmp) {
        cmp.addClsWithUI('parchment');
        if (typeof cmp.padding == 'undefined') {
            cmp.padding = 8;
        }
        if (cmp.isPanel) {
            if (!cmp.title)  {
                cmp.title = ' ';
            }
            
            Ext.override(cmp, {
                addTool: function(tools) {
                    var i = 0;
                    tools = [].concat(tools);
                    for (; i < tools.length; i++) {
                        // на пергаменте кнопка "закрыть" имеет размеры 32х31
                        tools[i].height = 31;
                        tools[i].width = 32;
                    }
                    this.callParent(arguments);
                }
            });
        }
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header)  {
            cmp.header.setHeight(0);
        }
        
        if (cmp.bodyBorder !== false)  {
            cmp.el.insertHtml('afterBegin', '<div class="parchment-border"></div>');
        }
        
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'close.png',
                IMAGE_URL + 'parchment-tl.jpg',
                IMAGE_URL + 'parchment-tm.jpg',
                IMAGE_URL + 'parchment-tr.jpg',
                IMAGE_URL + 'parchment-mr.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'parchment-br.jpg',
                IMAGE_URL + 'parchment-bm.jpg',
                IMAGE_URL + 'parchment-bl.jpg',
                IMAGE_URL + 'parchment-ml.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'separator-horizontal.jpg'
            ]
        };
    }
});

/**
 * Окно с пергаментным фоном
 */
Ext.define('ExGods.view.parchment.Window', {
    extend: Ext.window.Window,
    alias: 'widget.parchmentwindow',
    autoShow: true,
    bodyBorder: false,
    bodyPadding: 0,
    closable: true,
    cascade: true,
    draggable: false,
    header: {
        margin: 0
    },
    style: {
        overflow: 'visible'
    },
    /**
     * @cfg {Boolean} hideOnOuterClick 
     * Скрывать окно при любом клике на внешнюю область
     */
    hideOnOuterClick: true,
    layout: 'absolute',
    /**
     * @cfg {Ext.Element} maskCt
     * Область ограничивающее размещение окна
     */
    padding: '0 4 4',
    plugins: [
        'paperdeco'
    ],
    renderTo: Ext.getBody(),
    resizable: false,
    shadow: false,
    width: 230,
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
        me.on('hide', me.onWndHide, me);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        setTimeout(function() {
            me.doLayout();
        }, // иначе плывет лейаут с кнопками
        0);
    },
    onShowComplete: function() {
        var me = this,
            windowPosition, parentWindow;
        me.callParent(arguments);
        if (me.itemElement) {
            if (Ext.get(me.itemElement) && Ext.get(me.itemElement).up('.x-window') && me.cascade) {
                // рассчитываю координаты окна относительно родительского
                var coords = Ext.get(me.itemElement).up('.x-window').getXY();
                if (coords[0] + me.getSize().width + 20 <= Ext.getBody().getSize().width + Ext.getBody().getScroll().left) {
                    coords[0] += 20;
                } else {
                    coords[0] = Ext.getBody().getSize().width + Ext.getBody().getScroll().left - me.getSize().width - 21;
                }
                if (coords[1] + me.getSize().height + 20 <= Ext.getBody().getSize().height + Ext.getBody().getScroll().top) {
                    coords[1] += 20;
                } else {
                    coords[1] = Ext.getBody().getSize().height + Ext.getBody().getScroll().top - me.getSize().height - 21;
                }
                windowPosition = {
                    left: coords[0],
                    top: coords[1]
                };
                // закрываю окно, если родительское закрылось или получило фокус
                var parentWindow = Ext.getCmp(Ext.get(me.itemElement).up('.x-window').id);
                if (parentWindow) {
                    me.mon(parentWindow, 'close', function() {
                        setTimeout(function() {
                            me.close();
                        }, 0);
                    });
                    me.mon(parentWindow, 'activate', function() {
                        setTimeout(function() {
                            me.close();
                        }, 0);
                    });
                }
            } else {
                windowPosition = me.getItemWindowPosition(me.itemElement, me.maskCt);
            }
        }
        if (windowPosition) {
            if (windowPosition.left == 0 && windowPosition.top == 0) {
                me.close();
                return;
            } else {
                me.setPosition(windowPosition.left, windowPosition.top);
            }
        }
        if (me.hideOnOuterClick) {
            setTimeout(function() {
                Ext.getBody().on('click', me.processOuterClick, me);
            }, 10);
        }
    },
    onWndHide: function() {
        var me = this;
        if (me.hideOnOuterClick) {
            Ext.getBody().un('click', me.processOuterClick, me);
        }
    },
    processOuterClick: function(e, el) {
        var me = this;
        if (me.isVisible() && !Ext.fly(el).up('.' + me.cls) && !Ext.fly(el).up('.x-window') && me.plugins) //в кузнице баз плагина
        {
            me.close();
        }
    },
    /**
     * Рассчитывает положение окна-подсказки предмета
     * @private
     *
     * @param {ExGods.view.item.Item/HTMLElement} item Отображение предмета
     * @return {Object} Позиция окна-подсказки
     *
     *  {
     *      left: <left offset>,
     *      top: <top offset>
     *  }
     */
    getItemWindowPosition: function(item, container) {
        var me = this,
            itemPosition;
        if (Ext.isElement(item)) {
            item = Ext.get(item);
            itemPosition = item.getXY();
        } else {
            itemPosition = item.el.getXY();
        }
        // Ext JS 4.1rc1
        var windowPosition = {
                left: itemPosition[0],
                top: itemPosition[1]
            },
            itemSize = item.getSize(),
            itemWidth = item.getWidth(),
            windowSize = me.getSize(),
            containerSize = null,
            isBodyContainer = false;
        if (item.up('.pergament')) {
            container = item.up('.pergament');
            containerSize = container.getSize();
        } else if (container) {
            containerSize = container.getSize();
        } else if (container = item.up('#right-container')) {
            containerSize = container.getSize();
        } else if (container = item.up('#doll-panel')) {
            containerSize = container.getSize();
        } else {
            container = Ext.getBody();
            isBodyContainer = true;
            containerSize = container.getSize();
        }
        if (isBodyContainer) {
            var containerScroll = container.getScroll();
            if (windowPosition.left + itemSize.width + windowSize.width <= containerSize.width + containerScroll.left) {
                windowPosition.left += itemSize.width;
            } else {
                windowPosition.left -= windowSize.width;
            }
            if (windowPosition.top + windowSize.height + 4 > containerSize.height + containerScroll.top) {
                windowPosition.top -= (windowPosition.top + windowSize.height + 4) - (containerSize.height + containerScroll.top);
            }
        } else {
            var containerPosition;
            if (!container.el) {
                containerPosition = container.getOffsetsTo(Ext.getBody());
            } else {
                containerPosition = container.el.getOffsetsTo(Ext.getBody());
            }
            if (windowPosition.left + itemSize.width + windowSize.width <= containerSize.width + containerPosition[0] || windowPosition.left - windowSize.width < 0) {
                windowPosition.left += itemSize.width;
            } else {
                windowPosition.left -= windowSize.width;
            }
            if (windowPosition.top + windowSize.height > containerSize.height + containerPosition[1]) {
                windowPosition.top -= (windowPosition.top + windowSize.height) - (containerSize.height + containerPosition[1]);
            }
        }
        return windowPosition;
    }
});

/**
 * Окошко с информацией. Содержет картинку, нзвание, и описание.
 */
Ext.define('ExGods.view.CommonDetailsWindow', {
    extend: ExGods.view.parchment.Window,
    alias: 'widget.commondetailswindow',
    /**
     * @cfg {Object} data (required)
     *   label {String} Название 
     *   description {String} Описание 
     *   image {String} URL картинки, абсолютный
     *   rows {Array} Найстройки строчек инфомации. Каждая строка имеет следующие возможные настройки:
     *      cls {String} CSS класс   
     *      title {String}  Заголовок
     *      content {String} Информация строки
     *      separator {Boolean} Нужен ли разделитель перед строкой По умолчанию, нужен
     */
    data: {},
    /**
      * @cfg {Number} imageSize (52 или 64)
      */
    imageSize: 52,
    /**
      * @cfg {Template} headerTpl
      */
    headerTpl: [
        '<div class="parchment-content cf header">',
        '<span style="display: table;">',
        '<div class="image image{imageSize}" style="background-image: url({image});"></div>',
        '<span class="label">{label}</span>',
        '</span>',
        '</div>'
    ],
    cls: 'common-details-window',
    padding: '4 4 10 4',
    initComponent: function() {
        var me = this;
        me.html = '';
        me.data = me.config.data;
        me.data.imageSize = me.imageSize;
        me.headerTpl = new Ext.XTemplate(me.headerTpl).apply(me.data);
        me.tpl = [
            // картинка и название
            me.headerTpl,
            // описание
            '<tpl if="description">',
            '<div class="separator"></div>',
            '<div class="description parchment-content">',
            '{[ExGods.app.applyTpl(values.description)]}',
            '</div>',
            '</tpl>',
            // строки
            '<tpl for="rows">',
            '<tpl if="content">',
            '<div class="separator" style="{[ values.separator === false ? "display: none;" : "" ]}"></div>',
            '<div class="row parchment-content {[ values.cls ? values.cls : ""]}">',
            '<tpl if="title">',
            '<div class="paper-title title">{title}</div>',
            '</tpl>',
            '{content}',
            '</div>',
            '</tpl>',
            '</tpl>',
            '<tpl if="this.hasButtons">',
            '<div class="separator"></div>',
            '</tpl>',
            {
                hasButtons: me.buttons ? me.buttons.length : false
            }
        ];
        if (me.buttons && me.buttons.length) {
            me.dockedItems = [
                {
                    xtype: 'toolbar',
                    layout: 'anchor',
                    dock: 'bottom',
                    itemId: 'actions',
                    margin: '4 0 14 0',
                    padding: '0 16 0 16',
                    defaults: {
                        anchor: '100%',
                        margin: '2 0',
                        cls: 'no_border'
                    },
                    defaultType: 'textbutton',
                    items: me.buttons
                }
            ];
            delete me.buttons;
        }
        
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                me.data.image
            ]
        };
    }
});

Ext.define('ExGods.view.quest.ListItem', {
    extend: ExGods.view.ListItem,
    alias: 'widget.questlistitem',
    margin: '0 0 -3px 0',
    initComponent: function() {
        var me = this;
        //if(me.record.get('timedropfrom')) debugger
        var templateHelpers = {
                getDesc: function(desc) {
                    return ExGods.app.applyTpl(desc, {
                        u: ExGods.app.getUser().data
                    });
                },
                images: ExGods.references.get('images').get('quest_icons').image,
                shapes: ExGods.references.get('user_shape'),
                getThumb: function(values) {
                    if (values.giver && values.giver.shape) {
                        return this.shapes.getByKey(values.giver.shape).thumb;
                    } else if (values.giver && values.giver.image_thumb) {
                        // если giver предмет
                        return IMAGE_URL + values.giver.image_thumb;
                    } else if (values.giver && values.giver.icon) {
                        // если giver приключение
                        return IMAGE_URL + values.giver.icon;
                    } else if (values.params && values.params.image) {
                        return IMAGE_URL + values.params.image;
                    } else {
                        return Ext.BLANK_IMAGE_URL;
                    }
                },
                /**
             * status:
             * 0: Доступно
             * 1: В процессе выполнения
             * 2: Выполнено
             * 3: Доступно через время
             * 4: Провалено
             * 5: Завершено
             */
                getStatusIcon: function(values) {
                    var icon = '';
                    switch (values.status) {
                        case 0:
                        case 3:
                            if (values.params.story == 3) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_green.png';
                            } else if (values.params.repeat) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_blue.png';
                            } else {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_yellow.png';
                            };
                            break;
                        case 2:
                            if (values.params.story == 3) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_green.png';
                            } else if (values.params.repeat) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_blue.png';
                            } else {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_yellow.png';
                            };
                            break;
                    }
                    if (icon) {
                        return 'style="background-image:url(' + icon + ')"';
                    }
                },
                checkDaily: function(repeat) {
                    return repeat ? ' (' + ExGods.getMsgByKey('view_quest_listitem_daily') + ')' : '';
                },
                getAimStatus: function(status, done, count) {
                    var images = ExGods.references.get('images').get('quest_icons').image,
                        src = Ext.BLANK_IMAGE_URL,
                        title = '';
                    switch (status) {
                        case 1:
                        case 4:
                            src = images['aim_' + (done ? 'done' : 'undone')];
                            break;
                        case 2:
                        case 3:
                        case 5:
                            src = images.aim_done;
                            break;
                        default:
                            break;
                    }
                    return (src) ? 'style="background-image:url(' + src + ');text-indent:10px;' + ((count == 1) ? 'margin:5px 0' : '') + '"' : '';
                },
                getAimText: function(text) {
                    return text.replace(/["']/g, "&quot;");
                },
                getCounters: function(values, status, xindex, qtip) {
                    var out = '',
                        counters = values.counter,
                        arr = [];
                    xindex = xindex - 1;
                    if (counters && counters.length && (status == 1 || status == 2 || status == 4)) {
                        Ext.Array.forEach(counters, function(counter, index) {
                            if (counter.type == 1) {
                                if (qtip) {
                                    arr.push('(' + Ext.util.Format.countdown(counter.left, {
                                        format: 'short'
                                    }) + ')');
                                } else {
                                    index = xindex + '_' + index;
                                    var text = '';
                                    if (counter.left)  {
                                        text = '(' + Ext.util.Format.countdown(counter.left, {
                                            format: 'short'
                                        }) + ')';
                                    }
                                    
                                    arr.push('<span class="aim-ticker-' + index + '">' + text + '</span>');
                                    me.mon(me.record, 'aimcounter_' + index, function(left, record) {
                                        var span = me.el.down('.aim-ticker-' + index);
                                        if (me.el && span) {
                                            if (left < 1) {
                                                span.update('');
                                                span.up('li').setStyle('background-image', 'url(' + ExGods.references.get('images').get('quest_icons').image.aim_done + ')');
                                            } else {
                                                span.update('(' + Ext.util.Format.countdown(left, {
                                                    format: 'short'
                                                }) + ')');
                                            }
                                        }
                                    });
                                }
                            } else {
                                arr.push('(' + counter.curr + '/' + counter.need + ')');
                            }
                        });
                        if (arr.length) {
                            out = arr.join(', ');
                        }
                    }
                    return out;
                },
                showTimeToPerform: function(data) {
                    return data.timedropfrom && data.timedropfrom > 0 && (data.status == ExGods.model.Quest.ACTIVE || data.status == ExGods.model.Quest.READY_TO_COMPLETE);
                },
                /**
             * True, если квест может быть отслежен
             * @return {Boolean}
             */
                isTraceable: function(qid) {
                    var quest = me.up('questnewlist').store.getById(qid);
                    return quest ? quest.isTraceable() : false;
                },
                /**
             * True, если квест отслеживается
             * @return {Boolean}
             */
                isTraced: function(qid) {
                    var quest = me.up('questnewlist').store.getById(qid);
                    return quest ? quest.isTraced() : false;
                }
            };
        var expanded = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{name}{[this.templateHelpers.checkDaily(values.params.repeat)]}</h4>',
                '<div class="view-change-selector expanded"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url({[this.templateHelpers.getThumb(values)]})">',
                '<div class="quest-giver-sign" {[this.templateHelpers.getStatusIcon(values)]}"></div>',
                '</div>',
                '</div>',
                '<tpl if="this.templateHelpers.showTimeToPerform(values)">',
                '<div class="quest-timer">',
                '<span class="dropdown">{timedropfrom:countdown}</span>',
                '</div>',
                '</tpl>',
                '</div>',
                '<div class="wide-column">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image.title_aim + ')"></div>',
                '<div class="info-box-content">',
                '<tpl if="aims.length">',
                '<ul>',
                '<tpl for="aims">',
                '<tpl if="parent.status == 0 || parent.status == -1">',
                '<tpl if="stage == 1">',
                // для доступных квестов показывается только первый этап
                '<li class="aim" {[this.templateHelpers.getAimStatus(parent.status, values.done, parent.aims.length)]}>',
                '<span class="aim-text" data-qtip="{[this.templateHelpers.getAimText(values.name)]}{[this.templateHelpers.getCounters(values, parent.status, xindex, 1)]}">{name}' + ' {[this.templateHelpers.getCounters(values, parent.status, xindex)]}' + '</span>',
                '</li>',
                '</tpl>',
                '<tpl else>',
                '<li class="aim" {[this.templateHelpers.getAimStatus(parent.status, values.done, parent.aims.length)]}>',
                '<span class="aim-text" data-qtip="{[this.templateHelpers.getAimText(values.name)]}{[this.templateHelpers.getCounters(values, parent.status, xindex, 1)]}">{name}' + ' {[this.templateHelpers.getCounters(values, parent.status, xindex)]}' + '</span>',
                '</li>',
                '</tpl>',
                '</tpl>',
                '</ul>',
                '</tpl>',
                '</div>',
                '</div>',
                '<tpl if="random_rewards && random_rewards.length  || rewards && rewards.length">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image.title_award + ')"></div>',
                '<div class="info-box-content info-box-rewards">',
                '<ul>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '</ul>',
                '</div>',
                '</div>',
                '</tpl>',
                '<div class="button-place expanded" id="button-place-{proto_id}"></div>',
                '</div>',
                '<div class="quest-description">{[this.templateHelpers.getDesc(values.desc)]}</div>',
                '</div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        var collapsed = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{name}{[this.templateHelpers.checkDaily(values.params.repeat)]}</h4>',
                '<div class="view-change-selector collapsed"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url({[this.templateHelpers.getThumb(values)]})">',
                '<div class="quest-giver-sign" {[this.templateHelpers.getStatusIcon(values)]}"></div>',
                '</div>',
                '</div>',
                '<tpl if="this.templateHelpers.showTimeToPerform(values)">',
                '<div class="quest-timer">',
                '<span class="dropdown">{timedropfrom:countdown}</span>',
                '</div>',
                '</tpl>',
                '</div>',
                '<div class="wide-column">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_aim'] + ')"></div>',
                '<div class="info-box-content">',
                '<tpl if="aims.length">',
                '<ul>',
                '<tpl for="aims">',
                '<tpl if="parent.status == 0 || parent.status == -1">',
                '<tpl if="stage == 1">',
                // для доступных квестов показывается только первый этап
                '<li class="aim" {[this.templateHelpers.getAimStatus(parent.status, values.done, parent.aims.length)]}>',
                '<span class="aim-text" data-qtip="{[this.templateHelpers.getAimText(values.name)]}{[this.templateHelpers.getCounters(values, parent.status, xindex, 1)]}">{name}' + ' {[this.templateHelpers.getCounters(values, parent.status, xindex)]}' + '</span>',
                '</li>',
                '</tpl>',
                '<tpl else>',
                '<li class="aim" {[this.templateHelpers.getAimStatus(parent.status, values.done, parent.aims.length)]}>',
                '<span class="aim-text" data-qtip="{[this.templateHelpers.getAimText(values.name)]}{[this.templateHelpers.getCounters(values, parent.status, xindex, 1)]}">{name}' + ' {[this.templateHelpers.getCounters(values, parent.status, xindex)]}' + '</span>',
                '</li>',
                '</tpl>',
                '</tpl>',
                '</ul>',
                '</tpl>',
                '</div>',
                '</div>',
                '<div class="button-place expanded" id="button-place-{proto_id}"></div>',
                '</div>',
                '</div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        me.itemId = me.record.get('proto_id');
        me.expanded = me.setTpl(expanded);
        me.collapsed = me.setTpl(collapsed);
        me.callParent(arguments);
        me.on('render', function() {
            if (me.record.get('expanded') === true) {
                me.expand();
            } else {
                me.collapse();
            }
            me.el.on('click', function() {
                me.fireEvent('questaction', me.record);
            }, me, {
                delegate: '.world-quest-action'
            });
            me.el.on('click', function() {
                me.fireEvent('questcancel', me.record);
            }, me, {
                delegate: '.world-quest-cancel'
            });
            me.el.on('click', function() {
                me.fireEvent('questreroll', me.record);
            }, me, {
                delegate: '.world-quest-reroll'
            });
        });
        if (me.record.get('timedropfrom')) {
            me.mon(me.record, 'timedropchanged', function(time) {
                me.formatTime(time);
            }, me);
        }
    },
    formatTime: function(time) {
        var me = this;
        if (me.el) {
            var dropdown = me.el.down('.dropdown');
            if (dropdown) {
                if (time > 0) {
                    dropdown.update(Ext.util.Format.countdown(time, {
                        format: 'short'
                    }));
                } else {
                    me.destroy();
                }
            }
        }
    },
    getRewards: function() {
        var me = this,
            rewards = me.record.get('rewards') || [],
            random_rewards = me.record.get('random_rewards');
        if (random_rewards) {
            if (typeof random_rewards == 'object') {
                rewards = rewards.concat(random_rewards);
            } else {
                rewards = rewards.concat({
                    type: 'item',
                    params: {
                        id: ExGods.ref('constants|random_reward').value
                    }
                });
            }
        }
        if (rewards.length) {
            ExGods.util.Helper.loadProtosFromStuff(rewards, function() {
                var rewardsHtml = ExGods.stuff.StuffManager.image(rewards),
                    rewardsEl = document.createElement('div'),
                    ul = me.el && me.el.down('.info-box-rewards ul');
                rewardsEl.innerHTML = rewardsHtml;
                Ext.get(rewardsEl).select('li').addCls('info-box-itembox');
                if (ul) {
                    ul.update(rewardsEl.firstChild.innerHTML);
                    for (var i = rewards.length; i < 7; i++) {
                        ul.insertHtml('beforeEnd', '<li class="info-box-itembox"></li>');
                    }
                }
            });
        }
    },
    renderSubmitButton: function() {
        var me = this,
            status = me.record.get('status'),
            droppable = me.record.get('droppable'),
            id = me.record.get('proto_id'),
            reroll_stuff = me.record.get('reroll_stuff'),
            params = {};
        switch (status) {
            case 0:
                params.text = ExGods.getMsgByKey('view_quest_listitem_takebtn');
                params.cls = 'qh-object world-quest-action no_border';
                break;
            case 2:
                params.text = ExGods.getMsgByKey('view_quest_listitem_rewardbtn');
                params.cls = 'qh-object world-quest-action no_border';
                break;
        }
        if (droppable && !params.text) {
            params.text = ExGods.getMsgByKey('view_quest_listitem_cancelbtn');
            params.cls = 'qh-object x-btn-txt-red world-quest-cancel no_border';
        }
        params.width = 163;
        params.renderTo = 'button-place-' + id;
        if (params.text) {
            var btn = Ext.widget('textbutton', params);
            if (me.record.data.params.is_tutorial && (me.record.data.status == 0 || me.record.data.status == 2))  {
                btn.el.set({
                    'data-qh_otype': 'tutorial_quests',
                    'data-qh_oid': '1',
                    'data-qh_opts': "{&quot;cls&quot;:&quot;flip-h&quot;}"
                });
            }
            
        }
        //задание не взято, и есть возможность его рерольнуть
        if (reroll_stuff && status == 0) {
            var rerollBtn = Ext.widget('textbutton', {
                    text: ExGods.getMsgByKey('quest_reroll_btn_text') + ExGods.util.Stuff.printStuff(reroll_stuff),
                    cls: 'x-btn-txt-red world-quest-reroll no_border',
                    width: params.width,
                    renderTo: params.renderTo,
                    style: {
                        marginLeft: '15px'
                    }
                });
            me.el.down('#' + params.renderTo).setStyle('margin-left', '-170px');
        }
    },
    collapse: function() {
        var me = this;
        me.collapsed.overwrite(me.el, me.record.data);
        me.formatTime(me.record.get('timedropfrom'));
        me.renderSubmitButton();
        me.record.set('expanded', false);
        me.callParent();
    },
    expand: function() {
        var me = this;
        me.expanded.overwrite(me.el, me.record.data);
        me.formatTime(me.record.get('timedropfrom'));
        me.getRewards();
        me.renderSubmitButton();
        me.record.set('expanded', true);
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var rewards = [];
        var obj = ExGods.references.get('images').get('quest_icons').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        obj = ExGods.ref('images|common_text_images').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        rewards = me.record.get('rewards') || [] , random_rewards = me.record.get('random_rewards');
        if (random_rewards) {
            if (typeof random_rewards == 'object') {
                rewards = rewards.concat(random_rewards);
            } else {
                rewards = rewards.concat({
                    type: 'item',
                    params: {
                        id: ExGods.ref('constants|random_reward').value
                    }
                });
            }
        }
        return {
            stuff: rewards || [],
            images: [
                IMAGE_URL + 'quests/bg.png',
                IMAGE_URL + 'quests/top_1.png',
                IMAGE_URL + 'quests/top_2.png',
                IMAGE_URL + 'quests/top_3.png',
                IMAGE_URL + 'quests/side_left.png',
                IMAGE_URL + 'quests/side_right.png',
                IMAGE_URL + 'quests/bottom_1.png',
                IMAGE_URL + 'quests/bottom_2.png',
                IMAGE_URL + 'quests/bottom_3.png',
                IMAGE_URL + 'quests/item_box.jpg',
                IMAGE_URL + 'quests/button_task_close.png',
                IMAGE_URL + 'scrollbar/thumb.png',
                IMAGE_URL + 'scrollbar/bg_midle.png',
                IMAGE_URL + 'scrollbar/bg_top.png',
                IMAGE_URL + 'scrollbar/bg_bottom.png',
                IMAGE_URL + 'shop/btn_buy.png',
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Вьюшка для actions диалога.
 *
 * По умолчанию используется Dialog view для отображения actions
 *
 * @author Ветлугин Дмитрий
 *
 */
Ext.define('ExGods.view.dialog.DialogActions', {
    extend: Ext.container.Container,
    alias: 'widget.dialog_actions',
    dock: 'bottom',
    layout: 'anchor',
    id: 'actions-container',
    margin: '4 0 0 0',
    /**** @cfg {array} массив обьектов
     *  :text текст кнопки
     *  :action действие при нажатии
     */
    actions: [],
    /**** @cfg {object} по умолчанию итемы будут
     * кнопками
     * на всю ширину
     */
    defaults: {
        xtype: 'textbutton',
        anchor: '100%'
    },
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
        me.setActions(me.actions);
    },
    /**
     * Обновить список действий диалога
     * param {Array} Массив компонентов действий (кнопок в общем случае)
     */
    setActions: function(actions) {
        var me = this;
        me.removeAll();
        me.add(actions);
        actions.length ? me.show() : me.hide();
    }
});

/**
 * Список доступных квестов
 */
Ext.define('ExGods.store.AvailableQuests', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Quest',
    id: 'available_quests'
});
// proxy: {
//  type: 'ajax',
//  url: '/game.pl?cmd=quests.current',
//  limitParam: false,
//  pageParam: false,
//  startParam: false,
//  reader: {
//      type: 'json',
//      rootProperty: 'quests'
//  }
// }

/**
 * Контроллер квестов
 */
Ext.define('ExGods.controller.Quest', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: false,
        prefix: 'QuestController:'
    },
    stores: [
        'AvailableQuests',
        'Quests'
    ],
    models: [
        'Quest',
        'User'
    ],
    views: [
        'CommonDetailsWindow',
        'quest.TabPanel',
        'quest.Column',
        'List',
        'quest.NewList',
        'ListItem',
        'quest.ListItem',
        'TextButton',
        'dialog.DialogActions'
    ],
    tooltips: [
        'quest'
    ],
    refs: [
        {
            /**
             * @private
             * @method getQuestWnd
             * Возвращает окно с описанием ззадания
             */
            ref: 'questWnd',
            selector: '#QUESTS'
        },
        {
            /**
             * @private
             * @method getQuestDescriptionPanel
             * Получет контейнер описания квеста
             * @return {Ext.container.Container}
             */
            ref: 'questDescriptionPanel',
            selector: '#quest-description'
        },
        {
            ref: 'questButton',
            selector: '#mainmenu-quests-button'
        },
        {
            /**
             * @method getQuestList
             */
            ref: 'questList',
            selector: 'questnewlist'
        },
        {
            /**
             * @method getQuestTabs
             */
            ref: 'questTabs',
            selector: 'questtabpanel'
        },
        {
            /**
             * @method getDialog
             * @return {ExGods.view.Dialog}
             */
            ref: 'dialog',
            selector: '#quest-dialog'
        },
        {
            /**
             * NEW
             * @method getLocationView
             * @return {ExGods.view.Dialog}
             */
            ref: 'locationView',
            selector: 'locationmain'
        }
    ],
    /**
     * @property {Ext.XTemplate} questTpl
     * Шаблон описания квеста
     */
    init: function() {
        var me = this;
        me.service = ExGods.Services.get('quests');
        me.control({
            '#QUESTS questtabpanel': {
                afterrender: {
                    fn: me.onQuestsShow,
                    delay: 200
                }
            },
            '#QUESTS': {
                show: {
                    fn: function(wnd) {
                        if (wnd && wnd.down)  {
                            me.onQuestsShow(wnd.down('questtabpanel'));
                        }
                        
                    },
                    buffer: 100
                }
            },
            // нужна обработка в другом потоке + возможно несклько событий show подряд
            'questlist dataview': {
                itemclick: {
                    fn: me.onQuestClick,
                    delay: 0
                }
            },
            //NEW
            'questcolumn dataview': {
                itemclick: me.showQuestsWnd
            },
            'questcolumn button[dock="bottom"]': {
                click: me.showQuestsWnd
            },
            'questlistitem': {
                questaction: me.onWorldQuestAction,
                questcancel: me.onWorldQuestCancel,
                questreroll: me.onWorldQuestReroll,
                togglequesttracing: me.toggleQuestTracing
            }
        });
        // Добавляю обработчик ответа от сервера по ключу "trace_quest"
        me.addAjaxRequestKeyHandler('trace_quest', function(data) {
            var quest = me.getQuestsStore().getById(parseInt(data.trace_quest.proto_id));
            if (quest) {
                quest.set(data.trace_quest);
            }
        }, me);
        // Добавляю обработчик ответа от сервера по ключу "quests"
        me.addAjaxRequestKeyHandler('quests', function(data) {
            Ext.each(data.quests, function(quest) {
                var q = me.getQuestsStore().findRecord('proto_id', quest.proto_id);
                if (q && q.get('expanded')) {
                    quest.expanded = q.get('expanded');
                }
            });
            this.getQuestsStore().loadRawData(data.quests);
        }, me);
        me.application.getChatConnection().on({
            command_quests: me.onQuestsCommand,
            scope: me
        });
        ExGods.Components.addComponentInitializer('quests', me.initQuestsComponent, me);
        ExGods.Components.addComponentInitializer('quest_giver_list', me.initQuestGiverListComponent, me);
        ExGods.Components.addComponentInitializer('quest_button', me.initQuestButtonComponent, me);
        me.getQuestsStore().on('datachanged', function() {
            ExGods.Resources.load(me);
        });
    },
    /**
     * срабатывает на команду command_quests из чата
     */
    onQuestsCommand: Ext.Function.createBuffered(function(chatcn, data) {
        ExGods.Services.updateGroupOfServices('quests');
    }, 250),
    /*
     * @param {ExGods.view.TextButton[]} actions Список возможных действий
     * @param {Boolean} [closable=false] Показывать ли кнопку "Закрыть"
     */
    showQuest: function(quest, giverData, actions, closable) {
        var me = this,
            app = me.application,
            protos = me.application.getItemPrototypesStore(),
            missedProtos = [],
            container = me.getDialog();
        //удаляем уже имеющийся диалог (надо, т.к. листенер модели работает для всех квестов прежде отображенных в этом контейнере) и создаем новый
        if (container) {
            container.destroy();
        }
        container = Ext.widget('quest_dialog', {
            info: giverData,
            data: quest.data,
            actions: actions,
            id: 'quest-dialog',
            closable: closable
        });
        // запоминаем модель квеста, который сейчас отображен в контейнере
        container.quest = quest;
        // показываем
        me.application.getController('OverlayPanel').setLeftComponent(container, true, false);
        //догружаем награды
        var rewards = quest.get('rewards');
        if (rewards && rewards.length) {
            Ext.Array.forEach(rewards, function(reward) {
                if (reward.type == 'item') {
                    var proto_id = parseInt(reward.params.id);
                    if (!protos.data.getByKey(proto_id) && !Ext.Array.contains(missedProtos, proto_id)) {
                        missedProtos.push(proto_id);
                    }
                }
            });
        }
        if (missedProtos.length) {
            ExGods.util.Helper.maskElement(container.body);
            protos.loadNew(missedProtos, function() {
                container.body.unmask();
            });
        }
        //вешаем обработчик на временные квесты
        if (quest.get('timedropfrom')) {
            container.mon(quest, 'timedropchanged', function(time) {
                if (container.el) {
                    var dropdown = container.el.down('.dropdown');
                    if (dropdown)  {
                        if (time > 0) {
                            dropdown.update(Ext.util.Format.countdown(time));
                        } else {
                            container.destroy();
                        };
                    }
                    
                }
            }, me);
        }
        return container;
    },
    /**
     * @private
     * Показывает выбранный квест
     * 
     * @param {Ext.view.View} view Отображение списка квестов
     * @param {ExGods.model.Quest} quest Модель квеста
     * @param {HTMLElement} item 
     * @param {Number} index
     * @param {Ext.EventObject} e
     */
    onQuestClick: function(view, quest, item, index, e) {
        var me = this,
            giver = quest.get('giver'),
            giverData = {
                image: Ext.BLANK_IMAGE_URL
            };
        // при нажатии на кнопку отслеживания панель инфы по квесту не переключать
        if (Ext.fly(e.target).hasCls('tracequest-btn')) {
            me.toggleQuestTracing(quest);
            return;
        }
        if (giver.bot_data) {
            var bot = Ext.create('ExGods.model.User', quest.get('giver'));
            giverData = {
                title: bot.get('display_title'),
                image: bot.getAvatar(),
                description: bot.get('bot_data').description,
                greetings_template: bot.get('bot_data').greetings_template || ''
            };
        } else {
            giverData = {
                title: giver.title,
                image: (giver.image_info || giver.image) ? (IMAGE_URL + (giver.image_info || giver.image)) : Ext.BLANK_IMAGE_URL,
                description: giver.description
            };
        }
        var actions = [];
        // кнопка "Отказаться от задания"
        if (quest.get('droppable')) {
            actions.push({
                xtype: 'textbutton',
                handler: function() {
                    me.request({
                        url: '/map.pl?cmd=del_quest',
                        method: 'GET',
                        params: {
                            qid: quest.get('proto_id')
                        },
                        success: function(json) {
                            var questView = Ext.getCmp('quest-dialog');
                            if (questView && questView.quest == quest) {
                                questView.destroy();
                            }
                        }
                    });
                },
                text: ExGods.getMsgByKey('quests_del_quest_btn')
            });
        }
        me.showQuest(quest, giverData, actions);
    },
    /**
     * @private
     * Переключает отслеживание квеста. Если квест уже отслеживается - слежка отключается
     */
    toggleQuestTracing: function(quest, item) {
        var me = this,
            list = item.ownerCt.el;
        ExGods.util.Helper.maskElement(list);
        me.request({
            url: '/game.pl?cmd=trace_quest',
            params: {
                qid: quest.isTraced() ? 0 : quest.get('proto_id')
            },
            success: function(json) {
                list.unmask();
                if (me.getQuestList()) {
                    me.getQuestList().rerender();
                }
            },
            scope: me
        });
    },
    onQuestsShow: function(cmp) {
        var me = this,
            tabs = {
                available: cmp.getComponent('available_quests')
            },
            count = this.getUser().availableQuestsStore.getCount(),
            currentTab;
        if (me.selected_quest) {
            if (me.selected_quest.data.status == 2 || me.selected_quest.data.status == 1) {
                tabs.active = cmp.getComponent('active_quests');
                currentTab = 'active';
            } else {
                currentTab = 'available';
            }
            if (count > 0) {
                cmp.setActiveTab(currentTab + '_quests');
            } else {
                cmp.setActiveTab('active_quests');
            }
            if (me.selected_quest.data) {
                tabs[currentTab].scrollTo(me.selected_quest);
            } else {
                tabs[currentTab].showDefault();
            }
            me.selected_quest = null;
        } else {
            if (count > 0) {
                currentTab = cmp.setActiveTab('available_quests');
            } else {
                currentTab = cmp.setActiveTab('active_quests');
            }
            var record = currentTab.store.getAt(0);
            if (record) {
                record.set('expanded', true);
                currentTab.scrollTo(record);
            }
        }
        setTimeout(function() {
            cmp.up().el.setStyle('opacity', 1);
        }, 100);
    },
    /*
     * NEW functions
     * Открыть окно квестов
     */
    showQuestsWnd: function(view, quest, item, index, e) {
        var me = this,
            cmp = Ext.getCmp('QUESTS');
        me.selected_quest = quest;
        if (cmp) {
            ExGods.app.block();
            ExGods.Resources.load(cmp, function() {
                ExGods.app.unblock();
                cmp.show();
            });
        } else {
            ExGods.Components.factory('QUESTS');
        }
    },
    /*
     * NEW
     * событие questaction, срабатывает при нажатии на кнопку "Сдать" и "Взять"
     */
    onWorldQuestAction: function(record) {
        var me = this,
            status = record.get('status').toString(),
            fn, message;
        switch (status) {
            case '0':
                fn = record.getGiveConfirmation;
                break;
            case '2':
                fn = record.getTakeConfirmation;
                break;
        }
        message = fn.call(record);
        if (message) {
            // показываю диалог подтверждения взятия квеста
            Ext.widget('confirmdialog', {
                message: message,
                handler: Ext.bind(me.doWorldQuestAction, me, [
                    record
                ])
            });
        } else {
            me.doWorldQuestAction(record);
        }
    },
    /*
     * NEW
     * событие questaction, срабатывает при нажатии на кнопку "Сдать" и "Взять"
     */
    doWorldQuestAction: function(record) {
        var me = this,
            qid = record.get('proto_id'),
            status = record.get('status').toString(),
            cmd, index;
        switch (status) {
            case '0':
                cmd = 'quests_get';
                index = me.user.availableQuestsStore.indexOf(record);
                break;
            case '2':
                cmd = 'quests_finish';
                index = me.getQuestsStore().indexOf(record);
                break;
        }
        me.service.command(cmd, {
            qid: qid
        }, function(json) {
            var oQuest = me.getQuestsStore().getById(parseInt(record.raw.proto_id));
            if (json.quest) {
                if (json.quest.status == 5) {
                    if (oQuest)  {
                        me.getQuestsStore().remove(oQuest);
                    }
                    
                } else {
                    if (oQuest) {
                        oQuest.set(json.quest);
                    } else {
                        me.getQuestsStore().loadRawData([
                            json.quest
                        ], true);
                        me.getUser().availableQuestsStore.remove(record);
                    }
                }
            }
            if (json.list) {
                ExGods.app.getStore('Adventures').loadRawData(json.list);
            }
            me.onAfterAction(index);
        });
    },
    /*
     * событие questcancel, срабатывает при нажатии на кнопку "Отказаться от задания"
     */
    onWorldQuestCancel: function(record) {
        var me = this,
            index = me.getQuestsStore().indexOf(record);
        me.service.command('quests_delete', {
            qid: record.get('proto_id')
        }, function() {
            me.onAfterAction(index);
        });
    },
    /*
     * событие questreroll, срабатывает при нажатии на кнопку "Сменить задание"
     */
    onWorldQuestReroll: function(record) {
        var me = this,
            index = me.getQuestsStore().indexOf(record),
            tpl = new Ext.XTemplate(ExGods.ref('message_client|quest_reroll_confirm')).apply({
                cost: ExGods.util.Stuff.printStuff(record.get('reroll_stuff'))
            });
        Ext.widget('confirmdialog', {
            message: tpl,
            handler: function() {
                me.service.command('quests_reroll', {
                    qid: record.get('proto_id')
                }, function() {
                    me.onAfterAction(index);
                });
            }
        });
    },
    /**
     * Обработчик после действия пользователя. Решает, что делать с компонентом - закрыть или переключить на другую вкладку
     * index - индекс квеста в сторе активной вкладки, который нужно открыть
     */
    onAfterAction: function(index) {
        var me = this,
            activeQuests = me.getQuestsStore(),
            availQuests = me.user.availableQuestsStore,
            wnd = me.getQuestWnd(),
            cmp, activeItem;
        cmp = wnd.down('questtabpanel');
        activeItem = cmp.getLayout().getActiveItem();
        if (activeItem && activeItem.itemId == 'available_quests') {
            if (!availQuests.getCount()) {
                wnd.close();
            }
        } else if (activeItem && activeItem.itemId == 'active_quests' && !activeQuests.getCount()) {
            if (availQuests.getCount()) {
                cmp.getLayout().setActiveItem(1);
                // переключаю на вкладку "available_quests"
                index = 0;
            } else {
                wnd.close();
            }
        }
        if (cmp.isVisible() && typeof index == 'number') {
            setTimeout(function() {
                var store = cmp.getLayout().getActiveItem().store,
                    record = store.getAt(index);
                if (record) {
                    var listitem = cmp.getLayout().getActiveItem().getComponent('wrap').getComponent(record.get('proto_id'));
                    if (listitem) {
                        listitem.expand();
                    } else {
                        record.set('expanded', true);
                    }
                }
            }, 0);
        }
    },
    initQuestGiverListComponent: function(config, componentId) {
        var me = this,
            cmp = Ext.getCmp('LOB_QUEST_GIVER_LIST');
        if (cmp)  {
            cmp.close();
        }
        
        cmp = Ext.widget('questcolumn', {
            id: 'LOB_QUEST_GIVER_LIST',
            user: me.getUser(),
            width: 85,
            height: 365
        });
        return cmp;
    },
    initQuestButtonComponent: function(config) {
        var me = this,
            btn = Ext.getCmp('LOB_QUEST_BUTTON');
        if (btn)  {
            btn.destroy();
        }
        
        return Ext.widget('textbutton', {
            id: 'LOB_QUEST_BUTTON',
            cls: 'double_text_btn double_text x-btn-txt',
            height: 42,
            width: 92,
            minWidth: 10,
            handler: function() {
                me.showQuestsWnd();
            },
            text: config.btn_text,
            listeners: {
                afterrender: function() {
                    if (me.getQuestButton())  {
                        me.getQuestButton().drawLocationCount(true);
                    }
                    
                }
            }
        });
    },
    initQuestsComponent: function(config) {
        var me = this,
            activeQuestsStore = me.getQuestsStore(),
            availQuestsStore = me.user.availableQuestsStore,
            wnd, quest,
            _setSelectedQuestFromAction = function(clientAction) {
                if (clientAction.options.active_quests) {
                    quest = activeQuestsStore.getById(clientAction.options.active_quests.qid);
                    if (quest)  {
                        me.selected_quest = quest;
                    }
                    
                } else if (clientAction.options.available_quests) {
                    quest = availQuestsStore.getById(clientAction.options.available_quests.qid);
                    if (quest)  {
                        me.selected_quest = quest;
                    }
                    
                }
                if (wnd)  {
                    wnd.show();
                }
                
            };
        if (config.clientAction) {
            _setSelectedQuestFromAction(config.clientAction);
        }
        wnd = Ext.widget('window2', {
            id: 'QUESTS',
            closeAction: 'hide',
            onClientAction: _setSelectedQuestFromAction,
            autoShow: false,
            style: {
                opacity: 0
            },
            items: [
                {
                    xtype: 'questtabpanel',
                    items: [
                        {
                            xtype: 'questnewlist',
                            icon: ExGods.ref('images|quest_images').image.active_quests,
                            store: activeQuestsStore,
                            itemId: 'active_quests',
                            description: '',
                            tabtitle: '',
                            quantityLeft: 145,
                            emptyText: ''
                        },
                        {
                            xtype: 'questnewlist',
                            icon: ExGods.ref('images|quest_images').image.available_quests,
                            store: availQuestsStore,
                            itemId: 'available_quests',
                            description: '',
                            tabtitle: '',
                            quantityLeft: 133,
                            skipFilter: true,
                            emptyText: ''
                        }
                    ]
                }
            ],
            isVisible: function() {
                var me = this,
                    hidden;
                if (me.hidden || !me.rendered || me.isDestroyed || me.el.getStyle('opacity') == 0) {
                    hidden = true;
                }
                return !hidden;
            },
            listeners: {
                hide: function() {
                    this.el.setStyle({
                        opacity: 0
                    });
                }
            }
        });
        ExGods.app.block();
        ExGods.Resources.load(wnd, function() {
            ExGods.app.unblock();
            wnd.show();
        });
        return wnd;
    },
    getResources: function() {
        var me = this,
            images = [],
            stuff = [];
        me.getQuestsStore().each(function(item) {
            if (item.data.params && item.data.params.image) {
                images.push(item.data.params.image);
            }
            if (item.rewards && item.rewards.length) {
                stuff = stuff.concat(item.rewards);
            }
        });
        return {
            images: images,
            stuff: stuff
        };
    },
    /**
     * Реализация метода источника тултипов
     */
    getTooltipData: function(type, value) {
        var me = this,
            data;
        if (type == 'quest') {
            data = me.getQuestsStore().getById(parseInt(value));
            if (!data) {
                data = me.user.availableQuestsStore.getById(parseInt(value));
            }
            return data;
        }
    }
});

/**
 * Контроллер помощника по квестам (v.2)
 *
 * Пример элемента интерфейса, на который может быть выставлен указатель квест-хелпера:
 *
 *      <div class="qh-object" data-qh_otype="bot" data-qh_oid="123"></div>
 *
 *
 * @author Oleg Mikhailov
 *
 */
Ext.define('ExGods.controller.QuestHelper', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: false,
        prefix: 'QuestHelper:'
    },
    stores: [
        'Quests'
    ],
    models: [
        'User'
    ],
    refs: [
        {
            /**
         * @method getLayerOver2
         */
            ref: 'layerOver2',
            selector: '#layer-over2'
        }
    ],
    /**
     * @property {Boolean} traced Флаг активности слежки (readonly)
     */
    traced: false,
    /**
     * @property {Boolean} disabled Флаг блокировки маркеров (readonly)
     */
    disabled: false,
    shopItems: [],
    shopItemKits: [],
    init: function() {
        var me = this;
        me.listen({
            component: {
                '#LOB_BOT_LIST > dataview': {
                    refresh: {
                        fn: me.onBotsListRefresh,
                        delay: 1
                    }
                }
            }
        });
        me.lairCtrl = me.app.getController('Lair');
        me.fucinaCtrl = me.app.getController('Fucina');
        me.app.getController('Viewport').on('layoutchanged', function(viewport, layout) {
            if (layout == 'battle') {
                me.setDisabled(true);
            } else {
                me.setDisabled(false);
            }
        });
    },
    onLaunch: function() {
        this.startTracing();
    },
    /**
     * @private
     * Запускает слежку
     */
    startTracing: function() {
        var me = this;
        /**/
        me.log('запускаю отслеживание..');
        if (!me.traceInterval) {
            me.traceInterval = window.setInterval(Ext.bind(me.showAllPointers, me), 1000);
        }
        me.showAllPointers();
        me.startAnim();
        me.traced = true;
        return me.traceInterval;
    },
    /**
     * @private
     * Останавливает слежку
     */
    stopTracing: function() {
        var me = this;
        if (me.traceInterval) {
            window.clearInterval(me.traceInterval);
            me.traceInterval = null;
        }
        me.removeAllPointers();
        me.stopAnim();
        me.traced = false;
        /***/
        me.log('отслеживание остановлено.');
    },
    /**
     * @private
     * Блокирует отображение квест-маркеров
     */
    setDisabled: function(disabled) {
        var me = this;
        me.disabled = disabled;
        if (me.traced) {
            if (me.disabled) {
                me.removeAllPointers();
            } else {
                me.showAllPointers();
            }
        }
    },
    isDisabled: function() {
        return this.disabled;
    },
    /**
     * Срабатывает, когда отслеживаемый квест поменялся
     */
    onChangeTraceQuest: function() {
        var me = this;
        /**/
        me.log('отслеживаемый квест изменился');
        if (me.getTracedQuest()) {
            if (!me.traced) {
                me.startTracing();
            }
        } else {
            if (me.traced) {
                me.stopTracing();
            }
        }
    },
    /**
     * Срабатывает на обновление данных по квестам в сторе квестов
     */
    onQuestsStoreUpdate: function() {
        var me = this;
        /**/
        me.log('данные по квестам изменились. Актуализирую состояние слежки');
        if (me.getTracedQuest()) {
            if (!me.traced) {
                me.startTracing();
            }
        } else {
            if (me.traced) {
                me.stopTracing();
            }
        }
    },
    /**
     * @private
     */
    onBotsListRefresh: function() {
        var me = this;
        if (me.traced) {
            me.showAllPointers();
        }
    },
    /** 
     * @private
     * Удаляет все указатели
     */
    removeAllPointers: function() {
        var me = this;
        Ext.select('.qh-on').each(function(el) {
            me.hidePointer(el);
        });
    },
    /**
     * @private
     * Показывает все указатели
     */
    showAllPointers: function() {
        var me = this;
        if (me.isDisabled()) {
            /***/
            me.log('отображение маркеров заблокировано..');
            return;
        }
        me.shopItems = [];
        me.shopItemKits = [];
        var tracedObjects = {
                quest: [],
                location: [],
                iobject: [],
                bot: [],
                item: [],
                menu: [],
                maskobject: [],
                shop_item_kit: [],
                shop_item: [],
                skill_interface: [],
                lair: [],
                arena_button_battle: [],
                bot_button_attack: [],
                bot_button_banish: [],
                room_mask: [],
                room_mask_button_uluchshit: [],
                skill_interface_boost: [],
                skill_interface_boost_complete: [],
                inventory_item: [],
                inventory_item_button_puton: [],
                lair_button_start: [],
                tutorial_quests: [
                    '1'
                ],
                bot_any: [],
                bot_button_attack_any: [],
                bot_button_banish_any: [],
                active_slot: [],
                protect_slot_button: [],
                lair_mode: [],
                map_action: [],
                world: [],
                payment_buy_button: [],
                payment_exchange: [],
                exchange_gold_button: [],
                exchange_crystal_button: [],
                forge_entry: [],
                forge_type: [],
                forge_type_ready_button: [],
                forge_item: [],
                forge_item_action_btn: [],
                tools_menu_fullscreen_button: [],
                robbery_button_battle: [],
                room_pet_button_puton: [],
                room_pet: []
            };
        me.getQuestsStore().each(function(quest) {
            var answer = me.getTracedObjects(quest, tracedObjects);
        });
        /***/
        me.log('отслеживаю объекты', tracedObjects);
        Ext.select('.qh-object').each(function(el) {
            var objectType = el.dom.getAttribute('data-qh_otype');
            var objectId = el.dom.getAttribute('data-qh_oid');
            var options = el.dom.getAttribute('data-qh_opts');
            if (options) {
                options = Ext.decode(Ext.String.htmlDecode(options));
            } else {
                options = {};
            }
            if (Ext.isArray(tracedObjects[objectType]) && Ext.Array.indexOf(tracedObjects[objectType], objectId) != -1) {
                me.showPointer(el, options);
            } else {
                me.hidePointer(el);
            }
            if ((objectType == 'bot_button_attack' && tracedObjects.bot_button_attack_any.length) || (objectType == 'bot_button_banish' && tracedObjects.bot_button_banish_any.length)) {
                me.showPointer(el, options);
            }
            if ((objectType == 'lair_mode' && el.hasCls('selected'))) {
                me.hidePointer(el);
            }
            //хардкодю табы магазина
            if (el.dom.id.substr(0, 9) == 'shop-tab-') {
                var shopView = ExGods.app.getShopController().getShopTabs(),
                    tabPanel = shopView.down('skintabpanel'),
                    activeTab = tabPanel.getActiveTab().id,
                    index = el.dom.id.substr(9),
                    shop = tabPanel.items.items[index],
                    store = shop.shop.itemsStore,
                    hasItems = false;
                Ext.Array.each(me.shopItems, function(id) {
                    if (store.findBy(function(item) {
                        var proto = item.get('item_proto');
                        return proto.get ? proto.get('entry') == id : false;
                    }) != -1) {
                        hasItems = true;
                    }
                });
                Ext.Array.each(me.shopItemKits, function(id) {
                    if (store.findBy(function(item) {
                        var proto = item.get('item_proto');
                        return proto.entry ? proto.entry == id : false;
                    }) != -1) {
                        hasItems = true;
                    }
                });
                if (hasItems && shop.id != activeTab) {
                    me.showPointer(el.up('.x-tab-bar'), {
                        style: 'left:' + (53 * index - 45) + 'px'
                    });
                } else if (hasItems) {
                    me.hidePointer(el.up('.x-tab-bar'));
                }
            }
        });
        Ext.select('.quest.tutorial').each(function(el) {
            if (!el.hasCls('active')) {
                me.showPointer(el);
            }
        });
    },
    /**
     * @private
     * Вернет список объектов, которые нужно отследить в данный момент для отслеживаемого квеста
     * @return {Array}
     */
    getTracedObjects: function(quest, objects) {
        var me = this,
            //          quest = me.getTracedQuest(),
            aims = quest ? quest.get('aims') : [],
            marks = [],
            path, i,
            layerOver2 = me.getLayerOver2();
        // маркеры самого квеста
        if (quest) {
            marks = quest.get('marks');
        }
        // маркеры целей квеста
        if (aims.length) {
            for (i = 0; i < aims.length; i++) {
                if (aims[i].marks && aims[i].marks.length) {
                    marks = Ext.Array.merge(marks, aims[i].marks);
                    break;
                }
            }
        }
        // достаем маркеры первой цели с маркерами
        me.room_mask = [];
        // для каждого маркера определяю дошел ли пользователь до нужной локации.
        // если не дошел, то для этого маркера нужно установить указатель на локацию (отслеживаемый объект "location"),
        // иначе отслеживаемым объектом для маркера будет либо бот, либо предмет, либо пункт меню.
        for (i = 0; i < marks.length; i++) {
            path = marks[i].path && marks[i].path.length ? marks[i].path[0] : [];
            if (path.length == 0 || path.length == 1) {
                // если длина пути = 0 - путь не был задан
                //  если длина пути = 1 - юзер дошел до нужной локации
                if (marks[i].object) {
                    if (marks[i].object.object_type == 1) {
                        objects.bot.push(marks[i].object.object_id);
                    } else if (marks[i].object.object_type == 2) {
                        objects.item.push(marks[i].object.object_id);
                    }
                }
                if (marks[i].menu) {
                    if (!layerOver2 || !layerOver2.isVisible()) {
                        objects.menu.push(marks[i].menu);
                    }
                }
                if (marks[i].iobject) {
                    objects.iobject.push(marks[i].iobject);
                }
                if (marks[i].room_mask) {
                    if (ExGods.app.getController('Masks').currentFitMask && ExGods.app.getController('Masks').currentFitMask.get('id') != marks[i].room_mask.toString()) {
                        objects.maskobject.push(marks[i].room_mask);
                        me.room_mask.push(marks[i].room_mask);
                    }
                }
                if (marks[i].room_mask_button_uluchshit) {
                    if (ExGods.app.getController('Masks').currentFitMask && ExGods.app.getController('Masks').currentFitMask.get('id') != marks[i].room_mask_button_uluchshit.toString()) {
                        objects.maskobject.push(marks[i].room_mask_button_uluchshit);
                    }
                    if (ExGods.app.getController('Masks').currentFitMask && ExGods.app.getController('Masks').currentFitMask.get('id') == marks[i].room_mask_button_uluchshit.toString()) {
                        objects.room_mask_button_uluchshit.push(marks[i].room_mask_button_uluchshit);
                    }
                }
                if (marks[i].room_pet) {
                    var currentPet = ExGods.app.getController('Pets').currentPet;
                    if (!currentPet || (currentPet && currentPet.get('item_proto').entry != marks[i].room_pet.toString())) {
                        objects.room_pet.push(marks[i].room_pet);
                    } else {
                        objects.room_pet_button_puton.push('1');
                    }
                }
                if (marks[i].shop_item_kit) {
                    me.shopItemKits.push(marks[i].shop_item_kit);
                    objects.shop_item_kit.push(marks[i].shop_item_kit);
                }
                if (marks[i].shop_item) {
                    me.shopItems.push(marks[i].shop_item);
                    objects.shop_item.push(marks[i].shop_item);
                }
                if (marks[i].skill_interface) {
                    var skillTabsData = ExGods.app.getSkillsStore().data.items,
                        show_marker = false;
                    for (var j = 0; j < skillTabsData.length; j++) {
                        skillTabsData[j].data.skills.each(function(skill) {
                            if (skill.data.name == marks[i].skill_interface) {
                                if (skill.data.can_master || skill.data.progress.is_ready)  {
                                    show_marker = true;
                                }
                                
                            }
                        });
                    }
                    if (show_marker)  {
                        objects.skill_interface.push(marks[i].skill_interface);
                    }
                    
                }
                if (marks[i].lair_id && marks[i].lair_mode && marks[i].lair_stage) {
                    if (me.lairCtrl.selectedStage != marks[i].lair_stage || me.lairCtrl.activeMode != marks[i].lair_mode) {
                        //если этап не тот что нужен
                        objects.lair.push(marks[i].lair_id + '_' + marks[i].lair_mode + '_' + marks[i].lair_stage);
                    } else {
                        objects.lair_button_start.push('1');
                    }
                    objects.lair_mode.push(marks[i].lair_id + '_' + marks[i].lair_mode.toString());
                }
                if (marks[i].arena_button_battle) {
                    objects.arena_button_battle.push(marks[i].arena_button_battle.toString());
                }
                if (marks[i].bot_button_attack) {
                    objects.bot_button_attack.push(marks[i].bot_button_attack.toString());
                }
                if (marks[i].room_mask) {
                    objects.room_mask.push(marks[i].room_mask.toString());
                }
                if (marks[i].bot_button_banish) {
                    objects.bot_button_banish.push(marks[i].bot_button_banish.toString());
                }
                if (marks[i].skill_interface_boost) {
                    objects.skill_interface_boost.push(marks[i].skill_interface_boost.toString());
                }
                if (marks[i].skill_interface_boost_complete) {
                    objects.skill_interface_boost_complete.push(marks[i].skill_interface_boost_complete.toString());
                }
                if (marks[i].inventory_item) {
                    var open_window = false;
                    Ext.WindowMgr.each(function(win) {
                        if (win.initialCls == "item-window" && win.item && win.item.data && win.item.data.proto_id == marks[i].inventory_item)  {
                            open_window = true;
                        }
                        
                    });
                    if (!open_window)  {
                        objects.inventory_item.push(marks[i].inventory_item.toString());
                    }
                    
                }
                if (marks[i].inventory_item_button_puton) {
                    objects.inventory_item_button_puton.push(marks[i].inventory_item_button_puton.toString());
                }
                if (marks[i].bot_any) {
                    objects.bot_any.push(marks[i].bot_any.toString());
                }
                if (marks[i].bot_button_attack_any) {
                    objects.bot_button_attack_any.push(marks[i].bot_button_attack_any.toString());
                }
                if (marks[i].bot_button_banish_any) {
                    objects.bot_button_banish_any.push(marks[i].bot_button_banish_any.toString());
                }
                if (marks[i].active_slot) {
                    objects.active_slot.push(marks[i].active_slot.toString());
                }
                if (marks[i].protect_slot_button) {
                    objects.protect_slot_button.push(marks[i].protect_slot_button.toString());
                }
                if (marks[i].map_action) {
                    objects.map_action.push(marks[i].map_action.toString());
                }
                if (marks[i].world) {
                    objects.world.push(marks[i].world.toString());
                }
                if (marks[i].payment_buy_button) {
                    objects.payment_buy_button.push(marks[i].payment_buy_button.toString());
                }
                if (marks[i].payment_exchange) {
                    if (Ext.ComponentQuery.query('banktable')[0] && Ext.ComponentQuery.query('banktable')[0].selected && Ext.ComponentQuery.query('banktable')[0].selected.record.data.entry == marks[i].payment_exchange.toString()) {
                        objects.exchange_crystal_button.push('1');
                    } else if (Ext.ComponentQuery.query('banktable')[1] && Ext.ComponentQuery.query('banktable')[1].selected && Ext.ComponentQuery.query('banktable')[1].selected.record.data.entry == marks[i].payment_exchange.toString()) {
                        objects.exchange_gold_button.push('1');
                    } else  {
                        objects.payment_exchange.push(marks[i].payment_exchange.toString());
                    }
                    
                }
                if (Ext.getCmp('FUCINA')) {
                    // if (marks[i].forge_entry && me.fucinaCtrl.service && me.fucinaCtrl.service.data.fucina.current != marks[i].forge_entry) {
                    //  objects.forge_entry.push(marks[i].forge_entry);
                    // }
                    if (marks[i].forge_type && me.fucinaCtrl.service && me.fucinaCtrl.service.data.fucina.fucina_type != marks[i].forge_type) {
                        objects.forge_type.push(marks[i].forge_type);
                    }
                    if (marks[i].forge_type_ready_button && me.fucinaCtrl.service && me.fucinaCtrl.service.data.fucina.fucina_type == marks[i].forge_type_ready_button) {
                        objects.forge_type_ready_button.push(marks[i].forge_type_ready_button);
                    }
                    if (marks[i].forge_item) {
                        objects.forge_item.push(marks[i].forge_item);
                    }
                    if (marks[i].forge_item) {
                        objects.forge_item_action_btn.push(marks[i].forge_item);
                    }
                }
                if (marks[i].full_screen_button) {
                    objects.tools_menu_fullscreen_button.push("1");
                }
                if (marks[i].robbery_button_battle) {
                    objects.robbery_button_battle.push("1");
                }
            } else {
                objects.location = Ext.Array.merge(objects.location, path);
            }
        }
        if (objects.item.length) {
            // если есть маркер на предмет - добавляю также маркер на меню "инвентарь"
            objects.menu.push('inventory');
        }
        return objects;
    },
    //  ///
    //   * @priva//
    //   * Вернет текущий отслеживаемый квест или null, если такового н//
    //   * @return {ExGods.model.Ques//
    //   //
    //  getTracedQuest: function()//
    //      var me = thi//
    //      return me.getQuestsStore().getById( me.getUser().get('trace_quest_proto') //
    //  },
    /**
     * @private
     * Выставить указатель на элемент
     * @param {Ext.dom.Element} el
     * @param {Object} options Набор опций
     */
    showPointer: function(el, options) {
        var me = this;
        options = Ext.applyIf(options || {}, {
            cls: '',
            style: ''
        });
        if (!el.hasCls('qh-on')) {
            el.insertHtml('beforeEnd', '<div class="qh-pointer ' + options.cls + '" style="' + options.style + '"></div>');
            el.addCls('qh-on');
        }
    },
    /**
     * @private
     * Убрать указатель с элемента
     * @param {Ext.dom.Element} el
     */
    hidePointer: function(el) {
        var me = this;
        if (el.hasCls('qh-on')) {
            el.removeCls('qh-on');
            el.select('.qh-pointer').remove();
        }
    },
    /**
     * @private
     * Анимирует элементы указателя хелпера
     */
    startAnim: function() {
        var me = this;
        if (me._anim_timer_id)  {
            return;
        }
        
        var duration = 600,
            distance = 5,
            speed = 1,
            direction = -1,
            counter = 0;
        me._anim_timer_id = window.setInterval(function() {
            if (++counter % distance == 0) {
                direction *= -1;
            }
            Ext.select('.qh-pointer').each(function(el) {
                if (el.dom.offsetParent)  {
                    el.setStyle('left', (el.getLocalX() + speed * direction) + 'px');
                }
                
            });
        }, duration / distance);
    },
    /**
     * @private
     * Останавливает анимацию
     */
    stopAnim: function() {
        var me = this;
        if (me._anim_timer_id) {
            window.clearInterval(me._anim_timer_id);
            delete me._anim_timer_id;
        }
    },
    /**
     * @private
     * Вернет true, если отображена текущий лейаут - лейаут боя
     */
    isBattleLayout: function() {
        return Ext.getCmp('battle-container') ? true : false;
    }
});

/**
 * Окно с выбором цели-предмета
 */
Ext.define('ExGods.view.item.TargetWindow', {
    extend: ExGods.view.TargetWindow,
    alias: 'widget.itemtargetwindow',
    /**
     * @cfg {Array} items Массив моделей ExGods.model.Item, из которых нужно выбрать цель
     */
    items: null,
    cls: 'target-window item-target-window',
    padding: '10 10 15 10',
    buttonCls: ' ',
    //нужна простая кнопка - поэтому пробел.
    width: 350,
    initComponent: function() {
        var me = this;
        Ext.apply(this, {
            store: me.initStore(),
            itemTpl: me.getItemTpl(),
            searchField: 'title'
        });
        me.callParent();
    },
    /**
     * @private
     * Создает хранилище предметов-целей
     */
    initStore: function() {
        var me = this,
            store, missedProtos;
        store = Ext.create('Ext.data.Store', {
            fields: [
                'title',
                'level',
                'price',
                'dur',
                'dur_max',
                'dur_is_critical',
                'image',
                'upgrades',
                'item'
            ]
        });
        Ext.Array.each(me.items, function(item) {
            var proto = item.getProto();
            store.add({
                title: proto.get('title'),
                level: proto.getLevel(),
                dur: item.getDur(),
                dur_max: item.getMaxDur(),
                dur_is_critical: item.hasCriticalDurability(),
                price: proto.get('data').price,
                item: item
            });
        });
        return store;
    },
    getItemTpl: function() {
        return [
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="target-item">',
            '{[this.printImage(values)]}',
            '<div class="title">{title}</div>',
            '<div>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {level}</div>',
            '<div>' + ExGods.getMsgByKey('price_text') + ' {[this.getPrice(values)]}</div>',
            '<div <tpl if="dur_is_critical">class="critical-durability"</tpl>>' + ExGods.getMsgByKey('durability') + ' {dur}/{dur_max}</div>',
            '<div class="x-clear"></div>',
            '</div>',
            {
                getPrice: function(data) {
                    return ExGods.util.Stuff.printStuff({
                        type: "currency",
                        params: {
                            id: 'gold',
                            quantity: data.price
                        }
                    });
                },
                printImage: function(values) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'repair_item',
                        params: {
                            itemModel: values.item
                        }
                    });
                }
            }
        ];
    },
    /**
     * @private
     * Override
     */
    onTargetSelect: function(target) {
        this.callParent([
            target.get('item')
        ]);
    }
});

/**
 * Контроллер "быстрых" слотов
 */
Ext.define('ExGods.controller.QuickSlot', {
    extend: ExGods.controller.Base,
    models: [
        'Slot@ExGodsCore.model'
    ],
    views: [
        'user.TargetWindow'
    ],
    refs: [
        {
            /**
         * @method getQuickSlots
         * Возвращает отображение быстрых слотов
         * @return {ExGods.view.QuickSlots}
         */
            ref: 'quickSlots',
            selector: '#quick-slots'
        }
    ],
    /**
     * @property {ExGods.model.User} user
     * @inheritdoc ExGods.app#user
     */
    init: function(app) {
        var me = this;
        me.user.slots().on('datachanged', me.setSlots, me);
        me.setSlots();
        me.control({
            '#quick-slots': {
                itemclick: {
                    fn: me.onQuickItemClick,
                    buffer: 200
                }
            }
        });
    },
    onLaunch: function(app) {
        var me = this,
            user = me.user;
        // создаём функцию с буферным срабатыванием
        var bufferedRefresh = Ext.Function.createBuffered(me.refreshSlots, 1, me);
        me.quickSlotsStore.each(function(slot) {
            slot.items().on('datachanged', bufferedRefresh, me);
        });
    },
    refreshSlots: function() {
        this.getQuickSlots().refresh();
    },
    setSlots: function() {
        var me = this,
            records = me.user.slots().queryBy(function(slot) {
                return slot.get('type') == 14;
            });
        if (!me.quickSlotsStore) {
            me.quickSlotsStore = Ext.create('Ext.data.Store', {
                id: 'quick-slots',
                model: 'ExGodsCore.model.Slot'
            });
        }
        me.quickSlotsStore.loadData(records.getRange());
        if (me.getQuickSlots()) {
            me.getQuickSlots().refresh();
        }
    },
    /**
     * Обрабатываю клик по пустому слоту
     */
    onQuickItemClick: function(view, slot, itemEl) {
        var me = this;
        if (view.isDisabled())  {
            return;
        }
        
        //если есть предмет - то сработает обработчик клика по стаффу
        if (slot.items().getCount())  {
            return;
        }
        
        me.app.getItemController().showSlotWindow(slot, itemEl);
    }
});

/**
 * Таблица доблести персонажа
 */
Ext.define('ExGods.view.user.TrophyTable', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.usertrophytable',
    id: 'user-trophy-table',
    autoShow: true,
    bodyPadding: 0,
    /**
     * @cfg {Ext.data.Store} store (required)
     * Таблица
     */
    /**
     * @cfg {ExGods.model.User} [user]
     * Пользователь
     */
    y: 142,
    initComponent: function() {
        var me = this,
            grid;
        grid = Ext.widget({
            xtype: 'dataview',
            itemSelector: 'tbody tr',
            store: me.store,
            tpl: [
                '<div class="paper-title" style="margin:2px 1px 0">',
                '<h4>' + ExGods.getMsgByKey('stuff_tooltip_trophy') + '</h4>',
                '</div>',
                '<table>',
                '<thead>',
                '<tr>',
                '<th>' + ExGods.getMsgByKey('stuff_tooltip_league') + '</th>',
                '<th class="trophy">' + ExGods.getMsgByKey('stuff_tooltip_trophy') + '</th>',
                '</tr>',
                '</thead>',
                '<tbody>',
                '<tpl for=".">',
                '<tr {[this.getCls(xindex)]}>',
                '<td>{description.label}</td>',
                '<td class="trophy">{trophy:number("0,0")}</td>',
                '</tr>',
                '</tpl>',
                '</tbody>',
                '</table>',
                {
                    getCls: function(i) {
                        return i % 2 ? 'class="even"' : '';
                    }
                }
            ],
            width: 200
        });
        me.items = [
            grid
        ];
        me.callParent();
        if (me.user) {
            grid.on('viewready', me.onViewReady, me);
        }
    },
    onViewReady: function(grid) {
        var me = this,
            selModel = grid.getSelectionModel();
        selModel.select(me.user.get('hoard').trophy_level - 1);
        selModel.setLocked(true);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Полоска уровня маны
 */
Ext.define('ExGods.view.user.ExperienceBar', {
    extend: Ext.ProgressBar,
    alias: 'widget.experiencebar',
    itemId: 'experience-bar',
    border: 0,
    cls: 'experience-bar',
    height: 14,
    text: '???',
    /**
     * @cfg {ExGods.model.User} user (required)
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    width: 151,
    onRender: function() {
        var me = this,
            user = me.user;
        me.callParent(arguments);
        if (user) {
            me.tooltip = Ext.widget('tooltip', {
                target: me.el,
                maxWidth: parseInt(ExGods.ref('constants|tooltip_max_width').value),
                cls: 'paperdeco-tooltip',
                plugins: [
                    'paperdeco'
                ],
                tpl: new Ext.Template('<div class="paper-title ellipsis">' + ExGods.getMsgByKey('stuff_tooltip_experience') + '</div>' + '<div class="tooltip-paper-body">' + ExGods.ref('message_client|expa_tooltip') + '</div>'),
                listeners: {
                    beforeshow: function(tooltip) {
                        var expa = me.user.get('hoard').expa,
                            relative = me.getRelativeExpa(expa);
                        tooltip.update({
                            expa: expa,
                            to_level: relative.total - relative.current
                        });
                    }
                }
            });
            me.setData(user.get('hoard').expa);
            me.mon(user, {
                expachanged: me.setData,
                levelchanged: me.setData,
                scope: me
            });
            me.mon(user.get('feature'), 'datachanged', me.animateProgress, me);
            me.el.on('click', function() {
                /**
                 * @event click
                 * Срабатывает при клике по компоненте
                 * @param {ExGods.view.user.ExperienceBar} this
                 */
                this.fireEvent('click', this);
            }, me);
        }
    },
    onShow: function() {
        this.setExpBuffLength();
        this.callParent(arguments);
    },
    /**
     * Устанавливает данные опыта
     * 
     * @param {Number} expa Опыт
     */
    setData: function(expa) {
        var me = this,
            relative = me.getRelativeExpa(expa),
            percent = relative.current >= 0 ? relative.current / relative.total : 0;
        me.updateProgress(percent, Math.floor(percent * 100) + '%');
        me.setExpBuffLength();
        me.tooltip.update(relative);
    },
    /**
     * Рассчитывает относительные значения опыта для показа в шкале и подсказке
     * 
     * @param {Number} expa Текущий опыт пользователя
     * @return {Object} Относительные показатели опыта
     * 
     *  {
     *      current: <текущее_значение>,
     *      total: <необходимое_значение>
     *  }
     */
    getRelativeExpa: function(expa) {
        var me = this,
            levels = ExGods.references.get('user_level'),
            level = me.user.getLevel(),
            min = level ? levels.getByKey(level).expa : 0,
            max = levels.getByKey(level + 1).expa;
        return {
            current: expa - min,
            total: max - min
        };
    },
    /**
     * Меняет одного пользователя на другого
     * 
     * @param {ExGods.model.User} user Новый пользователь
     */
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            me.mun(me.user, {
                expachanged: me.setData,
                levelchanged: me.setData,
                scope: me
            });
            me.user = user;
            me.setData(user.get('hoard').expa);
            me.mon(user, {
                expachanged: me.setData,
                levelchanged: me.setData,
                scope: me
            });
        }
    },
    setExpBuffLength: function() {
        var me = this;
        if (me.processEl) {
            setTimeout(function() {
                me.processEl.style.width = Math.max((me.el.down('.x-progress-bar').getWidth() - 4), 0) + 'px';
            }, 0);
        }
    },
    animateProgress: function(store) {
        var me = this,
            user = me.user,
            feats = store.getExpFeatures();
        if (feats.length) {
            var feat = feats[0],
                el = me.el.down('.x-progress-bar'),
                left = 0,
                calcTime = function() {
                    return Math.floor(Math.max((ExGods.util.Date.normalizeServerDateTime(new Date(feat.get('ended').split('-').join('/'))).getTime() - new Date().getTime()) / 1000, 0));
                },
                timeStr = Ext.util.Format.countdown(calcTime(), {
                    format: "short"
                });
            if (!me.processEl) {
                me.processEl = document.createElement('div');
                me.processEl.className = 'x-progress-bar-process';
                me.setExpBuffLength();
                me.expFeatInterval = setInterval(function() {
                    left = left >= 19 ? 0 : left + 1;
                    me.processEl.style.backgroundPosition = left + 'px 0';
                }, 30);
                el.dom.insertBefore(me.processEl, el.dom.firstChild);
            }
            if (!me.timerEl) {
                me.timerEl = document.createElement('span');
                me.timerEl.className = 'x-progress-exgods-timer';
                me.el.dom.appendChild(me.timerEl);
            }
            me.timerEl.innerText = timeStr;
            var _onTick = function() {
                    var time = calcTime();
                    if (time > 0) {
                        me.timerEl.innerHTML = Ext.util.Format.countdown(time, {
                            format: "short"
                        });
                    } else {
                        ExGods.util.Ticker.removeListener(me.timer);
                        store.remove(feat);
                    }
                };
            setTimeout(function() {
                me.timer = ExGods.util.Ticker.addListener(_onTick, me);
                _onTick();
            }, 0);
        } else {
            if (me.expFeatInterval)  {
                clearInterval(me.expFeatInterval);
            }
            
            if (me.processEl && me.processEl.parentNode)  {
                me.processEl.parentNode.removeChild(me.processEl);
            }
            
            if (me.timerEl && me.timerEl.parentNode)  {
                me.timerEl.parentNode.removeChild(me.timerEl);
            }
            
        }
    }
});

/**
 * Полоска уровня жизней
 */
Ext.define('ExGods.view.user.HealthBar', {
    extend: Ext.ProgressBar,
    alias: 'widget.healthbar',
    border: 0,
    cls: 'health-bar',
    height: 14,
    width: 68,
    /**
     * @cfg {ExGods.model.User} user
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.tooltip = Ext.widget('tooltip', {
            target: me.el,
            tpl: new Ext.Template(ExGods.getMsgByKey('view_battle_userlist_hptt') + ' {current}/{total}'),
            listeners: {
                beforeshow: function(tooltip) {
                    var hp;
                    if (me.user) {
                        hp = me.user.get('timed').hp;
                        tooltip.update({
                            current: Math.floor(hp[0]),
                            total: hp[1]
                        });
                    }
                }
            }
        });
        if (me.user) {
            me.setData(me.user.get('timed').hp);
            me.mon(me.user, {
                hpchanged: me.setData,
                scope: me
            });
        }
    },
    /**
     * Устанавливает данные здоровья
     * @param {Number[]} hp Данные об уровне жизней
     */
    setData: function(hp) {
        var me = this;
        me.updateProgress(hp[0] / hp[1], ExGods.printNumber(Math.floor(hp[0]), 1000, '0', '0.0') + ' / ' + ExGods.printNumber(hp[1], 1000, '0', '0.0'));
        me.tooltip.update({
            current: Math.floor(hp[0]),
            total: hp[1]
        });
    },
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            if (me.user) {
                me.mun(me.user, {
                    hpchanged: me.setData,
                    scope: me
                });
            }
            if (me.rendered) {
                me.setData(user.get('timed').hp);
            }
            me.mon(user, {
                hpchanged: me.setData,
                scope: me
            });
            me.user = user;
        }
    }
});

/**
 * Полоска уровня маны
 */
Ext.define('ExGods.view.user.ManaBar', {
    alias: 'widget.manabar',
    extend: Ext.ProgressBar,
    border: 0,
    cls: 'mana-bar',
    height: 14,
    /**
     * @cfg {ExGods.model.User} user
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    /**
      * @cfg {Boolean} empty Настройка "показывать только (???) вместо значения"
      */
    /**
     * @cfg {String} 
     */
    emptyText: '???',
    width: 152,
    initComponent: function() {
        var me = this;
        if (me.empty) {
            me.text = me.emptyText;
        }
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        if (!me.empty) {
            me.tooltip = Ext.widget('tooltip', {
                target: me.el,
                tpl: new Ext.Template(ExGods.getMsgByKey('view_battle_userlist_mptt') + ' {current}/{total}'),
                listeners: {
                    beforeshow: function(tooltip) {
                        var mp;
                        if (me.user) {
                            mp = me.user.get('timed').mp;
                            tooltip.update({
                                current: Math.floor(mp[0]),
                                total: mp[1]
                            });
                        }
                    }
                }
            });
            if (me.user) {
                me.setData(me.user.get('timed').mp);
                me.mon(me.user, {
                    mpchanged: me.setData,
                    scope: me
                });
            }
        }
    },
    /**
     * Устанавливает данные здоровья
     * @param {Number[]} mp Данные об уровне маны
     */
    setData: function(mp) {
        var me = this;
        if (me.empty) {
            return;
        }
        me.updateProgress(mp[0] / mp[1], ExGods.printNumber(Math.floor(mp[0]), 10000, '0', '0.0') + ' / ' + ExGods.printNumber(mp[1], 10000, '0', '0.0'));
        me.tooltip.update({
            current: Math.floor(mp[0]),
            total: mp[1]
        });
    },
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            if (me.user) {
                me.mun(me.user, {
                    mpchanged: me.setData,
                    scope: me
                });
            }
            if (me.rendered) {
                me.setData(user.get('timed').mp);
            }
            me.mon(user, {
                mpchanged: me.setData,
                scope: me
            });
            me.user = user;
        }
    }
});

/**
 * Полоска уровня щита
 */
Ext.define('ExGods.view.user.ShieldBar', {
    alias: 'widget.shieldbar',
    extend: Ext.ProgressBar,
    border: 0,
    cls: 'shield-bar',
    height: 14,
    /**
     * @cfg {ExGods.model.User} user
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    width: 68,
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.tooltip = Ext.widget('tooltip', {
            target: me.el,
            tpl: new Ext.Template(ExGods.getMsgByKey('view_battle_userlist_sptt') + ' {current}/{total}'),
            listeners: {
                beforeshow: function(tooltip) {
                    var shield;
                    if (me.user) {
                        shield = me.user.get('timed').shield;
                        tooltip.update({
                            current: Math.floor(shield[0]),
                            total: shield[1]
                        });
                    }
                }
            }
        });
        if (me.user) {
            me.setData(me.user.get('timed').shield);
            me.mon(me.user, {
                shieldchanged: me.setData,
                scope: me
            });
        }
    },
    /**
     * Устанавливает данные здоровья
     * @param {Number[]} shield Данные об уровне щита
     */
    setData: function(shield) {
        var me = this;
        me.updateProgress(shield[0] / shield[1], ExGods.printNumber(Math.floor(shield[0]), 1000, '0', '0.0') + ' / ' + ExGods.printNumber(shield[1], 1000, '0', '0.0'));
        me.tooltip.update({
            current: Math.floor(shield[0]),
            total: shield[1]
        });
    },
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            if (me.user) {
                me.mun(me.user, {
                    shieldchanged: me.setData,
                    scope: me
                });
            }
            if (me.rendered) {
                me.setData(user.get('timed').shield);
            }
            me.mon(user, {
                shieldchanged: me.setData,
                scope: me
            });
            me.user = user;
        }
    }
});

/**
 * Полоска уровня маны
 */
Ext.define('ExGods.view.user.TrophyBar', {
    extend: Ext.ProgressBar,
    alias: 'widget.trophybar',
    itemId: 'trophy-bar',
    border: 0,
    cls: 'trophy-bar',
    height: 14,
    text: '???',
    /**
     * @cfg {ExGods.model.User} user (required)
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    width: 151,
    onRender: function() {
        var me = this,
            user = me.user;
        me.callParent(arguments);
        if (user) {
            me.tooltip = Ext.widget('tooltip', {
                target: me.el,
                cls: 'paperdeco-tooltip',
                plugins: [
                    'paperdeco'
                ],
                maxWidth: parseInt(ExGods.ref('constants|tooltip_max_width').value),
                tpl: new Ext.Template('<div class="paper-title ellipsis">' + ExGods.getMsgByKey('stuff_tooltip_trophy') + '</div>' + '<div class="tooltip-paper-body">' + ExGods.ref('message_client|trophy_tooltip') + '</div>'),
                listeners: {
                    beforeshow: function(tooltip) {
                        var trophy = me.user.get('hoard').trophy,
                            relative = me.getRelativeTrophy(trophy);
                        tooltip.update({
                            trophy: trophy,
                            to_level: relative.total - relative.current
                        });
                    }
                }
            });
            me.setData(user.get('hoard').trophy);
            me.mon(user, {
                trophychanged: me.setData,
                //trophy_levelchanged: me.setData,
                scope: me
            });
            me.el.on('click', function() {
                /**
                 * @event click
                 * Срабатывает при клике по компоненте
                 * @param {ExGods.view.user.TrophyBar} this
                 */
                this.fireEvent('click', this);
            }, me);
        }
    },
    /**
     * Устанавливает данные трофеев
     * 
     * @param {Number} trophy Трофеи
     */
    setData: function(trophy) {
        var me = this,
            relative = me.getRelativeTrophy(trophy),
            percent = relative.current >= 0 ? relative.current / relative.total : 0;
        me.updateProgress(percent, Math.floor(percent * 100) + '%');
        me.tooltip.update(relative);
    },
    /**
     * Рассчитывает относительные значения трофеев для показа в шкале и подсказке
     * 
     * @param {Number} trophy Текущее количество трофеев пользователя
     * @return {Object} Относительные показатели трофеев
     * 
     *  {
     *      current: <текущее_значение>,
     *      total: <необходимое_значение>
     *  }
     */
    getRelativeTrophy: function(trophy) {
        var me = this,
            levels = ExGods.references.get('user_trophy'),
            level = me.user.get('hoard').trophy_level || 1,
            min = level ? levels.get(level).trophy : 0,
            max = levels.get(level + 1) ? levels.get(level + 1).trophy : levels.get(level).trophy;
        if (max - min == 0)  {
            min = levels.get(level - 1).trophy;
        }
        
        return {
            current: Math.max(Math.min(trophy, max) - min, 0),
            total: max - min
        };
    },
    /**
     * Меняет одного пользователя на другого
     * 
     * @param {ExGods.model.User} user Новый пользователь
     */
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            me.mun(me.user, {
                trophychanged: me.setData,
                //trophy_levelchanged: me.setData,
                scope: me
            });
            me.user = user;
            me.setData(user.get('hoard').trophy);
            me.mon(user, {
                trophychanged: me.setData,
                //trophy_levelchanged: me.setData,
                scope: me
            });
        }
    }
});

/**
 * Отображает техническую информацию о персонаже
 */
Ext.define('ExGods.view.user.TechInfo', {
    extend: Ext.container.Container,
    alias: 'widget.techinfo',
    cls: 'tech-info-container',
    id: 'tech-info',
    /**
     * @cfg {Boolean} enemy
     * Флаг для отображения информации о сопернике
     */
    enemy: false,
    height: 95,
    layout: 'absolute',
    /**
     * @cfg {ExGods.model.User} user
     * Пользователь, характеристики которого отображает компонента
     */
    width: 285,
    initComponent: function() {
        var me = this,
            shift = 0,
            isInBattle = (me.enemy || me.user.get('battle')) ? true : false;
        if (me.enemy) {
            shift = 54;
        }
        me.thumb = Ext.widget('button', {
            cls: me.enemy ? 'enemy-btn flip-h' : '',
            height: 50,
            icon: Ext.BLANK_IMAGE_URL,
            itemId: 'avatar-thumb',
            listeners: {
                click: {
                    fn: me.avatarThumbClick,
                    scope: me
                }
            },
            width: 50,
            ui: 'image',
            x: 5 + shift,
            y: 5
        });
        me.displayTitle = Ext.widget('component', {
            tpl: [
                '{[ ExGods.printUser(values, {fields: ["name", "rank"], maxNameWidth: 150 }) ]}'
            ],
            x: 66 + shift,
            y: 4
        });
        me.healthBar = Ext.widget('healthbar', {
            user: me.user,
            hidden: !isInBattle,
            x: 75 + shift,
            y: 26
        });
        me.manaBar = Ext.widget('manabar', {
            user: me.user,
            hidden: !isInBattle,
            x: 75 + shift,
            y: 41,
            empty: me.enemy
        });
        me.shieldBar = Ext.widget('shieldbar', {
            user: me.user,
            hidden: !isInBattle,
            x: 159 + shift,
            y: 26
        });
        me.experienceBar = Ext.widget('experiencebar', {
            user: me.enemy ? null : me.user,
            hidden: isInBattle,
            x: 76 + shift,
            y: 41
        });
        me.trophyBar = Ext.widget('trophybar', {
            user: me.enemy ? null : me.user,
            hidden: isInBattle,
            x: 76 + shift,
            y: 26
        });
        me.level = Ext.widget('component', {
            cls: 'level',
            height: 13,
            width: 20,
            x: 135 + shift + (me.enemy ? 1 : 0),
            y: 67
        });
        me.items = [
            me.thumb,
            me.displayTitle,
            me.healthBar,
            me.manaBar,
            me.shieldBar,
            me.experienceBar,
            me.trophyBar,
            me.level
        ];
        me.callParent();
        if (me.user) {
            me.setUser(me.user);
        }
        me.on({
            battlestart: function() {
                me.el.addCls('in-battle');
                me.healthBar.show();
                me.manaBar.show();
                me.shieldBar.show();
                me.experienceBar.hide();
                me.trophyBar.hide();
            },
            battlefinish: {
                fn: me.onBattleFinish,
                scope: me
            }
        });
    },
    onBattleFinish: function() {
        var me = this,
            hoard = me.user.get('hoard');
        me.el.removeCls('in-battle');
        me.healthBar.hide();
        me.manaBar.hide();
        me.shieldBar.hide();
        me.experienceBar.show();
        me.trophyBar.show();
        me.user.set('hoard', hoard);
    },
    setHealthBar: function(hp) {
        this.setProgressBar(this.healthBar, hp);
    },
    setManaBar: function(mp) {
        this.setProgressBar(this.manaBar, mp);
    },
    /**
     * Пробная функция обновления прогрессбара
     */
    setProgressBar: function(bar, progress) {
        var value = parseInt(progress[0]),
            max = parseInt(progress[1]);
        bar.updateProgress(value / max, value + ' / ' + max);
    },
    avatarThumbClick: function() {
        var me = this;
        me.fireEvent('thumbclick', me);
    },
    /**
     * Устанавливает нового пользователя для отображения данных
     * @param {ExGods.model.User} user
     */
    setUser: function(user) {
        var me = this,
            userEvents = {
                change: me.updateUser,
                avatar_ruin_changed: me.updateThumbIcon,
                scope: me
            };
        if (me.user) {
            me.user.un(userEvents);
        }
        me.user = user;
        me.updateUser();
        user.on(userEvents);
        if (user.isBattle()) {
            me.healthBar.setUser(user);
            me.manaBar.setUser(user);
            me.shieldBar.setUser(user);
        } else if (!me.enemy) {
            me.experienceBar.setUser(user);
            me.trophyBar.setUser(user);
        }
    },
    /**
     * Обновляет данные при смене пользователя
     */
    updateUser: function() {
        var me = this,
            user = me.user,
            level = parseInt(user.getLevel()),
            valourRef = user.getValourRef();
        if (me.enemy && user.get('is_bot')) {
            me.addCls('is_bot');
        } else {
            me.removeCls('is_bot');
        }
        // обновляем аватарку
        me.updateThumbIcon();
        // обновляем ник
        me.displayTitle.update(user.data);
        var timed = user.get('timed');
        // обновляем уровень выносливости
        //me.setManaBar(timed.mp);
        var hoard = user.get('hoard');
        // обновляем шкалу доблести
        var valour = parseInt(hoard.valour),
            valourLevels = ExGods.ref('user_valour'),
            maxValour = null;
        // обновляем уровень
        var arr = level.toString().split('');
        var levelStr = '';
        Ext.Array.forEach(arr, function(item) {
            levelStr += '<img alt="' + item + '" class="number number-' + item + '" height="13" src="' + Ext.BLANK_IMAGE_URL + '" width="10" />';
        });
        me.level.update(levelStr);
    },
    /**
     * @private Выставляет иконку аватарки пользователя
     */
    updateThumbIcon: function() {
        var me = this,
            iconEl = me.thumb.btnIconEl,
            backgrounds = [];
        if (!me.thumb.rendered) {
            me.thumb.on('afterrender', me.updateThumbIcon, me, {
                single: true
            });
            return;
        }
        if (!me.user.data.real_user && me.user.data.is_bot) {
            me.thumb.addCls('bot_thumb');
        } else {
            me.thumb.removeCls('bot_thumb');
        }
        if (me.user.hasFeature("avatar_ruin")) {
            backgrounds.push('url(' + ExGods.ref('images|avatar_ruin').image.avatar_ruin_small + ') no-repeat 50% 50%');
        }
        backgrounds.push('url(' + me.user.getThumb() + ') no-repeat 50% 50%');
        if (iconEl) {
            iconEl.setStyle('background', backgrounds.join(','));
        }
    },
    getResources: function() {
        var me = this,
            images = [];
        var imgs = ExGods.ref('images|avatar_ruin').image;
        for (var it in imgs) {
            images.push(imgs[it]);
        }
        if (me.user) {
            images.push(me.user.getThumb());
        }
        return {
            images: images
        };
    }
});

/**
 * Предмет
 */
Ext.define('ExGods.view.item.Item', {
    extend: Ext.button.Button,
    alias: 'widget.item',
    /**
     * @cfg {Object} item (required)
     * Предмет
     */
    /**
     * @cfg {ExGods.model.User} user
     * Пользователь
     */
    cls: 'item',
    height: 64,
    /**
     * @property {Boolean} isLoaded статус загрузки предмета
     */
    isLoaded: false,
    renderTpl: '<em id="{id}-btnWrap" class="{splitCls}">' + '<div id="{id}-btnEl" type="{type}" hidefocus="true"' + // the autocomplete="off" is required to prevent Firefox from remembering
    // the button's disabled state between page reloads.
    '<tpl if="tabIndex"> tabIndex="{tabIndex}"</tpl> role="button" autocomplete="off">' + '<span id="{id}-btnInnerEl" class="{baseCls}-inner" style="{innerSpanStyle}">' + '{text}' + '</span>' + '<span id="{id}-btnIconEl" class="{baseCls}-icon {iconCls}">&#160;</span>' + '</div>' + '</em>' + '<div class="stack-counter" id="{id}-btnStackCounter"></div>' + '<div class="upgrade_stars_container" id="{id}-upgradeStarsContainer"></div>',
    padding: 0,
    text: ' ',
    width: 64,
    initComponent: function() {
        var me = this;
        if (me.item)  {
            me.itemPrototype = ExGods.app.getItemPrototypesStore().data.getByKey(me.item.get('proto_id'));
        }
        
        me.callParent();
    },
    getSlot: function() {
        var slot_id = this.slot.id,
            user = this.user || ExGods.app.user;
        return user.slots().data.getByKey(slot_id);
    },
    /**
     * Обновляет/дорисовывает предмет после получения прототипа
     */
    updateItem: function() {
        var me = this;
        me.isLoaded = true;
        if (me.item) {
            if (me.el) {
                me.el.setStyle('background-image', me.getItemBckgImage());
            } else {
                me.style = {
                    'background-image': me.getItemBckgImage()
                };
            }
        }
    },
    onRender: function(ct, position) {
        var me = this;
        me.callParent(arguments);
        me.btnStackCounter = me.el.down('#' + me.id + '-btnStackCounter');
        me.upgradeStarsContainer = me.el.down('#' + me.id + '-upgradeStarsContainer');
        if (me.item) {
            me.updateItem();
            var count = me.item.get('count');
        }
        if (count > 1) {
            me.btnStackCounter.update(count);
            me.btnStackCounter.show();
        } else {
            me.btnStackCounter.hide();
        }
        if (me.item && me.item.get('param').upgrades > 0) {
            var stars = '<div class="upgrade_stars_container">';
            for (i = 0; i < me.item.get('param').upgrades; i++) {
                stars += '<div class="upgrade_star"></div>';
            }
            stars += '</div>';
            me.upgradeStarsContainer.update(stars);
            me.upgradeStarsContainer.show();
        } else {
            me.upgradeStarsContainer.hide();
        }
        //если предмет в слоте куклы - то ставлю маркеры квестхелпера
        var slotType = me.slot.get('type'),
            obj = {
                'data-qh_otype': 'active_slot',
                'data-qh_oid': slotType
            };
        if ([
            1,
            2,
            5,
            8
        ].indexOf(slotType) != -1) {
            obj['data-qh_opts'] = "{&quot;cls&quot;:&quot;flip-h&quot;}";
        }
        if ([
            1,
            2,
            4,
            5,
            8,
            11,
            12,
            13
        ].indexOf(slotType) != -1) {
            me.el.addCls('qh-object active-slot');
            me.el.set(obj);
        }
        // тултипы
        if (me.item) {
            ExGods.Tooltips.makeElementAsTip(me.el, 'item', me.item.get('item_id') + '|user_info');
        }
    },
    getItemBckgImage: function() {
        var me = this,
            slotType = me.getSlot().get('type'),
            active = references.get('slot_type').getByKey(slotType).active,
            result = '';
        if (me.item.hasCriticalDurability()) {
            result = 'url(' + ExGods.references.get('images').get('item_critical_status').image['img60'] + '), ';
        }
        if (me.slot.data.protect == 1) {
            result += 'url(' + IMAGE_URL + '/slots/new/frm.png),';
        }
        result += 'url(' + me.itemPrototype.getImage(active ? 'on' : 'off') + ')';
        return result;
    },
    onDestroy: function() {
        var me = this;
        // me.clearTip(); // удаляю тултип с кнопки
        me.callParent(arguments);
    }
});

/**
 * Кукла пользователя
 */
Ext.define('ExGods.view.user.DollPanel', {
    extend: Ext.panel.Panel,
    alias: 'widget.dollpanel',
    mixins: [
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.InventoryDragHighlight
    ],
    cls: 'doll',
    layout: 'absolute',
    x: 5,
    y: 22,
    style: {
        'float': 'left'
    },
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь, чью куклу показываем
     */
    width: 358,
    initComponent: function() {
        var me = this,
            user = me.user;
        me.plugins = [
            'inventory_frame'
        ];
        me.callParent();
        me.data_items = [];
        me.slotsWdg = undefined;
        me.initDoll();
        me.mon(user.slots(), 'load', me.initDoll, me);
    },
    /**
     * @private Расположение слотов по типу
     */
    getSlotsConfig: function() {
        return {
            11: {
                //кольца
                height: 64,
                width: 64,
                x: 274,
                y: 192
            },
            12: {
                //сережки
                height: 64,
                width: 64,
                x: 274,
                y: 0
            },
            2: {
                // Шлем
                height: 64,
                width: 64,
                x: 0,
                y: 0
            },
            1: {
                // Оружие
                height: 64,
                width: 64,
                x: 0,
                y: 128
            },
            5: {
                // Доспех
                height: 64,
                width: 64,
                x: 0,
                y: 64
            },
            13: {
                // Амулет
                height: 64,
                width: 64,
                x: 274,
                y: 64
            },
            24: {
                // Тотем
                height: 64,
                width: 64,
                x: 274,
                y: 256
            },
            4: {
                // Щит
                height: 64,
                width: 64,
                x: 274,
                y: 128
            },
            8: {
                // Сапоги
                height: 64,
                width: 64,
                x: 0,
                y: 192
            }
        };
    },
    /**
     * Обновляет куклу персонажа
     */
    initDoll: function() {
        var me = this,
            user = me.user,
            userSlots = user.slots(),
            slots, slotConfigs;
        slotConfigs = me.getSlotsConfig();
        var slots = [];
        userSlots.each(function(slot) {
            var config = slotConfigs[slot.get('type')];
            if (config) {
                slots.push(me.initSlotComponent(slot, config));
            }
        });
        me.suspendLayouts();
        me.removeAll(true);
        me.add(me.initAvatar());
        if (slots) {
            //me.add(slots);
            me.slotsWdg = slots;
        }
        // выносим show виджетов в рендер, чтобы ресурсы сумели подгрузиться
        me.resumeLayouts(true);
    },
    initSlotComponent: function(slot, config) {
        var me = this,
            user = me.user;
        Ext.apply(config, {
            slot: slot,
            type: slot.get('type'),
            user: user
        });
        var wdg = Ext.widget('dollslot', config);
        if (wdg.stuff) {
            me.data_items.push(wdg.stuff);
        }
        return wdg;
    },
    onRender: function() {
        var me = this,
            itemController = ExGods.app.getController('Item');
        user = me.user;
        me.callParent(arguments);
        if (me.slotsWdg) {
            me.add(me.slotsWdg);
        }
        me.mon(user.slots(), 'new_slot', me.onNewSlot, me);
        me.mon(user, 'avatar_ruin_changed', me.updateAvatar, me);
        me.mon(user, 'shapechanged', me.updateAvatar, me);
        if (user == ExGods.app.user && user.getMaskSlot()) {
            me.mon(user.getMaskSlot().items(), 'datachanged', me.updateAvatar, me);
        }
        if (me.user == ExGods.app.user) {
            me.initDrop({
                onDrop: function(target, dd, e, data) {
                    if (Ext.getClassName(data.item) != 'ExGodsCore.model.Item')  {
                        return false;
                    }
                    
                    var type = data.item.getType().slot_on,
                        isValid = false;
                    me.user.slots().each(function(slot) {
                        if (slot.get('type') == type) {
                            isValid = true;
                        }
                    });
                    if ([
                        1,
                        2,
                        4,
                        5,
                        8,
                        11,
                        12,
                        13
                    ].indexOf(data.slot.get('type')) != -1) {
                        isValid = false;
                    }
                    if (isValid) {
                        itemController.putOn(data.item, data.cancel);
                    }
                    return isValid;
                }
            });
            me.initDragHighlight();
        }
    },
    /**
     * @private Обработка события добавления нового слота
     */
    onNewSlot: function(slot) {
        var me = this,
            config = me.getSlotsConfig()[slot.data.type];
        if (config) {
            me.add(me.initSlotComponent(slot, config));
        }
    },
    initAvatar: function() {
        var me = this;
        me.avatar = Ext.widget('component', {
            itemId: 'avatar',
            style: this.getAvatarStyle(),
            height: 316,
            width: 210,
            x: 64,
            y: 1
        });
        me.maskGradeLine = Ext.widget('maskgradeline', {
            x: 124,
            y: 296,
            maskProto: me.user.getMaskProto()
        });
        return [
            me.avatar,
            me.maskGradeLine
        ];
    },
    /**
     * Меняет аватар пользователя
     */
    updateAvatar: function() {
        var me = this;
        // обновляю аватар
        if (me.avatar.el) {
            me.avatar.el.setStyle(me.getAvatarStyle());
            me.avatar.style = me.getAvatarStyle();
        } else {
            me.avatar.style = me.getAvatarStyle();
        }
        // обновляю прогресс маски
        me.maskGradeLine.update(me.user.getMaskProto());
    },
    /**
     * @private
     * Вернет стили для элемента аватарки
     */
    getAvatarStyle: function() {
        var me = this,
            backgrounds = [];
        if (me.user.hasFeature("avatar_ruin")) {
            backgrounds.push('url(' + ExGods.references.get('images').get('avatar_ruin').image.avatar_ruin + ') no-repeat 50% 50%');
        }
        backgrounds.push('url(' + me.user.getInventoryAvatar() + ') no-repeat 50% 50%');
        return {
            background: backgrounds.join(',')
        };
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var obj = ExGods.ref('images|avatar_ruin').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        // Изображения слотов по умолчанию
        me.user.slots().each(function(slot) {
            obj = ExGods.ref('slot_type|' + slot.get('type')).images;
            for (var i in obj) {
                arr_images.push(obj[i]);
            }
        });
        return {
            stuff: me.data_items || [],
            images: [
                me.user.getInventoryAvatar(),
                IMAGE_URL + 'inventory/frm_top_left.jpg',
                IMAGE_URL + 'inventory/frm_top_center.jpg',
                IMAGE_URL + 'inventory/frm_top_right.jpg',
                IMAGE_URL + 'inventory/frm_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_center.jpg',
                IMAGE_URL + 'inventory/frm_bottom_left.jpg',
                IMAGE_URL + 'inventory/frm_left.jpg',
                IMAGE_URL + 'inventory/frm_top.png',
                // Изображения прокачки маски
                IMAGE_URL + 'battle/peril-trafaret.png',
                IMAGE_URL + 'battle/peril-ico.png',
                // Кнопка параметры игрока
                IMAGE_URL + 'inventory/btn_axes.png',
                IMAGE_URL + 'inventory/frm_avatar_bottom.jpg',
                IMAGE_URL + 'slot_locked.jpg',
                IMAGE_URL + 'inventory/frm_avatar_top.jpg'
            ].concat(arr_images)
        };
    }
});

/**
 * Отображение характеристик пользователя
 */
Ext.define('ExGods.view.user.Stats', {
    extend: Ext.container.Container,
    alias: 'widget.userstats',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'user-info-stats',
    width: 225,
    height: 325,
    plugins: [
        'paperdeco'
    ],
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    /**
     * @cfg {ExGods.store.UserContacts} userContacts (required)
     * Контакты пользователя ExGods.user
     */
    initComponent: function() {
        var me = this,
            user = me.user;
        me.items = [
            {
                xtype: 'component',
                data: me.prepareData(user.data),
                tpl: [
                    '<div style="margin: 7px 5px;">',
                    '<tpl if="ExGods.app.user.get(\'display_title\') == title">',
                    '<tpl if="guild">',
                    '<div class="stats-list">',
                    '<div style="text-align: center; max-width: 185px;" class="ellipsis"><strong>[{guild.tag}]&nbsp;{guild.title}</strong></div>',
                    '</div>',
                    '<div class="separator"></div>',
                    '</tpl>',
                    '<div class="stats-list">',
                    '<ul class="table-list">' + '<li><span class="label">' + references.get('user_hoard').getByKey('level').label + '</span><span class="value">{[ this.printIcon("level", "user_hoard") ]} </span><span class="value">{hoard.level}</span></li>' + '<li class="even"><span class="label">' + references.get('user_hoard').getByKey('expa').label + '</span><span class="value">{[ this.printIcon("expa", "user_hoard") ]} </span><span class="value">{[this.printExp(values.experience)]}</span></li>' + '<li><span class="label">' + references.get('user_hoard').getByKey('trophy_level').label + '</span><span class="value">{[ this.printIcon("trophy_level", "user_hoard") ]} </span><span class="value">{trophy_level_label}</span></li>' + '<li class="even"><span class="label">' + references.get('user_hoard').getByKey('trophy').label + '</span><span class="value">{[ this.printIcon("trophy", "user_hoard") ]} </span><span class="value">{trophy.current}{trophy.total}</span></li>' + '{elo_string}' + '<li class="even"><span class="label">' + references.get('user_stat').getByKey('weightlift').label + '</span><span class="value">{[ this.printIcon("weightlift", "user_stat") ]}</span><span class="value">{stats.summary.mass}/{stats.modif.capacity}</span></li>' + '</ul>' + '</div>',
                    '<tpl else>',
                    '<div class="stats-list">',
                    '<div style="text-align: center;"><strong>{title}</strong></div>',
                    '<tpl if="guild">',
                    '<div style="text-align: center; max-width: 185px;" class="ellipsis"><strong>[{guild.tag}]&nbsp;{guild.title}</strong></div>',
                    '</tpl>',
                    '</div>',
                    '<div class="separator"></div>',
                    '<div class="stats-list">',
                    '<ul class="table-list">' + '<li><span class="label">' + references.get('user_hoard').getByKey('level').label + '</span><span class="value">{[ this.printIcon("level", "user_hoard") ]} </span><span class="value">{hoard.level}</span></li>' + '<li class="even"><span class="label">' + references.get('user_hoard').getByKey('trophy_level').label + '</span><span class="value">{[ this.printIcon("trophy_level", "user_hoard") ]} </span><span class="value">{trophy_level_label}</span></li>' + '<li><span class="label">' + references.get('user_hoard').getByKey('trophy').label + '</span><span class="value">{[ this.printIcon("trophy", "user_hoard") ]} </span><span class="value">{trophy.current}{trophy.changes}</span></li>' + '{elo_string_even}' + '</ul>' + '</div>',
                    '</tpl>',
                    '<div class="separator"></div>',
                    '<div class="stats-list">',
                    '{user_stat}',
                    '</div>',
                    '<div class="separator"></div>',
                    '<tpl if="this.getMaskProto()">',
                    '<div class="paper-title ellipsis" style="max-width:207px; font-weight: bold;">{[ this.getMaskProto().title ]}</div>',
                    '</tpl>',
                    '<div class="user_stats_image">',
                    '{[ ExGods.util.User.printUserStats(values.stats.stats, {visibleValue: 2}) ]}',
                    '</div>',
                    '</div>',
                    {
                        printExp: function(exp) {
                            return ExGods.printNumber(exp.current, 100000) + '/' + ExGods.printNumber(exp.total, 100000);
                        },
                        getMaskProto: function() {
                            return me.user.getMaskProto();
                        },
                        printIcon: function(name, reference) {
                            var iconHtml = '';
                            var icon = reference == 'user_hoard' ? references.get(reference).getByKey(name).icon : reference == 'user_stat' ? references.get(reference).getByKey(name).param.icon : reference == 'user_summary' ? references.get(reference).getByKey(name).icon : name;
                            if (icon) {
                                iconHtml = '<img width="16" height="16" style="margin: 0 2px -3px 0;" src="' + IMAGE_URL + icon + '"/>';
                            }
                            return iconHtml;
                        }
                    }
                ]
            }
        ];
        me.callParent();
        me.mon(user, 'change', function() {
            var data = me.prepareData(user.data);
            me.items.first().update(data);
        }, me);
        if (user == ExGods.app.user) {
            me.addCls('myinfo');
        }
    },
    /**
     * Преобразовывает данные о пользователе в удобный вид для шаблона
     * 
     * @param {Object} data Данные модели {ExGods.model.User}
     * @return {Object}
     */
    prepareData: function(data) {
        var me = this,
            user = me.user,
            levels = ExGods.references.get('user_level'),
            level = data.hoard.level,
            min = level ? levels.getByKey(level).expa : 0,
            max = levels.getByKey(level + 1).expa,
            expa = data.hoard.expa,
            trophy_level_label, curr_trophy, next_trophy;
        preparedData = data;
        //рейтинг на арене
        preparedData.elo_string = '';
        preparedData.elo_string_even = '';
        var string_id = 0;
        Ext.Object.each(data.elo, function(key, value) {
            var elo_change = parseInt(value) - parseInt(ExGods.app.user.data.elo[key]);
            var elo_change_string = '';
            if (elo_change != 0) {
                elo_change_string = '<small>(<span class="' + (elo_change > 0 ? "up" : "down") + '">' + (elo_change > 0 ? "+" : "") + elo_change + '</span>)</small>';
            }
            preparedData.elo_string += '<li class="' + (string_id % 2 == 0 ? "" : "even") + '"><span class="label">' + ExGods.ref('user_elo|' + key).label + '</span><span class="value"></span><span class="value">' + value + elo_change_string + '</span></li>';
            preparedData.elo_string_even += '<li class="' + (string_id % 2 == 0 ? "even" : "") + '"><span class="label">' + ExGods.ref('user_elo|' + key).label + '</span><span class="value"></span><span class="value">' + value + elo_change_string + '</span></li>';
            string_id++;
        });
        //название уровня лиги
        if (data.hoard.trophy_level == 0)  {
            data.hoard.trophy_level = 1;
        }
        
        Ext.Object.each(ExGods.references.map.user_trophy.map, function(key, item) {
            if (item.level == data.hoard.trophy_level) {
                preparedData.trophy_level_label = item.description.label;
                curr_trophy = item.trophy;
            }
            if (item.level == data.hoard.trophy_level + 1) {
                next_trophy = item.trophy;
            }
        });
        //трофеи
        var changes = data.hoard.trophy - ExGods.app.user.data.hoard.trophy;
        preparedData.trophy = {
            current: data.hoard.trophy,
            total: '/' + next_trophy,
            changes: '<small>(<span class="' + (changes > 0 ? "up" : "down") + '">' + (changes > 0 ? "+" : "") + changes + '</span>)</small>'
        };
        //опыт
        preparedData.experience = {
            current: expa,
            total: max
        };
        var preparedChanges = {};
        Ext.each(config.references.user_stat, function(item) {
            if (item.visible == 1 && !item.param.fill) {
                var curStat = user.data.stats.stats[item.name],
                    wasStat = ExGods.app.user.data.stats.stats[item.name],
                    changes = parseInt(curStat) - parseInt(wasStat),
                    className = '';
                preparedChanges[item.name] = changes;
            }
        });
        preparedData.user_stat = ExGods.util.User.printUserStats(user.data.stats.stats, {
            visibleValue: 1,
            changes: preparedChanges,
            align: 'right'
        });
        return preparedData;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'icons/stats/ico_injury16.png',
                IMAGE_URL + 'icons/stats/ico_life16.png',
                IMAGE_URL + 'icons/stats/ico_shield16.png',
                IMAGE_URL + 'icons/stats/ico_mana16.png',
                IMAGE_URL + 'icons/stats/ico_fury16.png',
                IMAGE_URL + 'mask/ico_adroitness.png',
                IMAGE_URL + 'mask/star_red.png',
                IMAGE_URL + 'mask/star_green.png',
                IMAGE_URL + 'mask/star.png',
                IMAGE_URL + 'mask/stars_bg.png',
                IMAGE_URL + 'mask/ico_power.png',
                IMAGE_URL + 'mask/ico_armor.png',
                IMAGE_URL + 'mask/ico_accuracy.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Отображает техническую информацию о персонаже
 */
Ext.define('ExGods.view.user.Info', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.userinfo',
    tabUi: 'skintext',
    cls: 'owerflow_visible_panel',
    bodyPadding: '0 11 11',
    closable: false,
    plugins: [
        'skindeco'
    ],
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь, чью информацию надо отобразить
     */
    initComponent: function() {
        var me = this,
            icons = ExGods.references.get('images'),
            user = me.user,
            items;
        if (user != ExGods.app.user || user.isBattle()) {
            me.closable = true;
        }
        user.setRaidAchievements();
        items = [
            {
                icon: ExGods.ref('images|inventory_tabs').image['inventory'],
                layout: 'absolute',
                items: [
                    {
                        xtype: 'button',
                        text: ExGods.getMsgByKey('inventory_params_btn_text'),
                        x: 132,
                        y: 8,
                        width: 104,
                        height: 18,
                        cls: 'inventory-params',
                        style: {
                            'z-index': '999'
                        },
                        handler: function() {
                            if (Ext.ComponentQuery.query('#info-stats')[0].isVisible()) {
                                Ext.ComponentQuery.query('#info-stats')[0].hide();
                                this.removeCls('opened');
                            } else {
                                Ext.ComponentQuery.query('#info-stats')[0].show();
                                this.addClass('opened');
                            }
                        }
                    },
                    {
                        xtype: 'userstats',
                        user: user,
                        // id: 'user-info-stats',
                        itemId: 'info-stats',
                        hidden: true,
                        width: 225,
                        height: 325,
                        style: {
                            'z-index': '999'
                        },
                        x: 72,
                        y: 32
                    },
                    {
                        xtype: 'dollpanel',
                        user: user
                    },
                    {
                        xtype: 'panel',
                        headerText: ExGods.getMsgByKey('view_user_info_bagtitle'),
                        x: 395,
                        width: 340,
                        height: 337,
                        y: 22,
                        plugins: [
                            'inventory_frame'
                        ],
                        items: [
                            {
                                xtype: 'component',
                                style: {
                                    position: 'absolute',
                                    width: '337px',
                                    height: '335px',
                                    left: '-9px',
                                    top: '-5px'
                                },
                                tpl: '<div style="display: table; height: 100%;"><div style="padding: 0px 20px 0px 25px; position: relative; display: table-cell; vertical-align: middle; text-align: center; ">' + (user.data.title === ExGods.app.user.data.title ? ExGods.ref('message_client|my_user_info') : ExGods.ref('message_client|enemy_user_info')) + '</div>',
                                data: user.data,
                                plugins: [
                                    'paperdeco'
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                icon: ExGods.ref('images|inventory_tabs').image.raids,
                layout: 'absolute',
                items: [
                    {
                        xtype: 'guildraids',
                        store: me.raidsStore,
                        show_rewards: false
                    }
                ]
            }
        ];
        me.items = items;
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        var imgs = ExGods.ref('images|inventory_tabs').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        var obj = me.callParent();
        return {
            stuff: [].concat(obj.stuff),
            images: [].concat(arr_images).concat(obj.images)
        };
    }
});

Ext.define('ExGods.view.user.PowerChange', {
    extend: Ext.Component,
    alias: 'widget.powerchange',
    cls: 'user-power-change',
    id: 'user_power_change',
    autoShow: true,
    closable: false,
    width: 366,
    height: 104,
    y: 163,
    //(430 - 104)/2
    x: 247,
    //(860 - 366)/2
    renderTo: 'center',
    style: {
        opacity: 0
    },
    animData: {
        up: {
            images: [
                'add_power.png'
            ],
            frames: [
                [
                    0,
                    0,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    0,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    107,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    107,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    214,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    214,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    321,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    321,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    428,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    428,
                    366,
                    107,
                    0,
                    0,
                    0
                ]
            ]
        },
        down: {
            images: [
                'delete_power.png'
            ],
            frames: [
                [
                    0,
                    0,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    0,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    104,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    104,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    208,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    208,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    312,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    312,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    416,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    416,
                    366,
                    104,
                    0,
                    0,
                    0
                ]
            ]
        }
    },
    initComponent: function() {
        var me = this,
            text;
        if (me.positive) {
            text = ExGods.app.applyTpl(ExGods.getMsgByKey('powerchange_positive'), {
                change: me.change
            });
        } else {
            text = ExGods.app.applyTpl(ExGods.getMsgByKey('powerchange_negative'), {
                change: me.change
            });
        }
        me.html = [
            '<div class="user-power-change-text">' + text + '</div>'
        ];
    },
    onRender: function() {
        var me = this,
            animData = me.positive ? me.animData.up : me.animData.down,
            top = me.y + (me.positive ? -100 : 100);
        var spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                images: animData.images,
                frames: animData.frames,
                renderTo: me.getEl(),
                infinite: true
            });
        spriteSheet.start();
        me.el.animate({
            to: {
                opacity: 1
            },
            duration: Number(ExGods.ref('constants|powerchange_fade_id_speed').value),
            callback: function() {
                me.el.animate({
                    to: {
                        opacity: 0,
                        top: top + 'px'
                    },
                    delay: Number(ExGods.ref('constants|powerchange_delay').value),
                    duration: Number(ExGods.ref('constants|powerchange_fade_out_speed').value),
                    callback: function() {
                        me.el.remove();
                        me.destroy();
                    }
                });
            }
        });
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var it in me.animData) {
            arr_images = arr_images.concat(me.animData[it].images);
        }
        return {
            stuff: [],
            images: [].concat(arr_images)
        };
    }
});

/**
 * Таблица опыта персонажа
 */
Ext.define('ExGods.view.user.ExperienceTable', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.userexperiencetable',
    id: 'user-experience-table',
    autoShow: true,
    bodyPadding: 0,
    /**
     * @cfg {Ext.data.Store} store (required)
     * Таблица
     */
    /**
     * @cfg {ExGods.model.User} [user]
     * Пользователь
     */
    y: 142,
    initComponent: function() {
        var me = this,
            grid,
            feats = [];
        if (me.user) {
            var featureStore = me.user.get('feature'),
                feats = featureStore.getExpFeatures();
        }
        grid = Ext.widget({
            xtype: 'dataview',
            itemSelector: 'tbody tr',
            store: me.store,
            tpl: [
                '<div class="paper-title" style="margin:2px 1px 0">',
                '<h4>' + ExGods.getMsgByKey('stuff_tooltip_experience') + '</h4>',
                '</div>',
                '<table>',
                '<thead>',
                '<tr>',
                '<th>' + ExGods.getMsgByKey('view_arena_enemylist_level') + '</th>',
                '<th class="expa">' + ExGods.getMsgByKey('stuff_tooltip_experience') + '</th>',
                '</tr>',
                '</thead>',
                '<tbody>',
                '<tpl for=".">',
                '<tr {[this.getCls(xindex)]}>',
                '<td>{level}</td>',
                '<td class="expa">{expa:number("0,0")}</td>',
                '</tr>',
                '</tpl>',
                '</tbody>',
                '</table>',
                '<tpl if="this.checkBonuses(values)">',
                '<div class="paper-separator"></div>',
                '<div class="paper-title" style="margin:2px 1px 0">',
                '<h4>' + ExGods.getMsgByKey('view_user_exptable_bonuses') + '</h4>',
                '</div>',
                '<ul class="exp-bonuses"></ul>',
                '</tpl>',
                {
                    getCls: function(i) {
                        return i % 2 ? 'class="even"' : '';
                    },
                    checkBonuses: function() {
                        return feats.length > 0;
                    }
                }
            ],
            width: 225
        });
        me.items = [
            grid
        ];
        me.mon(featureStore, 'datachanged', me.renderBonuses, me);
        me.callParent();
        if (me.user) {
            grid.on('viewready', me.onViewReady, me);
        }
    },
    onViewReady: function(grid) {
        var me = this,
            selModel = grid.getSelectionModel();
        if (me.user) {
            me.renderBonuses(me.user.get('feature'));
        }
        selModel.select(me.user.getLevel() - 1);
        selModel.setLocked(true);
    },
    renderBonuses: function(store) {
        var me = this,
            feats = store.getExpFeatures(),
            l = Math.min(feats.length, 4),
            el = me.el.down('.exp-bonuses'),
            calcTime = function(feat) {
                return Math.floor(Math.max((ExGods.util.Date.normalizeServerDateTime(new Date(feat.get('ended').split('-').join('/'))).getTime() - new Date().getTime()) / 1000, 0));
            },
            onClickFn = function(feature) {
                Ext.widget('commondetailswindow', {
                    itemElement: this,
                    cascade: false,
                    data: {
                        label: feature.data.label,
                        description: feature.data.description,
                        image: feature.data.images.main
                    }
                });
            };
        ExGods.util.Ticker.removeListener(me.timer);
        me.timers = [];
        if (el) {
            if (l) {
                var el = me.el.down('.exp-bonuses'),
                    i = 0,
                    feat, li, timer;
                while (el.dom.firstChild) {
                    el.dom.firstChild.onclick = null;
                    el.dom.removeChild(el.dom.firstChild);
                }
                for (; i < l; i++) {
                    feat = feats[i];
                    li = document.createElement('li');
                    li.style.backgroundImage = 'url(' + feat.get('images').main + ')';
                    timer = document.createElement('div');
                    timer.innerHTML = Ext.util.Format.countdown(calcTime(feat), {
                        format: "short"
                    });
                    me.timers.push(timer);
                    li.onclick = onClickFn.bind(li, feat);
                    li.appendChild(timer);
                    el.dom.appendChild(li);
                }
                var _onTick = function() {
                        for (i = 0; i < l; i++) {
                            me.timers[i].innerHTML = Ext.util.Format.countdown(calcTime(feats[i]), {
                                format: "short"
                            });
                        }
                    };
                setTimeout(function() {
                    me.timer = ExGods.util.Ticker.addListener(_onTick, me);
                    _onTick();
                }, 0);
            } else {
                el.dom.removeChild(el.dom.firstChild);
            }
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: []
        };
    }
});

/**
 * Управление пользователем
 */
Ext.define('ExGods.controller.User', {
    extend: ExGods.controller.Base,
    models: [
        'User'
    ],
    views: [
        'CommonWindow',
        'user.ExperienceTable',
        'user.Info',
        'user.TechInfo',
        'user.TrophyTable',
        'user.PowerChange'
    ],
    refs: [
        {
            /**
         * @method getTechInfoContainer
         * Получает отображение краткой инфы персонажа
         * @return {Ext.container.Container}
         */
            ref: 'techInfoContainer',
            selector: '#tech-info-container'
        },
        {
            /**
         * @method getTechInfo
         * Получает отображение краткой инфы персонажа
         * @return {ExGods.view.user.TechInfo}
         */
            ref: 'techInfo',
            selector: '#tech-info'
        },
        {
            /**
         * @method getHeaderRight
         * Возвращает отображение контейнер в правом углу шапки
         * @return {Ext.container.Container}
         */
            ref: 'headerRight',
            selector: '#header-right'
        },
        {
            ref: 'questButton',
            selector: '#mainmenu-quests-button'
        }
    ],
    tooltips: [
        'item',
        'slot'
    ],
    init: function(app) {
        var me = this;
        me.control({
            'techinfo': {
                thumbclick: me.onTechInfoClick
            },
            'chatmessagelist': {
                infoclick: me.onNickInfoClick
            },
            'experiencebar': {
                click: me.onUserExpirienceClick
            },
            'trophybar': {
                click: me.onUserTrophyClick
            },
            'userfinance': {
                render: me.updateMoney
            }
        });
        app.on({
            /**
             * @event nickinfoclick
             * Срабатывает при клике по иконке инфы персонажа
             * @member ExGods.app
             * 
             * @param {String} title
             */
            nickinfoclick: me.onNickInfoClick,
            scope: me
        });
        app.getChatConnection().on({
            command_user: me.onUserCommand,
            command_reload: me.onReloadCommand,
            scope: me
        });
        // Добавляю обработчик ответа от сервера по ключу "user"
        me.addAjaxRequestKeyHandler('user', function(data) {
            me.getUser().set(data.user);
            var slots = me.getUser().get('slots');
            Ext.each(data.user.update_slots, function(slot) {
                var record = slots.getById(parseInt(slot.ekey));
                if (record) {
                    record.set(slot);
                }
            });
            if (me.getQuestButton()) {
                me.getQuestButton().reset();
                me.getQuestButton().addCount(ExGods.app.user.availableQuestsStore.totalCount);
            }
        }, me);
        ExGods.Components.addComponentInitializer('user_target_panel', me.initUserTargetPanelComponent, me);
        me.getUser().on('statschanged', me.onPowerChanged, me);
        me.getUser().on('money' + ExGods.ref('constants|currency').value + 'changed', me.onMoneyChanged, me);
        me.getUser().on('moneycrystalchanged', me.onMoneyChanged, me);
    },
    onLaunch: function(app) {
        var me = this,
            user = me.getUser();
        me.getTechInfoContainer().add({
            xtype: 'techinfo',
            id: 'tech-info',
            user: user
        });
        if (me.getQuestButton())  {
            me.getQuestButton().addCount(ExGods.app.user.availableQuestsStore.totalCount);
        }
        
    },
    /**
     * срабатывает на команту command_user из чата
     */
    onUserCommand: function() {
        this.getUser().loadRemote();
    },
    /**
     * Обработка команды чата reload.
     */
    onReloadCommand: function() {
        location.reload();
    },
    onPowerChanged: function(user, newStats, oldStats) {
        var change = newStats.power - oldStats.power;
        if (Ext.get('user_power_change'))  {
            return;
        }
        
        var positive = undefined;
        if (change > 0) {
            positive = true;
        } else if (change < 0) {
            positive = false;
        }
        if (positive != undefined) {
            var wdj = Ext.widget('powerchange', {
                    positive: positive,
                    change: change,
                    autoShow: false
                });
            ExGods.Resources.load(wdj, function() {
                wdj.show();
            });
        }
    },
    onMoneyChanged: function(newValue, oldValue, record, key) {
        var me = this,
            isBattle = me.user.getBattle(),
            cmp = Ext.getCmp('user-finance');
        if (!cmp || !cmp.rendered) {
            if (!me.old_values)  {
                me.old_values = {};
            }
            
            me.old_values[key] = oldValue;
            return;
        }
        if (cmp.animating[key])  {
            return;
        }
        
        cmp.updateMoney.apply(cmp, arguments);
    },
    updateMoney: function() {
        var me = this,
            cmp = Ext.getCmp('user-finance'),
            money = me.user.get('money'),
            value;
        if (!me.old_values || cmp.animating[key])  {
            return;
        }
        
        for (var key in me.old_values) {
            cmp.updateMoney(money[key], me.old_values[key], me.user, key);
        }
        delete me.old_values;
    },
    /**
     * Возвращает отображение информации о пользователе
     * 
     * @param {ExGods.model.User} [user] Пользователь, если его нет, то это ты
     */
    initUserInfo: function(user) {
        var me = this,
            app = me.application,
            info,
            raidsStore = ExGods.app.getGuildRaidsStore();
        if (!user)  {
            user = app.user;
        }
        
        info = Ext.widget('window2', {
            id: 'user-info',
            autoShow: false,
            user: user,
            items: [
                {
                    xtype: 'userinfo',
                    user: user,
                    raidsStore: raidsStore,
                    listeners: {
                        close: function() {
                            info.close();
                        }
                    }
                }
            ]
        });
        if (user != app.user) {
            info.on('destroy', function(view) {
                user.destroyStores();
            });
        }
        ExGods.app.block();
        ExGods.Resources.load(info, function() {
            ExGods.app.unblock();
            info.show();
        });
        return info;
    },
    /**
     * @private
     */
    onTechInfoClick: function(data) {
        var me = this;
        if (!data.displayTitle.data.real_user && data.displayTitle.data.is_bot) {} else // ignore
        {
            me.onNickInfoClick(data.displayTitle.data.display_title);
        }
    },
    /**
     * Обрабатывает клик по инфе в нике. Показывает куклу и пр. другого персонажа.
     * @private
     *
     * @param {String} title Ник персонажа
     */
    onNickInfoClick: function(title) {
        var me = this,
            cmp, cmpId,
            viewport = me.app.getController('Viewport');
        if (me.user.get('display_title') != title) {
            me.request({
                url: '/game.pl?cmd=info_user',
                params: {
                    title: title
                },
                success: function(json) {
                    if (json.user_info) {
                        ExGods.helpme.loadProtos(json.user_info, 'slots.items.proto_id|mask_proto_id', function() {
                            me.showUserInfo(json.user_info);
                        });
                    }
                }
            });
        } else {
            me.showMyInfo();
        }
    },
    /**
     * @private
     * Показывает инфо текущего пользователя
     */
    showMyInfo: function() {
        var me = this;
        if (me.getUser().isBattle()) {
            me.showUserInfo(me.user);
        } else {
            ExGods.Components.toggle('INVENTORY');
        }
    },
    /**
     * Показывает окно с информацией о другом пользователе
     * @private
     * 
     * @param {Object} user Данные пользователя или модель пользователя
     */
    showUserInfo: function(user) {
        var me = this,
            user,
            viewport = me.app.getController('Viewport'),
            info = Ext.getCmp('user-info');
        if (Ext.getClassName(user) != 'ExGods.model.User') {
            user = Ext.create('ExGods.model.User', user);
        }
        if (info) {
            if (info.user != user) {
                info.destroy();
                me.initUserInfo(user);
            } else {
                info.destroy();
            }
        } else {
            me.initUserInfo(user);
        }
    },
    /**
     * Показывает окно с таблицей опыта
     * @private
     *
     * @param {ExGods.view.user.ExperienceBar} cmp Шкала опыта
     */
    onUserExpirienceClick: function(cmp) {
        var me = this,
            user = cmp.user,
            data, store, cmp;
        data = Ext.Array.clone(ExGods.references.get('user_level').items);
        data.pop();
        // убираем последний уровень, его показывать не надо, он недостижим
        store = Ext.create('Ext.data.Store', {
            fields: [
                'level',
                'expa'
            ],
            data: data,
            proxy: {
                type: 'memory'
            }
        });
        cmp = Ext.widget('userexperiencetable', {
            store: store,
            user: user,
            autoShow: false
        });
        ExGods.Resources.load(cmp, function() {
            cmp.show();
        });
    },
    /**
     * Показывает окно с таблицей трофеев
     * @private
     *
     * @param {ExGods.view.user.TrophyBar} cmp Шкала трофеев
     */
    onUserTrophyClick: function(cmp) {
        var me = this,
            user = cmp.user,
            data, cmp, store;
        data = Ext.Array.clone(ExGods.references.get('user_trophy').getValues());
        data.pop();
        // убираем последний ранг, его показывать не надо, он недостижим
        store = Ext.create('Ext.data.Store', {
            fields: [
                'description',
                'trophy'
            ],
            data: data,
            proxy: {
                type: 'memory'
            }
        });
        cmp = Ext.widget('usertrophytable', {
            store: store,
            user: user,
            autoShow: false
        });
        ExGods.Resources.load(cmp, function() {
            cmp.show();
        });
    },
    initUserTargetPanelComponent: function(config, componentId) {
        var me = this,
            store = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.User'
            }),
            actions = [],
            wnd;
        if (config.users) {
            store.loadRawData(config.users);
        } else {
            switch (config.source) {
                case 'battle':
                    var mySide = me.getUser().getBattleSide(),
                        targetSide = (mySide == config.side) ? 'allies' : 'enemies';
                    var users = Ext.Array.filter(me.application.getController('battle.BattleView')[targetSide].getRange(), function(item) {
                            var valid = true;
                            if (config.dead == item.getBattleInfo().live) {
                                valid = false;
                            }
                            return valid;
                        });
                    store.loadRecords(users);
                    break;
                default:
                    var users = me.application.getChatContactsStore().data.items;
                    store.loadRecords(users);
                    break;
            }
        }
        for (var i = 1; i < 5; i++) {
            var label = config['btn' + i];
            if (label) {
                var act = config['act' + i];
                var clientAction = {
                        text: label,
                        xtype: "textbutton",
                        cls: 'no_border',
                        margin: '3 5 0 5',
                        disabled: true
                    };
                if (Ext.isObject(act)) {
                    Ext.apply(clientAction, {
                        clientAction: act.id,
                        handler: function(button, event) {
                            var selection = button.up().down('viewpanel').getView().getSelectionModel().getSelection();
                            if (selection.length) {
                                ExGods.ClientActions.createAndInvoke({
                                    actionId: this.clientAction,
                                    selected_target: selection[0]
                                }, function() {
                                    wnd.close();
                                }, function(err) {
                                    /***/
                                    me.log('error', err);
                                });
                            }
                        }
                    });
                }
                actions.push(clientAction);
            }
        }
        wnd = Ext.widget('floatwindow', {
            id: componentId,
            autoShow: false,
            width: 360,
            height: 360,
            plugins: [
                'skindeco'
            ],
            y: 100,
            items: [
                {
                    xtype: 'usertargetwindow',
                    componentCls: config.componentCls,
                    windowTitle: config.windowTitle,
                    store: store,
                    action: config.action,
                    clientActions: actions,
                    listeners: config.listeners || [],
                    singleBtn: false,
                    searchEmptyText: config.searchEmptyText,
                    buttonCls: 'user-button no_border',
                    buttonText: config.buttonText || ExGods.getMsgByKey('apply_btn_text')
                }
            ]
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
        });
        return wnd;
    },
    /**
     * Реализация метода источника тултипов
     */
    getTooltipData: function(type, value) {
        var me = this,
            userInfo = Ext.getCmp('user-info'),
            data;
        value = value.split('|');
        if (userInfo) {
            if (type == 'item' && value[1] == 'user_info') {
                userInfo.user.slots().each(function(slot) {
                    slot.items().each(function(item) {
                        if (item.data.item_id == value[0]) {
                            data = {
                                item: item
                            };
                        }
                    });
                });
            } else if (type == 'slot') {
                userInfo.user.slots().each(function(slot) {
                    if (slot.data.ekey == value[0]) {
                        data = {
                            slot: slot
                        };
                    }
                });
            }
        }
        return data;
    }
});

/**
 * Контроллер вьюпорта. Управляет основным лейаутом игры.
 *
 * Инициализация лейату выполняется через метод setLayout(<layoutName>). Контроллер сначала вызовет метод before<layoutName>Layout,
 * после чего будет вызван метод set<layoutName>Layout и выкинет событие "layoutchanged".
 *
 * @author orangecat
 * @music Moby - Natural Blues
 */
Ext.define('ExGodsCore.controller.Viewport', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            error: true,
            warn: true
        },
        prefix: 'ViewportCore:'
    },
    /**
     * @cfg {Array} layouts Список основных лейаутов.
     * Для каждого лейаута будут созданы методы контроллера before<LayoutName>Layout и set<LayoutName>Layout
     */
    layouts: [
        'main'
    ],
    /**
     * @property {String} layout Название текущего лейаута
     * @param this
     * @param {String} layout Название лейатуа
     */
    layout: null,
    init: function() {
        var me = this;
        // создаю методы инициализации лейаутов
        Ext.Array.each(me.layouts, function(layout) {
            var beforeMethodName = 'before' + Ext.String.capitalize(layout) + 'Layout',
                setMethodName = 'set' + Ext.String.capitalize(layout) + 'Layout';
            if (!me[beforeMethodName]) {
                me[beforeMethodName] = Ext.emptyFn;
            }
            if (!me[setMethodName]) {
                me[setMethodName] = Ext.emptyFn;
            }
        });
        me.callParent();
    },
    /**
     * Поменять текущий лейаут приложения
     */
    setLayout: function(layout, callback) {
        var me = this,
            methodName = 'set' + Ext.String.capitalize(layout) + 'Layout';
        if (typeof me[methodName] == 'function') {
            me[methodName](function() {
                me.layout = layout;
                me.fireEvent('layoutchanged', me, me.layout);
                if (callback) {
                    callback();
                }
            });
        } else {
            /***/
            me.log('error', 'Метод для установки лейаута "' + layout + '" не найден.');
        }
    }
});

/**
 * Диалог разлогинивания
 *
 * @author Viatluhin Dmitry
 */
Ext.define('ExGods.view.LogOutDialog', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.logoutdialog',
    /**
     * @cfg {String} message Сообщение диалога
     */
    message: '',
    /**
     * @cfg {Array} buttons Кнопки диалога
     */
    buttons: null,
    minWidth: 250,
    plugins: [
        'skindeco'
    ],
    closable: false,
    y: 260,
    // по высоте центрирую относительно локации
    padding: '0 0 12 0',
    initComponent: function() {
        var me = this;
        Ext.apply(me, {
            autoShow: true,
            items: [
                {
                    xtype: 'panel',
                    tpl: new Ext.Template(me.message),
                    data: {
                        time_to_end: me.time_to_end
                    },
                    plugins: [
                        'paperdeco'
                    ],
                    padding: '20 10 30 10',
                    width: 500,
                    margin: '0 0 -15 0'
                }
            ],
            bodyStyle: 'text-align: center; line-height: 18px; overflow: visible;',
            buttonAlign: 'center',
            buttons: {
                defaults: {
                    xtype: 'textbutton',
                    cls: 'in_one_row double_text_btn',
                    minWidth: 190
                },
                items: me.buttons
            }
        });
        me.callParent();
    }
});

/**
 * Заголовок поля боя.
 *
 * Генерирует события clicklink - по клику на ссылку в заголовке
 */
Ext.define('ExGods.view.battle_new.Header', {
    extend: Ext.Component,
    alias: 'widget.battle_header',
    timerValue: 0,
    initComponent: function() {
        var me = this;
        me.html = '<a class="btn-battle selected" style="background-image: url(' + ExGods.ref('images|battle_images').image['fight_btn_text'] + ')"></a>' + '<a class="btn-group" style="background-image: url(' + ExGods.ref('images|battle_images').image['group_btn_text'] + ')"></a>' + '<div class="timer"></div>';
        me.callParent(arguments);
    },
    setBlocked: function(blocked) {
        var me = this,
            _turnTimer = function() {
                var blockedEl;
                if (me.getEl()) {
                    blockedEl = me.getEl().down('.blocked');
                    if (blockedEl) {
                        blockedEl.applyStyles({
                            'background-image': 'none'
                        });
                        ExGods.helpme.shine(blockedEl, 'blocked-timer', 9, -54, ExGods.ref('constants|bat_anim_header_timer_spf').value, function() {
                            blockedEl.applyStyles({
                                'background-image': 'url(' + IMAGE_URL + 'battle/watch_for_compile.png)'
                            });
                            setTimeout(function() {
                                if (me.blocked) {
                                    _turnTimer();
                                }
                            }, ExGods.ref('constants|bat_anim_header_timer_pause').value);
                        });
                    }
                }
            };
        if (!me.died) {
            if (me.blocked !== blocked) {
                me.blocked = blocked;
                if (me.rendered) {
                    if (me.blocked) {
                        me.getEl().down('.timer').setHTML('<div class="blocked"></div>');
                        _turnTimer();
                    } else {
                        me.updateTimer();
                    }
                }
            }
        }
    },
    setDied: function() {
        var me = this;
        me.died = true;
        me.blocked = true;
        me.getEl().down('.timer').setHTML('');
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.getEl().on('click', me.onLinkClick, me, {
            delegate: 'a'
        });
    },
    /**
     * Выставить таймер на time секунд
     */
    setTime: function(time) {
        var me = this;
        me.timerValue = time;
        if (!me.blocked) {
            if (me.timerValue > 0) {
                me.updateTimer();
            } else {
                me.setBlocked(true);
            }
        }
    },
    updateTimer: function() {
        var me = this,
            el = me.getEl().down('.timer');
        el.setHTML(ExGods.util.Sprite.printSprite(me.timerValue, false, {
            width: 18,
            height: 38,
            horizontal: false
        }));
    },
    onLinkClick: function(e, el) {
        var me = this;
        el = Ext.get(el);
        if (!el.hasCls('selected')) {
            me.getEl().select('a').removeCls('selected');
            el.addCls('selected');
            if (el.hasCls('btn-battle')) {
                me.getEl().select('.timer').show();
                me.fireEvent('showbattle');
            } else {
                me.getEl().select('.timer').hide();
                me.fireEvent('showgroup');
            }
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.battle_new.Container', {
    extend: Ext.container.Container,
    alias: 'widget.battlecontainer',
    id: 'battle-container',
    layout: 'card',
    padding: 0,
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [],
            imgs;
        imgs = ExGods.ref('images|battle_images').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        imgs = ExGods.ref('images|combat_bgs').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Сообщение о действии
 */
Ext.define('ExGods.view.Message', {
    extend: Ext.panel.Panel,
    alias: 'widget.message',
    closable: true,
    floating: true,
    shadow: false,
    width: 458,
    height: 74,
    bodyPadding: '0 25 0 25',
    y: 23,
    initComponent: function() {
        var me = this;
        if (/<br/.test(me.html)) {
            me.bodyStyle = {
                margin: '-5px'
            };
        }
        me.callParent();
    }
});

/**
 * Отображает техническую информацию о локации
 */
Ext.define('ExGods.view.location.Info', {
    alias: 'widget.locationinfo',
    extend: Ext.Component,
    renderTpl: [
        '<span id="location-info-world">{world}</span>',
        '<span id="location-info-location">{location}</span>'
    ],
    childEls: [
        'world',
        'location'
    ],
    id: 'location-info',
    layout: 'absolute',
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.location = me.el.down('#location-info-location');
        me.world = me.el.down('#location-info-world');
    },
    update: function(renderData) {
        var me = this;
        me.location.update(renderData.location);
        me.world.update(renderData.world);
    }
});

/**
 * Состаяние средств персонажа отображается в правом верхнем углу и показывает
 * (на текущий момент) количество золота и кристаллов. Также позволяет быстро
 * перейти в банк для покупки той или иной валюты.
 */
Ext.define('ExGods.view.user.Finance', {
    extend: Ext.Component,
    alias: 'widget.userfinance',
    id: 'user-finance',
    /**
     * @private
     * @property {String} gameCur
     * Ключ игровой валюты
     */
    /**
     * @private
     * @property {String} crystalCur
     * Ключ валюты, полученной за реальные деньги
     */
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    animating: {},
    animData: {
        gold: {
            images: [
                'user/add_coins.png'
            ],
            frames: [
                [
                    0,
                    0,
                    26,
                    25,
                    0,
                    -66.2,
                    0.5499999999999998
                ],
                [
                    26,
                    0,
                    38,
                    25,
                    0,
                    -66.2,
                    0.5499999999999998
                ],
                [
                    64,
                    0,
                    52,
                    25,
                    0,
                    -65.2,
                    0.5499999999999998
                ],
                [
                    116,
                    0,
                    65,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ],
                [
                    0,
                    25,
                    78,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ],
                [
                    78,
                    25,
                    92,
                    26,
                    0,
                    -63.2,
                    1.5499999999999998
                ],
                [
                    0,
                    51,
                    97,
                    27,
                    0,
                    -62.2,
                    2.55
                ],
                [
                    97,
                    51,
                    103,
                    27,
                    0,
                    -61.2,
                    2.55
                ],
                [
                    0,
                    78,
                    107,
                    28,
                    0,
                    -61.2,
                    3.55
                ],
                [
                    107,
                    78,
                    113,
                    29,
                    0,
                    -60.2,
                    4.55
                ],
                [
                    0,
                    107,
                    114,
                    29,
                    0,
                    -59.2,
                    4.55
                ],
                [
                    114,
                    107,
                    115,
                    30,
                    0,
                    -58.2,
                    5.55
                ],
                [
                    0,
                    137,
                    114,
                    29,
                    0,
                    -59.2,
                    4.55
                ],
                [
                    114,
                    137,
                    113,
                    29,
                    0,
                    -60.2,
                    4.55
                ],
                [
                    0,
                    166,
                    113,
                    28,
                    0,
                    -60.2,
                    3.55
                ],
                [
                    113,
                    166,
                    112,
                    28,
                    0,
                    -61.2,
                    3.55
                ],
                [
                    0,
                    194,
                    113,
                    28,
                    0,
                    -60.2,
                    2.55
                ],
                [
                    113,
                    194,
                    113,
                    28,
                    0,
                    -60.2,
                    2.55
                ],
                [
                    0,
                    222,
                    113,
                    27,
                    0,
                    -60.2,
                    1.5499999999999998
                ],
                [
                    113,
                    222,
                    112,
                    25,
                    0,
                    -61.2,
                    0.5499999999999998
                ],
                [
                    0,
                    249,
                    112,
                    25,
                    0,
                    -61.2,
                    0.5499999999999998
                ],
                [
                    112,
                    249,
                    112,
                    25,
                    0,
                    -61.2,
                    0.5499999999999998
                ],
                [
                    0,
                    274,
                    111,
                    25,
                    0,
                    -62.2,
                    0.5499999999999998
                ],
                [
                    111,
                    274,
                    111,
                    25,
                    0,
                    -62.2,
                    0.5499999999999998
                ],
                [
                    0,
                    299,
                    110,
                    25,
                    0,
                    -63.2,
                    0.5499999999999998
                ],
                [
                    110,
                    299,
                    110,
                    25,
                    0,
                    -63.2,
                    0.5499999999999998
                ],
                [
                    0,
                    324,
                    110,
                    25,
                    0,
                    -63.2,
                    0.5499999999999998
                ],
                [
                    110,
                    324,
                    109,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ],
                [
                    0,
                    349,
                    109,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ],
                [
                    109,
                    349,
                    109,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ]
            ]
        },
        crystal: {
            images: [
                'user/crystall_add.png'
            ],
            frames: [
                [
                    0,
                    0,
                    17,
                    13,
                    0,
                    -60.6,
                    -26.05
                ],
                [
                    17,
                    0,
                    22,
                    14,
                    0,
                    -59.6,
                    -26.05
                ],
                [
                    39,
                    0,
                    29,
                    15,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    68,
                    0,
                    29,
                    18,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    97,
                    0,
                    34,
                    23,
                    0,
                    -57.6,
                    -26.05
                ],
                [
                    131,
                    0,
                    37,
                    25,
                    0,
                    -56.6,
                    -26.05
                ],
                [
                    168,
                    0,
                    48,
                    26,
                    0,
                    -55.6,
                    -25.05
                ],
                [
                    0,
                    26,
                    61,
                    27,
                    0,
                    -55.6,
                    -24.05
                ],
                [
                    61,
                    26,
                    75,
                    27,
                    0,
                    -54.6,
                    -24.05
                ],
                [
                    136,
                    26,
                    89,
                    28,
                    0,
                    -53.6,
                    -23.05
                ],
                [
                    0,
                    54,
                    101,
                    29,
                    0,
                    -53.6,
                    -22.05
                ],
                [
                    101,
                    54,
                    107,
                    29,
                    0,
                    -52.6,
                    -22.05
                ],
                [
                    0,
                    83,
                    111,
                    29,
                    0,
                    -52.6,
                    -22.05
                ],
                [
                    111,
                    83,
                    113,
                    28,
                    0,
                    -53.6,
                    -23.05
                ],
                [
                    0,
                    112,
                    118,
                    28,
                    0,
                    -54.6,
                    -23.05
                ],
                [
                    118,
                    112,
                    118,
                    27,
                    0,
                    -54.6,
                    -24.05
                ],
                [
                    0,
                    140,
                    117,
                    27,
                    0,
                    -55.6,
                    -24.05
                ],
                [
                    117,
                    140,
                    117,
                    26,
                    0,
                    -55.6,
                    -25.05
                ],
                [
                    0,
                    167,
                    116,
                    25,
                    0,
                    -56.6,
                    -26.05
                ],
                [
                    116,
                    167,
                    115,
                    25,
                    0,
                    -57.6,
                    -26.05
                ],
                [
                    0,
                    192,
                    115,
                    25,
                    0,
                    -57.6,
                    -26.05
                ],
                [
                    115,
                    192,
                    114,
                    25,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    0,
                    217,
                    113,
                    25,
                    0,
                    -59.6,
                    -26.05
                ],
                [
                    113,
                    217,
                    113,
                    25,
                    0,
                    -59.6,
                    -26.05
                ],
                [
                    0,
                    242,
                    112,
                    25,
                    0,
                    -60.6,
                    -26.05
                ],
                [
                    112,
                    242,
                    112,
                    25,
                    0,
                    -60.6,
                    -26.05
                ],
                [
                    0,
                    267,
                    113,
                    25,
                    0,
                    -59.6,
                    -26.05
                ],
                [
                    113,
                    267,
                    114,
                    25,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    0,
                    292,
                    114,
                    25,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    114,
                    292,
                    115,
                    25,
                    0,
                    -57.6,
                    -26.05
                ],
                [
                    0,
                    317,
                    116,
                    25,
                    0,
                    -56.6,
                    -26.05
                ],
                [
                    116,
                    317,
                    117,
                    26,
                    0,
                    -55.6,
                    -25.05
                ],
                [
                    0,
                    343,
                    117,
                    27,
                    0,
                    -55.6,
                    -24.05
                ],
                [
                    117,
                    343,
                    118,
                    27,
                    0,
                    -54.6,
                    -24.05
                ],
                [
                    0,
                    370,
                    119,
                    28,
                    0,
                    -53.6,
                    -23.05
                ]
            ]
        }
    },
    initComponent: function() {
        var me = this,
            user = me.user,
            money = user.get('money'),
            constants = ExGods.references.get('constants'),
            gameCur = constants.get('currency').value,
            crystalCur = 'crystal';
        me.gameCur = gameCur;
        me.crystalCur = crystalCur;
        if (user) {
            me.childEls = [
                'icon',
                gameCur,
                gameCur + 'Btn',
                crystalCur,
                crystalCur + 'Btn'
            ];
            me.renderTpl = [
                '<span id="user-finance-icon"></span>',
                '<div id="frame-anim-' + gameCur + '"></div>',
                '<span class="money money-1" id="{id}-' + gameCur + '">{' + gameCur + '}</span>',
                '<input class="add-btn add-btn-1" id="{id}-' + gameCur + 'Btn" type="button" />',
                '<div id="frame-anim-' + crystalCur + '"></div>',
                '<span class="money money-2" id="{id}-' + crystalCur + '">{' + crystalCur + '}<div class="frame-anim-container"></div></span>',
                '<input class="add-btn add-btn-2" id="{id}-' + crystalCur + 'Btn" type="button" />'
            ];
            me.renderData = {};
            me.renderData[gameCur] = Ext.util.Format.number(money[gameCur], '0,0');
            me.renderData[crystalCur] = Ext.util.Format.number(money[crystalCur], '0,0');
        }
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        // migration 4.1.2 -> 5.1.1 fix
        me.icon = me.el.down('#' + me.id + '-icon');
        me[me.gameCur] = me.el.down('#' + me.id + '-' + me.gameCur);
        me[me.gameCur + 'Btn'] = me.el.down('#' + me.id + '-' + me.gameCur + 'Btn');
        me[me.crystalCur] = me.el.down('#' + me.id + '-' + me.crystalCur);
        me[me.crystalCur + 'Btn'] = me.el.down('#' + me.id + '-' + me.crystalCur + 'Btn');
        /**
         * @event iconclick
         * Клик по иконке с мешком денег
         */
        me.mon(me.icon, 'click', Ext.Function.pass(me.fireEvent, [
            'iconclick'
        ], me));
        /**
         * @event adddefaultcurrency
         * Клик по "+" напротив игровой валюты
         */
        me.mon(me[me.gameCur + 'Btn'], 'click', Ext.Function.pass(me.fireEvent, [
            'adddefaultcurrency'
        ], me));
        /**
         * @event addrealcurrency
         * Клик по "+" напротив реальной валюты
         */
        me.mon(me[me.crystalCur + 'Btn'], 'click', Ext.Function.pass(me.fireEvent, [
            'addrealcurrency'
        ], me));
    },
    /**
     * @private
     * Отображает изменения финансов пользовтеля
     *
     * @param {Number} newValue
     * @param {Number} oldValue
     * @param {Ext.data.Model} record
     * @param {String} key Ключ валюты из справочника
     */
    updateMoney: function(newValue, oldValue, record, key) {
        var me = this,
            user = me.user,
            animData = me.animData[key],
            l = animData.frames.length,
            color;
        if (newValue - oldValue > 0) {
            me.animating[key] = true;
            document.getElementById('frame-anim-' + key).style.display = 'block';
            var spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                    images: animData.images,
                    frames: animData.frames,
                    renderTo: 'frame-anim-' + key,
                    onProgress: function(index) {
                        me[key].update(Ext.util.Format.number(Math.floor(oldValue + (user.get('money')[key] - oldValue) * index / l), '0,0'));
                    },
                    onFinish: function() {
                        me[key].update(Ext.util.Format.number(user.get('money')[key], '0,0'));
                        var dom = document.getElementById('frame-anim-' + key);
                        if (dom)  {
                            dom.style.display = 'none';
                        }
                        
                        me.animating[key] = false;
                    }
                });
            spriteSheet.start();
        } else {
            me[key].update(Ext.util.Format.number(user.get('money')[key], '0,0'));
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var it in me.animData) {
            arr_images = arr_images.concat(me.animData[it].images);
        }
        return {
            images: [
                IMAGE_URL + 'user/add_coins.png',
                IMAGE_URL + 'user/crystall_add.png',
                IMAGE_URL + 'user-finance-icon.jpg',
                IMAGE_URL + 'user-finance-add.jpg',
                IMAGE_URL + 'panel_user.png',
                IMAGE_URL + 'panel_user_combo.png',
                IMAGE_URL + 'panel_finances.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Контейнер локации
 */
Ext.define('ExGods.view.location.Container', {
    extend: Ext.panel.Panel,
    alias: 'widget.locationcontainer',
    /**
     * @cfg user 
     */
    user: {},
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'locationview',
                user: me.user
            }
        ];
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this,
            images = [];
        if (me.user.location && me.user.location.data) {
            images.push(me.user.location.data.blob.image);
            if (me.user.location.data.blob.objects) {
                Ext.Array.each(me.user.location.data.blob.objects, function(obj) {
                    if (obj.interactive.view == "button" && /^img\:/.test(obj.interactive.params_display.label)) {
                        images.push(obj.interactive.params_display.label.replace('img:', ''));
                    } else if (obj.interactive.view == "image") {
                        images.push(obj.interactive.params_display.image);
                    } else if (obj.interactive.view == "component") {}
                    //
                    images.push(obj.interactive.image_mask);
                });
            }
        }
        return {
            images: images
        };
    }
});

/**
 * Отображение восстанавливаемого параметра, опционально с кнопкой нажатия textbutton
 */
Ext.define('ExGods.view.Loader', {
    extend: Ext.Component,
    alias: 'widget.loader',
    width: 840,
    height: 410,
    y: 8,
    x: 10,
    style: {
        backgroundColor: 'black',
        backgroundRepeat: 'no-repeat',
        opacity: 0,
        zIndex: 301,
        position: 'absolute'
    },
    hidden: true,
    /**
     * добавляет анимированное затемнение локации
     * options: img,html,duration
     */
    addLoader: function(callback, options) {
        if (!options)  {
            options = {};
        }
        
        var me = this,
            duration = (options && options.duration) ? options.duration : parseInt(ExGods.ref('constants|location_loader_duration').value),
            timeout = options.timeout || ExGods.ref('constants|location_loader_spinner_delay').value,
            world = ExGods.app.getLocationController().service.data.location.world,
            image = ExGods.ref('images|location_loader').image[world],
            spinnerTop;
        if (me.isVisible()) {
            if (callback) {
                setTimeout(callback, new Date() - me.maskSetTime + duration);
            }
            // если маску уже повесили, вызываю коллбек только после полного завершения отрисовки
            return;
        }
        
        if (options.img === undefined) {
            options.img = image;
            spinnerTop = '193px !important';
        }
        options.img = options.img.indexOf('http') == -1 ? IMAGE_URL + options.img : options.img;
        me.el.dom.style.backgroundImage = 'url(' + options.img + ')';
        me.el.dom.innerHTML = options.html || '';
        me.loaderOptions = options;
        me.show();
        me.animating = true;
        me.el.animate({
            duration: duration,
            to: {
                opacity: 1
            },
            callback: function() {
                me.animating = false;
                if (callback)  {
                    callback();
                }
                
            }
        });
        me.spinnerTimeout = setTimeout(me.addSpinner.bind(me, spinnerTop), timeout);
        me.maskSetTime = new Date();
    },
    /**
     * убирает затемнение локации анимированно
     * options: img,html,duration
     */
    addLoadRemover: function(callback, options) {
        if (!options)  {
            options = {};
        }
        
        var me = this;
        Ext.applyIf(options, me.loaderOptions);
        var duration = (options && options.duration) ? options.duration : parseInt(ExGods.ref('constants|location_loader_duration').value);
        if (me.removing) {
            if (callback)  {
                callback();
            }
            
            return;
        }
        
        me.removing = true;
        clearTimeout(me.spinnerTimeout);
        me.removeSpinner();
        me.el.animate({
            duration: duration,
            to: {
                opacity: 0
            },
            callback: function() {
                me.removing = false;
                me.hide();
                me.fireEvent('loader_removed');
                if (callback)  {
                    callback();
                }
                
            }
        });
    },
    /**
     * запускает подряд addLoader и addLoadRemover, вставляет колбек по-середине
     * options: img,html,duration
     */
    loadAndRemove: function(callback, options) {
        var me = this;
        me.addLoader(function() {
            if (callback)  {
                callback();
            }
            
            me.addLoadRemover();
        }, options);
    },
    addSpinner: function(top) {
        var me = this,
            spriteY = 0;
        me.el.mask('', 'new-mask-loading').addCls('global-mask');
        var el = me.el.down('.new-mask-loading');
        setTimeout(function() {
            if (top) {
                el.dom.setAttribute('style', 'top:' + top);
                setTimeout(function() {
                    if (el.dom)  {
                        el.dom.style.opacity = 1;
                    }
                    
                }, 500);
            } else {
                el.dom.style.opacity = 1;
            }
            me.blockInterval = setInterval(function() {
                if (el.dom) {
                    spriteY -= el.getHeight();
                    if (spriteY <= -3445)  {
                        spriteY = 0;
                    }
                    
                    el.dom.style.backgroundPosition = '0 ' + spriteY + 'px';
                } else {
                    clearInterval(me.blockInterval);
                }
            }, 42);
        }, 0);
    },
    removeSpinner: function() {
        clearInterval(this.blockInterval);
        this.el.unmask();
    },
    getResources: function() {
        var me = this,
            images = [
                IMAGE_URL + 'loader_waiting.png'
            ];
        Ext.Object.each(ExGods.ref('images|location_loader').image, function(k, v) {
            images.push(v);
        });
        return {
            images: images
        };
    }
});

/**
 * Окно на всю область локаций
 */
Ext.define('ExGods.view.Window1', {
    extend: Ext.panel.Panel,
    alias: 'widget.window1',
    layout: 'fit',
    layer: 'layer-over1',
    animating: false,
    closable: false,
    autoShow: true,
    width: 860,
    height: 430,
    y: 0,
    x: 0,
    plugins: [
        'skindeco'
    ]
});

/**
 * Окно поверх локации
 */
Ext.define('ExGods.view.Window2', {
    extend: Ext.panel.Panel,
    alias: 'widget.window2',
    layout: 'fit',
    closable: true,
    layer: 'layer-over2',
    width: 780,
    height: 430,
    y: 0,
    x: 40,
    plugins: [
        'skindeco'
    ],
    autoShow: true
});

/**
 * Плавающий контейнер. Должен располагаться поверх всех окон.
 */
Ext.define('ExGods.view.FloatWindow', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.floatwindow',
    cls: 'float-window',
    y: 260,
    width: 320,
    height: 155,
    closeAction: 'destroy',
    toFrontOnShow: true,
    bodyPadding: 0,
    layout: 'fit',
    title: '',
    autoShow: true
});

/**
 * Контроллер управляет общими элементами интерфейса.
 * Осуществляет переключение между основными окнами в случае начала боя.
 */
Ext.define('ExGods.controller.Viewport', {
    extend: ExGodsCore.controller.Viewport,
    views: [
        'CommonWindow',
        'Message',
        'skin.TabPanel',
        'TextButton',
        'Window1',
        'Window2',
        'FloatWindow',
        'user.Finance',
        'battle_new.Header',
        'LogOutDialog',
        'location.Container',
        'location.Info',
        'Loader',
        'battle_new.Container'
    ],
    layouts: [
        'main',
        'battle'
    ],
    refs: [
        {
            /**
         * @method getCenter
         * Возвращает центральную часть окна игры
         * @return {Ext.container.Container}
         */
            ref: 'center',
            selector: '#center'
        },
        {
            /**
         * @method getBottom
         * Возвращает нижнюю часть окна игры
         * @return {Ext.container.Container}
         */
            ref: 'bottom',
            selector: '#bottom'
        },
        {
            /**
         * @method getHeaderCenterContainer          
         * @return {Ext.container.Container}
         */
            ref: 'headerCenterContainer',
            selector: '#header-center'
        },
        {
            /**
         * @method getHeaderRight
         * Возвращает отображение контейнер в правом углу шапки
         * @return {Ext.container.Container}
         */
            ref: 'headerRight',
            selector: '#header-right'
        },
        {
            /**
         * @method getMessage
         * Возвращает сообщение об ошибке
         * @return {ExGods.view.ErrorReport}
         */
            ref: 'message',
            selector: '#message'
        },
        {
            ref: 'mainMenu',
            selector: '#mainmenu'
        },
        {
            ref: 'newsListCmp',
            selector: '#game-news-list'
        },
        {
            ref: 'viewportView',
            selector: '#viewport'
        },
        {
            ref: 'announcmentsView',
            selector: '#announcments-view'
        },
        {
            ref: 'chatContainer',
            selector: '#chat-container'
        },
        {
            ref: 'chestsHeaderButton',
            selector: '#chests-header-button'
        },
        {
            //getToolsMenuLangSelector
            ref: 'toolsMenuLangSelector',
            selector: '#tools_menu_lang_select'
        }
    ],
    /**
     * @property {ExGods.model.User} user
     * @inheritdoc ExGods.app#user
     */
    /**
     * @property {Boolean} gameShown
     */
    gameShown: false,
    tooltips: [
        'text',
        'item',
        'proto_item',
        'ingredient',
        'currency',
        'timed'
    ],
    init: function(app) {
        var me = this;
        me.user = app.user;
        me.listen({
            component: {
                '#chat-container': {
                    render: function(panel) {
                        panel.body.insertHtml('beforeEnd', '<div class="chat-deco chat-deco-tl"></div>' + '<div class="chat-deco chat-deco-tr"></div>');
                    }
                },
                '#chat-toolbar': {
                    render: function(bottom) {
                        bottom.getEl().insertHtml('beforeEnd', '<img alt="" height="4" id="splitter-chat-contacts-bottom" src="' + IMAGE_URL + 'chat-splitter-contacts-bottom.png" width="39" />');
                    }
                },
                'systemmenu button': {
                    click: me.onSystemMenuButtonClick
                },
                'window1': {
                    beforeshow: me.closeAllWindows,
                    beforeclose: me.onWindow1BeforeClose
                },
                'window2': {
                    beforeclose: me.onWindow2BeforeClose
                },
                'mainmenubutton': {
                    click: me.onMenuButtonClick
                },
                '#announcments-view': {
                    viewupdate: me.refreshViewportSize
                },
                '#chat-container': {
                    hide: me.onChatHide,
                    show: me.onChatShow
                },
                '#viewport': {
                    afterrender: me.onAfterViewportRendered
                },
                '#center': {
                    show: me.onCenterShow
                }
            }
        });
        app.on({
            logmessage: me.onLogMessage,
            gamestarted: me.onGameStarted,
            scope: me
        });
        Ext.getDoc().on({
            keyup: function(e) {
                if (e.altKey && e.ctrlKey && e.getCharCode() == e.Z) {
                    this.doFullscreen();
                }
            },
            scope: me
        });
        Ext.on('resize', me.refreshViewportSize, me);
        Ext.getBody().on('click', function(e, t) {
            var el = Ext.fly(t),
                parentDom = t.parentNode,
                proto;
            // клик по иконке "инфо персонажа"
            if (el.hasCls('info-icon')) {
                ExGods.app.fireEvent('nickinfoclick', el.parent('.userinfo').getAttribute('data-uname'));
            }
            //кликнули по абилке
            //проверка parentDom.className.indexOf для SVG элементов
            if (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('ability') != -1) {
                var protoId = parentDom.getAttribute('data-ability_id');
                /* подгружаем данные по абилке и показываем инфо после */
                ExGods.app.getAbilityPrototypesStore().loadNew(protoId, function() {
                    proto = this.data.getByKey(protoId);
                    if (proto) {
                        Ext.widget('commondetailswindow', {
                            itemElement: el.dom,
                            data: {
                                label: proto.data.label,
                                description: proto.data.description,
                                image: IMAGE_URL + proto.data.images.a
                            }
                        });
                    }
                });
            }
            //кликнули по основному движению
            if (el.hasCls('turn-link') || (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('turn-link') != -1)) {
                var turn = ExGods.ref('battle_turn').get(el.getAttribute('data-turn_name') || parentDom.getAttribute('data-turn_name'));
                Ext.widget('commondetailswindow', {
                    itemElement: el.dom,
                    data: {
                        label: turn.label,
                        description: turn.desc.desc,
                        image: IMAGE_URL + turn.desc.images.active
                    }
                });
            }
            //кликнули по предварительному движению
            if (el.hasCls('prep-link') || (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('prep-link') != -1)) {
                var prep = ExGods.ref('battle_prep').get(el.getAttribute('data-prep_name') || parentDom.getAttribute('data-prep_name'));
                Ext.widget('commondetailswindow', {
                    itemElement: el.dom,
                    data: {
                        label: prep.label,
                        description: prep.desc.desc,
                        image: IMAGE_URL + prep.desc.images.active
                    }
                });
            }
            //кликнули по боевому движению
            if (el.hasCls('battleaction-link') || (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('battleaction-link') != -1)) {
                var battleaction = ExGods.ref('battle_actions').get(el.getAttribute('data-battleaction_id') || parentDom.getAttribute('data-battleaction_id'));
                Ext.widget('commondetailswindow', {
                    itemElement: el.dom,
                    data: {
                        label: battleaction.label,
                        description: battleaction.desc.msg,
                        image: IMAGE_URL + battleaction.desc.img
                    }
                });
            }
            //кликнули по фиче
            if (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('feature') != -1) {
                var featureProtoId = parentDom.getAttribute('data-feature_id');
                /* подгружаем данные по фиче и показываем инфо после */
                ExGods.app.getFeaturePrototypesStore().loadNew(featureProtoId, function() {
                    proto = this.data.getByKey(featureProtoId);
                    if (proto) {
                        Ext.widget('commondetailswindow', {
                            itemElement: el.dom,
                            data: {
                                label: proto.data.label,
                                description: proto.data.description,
                                image: IMAGE_URL + proto.data.images.main
                            }
                        });
                    }
                });
            }
            //кликнули по действию
            if (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('action-item') != -1) {
                var actionId = parentDom.getAttribute('data-action_id');
                proto = ExGods.ref('direct_actions|' + actionId);
                if (proto) {
                    Ext.widget('commondetailswindow', {
                        itemElement: el.dom,
                        data: {
                            label: proto.images.name,
                            description: proto.images.description,
                            image: IMAGE_URL + proto.images.simple
                        }
                    });
                }
            }
            //кликнули по итем
            if (el.parent('.item')) {
                var item = el.parent('.item').dom;
                if (item) {
                    if (item.getAttribute('data-proto_id')) {
                        var slot = ExGods.app.user.slots().data.getByKey(item.getAttribute('data-slot_id')),
                            user_item = slot ? slot.items().getById(Number(item.getAttribute('data-item_id'))) : null;
                        ExGods.app.fireEvent('itemclick', {
                            itemEl: item,
                            item: user_item,
                            proto_id: item.getAttribute('data-proto_id'),
                            type: user_item ? 'iteminstance' : 'item',
                            quantity: 1
                        });
                    }
                    if (item.getAttribute('data-big_stuff_type')) {
                        ExGods.app.fireEvent('itemclick', {
                            itemEl: item,
                            proto_id: item.getAttribute('data-big_stuff_id'),
                            type: item.getAttribute('data-big_stuff_type'),
                            quantity: item.getAttribute('data-big_stuff_value')
                        });
                    }
                }
            }
        });
        me.on('layoutchanged', function() {
            if (me.startGameData) {
                me.showGame();
            }
        }, me, {
            single: true
        });
        me.callParent(arguments);
    },
    onLaunch: function(app) {
        var me = this;
        if (!me.user.isChatOn()) {
            Ext.getBody().addCls('chat-off');
        }
    },
    onAfterViewportRendered: function() {
        var me = this;
        /* Слои локации */
        var locationLayer = ExGods.Layers.factory({
                id: 'location-layer',
                renderTo: 'center',
                width: 860,
                height: 430,
                layout: 'fit',
                hidden: false
            });
        var layerOver1 = ExGods.Layers.factory({
                id: 'layer-over1',
                renderTo: 'center',
                type: 'single',
                style: {
                    zIndex: '101'
                },
                hidden: true
            });
        var layerOver2 = ExGods.Layers.factory({
                id: 'layer-over2',
                renderTo: 'center',
                type: 'single',
                style: {
                    zIndex: '201'
                },
                hidden: true,
                listeners: {
                    cmp_visible: function() {
                        layerOver1.mask();
                        locationLayer.mask();
                    },
                    hide: function() {
                        layerOver1.unmask();
                        locationLayer.unmask();
                    }
                }
            });
        /** Слой указаний */
        ExGods.Layers.factory({
            id: 'directions-layer',
            renderTo: 'viewport',
            type: 'stack',
            hidden: true,
            style: {
                'background-color': 'rgba(85, 85, 85, 0.15)',
                'zIndex': '10002'
            }
        });
        // он должен быть веше global-mask-ct. пока так, потом когда выпилю global-mask-ct поменяю
        /** loader component */
        ExGods.loaderCt = me.loaderCt = Ext.widget('loader', {
            renderTo: 'center'
        });
        if (me.user.isBattle()) {
            me.app.getController('battle.Battle').loadStart();
        } else // переключение лейаута в этом случае управляет контроллер battle.BattleView
        {
            me.setLayout('main');
        }
        me.refreshViewportSize();
    },
    onGameStarted: function(data) {
        var me = this;
        me.startGameData = data;
        if (me.layout) {
            me.showGame();
        }
    },
    /**
     * Показать интерфейс игры
     */
    showGame: function() {
        var me = this,
            data = me.startGameData,
            dailyBonusDialog;
        setTimeout(function() {
            exGodsLoader.finishAndDestroy(function() {
                me.getAnnouncmentsView().updateLayout();
                // иначе некорректный размер в начале
                me.getMainMenu().updateLayout();
                me.refreshViewportSize();
                me.getChatContainer().scrollChatToBottom();
                // показываем ежедневный бонус
                if (data.bonus && data.bonus.login_days && data.bonus.login_days > 1) {
                    // бонус за первый день не показываем
                    dailyBonusDialog = ExGods.Components.factory('DIALOG_DAILY_BONUS', {
                        selectedIndex: data.bonus.login_days
                    });
                }
                // разблокируем показ указаний
                if (dailyBonusDialog && !dailyBonusDialog.rendered) {
                    // после отрисовки компонента
                    dailyBonusDialog.on('close', function() {
                        me.app.getController('Direction').setDisabled(false);
                    }, me, {
                        single: true
                    });
                } else {
                    // сразу
                    me.app.getController('Direction').setDisabled(false);
                }
                ExGods.app.getChatConnection().on({
                    ping: me.onPing,
                    scope: me
                });
                me.gameShown = true;
                me.fireEvent('gameshown', me);
            });
        }, 200);
    },
    /**
     * Основной лейаут игры
     */
    setMainLayout: function(fireLayoutChange) {
        var me = this,
            headerCenterCt = me.getHeaderCenterContainer(),
            headerRightCt = me.getHeaderRight(),
            mainMenu = me.getMainMenu(),
            chestsButton = me.getChestsHeaderButton(),
            langSelector = me.getToolsMenuLangSelector(),
            locationHeader, lcoationContainer, userFinance, preloads;
        if (langSelector) {
            langSelector.show();
        }
        locationHeader = Ext.widget('container', {
            id: 'location-header',
            layout: 'fit',
            items: [
                {
                    xtype: 'locationinfo',
                    renderData: {
                        location: me.user.location.get('name'),
                        world: me.user.location.getWorld().get('title')
                    }
                }
            ]
        });
        userFinance = Ext.widget('userfinance', {
            user: me.user
        });
        locationContainer = Ext.widget('locationcontainer', {
            id: 'location-container',
            layout: 'fit',
            user: me.user,
            plugins: [
                'skindeco'
            ]
        });
        preloads = [
            'system-menu',
            'tools-menu',
            'tech-info',
            'quick-slots',
            mainMenu,
            locationContainer,
            ExGods.loaderCt,
            'user-finance'
        ];
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Подгрузка ресурсов перед сменой лейаута');
        ExGods.Resources.loadMulti(preloads, function() {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Ресурсы загружены');
            Ext.getBody().removeCls('body-battle');
            // перерисовываю заголовок
            headerCenterCt.removeAll();
            headerCenterCt.add(locationHeader);
            // в правой части заголовка финансы юзера
            headerRightCt.removeAll();
            headerRightCt.add(userFinance);
            // создаю контейнер локации
            ExGods.Layers.get('location-layer').clear();
            ExGods.Layers.get('location-layer').add(locationContainer);
            if (me.user.isChain()) {
                mainMenu.disableMenu([
                    'inventory'
                ]);
            } else // если юзер в цепочке ему доступен только рюкзак
            {
                mainMenu.enableMenu();
            }
            if (chestsButton) {
                chestsButton.setDisabled(false);
            }
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView Лейаут изменен - Обратный вызов');
            fireLayoutChange();
        });
    },
    /**
     * Боевой лейаут игры
     */
    setBattleLayout: function(fireLayoutChange) {
        var me = this,
            battleViewController = me.app.getController('battle.BattleView'),
            battleAnimController = me.app.getController('battle.Animation'),
            locationController = me.app.getController('Location'),
            headerCenterCt = me.getHeaderCenterContainer(),
            headerRightCt = me.getHeaderRight(),
            mainMenu = me.getMainMenu(),
            chestsButton = me.getChestsHeaderButton(),
            langSelector = me.getToolsMenuLangSelector(),
            battleHeader = Ext.getCmp('battle-header'),
            battleContainer = Ext.getCmp('battle-container'),
            enemyInfo = Ext.getCmp('battle-enemy-info'),
            preloads;
        if (langSelector) {
            langSelector.hide();
        }
        if (battleContainer)  {
            battleContainer.close();
        }
        
        if (battleHeader)  {
            battleHeader.destroy();
        }
        
        if (enemyInfo)  {
            enemyInfo.destroy();
        }
        
        battleHeader = Ext.widget('battle_header', {
            id: 'battle-header',
            autoShow: false
        });
        enemyInfo = Ext.widget('techinfo', {
            id: 'battle-enemy-info',
            enemy: true
        });
        battleContainer = Ext.widget('battlecontainer', {
            autoShow: false
        });
        preloads = [
            'system-menu',
            'tools-menu',
            'tech-info',
            'battle-enemy-info',
            'quick-slots',
            mainMenu,
            battleViewController,
            battleAnimController,
            battleContainer,
            battleHeader
        ];
        ExGods.Resources.loadMulti(preloads, function() {
            me.closeAllWindows();
            Ext.getBody().addCls('body-battle');
            // перерисовываю заголовок
            headerCenterCt.removeAll();
            headerCenterCt.add(battleHeader);
            // в правой части заголовка информация о враге
            headerRightCt.removeAll();
            headerRightCt.add(enemyInfo);
            // создаю контейнер боя
            ExGods.Layers.get('location-layer').clear();
            ExGods.Layers.get('location-layer').add(battleContainer);
            mainMenu.disableMenu();
            if (chestsButton) {
                chestsButton.setDisabled(true);
            }
            fireLayoutChange();
            locationController.unmaskLocation();
        });
    },
    // снимаю маску повешанную при старте загрузки боя (onBattleLoadStart)
    closeAllWindows: function() {
        var me = this;
        me.closeAllFloatWindows();
        ExGods.Layers.get('layer-over1').clear();
        ExGods.Layers.get('layer-over2').clear();
    },
    closeAllFloatWindows: function() {
        var me = this,
            floates = [
                'commondetailswindow',
                'parchmentwindow'
            ];
        Ext.Array.each(floates, function(windowCls) {
            var items = Ext.ComponentQuery.query(windowCls);
            Ext.Array.each(items, function(item) {
                if (item.plugins)  {
                    item.close();
                }
                
            });
        });
    },
    /**
     * @private Клик по кнопке системного меню
     */
    onSystemMenuButtonClick: function(button) {
        var me = this;
        if (button.action && !button.href) {
            ExGods.ClientActions.doAction(button.action, function(res) {
                if (res.error) {
                    /***/
                    me.log('error', err);
                }
            });
        }
    },
    /**
     * @private
     * Обработка обычного сообщения от сервера
     *
     * @param {String} message Текст выводимого сообщения
     */
    onLogMessage: function(message) {
        var me = this,
            win = me.getMessage();
        if (!message)  {
            return;
        }
        
        if (win) {
            clearTimeout(win.closeTimeout);
            win.el.stopAnimation();
            win.destroy();
        }
        win = Ext.widget('message', {
            id: 'message',
            autoShow: true,
            html: message,
            style: {
                background: 'url(' + IMAGE_URL + "/message/popap_messages.png)"
            }
        });
        //renderTo: 'header-center'
        //.center();
        win.el.setOpacity(0).fadeIn({
            opacity: 1,
            easing: 'easeIn',
            duration: 500
        });
        win.closeTimeout = setTimeout(function() {
            if (!win || !win.el)  {
                return;
            }
            
            win.el.stopAnimation();
            win.el.fadeOut({
                opacity: 0,
                easing: 'easeOut',
                duration: 500,
                callback: Ext.Function.bind(win.destroy, win)
            });
        }, 4000);
    },
    doFullscreen: function() {
        var me = this,
            sendFullScreenRequest = function() {
                me.request({
                    url: 'game.pl?cmd=do_full_screen'
                });
            },
            doFullscreen__ = function() {
                if (screenfull && screenfull.enabled) {
                    screenfull.toggle();
                } else if (Ext.browser.is.Safari) {
                    var fullScreenApi = {
                            supportsFullScreen: false,
                            nonNativeSupportsFullScreen: false,
                            isFullScreen: function() {
                                return false;
                            },
                            requestFullScreen: function() {},
                            cancelFullScreen: function() {},
                            fullScreenEventName: '',
                            prefix: ''
                        },
                        browserPrefixes = 'webkit moz o ms khtml'.split(' ');
                    // check for native support
                    if (typeof document.cancelFullScreen != 'undefined') {
                        fullScreenApi.supportsFullScreen = true;
                    } else {
                        // check for fullscreen support by vendor prefix
                        for (var i = 0,
                            il = browserPrefixes.length; i < il; i++) {
                            fullScreenApi.prefix = browserPrefixes[i];
                            if (typeof document[fullScreenApi.prefix + 'CancelFullScreen'] != 'undefined') {
                                fullScreenApi.supportsFullScreen = true;
                                break;
                            }
                        }
                    }
                    // update methods to do something useful
                    if (fullScreenApi.supportsFullScreen) {
                        fullScreenApi.fullScreenEventName = fullScreenApi.prefix + 'fullscreenchange';
                        fullScreenApi.isFullScreen = function() {
                            switch (this.prefix) {
                                case '':
                                    return document.fullScreen;
                                case 'webkit':
                                    return document.webkitIsFullScreen;
                                default:
                                    return document[this.prefix + 'FullScreen'];
                            }
                        };
                        fullScreenApi.requestFullScreen = function(el) {
                            return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();
                        };
                        fullScreenApi.cancelFullScreen = function(el) {
                            return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();
                        };
                    }
                    // export api
                    me.fullScreenApi = fullScreenApi;
                    if (me.fullScreenApi.isFullScreen()) {
                        me.fullScreenApi.cancelFullScreen(document.body);
                    } else {
                        me.fullScreenApi.requestFullScreen(document.body);
                    }
                    var isflscr = me.fullScreenApi.isFullScreen();
                    if (!me.screenfull_SAFARI) {
                        me.screenfull_SAFARI = {};
                    }
                    me.screenfull_SAFARI.isFullscreen = isflscr;
                } else if (Ext.browser.is.IE11) {
                    if (!document.inFullScreen) {
                        document.inFullScreen = false;
                    }
                    function makeFullScreen(divObj) {
                        if (divObj.requestFullscreen) {
                            divObj.requestFullscreen();
                        } else if (divObj.msRequestFullscreen) {
                            document.addEventListener("MSFullscreenError", function(evt) {
                                console.log("full screen error has occured " + evt.target);
                            }, true);
                            divObj.msRequestFullscreen();
                        } else if (divObj.mozRequestFullScreen) {
                            divObj.mozRequestFullScreen();
                        } else if (divObj.webkitRequestFullscreen) {
                            divObj.webkitRequestFullscreen();
                        } else {
                            console.log("Fullscreen API is not supported");
                        }
                        document.inFullScreen = true;
                    }
                    function reset() {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.webkitCancelFullScreen) {
                            document.webkitCancelFullScreen();
                        }
                        document.inFullScreen = false;
                        return;
                    }
                    if (document.inFullScreen && document.inFullScreen == true) {
                        reset(document.body);
                    } else {
                        makeFullScreen(document.body);
                    }
                    screenfull = screenfull || {};
                    screenfull.isFullscreen = document.inFullScreen;
                } else if (Ext.browser.is.IE) {
                    // для старых версий IE (начиная с 10) попробуем развернуть на весь экран обходным путем
                    screenfull = screenfull || {};
                    var wscript = new ActiveXObject("WScript.Shell");
                    if (wscript !== null) {
                        screenfull.isFullscreen = !screenfull.isFullscreen;
                        wscript.SendKeys("{F11}");
                    }
                }
            };
        if ((!screenfull || !screenfull.isFullscreen) || (Ext.browser.is.Safari && (!me.screenfull_SAFARI || !me.screenfull_SAFARI.isFullscreen))) {
            sendFullScreenRequest();
        }
        doFullscreen__();
    },
    onWindow1BeforeClose: function() {
        this.closeAllFloatWindows();
    },
    onWindow2BeforeClose: function() {
        this.closeAllFloatWindows();
    },
    /**
     * @private Обработка клика по кнопке меню
     */
    onMenuButtonClick: function(button) {
        var me = this;
        if (button.action && !button.el.hasCls('x-btn-disabled') && !button.el.hasCls('x-btn-blocked')) {
            ExGods.ClientActions.createAndInvoke({
                src: 'menu',
                actionId: button.action
            }, null, function(err) {
                /***/
                me.log('error', err);
            });
        }
    },
    onPing: function(data) {
        var me = this;
        if (data.validate_key && data.validate_to) {
            me.showLogOutDialog(data);
        }
    },
    showLogOutDialog: function(data) {
        var me = this,
            confirmBtnText = ExGods.ref('message_client|button_logout_confirm'),
            abortBtnText = ExGods.ref('message_client|button_logout_abort'),
            logoutFn = function() {
                if (isSocialApp) {
                    window.location.href = '/logout-social.html';
                } else {
                    window.location.href = '/reg.pl?cmd=exit';
                }
                dialog.destroy();
            },
            abortFn = function() {
                clearInterval(intervalId);
                me.request({
                    url: '/game.pl?cmd=afk_validate&key=' + data.validate_key
                });
                dialog.destroy();
            };
        if (Math.random() > 0.5) {
            var buttons = [
                    {
                        text: confirmBtnText,
                        handler: logoutFn
                    },
                    {
                        text: abortBtnText,
                        handler: abortFn
                    }
                ];
        } else {
            var buttons = [
                    {
                        text: abortBtnText,
                        handler: abortFn
                    },
                    {
                        text: confirmBtnText,
                        handler: logoutFn
                    }
                ];
        }
        var dialog = Ext.widget('logoutdialog', {
                message: ExGods.ref('message_client|before_log_out_message'),
                time_to_end: Number(data.validate_to) + 1,
                buttons: buttons,
                minWidth: 510,
                logOutWindow: true,
                autoShow: false,
                listeners: {
                    close: abortFn
                }
            });
        ExGods.Resources.load(dialog, function() {
            dialog.show();
        });
        var intervalId = setInterval(function() {
                if (data.validate_to >= 1) {
                    dialog.items.items[0].update({
                        time_to_end: data.validate_to--
                    });
                } else {
                    dialog.items.items[0].update({
                        time_to_end: 0
                    });
                    ExGods.app.getChatConnection().ping();
                }
            }, 1000);
    },
    refreshViewportSize: function() {
        var me = this,
            viewportView = me.getViewportView(),
            chatContainer = me.getChatContainer(),
            centerContainer = me.getCenter(),
            headerHeight = 95,
            // высота заголовка
            centerHeight = 430,
            // высота основного окна
            screenHeight = Ext.getBody().parent().getHeight(),
            announceHeight = me.getAnnouncmentsView().getHeight() || me.getAnnouncmentsView().minHeight,
            chatHeight,
            socialCtrl = me.app.getSocialController();
        if (me.user.isChatOn()) {
            chatHeight = Math.min(Math.max(screenHeight - headerHeight - centerHeight, ExGods.ref('constants|chat_min_height').value), ExGods.ref('constants|chat_max_height').value);
            if (centerContainer.isVisible()) {
                chatContainer.setHeight(chatHeight);
            } else {
                chatContainer.setHeight(chatHeight + centerHeight);
            }
        } else {
            chatHeight = 56;
        }
        viewportView.setHeight(Math.max(window.innerHeight, headerHeight + centerHeight + chatHeight + announceHeight));
        // обновляю фрейм окна для социалок
        if (socialCtrl && socialCtrl.initialized) {
            socialCtrl.setSize(viewportView.getWidth(), viewportView.getHeight());
        }
    },
    onChatShow: function() {
        var me = this;
        me.refreshViewportSize();
        Ext.getBody().removeCls('chat-off');
    },
    onChatHide: function() {
        var me = this,
            centerContainer = me.getCenter();
        if (!centerContainer.isVisible()) {
            centerContainer.setVisible(true);
        }
        me.refreshViewportSize();
        Ext.getBody().addCls('chat-off');
    },
    // Свернуть/развернуть чат на весь экран
    toggleChatExpand: function() {
        var me = this,
            centerContainer = me.getCenter();
        centerContainer.setVisible(!centerContainer.isVisible());
        me.refreshViewportSize();
    },
    onCenterShow: function() {
        ExGods.Layers.get('layer-over2').updateLayout();
    },
    getTooltipData: function(type, value) {
        var me = this,
            data;
        value = value.split('|');
        if (value[1] && value[1] != 'use')  {
            return;
        }
        
        if (type == 'item') {
            me.user.slots().each(function(slot) {
                slot.items().each(function(item) {
                    if (item.data.item_id == value[0]) {
                        data = {
                            item: item
                        };
                        if (value[1]) {
                            data.tooltipText = ExGods.getMsgByKey('tooltip_text');
                        }
                    }
                });
            });
        } else if (type == 'proto_item') {
            data = {
                proto: ExGods.app.getItemPrototypesStore().data.getByKey(value[0])
            };
            if (value[1]) {
                data.tooltipText = ExGods.getMsgByKey('tooltip_text');
            }
        } else if (type == 'ingredient') {
            ExGods.ref('ingredients').each(function(key, ingredient) {
                if (key == value[0]) {
                    data = {
                        label: ingredient.label,
                        description: ingredient.params.description,
                        image: IMAGE_URL + ingredient.params.images.img_1
                    };
                    if (value[1]) {
                        data.rows = [
                            {
                                content: ExGods.getMsgByKey('tooltip_text')
                            }
                        ];
                    }
                }
            });
        } else if (type == 'currency') {
            ExGods.ref('user_money').each(function(currency) {
                if (currency.name == value[0]) {
                    data = {
                        label: currency.label,
                        description: ExGods.getMsgByKey('currency_description_' + currency.name),
                        image: currency.image_big
                    };
                    if (value[1]) {
                        data.rows = [
                            {
                                content: ExGods.getMsgByKey('tooltip_text')
                            }
                        ];
                    }
                }
            });
        } else if (type == 'timed') {
            ExGods.ref('user_timed').each(function(name, timed) {
                if (name == value[0]) {
                    data = {
                        label: timed.img.label,
                        description: timed.img.desc,
                        image: IMAGE_URL + timed.img.img2
                    };
                    if (value[1]) {
                        data.rows = [
                            {
                                content: ExGods.getMsgByKey('tooltip_text')
                            }
                        ];
                    }
                }
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.lair.stuff.SkullItem', {
    extend: ExGods.stuff.stuff.Item,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators = [
            ExGods.view.lair.stuff.decorator.Skull
        ];
        return data;
    }
});

/**
 * Добавляет черепа на иконку предмета
 */
Ext.define('ExGods.view.lair.stuff.decorator.Skull', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="exg-stuff-decorator-quantity-counter"><span class="skull"><div></div>x ' + (data.stuff.params.quantity || 1) + '</span></div>';
        }
    }
});

/**
 * Модель этапа логова
 */
Ext.define('ExGods.model.LairStage', {
    extend: Ext.data.Model,
    idProperty: 'number',
    fields: [
        {
            //номер этапа
            name: 'number',
            type: 'int'
        },
        {
            //разрешен ли этап для прохождения
            name: 'allowed',
            type: 'int'
        },
        {
            //описание этапа логова
            name: 'description',
            type: 'string'
        },
        {
            //Object, список картинок, использувемых в отображении этапа логова
            name: 'images',
            type: 'auto'
        },
        {
            //Array, массив наград за прохождение этапа
            name: 'reward',
            type: 'auto'
        },
        {
            //Array, массив с описанием имущества, которое может получить игрок с монстра
            name: 'description_stuff',
            type: 'auto'
        },
        {
            //Array, массив с описанием имущества, которое может получить игрок с босса
            name: 'description_items',
            type: 'auto',
            convert: function(v, r) {
                return Ext.Array.map(v || [], function(item) {
                    return {
                        type: 'skull_item',
                        params: item
                    };
                });
            }
        },
        {
            //Array, массив с описанием имущества, которое требуется для разблокировки логова
            name: 'drop_timeout_stuff',
            type: 'auto'
        },
        {
            //Array, массив с описанием имущества, которое требуется для прохождения логова
            name: 'pay_stuff',
            type: 'auto'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'cooldown',
            type: 'auto'
        },
        {
            name: 'is_boss',
            type: 'int'
        },
        {
            name: 'level',
            type: 'int'
        },
        {
            name: 'message',
            type: 'auto'
        }
    ]
});

Ext.define('ExGods.view.lair.Container', {
    extend: Ext.container.Container,
    alias: 'widget.laircontainer',
    layout: 'absolute',
    plugins: [
        'skindeco'
    ],
    initComponent: function() {
        var me = this,
            comboStoreConfig = [],
            modes = me.service.data.lair.modes,
            lair_id = me.service.data.lair.id,
            title = me.service.data.lair.title,
            key, i;
        var headerTpl = [
                '<div class="lair-title-bg">',
                '<div class="lair-title" style="background-image:url({[this.getTitle(values.title)]})"></div>',
                '</div>',
                '<div class="lair-modes-text" style="background-image: url(' + ExGods.ref('images|lair_images').image['text_level'] + ');"></div>',
                '<div class="lair-selecting">{[this.getModes()]}</div>',
                {
                    getTitle: function(title) {
                        return IMAGE_URL + title;
                    },
                    getModes: function() {
                        var images = ExGods.ref('images|lair_icons').image,
                            j = 1,
                            print = '',
                            sortedModes = [];
                        for (key in modes) {
                            sortedModes.push(Ext.apply(modes[key], {
                                mode: key
                            }));
                        }
                        Ext.Array.sort(sortedModes, function(a, b) {
                            return parseInt(a.order) - parseInt(b.order);
                        });
                        for (i = 0; i < sortedModes.length; i++) {
                            print += '<div class="qh-object lair-mode-icon' + (sortedModes[i].message ? ' disabled' : '') + '" id="lair-mode-' + sortedModes[i].mode + '"' + 'style="background-image:url(' + images['level' + j] + ');margin-right:-' + (8 + ((j != 1) ? 4 : 0)) + 'px" ' + 'data-qtip="' + sortedModes[i].title + '" data-qh_otype="lair_mode" data-qh_oid="' + lair_id + '_' + sortedModes[i].mode + '"></div>';
                            j++;
                        }
                        return print;
                    }
                }
            ];
        me.items = [
            {
                xtype: 'room',
                closeText: me.closeText,
                closeColor: me.closeColor,
                closeCallback: function() {
                    me.fireEvent('close');
                },
                backgroundImage: me.backImg,
                rightPanelX: 245,
                items: [
                    {
                        itemId: 'npcImg',
                        width: 330,
                        height: 410,
                        style: {
                            backgroundImage: "url(" + IMAGE_URL + me.npcImg + ")",
                            zIndex: 10,
                            backgroundSize: "auto 100%",
                            backgroundRepeat: "no-repeat"
                        }
                    },
                    {
                        xtype: 'component',
                        itemId: 'robbery_next',
                        html: '<div class="robbery-next">' + '<div class="info"></div>' + '<div class="timer"></div>' + '</div>',
                        style: {
                            zIndex: 100
                        },
                        hidden: !me.getRobberyNextTime(),
                        listeners: {
                            afterrender: function(view) {
                                if (!view.hidden) {
                                    var interval = setInterval(function() {
                                            if (!view.getEl() || !view.getEl().dom) {
                                                clearInterval(interval);
                                                return;
                                            }
                                            ExGods.helpme.shine(view.getEl(), 'robbery-next-shine', 22, 116, 25).on('click', function(e) {
                                                me.onTurnClick(e, turnEl);
                                            });
                                        }, 5000);
                                }
                            }
                        }
                    },
                    {
                        xtype: 'panel',
                        layout: 'absolute',
                        activeTab: 0,
                        x: 245,
                        y: 15,
                        width: 579,
                        height: 353,
                        plugins: [
                            'skindeco'
                        ],
                        closable: true,
                        bodyStyle: {
                            background: 'url(' + IMAGE_URL + 'lair/blood.png) no-repeat'
                        },
                        items: [
                            {
                                xtype: 'component',
                                tpl: headerTpl,
                                data: {
                                    title: me.titleImg
                                },
                                listeners: {
                                    render: function() {
                                        this.el.on('click', function(e, target) {
                                            this.fireEvent('selectmode', target);
                                        }, this, {
                                            delegate: '.lair-mode-icon'
                                        });
                                    }
                                }
                            },
                            {
                                xtype: 'panel',
                                itemId: 'lairComponent',
                                layout: 'card',
                                y: 55
                            }
                        ],
                        listeners: {
                            beforeclose: {
                                fn: function() {
                                    me.fireEvent('close');
                                    return false;
                                }
                            }
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.down('.robbery-next').on('click', function() {
            Ext.widget('commondetailswindow', {
                itemElement: me.el.down('.robbery-next').dom,
                //name: name,
                data: {
                    label: ExGods.getMsgByKey('robbery_defence_dialog_label'),
                    description: ExGods.getMsgByKey('robbery_defence_dialog_text'),
                    image: IMAGE_URL + ExGods.getMsgByKey('robbery_defence_dialog_img')
                }
            });
        });
        if (me.getRobberyNextTime()) {
            me.updateRobberyNext();
            ExGods.util.Ticker.addListener(me.updateRobberyNext, me);
        }
    },
    updateRobberyNext: function() {
        var me = this,
            time = me.getRobberyNextTime();
        if (!time) {
            me.el.down('.robbery-next').parent().hide();
        } else {
            try {
                me.el.down('.robbery-next .timer').setHTML(ExGods.util.Time.printTime(time / 1000, {
                    format: 'short'
                }));
            } catch (e) {}
            
        }
    },
    getRobberyNextTime: function() {
        var me = this,
            robbery_next = me.service.data.lair.robbery_next ? ExGods.util.Date.normalizeUnixTime(me.service.data.lair.robbery_next) : null,
            time = robbery_next ? Math.max(0, robbery_next - Date.now()) : 0;
        return time;
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateRobberyNext);
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this,
            lair_icons = ExGods.ref('images|lair_icons').image,
            images = [
                IMAGE_URL + me.titleImg,
                IMAGE_URL + me.npcImg,
                IMAGE_URL + 'lair/blood.png'
            ];
        Ext.Object.each(lair_icons, function(k, v) {
            images.push(v);
        });
        var imgs_ref = ExGods.ref('images|lair_images').image;
        for (var it in imgs_ref) {
            images.push(imgs_ref[it]);
        }
        return images;
    }
});

Ext.define('ExGods.view.lair.Panel', {
    extend: Ext.panel.Panel,
    alias: 'widget.lair',
    cls: 'stage-container',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    initComponent: function() {
        var me = this,
            config = me.config,
            store = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.LairStage',
                data: config.stages
            });
        me.store = store;
        me.singleLair = store.getCount() == 1;
        me.items = [
            {
                xtype: 'dataview',
                store: store,
                itemSelector: 'li.stage',
                tpl: [
                    '<ul style="height:150px">',
                    '<tpl for=".">',
                    '<tpl if="xcount == 1">',
                    '<li class="stage single-lair-description">',
                    '<div class="paper paper-tl"></div>',
                    '<div class="paper paper-tm"></div>',
                    '<div class="paper paper-tr"></div>',
                    '<div class="paper paper-mr"></div>',
                    '<div class="paper paper-br"></div>',
                    '<div class="paper paper-bm"></div>',
                    '<div class="paper paper-bl"></div>',
                    '<div class="paper paper-ml"></div>',
                    '<div class="paper paper-bg"></div>',
                    '<div class="single-lair-description-content">',
                    '<div class="desc">{description}</div>',
                    '<div class="lair-reward-items">{[ExGods.stuff.StuffManager.image(values.description_items)]}</div>',
                    '</div>',
                    '</li>',
                    '<tpl else>',
                    '<li class="{[this.setClass(values)]} qh-object" data-qtip="{title}" data-qh_otype="lair" data-qh_oid="' + me.lair_id + '_' + me.itemId + '_{number}" {[this.checkIndex(xindex)]}>',
                    '<div class="stage-bg-{is_boss}"></div>',
                    '<div class="stage-image-{number}"></div>',
                    '<p>{[this.printTimer(values.cooldown,values.number)]}</p>',
                    '<span class="stage-click-enabler"></span>',
                    '</li>',
                    '</tpl>',
                    '</tpl>',
                    '</ul>',
                    {
                        checkIndex: function(index) {
                            var cls = index == 1 ? ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : '';
                            return cls;
                        },
                        getBg: function(background) {
                            return IMAGE_URL + background;
                        },
                        printTimer: function(cd, num) {
                            var text = '',
                                date = new Date(Date.now() + cd * 1000);
                            if (cd > 0) {
                                text = '<span class="pager-text-left"></span>' + '<span class="pager-text-center"></span>' + '<span class="pager-text-right"></span>' + '<span class="pager-text-text">' + ExGods.util.Timers.printTimer('rest', 'lair-stage-cd' + me.lair_id + me.itemId + num, date, {
                                    needNormalized: true,
                                    format: 'threenums'
                                }) + '</span>';
                            }
                            return text;
                        },
                        setClass: function(values) {
                            var cls = [
                                    'stage',
                                    'multiple'
                                ],
                                lvlDelta = parseInt(ExGods.ref('constants|lair_level_delta').value),
                                userLvl = parseInt(ExGods.app.user.getLevel());
                            if (!values.allowed)  {
                                cls.push('disabled');
                            }
                            
                            if (me.user_modes[me.itemId] && parseInt(me.user_modes[me.itemId].finished_stage) < values.number) {
                                cls.push('incomplete');
                            }
                            if (values.level > lvlDelta + userLvl)  {
                                cls.push('high-level');
                            }
                            
                            return cls.join(' ');
                        }
                    }
                ]
            }
        ];
        me.dockedItems = [
            {
                xtype: 'component',
                dock: 'bottom',
                cls: 'stage-info',
                data: {},
                tpl: [
                    '<div class="lair-stage-description">',
                    '<div class="paper paper-tl"></div>',
                    '<div class="paper paper-tm"></div>',
                    '<div class="paper paper-tr"></div>',
                    '<div class="paper paper-mr"></div>',
                    '<div class="paper paper-br"></div>',
                    '<div class="paper paper-bm"></div>',
                    '<div class="paper paper-bl"></div>',
                    '<div class="paper paper-ml"></div>',
                    '<div class="paper paper-bg"></div>',
                    '<tpl if="title">',
                    '<div class="paper-title">',
                    '{[this.getTitleText()]}',
                    '</div>',
                    '</tpl>',
                    '<div class="lair-stage-description-text">',
                    '<tpl if="title">',
                    '{[this.getRewards(values)]}',
                    '<tpl else>',
                    '<p class="lair-hint">{[this.getHint(values)]}</p>',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    //'<div id="enter-lair" data-qh_otype="lair_button_start" data-qh_oid="1" class="  {[this.getBtnCls(values)]}"></div>',
                    '<div class="enter-lair-btn-cnt" id="enter-lair-btn-cnt-' + me.itemId + '"></div>',
                    {
                        // getBtnCls:function(values){
                        //  var cls = 'qh-object ';
                        //  if(values.drop_timeout_stuff && values.cooldown > 0){
                        //      cls += 'lair-reset-btn';
                        //      if(!ExGods.app.getUser().checkStuff(values.drop_timeout_stuff)){
                        //          cls += ' disabled';
                        //      } else {
                        //          cls += ' ';
                        //      }
                        //  }else{
                        //      cls += 'lair-enter-btn';
                        //      if(!values || !values.allowed || values.cooldown > 0){
                        //          cls += ' disabled';
                        //      } else {
                        //          cls += ' ';
                        //      }
                        //  }
                        //  return cls;
                        // },
                        getTitleText: function() {
                            if (me.singleLair) {
                                return ExGods.getMsgByKey('rewards_title_single');
                            } else {
                                return ExGods.getMsgByKey('rewards_title');
                            }
                        },
                        getHint: function(values) {
                            if (me.singleLair && values.no_stages_allowed) {
                                return ExGods.ref('message_client|no_stages_allowed_single');
                            } else if (me.singleLair) {
                                //return ExGods.ref('message_client|lair_hint_single');
                                return this.getRewards(values);
                            } else if (values.no_stages_allowed) {
                                return ExGods.ref('message_client|no_stages_allowed');
                            } else {
                                return ExGods.ref('message_client|lair_hint');
                            }
                        },
                        getRewards: function(stage, itemFlag) {
                            var me = this,
                                stuff = ExGods.helpme.sumStuff(stage.reward || [], stage.description_stuff || []);
                            return '<div class="lair-reward-items">' + ExGods.stuff.StuffManager.image(stuff) + '</div>';
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    // afterRender:function(){
    //  var me = this;
    //  me.callParent(arguments);
    //  me.renderBtn();
    // },
    renderBtn: function() {
        var me = this;
        if (!me.timed)  {
            return;
        }
        
        me.timedtimer = Ext.widget('timedtimer', {
            textbutton: {
                itemId: 'enter-lair'
            },
            qh: {
                'data-qh_otype': 'lair_button_start',
                'data-qh_oid': '1'
            },
            timed: me.timed,
            quantity: 1,
            renderTo: 'enter-lair-btn-cnt-' + me.itemId,
            autoShow: false
        });
        ExGods.Resources.load(me.timedtimer, function() {
            me.timedtimer.show();
        });
    },
    updateDocked: function(data) {
        var me = this,
            fn = function() {
                if (me.timedtimer)  {
                    me.timedtimer.destroy();
                }
                
                me.getDockedComponent(0).update(data);
                me.renderBtn();
            };
        if (me.rendered) {
            fn();
        } else {
            me.on('afterrender', fn, me);
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            var itm = me.store.data.items[i].data;
            for (var j = 0; j < itm.description_stuff.length; j++) {
                stuff_arr.push(itm.description_stuff[j]);
            }
            for (var j = 0; j < itm.description_items.length; j++) {
                stuff_arr.push(itm.description_items[j]);
            }
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [].concat(arr_images)
        };
    }
});

/**
 * Управление логовами.
 */
Ext.define('ExGods.controller.Lair', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: false,
            error: false
        },
        prefix: 'Lair:'
    },
    models: [
        'LairStage'
    ],
    views: [
        'lair.Container',
        'lair.Panel',
        'TimedTimer'
    ],
    refs: [
        {
            /**
         * @method getLairContainer
         * Получет отображение контейнера логова
         * @return {Ext.container.Container}
         */
            ref: 'lairContainer',
            selector: 'laircontainer'
        }
    ],
    init: function(app) {
        var me = this;
        me.control({
            'laircontainer component': {
                selectmode: me.onModeSelect
            },
            'laircontainer': {
                afterrender: me.afterContainerRender
            },
            'lair > dataview': {
                itemclick: me.onStageClick
            },
            'lair': {
                afterrender: me.afterModeRender
            },
            'battleresult': {
                close: me.showLair
            }
        });
        ExGods.stuff.StuffManager.register({
            'skull_item': ExGods.view.lair.stuff.SkullItem
        });
        ExGods.Components.addComponentInitializer('lair', me.initLairComponent, me);
    },
    //флаг, если бой из логова запущен - то true
    isLairBattle: false,
    onModeSelect: function(target) {
        mode = target.id.substr(10);
        if (Ext.get(target).hasCls('disabled'))  {
            return;
        }
        
        Ext.select('.lair-mode-icon').removeCls('selected');
        Ext.get(target).addCls('selected');
        this.changeMode(mode);
    },
    /**
     * Изменения мода логова. Перерисовываю содержимое
     */
    changeMode: function(newMode) {
        var me = this,
            ct = me.getLairContainer(),
            card = ct.down('#lairComponent'),
            cmp = card.down('#' + newMode),
            config = me.service.data.lair.modes[newMode],
            npcImg;
        me.selectedStage = -1;
        if (!cmp) {
            config.width = 550;
            cmp = Ext.widget('lair', {
                config: config,
                lair_id: me.service.data.lair.id,
                timed: me.findTimed(newMode),
                autoShow: false,
                user_modes: me.service.data.lair.user_modes,
                itemId: newMode
            });
            ExGods.helpme.loadProtos(cmp.store.getAt(0).get('description_items'), 'params.id', function() {
                ExGods.Resources.load(cmp, function() {
                    card.add(cmp);
                });
            });
        }
        var allowed = false;
        Ext.Array.each(config.stages, function(stage) {
            if (stage.allowed) {
                allowed = true;
            }
        });
        if (cmp.el) {
            cmp.el.select('li').removeCls('selected');
        }
        me.activeMode = newMode;
        var callback = function() {
                card.getLayout().setActiveItem(cmp);
                cmp.items.getAt(0).refresh();
                if (!cmp.singleLair || !allowed) {
                    cmp.updateDocked({
                        no_stages_allowed: !allowed
                    });
                    cmp.timedtimer.setDisable();
                }
                //дизаблю кнопку, т.к. ни одного этапа еще не выбрано
                /***/
                me.log('Показываю сложность логова');
                // меняю картинку для npc 
                npcImg = ct['npcImg_' + newMode] || ct['npcImg'];
                ct.down('#npcImg').getEl().applyStyles({
                    'background-image': 'url(' + IMAGE_URL + npcImg + ')'
                });
            };
        if (cmp.singleLair) {
            if (cmp.rendered) {
                me.selectStage(cmp, cmp.store.getAt(0), false, callback);
            } else {
                cmp.on('afterrender', me.selectStage.bind(me, cmp, cmp.store.getAt(0), false, callback), me, {
                    single: true
                });
            }
        } else  {
            callback();
        }
        
    },
    /**
     * ищу в стаффе первый таймед на данной сложности логова
     */
    findTimed: function(mode) {
        var me = this,
            stages = me.service.data.lair.modes[mode].stages,
            timed;
        for (var i = 0; i < stages.length; i++) {
            var stuff = stages[i].pay_stuff;
            if (timed)  {
                break;
            }
            
            if (!stuff || !stuff.length)  {
                
                continue;
            }
            
            for (var j = 0; j < stuff.length; j++) {
                if (stuff[j].type == 'timed') {
                    timed = stuff[j].params.id;
                    break;
                }
            }
        }
        return timed;
    },
    afterContainerRender: function(container) {
        var me = this,
            combo = container.down('combo'),
            modes = me.service.data.lair.modes,
            sortedModes = [],
            index = 0,
            key;
        for (key in modes) {
            sortedModes.push(Ext.apply(modes[key], {
                mode: key
            }));
        }
        Ext.Array.sort(sortedModes, function(a, b) {
            return a.order - b.order;
        });
        Ext.each(sortedModes, function(el, i) {
            if (el.allowed != 0) {
                Ext.Array.each(el.stages, function(stage) {
                    if (stage.allowed)  {
                        index = i;
                    }
                    
                });
            }
        });
        newMode = sortedModes[index].mode;
        Ext.select('.lair-mode-icon').item(index).addCls('selected');
        this.changeMode(newMode);
    },
    afterModeRender: function(panel) {
        var me = this,
            store = panel.down('dataview').getStore(),
            lastStage = store.getAt(0),
            i = 0,
            el;
    },
    // store.each(function(record, index){
    //  if(record.get('allowed')){
    //      lastStage = record;
    //      i = index;
    //  }
    // });
    // panel.down('dataview').on('viewready',function(){
    //  if(lastStage){
    //      el = panel.el.query('li')[i];
    //      me.selectStage(panel,lastStage,el);
    //  }
    // });
    /**
     * Событие при клике на стадию логова
     */
    onStageClick: function(dataview, record, el, index, e) {
        var me = this,
            panel = dataview.up('lair');
        me.selectStage(panel, record, el);
    },
    /**
     * если el не придет - значит single lair
     */
    selectStage: function(panel, record, el, callback) {
        var me = this,
            docked = panel.getDockedComponent(0),
            itemRewards = [],
            protos = ExGods.app.getItemPrototypesStore(),
            missedProtos = [],
            _selectStage = function() {
                //if(Ext.get(el).hasCls('selected')) return;
                panel.el.select('li').removeCls('selected');
                if (el)  {
                    Ext.get(el).addCls('selected');
                }
                
                panel.updateDocked(record.data);
                if (callback)  {
                    callback();
                }
                
                var button = panel.timedtimer.textbutton,
                    service = me.service,
                    mode = me.getLairContainer();
                if (record.get('allowed') && record.get('cooldown') <= 0) {
                    panel.timedtimer.setEnable();
                } else {
                    panel.timedtimer.setDisable();
                }
                button.on('click', function() {
                    var fn = function() {
                            me.service.command('lair_start', {
                                id: service.data.lair.id,
                                mode: me.activeMode,
                                stage: record.get('number')
                            }, function() {
                                me.isLairBattle = service.id;
                            });
                        };
                    if (record.get('allowed') && record.get('cooldown') <= 0) {
                        var lvlDelta = parseInt(ExGods.ref('constants|lair_level_delta').value),
                            userLvl = parseInt(ExGods.app.user.getLevel());
                        if (record.get('level') > lvlDelta + userLvl) {
                            Ext.widget('confirmdialog', {
                                title: '',
                                message: new Ext.XTemplate(ExGods.ref('message_client|high_level_lair')).apply(),
                                handler: fn
                            });
                        } else  {
                            fn();
                        }
                        
                    } else if (record.get('drop_timeout_stuff') && record.get('cooldown') > 0) {
                        Ext.widget('confirmdialog', {
                            title: '',
                            message: new Ext.XTemplate(ExGods.ref('message_client|drop_timeout_confirm')).apply({
                                lair: service.data.lair.title,
                                stage: record.get('number'),
                                cooldown: Ext.util.Format.countdown(record.get('cooldown'), {
                                    format: 'threenums'
                                }),
                                cost: record.get('drop_timeout_stuff')
                            }),
                            handler: function() {
                                me.service.command('lair_drop_timeout', {
                                    id: service.data.lair.id,
                                    mode: me.activeMode,
                                    stage: record.get('number')
                                }, function(data) {
                                    if (!data.msg)  {
                                        record.set('cooldown', 0);
                                    }
                                    
                                    var stageEl = Ext.get(panel.down('dataview').getNode(record));
                                    stageEl.removeCls('disabled');
                                    stageEl.addCls('selected');
                                    button.removeCls('disabled');
                                    button.removeCls('lair-reset-btn');
                                    if (!button.hasCls('lair-enter-btn'))  {
                                        button.addCls('lair-enter-btn');
                                    }
                                    
                                });
                            }
                        });
                    }
                });
            };
        me.selectedStage = record.get('number');
        var itemRewards = [];
        if (record.data.reward) {
            itemRewards = itemRewards.concat(Ext.Array.filter(record.data.reward, function(item) {
                return item.type == 'item';
            }));
        }
        if (record.data.description_stuff) {
            itemRewards = itemRewards.concat(Ext.Array.filter(record.data.description_stuff, function(item) {
                return item.type == 'item';
            }));
        }
        // пробегаемся по всем предметам в поисках незагруженных прототипов
        ExGods.util.Helper.maskElement(me.getLairContainer().getEl());
        ExGods.helpme.loadProtos(itemRewards, 'params.id', function() {
            /***/
            me.log('Показываю стадию логова');
            _selectStage();
            me.getLairContainer().getEl().unmask();
        });
    },
    showLair: function() {
        var me = this;
        if (me.isLairBattle && ExGods.app.user.getSetting('reopen_interface') == 1) {
            ExGods.ClientActions.createAndInvoke({
                actionId: me.isLairBattle
            }, null, function(err) {
                /***/
                me.log('error', err);
            });
            me.isLairBattle = false;
        }
    },
    // startService:function(callback, options){
    //  var me = this;      
    //  me.app.ServiceMgr.showServiceComponent(me.service, callback);
    // },
    initLairComponent: function(config, componentId) {
        var me = this,
            cmp;
        if (Ext.getCmp(componentId)) {
            return;
        }
        // запрещаю повторную инициализацию, если уже отрисован
        me.service = config.service;
        Ext.apply(config, {
            style: {
                backgroundImage: "url(" + IMAGE_URL + config.backImg + ")",
                backgroundSize: "100% auto",
                backgroundRepeat: "no-repeat"
            },
            listeners: {
                close: {
                    fn: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            wnd.close();
                        }, {
                            img: config.backImg
                        });
                        return false;
                    },
                    single: true
                }
            }
        });
        /***/
        me.log('Инициализирую компонент логова');
        cmp = Ext.apply({
            xtype: 'laircontainer'
        }, config);
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ],
            getResources: function() {
                return {
                    images: [
                        IMAGE_URL + config.backImg
                    ]
                };
            }
        });
        ExGods.Resources.load(wnd, function() {
            ExGods.app.getController('Location').maskLocation(function() {
                // подгрузка ресурсов
                wnd.show();
                ExGods.app.getController('Location').unmaskLocation();
            }, {
                img: config.backImg
            });
        });
        return wnd;
    }
});

/**
 * Окошко с информацией. Содержет картинку, нзвание, и описание.
 */
Ext.define('ExGods.view.skills.Window', {
    extend: ExGods.view.parchment.Window,
    alias: 'widget.skillwindow',
    cls: 'skill-window',
    padding: '7 10 17',
    initComponent: function() {
        var me = this;
        me.data = me.skill.data;
        me.tpl = [
            '<div class="paper-title">{skill.data.label}</div>',
            '<ul class="skill-params">',
            '<li>',
            '<div class="skill-param-label">' + me.clientConfig.level + '</div>',
            '<div class="skill-param-value">{level}</div>',
            '</li>',
            '<li>',
            '<div class="skill-param-label">' + me.clientConfig.bonus + '</div>',
            '<div class="skill-param-value">{[ExGods.app.applyTpl(values.description)]}</div>',
            '</li>',
            '<tpl if="this.timeIsVisible(values)">',
            '<li>',
            '<tpl if="current && skill.data.progress">',
            '<div class="skill-param-label">' + me.clientConfig.time_left + '</div>',
            '<div class="skill-param-value">{[this.printLeftTime(values)]}</div>',
            '<tpl else>',
            '<div class="skill-param-label">' + me.clientConfig.time_learn + '</div>',
            '<div class="skill-param-value">{[this.printTime(values)]}</div>',
            '</tpl>',
            '</li>',
            '</tpl>',
            '<tpl if="this.costIsVisible(values)">',
            '<li>',
            '<div class="skill-param-label">' + me.clientConfig.learn_cost + '</div>',
            '<div class="skill-param-value">{[this.printStuff(values)]}</div>',
            '</li>',
            '</tpl>',
            '</ul>',
            '<div class="paper-separator"></div>',
            '<div class="paper-title">' + me.clientConfig.condition_title + '</div>',
            '<div class="skill-condition">{skill.data.description2}</div>',
            '<tpl if="current">',
            '<div class="paper-separator"></div>',
            '<div class="skill-comment">{[this.isAnotherLearningSkill(values)]}</div>',
            '<tpl elseif="!complete">',
            '<div class="paper-separator"></div>',
            '<div class="skill-comment">' + me.clientConfig.learn_previous_skill + '</div>',
            '</tpl>',
            {
                printLeftTime: function(values) {
                    var progress = values.skill.data.progress;
                    if (progress.pause) {
                        return ExGods.util.Time.printTime((new Date(progress.end) - new Date(progress.pause)) / 1000 + 1, {
                            format: 'twonums'
                        });
                    } else {
                        return ExGods.util.Timers.printRestTimer('skill-window-timer', progress.end, {
                            needNormalized: true,
                            format: 'twonums'
                        });
                    }
                },
                printTime: function(values) {
                    return ExGods.util.Time.printTime(values.time, {
                        format: 'twonums'
                    });
                },
                printStuff: function(values) {
                    return ExGods.stuff.StuffManager.print(values.stuff);
                },
                isAnotherLearningSkill: function(values) {
                    if (me.other_skill == values.skill)  {
                        return '';
                    }
                    
                    if (me.other_skill && me.other_skill.data.progress.is_ready) {
                        return me.clientConfig.another_ready_comment;
                    } else if (me.other_skill) {
                        return me.clientConfig.another_learning_comment;
                    } else  {
                        return '';
                    }
                    
                },
                costIsVisible: function(values) {
                    return !values.complete && (!values.current || !values.skill.data.progress);
                },
                timeIsVisible: function(values) {
                    return !values.complete && (!values.current || !values.skill.data.progress || !values.skill.data.progress.is_ready);
                }
            }
        ];
        if (me.tooltip) {
            me.closable = false;
            if (me.skill.get('current')) {
                me.buttons = {
                    xtype: 'component',
                    cls: 'textcenter',
                    html: ExGods.getMsgByKey('tooltip_text')
                };
            }
        }
        if (me.buttons && me.buttons.length) {
            me.dockedItems = [
                {
                    xtype: 'toolbar',
                    layout: 'anchor',
                    dock: 'bottom',
                    itemId: 'actions',
                    padding: '4 16',
                    defaults: {
                        anchor: '100%',
                        margin: '2 0',
                        cls: 'no_border'
                    },
                    defaultType: 'textbutton',
                    items: me.buttons
                }
            ];
        }
        delete me.buttons;
        me.callParent(arguments);
    }
});

Ext.define('ExGods.model.Skill', {
    extend: Ext.data.Model,
    idProperty: 'name',
    fields: [
        {
            name: 'can_master',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description2',
            type: 'string'
        },
        {
            name: 'enabled',
            type: 'int'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            name: 'label_img',
            type: 'string'
        },
        {
            name: 'level',
            type: 'int'
        },
        {
            name: 'master',
            type: 'auto'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'progress',
            type: 'auto',
            defaultValue: ''
        },
        {
            name: 'group',
            type: 'string'
        },
        {
            name: 'message',
            type: 'string'
        },
        {
            name: 'levels',
            type: 'auto',
            convert: function(v, r) {
                if (!r.levelsStore) {
                    r.levelsStore = Ext.create('Ext.data.Store', {
                        model: 'ExGods.model.SkillLevel',
                        record: r
                    });
                }
                r.levelsStore.loadRawData(Ext.Array.map(ExGods.ref('skills|' + r.get('name')).data.levels, function(el) {
                    var complete = el.level <= r.get('level'),
                        current = el.level == r.get('level') + 1;
                    return Ext.apply({
                        complete: complete,
                        current: current,
                        skill: r
                    }, el);
                }));
                return r.levelsStore;
            }
        },
        {
            name: 'stats',
            type: 'auto',
            convert: function(v) {
                return Ext.Array.map(v || [], function(el) {
                    return el.stat;
                });
            }
        },
        {
            name: 'order',
            type: 'int'
        }
    ],
    /**
     * вернет true/false действует ли на стат
     */
    affects: function(stat_name) {
        return this.get('stats').indexOf(stat_name) != -1;
    },
    /**
     * вернет картинку заголовка скилла и картинки скиллов по уровням
     */
    getImages: function() {
        var me = this,
            images = [
                IMAGE_URL + me.get('label_img')
            ];
        me.levelsStore.each(function(level) {
            images = images.concat(level.getImages());
        });
        return images;
    }
});

Ext.define('ExGods.model.SkillGroup', {
    extend: Ext.data.Model,
    idProperty: 'label',
    fields: [
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'description',
            mapping: 'params.description',
            type: 'string'
        },
        {
            name: 'image',
            mapping: 'params.image',
            type: 'string'
        },
        {
            name: 'l_order',
            type: 'int'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            name: 'group',
            type: 'string'
        },
        {
            name: 'visible',
            type: 'int'
        },
        {
            name: 'skills',
            type: 'auto',
            convert: function(v, r) {
                return Ext.create('Ext.data.Store', {
                    model: 'ExGods.model.Skill',
                    record: r,
                    sorters: [
                        {
                            property: 'order',
                            direction: 'ASC'
                        }
                    ],
                    data: []
                });
            }
        }
    ],
    /**
     * вернет стор скиллов, если нет фильтра, или коллекцию нефильтрованных скиллов стора
     */
    getSource: function() {
        var me = this,
            store = me.get('skills');
        //если есть getSource - значит стор фильтрованый, и поиск будет осуществляться по всем элементам (source)
        return store.data.getSource() || store;
    },
    /**
     * вернет картинку заголовка таба и картинки скиллов
     */
    getImages: function() {
        var me = this,
            images = [
                IMAGE_URL + me.get('image')
            ];
        me.getSource().each(function(skill) {
            images = images.concat(skill.getImages());
        });
        return images;
    }
});

Ext.define('ExGods.model.SkillLevel', {
    extend: Ext.data.Model,
    idProperty: 'level',
    fields: [
        {
            name: 'level',
            type: 'int'
        },
        {
            name: 'image_b',
            type: 'string'
        },
        {
            name: 'image_r',
            type: 'string'
        },
        {
            name: 'complete',
            type: 'boolean'
        },
        {
            name: 'current',
            type: 'boolean'
        },
        {
            name: 'skill',
            type: 'auto'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description2',
            type: 'string'
        },
        {
            name: 'time',
            type: 'int'
        },
        {
            name: 'stuff',
            type: 'auto'
        }
    ],
    /**
     * вернет картинки уровня скилла
     */
    getImages: function() {
        var me = this;
        return [
            IMAGE_URL + me.get('image_r'),
            IMAGE_URL + me.get('image_b')
        ];
    }
});

/**
 * Табы кошелька
 */
Ext.define('ExGods.view.skills.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.skillstabpanel',
    id: 'skill-tabs',
    tabUi: 'skintext',
    bodyPadding: '0 12 8 5',
    initComponent: function() {
        var me = this;
        me.items = [];
        me.store.each(function(group) {
            var width = 100,
                img = group.get('image');
            if (!!~img.indexOf('equipment_sprite')) {
                width = 120;
            } else if (!!~img.indexOf('group_sprite')) {
                width = 120;
            } else if (!!~img.indexOf('potion_sprite')) {
                width = 195;
            } else if (!!~img.indexOf('mask_sprite')) {
                width = 120;
            }
            me.items.push({
                xtype: 'skillgroup',
                id: 'skill_group_' + group.get('entry'),
                skills: group.get('skills'),
                free_boost: me.free_boost,
                clientConfig: me.clientConfig,
                tabConfig: {
                    icon: IMAGE_URL + img,
                    width: width
                }
            });
        });
        me.plugins = [
            {
                ptype: 'pager',
                marginLeft: -30,
                marginRight: -30,
                top: 190,
                textTop: 395,
                textLeft: 326,
                totalTabs: me.store.getCount()
            }
        ];
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'skills/icon_skills_learning_left.png',
                IMAGE_URL + 'skills/icon_skills_learning_accelerate.png',
                IMAGE_URL + 'mask/arrow.png',
                IMAGE_URL + 'mask/arrow_dis.png',
                IMAGE_URL + 'skills/skills_skin_01.png',
                IMAGE_URL + 'skills/skills_skin_02.png',
                IMAGE_URL + 'skills/skills_skin_03.png',
                IMAGE_URL + 'skills/skills_skin_04.png',
                IMAGE_URL + 'skills/skills_skin_05.png',
                IMAGE_URL + 'skills/skills_skin_06.png',
                IMAGE_URL + 'skills/skills_skin_01_locked.png',
                IMAGE_URL + 'skills/skills_skin_02_locked.png',
                IMAGE_URL + 'skills/skills_skin_03_locked.png',
                IMAGE_URL + 'skills/skills_skin_04_locked.png',
                IMAGE_URL + 'skills/skills_skin_05_locked.png',
                IMAGE_URL + 'skills/skills_skin_06_locked.png',
                IMAGE_URL + 'skills/skills_frame_01.png',
                IMAGE_URL + 'skills/skills_frame_02.png',
                IMAGE_URL + 'skills/skills_frame_03.png',
                IMAGE_URL + 'skills/skills_frame_04.png',
                IMAGE_URL + 'skills/skills_frame_05.png',
                IMAGE_URL + 'skills/skills_frame_06.png',
                IMAGE_URL + 'skills/skills_frame_01_locked.png',
                IMAGE_URL + 'skills/skills_frame_02_locked.png',
                IMAGE_URL + 'skills/skills_frame_03_locked.png',
                IMAGE_URL + 'skills/skills_frame_04_locked.png',
                IMAGE_URL + 'skills/skills_frame_05_locked.png',
                IMAGE_URL + 'skills/skills_frame_06_locked.png'
            ].concat(me.store.getImages())
        };
    }
});

/**
 * Табы кошелька
 */
Ext.define('ExGods.view.skills.Group', {
    extend: Ext.container.Container,
    alias: 'widget.skillgroup',
    padding: '10 17 0',
    initComponent: function() {
        var me = this;
        //задаю стор здесь, т.к. ссылка на оригинальный стор должна остаться
        me.store = me.skills;
        me.callParent(arguments);
        me.onStoreDataChanged();
        me.mon(me.store, 'datachanged', me.onStoreDataChanged, me);
    },
    onStoreDataChanged: function() {
        var me = this,
            current_items = [];
        me.items.each(function(item) {
            current_items.push(item);
        });
        me.store.each(function(skill) {
            me.add(Ext.widget('skill', {
                skill: skill,
                free_boost: me.free_boost,
                clientConfig: me.clientConfig
            }));
        });
        Ext.Array.each(current_items, function(item) {
            me.remove(item);
        });
    },
    bindStore: function(store) {
        var me = this;
        me.mun(me.store, 'datachanged', me.onStoreDataChanged, me);
        me.store = store;
        me.mon(me.store, 'datachanged', me.onStoreDataChanged, me);
        me.onStoreDataChanged();
    },
    bindDefaultStore: function() {
        this.bindStore(this.skills);
    }
});

/**
 * Табы кошелька
 */
Ext.define('ExGods.view.skills.Skill', {
    extend: Ext.view.View,
    alias: 'widget.skill',
    itemSelector: '.skill-level',
    initComponent: function() {
        var me = this;
        me.store = me.skill.get('levels');
        me.tpl = [
            '<div class="skill-label" style="background-image:url(' + IMAGE_URL + me.skill.get('label_img') + ')"></div>',
            '<ul>',
            '<tpl for=".">',
            '<tpl if="level &gt; 1">',
            '<li class="skill-arrow{[this.isActive(values)]}"></li>',
            '</tpl>',
            '<li class="skill-level qh-object skill-level-{level}{[this.isActive(values)]}"{[this.getAttributes(values)]}>',
            '<div class="skill-frame">',
            '<div class="skill-img" style="background-image:url({[IMAGE_URL + this.getImage(values)]})"></div>',
            '<tpl if="complete">',
            '<div class="skill-complete"></div>',
            '<tpl elseif="current && skill.data.progress && !skill.data.progress.is_ready">',
            '{[this.createTimer(values)]}',
            '</tpl>',
            '</div>',
            '<div class="skill-description">',
            '<tpl if="current && skill.data.progress && skill.data.progress.pause">',
            '<span class="skill-timer"></span>{[this.getTime(values)]}',
            '<tpl elseif="current && skill.data.progress && !skill.data.progress.is_ready">',
            '<span class="skill-timer"></span>{[this.getTimer(values)]}',
            '<tpl else>',
            //ExGods.app.applyTpl(me.skill.get('description')),
            '{[ExGods.app.applyTpl(values.description)]}',
            '</tpl>',
            '</div>',
            '<div class="skill-info"></div>',
            '<tpl if="current && skill.data.progress && skill.data.progress.is_ready">',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="itemId">skill_complete_btn</span>',
            '<span role="skill_name">{skill.data.name}</span>',
            '<span role="text">',
            me.clientConfig.ready_btn,
            '</span>',
            '<span role="qh:object">{[this.getQuestHelperInfo(values)]}</span>',
            '<span role="cls">x-btn-txt-green qh-object</span>',
            '</div>',
            '<tpl elseif="current && skill.data.progress && !skill.data.progress.pause && this.canBoost()">',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="itemId">skill_boost_btn</span>',
            '<span role="skill_name">{skill.data.name}</span>',
            '<span role="text">',
            '<span class="skill-boost-icon"></span>',
            '{[this.printBoostStuff(values)]}',
            '</span>',
            '<span role="qh:object">{[this.getQuestHelperInfo(values)]}</span>',
            '<span role="cls">x-btn-txt-green skill-boost-btn qh-object</span>',
            '</div>',
            '</tpl>',
            '</li>',
            '</tpl>',
            '</ul>',
            '<div class="skill-separator"></div>',
            {
                isActive: function(values) {
                    return (values.complete || values.current) ? '' : '-locked locked';
                },
                getImage: function(values) {
                    return (values.complete || (values.current && values.skill.data.progress)) ? values.image_r : values.image_b;
                },
                getTimer: function(values) {
                    return ExGods.util.Timers.printRestTimer('skill-timer', values.skill.data.progress.end, {
                        needNormalized: true,
                        format: 'twonums'
                    });
                },
                getTime: function(values) {
                    var progress = values.skill.data.progress;
                    return ExGods.util.Time.printTime((new Date(progress.end) - new Date(progress.pause)) / 1000 + 1, {
                        format: 'twonums'
                    });
                },
                canBoost: function() {
                    return me.free_boost || me.skill.get('progress').stuff_boost_complete;
                },
                printBoostStuff: function(values) {
                    var progress = values.skill.data.progress;
                    if (me.free_boost || Ext.isEmpty(progress.stuff_boost_complete)) {
                        return ExGods.getMsgByKey('skills_free_pay_text');
                    } else {
                        return ExGods.stuff.StuffManager.print(progress.stuff_boost_complete);
                    }
                },
                getAttributes: function(values) {
                    return values.current && (!values.skill.data.progress || !values.skill.data.progress.is_ready) ? ' data-qh_otype="skill_interface" data-qh_oid="' + values.skill.data.name + '" data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : '';
                },
                getQuestHelperInfo: function(values) {
                    return JSON.stringify({
                        'data-qh_otype': 'skill_interface_boost_complete',
                        'data-qh_oid': values.skill.data.name,
                        'data-qh_opts': '{"cls":"flip-h"}'
                    });
                },
                createTimer: function(values) {
                    var progress = values.skill.data.progress,
                        progress_end, progress_start, progress_pause;
                    if (progress.end)  {
                        progress_end = ExGods.util.Date.normalizeServerDateTime(progress.end);
                    }
                    
                    if (progress.start)  {
                        progress_start = ExGods.util.Date.normalizeServerDateTime(progress.start);
                    }
                    
                    if (progress.pause)  {
                        progress_pause = ExGods.util.Date.normalizeServerDateTime(progress.pause);
                    }
                    
                    return ExGods.util.Timers.printSquareTimer({
                        end: progress_end,
                        start: progress_start,
                        pause: progress_pause
                    });
                }
            }
        ];
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.on({
            beforerefresh: function() {
                ExGods.util.Helper.destroyComponents(me.el);
            },
            refresh: function() {
                ExGods.util.Helper.renderComponents(me.el, me);
            }
        });
        me.callParent(arguments);
    },
    onBeforeDestroy: function() {
        var me = this;
        me.clearListeners();
        ExGods.util.Helper.destroyComponents(me.el);
        me.callParent(arguments);
    }
});

/**
 * Управление скиллами
 */
Ext.define('ExGods.controller.Skills', {
    extend: ExGodsCore.controller.Base,
    models: [
        'SkillGroup',
        'SkillLevel',
        'Skill'
    ],
    views: [
        'skills.TabPanel',
        'skills.Group',
        'skills.Skill',
        'skills.Window'
    ],
    refs: [
        {
            /**
         * @method getSkillsButton
         */
            ref: 'skillsButton',
            selector: '#mainmenu-combos-and-features-button'
        },
        {
            /**
         * @method getSkillTabs
         */
            ref: 'skillTabs',
            selector: 'skillstabpanel'
        },
        {
            /**
         * @method getSearchInput
         */
            ref: 'searchInput',
            selector: '#skill-text-search'
        }
    ],
    //при фильтрации сюда записываю состояние пейджера до фильтрации
    pager_original_state: {},
    init: function() {
        var me = this,
            user = me.getUser();
        me.service = ExGods.Services.get('skills');
        me.service.on('update', me.onServiceUpdate, me);
        me.skillsStore = me.app.getSkillsStore();
        me.skillsStore.loadRawData(ExGods.ref('skill_groups'));
        //хранилище всех скиллов, используется для фильтрации по имени
        me.allSkillsStore = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.Skill'
        });
        me.app.getViewportController().on('gameshown', me.onServiceUpdate, me);
        me.control({
            'skillstabpanel': {
                next: me.openNextPage,
                prev: me.openPrevPage,
                tabchange: me.onTabChange,
                beforetabchange: me.onBeforeTabChange,
                scope: me
            },
            'skill': {
                itemclick: me.onSkillClick,
                itemmouseenter: me.onSkillOver,
                itemmouseleave: me.onSkillOut,
                scope: me
            },
            '#skill_complete_btn': {
                click: me.onSkillCompleteBtnClick,
                scope: me
            },
            '#skill_boost_btn': {
                click: me.onSkillBoostBtnClick,
                scope: me
            }
        });
        ExGods.Components.addComponentInitializer('skills', me.initSkillsComponent, me);
        me.app.chatcn.on({
            command_refresh_skill_service: me.service.update,
            scope: me
        });
    },
    onServiceUpdate: function() {
        var me = this,
            cmp = Ext.getCmp('SKILLS');
        me.skillsStore.each(function(group) {
            group.get('skills').loadRawData(Ext.Array.findBy(me.service.data.skill_groups, function(el) {
                return el.label == group.get('label');
            }).skills);
        });
        me.allSkillsStore.loadRecords(me.skillsStore.getAll());
        me.startMenuTimer();
        //в целом бесполезно что-то тут делать, если компонент не показан. При открытии компонента сервис будет перезапрошен.
        if (!cmp)  {
            return;
        }
        
        if (me.service.data.free_boost) {
            if (cmp)  {
                cmp.free_boost = true;
            }
            
            me.free_boost = true;
        } else {
            if (cmp)  {
                cmp.free_boost = false;
            }
            
            me.free_boost = false;
        }
        me.setPage();
    },
    onBeforeTabChange: function(tabpanel, newTab, oldTab) {
        var me = this,
            textfield = me.getSearchInput();
        if (!textfield)  {
            return;
        }
        
        textfield.suspendEvents();
        textfield.setValue('');
        textfield.resumeEvents();
        me.filtered = false;
        oldTab.bindDefaultStore();
        Ext.apply(tabpanel.pager, me.pager_original_state);
        me.pager_original_state = {};
    },
    onTabChange: function(tabpanel, newTab, oldTab) {
        tabpanel.pager.currentTab = tabpanel.items.indexOf(newTab);
        this.setPageInCurrentTab(1);
    },
    openNextPage: function(pager) {
        var me = this;
        me.setPage(pager.current);
    },
    openPrevPage: function(pager) {
        var me = this;
        me.setPage(pager.current);
    },
    setPage: function(pageIndex) {
        var me = this,
            tabs = me.getSkillTabs();
        if (!tabs)  {
            return;
        }
        
        var pager = tabs.pager,
            store = tabs.getActiveTab().store;
        me.closeTips();
        if (!pageIndex)  {
            pageIndex = pager.current;
        }
        
        store.removeFilter('pager', true);
        if (me.filtered) {
            if (pageIndex < 1)  {
                return;
            }
            
            if (pageIndex * 2 > store.getCount() + 1)  {
                return;
            }
            
        } else {
            if (pageIndex < 1 && pager.currentTab <= 0) {
                return false;
            } else if (pageIndex < 1) {
                store = tabs.setActiveTab(pager.currentTab - 1).store;
                store.removeFilter('pager', true);
                pageIndex = Math.ceil(store.getCount() / 2) || 1;
            } else if (pageIndex * 2 > store.getCount() + 1 && tabs.items.getCount() <= pager.currentTab + 1) {
                return false;
            } else if (pageIndex * 2 > store.getCount() + 1) {
                store = tabs.setActiveTab(pager.currentTab + 1).store;
                store.removeFilter('pager', true);
                pageIndex = 1;
            }
        }
        pager.total = Math.ceil(store.getCount() / 2);
        pager.current = pageIndex;
        store.addFilter(Ext.util.Filter({
            filterFn: function(rec) {
                var page = Math.floor(store.indexOf(rec) / 2) + 1;
                return pageIndex == page;
            },
            id: 'pager'
        }));
        pager.refresh();
    },
    setPageInCurrentTab: function(pageIndex) {
        var me = this,
            tabs = me.getSkillTabs(),
            pager = tabs.pager,
            store = tabs.getActiveTab().store;
        me.closeTips();
        if (!pageIndex)  {
            pageIndex = pager.current;
        }
        
        store.removeFilter('pager', true);
        pager.total = Math.ceil(store.getCount() / 2);
        pager.current = pageIndex;
        store.addFilter(Ext.util.Filter({
            filterFn: function(rec) {
                var page = Math.floor(store.indexOf(rec) / 2) + 1;
                return pageIndex == page;
            },
            id: 'pager'
        }));
        pager.refresh();
    },
    onSkillBoostBtnClick: function(btn) {
        var me = this,
            skill = me.skillsStore.getSkillByName(btn.skill_name);
        if (skill) {
            me.closeTips();
            me.boost(skill);
        }
    },
    onSkillCompleteBtnClick: function(btn) {
        var me = this,
            skill = me.skillsStore.getSkillByName(btn.skill_name);
        if (skill) {
            me.closeTips();
            me.complete(skill);
        }
    },
    onSkillClick: function(view, record, el, index, event) {
        var me = this,
            buttons = [],
            target = Ext.fly(event.target),
            current_learning_skill = me.skillsStore.getLearningSkill();
        //если кнопка - значит обрабатываем клик по кнопке и все
        if (target.hasCls('.x-btn') || target.up('.x-btn'))  {
            return;
        }
        
        if (record.get('current')) {
            var skill = record.get('skill'),
                progress = skill.get('progress'),
                master = skill.get('master'),
                name = skill.get('name'),
                learning = Boolean(current_learning_skill),
                boost_btn_cfg;
            if (current_learning_skill && current_learning_skill.data.progress.is_ready) {
                boost_btn_cfg = {
                    text: me.clientConfig.ready_other_btn,
                    cls: 'no_border x-btn-txt-green',
                    handler: function() {
                        if (me.skillWindow)  {
                            me.skillWindow.close();
                        }
                        
                        me.complete(current_learning_skill);
                    }
                };
            } else if (current_learning_skill) {
                var stuff = current_learning_skill.data.progress.stuff_boost_complete;
                boost_btn_cfg = {
                    text: (me.free_boost || Ext.isEmpty(stuff)) ? me.clientConfig.boost_btn_free : '<span class="skill-boost-icon"></span>' + ExGods.stuff.StuffManager.print(stuff),
                    cls: 'no_border x-btn-txt-green',
                    handler: function() {
                        if (me.skillWindow)  {
                            me.skillWindow.close();
                        }
                        
                        me.boost(current_learning_skill);
                    }
                };
            }
            if (progress) {
                if (progress.pause) {
                    if (learning) {
                        buttons.push(boost_btn_cfg);
                    } else {
                        buttons.push({
                            text: me.clientConfig.continue_btn,
                            disabled: learning,
                            handler: function() {
                                if (me.skillWindow)  {
                                    me.skillWindow.close();
                                }
                                
                                me.service.command('skills_unpause', {
                                    name: name
                                }, function(response) {
                                    me.afterResponse(response);
                                });
                            }
                        });
                    }
                } else if (progress.is_ready) {
                    buttons.push({
                        text: me.clientConfig.ready_btn,
                        cls: 'no_border x-btn-txt-green',
                        handler: function() {
                            if (me.skillWindow)  {
                                me.skillWindow.close();
                            }
                            
                            me.complete(skill);
                        }
                    });
                } else {
                    buttons.push({
                        text: me.clientConfig.pause_btn,
                        handler: function() {
                            if (me.skillWindow)  {
                                me.skillWindow.close();
                            }
                            
                            me.service.command('skills_pause', {
                                name: name
                            }, function(response) {
                                me.afterResponse(response);
                            });
                        }
                    });
                }
            } else if (master.enabled) {
                if (learning) {
                    buttons.push(boost_btn_cfg);
                } else {
                    buttons.push({
                        text: me.clientConfig.learn_btn,
                        disabled: learning,
                        handler: function() {
                            me.master(skill);
                        },
                        cls: 'qh-object no_border',
                        qh: {
                            'data-qh_otype': 'skill_interface',
                            'data-qh_oid': name
                        }
                    });
                }
            }
        }
        if (me.skillWindow)  {
            me.skillWindow.close();
        }
        
        el = Ext.fly(el);
        el.set({
            'data-qh_oid': 0
        });
        me.skillWindow = Ext.widget('skillwindow', {
            itemElement: el,
            skill: record,
            clientConfig: me.clientConfig,
            free_boost: me.free_boost,
            buttons: buttons,
            other_skill: current_learning_skill,
            listeners: {
                close: function() {
                    me.skillWindow = false;
                    if (el) {
                        el.set({
                            'data-qh_oid': record.get('skill').get('name')
                        });
                    }
                }
            }
        });
    },
    onSkillOver: function(view, record, el, index, event) {
        var me = this;
        if (me.skillWindow)  {
            return;
        }
        
        me.skillTip = Ext.widget('skillwindow', {
            itemElement: el,
            skill: record,
            clientConfig: me.clientConfig,
            free_boost: me.free_boost,
            tooltip: true,
            listeners: {
                close: function() {
                    me.skillTip = false;
                }
            }
        });
    },
    onSkillOut: function(view, record, el, index, event) {
        var me = this;
        if (me.skillTip) {
            me.skillTip.close();
        }
    },
    onSearch: Ext.Function.createBuffered(function(textfield, value, previous) {
        var me = this,
            tabs = me.getSkillTabs(),
            tab = tabs.getActiveTab(),
            pager = tabs.pager,
            escapeSpecialChars = function(text) {
                return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            };
        if (!value) {
            me.filtered = false;
            tab.bindDefaultStore();
            Ext.apply(pager, me.pager_original_state);
            me.pager_original_state = {};
            me.setPage();
            return;
        }
        me.filtered = true;
        tab.bindStore(me.allSkillsStore);
        if (Ext.Object.isEmpty(me.pager_original_state)) {
            me.pager_original_state = {
                current: pager.current,
                total: pager.total,
                currentTab: pager.currentTab,
                totalTabs: pager.totalTabs
            };
        }
        value = new RegExp('^.*' + escapeSpecialChars(value) + '.*$', 'i');
        me.allSkillsStore.clearFilter(true);
        me.allSkillsStore.filterBy(function(record) {
            return value.test(record.get('label'));
        });
        pager.currentTab = 0;
        pager.totalTabs = 0;
        pager.current = 1;
        me.setPage();
    }, 200),
    onCheckboxChange: function(field) {
        var me = this,
            values = [],
            all_checked = true;
        Ext.Array.each(field.up().up().query('checkboxfield'), function(checkBox) {
            if (checkBox.getValue()) {
                values.push(checkBox.stat_name);
            } else  {
                all_checked = false;
            }
            
        });
        me.skillsStore.each(function(group) {
            var store = group.get('skills');
            store.removeFilter('stats');
            if (!all_checked) {
                store.addFilter(Ext.util.Filter({
                    filterFn: function(rec) {
                        var i = values.length;
                        while (i--) {
                            if (rec.affects(values[i]))  {
                                return true;
                            }
                            
                        }
                    },
                    id: 'stats'
                }));
            }
        });
        me.setPageInCurrentTab(1);
    },
    closeTips: function() {
        var me = this;
        if (me.skillWindow)  {
            me.skillWindow.close();
        }
        
        if (me.skillTip)  {
            me.skillTip.close();
        }
        
    },
    boost: function(skill) {
        var me = this,
            progress = skill.get('progress'),
            message = ExGods.app.applyTpl(ExGods.ref('message_client|skills_burst_complete_message'), {
                burst_time: ExGods.util.Time.printTime((progress.time + 1) * ExGods.ref('constants|skill_boost_rate').value, {
                    format: 'detailed'
                }),
                level: skill.get('level'),
                next_level: skill.get('level') + 1,
                name: skill.get('label'),
                stuff: (me.free_boost || Ext.isEmpty(progress.stuff_boost_complete)) ? ExGods.getMsgByKey('skills_free_pay_text') : Ext.String.format(ExGods.getMsgByKey("skills_boost_pay"), ExGods.stuff.StuffManager.print(progress.stuff_boost_complete))
            });
        Ext.widget('confirmdialog', {
            message: message,
            handler: function() {
                var end = ExGods.util.Date.normalizeServerDateTime(progress.end),
                    time = new Date();
                if (end <= time)  {
                    return;
                }
                
                me.service.command('skills_boost_complete', {
                    name: skill.get('name')
                }, function(response) {
                    me.afterResponse(response);
                });
            }
        });
    },
    complete: function(skill) {
        var me = this;
        me.service.command('skills_complete', {
            name: skill.get('name')
        }, function(response) {
            me.afterResponse(response);
        });
    },
    master: function(skill) {
        var me = this,
            master = skill.get('master'),
            message = ExGods.app.applyTpl(ExGods.getMsgByKey('skills_learn_cost_message'), {
                time: ExGods.util.Time.printTime(master.time, {
                    format: 'detailed'
                }),
                level: skill.get('level'),
                next_level: skill.get('level') + 1,
                name: skill.get('label'),
                stuff: ExGods.stuff.StuffManager.print(master.stuff)
            });
        Ext.widget('confirmdialog', {
            message: message,
            handler: function() {
                me.service.command('skills_master', {
                    name: skill.get('name')
                }, function(response) {
                    me.afterResponse(response);
                });
            }
        });
    },
    afterResponse: function(response) {
        var me = this;
        if (response.success && response.skill_groups) {
            me.service.data.skill_groups = response.skill_groups;
            me.onServiceUpdate();
        }
    },
    /**
     * @private
     * Запускает таймер до начала боя (отображается на пункте "Умения" основного меню)
     */
    startMenuTimer: function(view) {
        var me = this,
            skill = me.skillsStore.getLearningSkill(),
            menu_btn = me.getSkillsButton(),
            timer_id = 'skill-timer';
        ExGods.util.Helper.stopMenuTimer(timer_id);
        if (!menu_btn)  {
            return;
        }
        
        if (!skill) {
            return menu_btn.reset();
        }
        var progress = skill.get('progress'),
            end_time = progress.end,
            menu_id = menu_btn.id;
        if (progress.is_ready) {
            return me.updateMenuBtnCount();
        } else {
            menu_btn.reset();
        }
        ExGods.util.Helper.startMenuTimer(menu_id, timer_id, end_time, function() {
            me.learningSkillComplete();
            ExGods.util.Helper.stopMenuTimer(timer_id);
        });
    },
    learningSkillComplete: function() {
        var me = this,
            skill = me.skillsStore.getLearningSkill(),
            progress = skill.get('progress');
        progress.is_ready = 1;
        progress.can_boost = 0;
        progress.can_pause = 0;
        skill.set('progress', progress);
        me.setPage();
        me.updateMenuBtnCount();
    },
    updateMenuBtnCount: function() {
        var me = this;
        me.getSkillsButton().addCount(1);
    },
    initSkillsComponent: function(config) {
        var me = this,
            wnd,
            stats = [];
        //компонент уже грузится
        if (me.initializing_component)  {
            return;
        }
        
        ExGods.app.block();
        me.initializing_component = true;
        me.clientConfig = config;
        Ext.Array.each(me.skillsStore.getAll(), function(record) {
            stats = stats.concat(record.get('stats'));
        });
        stats = Ext.Array.unique(stats);
        stats = Ext.Array.map(stats, function(name) {
            var ref = ExGods.ref('user_stat|' + name);
            if (ref) {
                return {
                    boxLabel: ExGods.printStat(name),
                    stat_name: name
                };
            }
        });
        stats = Ext.Array.clean(stats);
        wnd = Ext.widget('window2', {
            id: 'SKILLS',
            layout: 'absolute',
            items: [
                {
                    xtype: 'skillstabpanel',
                    store: me.skillsStore,
                    free_boost: me.free_boost,
                    clientConfig: config
                },
                {
                    xtype: 'form',
                    x: 347,
                    y: 8,
                    width: 400,
                    height: 30,
                    tbar: {
                        xtype: 'panel',
                        bodyCls: 'skills-checkbox-container',
                        defaults: {
                            xtype: 'checkboxfield',
                            checked: true,
                            listeners: {
                                change: me.onCheckboxChange,
                                scope: me
                            }
                        },
                        items: stats,
                        layout: {
                            type: 'hbox',
                            align: 'right',
                            pack: 'end'
                        }
                    }
                }
            ],
            /*{
                x: 585,
                y: 9,
                width: 152,
                height: 30,
                xtype: 'textfield',
                emptyText: me.clientConfig.search_empty_text,
                id: 'skill-text-search',
                cls: 'text-search-input',
                listeners: {
                    change: me.onSearch,
                    scope: me
                },
                value: ''
            }*/
            autoShow: false,
            listeners: {
                close: function() {
                    me.filtered = false;
                    me.pager_original_state = {};
                    me.skillsStore.each(function(group) {
                        group.get('skills').clearFilter(true);
                    });
                }
            }
        });
        me.service.update(null, function() {
            ExGods.Resources.load(wnd, function() {
                var learning = me.skillsStore.getLearningSkill(),
                    group = me.skillsStore.getLearningGroup(),
                    tabs = me.getSkillTabs();
                ExGods.app.unblock();
                me.initializing_component = false;
                //значит окно уже закрылось пока грузилось
                if (!tabs)  {
                    return;
                }
                
                if (learning) {
                    tabs.setActiveTab('skill_group_' + group.get('entry'));
                    var store = group.get('skills');
                    store.removeFilter('pager');
                    me.setPage(Math.floor(store.indexOf(learning) / 2) + 1);
                } else {
                    me.setPage(1);
                }
                wnd.show();
            });
        });
        return wnd;
    }
});

/**
 * Класс имущества источников для кузницы

    Формат имущества:
    
        type: 'fucina_source',
        params: {
            stuff: <Object>,
        }
        sourceModel: <Object>

 */
Ext.define('ExGods.view.fucina.stuff.FucinaSource', {
    extend: ExGods.stuff.Composite,
    dblclickAction: '',
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators = data.decorators || [];
        if (me.stuff.sourceModel.get('selected')) {
            me.dblclickAction = 'putoff';
        } else {
            me.dblclickAction = 'put';
            me.replaceQuantityDecorator(data.decorators);
        }
        if (me.stuff.sourceModel.get('invalid')) {
            data.decorators.push(ExGods.stuff.decorator.Disabled);
        }
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        if (data.itemModel && data.itemModel.data.clothed) {
            Ext.Array.insert(data.blocks, 1, [
                ExGods.view.fucina.stuff.block.ClothedTextSource
            ]);
        }
        if (me.stuff.sourceModel.get('selected') && me.wrappedStuff.type == 'iteminstance') {
            me.replaceItemStatsBlock(data.blocks);
        }
        return Ext.apply(data, {
            buttons: [
                {
                    text: ExGods.getMsgByKey('fucina_puton'),
                    action: 'put',
                    hidden: me.stuff.sourceModel.get('selected')
                },
                {
                    text: ExGods.getMsgByKey('fucina_putoff'),
                    action: 'putoff',
                    hidden: !me.stuff.sourceModel.get('selected')
                }
            ]
        });
    },
    /**
     * Заменяет стандартный декоратор кол-ва
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.fucina.stuff.decorator.SourceQuantity);
    },
    /**
     * Заменяет стандартный блок статов со сравнением на блок без сравнения
     */
    replaceItemStatsBlock: function(blocks) {
        var index = blocks.indexOf(ExGods.stuff.block.item.Stats2);
        Ext.Array.replace(blocks, index, 1, [
            ExGods.view.fucina.stuff.block.EmptyStats2
        ]);
    }
});

/**
 * Класс имущества ресурса ковки (отображается в слотах требуемых ресурсов)

    Формат имущества:
    
        type: 'fucina_resource',
        params: {
            stuff: <Object>,            
        },
        resultInfo: <Object> Данные предполагаемого результата ковки (в случае Переплавки, например хранит диапазон min-max результата)

 */
Ext.define('ExGods.view.fucina.stuff.FucinaResource', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.resultInfo = me.stuff.resultInfo;
        // добавляю Disabled декоратор
        if (me.wrappedStuff.type == 'currency') {
            if (ExGods.app.user.get('money')[me.wrappedStuff.params.id] < me.wrappedStuff.params.quantity) {
                data.decorators.push(ExGods.stuff.decorator.Disabled);
            }
        } else if (me.wrappedStuff.type == 'item') {
            if (ExGods.app.user.slots().getItemCount(me.wrappedStuff.params.id) < me.wrappedStuff.params.quantity) {
                data.decorators.push(ExGods.stuff.decorator.Disabled);
            }
        } else if (me.wrappedStuff.type == 'ingredients') {
            if (ExGods.app.user.getIngredientCountByName(me.wrappedStuff.params.id) < me.wrappedStuff.params.quantity) {
                data.decorators.push(ExGods.stuff.decorator.Disabled);
            }
        }
        // заменяю стандартный декоратор кол-ва 
        me.replaceQuantityDecorator(data.decorators);
        return data;
    },
    /**
     * Заменяет стандартный декоратор кол-ва
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.fucina.stuff.decorator.RequiredQuantity);
    }
});

/**
 * Класс имущества прогнозируемого результата

    Формат имущества:
    
        type: 'fucina_prognoz',
        fucinaType: <String>
        sourceModel: <Object>
        params: {
            stuff: <Object>,
        },

 */
Ext.define('ExGods.view.fucina.stuff.FucinaPrognoz', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        if (me.stuff.sourceModel.get('selected') && me.stuff.sourceModel.get('invalid')) {
            data.decorators.push(ExGods.stuff.decorator.Disabled);
        }
        if (me.wrappedStuff.type == 'iteminstance' && me.stuff.fucinaType == 'upgrade') {
            me.replaceItemGradeDecorator(data.decorators);
        }
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        data.sourceModel = me.stuff.sourceModel;
        me.replaceItemStats1Block(data.blocks);
        me.replaceItemStats2Block(data.blocks);
        if (me.wrappedStuff.type == 'iteminstance') {
            if (me.stuff.fucinaType == 'upgrade') {
                me.replaceItemGradeDecorator(data.decorators);
            } else if (me.stuff.fucinaType == 'enchant') {
                me.replaceFeaturesBlock(data.blocks);
            } else if (me.stuff.fucinaType == 'transmutation') {
                Ext.Array.insert(data.blocks, 1, [
                    ExGods.stuff.block.item.Description
                ]);
            }
        }
        return data;
    },
    /**
     * Заменяет стандартный декоратор уровня грейда на добавляющий +1 звезду
     */
    replaceItemGradeDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.ItemGrade);
        decorators.push(ExGods.view.fucina.stuff.decorator.ItemGradePrognoz);
    },
    /**
     * Заменяет стандартный блок статов (прочность, ..) предмета
     */
    replaceItemStats1Block: function(blocks) {
        var me = this,
            index = blocks.indexOf(ExGods.stuff.block.item.Stats1),
            fucinaType = me.stuff.fucinaType;
        if (fucinaType == 'transmutation') {
            Ext.Array.replace(blocks, index, 1, [
                ExGods.view.fucina.stuff.block.TransmuteStats1Prognoz
            ]);
        }
    },
    /**
     * Заменяет стандартный блок статов (урон, ..) предмета
     */
    replaceItemStats2Block: function(blocks) {
        var me = this,
            index = blocks.indexOf(ExGods.stuff.block.item.Stats2),
            fucinaType = me.stuff.fucinaType;
        if (fucinaType == 'upgrade') {
            Ext.Array.replace(blocks, index, 1, [
                ExGods.view.fucina.stuff.block.Stats2Prognoz
            ]);
        } else if (fucinaType == 'enchant') {
            Ext.Array.replace(blocks, index, 1, [
                ExGods.view.fucina.stuff.block.EmptyStats2
            ]);
        } else if (fucinaType == 'transmutation') {
            Ext.Array.replace(blocks, index, 1, [
                ExGods.view.fucina.stuff.block.TransmuteStats2Prognoz
            ]);
        }
    },
    /**
     * Заменяет стандартный блок фич, на блок показывающий "Случайную" фичу
     */
    replaceFeaturesBlock: function(blocks) {
        var index = blocks.indexOf(ExGods.stuff.block.item.Features);
        Ext.Array.replace(blocks, index, 1, [
            ExGods.view.fucina.stuff.block.FeaturesPrognoz
        ]);
    }
});

/**
 * Класс имущества результата ковки

    Формат имущества:
    
        type: 'fucina_result',
        fucinaType: <String>
        params: {
            stuff: <Object>,
        }
        workData: <Object> // Данные кузницы для этого результата ({result: <Object>, was_result: <Object>, work: <Object>, etc })

 */
Ext.define('ExGods.view.fucina.stuff.FucinaResult', {
    extend: ExGods.stuff.Composite,
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.stuff.decorator.Quantity);
        if (me.stuff.fucinaType == 'transmutation') {
            me.replaceItemStats1Block(data.blocks);
        }
        if (me.wrappedStuff.type == 'iteminstance') {
            me.replaceItemStats2Block(data.blocks);
        }
        data.workData = me.stuff.workData;
        // пробрасываю данные для блока статов
        return data;
    },
    /**
     * Заменяет стандартный блок статов предмета, на блок добавляющий изменения статов в результате ковки
     */
    replaceItemStats1Block: function(blocks) {
        var index = blocks.indexOf(ExGods.stuff.block.item.Stats1);
        Ext.Array.replace(blocks, index, 1, [
            ExGods.view.fucina.stuff.block.TransmuteStats1Prognoz
        ]);
    },
    /**
     * Заменяет стандартный блок статов предмета, на блок добавляющий изменения статов в результате ковки
     */
    replaceItemStats2Block: function(blocks) {
        var index = blocks.indexOf(ExGods.stuff.block.item.Stats2);
        Ext.Array.replace(blocks, index, 1, [
            ExGods.view.fucina.stuff.block.Stats2Result
        ]);
    }
});

/**
 * Добавляет + 1 к уровню грейда предмета
 */
Ext.define('ExGods.view.fucina.stuff.decorator.ItemGradePrognoz', {
    extend: ExGods.stuff.decorator.ItemGrade,
    statics: {
        /**
        * @override
        */
        getGrade: function(data) {
            return data.itemModel && data.itemModel.isUpgraded() ? data.itemModel.get('param').upgrades + 1 : 1;
        }
    }
});

/**
 * Декоратор "Кол-во необходимых ресурсов"
 */
Ext.define('ExGods.view.fucina.stuff.decorator.RequiredQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getCls: function(data) {
            var cls = 'fucina-stuff-decorator-required-quantity',
                userQuantity = this.getUserQuantityOfStuff(data),
                requiredQuantity = data.stuff.params.quantity || 0;
            if (!data.resultInfo && requiredQuantity > userQuantity) {
                cls += ' fucina-stuff-decorator-required-quantity-red';
            }
            return cls;
        },
        /**
         * @override
         */
        getQuantity: function(data) {
            var userQuantity, requiredQuantity;
            if (data.resultInfo) {
                return data.resultInfo.min + ' - ' + data.resultInfo.max;
            } else {
                userQuantity = this.getUserQuantityOfStuff(data);
                requiredQuantity = data.stuff.params.quantity || 0;
                if (data.stuff.type == 'currency') {
                    return requiredQuantity;
                } else {
                    return userQuantity + '/' + requiredQuantity;
                }
            }
        },
        /**
         * Вернет текущее кол-во ресурсов юзера по типу ресурса      
         */
        getUserQuantityOfStuff: function(data) {
            var userQuantity = 0;
            if (data.stuff.type == 'currency') {
                userQuantity = ExGods.app.user.get('money')[data.stuff.params.id];
            } else if (data.stuff.type == 'item') {
                userQuantity = ExGods.app.user.slots().getItemCount(data.stuff.params.id);
            } else if (data.stuff.type == 'ingredients') {
                userQuantity = ExGods.app.user.getIngredientCountByName(data.stuff.params.id);
            }
            return userQuantity;
        }
    }
});

/**
 * Декоратор "Кол-во" для источников кузницы
 */
Ext.define('ExGods.view.fucina.stuff.decorator.SourceQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getQuantity: function(data) {
            var quantity = this.superclass.self.getQuantity(data);
            if (quantity == 1) {
                return false;
            } else {
                return quantity;
            }
        }
    }
});

/**
 * Блок статов источника (не показывает сравнение статов)
 */
Ext.define('ExGods.view.fucina.stuff.block.EmptyStats2', {
    extend: ExGods.stuff.block.item.Stats2,
    statics: {
        /**
         * @override
         */
        getStatsChanged: function(data) {
            return {};
        }
    }
});

/**
 * Добаляет текст "Предмет надет"
 */
Ext.define('ExGods.view.fucina.stuff.block.ClothedTextSource', {
    extend: ExGods.stuff.Block,
    statics: {
        /**
         * @override
         */
        getContent: function(data) {
            return '<div style="text-align: center; font-weight: bold; padding: 0 10px;">' + ExGods.getMsgByKey('fucina_putedon_item') + '</div>';
        }
    }
});

/**
 * Блок статов предмета для прогнозируемого результата ковки (добавляет знаки вопроса к статам)
 */
Ext.define('ExGods.view.fucina.stuff.block.Stats2Prognoz', {
    extend: ExGods.stuff.block.item.Stats2,
    statics: {
        /**
         * @override
         */
        getStatsChanged: function(data) {
            var changes = {};
            Ext.Object.each(data.protoModel.data.data.stats, function(key, value) {
                changes[key] = '<span class="up">+?</span>';
            });
            return changes;
        }
    }
});

/**
 * Блок статов предмета для результата ковки (добавляет изменения статов от оригинала и максимально возможные значения)
 */
Ext.define('ExGods.view.fucina.stuff.block.Stats2Result', {
    extend: ExGods.stuff.block.item.Stats2,
    statics: {
        /**
         * @override
         */
        getItemStats: function(data) {
            var changes = this.getStatsChanged(data),
                stats = this.superclass.self.getItemStats(data);
            // накатываю изменения кузницы
            // они уже накатываются в методе суперкласса
            // Ext.Object.each(changes, function(key, value) {
            //  if (stats[key]) {
            //      stats[key] += value;
            //  }
            // });
            return stats;
        },
        /**
         * @override
         */
        getStatsChanged: function(data) {
            var changes = {},
                newStats = {},
                oldStats = {};
            if (data.workData && data.workData.result && data.workData.result.param.stat) {
                newStats = Ext.clone(data.workData.result.param.stat);
            }
            if (data.workData && data.workData.work && data.workData.work.source_data && data.workData.work.source_data.param.stat) {
                oldStats = Ext.clone(data.workData.work.source_data.param.stat);
            }
            Ext.Object.each(newStats, function(key, value) {
                changes[key] = value - (oldStats[key] || 0);
            });
            return changes;
        },
        /**
         * @override
         */
        getStatsMax: function(data) {
            var max = {};
            if (data.workData && data.workData.was_result && data.workData.was_result.list && data.workData.was_result.list.length) {
                data.workData.was_result.list.forEach(function(item) {
                    if (item.type == 'stat') {
                        max[item.data] = item.max;
                    }
                });
            }
            return max;
        }
    }
});

/**
 * Блок фич для прогнозируемого результата ковки
 */
Ext.define('ExGods.view.fucina.stuff.block.FeaturesPrognoz', {
    extend: ExGods.stuff.block.item.Features,
    statics: {
        /**
         * @override
         */
        getFeaturesData: function(data) {
            var features = [];
            // Вместо реальной фичи, нужно показать "Случайную" фичу с прототипа
            Ext.Array.each(data.protoModel.get('action_full') || [], function(action) {
                if (action.type == 'feature' && action.only_proto) {
                    features.push(action);
                }
            });
            return features;
        }
    }
});

/**
 * Блок статов предмета для прогнозируемого результата трансмутации (уровень, прочность.. )
 * Добавляет к статам время экспирации 
 */
Ext.define('ExGods.view.fucina.stuff.block.TransmuteStats1Prognoz', {
    extend: ExGods.stuff.block.item.Stats1,
    statics: {
        /**
         * @override
         */
        getContent: function(data) {
            var content = this.superclass.self.getContent(data);
            var expireTime = this.getExpirationTime(data);
            if (expireTime) {
                content.push([
                    ExGods.getMsgByKey('item_expire_after'),
                    '',
                    ExGods.util.Time.printRestTime(expireTime, {
                        format: 'short'
                    })
                ]);
            }
            return content;
        },
        /**
         * Вернет время через которое предмет должен исчезнуть ()
         */
        getExpirationTime: function(data) {
            var me = this;
            if (data.protoModel.data.data.expire_after) {
                return ExGods.util.Date.parseString(data.protoModel.data.data.expire_after);
            }
        }
    }
});

/**
 * Блок статов предмета для прогнозируемого результата трансмутации
 */
Ext.define('ExGods.view.fucina.stuff.block.TransmuteStats2Prognoz', {
    extend: ExGods.stuff.block.item.Stats2,
    statics: {
        /**
         * @override
         */
        getStatsChanged: function(data) {
            var changes = {},
                itemStats = {},
                sourceStats = {},
                sourceProto;
            itemStats = this.superclass.self.getItemStats(data);
            sourceProto = ExGods.app.getItemPrototypesStore().getById(parseInt(data.sourceModel.data.source_data.proto_id));
            if (sourceProto) {
                sourceStats = Ext.clone(sourceProto.data.data.stats);
                if (data.sourceModel.data.source_data.param && data.sourceModel.data.source_data.param.stat) {
                    Ext.Object.each(data.sourceModel.data.source_data.param.stat, function(key, value) {
                        sourceStats[key] += value;
                    });
                }
            }
            Ext.Object.each(itemStats, function(key, value) {
                changes[key] = value - (sourceStats[key] || 0);
            });
            return changes;
        }
    }
});

/**
 * Отображение вкладки в виде кнопки-картинки на камне
 */
Ext.define('ExGods.view.stone.Tab', {
    extend: Ext.tab.Tab,
    alias: 'widget.stonetab',
    /**
     * Значение счетчика на кнопке таба
     */
    counter: 0,
    border: 0,
    height: 47,
    margin: 0,
    width: 47,
    ui: 'stone',
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.counterEl = me.btnEl.insertHtml('beforeEnd', '<div class="counter">' + me.counter + '</div>', true);
        me.counterEl.setVisibilityMode(Ext.Element.DISPLAY);
        me.counterEl[me.counter ? 'show' : 'hide']();
    },
    addCount: function(value) {
        var me = this;
        me.counter += value;
        if (me.counterEl) {
            me.counterEl[me.counter ? 'show' : 'hide']();
            me.counterEl.setHTML(me.counter);
        }
    },
    reset: function() {
        var me = this;
        me.counter = 0;
        if (me.counterEl) {
            me.counterEl.hide();
        }
    }
});

/**
 * Табы на камне
 */
Ext.define('ExGods.view.stone.TabPanel', {
    extend: Ext.tab.Panel,
    alias: 'widget.stonetabpanel',
    activeTab: 0,
    /**
     * @cfg
     */
    tabUi: 'stone',
    // stone или stonetext
    constructor: function(config) {
        var me = this;
        config.tabBar = Ext.apply({
            height: 60,
            layout: {
                align: 'top'
            },
            margin: '0 0 -16 0',
            padding: '11 5 0 38',
            ui: 'stone',
            style: {
                'z-index': 1
            }
        }, config.tabBar || {});
        me.callParent(arguments);
    },
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {};
        }
        Ext.applyIf(item.tabConfig, {
            xtype: 'stonetab',
            ui: me.tabUi,
            width: me.cls == 'inventory_tabpanel' ? 120 : me.tabUi == 'stone' ? 47 : 198
        });
        me.callParent(arguments);
    }
});

/**
 * Табы кузницы
 */
Ext.define('ExGods.view.fucina.FucinaTabs', {
    extend: ExGods.view.stone.TabPanel,
    alias: 'widget.fucinatabs',
    cls: 'fucinatabs',
    /**
     * @cfg service {ExGods.service.Fucina} Сервис кузницы
     */
    service: null,
    plugins: [
        'stonedeco'
    ],
    closable: true,
    bodyPadding: '0 20 10 10',
    width: 660,
    height: 420,
    y: 5,
    x: 210,
    layout: {
        type: 'absolute'
    },
    /**
     * @property filters [Array]
     */
    filters: [],
    initComponent: function() {
        var me = this;
        me.hidden = me.service.data.fucina.data.result;
        me.initFiltersBar();
        me.initTabs();
        me.callParent(arguments);
        me.mon(me.service, 'update', me.onServiceUpdate, me);
    },
    /*************** PRIVATES *******************/
    initTabs: function() {
        var me = this,
            currentTabIndex = 0,
            tabs = [];
        // для каждой кузницы создаю таб
        me.service.data.fucina.entry_list.forEach(function(fucina, index) {
            var itemSources = [],
                forceSourceId;
            if (me.service.data.fucina.current == fucina.entry) {
                currentTabIndex = index;
                itemSources = me.service.data.fucina.data.source;
                forceSourceId = me.service.data.fucina.data.force_source_id;
            }
            tabs.push({
                xtype: 'fucina',
                tabConfig: {
                    xtype: 'fucinatab',
                    fucinaType: fucina.fucina_type,
                    tooltip: fucina.desc.desc,
                    icon: IMAGE_URL + fucina.desc.img,
                    counter: fucina.count
                },
                itemSources: itemSources,
                fucinaData: fucina,
                forceSourceId: forceSourceId,
                itemId: 'fucina-' + fucina.entry
            });
        });
        if (!me.rendered) {
            me.activeTab = currentTabIndex;
            me.items = tabs;
            me.on('afterrender', function() {
                me.on('beforetabchange', me.onBeforeTabChange, me);
            });
        } else {
            me.un('beforetabchange', me.onBeforeTabChange, me);
            me.removeAll();
            ExGods.Resources.load({
                items: {
                    items: tabs
                },
                getResources: function() {
                    return {
                        images: []
                    };
                }
            }, function() {
                me.add(tabs);
                me.setActiveTab('fucina-' + me.service.data.fucina.current);
                me.on('beforetabchange', me.onBeforeTabChange, me);
            });
        }
    },
    onBeforeTabChange: function(tabPanel, newTab) {
        var me = this;
        me.fireEvent('fucina-tab-click', me, newTab.fucinaData.entry);
        return false;
    },
    onServiceUpdate: function() {
        var me = this;
        if (me.service.data.fucina.data.result) {
            me.suspendEvents();
            // чтобы не сработало событие 'beforetabchange'
            me.removeAll();
            me.resumeEvents();
            me.hide();
        } else {
            me.initTabs();
            me.show();
        }
    },
    initFiltersBar: function() {
        var me = this;
        me.dockedItems = [
            {
                dock: 'top',
                items: [
                    {
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        defaults: {
                            xtype: 'checkboxfield',
                            checked: true,
                            listeners: {
                                change: me.onFilterChange,
                                scope: me
                            }
                        },
                        items: [
                            {
                                boxLabel: ExGods.getMsgByKey('fucina_filter_checkbox_items'),
                                name: 'type_item',
                                padding: '0 15 0 0'
                            },
                            {
                                boxLabel: ExGods.getMsgByKey('fucina_filter_checkbox_ingredients'),
                                name: 'type_ingredient'
                            }
                        ]
                    }
                ],
                margin: '21 80 -45 280',
                style: {
                    'z-index': 2
                }
            }
        ];
    },
    onFilterChange: function(checkbox) {
        var me = this,
            activeView = me.getActiveTab();
        activeView.setFilter(checkbox.name, checkbox.getValue());
        activeView.applyFilters();
    }
});

/**
 * Результат работы кузницы
 */
Ext.define('ExGods.view.fucina.Result', {
    extend: Ext.Panel,
    alias: 'widget.fucinaresult',
    cls: 'fucina-result',
    width: 627,
    height: 367,
    y: 5,
    x: 210,
    padding: '8 0 0 5',
    layout: {
        type: 'absolute'
    },
    plugins: [
        'skinpaperdeco'
    ],
    /**
     * @cfg service {ExGods.service.Fucina} service
     */
    initComponent: function() {
        var me = this;
        me.hidden = true;
        me.cls = me.cls + ' fucina-result-' + me.service.data.fucina.fucina_type;
        me.tpl = [
            '<tpl if="values.data.work">',
            // Результат
            '<div class="fucina-result-item">',
            '<div class="paper-title title">' + ExGods.getMsgByKey('fucina_result') + '</div>',
            '<div>{[ this.printFucinaResult(values) ]}</div>',
            '</div>',
            '<div class="v-separator"></div>',
            // Список ресурсов //
            '<div class="fucina-result-resources {[ values.data.no_replay ? "no-replay" : "" ]}">',
            '<div class="paper-title title">' + ExGods.getMsgByKey('fucina_result_more') + '</div>',
            '{[ this.printRequiredResources(values) ]}',
            '<span class="fucina-result-replay-btn-tip">' + ExGods.getMsgByKey('fucina_result_more2') + '</span>',
            '<div class="component fucina-result-replay-btn">',
            '<span role="xtype">textbutton</span>',
            '<span role="disabled:bool">{[ values.data.invalid ? true : false ]}</span>',
            '<span role="cls">x-btn-txt-green no_border</span>',
            '<span role="action">fucina-result-replay</span>',
            '<span role="minWidth:int">90</span>',
            '<span role="text">',
            '{[ this.printButtonText(values) ]}',
            '</span>',
            '</div>',
            '<div class="separator"></div>',
            '</div>',
            // Награда //
            '<div class="fucina-rewards">',
            '<div class="paper-title title">' + ExGods.getMsgByKey('fucina_result_bonus') + '</div>',
            '<tpl if="values.data.reward">',
            '{[ ExGods.stuff.StuffManager.image(values.data.reward) ]}',
            '</tpl>',
            '<div class="component fucina-result-finish-btn">',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border qh-object</span>',
            '<span role="action">fucina-result-finish</span>',
            '<span role="qh:object">{[this.getQuestHelperInfo(values)]}</span>',
            '<span role="minWidth:int">170</span>',
            '<span role="text">' + ExGods.getMsgByKey('fucina_finish') + '</span>',
            '</div>',
            '</div>',
            '</tpl>',
            {
                printFucinaResult: function(values) {
                    var stuff, wrappedStuff;
                    if (Ext.isArray(values.data.result)) {
                        if (values.data.result.length == 1) {
                            wrappedStuff = values.data.result[0].stuff;
                        } else {
                            wrappedStuff = [];
                            values.data.result.forEach(function(item) {
                                wrappedStuff.push(item.stuff);
                            });
                        }
                    } else if (values.data.result.proto_id) {
                        wrappedStuff = {
                            type: 'iteminstance',
                            params: {
                                itemModel: Ext.create('ExGods.model.Item', values.data.result)
                            }
                        };
                    } else {
                        wrappedStuff = values.data.result;
                    }
                    if (wrappedStuff.length) {
                        stuff = [];
                        wrappedStuff.forEach(function(item) {
                            stuff.push({
                                type: 'fucina_result',
                                params: {
                                    stuff: item
                                },
                                workData: values.data,
                                fucinaType: me.service.data.fucina.fucina_type
                            });
                        });
                    } else {
                        stuff = {
                            type: 'fucina_result',
                            params: {
                                stuff: wrappedStuff
                            },
                            workData: values.data,
                            fucinaType: me.service.data.fucina.fucina_type
                        };
                    }
                    return ExGods.stuff.StuffManager.details(stuff);
                },
                printRequiredResources: function(values) {
                    var stuff = [],
                        workSourceModel;
                    if (values.data.was_required && values.data.was_required.length) {
                        stuff = values.data.was_required;
                    }
                    if (values.fucina_type == 'fragmentation') {
                        workSourceModel = Ext.create('ExGods.model.FucinaSourceItem', values.data.work);
                        stuff.push(workSourceModel.data.stuff);
                    }
                    return ExGods.stuff.StuffManager.image(stuff);
                },
                printButtonText: function(values) {
                    var price = '';
                    if (values.data.price) {
                        price = ExGods.util.Stuff.printStuff(values.data.price);
                    }
                    return ExGods.getMsgByKey('fucina_rerol') + ' ' + price;
                },
                getQuestHelperInfo: function(values) {
                    return JSON.stringify({
                        'data-qh_otype': 'forge_type_ready_button',
                        'data-qh_oid': me.service.data.fucina.fucina_type
                    });
                }
            }
        ];
        me.config.data = {};
        me.mon(me.service, 'update', me.onServiceUpdate, me);
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.showHideResult();
    },
    /**
     * @private
     */
    onServiceUpdate: function() {
        var me = this;
        me.showHideResult();
    },
    /**
     * Скрывает или показывает компонент в зависимости от данных сервиса
     */
    showHideResult: function() {
        var me = this,
            fucinaResultStuff, sourceModel;
        if (me.service.data.fucina.data.result) {
            if (me.rendered) {
                me.update(me.service.data.fucina);
                me.renderTemplateComponents();
                me.show();
            }
        } else {
            if (me.rendered) {
                me.hide();
            }
        }
    },
    /**
     * Отрисовка компонентов шаблона
     */
    renderTemplateComponents: function() {
        var me = this;
        ExGods.helpme.renderComponents(me.el, me);
        // обновляю лейаут кнопок после отрисовки, иначе невалидно отображается
        setTimeout(function() {
            Ext.Array.each(me.query('textbutton'), function(btn) {
                btn.updateLayout();
            });
        }, 0);
    }
});

/**
 * Модель объекта-источника кузницы
 * Источником может выступать предмет, прототип предмета, ингредиент.
 */
Ext.define('ExGods.model.FucinaSourceItem', {
    extend: Ext.data.Model,
    idProperty: 'source_id',
    fields: [
        {
            // id источника
            name: 'source_id',
            type: 'string'
        },
        {
            // тип источника (item, stuff)
            name: 'source_type',
            type: 'string'
        },
        {
            // данные источника
            name: 'source_data',
            type: 'auto'
        },
        {
            // данные источника в формате имущества
            name: 'stuff',
            convert: function(v, record) {
                if (record.data.source_type == 'stuff') {
                    return {
                        params: {
                            stuff: record.data.source_data
                        },
                        sourceModel: record,
                        type: 'fucina_source'
                    };
                } else if (record.data.source_type == 'item') {
                    return {
                        params: {
                            stuff: {
                                type: 'iteminstance',
                                params: {
                                    itemModel: Ext.create('ExGods.model.Item', record.data.source_data)
                                }
                            }
                        },
                        sourceModel: record,
                        type: 'fucina_source'
                    };
                }
            }
        },
        {
            // награда за использование источника
            name: 'reward',
            type: 'auto'
        },
        {
            // получаемые ресурсы при использовании
            name: 'result',
            type: 'auto'
        },
        {
            // требуемые ресурсы для использования
            name: 'required',
            type: 'auto'
        },
        {
            // стоимость использования
            name: 'price',
            type: 'auto'
        },
        {
            // признак невозможности использования
            name: 'invalid',
            type: 'auto'
        },
        {
            // признак что источник выбран для ковки
            name: 'selected',
            type: 'auto'
        }
    ]
});

/**
 * Позволяет добавить информацию для указателя квест хелпера к DOM-элементу компонента
 */
Ext.define('ExGods.view.plugin.QuestHelperTarget', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.qh_target',
    /**
     * @cfg {Object} target Данные квестхелпера в формате {type: <String>, id: <String>, opts: <Object>}
     */
    target: null,
    init: function(cmp) {
        var me = this;
        cmp.on('render', this.onRender, this);
    },
    onRender: function() {
        var me = this,
            cmp = me.cmp;
        if (me.target) {
            cmp.el.addCls('qh-object');
            cmp.el.set({
                'data-qh_otype': me.target.type,
                'data-qh_oid': me.target.id,
                'data-qh_opts': me.target.opts ? Ext.htmlEncode(JSON.stringify(me.target.opts)) : ''
            });
        }
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.onRender, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'interface/quest_helper/item.png'
            ]
        };
    }
});

/**
 * Отображение вкладки в виде кнопки-картинки на камне
 */
Ext.define('ExGods.view.fucina.Tab', {
    extend: ExGods.view.stone.Tab,
    alias: 'widget.fucinatab',
    cls: 'fucinatab',
    /**
     * @cfg {String} fucinaType Тип кузницы
     */
    fucinaType: '',
    initComponent: function() {
        var me = this;
        me.plugins = [
            {
                ptype: 'qh_target',
                target: {
                    type: 'forge_type',
                    id: me.fucinaType,
                    opts: {
                        cls: 'flip-h'
                    }
                }
            }
        ];
        me.callParent(arguments);
    }
});

/**
 * Кузница
 */
Ext.define('ExGods.view.fucina.Fucina', {
    extend: Ext.Panel,
    alias: 'widget.fucina',
    layout: 'absolute',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.Highlightable
    ],
    /**
     * @cfg itemSources {Array} Предметы, над которыми можно производить действие кузницы
     */
    itemSources: [],
    /**
     * @cfg fucinaData {Object} Данные кузницы
     */
    fucinaData: {},
    /**
     * @cfg forceSourceId {Number} ID источника для автовыбора после отрисовки
     */
    forceSourceId: null,
    /**
     * @property store {Ext.data.Store} Хранилище источников
     */
    store: null,
    /**
     * @property filters {Array} Список текущих фильтров 
     */
    filters: {},
    initComponent: function() {
        var me = this;
        me.cls = 'fucina ' + 'fucina-' + me.fucinaData.fucina_type;
        me.store = me.initItemSourcesStore();
        me.gridView = Ext.widget('slotsgrid', {
            height: 320,
            x: 312,
            y: 36,
            store: me.store,
            autoShow: false,
            bodyPadding: '35 7px 3px 8px',
            style: {
                background: 'url(' + IMAGE_URL + 'fucina/fucina_frm.png) -3px 24px no-repeat'
            },
            calcWidth: function() {
                this.width = 256 + 22;
            },
            // 22 - добавка от фрейма
            itemSelector: '.exg-grid-item',
            itemTpl: [
                '<div class="qh-object" data-qh_otype="forge_item" data-qh_oid="{[ values.source_type == "item" ? values.source_data.proto_id : "" ]}">',
                '{[ ExGods.stuff.StuffManager.image(values.stuff) ]}',
                '</div>'
            ],
            pager: {
                marginRight: -27,
                textTop: 301
            },
            listeners: {
                afterrender: function(view) {
                    me.initDragAndDrop();
                    view.el.on('click', function(e, t) {
                        Ext.fly(t).parent().down('.exg-stuff-item').dom.click();
                    }, me, {
                        delegate: '.qh-pointer'
                    });
                }
            },
            plugins: [
                {
                    ptype: 'frame_title',
                    text: ExGods.getMsgByKey('inventory_title_text'),
                    size: '4slots'
                }
            ]
        });
        me.anvilView = Ext.widget('fucinaanvil', {
            width: 282,
            height: 320,
            x: 29,
            y: 36,
            bodyPadding: '41 0 0 0',
            autoShow: false,
            plugins: [
                {
                    ptype: 'frame_title',
                    text: me.fucinaData.desc.label,
                    size: '0slots'
                }
            ],
            fucinaType: me.fucinaData.fucina_type,
            bodyStyle: {
                margin: '-18px 0 0 0'
            },
            listeners: {
                startdrag: function() {
                    me.highlight(true);
                },
                stopdrag: function() {
                    me.highlight(false);
                }
            }
        });
        me.on({
            'activate': function() {
                me.gridView.showPager();
            },
            'deactivate': function() {
                me.gridView.hidePager();
            },
            startdrag: function() {
                me.anvilView.highlight(true);
            },
            stopdrag: function() {
                me.anvilView.highlight(false);
            },
            scope: me
        });
        me.items = [
            me.gridView,
            me.anvilView
        ];
        me.margin = '-25 0 0 0';
        me.callParent();
    },
    /**
     * Выставить значение фильтра и отфильтровать вью
     */
    setFilter: function(type, value) {
        var me = this;
        if (type == 'type_item') {
            me.setTypeItemFilter(value);
        } else if (type == 'type_ingredient') {
            me.setTypeIngredientFilter(value);
        }
    },
    /**
     * Применить фильтры
     */
    applyFilters: function() {
        var me = this,
            filters = [];
        for (var filterName in me.filters) {
            if (me.filters.hasOwnProperty(filterName)) {
                filters.push(me.filters[filterName]);
            }
        }
        me.store.clearFilter();
        me.store.filter(filters);
    },
    /**
     * Сбросить фильтры
     */
    clearFilters: function() {
        var me = this;
        me.filters = {};
        me.store.clearFilter();
    },
    /****************** PRIVATES ************************/
    afterRender: function() {
        var me = this,
            sourceModel;
        me.callParent(arguments);
        if (me.forceSourceId) {
            sourceModel = me.store.getById(me.forceSourceId);
            if (!sourceModel) {
                // source_id может быть в формате <proto_id>:<slot_id>:<item_id>, а forceSourceId в формате <proto_id>
                // так что ищем по прототипу
                me.store.each(function(item) {
                    if (item.data.source_id.split(':')[0] == me.forceSourceId) {
                        sourceModel = item;
                    }
                });
            }
            if (sourceModel) {
                ExGods.app.getController('Fucina').doPutSource(sourceModel);
            }
        }
    },
    initItemSourcesStore: function() {
        var me = this;
        return Ext.create('Ext.data.Store', {
            model: 'ExGods.model.FucinaSourceItem',
            data: me.itemSources,
            sorters: [
                {
                    sorterFn: function(o1, o2) {
                        if (!o1 || !o2)  {
                            return 0;
                        }
                        
                        var item1Invalid = (o1.data.invalid) ? 1 : 0;
                        var item2Invalid = (o2.data.invalid) ? 1 : 0;
                        if (item1Invalid == item2Invalid) {
                            var item1Type = (o1.data.source_data.type == 'item' || o1.data.source_type == 'item') ? 1 : 0;
                            var item2Type = (o2.data.source_data.type == 'item' || o2.data.source_type == 'item') ? 1 : 0;
                            if (item1Type == item2Type) {
                                var item1Upgrd = 0;
                                var item2Upgrd = 0;
                                if (o1.data.source_data.param && o1.data.source_data.param.upgrades) {
                                    item1Upgrd = o1.data.source_data.param.upgrades;
                                }
                                if (o2.data.source_data.param && o2.data.source_data.param.upgrades) {
                                    item2Upgrd = o2.data.source_data.param.upgrades;
                                }
                                if (item1Upgrd == item2Upgrd) {
                                    // нужен критерий к которому можно привязаться, чтобы сортировка была однозначна. Пусть будет id источника
                                    if (o1.data.source_id < o2.data.source_id) {
                                        return -1;
                                    } else if (o1.data.source_id > o2.data.source_id) {
                                        return 1;
                                    } else {
                                        return 0;
                                    }
                                } else {
                                    if (me.fucinaData.fucina_type == 'fragmentation') {
                                        return (item1Upgrd < item2Upgrd) ? -1 : 1;
                                    } else {
                                        return (item1Upgrd < item2Upgrd) ? 1 : -1;
                                    }
                                }
                            } else {
                                return (item1Type < item2Type) ? 1 : -1;
                            }
                        } else {
                            return (item1Invalid < item2Invalid) ? -1 : 1;
                        }
                    }
                }
            ]
        });
    },
    /**
     * Реализация метода ExGods.mixin.Highlightable
     */
    getHighlitableTarget: function() {
        var me = this;
        return Ext.fly(me.gridView.itemsView.getEl().down('.exg-grid-inner'));
    },
    /**
     * @private
     */
    initDragAndDrop: function() {
        var me = this;
        me.initDrag({
            view: me.gridView.itemsView
        });
        me.initDrop({
            view: me.gridView.itemsView,
            onDrop: function(target, dd, e, data) {
                ExGods.app.getController('Fucina').doPutOffSource(data.item);
                return false;
            }
        });
    },
    /**
     * Выставить фильтр по типу источника "предмет"
     */
    setTypeItemFilter: function(value) {
        var me = this;
        if (!value) {
            me.filters['type_item'] = new Ext.util.Filter({
                filterFn: function(item) {
                    return item.data.source_type != "item";
                }
            });
        } else {
            delete me.filters['type_item'];
        }
    },
    /**
     * Выставить фильтр по типу источника "ингредиент"
     */
    setTypeIngredientFilter: function(value) {
        var me = this;
        if (!value) {
            me.filters['type_ingredient'] = new Ext.util.Filter({
                filterFn: function(item) {
                    return item.data.source_type != "stuff";
                }
            });
        } else {
            delete me.filters['type_ingredient'];
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.store.data.items) {
            for (var i = 0; i < me.store.data.items.length; i++) {
                var itm = me.store.data.items[i].data;
                if (itm.price.stuff) {
                    stuff_arr.concat(itm.price.stuff);
                }
                if (itm.reward) {
                    stuff_arr.concat(itm.reward);
                }
                if (itm.result) {
                    for (var j = 0; j < itm.result.length; j++) {
                        stuff_arr.push(itm.result[j].data);
                    }
                }
            }
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [
                IMAGE_URL + 'fucina/fucina_frm.png',
                IMAGE_URL + me.fucinaData.desc.img,
                // Все из CSS
                IMAGE_URL + 'interface/quest_helper/item.png',
                IMAGE_URL + 'fucina/arrow_down.png',
                IMAGE_URL + 'interface/quest_helper/item.png',
                IMAGE_URL + 'slots/slot_regular.png',
                IMAGE_URL + 'fucina/icon_bg_slot.png',
                IMAGE_URL + 'fucina/fucina_frm_top_small.png',
                IMAGE_URL + 'fucina/arrow.png',
                IMAGE_URL + 'fucina/arrow_up.png',
                IMAGE_URL + 'fucina/checkbox_grey.png',
                IMAGE_URL + 'fucina/checkbox_grey_checked.png',
                IMAGE_URL + 'interface/quest_helper/item.png',
                IMAGE_URL + 'interface/quest_helper/item.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Добавляет заголовок в виде плашки с текстом
 */
Ext.define('ExGods.view.plugin.FrameTitle', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.frame_title',
    size: '5slots',
    // размер плашки: 5slots, 4slots, 0slots
    init: function(cmp) {
        cmp.on('render', this.addTitle, this);
    },
    addTitle: function() {
        var me = this,
            cmp = me.cmp;
        cmp.el.insertHtml('afterBegin', '<div class="exg-frame-title exg-frame-title-' + me.size + '">' + '<div class="exg-frame-title-text">' + me.text + '</div>' + '<div class="exg-frame-title-text exg-frame-title-text2">' + me.text + '</div>' + '</div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addTitle, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     * Ресурсы плагин предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'inventory/frm_top.png',
                IMAGE_URL + 'fucina/fucina_frm_top.png',
                IMAGE_URL + 'fucina/fucina_frm_top_small.png'
            ]
        };
    }
});

/**
 * Наковальня, показывает выбранный предмет источника и ресурсы, которые необходимы для ковки
 */
Ext.define('ExGods.view.fucina.Anvil', {
    extend: Ext.Panel,
    alias: 'widget.fucinaanvil',
    cls: 'fucina-anvil',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.Highlightable
    ],
    /**
     * @cfg sourceModel {ExGods.model.FucinaSourceItem} sourceModel
     */
    /**
     * @cfg fucinaType {String} Тип кузницы
     */
    initComponent: function() {
        var me = this;
        me.tpl = [
            // слот наковальни и результата
            '<div class="anvil">',
            '<div class="fucina-anvil-slot fucina-anvil-target-slot">',
            '<div class="fucina-anvil-target-slot-inner">',
            '<tpl if="values.sourceModel">',
            '{[ ExGods.stuff.StuffManager.image(values.sourceModel.data.stuff) ]}',
            '</tpl>',
            '</div>',
            '</div>',
            '<div class="fucina-arrow fucina-anvil-prognoz-arrow"></div>',
            '<div class="fucina-anvil-slot fucina-anvil-prognoz-slot">',
            '<tpl if="values.sourceModel">',
            '{[ this.printPrognoz(values) ]}',
            '</tpl>',
            '</div>',
            '</div>',
            // кнопка Ковать
            '<div class="component anvil-btn">',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">x-btn-txt-green stone_double_btn in_one_row qh-object</span>',
            '<span role="disabled:bool">{[ values.sourceModel && !values.sourceModel.data.invalid ? false : true ]}</span>',
            '<span role="qh:object">{[this.getQuestHelperInfo(values)]}</span>',
            '<span role="action">fucina-make</span>',
            '<span role="width:int">110</span>',
            '<span role="text">',
            '{[ this.printButtonText() ]}',
            '</span>',
            '</div>',
            '<div class="fucina-arrow fucina-arrow-action"></div>',
            // слоты ресурсов (требуемых или получаемых)
            '<ul class="resources-list">',
            '<li class="fucina-anvil-slot">',
            '{[ this.printResource(0) ]}',
            '</li>',
            '<li class="fucina-anvil-slot">',
            '{[ this.printResource(1) ]}',
            '</li>',
            '<li class="fucina-anvil-slot">',
            '{[ this.printResource(2) ]}',
            '</li>',
            '</ul>',
            {
                printPrognoz: function() {
                    var stuff = '',
                        proto;
                    if (me.fucinaType == 'transmutation') {
                        stuff = {
                            type: 'iteminstance',
                            params: {
                                itemModel: Ext.create('ExGods.model.Item', me.sourceModel.data.result)
                            }
                        };
                    } else {
                        stuff = me.sourceModel.data.stuff.params.stuff;
                    }
                    return ExGods.stuff.StuffManager.image({
                        type: "fucina_prognoz",
                        sourceModel: me.sourceModel,
                        fucinaType: me.fucinaType,
                        params: {
                            stuff: stuff
                        }
                    });
                },
                printResource: function(index) {
                    if (me.sourceModel) {
                        if (me.sourceModel.data.required && me.sourceModel.data.required.length) {
                            if (me.sourceModel.data.required[index]) {
                                return ExGods.stuff.StuffManager.image({
                                    type: "fucina_resource",
                                    params: {
                                        stuff: me.sourceModel.data.required[index]
                                    }
                                });
                            }
                        } else if (me.sourceModel.data.result && me.sourceModel.data.result.length) {
                            if (me.sourceModel.data.result[index] && me.sourceModel.data.result[index].data) {
                                return ExGods.stuff.StuffManager.image({
                                    type: "fucina_resource",
                                    params: {
                                        stuff: me.sourceModel.data.result[index].data
                                    },
                                    resultInfo: me.sourceModel.data.result[index]
                                });
                            }
                        }
                    }
                },
                printButtonText: function() {
                    if (me.sourceModel && me.sourceModel.data.price && me.sourceModel.data.price.stuff && me.sourceModel.data.price.stuff.length) {
                        return ExGods.getMsgByKey("fucina_make") + " " + ExGods.util.Stuff.printStuff(me.sourceModel.data.price.stuff);
                    } else {
                        return ExGods.getMsgByKey("fucina_make_free");
                    }
                },
                getQuestHelperInfo: function(values) {
                    return JSON.stringify({
                        'data-qh_otype': 'forge_item_action_btn',
                        'data-qh_oid': values.sourceModel && !values.sourceModel.data.invalid && values.sourceModel.data.source_type == "item" ? values.sourceModel.data.source_data.proto_id : ""
                    });
                }
            }
        ];
        me.data = {};
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        ExGods.helpme.renderComponents(me.el, me);
        me.initDragAndDrop();
    },
    /**
     * Убрать источник с наковальни
     * @return {Ext.model.FucinaSourceItem} Удаленный источник
     */
    removeSourceModel: function() {
        var me = this,
            sourceModel;
        if (me.sourceModel) {
            sourceModel = me.sourceModel;
            me.sourceModel = null;
            me.updateView();
            sourceModel.set('selected', false);
            return sourceModel;
        }
    },
    /**
     * Выставить источник наковальни
     */
    setSourceModel: function(sourceModel) {
        var me = this;
        me.sourceModel = sourceModel;
        me.sourceModel.set('selected', true);
        me.loadProtos(function() {
            ExGods.Resources.load(me, function() {
                me.updateView();
            });
        });
    },
    /**
     * Реализация метода ExGods.mixin.Highlightable
     */
    getHighlitableTarget: function() {
        var me = this;
        return Ext.fly(me.getEl().down('.fucina-anvil-target-slot-inner'));
    },
    /************** PRIVATES **************/
    updateView: function() {
        var me = this;
        me.update({
            sourceModel: me.sourceModel
        });
        ExGods.helpme.destroyComponents(me.el);
        ExGods.helpme.renderComponents(me.el, me);
    },
    /**
     * @private
     */
    initDragAndDrop: function() {
        var me = this;
        me.initDrag({
            getSourceEl: function(e) {
                if (me.sourceModel && e.getTarget('.fucina-anvil-target-slot')) {
                    return Ext.get(e.getTarget('.exg-stuff-item'));
                }
            },
            getItem: function() {
                return me.sourceModel;
            }
        });
        me.initDrop({
            onDrop: function(target, dd, e, data) {
                ExGods.app.getController('Fucina').doPutSource(data.item);
                return true;
            }
        });
    },
    /**
     * @private
     */
    loadProtos: function(callback) {
        var me = this,
            paths = [
                'required.params.id',
                'result.proto_id'
            ];
        ExGods.helpme.loadProtos(me.sourceModel.data, paths.join('|'), function() {
            callback();
        });
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            stuff = undefined,
            arr_images = [];
        if (me.sourceModel) {
            if (me.fucinaType == 'transmutation') {
                stuff = {
                    type: 'iteminstance',
                    params: {
                        itemModel: Ext.create('ExGods.model.Item', me.sourceModel.data.result)
                    }
                };
            } else {
                stuff = me.sourceModel.data.stuff.params.stuff;
            }
            if (stuff) {
                stuff_arr.push(stuff);
            }
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [
                IMAGE_URL + 'fucina/arrow_up.png',
                IMAGE_URL + 'fucina/arrow_down.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Контроллер кузницы
 *
 */
Ext.define('ExGods.controller.Fucina', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            wrap: true,
            error: true
        },
        prefix: 'Fucina:'
    },
    views: [
        'fucina.Tab',
        'fucina.FucinaTabs',
        'fucina.Fucina',
        'fucina.Anvil',
        'fucina.Result'
    ],
    models: [
        'FucinaSourceItem'
    ],
    init: function() {
        var me = this;
        me.service = ExGods.Services.get('fucina');
        me.service.on({
            update: me.onServiceUpdate,
            scope: me
        });
        me.control({
            'textbutton[action="fucina-make"]': {
                click: me.onMakeBtnClick
            },
            'textbutton[action="fucina-result-replay"]': {
                click: me.onReplayBtnClick
            },
            'textbutton[action="fucina-result-finish"]': {
                click: me.onFinishBtnClick
            }
        });
        ExGods.stuff.StuffManager.register({
            'fucina_source': {
                classObj: ExGods.view.fucina.stuff.FucinaSource,
                listeners: {
                    'put': me.onFucinaSourcePut,
                    'putoff': me.onFucinaSourcePutOff,
                    'scope': me
                }
            },
            'fucina_resource': ExGods.view.fucina.stuff.FucinaResource,
            'fucina_prognoz': ExGods.view.fucina.stuff.FucinaPrognoz,
            'fucina_result': ExGods.view.fucina.stuff.FucinaResult
        });
        me.user.on('item_on', me.onUserItemOnOff, me);
        me.user.on('item_off', me.onUserItemOnOff, me);
        ExGods.Components.addComponentInitializer('fucina', me.initFucinaComponent, me);
    },
    /**
     * Создание комопненты
     */
    initFucinaComponent: function(config, componentId) {
        var me = this,
            tabs = [],
            currentTabIndex = 0,
            cmp, wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            closable: false,
            getResources: function() {
                return {
                    images: [
                        config.backgroundImage,
                        config.backImg
                    ]
                };
            }
        });
        ExGods.Resources.load({
            getResources: function() {
                return {
                    images: [
                        config.backgroundImage
                    ]
                };
            }
        }, function() {
            ExGods.app.getController('Location').maskLocation(function() {
                me.loadProtos(function() {
                    me.fucinaTabs = {
                        xtype: 'fucinatabs',
                        service: me.service,
                        listeners: {
                            beforeclose: {
                                fn: function() {
                                    ExGods.loaderCt.loadAndRemove(function() {
                                        wnd.close();
                                    }, {
                                        img: config.backgroundImage
                                    });
                                    return false;
                                }
                            },
                            'fucina-tab-click': me.onFucinaTabClick,
                            scope: me
                        }
                    };
                    me.fucinaResult = Ext.apply({
                        xtype: 'fucinaresult'
                    }, {
                        service: me.service
                    });
                    Ext.apply(config, {
                        closeBtnUI: 'stone',
                        rightPanelX: 220,
                        closeCallback: function() {
                            ExGods.loaderCt.loadAndRemove(function() {
                                wnd.close();
                            }, {
                                img: config.backgroundImage
                            });
                        },
                        margin: '0 10 10 0',
                        items: [
                            me.fucinaTabs,
                            me.fucinaResult
                        ],
                        backgroundImage: config.backImg
                    });
                    cmp = Ext.apply({
                        xtype: 'room'
                    }, config);
                    wnd.add(cmp);
                    me.fucinaTabs = wnd.down('fucinatabs');
                    ExGods.Resources.load(wnd, function() {
                        wnd.show();
                        ExGods.app.getController('Location').unmaskLocation();
                    });
                });
            }, {
                img: config.backgroundImage
            });
        });
        return wnd;
    },
    /**
     * Выставить источник на ковку
     */
    doPutSource: function(sourceModel) {
        var me = this,
            fucinaView = me.fucinaTabs.getActiveTab();
        if (fucinaView) {
            // убираю текущий источник ковки
            if (fucinaView.anvilView.sourceModel) {
                fucinaView.store.add(fucinaView.anvilView.removeSourceModel());
            }
            // выставляю источник на ковку
            fucinaView.anvilView.setSourceModel(sourceModel);
            fucinaView.store.remove(sourceModel);
        }
    },
    /**
     * Убрать источник
     */
    doPutOffSource: function() {
        var me = this,
            fucinaView = me.fucinaTabs.getActiveTab();
        // убираю текущий источник ковки
        if (fucinaView && fucinaView.anvilView.sourceModel) {
            fucinaView.store.add(fucinaView.anvilView.removeSourceModel());
        }
    },
    /**
     * @private Обработчик действия "put" имущества
     */
    onFucinaSourcePut: function(obj, btn, win) {
        var me = this;
        me.doPutSource(obj.stuff.sourceModel);
        win.close();
    },
    /**
     * @private Обработчик действия "putoff" имущества
     */
    onFucinaSourcePutOff: function(obj, btn, win) {
        var me = this;
        me.doPutOffSource();
        win.close();
    },
    /**
     * @private Обработчик переключения вкладки
     */
    onFucinaTabClick: function(tabPanel, entry) {
        var me = this;
        ExGods.app.block();
        me.service.command('fucina', {
            entry: entry
        }, function(resp) {
            ExGods.app.unblock();
            if (resp && resp.fucina) {
                me.service.update({
                    fucina: resp.fucina
                });
            } else {
                /****/
                me.log('error', '@onFucinaTabClick Сервер не вернул данные кузницы', resp);
            }
        });
    },
    /**
     * @priavte Обновляю данные сервиса при надевании/снимании вещей юзера
     */
    onUserItemOnOff: function() {
        var me = this;
        if (Ext.getCmp('FUCINA')) {
            ExGods.app.block();
            me.service.command('fucina', {
                entry: me.service.data.fucina.current
            }, function(resp) {
                ExGods.app.unblock();
                if (resp && resp.fucina) {
                    me.service.update({
                        fucina: resp.fucina
                    });
                }
            });
        }
    },
    /**
     * @private Обработчик клика по кнопке Ковать
     */
    onMakeBtnClick: function() {
        var me = this,
            confirmText = ExGods.getMsgByKey('make_fucina_' + me.service.data.fucina.fucina_type),
            sourceModel = me.fucinaTabs.getActiveTab().anvilView.sourceModel,
            cost;
        if (sourceModel && !sourceModel.data.invalid) {
            cost = sourceModel.data.price && sourceModel.data.price.stuff ? ExGods.util.Stuff.printStuff(sourceModel.data.price.stuff) : '';
            Ext.widget('confirmdialog', {
                message: new Ext.Template(confirmText).apply({
                    cost: cost
                }),
                handler: function() {
                    ExGods.app.block();
                    me.service.command('fucina', {
                        action: 'make',
                        entry: me.service.data.fucina.current,
                        value: sourceModel.data.source_id
                    }, function(resp) {
                        ExGods.app.unblock();
                        if (resp.fucina.message) {
                            me.app.fireEvent('logmessage', resp.fucina.message);
                        } else {
                            me.service.update({
                                fucina: resp.fucina
                            });
                        }
                    });
                }
            });
        }
    },
    /**
     * @private Обработчик клика по кнопке Повторить
     */
    onReplayBtnClick: function() {
        var me = this;
        ExGods.app.block();
        me.service.command('fucina', {
            action: 'replay'
        }, function(resp) {
            ExGods.app.unblock();
            if (resp.fucina.message) {
                me.app.fireEvent('logmessage', resp.fucina.message);
            } else {
                me.service.update({
                    fucina: resp.fucina
                });
            }
        });
    },
    /**
     * @private Обработчик клика по кнопке Завершить
     */
    onFinishBtnClick: function() {
        var me = this;
        ExGods.app.block();
        me.service.command('fucina', {
            action: 'finish'
        }, function(resp) {
            ExGods.app.unblock();
            if (resp.fucina.message) {
                me.app.fireEvent('logmessage', resp.fucina.message);
            } else {
                me.service.update({
                    fucina: resp.fucina
                });
            }
        });
    },
    /**
     * @private Обработчик обновления сервиса
     */
    onServiceUpdate: function() {
        var me = this;
        if (!me.service.loadedProtos) {
            me.service.loadProcessCount = (me.service.loadProcessCount || 0) + 1;
            me.loadProtos(function() {
                if (--me.service.loadProcessCount == 0) {
                    setTimeout(function() {
                        me.service.loadedProtos = true;
                        me.service.update(me.service.data);
                    }, 0);
                }
            });
            return false;
        } else {
            delete me.service.loadedProtos;
            return true;
        }
    },
    /**
     * @private Подгрузка прототипов из данных сервиса
     */
    loadProtos: function(callback) {
        var me = this,
            paths = [
                'fucina.data.result.proto_id',
                'fucina.data.result.stuff.params.id',
                'fucina.data.work.source_data.proto_id',
                'fucina.data.source.source_data.proto_id',
                'fucina.data.source.source_data.params.id'
            ];
        ExGods.helpme.loadProtos(me.service.data, paths.join('|'), function() {
            callback();
        });
    }
});

Ext.define('ExGods.view.chests.stuff.ChestStuff', {
    extend: ExGods.stuff.Composite
});

Ext.define('ExGods.view.chests.Info', {
    extend: Ext.panel.Panel,
    alias: 'widget.chestinfo',
    id: 'chest_info',
    config: {
        plugins: [
            'skindeco'
        ]
    },
    layout: 'absolute',
    closable: true,
    width: 314,
    height: 390,
    y: 15,
    style: {
        position: 'absolute',
        zIndex: 2
    },
    itemsInRow: 4,
    rowsInPage: 3,
    initComponent: function() {
        var me = this,
            chestX = me.itemElement.el.dom.offsetLeft,
            chestWidth = me.itemElement.el.dom.offsetWidth,
            maxWidth = 840;
        me.itemsRows = [];
        me.rowTitles = [];
        me.prepareRows();
        if (chestX + chestWidth + me.width <= maxWidth) {
            me.x = chestX + chestWidth;
        } else if (chestX - me.width > 0) {
            me.x = chestX - me.width;
        } else if (chestX + me.width <= maxWidth) {
            me.x = maxWidth - me.width;
        } else {
            me.x = 0;
        }
        me.items = [
            {
                xtype: 'component',
                width: 297,
                height: 356,
                margin: 8,
                data: Ext.apply(me.record.data, {
                    page: 1
                }),
                tpl: [
                    '<div class="paper paper-tl"></div>',
                    '<div class="paper paper-tm"></div>',
                    '<div class="paper paper-tr"></div>',
                    '<div class="paper paper-mr"></div>',
                    '<div class="paper paper-br"></div>',
                    '<div class="paper paper-bm"></div>',
                    '<div class="paper paper-bl"></div>',
                    '<div class="paper paper-ml"></div>',
                    '<div class="paper paper-bg"></div>',
                    '<div class="paper-title"><h4>{label}</h4></div>',
                    '<div class="chest-description">',
                    '<p class="chest-info-text"></p>',
                    '<div class="chest-progress-h">',
                    '<div class="chest-progress-line-h"></div>',
                    '<div class="chest-progress-glow-h"></div>',
                    '<div class="chest-progress-nums-h">{open_counter}/{open_cooldown}</div>',
                    '</div>',
                    '<div class="item_info"></div>',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    '<div class="paper-title">{[this.getLabel(values)]}</div>',
                    '{[this.getRows(values)]}',
                    {
                        getLabel: function(values) {
                            return me.rowTitles[(values.page - 1) * me.rowsInPage];
                        },
                        getRows: function(values) {
                            var rows = [],
                                startRow = (values.page - 1) * me.rowsInPage,
                                i = me.rowsInPage;
                            while (i > 0) {
                                i--;
                                var html = me.itemsRows[startRow + i];
                                if (typeof html == 'function') {
                                    html = html();
                                }
                                rows.unshift(html);
                            }
                            return rows.join('');
                        }
                    }
                ]
            }
        ];
        me.config.plugins.push({
            ptype: 'pager',
            marginLeft: -31,
            marginRight: -31,
            top: 165,
            textTop: 374,
            textLeft: me.x + 95,
            total: Math.ceil(me.itemsRows.length / me.rowsInPage)
        });
        me.listeners = {
            prev: me.setPage,
            next: me.setPage,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.updateData();
        me.callParent();
        me.el.on('click', function(e) {
            me.fireEvent('show_chest_tooltip', me);
        }, me, {
            delegate: '.chest-description'
        });
    },
    setPage: function() {
        var me = this,
            curPage = me.pager.current;
        me.items.getAt(0).update(Ext.apply(me.record.data, {
            page: curPage
        }));
        me.setInfoText();
        var open_counter = me.record.get('open_counter'),
            open_cooldown = me.record.get('open_cooldown'),
            lineEl = me.el.down('.chest-progress-line-h'),
            calcW = 149,
            pos = Math.floor(open_counter * calcW / open_cooldown) + 10;
        lineEl.setWidth(pos);
        me.pager.refresh();
    },
    prepareRows: function() {
        var me = this,
            titles = me.loot.titles;
        Ext.Array.each(me.loot.items, function(items, index) {
            var l = Math.ceil(items.length / me.itemsInRow),
                i = 0;
            if (me.itemsRows.length % me.rowsInPage > 0 && me.itemsRows.length % me.rowsInPage < me.rowsInPage - 1 && titles[index] !== titles[0]) {
                var title = me.prepareTitle(titles[index]);
                if (title) {
                    me.itemsRows.push(title);
                    me.rowTitles.push(titles[index]);
                }
            } else if (me.itemsRows.length % me.rowsInPage == me.rowsInPage - 1 && titles[index] !== titles[0]) {
                //если строка последняя на странице - то добавляем пустую строку чтобы начать с новой страницы
                me.itemsRows.push('');
                me.rowTitles.push('');
            }
            for (; i < l; i++) {
                //для корректного отображения нового стаффа нужно каждый раз регистрировать DOM, поэтому возвращаю метод создания дома
                var getHtml = function(index) {
                        return [
                            '<div class="chest-info-rewards-row">',
                            new ExGods.stuff.StuffCollection({
                                stuff: items.slice(index * me.itemsInRow, (index + 1) * me.itemsInRow),
                                sorted: false
                            }).image(),
                            '</div>'
                        ].join('');
                    };
                me.itemsRows.push(getHtml.bind(me, i));
                me.rowTitles.push(titles[index]);
            }
        });
    },
    updateData: function() {
        if (!this.el) {
            return;
        }
        this.setProgress();
        this.setInfoText();
    },
    setProgress: function() {
        if (!this.el) {
            return;
        }
        var me = this,
            open_counter = me.record.get('open_counter'),
            open_cooldown = me.record.get('open_cooldown'),
            lineEl = me.el.down('.chest-progress-line-h'),
            glowEl = me.el.down('.chest-progress-glow-h'),
            numsEl = me.el.down('.chest-progress-nums-h'),
            maxW = 169,
            calcW = 149,
            pos = Math.floor(open_counter * calcW / open_cooldown) + 10;
        if (pos != maxW) {
            glowEl.setStyle('opacity', 0);
        }
        lineEl.stopAnimation();
        lineEl.animate({
            to: {
                width: pos
            },
            duration: 1000,
            callback: function() {
                numsEl.setHTML(open_counter + '/' + open_cooldown);
                if (pos == calcW + 10) {
                    glowEl.animate({
                        to: {
                            opacity: 1
                        },
                        duration: 500
                    });
                }
            }
        });
    },
    setInfoText: function() {
        if (!this.el) {
            return;
        }
        var lucky = ExGods.ref('message_client|chests_info_lucky_open_text'),
            unlucky = ExGods.ref('message_client|chests_info_unlucky_open_text'),
            open_counter = this.record.get('open_counter'),
            open_cooldown = this.record.get('open_cooldown'),
            p = this.el.down('.chest-info-text');
        if (p)  {
            p.setHTML(open_counter == open_cooldown ? lucky : unlucky);
        }
        
    },
    /**
     * метод вернет хтмл строку для отображения заголовка
     */
    prepareTitle: function(title) {
        return '<div class="paper-separator"></div><div class="paper-title">' + title + '</div>';
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        for (var i = 0; i < me.record.data.items.length; i++) {
            stuff_arr.push(me.record.data.items[i]);
        }
        for (var i = 0; i < me.record.data.main_items.length; i++) {
            stuff_arr.push(me.record.data.main_items[i]);
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [
                IMAGE_URL + 'chests/chest_progress_bar_full_h.png',
                IMAGE_URL + 'chests/chest_progress_bar_empty_h.png',
                IMAGE_URL + 'chests/chest_progress_bar_glow_h.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.chests.Container', {
    extend: Ext.panel.Panel,
    alias: 'widget.chestscontainer',
    id: 'chests_container',
    plugins: [
        'irondeco'
    ],
    margin: '3 5 7',
    chestPositions: [
        [
            97,
            27,
            215,
            184
        ],
        [
            311,
            7,
            221,
            202
        ],
        [
            506,
            93,
            286,
            266
        ],
        [
            265,
            164,
            273,
            249
        ],
        [
            16,
            172,
            245,
            242
        ]
    ],
    initComponent: function() {
        var me = this;
        me.style = {
            backgroundImage: "url(" + IMAGE_URL + me.backImg + ")"
        };
        me.html = '<div class="chests-header" style="background-image: url(' + ExGods.ref('images|chests_images').image['header_btn'] + ');"><div class="chests-close-btn"></div></div>';
        me.callParent();
        var i = 0;
        me.removeAll();
        me.store.each(function(el) {
            me.add({
                xtype: 'chest',
                record: el,
                x: me.chestPositions[i][0],
                y: me.chestPositions[i][1],
                width: me.chestPositions[i][2],
                height: me.chestPositions[i][3],
                btnOpenText: me.openText,
                btnOpenColor: me.openColor,
                btnGetText: me.getText,
                btnGetColor: me.getColor,
                glowingDelay: me.glowingDelay,
                glowingSpeed: me.glowingSpeed,
                glowingMaxBrightTime: me.glowingMaxBrightTime,
                chestAppearSpeed: Number(me.chestAppearSpeed),
                chestAppearDelay: Number(me.chestAppearDelay)
            });
            i++;
        });
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.renderBtns();
        me.el.on('click', function(e) {
            me.fireEvent('close');
        }, me, {
            delegate: '.chests-close-btn'
        });
    },
    renderBtns: function() {
        var me = this,
            openCls = me.openAllColor ? 'x-btn-txt-' + me.openAllColor : '',
            getCls = me.getAllColor ? 'x-btn-txt-' + me.getAllColor : '',
            can_take = me.store.canTake();
        me.add(/*{
                            xtype:'textbutton',
                            style:{
                                position:'absolute'
                            },
                            text:can_take ? me.getAllText : me.openAllText,
                            cls:can_take ? getCls : openCls,
                            x:631,
                            y:375,
                            itemId:'open_all_chests',
                            listeners:{
                                click:function(){this.disable()}
                            }
                        },*/
        {
            xtype: 'textbutton',
            style: {
                position: 'absolute'
            },
            text: me.closeText,
            cls: me.closeColor ? 'x-btn-txt-' + me.closeColor : '',
            x: 737,
            y: 375,
            handler: function() {
                me.fireEvent('close');
            }
        });
    },
    /**
         * Ресурсы вью предзагрузка
         */
    getResources: function() {
        var me = this,
            arr_images = [];
        var images = ExGods.ref('images|chests_images').image;
        for (var i in images) {
            arr_images.push(images[i]);
        }
        return {
            images: [
                IMAGE_URL + me.backImg,
                me.openText,
                //me.getText,
                me.closeText,
                IMAGE_URL + 'button-text-30green.png',
                IMAGE_URL + 'button-text-30.png',
                IMAGE_URL + 'chests/chest_progress_bar_glow.png',
                IMAGE_URL + 'chests/chest_progress_bar_full.png',
                IMAGE_URL + 'chests/chest_progress_bar_empty.png',
                IMAGE_URL + 'chests/chest_index.png',
                IMAGE_URL + 'ind.png',
                IMAGE_URL + 'bid/timer.png',
                IMAGE_URL + 'chests/slot_glow.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Отображение конкретного врага на арене
 */
Ext.define('ExGods.view.chests.Chest', {
    extend: Ext.panel.Panel,
    alias: 'widget.chest',
    style: {
        position: 'absolute',
        cursor: 'pointer'
    },
    hidingClasses: [
        'chest-progress',
        'chest-stuff-container',
        'chest-button-place',
        'chest-bg-glow',
        'chest-you-got',
        'chest-slot-glow'
    ],
    initComponent: function() {
        var me = this;
        me.data = me.record.data;
        me.tpl = [
            '<div class="chest-bg" style="background-image:url({[ IMAGE_URL + values.image ]});height:' + me.height + 'px">',
            '<div class="chest-bg-glow" style="background:url({[ IMAGE_URL + values.image ]}) 0 -' + me.height + 'px;height:' + me.height + 'px;opacity:0"></div>',
            '<div class="chest-progress" style="opacity:0">',
            '<div class="chest-progress-line"></div>',
            '<div class="chest-progress-glow"></div>',
            '<div class="chest-progress-nums">{open_counter}/{open_cooldown}</div>',
            '</div>',
            '<div class="chest-slot-glow" style="opacity:0"></div>',
            '<div class="chest-you-got" style="background-image: url(' + ExGods.ref('images|chests_images').image.you_got + ');opacity:0"></div>',
            '<div class="chest-stuff-container" style="opacity:0"></div>',
            '<div class="chest-button-place" id="chest_button_place_{id}" style="opacity:0"></div>',
            '</div>'
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.renderBtn();
        me.updateData();
        me.startGlowing();
        me.callParent();
        me.el.on('click', function(e) {
            if (!e.getTarget('.x-btn') && !e.getTarget('.item')) {
                me.fireEvent('chestinfo', me, me.record);
                me.record.infoShown = true;
            }
        }, me);
        me.el.on('mouseenter', function() {
            me.overed = true;
            me.setVisible();
        }, me);
        me.el.on('mouseleave', function() {
            me.overed = false;
            me.setHidden();
        }, me);
    },
    renderBtn: function() {
        var me = this,
            r = me.record,
            has_dropped_items = r.get('dropped_items').length,
            can_open = r.get('can_open'),
            openCls = me.btnOpenColor ? 'x-btn-txt-' + me.btnOpenColor : '',
            getCls = me.btnGetColor ? 'x-btn-txt-' + me.btnGetColor : '';
        me.btn = Ext.widget('textbutton', {
            renderTo: 'chest_button_place_' + r.get('id'),
            record: me.record,
            cmp: me,
            text: has_dropped_items ? me.btnGetText : me.btnOpenText,
            cls: has_dropped_items ? getCls : openCls,
            itemId: 'open_chest',
            listeners: {
                click: function() {
                    this.disable();
                }
            }
        });
    },
    updateData: function(data) {
        if (!this.el)  {
            return;
        }
        
        var me = this;
        if (data)  {
            me.record.set(data);
        }
        
        me.setBtn();
        ExGods.Resources.load(me, function() {
            me.printStuff();
            if (!me.record.get('can_take')) {
                me.setHidden([
                    'chest-you-got',
                    'chest-slot-glow'
                ], true);
            } else {
                me.setVisible([
                    'chest-you-got',
                    'chest-slot-glow'
                ], true);
                me.setHidden([
                    'chest-bg-glow'
                ], true);
            }
            me.setProgress();
            me.setImage();
            me.updateVisibility();
        });
    },
    setBtn: function() {
        var me = this,
            r = me.record,
            has_dropped_items = r.get('dropped_items').length,
            can_open = r.get('can_open'),
            openCls = me.btnOpenColor ? 'x-btn-txt-' + me.btnOpenColor : '',
            getCls = me.btnGetColor ? 'x-btn-txt-' + me.btnGetColor : '';
        if (me.btn.rendered) {
            me.btn.setText(has_dropped_items ? me.btnGetText : me.btnOpenText);
            me.btn.removeCls(has_dropped_items ? openCls : getCls);
            me.btn.addCls(has_dropped_items ? getCls : openCls);
            me.btn.setDisabled(!has_dropped_items && !can_open);
        }
    },
    updateVisibility: function() {
        var can_take = this.record.get('can_take');
        if (can_take) {
            this.setVisible();
        } else if (!this.overed) {
            this.setHidden();
        }
        if (this.record.get('is_key') && this.record.get('key_count') > 0) {
            this.setVisible([
                'chest-stuff-container'
            ]);
        }
    },
    setVisible: function(classes, instant) {
        var me = this;
        if (me.blockedAnimation)  {
            return;
        }
        
        classes = classes || me.hidingClasses;
        Ext.Array.each(classes, function(cls) {
            var el = me.el.down('.' + cls);
            if (el.dom.style.opacity == 1)  {
                return;
            }
            
            if (el.dom.className.indexOf('chest-you-got') != -1 && !me.record.get('can_take'))  {
                return;
            }
            
            if (el.dom.className.indexOf('chest-slot-glow') != -1 && !me.record.get('can_take'))  {
                return;
            }
            
            if (el.dom.className.indexOf('chest-bg-glow') != -1 && !me.record.get('can_open'))  {
                return;
            }
            
            el.stopAnimation();
            if (instant) {
                el.setStyle('opacity', 1);
            } else {
                el.animate({
                    to: {
                        opacity: 1
                    },
                    duration: me.chestAppearSpeed,
                    delay: me.chestAppearDelay
                });
            }
        });
    },
    setHidden: function(classes, instant) {
        var me = this;
        if (!me.el)  {
            return;
        }
        
        if (me.blockedAnimation)  {
            return;
        }
        
        if (!classes && (me.record.get('can_take') || me.record.infoShown))  {
            return;
        }
        
        classes = classes || me.hidingClasses;
        Ext.Array.each(classes, function(cls) {
            var el = me.el.down('.' + cls);
            if (cls == 'chest-stuff-container' && me.record.get('is_key') && me.record.get('key_count') > 0)  {
                return;
            }
            
            el.stopAnimation();
            if (instant) {
                el.setStyle('opacity', 0);
            } else {
                el.animate({
                    to: {
                        opacity: 0
                    },
                    duration: me.chestAppearSpeed,
                    delay: me.chestAppearDelay
                });
            }
        });
    },
    printStuff: function() {
        var me = this,
            r = me.record,
            html = '';
        if (r.get('dropped_items').length) {
            html += ExGods.stuff.StuffManager.image(r.get('dropped_items'));
        } else if (r.get('is_key') && r.get('key_count') > 0) {
            html += me.printKey(r.get('key'), r.get('key_count'));
        } else if (r.get('price')) {
            html += me.printPrice(r.get('price').stuff);
        } else if (r.get('is_key')) {
            html += me.printKey(r.get('key'), 0);
        }
        if (me.el) {
            me.el.down('.chest-stuff-container').setHTML(html);
        }
    },
    printKey: function(item_stuff, count) {
        var proto, img;
        if (item_stuff.type == 'timed') {
            proto = ExGods.ref('user_timed|' + item_stuff.params.id);
            img = IMAGE_URL + proto.img.img2;
        } else {
            proto = ExGods.ref('ingredients|' + item_stuff.params.id);
            img = IMAGE_URL + proto.params.images.img_2;
        }
        return [
            '<div class="chest-open-item" style="background-image:url(' + img + ')">',
            '<span class="stack-counter">' + count + '</span>',
            '</div>'
        ].join('');
    },
    printPrice: function(stuff) {
        return Ext.Array.map(stuff, function(item_stuff) {
            var proto = ExGods.ref('user_money|' + item_stuff.params.id),
                img = IMAGE_URL + proto.param.image_chest;
            return [
                '<div class="chest-open-item" style="background-image:url(' + img + ')">',
                (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>'),
                '</div>'
            ].join('');
        }).join('');
    },
    setProgress: function() {
        if (!this.el) {
            return;
        }
        var me = this,
            open_counter = me.record.get('open_counter'),
            open_cooldown = me.record.get('open_cooldown'),
            lineEl = me.el.down('.chest-progress-line'),
            glowEl = me.el.down('.chest-progress-glow'),
            numsEl = me.el.down('.chest-progress-nums'),
            maxH = 169,
            calcH = 149,
            pos = Math.floor(open_counter * calcH / open_cooldown) + 10;
        if (pos != maxH) {
            glowEl.setStyle('opacity', 0);
        }
        lineEl.stopAnimation();
        if (open_cooldown > 50) {
            lineEl.dom.style.backgroundPosition = '0 -' + (maxH - pos) + 'px';
            lineEl.dom.style.height = pos + 'px';
            lineEl.dom.style.top = (maxH - pos) + 'px';
            numsEl.setHTML(open_counter + '/' + open_cooldown);
            if (pos == calcH + 10) {
                glowEl.animate({
                    to: {
                        opacity: 1
                    },
                    duration: 500
                });
            }
        } else {
            lineEl.animate({
                to: {
                    height: pos,
                    top: maxH - pos
                },
                duration: 1000,
                callback: function() {
                    numsEl.setHTML(open_counter + '/' + open_cooldown);
                    if (pos == calcH + 10) {
                        glowEl.animate({
                            to: {
                                opacity: 1
                            },
                            duration: 500
                        });
                    }
                }
            });
        }
    },
    setImage: function() {
        var me = this,
            el = me.el.down('.chest-bg'),
            posY;
        if (me.record.get('can_take')) {
            posY = 0;
        } else if (me.record.get('can_open')) {
            posY = me.height * 2;
        } else {
            posY = me.height * 3;
        }
        el.setStyle('background-position', '0 -' + posY + 'px');
    },
    startGlowing: function() {
        var me = this;
        me.glowingInterval = setInterval(function() {
            if (!me.overed && !me.record.infoShown && me.record.get('can_open')) {
                if (!me.el || !me.el.dom)  {
                    return;
                }
                
                var el = me.el.dom.querySelector('.chest-bg-glow');
                if (!el)  {
                    return clearInterval(me.glowingInterval);
                }
                
                var glowingSpeed = Number(me.glowingSpeed),
                    its = Math.ceil(Number(me.glowingSpeed) / 40),
                    //40 - 1000/25 чтобы было 25 fps
                    i = its,
                    value = 1 / its,
                    setOpacity = function(positive, i, callback) {
                        el.style.opacity = Math.max(0, Math.min(1, Number(el.style.opacity) + value * (positive ? 1 : -1)));
                        i--;
                        if (i > 0) {
                            setTimeout(function() {
                                setOpacity(positive, i, callback);
                            }, 40);
                        } else if (callback) {
                            callback();
                        }
                    };
                setOpacity(true, i, function() {
                    setTimeout(function() {
                        i = its;
                        setOpacity(false, i);
                    }, Number(me.glowingMaxBrightTime) || 0);
                });
            }
        }, me.glowingDelay);
    },
    onDestroy: function() {
        clearInterval(this.glowingInterval);
        this.callParent();
    },
    blockAnimation: function() {
        this.blockedAnimation = true;
    },
    unblockAnimation: function() {
        this.blockedAnimation = false;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            r = me.record,
            stuff_arr = [],
            arr_images = [];
        if (r.get('dropped_items').length) {
            stuff_arr = stuff_arr.concat(r.get('dropped_items'));
        } else if (r.get('is_key') && r.get('key_count') > 0) {
            stuff_arr = stuff_arr.concat(r.get('key'));
        } else if (r.get('price')) {
            stuff_arr = stuff_arr.concat(r.get('price').stuff);
        }
        var main_items__ = r.get('main_items');
        if (main_items__.length) {
            stuff_arr = stuff_arr.concat(main_items__);
        }
        return {
            stuff: [],
            images: [
                IMAGE_URL + r.data.image
            ].concat(arr_images)
        };
    }
});

/**
 * Кнопка в виде сундука в шапке игры
 */
Ext.define('ExGods.view.chests.HeaderButton', {
    extend: Ext.Component,
    alias: 'widget.chestsheaderbutton',
    id: 'chests-header-button',
    width: 92,
    height: 69,
    isDisabled: false,
    /**
     * @cfg {Array} Список восстанавливаемых хар-к, которые являются ключами к сундукам.
     */
    timedWithKeys: [
        'goods'
    ],
    /**
     * Счетчик на кнопке
     */
    counter: 0,
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="glow-bg"></div>',
            '<div class="counter {[ values.counter > 0 ? "" : "hidden" ]}">{counter}</div>',
            '<div class="timer"></div>'
        ];
        me.data = {
            counter: me.counter
        };
        me.mon(ExGods.util.Timers, 'chests-header-button-timer-expire', me.onNextKeyTimerExpire, me);
        me.mon(ExGods.app.user, 'timedchanged', me.onTimedChanged, me);
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.on('click', function() {
            if (!me.isDisabled) {
                me.fireEvent('click');
            }
        });
        me.setDisabled(me.isDisabled);
        if (me.counter == 0) {
            me.showNextKeyTimer();
        } else {
            me.hideNextKeyTimer();
        }
    },
    /**
     * Заблокировать кнопку
     */
    setDisabled: function(disabled) {
        var me = this;
        me.isDisabled = disabled;
        if (me.isDisabled) {
            me.stopGlow();
            me.el.addCls('disabled');
        } else {
            me.startGlow();
            me.el.removeCls('disabled');
        }
    },
    /**
     * Выставить счетчик
     */
    setCounter: function(counter) {
        var me = this,
            counterEl = me.el.down('.counter');
        if (me.counter === counter) {
            return;
        }
        me.counter = counter;
        if (me.counter > 0) {
            me.hideNextKeyTimer();
            counterEl.removeCls('hidden');
            counterEl.setHTML(me.counter);
        } else {
            me.showNextKeyTimer();
            counterEl.addCls('hidden');
        }
    },
    /**
     * @private
     */
    showNextKeyTimer: function() {
        var me = this,
            el = Ext.get(me.el.down('.timer')),
            timed = ExGods.app.user.data.timed[me.timedWithKeys[0]],
            timedDate = timed ? timed[3] : null;
        if (timedDate && timedDate - Date.now() > 0) {
            el.setHTML(ExGods.util.Timers.printTimer('rest', 'chests-header-button-timer', timedDate, {
                needNormalized: false
            }));
            el.removeCls('hidden');
        } else {
            me.hideNextKeyTimer();
        }
    },
    /**
     * @private
     */
    hideNextKeyTimer: function() {
        var me = this,
            el = Ext.get(me.el.down('.timer'));
        el.setHTML('');
        el.addCls('hidden');
    },
    /**
     * @private
     */
    onNextKeyTimerExpire: function() {
        var me = this;
        me.hideNextKeyTimer();
    },
    /**
     * @private Обработчик изменения таймедов юзера.
     * Обновляю время таймера, если нужно
     */
    onTimedChanged: function() {
        var me = this;
        if (me.counter == 0) {
            me.showNextKeyTimer();
        }
    },
    /**
     * @private Запускает свечение
     */
    startGlow: function() {
        var me = this,
            ticktime = 100,
            time1 = parseFloat(ExGods.ref('constants|chests_button_anim_to_show').value),
            time2 = parseFloat(ExGods.ref('constants|chests_button_anim_pause').value),
            time3 = parseFloat(ExGods.ref('constants|chests_button_anim_to_hide').value),
            phases = [
                {
                    from: 0,
                    to: 1,
                    dur: time1,
                    perTick: 1 / (time1 / ticktime)
                },
                {
                    from: 1,
                    to: 1,
                    dur: time2,
                    perTick: 0
                },
                {
                    from: 1,
                    to: 0,
                    dur: time3,
                    perTick: -1 / (time3 / ticktime)
                },
                {
                    from: 0,
                    to: 0,
                    dur: time2,
                    perTick: 0
                }
            ],
            curPhase = 0,
            curTime = 0,
            curValue = phases[curPhase].from,
            el = me.el.down('.glow-bg');
        if (me.glowInterval) {
            return;
        }
        me.glowInterval = setInterval(function() {
            curTime += ticktime;
            if (phases[curPhase].dur > curTime) {
                curValue += phases[curPhase].perTick;
                el.setStyle('opacity', curValue);
            } else {
                el.setStyle('opacity', phases[curPhase].to);
                curPhase = curPhase == 3 ? 0 : curPhase + 1;
                curTime = 0;
                curValue = phases[curPhase].from;
            }
        }, ticktime);
    },
    /**
     * @private Останавливает свечение
     */
    stopGlow: function() {
        var me = this;
        clearInterval(me.glowInterval);
        me.glowInterval = null;
    }
});

/**
 * Модель сундука
 */
Ext.define('ExGods.model.Chest', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'id',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'image',
            type: 'string'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            // флаг возможности открыть сундук
            name: 'can_open',
            type: 'int',
            convert: function(v, r) {
                if (v && r.get('is_key') && r.get('key_count') == 0 && !r.get('price')) {
                    return 0;
                } else  {
                    return v;
                }
                
            }
        },
        {
            // флаг возможности забрать содержимое сундука
            name: 'can_take',
            type: 'int'
        },
        {
            // выпавшие предметы
            name: 'dropped_items',
            type: 'auto',
            convert: function(v, r) {
                return v || [];
            }
        },
        {
            // открывается ли ключем
            name: 'is_key',
            type: 'int'
        },
        {
            // stuff ключа
            name: 'key',
            type: 'auto'
        },
        {
            // предметы, которые могут упасть
            name: 'items',
            type: 'auto',
            convert: function(v, r) {
                var items = [],
                    main_items = [];
                Ext.Array.sort(v, function(a, b) {
                    return a.l_order > b.l_order ? 1 : -1;
                });
                Ext.Array.each(v, function(el) {
                    if (el.is_main == 1) {
                        main_items.push(el.stuff);
                    } else {
                        items.push(el.stuff);
                    }
                });
                r.set('main_items', main_items);
                return items;
            }
        },
        {
            // главная награда
            name: 'main_items',
            type: 'auto'
        },
        {
            // количество ключей
            name: 'key_count',
            type: 'int'
        },
        {
            // сортировка
            name: 'l_order',
            type: 'int'
        },
        {
            // сколько раз надо открыть сундук до "супероткрытия"
            name: 'open_cooldown',
            type: 'int'
        },
        {
            // количество открытий
            name: 'open_counter',
            type: 'int'
        },
        {
            // стоимость открытия
            name: 'price',
            type: 'auto'
        }
    ]
});

/**
 * Хранилище сундуков
 */
Ext.define('ExGods.store.Chests', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Chest',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'l_order',
            direction: 'DESC'
        }
    ],
    canOpen: function() {
        var ret = 0;
        this.each(function(record) {
            ret += record.get('can_open');
        });
        return !!ret;
    },
    canOpenByKey: function() {
        var ret = 0;
        this.each(function(record) {
            ret += record.get('key_count');
        });
        return !!ret;
    },
    canTake: function() {
        var ret = 0;
        this.each(function(record) {
            ret += record.get('can_take');
        });
        return !!ret;
    },
    hasMultipleDrop: function() {
        var has = false;
        this.each(function(record) {
            if (record.get('dropped_items').length > 1)  {
                has = true;
            }
            
        });
        return has;
    },
    getTotalKeysCount: function() {
        var count = 0;
        this.each(function(record) {
            if (record.get('is_key'))  {
                count += record.get('key_count');
            }
            
        });
        return count;
    },
    getAllDroppedItems: function() {
        var dropped = [];
        this.each(function(record) {
            [].push.apply(dropped, record.get('dropped_items'));
        });
        return dropped;
    }
});

/**
 * Контроллер сундуков
 */
Ext.define('ExGods.controller.Chests', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    views: [
        'chests.Container',
        'chests.Chest',
        'chests.Info',
        'chests.HeaderButton'
    ],
    stores: [
        'Chests'
    ],
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'Chests:'
    },
    init: function(app) {
        var me = this;
        me.service = ExGods.Services.get('chests');
        if (me.service.on) {
            me.service.on('update', me.onServiceUpdate, me);
        }
        me.app.getChestsStore().loadRawData(me.service.data.chests);
        me.control({
            '#open_chest': {
                click: me.onChestBtnClick
            },
            'chest': {
                chestinfo: me.onChestInfo
            },
            'chestinfo': {
                show_chest_tooltip: me.showChestTooltip
            }
        });
        // ключи, как ингредиенты с типом "Сундуки"
        me.user.on('ingredientschanged', me.onIngredientsChanged, me);
        // ключи как timed
        // me.user.on('goodschanged', me.onGoldTriesChanged, me);
        // me.gold_tries = Math.floor(me.user.get('timed').goods[0]);
        me.user.on('gold_chest_trieschanged', me.onGoldTriesChanged, me);
        me.gold_tries = Math.floor(me.user.get('timed').gold_chest_tries[0]);
        ExGods.stuff.StuffManager.register({
            'chest_stuff': ExGods.view.chests.stuff.ChestStuff
        });
        ExGods.Components.addComponentInitializer('chests', me.initChestsComponent, me);
    },
    onLaunch: function() {
        var me = this;
        me.initHeaderButton();
    },
    onIngredientsChanged: function() {
        var me = this;
        if (me.cmp && me.cmp.isVisible()) {
            me.service.update();
        }
    },
    onGoldTriesChanged: function(timed) {
        var me = this,
            cur_tries = me.gold_tries,
            value = Math.floor(timed[0]);
        //текущее целое значение
        if (value == cur_tries)  {
            return;
        }
        
        me.gold_tries = value;
        if (me.cmp && me.cmp.isVisible() && cur_tries < value) {
            me.service.update();
        }
    },
    initHeaderButton: function() {
        var me = this,
            store = me.app.getChestsStore(),
            btn,
            getTotalKeysCount = function(src) {
                var count = 0,
                    timedWithKeys = [
                        'gold_chest_tries'
                    ];
                if (src == 'store') {
                    count = store.getTotalKeysCount();
                } else {
                    timedWithKeys.forEach(function(name) {
                        if (me.user.data.timed[name]) {
                            count += Math.floor(me.user.data.timed[name][0]);
                        }
                    });
                    count += me.user.getIngredientsGroupCount('Сундуки');
                    count += me.user.getIngredientsGroupCount('Chests');
                }
                return count;
            };
        btn = Ext.widget('chestsheaderbutton', {
            renderTo: 'header',
            isDisabled: me.user.isBattle(),
            counter: getTotalKeysCount('store'),
            timedWithKeys: [
                'gold_chest_tries'
            ],
            listeners: {
                click: function() {
                    ExGods.ClientActions.createAndInvoke({
                        actionId: me.service.id
                    });
                }
            }
        });
        store.on('update', function() {
            btn.setCounter(getTotalKeysCount('store'));
        });
        store.on('datachanged', function() {
            btn.setCounter(getTotalKeysCount('store'));
        });
        // ключи, как ингредиенты с типом "Сундуки"
        me.user.on('ingredientschanged', function() {
            btn.setCounter(getTotalKeysCount());
        });
        // ключи как timed
        ExGods.app.user.on('gold_chest_trieschanged', function() {
            btn.setCounter(getTotalKeysCount());
        });
    },
    onServiceUpdate: function() {
        var me = this;
        Ext.Array.each(me.service.data.chests, function(chest) {
            me.app.getChestsStore().each(function(record) {
                if (record.get('l_order') == chest.l_order) {
                    record.set(chest);
                    //этот параметр зависит от других параметров, его значение проставляется в методе convert поля модели
                    //поэтому делаю set параметра после сета всех остальных
                    record.set('can_open', chest.can_open);
                }
            });
            if (me.cmp && me.cmp.isVisible()) {
                me.cmp.items.each(function(item) {
                    if (item.xtype == 'chest' && item.record.get('l_order') == chest.l_order) {
                        ExGods.helpme.loadProtosFromStuff(chest.dropped_items, function() {
                            item.updateData(chest);
                            if (me.chestInfo)  {
                                me.chestInfo.updateData();
                            }
                            
                        });
                    }
                });
            }
        });
    },
    onChestBtnClick: function(btn) {
        var me = this,
            can_take = btn.record.get('can_take');
        btn.cmp.blockAnimation();
        me.service.suspendEvents();
        me.service.command(can_take ? 'chest_take' : 'chest_open', {
            id: btn.record.get('id')
        }, function(data) {
            if (data && data.chests) {
                var newData = Ext.Array.findBy(data.chests, function(el) {
                        return el.l_order == btn.record.get('l_order');
                    });
                ExGods.helpme.loadProtosFromStuff(newData.dropped_items, function() {
                    ExGods.Resources.loadStuff(newData.dropped_items, function() {
                        btn.cmp.unblockAnimation();
                        btn.cmp.updateData(newData);
                        if (me.chestInfo)  {
                            me.chestInfo.updateData();
                        }
                        
                    });
                });
            } else {
                btn.cmp.updateData();
            }
            me.service.resumeEvents();
        });
    },
    onChestInfo: function(chestView, record) {
        var me = this,
            items = record.get('items'),
            main_items = record.get('main_items'),
            rows = [];
        ExGods.app.block();
        if (me.chestInfo) {
            me.chestInfo.close();
        }
        me.chestInfo = Ext.widget('chestinfo', {
            itemElement: chestView.el,
            autoShow: false,
            loot: {
                items: [
                    main_items,
                    items
                ],
                titles: [
                    ExGods.getMsgByKey('chest_main_reward_title'),
                    ExGods.getMsgByKey('chest_reward_title')
                ]
            },
            record: record,
            onDestroy: function() {
                record.infoShown = false;
                chestView.setHidden();
                me.chestInfo = false;
                if (me.chesttooltip)  {
                    me.chesttooltip.close();
                }
                
                this.callParent();
            }
        });
        ExGods.Resources.load(me.chestInfo, function() {
            me.cmp.add(me.chestInfo);
            ExGods.app.unblock();
        });
    },
    showChestTooltip: function(chestinfo) {
        var me = this,
            el = chestinfo.el.down('.chest-description');
        me.chesttooltip = Ext.widget('parchmentwindow', {
            itemElement: el,
            html: [
                '<div class="chest-info-tooltip-text">',
                ExGods.ref('message_client|chest_info_tooltip'),
                '</div>'
            ].join(''),
            listeners: {
                close: function() {
                    me.chesttooltip = false;
                }
            }
        });
    },
    initChestsComponent: function(config, id) {
        var me = this,
            store = me.app.getChestsStore();
        me.onServiceUpdate();
        me.cmp = Ext.widget('chestscontainer', Ext.applyIf({
            service: me.service,
            store: store,
            listeners: {
                close: {
                    fn: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            if (me.chestInfo)  {
                                me.chestInfo.close();
                            }
                            
                            me.wnd.close();
                        }, {
                            img: config.loadImg
                        });
                        return false;
                    },
                    single: true
                }
            }
        }, config));
        me.wnd = Ext.widget('window1', {
            id: id,
            items: [
                me.cmp
            ],
            autoShow: false,
            getResources: function() {
                var me = this;
                return {
                    images: [
                        config.loadImg
                    ]
                };
            }
        });
        ExGods.app.getController('Location').maskLocation(function() {
            // подгрузка ресурсов
            ExGods.Resources.load(me.wnd, function() {
                ExGods.Resources.loadStuff(store.getAllDroppedItems(), function() {
                    me.wnd.show();
                    if (store.hasMultipleDrop())  {
                        me.showDropCmp();
                    }
                    
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.loadImg
        });
        return me.wnd;
    }
});

/**
 * Модель задания гильдии
 */
Ext.define('ExGods.model.GuildQuest', {
    extend: Ext.data.Model,
    idProperty: 'task_id',
    fields: [
        {
            name: 'task_id',
            type: 'int'
        },
        {
            name: 'create_date',
            type: 'auto'
        },
        {
            name: 'done_date',
            type: 'auto'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description_short',
            type: 'string'
        },
        {
            name: 'image',
            type: 'string'
        },
        {
            name: 'short_title',
            type: 'string'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'guild_id',
            type: 'int'
        },
        {
            name: 'params',
            type: 'auto'
        },
        {
            name: 'stages',
            type: 'auto'
        },
        {
            //список участников гильдии, принимавших участике в квесте
            name: 'pcp',
            type: 'auto',
            convert: function(v, r) {
                if (!v)  {
                    return [];
                }
                
                // var i = v.length;
                // while(i--){
                //  //TODO удалить лишних. Но вроде бы лишние даже не приходят
                //  //if(v[i])
                // }
                v.sort(function(a, b) {
                    return Number(a.count) > Number(b.count) ? -1 : 1;
                });
                return v;
            }
        },
        {
            name: 'expanded',
            type: 'boolean'
        }
    ]
});

/**
 * Модель запроса к гильдии
 */
Ext.define('ExGods.model.GuildRaid', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'counter',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'image',
            type: 'string'
        },
        {
            name: 'image2',
            type: 'string'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'achievement',
            type: 'auto'
        },
        {
            name: 'l_order',
            type: 'int'
        },
        {
            name: 'empty',
            type: 'boolean'
        },
        {
            name: 'short_description',
            type: 'string'
        },
        {
            name: 'rewards',
            type: 'auto'
        }
    ],
    isComplete: function() {
        return this.get('counter') && this.get('counter') > 0;
    }
});

/**
 * Модель запроса к гильдии
 */
Ext.define('ExGods.model.GuildRequest', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'id',
            type: 'int'
        },
        {
            name: 'current_count',
            type: 'int',
            convert: function(v, r) {
                r.set('left_count', r.get('max_count') - v);
                return Number(v);
            }
        },
        {
            name: 'owner',
            type: 'auto'
        },
        {
            name: 'max_count',
            type: 'int'
        },
        {
            name: 'left_count',
            type: 'int'
        },
        {
            name: 'type',
            type: 'int',
            convert: function(v, r) {
                var ref = ExGods.ref('guild_request_types|' + v);
                r.set('label', ref.label);
                r.set('type_request', ref.type);
                return Number(v);
            }
        },
        {
            name: 'type_request',
            type: 'string'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            name: 'timeout',
            type: 'int',
            convert: function(v, r) {
                if (v && !r.timerStarted)  {
                    r.startTimer();
                }
                
                return Number(v);
            }
        },
        {
            name: 'index',
            type: 'int'
        }
    ],
    isFull: function() {
        return this.get('owner') ? this.get('current_count') == this.get('max_count') : false;
    },
    isUserOwner: function() {
        return this.get('owner') ? this.get('owner').display_title == ExGods.app.getUser().get('display_title') : false;
    },
    startTimer: function() {
        this.timerStarted = true;
        ExGods.util.Ticker.addListener(this.updateTimeout, this);
    },
    updateTimeout: function() {
        var left = this.get('timeout');
        left--;
        if (left <= 0) {
            ExGods.util.Ticker.removeListener(this.updateTimeout, this);
            this.timerStarted = false;
        }
        this.set('timeout', Math.max(left, 0));
    }
});

/**
 * Модель группы к гильдии
 */
Ext.define('ExGods.model.GuildGroup', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'id',
            type: 'int'
        },
        {
            name: 'creator',
            type: 'string'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'level',
            type: 'int'
        },
        {
            name: 'users',
            type: 'auto'
        }
    ]
});

Ext.define('ExGods.view.guild.Container', {
    extend: Ext.container.Container,
    alias: 'widget.guildcontainer',
    id: 'guild_container',
    layout: 'card'
});

/**
 * Окошко с информацией. Содержет картинку, нзвание, и описание.
 */
Ext.define('ExGods.view.guild.RaidInfoWindow', {
    extend: ExGods.view.CommonDetailsWindow,
    alias: 'widget.raidinfowindow',
    initComponent: function() {
        var me = this,
            data = me.record.data;
        me.config.data = {
            image: IMAGE_URL + (me.complete ? data.image : data.image2),
            label: data.title,
            description: data.description
        };
        if (me.show_rewards) {
            me.config.data.rows = [
                {
                    title: ExGods.ref('message_client|view_battle_rewards_rewardstitle'),
                    content: ExGods.stuff.StuffManager.image(data.rewards)
                }
            ];
        }
        me.callParent(arguments);
    }
});

Ext.define('ExGods.view.guild.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.guildtabpanel',
    bodyPadding: '0 10 8 8',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.items = [];
        //guild info
        me.items.push({
            xtype: 'guildinfo',
            guild: me.guild,
            service: me.service,
            tabConfig: {
                tooltip: cfg.tab_info_tt,
                icon: IMAGE_URL + cfg.tab_info_img
            }
        });
        //guild requests
        me.items.push({
            xtype: 'guildhelp',
            guild: me.guild,
            service: me.service,
            myRequestsStore: me.myRequestsStore,
            requestsStore: me.requestsStore,
            tabConfig: {
                id: 'guild_help_tab',
                tooltip: cfg.tab_req_tt,
                icon: IMAGE_URL + cfg.tab_req_img
            }
        });
        //guild shop
        if (Number(me.service.data.shop_service_id)) {
            me.items.push({
                xtype: 'guildshop',
                guild: me.guild,
                service: me.service,
                tabConfig: {
                    tooltip: cfg.tab_shop_tt,
                    icon: IMAGE_URL + cfg.tab_shop_img
                }
            });
        }
        //guild quests
        me.items.push({
            xtype: 'guildquests',
            guild: me.guild,
            service: me.service,
            store: me.questsStore,
            tabConfig: {
                tooltip: cfg.tab_quest_tt,
                icon: IMAGE_URL + cfg.tab_quest_img
            }
        });
        //guild groups
        me.items.push({
            xtype: 'guildgroups',
            guild: me.guild,
            service: me.service,
            groupsStore: me.groupsStore,
            tabConfig: {
                tooltip: cfg.tab_group_tt,
                icon: IMAGE_URL + cfg.tab_group_img
            }
        });
        //guild raids
        me.items.push({
            xtype: 'guildraids',
            guild: me.guild,
            service: me.service,
            store: me.raidsStore,
            tabConfig: {
                tooltip: cfg.tab_raids_tt,
                icon: IMAGE_URL + cfg.tab_raids_img
            }
        });
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            cfg = me.service.init_config;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + cfg.tab_info_img,
                IMAGE_URL + cfg.tab_req_img,
                IMAGE_URL + cfg.tab_shop_img,
                IMAGE_URL + cfg.tab_quest_img,
                IMAGE_URL + cfg.tab_group_img,
                IMAGE_URL + cfg.tab_raids_img
            ].concat(arr_images)
        };
    }
});

/**
 * Модель гильдии
 */
Ext.define('ExGods.model.Guild', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'id',
            type: 'int'
        },
        {
            name: 'current_count',
            type: 'int',
            convert: function(v, r) {
                r.set('left_count', r.get('max_count') - v);
                return v;
            }
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            //глава гильдии
            name: 'head',
            type: 'auto'
        },
        {
            name: 'max_count',
            type: 'int'
        },
        {
            name: 'left_count',
            type: 'int'
        },
        {
            name: 'open',
            type: 'int'
        },
        {
            name: 'tag',
            type: 'string'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'bids',
            type: 'auto'
        },
        {
            name: 'users',
            type: 'auto',
            convert: function(v, r) {
                if (!v)  {
                    return v;
                }
                
                if (!r.guildMembers) {
                    r.guildMembers = Ext.create('ExGods.store.GuildMembers', {
                        guild: r
                    });
                }
                setTimeout(function() {
                    r.guildMembers.loadRawData(v.concat([
                        r.get('head')
                    ].concat(r.get('bids') || [])));
                }, 0);
                return r.guildMembers;
            }
        }
    ],
    isFull: function() {
        return this.get('current_count') == this.get('max_count');
    },
    isUserHead: function() {
        return this.get('head').display_title == ExGods.app.getUser().get('display_title');
    },
    getMembersCount: function() {
        var bids = this.get('bids'),
            bidsCount = bids ? bids.length : 0;
        return this.get('users').getCount() - bidsCount;
    }
});

/**
 * Хранилище гильдий
 */
Ext.define('ExGods.store.Guilds', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Guild',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'left_count',
            direction: 'ASC'
        }
    ],
    getUserGuild: function() {
        if (ExGods.app.getUser().getGuild())  {
            return this.getAt(0);
        }
        
    }
});

/**
 * Модель члена гильдии
 */
Ext.define('ExGods.model.GuildMember', {
    extend: ExGods.model.BasicUser,
    fields: [
        {
            name: 'guild_points',
            type: 'int'
        },
        {
            name: 'isBid',
            type: 'boolean'
        },
        {
            name: 'guild_noob',
            type: 'int'
        },
        {
            // данные гильдии
            name: 'guild',
            type: 'auto',
            convert: function(v) {
                if (typeof v != 'object') {
                    return '';
                }
                return v;
            }
        },
        {
            // флаг - может ли глава гильдии отправить сообщение через соц.сеть члену гильдии
            name: 'can_snet_notice_inactive',
            type: 'int'
        },
        {
            // инфо соц.сети члена гильдии (user_id, social_net, social_net_id)
            name: 'social',
            type: 'auto'
        }
    ]
});

/**
 * Хранилище участников гильдии
 */
Ext.define('ExGods.store.GuildMembers', {
    extend: Ext.data.Store,
    model: 'ExGods.model.GuildMember',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'isBid',
            direction: 'DESC'
        },
        {
            property: 'online',
            direction: 'DESC'
        },
        {
            property: 'guild_points',
            direction: 'DESC'
        }
    ],
    constructor: function(config) {
        var me = this;
        Ext.apply(me.config, config);
        me.config.sorters.push({
            sorterFn: function(m1, m2) {
                if (!me.config.guild)  {
                    return 0;
                }
                
                var title = me.config.guild.get('head').display_title,
                    v = 0;
                if (m1.get('display_title') == title)  {
                    v = -1;
                }
                
                if (m2.get('display_title') == title)  {
                    v = 1;
                }
                
                return v;
            }
        });
        me.callParent(arguments);
    }
});

/**
 * Хранилище гильдейской группы онлайн
 */
Ext.define('ExGods.store.GuildGroupOnlineList', {
    extend: ExGodsCore.store.ChatContacts,
    model: 'ExGods.model.BasicUser'
});

/**
 * Хранилище участников гильдии
 */
Ext.define('ExGods.store.GuildRaids', {
    extend: Ext.data.Store,
    model: 'ExGods.model.GuildRaid',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'l_order',
            direction: 'ASC'
        }
    ],
    loadRawData: function(data) {
        var me = this,
            i = data.length,
            addRewards = function(recData) {
                var i = recData.achievement.stages.length,
                    rewards = [];
                while (i--) {
                    rewards = rewards.concat(recData.achievement.stages[i].rewards);
                }
                recData.rewards = rewards;
            };
        while (i--) {
            addRewards(data[i]);
        }
        me.callParent(arguments);
    }
});

/**
 * Хранилище запросов гильдии
 */
Ext.define('ExGods.store.GuildRequests', {
    extend: Ext.data.Store,
    model: 'ExGods.model.GuildRequest',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            sorterFn: function(m1, m2) {
                var v = 0;
                if (m1.get('owner'))  {
                    v = -1;
                }
                
                if (m2.get('owner'))  {
                    v = 1;
                }
                
                return v;
            }
        },
        {
            property: 'timeout',
            direction: 'ASC'
        }
    ]
});

/**
 * Хранилище групп гильдии
 */
Ext.define('ExGods.store.GuildGroups', {
    extend: Ext.data.Store,
    model: 'ExGods.model.GuildGroup',
    proxy: {
        type: 'memory'
    }
});

Ext.define('ExGods.view.guild.Search', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildsearch',
    id: 'guild_search',
    layout: 'fit',
    padding: '6 10 12',
    margin: 4,
    plugins: [
        'paperdeco'
    ],
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-title"><h4>' + cfg.search_title + '</h4></div>'
            },
            {
                dock: 'top',
                xtype: 'form',
                layout: {
                    type: 'hbox',
                    pack: 'center',
                    align: 'center'
                },
                margin: '3 8',
                items: [
                    {
                        xtype: 'textfield',
                        ui: 'guild',
                        enableKeyEvents: true,
                        emptyText: cfg.search_empty_text,
                        margin: 2,
                        width: 180
                    },
                    {
                        xtype: 'radiogroup',
                        ui: 'guild',
                        layout: 'hbox',
                        items: [
                            {
                                boxLabel: cfg.search_radio_all_guilds,
                                inputValue: 0,
                                name: 'guild_type',
                                checked: true,
                                width: 120
                            },
                            {
                                boxLabel: cfg.search_radio_open_guilds,
                                inputValue: 1,
                                name: 'guild_type',
                                width: 120
                            },
                            {
                                boxLabel: cfg.search_radio_closed_guilds + '<span class="closed-guild"></span>',
                                inputValue: 2,
                                name: 'guild_type',
                                width: 120
                            }
                        ]
                    },
                    {
                        xtype: 'combo',
                        ui: 'guild',
                        store: Ext.create('Ext.data.Store', {
                            fields: [
                                'value',
                                'label'
                            ],
                            data: [
                                {
                                    value: 'ASC',
                                    label: cfg.search_combo_asc
                                },
                                {
                                    value: 'DESC',
                                    label: cfg.search_combo_desc
                                }
                            ]
                        }),
                        value: 'ASC',
                        editable: false,
                        queryMode: 'local',
                        displayField: 'label',
                        valueField: 'value',
                        margin: 2,
                        width: 180
                    }
                ]
            },
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            },
            {
                dock: 'bottom',
                xtype: 'panel',
                margin: '0 10 10 5',
                height: 43,
                items: [
                    {
                        xtype: 'component',
                        padding: '8 5',
                        height: 48,
                        style: {
                            display: 'table-cell',
                            verticalAlign: 'middle'
                        },
                        html: cfg.search_create_guild_description
                    }
                ],
                dockedItems: [
                    {
                        dock: 'right',
                        xtype: 'textbutton',
                        itemId: 'show_create_form',
                        text: cfg.search_create_guild_btn,
                        cls: 'no_border_double'
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.items = [
            {
                xtype: 'guildslist',
                noEmpty: true,
                store: me.store
            }
        ];
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'combobox_btn.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.CreateForm', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildcreate',
    id: 'guild_create',
    layout: 'fit',
    padding: '0 0 8 0',
    margin: 4,
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.guildOptions = {};
        me.items = [
            {
                xtype: 'form',
                plugins: [
                    'paperdeco'
                ],
                padding: '6 10 12',
                margin: '0 0 -4 0',
                items: [
                    {
                        xtype: 'component',
                        html: [
                            '<div class="paper-title"><h4>' + cfg.create_title + '</h4></div>',
                            '<p class="guild-create-description">' + cfg.create_description + '</p>',
                            '<div class="paper-separator"></div>'
                        ]
                    },
                    {
                        xtype: 'textfield',
                        fieldLabel: cfg.create_title_field,
                        //maxLength:500,
                        labelWidth: 110,
                        width: 410,
                        //allowBlank:false,
                        margin: '10 0 0 10',
                        name: 'title'
                    },
                    {
                        xtype: 'textfield',
                        fieldLabel: cfg.create_tag_field,
                        //maxLength:10,
                        labelWidth: 110,
                        width: 235,
                        //allowBlank:false,
                        margin: '10 0 0 10',
                        name: 'tag'
                    },
                    {
                        xtype: 'textarea',
                        fieldLabel: cfg.create_description_field,
                        maxLength: 1500,
                        labelWidth: 110,
                        width: 725,
                        height: 100,
                        name: 'description',
                        margin: '10 0 10 10'
                    },
                    {
                        xtype: 'component',
                        html: '<div class="paper-separator"></div>'
                    },
                    {
                        xtype: 'radiogroup',
                        margin: '10 0 10 10',
                        layout: 'vbox',
                        minWidth: 500,
                        items: [
                            {
                                boxLabel: cfg.create_option_open_guild,
                                inputValue: 0,
                                minWidth: 500,
                                name: 'options',
                                checked: true
                            }
                        ].concat(Ext.Array.map(me.service.data.options, function(opt, i) {
                            var label = opt.label;
                            if (opt.price && opt.price.length) {
                                label += ExGods.util.Stuff.printStuff(opt.price);
                            }
                            if (opt.description) {
                                label += '<div class="item_info" data-option_id="' + opt.entry + '"></div>';
                                me.guildOptions[opt.entry] = opt.description;
                            }
                            return {
                                minWidth: 500,
                                boxLabel: label,
                                inputValue: opt.entry,
                                name: 'options'
                            };
                        }))
                    }
                ]
            }
        ];
        me.buttons = {
            defaultType: 'textbutton',
            items: [
                {
                    text: cfg.create_create_btn,
                    itemId: 'create_guild',
                    minWidth: 100,
                    margin: '0 5'
                },
                {
                    text: cfg.create_back_btn,
                    itemId: 'back_to_guild_search',
                    minWidth: 100,
                    margin: '0 5',
                    cls: 'x-btn-txt-red'
                }
            ]
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent();
        me.el.on('click', function(e) {
            var optEl = e.target,
                desc = me.guildOptions[optEl.dataset.option_id];
            me.fireEvent('optioninfoclick', me, optEl, desc);
        }, me, {
            delegate: '.item_info'
        });
    },
    onShow: function() {
        var me = this;
        me.callParent();
        me.items.getAt(0).items.getAt(1).inputEl.focus();
    }
});

Ext.define('ExGods.view.guild.WaitBid', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildwait',
    id: 'guild_wait',
    layout: 'fit',
    padding: '6 10 12',
    margin: 4,
    plugins: [
        'paperdeco'
    ],
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                itemId: 'guild_description',
                data: me.service.data.guild,
                tpl: [
                    '<div class="paper-title"><h4>{[this.getTitleTpl(values)]}{[this.getClosedHTML(values)]}</h4></div>',
                    '<div class="guild-info-description">',
                    '{description}',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    {
                        getClosedHTML: function(values) {
                            if (!values.open) {
                                return '<span class="closed-guild"></span>';
                            } else {
                                return '';
                            }
                        },
                        getTitleTpl: function(values) {
                            return ExGods.app.applyTpl(cfg.wait_title_tpl, values);
                        }
                    }
                ]
            },
            {
                xtype: 'toolbar',
                dock: 'bottom',
                layout: {
                    pack: 'center'
                },
                items: [
                    {
                        xtype: 'textbutton',
                        text: cfg.wait_call_back_bit_btn,
                        itemId: 'call_back_bid',
                        cls: 'no_border'
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.items = [
            {
                xtype: 'component',
                cls: 'guild-wait-description',
                html: ExGods.app.applyTpl(cfg.wait_desc, Ext.applyIf({
                    head: ExGods.printUser(me.service.data.guild.head, {
                        fields: "infoiconleft,name,rank,level"
                    })
                }, me.service.data.guild))
            }
        ];
        me.callParent();
    }
});

Ext.define('ExGods.view.guild.ListItem', {
    extend: ExGods.view.ListItem,
    alias: 'widget.guildlistitem',
    //margin:'0 0 -3px 0',
    viewChangeSelector: '.guild-item-view-change-selector',
    initComponent: function() {
        var me = this;
        var templateHelpers = {
                getFullCls: function(values) {
                    return values.current_count < values.max_count ? '' : ' full';
                },
                printClosed: function(values) {
                    return values.open ? '' : '<span class="closed-guild"></span>';
                }
            };
        var expanded = [
                '<div class="guild-item-title"><span>[{tag}] {title}</span>{[this.templateHelpers.printClosed(values)]}</div>',
                '<div class="guild-item-head">{[ ExGods.printUser(values.head, {fields: "infoiconleft,name,rank,level", maxNameWidth: 84})]}</div>',
                '<div class="guild-item-users{[this.templateHelpers.getFullCls(values)]}">{current_count}/{max_count}</div>',
                '<div class="guild-item-collapse guild-item-view-change-selector"></div>',
                '<div class="guild-item-btn-place" id="guild-item-btn-place-{id}"></div>',
                '<div class="guild-item-description">{description}</div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        var collapsed = [
                '<div class="guild-item-title"><span>[{tag}] {title}</span>{[this.templateHelpers.printClosed(values)]}</div>',
                '<div class="guild-item-head">{[ ExGods.printUser(values.head, {fields: "infoiconleft,name,rank,level", maxNameWidth: 84})]}</div>',
                '<div class="guild-item-users{[this.templateHelpers.getFullCls(values)]}">{current_count}/{max_count}</div>',
                '<div class="guild-item-expand guild-item-view-change-selector"></div>',
                '<div class="guild-item-btn-place" id="guild-item-btn-place-{id}"></div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        //me.itemId = me.record.get('proto_id');
        me.cls = me.record.store.indexOf(me.record) % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
        me.expanded = me.setTpl(expanded);
        me.collapsed = me.setTpl(collapsed);
        me.callParent(arguments);
        me.on('render', function() {
            if (me.record.get('expanded') == true) {
                me.expand();
            } else {
                me.collapse();
            }
        });
    },
    renderButton: function() {
        var me = this;
        Ext.widget('textbutton', {
            xtype: 'textbutton',
            text: ExGods.getMsgByKey('view_guild_enter_btn_text'),
            cls: 'no_border',
            renderTo: 'guild-item-btn-place-' + me.record.get('id'),
            handler: function() {
                me.fireEvent('join_guild', me.record);
            }
        });
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me);
    },
    collapse: function() {
        var me = this;
        me.collapsed.overwrite(me.el, me.record.data);
        me.renderButton();
        me.record.set('expanded', false);
        me.callParent();
    },
    expand: function() {
        var me = this;
        me.expanded.overwrite(me.el, me.record.data);
        me.renderButton();
        me.record.set('expanded', true);
        me.callParent();
    }
});

Ext.define('ExGods.view.guild.GuildsList', {
    extend: ExGods.view.List,
    alias: 'widget.guildslist',
    initComponent: function() {
        var me = this;
        me.itemWidgetConfig = {
            xtype: 'guildlistitem',
            listeners: {
                expand: me.onItemExpand,
                collapse: me.onItemCollapse,
                scope: me
            }
        };
        me.callParent();
    },
    onItemExpand: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onItemCollapse: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'guild/btn_list_close.png',
                IMAGE_URL + 'guild/btn_list_open.png',
                IMAGE_URL + 'ico_guild_closed.png',
                IMAGE_URL + 'radiobutton.png',
                IMAGE_URL + 'radiobutton_selected_blue.png',
                IMAGE_URL + 'shop/btn_buy.png',
                IMAGE_URL + 'btn_standart_high.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.GuildInfo', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildinfo',
    id: 'guild_info',
    layout: 'fit',
    padding: '6 10 12',
    plugins: [
        'paperdeco'
    ],
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            can_leave = !me.guild.isUserHead() || me.guild.getMembersCount() == 1,
            cfg = me.service.init_config,
            store = me.guild.get('users');
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                itemId: 'guild_description',
                data: me.guild.data,
                tpl: [
                    '<div class="paper-title"><h4>{[this.getTitleTpl(values)]}{[this.getClosedHTML(values)]} ({current_count}/{max_count})</h4></div>',
                    '<div class="guild-info-description">',
                    '{description}',
                    '<div class="guild-info-change-description-btn{[this.setVisible(values)]}"></div>',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    {
                        setVisible: function() {
                            return me.guild.isUserHead() ? '' : ' hidden';
                        },
                        getClosedHTML: function(values) {
                            if (!values.open) {
                                return '<span class="closed-guild"></span>';
                            } else {
                                return '';
                            }
                        },
                        getTitleTpl: function(values) {
                            return ExGods.app.applyTpl(cfg.guild_title_tpl, values);
                        }
                    }
                ],
                listeners: {
                    render: function() {
                        this.el.on('click', function() {
                            if (me.guild.isUserHead())  {
                                me.fireEvent('change_description', me.guild, me);
                            }
                            
                        }, me, {
                            delegate: '.guild-info-change-description-btn'
                        });
                        this.el.on('dblclick', function() {
                            if (me.guild.isUserHead())  {
                                me.fireEvent('change_description', me.guild, me);
                            }
                            
                        }, me, {
                            delegate: '.guild-info-description'
                        });
                    }
                }
            },
            {
                xtype: 'toolbar',
                dock: 'bottom',
                layout: {
                    pack: 'center'
                },
                //ui:'footer',
                //defaults: {minWidth: minButtonWidth},
                items: [
                    {
                        xtype: 'textbutton',
                        text: cfg.guild_change_head,
                        itemId: 'change_guild_head',
                        cls: 'no_border',
                        hidden: can_leave
                    },
                    {
                        xtype: 'textbutton',
                        text: cfg.guild_leave,
                        itemId: 'leave_guild',
                        cls: 'no_border',
                        hidden: !can_leave
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                items: [
                    {
                        xtype: 'dataview',
                        store: store,
                        autoEl: 'ul',
                        cls: 'guild-info-list',
                        itemSelector: 'li',
                        tpl: [
                            '<tpl for=".">',
                            '<li class="{[this.getBgCls(xindex)]}">',
                            '<div class="guild-member-online{[this.getOnlineCls(values)]}"></div>',
                            '<div class="guild-member-status">',
                            '{[this.getHead(values.display_title)]}',
                            '</div>',
                            '<div class="guild-member-title">',
                            '{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank,level", maxNameWidth: 350})]}',
                            '</div>',
                            '<div class="guild-member-points">{[this.getGuildPoints(values)]}</div>',
                            '<tpl if="this.isUserHead()">',
                            '<tpl if="isBid">',
                            '<div class="guild-member-bid-accept-btn"></div>',
                            '<div class="guild-member-bid-decline-btn"></div>',
                            '<tpl elseif="!this.getHead(values.display_title)">',
                            '<div class="guild-member-kick-btn"></div>',
                            '<tpl if="this.canSendSocialMessage(values)">',
                            '<div class="guild-member-send-social-message-btn" data-qtip="' + ExGods.getMsgByKey('view_guild_social_message_btn_tip') + '"></div>',
                            '</tpl>',
                            '</tpl>',
                            '</tpl>',
                            '</li>',
                            '</tpl>',
                            {
                                getBgCls: function(i) {
                                    return i % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
                                },
                                getOnlineCls: function(values) {
                                    if (values.isBid) {
                                        return ' bid';
                                    } else if (values.online) {
                                        return ' online';
                                    } else {
                                        return '';
                                    }
                                },
                                getHead: function(title) {
                                    return me.guild.get('head').display_title == title ? cfg.head : '';
                                },
                                isUserHead: function() {
                                    return me.guild.isUserHead();
                                },
                                getGuildPoints: function(values) {
                                    if (values.isBid) {
                                        return cfg.candidate;
                                    } else if (values.guild_noob) {
                                        return cfg.guild_noob;
                                    } else {
                                        return '<span class="rating-value" data-qtip="' + cfg.guild_points_tt + '" style="background-image: url(' + IMAGE_URL + cfg.guild_points_img + ')">' + values.guild_points + '</span>';
                                    }
                                },
                                canSendSocialMessage: function(values) {
                                    return values.can_snet_notice_inactive && ExGods.app.getSocialController().isCanSendUserToUserMessage();
                                }
                            }
                        ]
                    }
                ]
            }
        ];
        me.callParent();
        store.on('datachanged', me.updateBtns, me);
        store.on('update', me.updateBtns, me);
    },
    updateBtns: function(store) {
        var me = this;
        if (me.guild.isUserHead() && me.guild.getMembersCount() > 1) {
            me.down('#change_guild_head').show();
            me.down('#leave_guild').hide();
        } else {
            me.down('#change_guild_head').hide();
            me.down('#leave_guild').show();
        }
    },
    onDestroy: function() {
        var me = this,
            store = me.guild.get('users');
        store.un('datachanged', me.updateBtns, me);
        store.un('update', me.updateBtns, me);
        me.callParent(arguments);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            cfg = me.service.init_config;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'guild/offline.png',
                IMAGE_URL + 'guild/online.png',
                IMAGE_URL + 'guild/request.png',
                IMAGE_URL + 'guild/btn_exclude.png',
                IMAGE_URL + 'guild/btn_send_msg.png',
                IMAGE_URL + 'guild/btn_accept.png',
                IMAGE_URL + 'guild/btn_exclude.png',
                IMAGE_URL + 'guild/btn_edit.png',
                IMAGE_URL + cfg.guild_points_img
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.Help', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildhelp',
    id: 'guild_help',
    layout: 'hbox',
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser(),
            cfg = me.service.init_config;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                html: [
                    '<div class="paper-title"><h4>' + cfg.help_title + '</h4></div>',
                    '<p class="guild-help-description"></p>'
                ],
                listeners: {
                    afterrender: function() {
                        me.updateTimed(user.get('timed')[me.service.data.timed], true);
                        user.on(me.service.data.timed + 'changed', me.updateTimed, me);
                    },
                    destroy: function() {
                        user.un(me.service.timed + 'changed', me.updateTimed, me);
                    }
                }
            }
        ];
        me.items = [
            {
                xtype: 'guildrequestslist',
                store: me.myRequestsStore,
                title: cfg.help_my_requests_title,
                description: cfg.help_my_requests_description,
                listItemTpl: [
                    '<div class="guild-my-request-label{[this.getCls(values.timeout,values.owner)]}">',
                    '{label}',
                    '<span class="right">',
                    '<tpl if="owner">',
                    '<span class="current">{current_count}</span>/{max_count}',
                    '<tpl else>',
                    '<tpl if="timeout">',
                    '{[ExGods.util.Time.printTime(values.timeout,{format:"short"})]}',
                    '<tpl else>',
                    ExGods.getMsgByKey('view_guild_help_availrequest'),
                    '</tpl>',
                    '</tpl>',
                    '</span>',
                    '</div>'
                ].join(''),
                listItemMethods: {
                    getCls: function(timeout, owner) {
                        return timeout && !owner ? ' grey' : '';
                    }
                },
                width: 300
            },
            {
                xtype: 'guildrequestslist',
                store: me.requestsStore,
                listItemTpl: [
                    '<div class="guild-request-title">',
                    '{[ this.getHead(values.owner.display_title) ]}',
                    '{[ ExGods.printUser(values.owner, {fields: "infoiconleft,name,rank,level", maxNameWidth: 84})]}',
                    '</div>',
                    '<div class="guild-request-label">',
                    '{label}',
                    '</div>',
                    '<div class="guild-request-count">',
                    '<span class="current">{current_count}</span>/{max_count}',
                    '</div>',
                    '<div class="guild-request-help-btn">',
                    '<div class="component">',
                    '<span role="xtype">textbutton</span>',
                    '<span role="cls">no_border{[this.red(values)]}</span>',
                    '<span role="text">' + cfg.help_help_btn + '</span>',
                    '<span role="width">70px</span>',
                    '<span role="minWidth">70px</span>',
                    '<span role="action">guild_help</span>',
                    '<span role="request_id">{id}</span>',
                    '</div>',
                    '</div>'
                ].join(''),
                title: cfg.help_requests_title,
                description: cfg.help_requests_description,
                listItemMethods: {
                    getHead: function(title) {
                        return me.guild.get('head').display_title == title ? '<span class="guild-member-head">' + cfg.head + '</span>' : '';
                    },
                    red: function(values) {
                        return values.type_request == 'meddle' ? ' x-btn-txt-red' : '';
                    }
                },
                flex: 1
            }
        ];
        me.callParent();
    },
    updateTimed: function(timed, value_changed) {
        var me = this,
            cfg = me.service.init_config,
            time = new Date(timed[3]) - new Date() + 1000;
        //временной лаг
        if (!me.el)  {
            return;
        }
        
        time = Math.max(1, time / 1000);
        var el = me.el.down('.guild-help-description'),
            text = (timed[3] && timed[0] != timed[1]) ? cfg.help_timed_text : cfg.help_full_timed_text;
        tpl = ExGods.app.applyTpl(text, {
            timed_current: Math.floor(timed[0]),
            timed_max: timed[1],
            timed_timer: [
                '<span id="guild-help-timed-timer">',
                ExGods.util.Time.printTime(time, {
                    format: 'short'
                }),
                '</span>'
            ].join('')
        });
        el.setHTML(tpl);
    }
});

Ext.define('ExGods.view.guild.RequestsList', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildrequestslist',
    cls: 'guild-request-list',
    plugins: [
        'paperdeco'
    ],
    height: '100%',
    listItemTpl: '',
    listItemMethods: {},
    initComponent: function() {
        var me = this,
            title = me.title;
        me.title = false;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-title"><h4>' + title + '<div class="item_info"></div></h4></div>'
            }
        ];
        me.items = [
            {
                xtype: 'dataview',
                itemSelector: 'li',
                autoEl: 'ul',
                padding: '0 11',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                store: me.store,
                tpl: [
                    '<tpl for=".">',
                    '<li class="{[this.getBgCls(values.index)]}">',
                    me.listItemTpl,
                    '</li>',
                    '</tpl>',
                    Ext.apply({
                        getBgCls: function(i) {
                            return i % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
                        }
                    }, me.listItemMethods)
                ],
                listeners: {
                    beforerefresh: function(view) {
                        ExGods.util.Helper.destroyComponents(view.el);
                    },
                    refresh: function(view) {
                        ExGods.util.Helper.renderComponents(view.el, view);
                    }
                }
            }
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.down('.item_info').on('click', me.onInfoClick, me);
    },
    onInfoClick: function(e) {
        this.fireEvent('infoclick', this, e.currentTarget, this.description);
    },
    onDestroy: function() {
        var me = this;
        if (me.el && me.el.down('.item_info'))  {
            me.el.down('.item_info').un('click', me.onInfoClick, me);
        }
        
        me.callParent(arguments);
    }
});

Ext.define('ExGods.view.guild.Shop', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildshop',
    id: 'guild-shop',
    /**
     * @cfg {ExGods.model.Guild} guild Модель гильдии
     */
    guild: null,
    /**
     * @cfg {ExGods.service.Guilds} service Сервис гильдии
     */
    service: null,
    plugins: [
        {
            ptype: 'pager',
            marginLeft: -38,
            marginRight: -36,
            top: 164,
            textTop: 348,
            textLeft: 324
        }
    ],
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser(),
            cfg = me.service.init_config;
        me.store = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.ShopItem'
        });
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                id: 'guild-shop-header',
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                margin: '0 0 -5 0',
                items: [
                    {
                        xtype: 'component',
                        html: '<div class="paper-title"><h4>' + cfg.guild_shop_title + '</h4></div>'
                    },
                    {
                        layout: 'hbox',
                        margin: '-6 0 0 0',
                        bodyPadding: '0 20 15 20',
                        items: [
                            {
                                xtype: 'component',
                                itemId: 'guild-points',
                                cls: 'points-text',
                                tpl: cfg.guild_shop_points_text,
                                data: {
                                    points: ExGods.util.Stuff.printStuff({
                                        type: 'currency',
                                        params: {
                                            id: 'guild',
                                            quantity: ExGods.app.user.get('money').guild || 0
                                        }
                                    })
                                }
                            },
                            {
                                xtype: 'tbfill'
                            },
                            {
                                xtype: 'checkboxfield',
                                boxLabel: cfg.guild_shop_avail_text,
                                checked: true,
                                style: {
                                    color: '#e3ac69'
                                },
                                listeners: {
                                    change: function(f, value) {
                                        me.updateFilters('level', value);
                                    },
                                    scope: me
                                },
                                margin: '0 20 0 0'
                            },
                            {
                                xtype: 'textfield',
                                emptyText: cfg.guild_shop_search_placeholder,
                                height: 22,
                                listeners: {
                                    change: {
                                        fn: function(f, value) {
                                            me.updateFilters('text', value);
                                        },
                                        buffer: 100
                                    },
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            }
                        ]
                    }
                ]
            }
        ];
        me.shopView = Ext.widget('shop', {
            height: 283,
            store: me.store,
            emptyText: cfg.guild_shop_empty_text
        });
        me.items = [
            me.shopView
        ];
        me.on({
            next: me.showNextPage,
            prev: me.showPrevPage,
            scope: me
        });
        me.mon(ExGods.app.user, 'moneychanged', me.onUserMoneyChanged, me);
        me.callParent();
    },
    // =============== PRIVATES ============================
    afterRender: function() {
        var me = this,
            _bindService = function() {
                me.mon(me.service.shopService, 'init', me.fillStoreFromService, me);
                me.mon(me.service.shopService, 'update', me.fillStoreFromService, me);
                me.shopService = me.service.shopService;
                if (!me.service.shopService.initialized) {
                    ExGods.app.block();
                } else // жду инициалиции сервиса
                {
                    me.fillStoreFromService();
                }
            };
        if (me.service.shopService) {
            _bindService();
        } else {
            setTimeout(function() {
                _bindService();
            }, 0);
        }
        me.callParent(arguments);
    },
    fillStoreFromService: function() {
        var me = this,
            items = [],
            missedProtos = [],
            shopModel;
        if (me.service.shopService.data.shops.length) {
            missedProtos = ExGods.model.Shop.getMissedProtos(me.service.shopService.data.shops[0]);
            ExGods.app.getItemPrototypesStore().loadNew(missedProtos, function() {
                shopModel = Ext.create('ExGods.model.Shop', me.service.shopService.data.shops[0]);
                me.store.loadRawData(shopModel.items().getRange());
                me.updatePager();
                ExGods.app.unblock();
            });
        } else {
            ExGods.app.unblock();
        }
    },
    updateFilters: function(filterName, value) {
        var me = this;
        if (filterName == 'level') {
            me.shopView.setFilterByLevel(value);
        } else if (filterName == 'text') {
            me.shopView.setTextFilter(value);
        }
        me.updatePager();
    },
    updatePager: function() {
        var me = this,
            total;
        if (me.pager) {
            //вычисляем количество страниц (на страницу по 8 вещей, поэтому делим общее кол-во вещей на 8)      
            if (me.store.getCount()) {
                total = Math.ceil(me.store.getCount() / 8);
            } else {
                total = 1;
            }
            Ext.apply(me.pager, {
                current: 1,
                total: total
            });
            me.pager.refresh();
        }
    },
    showNextPage: function() {
        var me = this;
        me.openPage(-1);
        me.pager.refresh();
    },
    showPrevPage: function() {
        var me = this;
        me.openPage(1);
        me.pager.refresh();
    },
    openPage: function(direction) {
        var me = this,
            ul = me.shopView.getEl().down('.shop-items'),
            marginTop = parseInt(ul.getStyle('margin-top').split('p')[0]),
            offsetHeight = 282;
        ul.setStyle('margin-top', (marginTop + offsetHeight * direction) + 'px');
    },
    onUserMoneyChanged: function() {
        var me = this;
        me.dockedItems.items[0].down('#guild-points').update({
            points: ExGods.util.Stuff.printStuff({
                type: 'currency',
                params: {
                    id: 'guild',
                    quantity: ExGods.app.user.get('money').guild || 0
                }
            })
        });
    }
});

Ext.define('ExGods.view.guild.Quests', {
    extend: ExGods.view.List,
    alias: 'widget.guildquests',
    id: 'guild_quests',
    cls: 'questnewlist',
    //margin:'-3px -3px 0 -3px',
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            scrollDeltaY: 50,
            autoHide: true,
            autoRestorePosition: true,
            padding: '3px 3px 0 0'
        }
    ],
    emptyTpl: [
        '<p class="central-window-empty">{text}</p>'
    ],
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.itemWidgetConfig = {
            xtype: 'guildquestlistitem',
            service: me.service,
            listeners: {
                expand: me.onItemExpand,
                collapse: me.onItemCollapse,
                scope: me
            }
        };
        me.emptyData = {
            text: me.service.data.guild_noob ? cfg.quests_guild_noob : cfg.quests_empty_text
        };
        me.callParent(arguments);
    },
    onItemExpand: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onItemCollapse: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            cfg = me.service.init_config;
        var arr_images = [];
        return {
            stuff: [],
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.QuestListItem', {
    extend: ExGods.view.ListItem,
    alias: 'widget.guildquestlistitem',
    margin: '0 0 -3px 0',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        var templateHelpers = {
                printDailyTimer: function(values) {
                    if (!values.done_date) {
                        var task_id = values.task_id,
                            y = new Date().getFullYear(),
                            m = new Date().getMonth() + 1,
                            d = new Date().getDate() + 1;
                        if (m.toString().length == 1)  {
                            m = '0' + m;
                        }
                        
                        if (d.toString().length == 1)  {
                            d = '0' + d;
                        }
                        
                        var date = new Date(y + '-' + m + '-' + d);
                        if (!date.getTime()) {
                            m = new Date().getMonth() + 2;
                            if (m.toString().length == 1)  {
                                m = '0' + m;
                            }
                            
                            date = new Date(y + '-' + m + '-01');
                        }
                        date = date.getTime() + date.getTimezoneOffset() * 60 * 1000 - ExGods.util.Date.serverTimeOffset * 1000;
                        return ExGods.util.Timers.printTimer('rest', 'guild-quest-timer' + task_id, new Date(date), {
                            needNormalized: false,
                            format: 'short'
                        });
                    } else {
                        return cfg.quest_complete;
                    }
                },
                getCompleteCls: function(values) {
                    return values.done_date ? ' complete' : '';
                }
            };
        var expanded = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{title}</h4>',
                '<div class="view-change-selector expanded"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url(' + IMAGE_URL + '{image})"></div>',
                '</div>',
                '<div class="quest-timer{[this.templateHelpers.getCompleteCls(values)]}">',
                '<span class="dropdown">',
                '{[this.templateHelpers.printDailyTimer(values)]}',
                '</span>',
                '</div>',
                '</div>',
                '<div class="wide-column">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_aim'] + ');"></div>',
                '<div class="info-box-content guild-short-description">',
                '{description_short} ({params.points}/{[values.stages[values.stages.length - 1].counter]})',
                '</div>',
                '</div>',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_award'] + ');"></div>',
                '<div class="info-box-content info-box-rewards">',
                '<ul>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '</ul>',
                '<tpl for="stages">',
                '<div class="guild-quest-stage-count">',
                '<img src="{[this.getStageCompleteIcon(parent.params.stage,xindex)]}">',
                '{[ExGods.printNumber(values.counter,1000,"0","0.0")]}',
                '</div>',
                '</tpl>',
                '</div>',
                '</div>',
                '</div>',
                '<div class="quest-description">{description}</div>',
                '<div class="paper-separator"></div>',
                '</div>',
                '<div class="guild-quest-pcp">',
                '<div class="paper-title"><h4>' + cfg.quests_pcp_title + '</h4></div>',
                //TODO
                '<tpl if="pcp.length">',
                '<table class="list">',
                '<tpl for="pcp">',
                '<tr class="{[ xindex % 2 ? "exg-share-bg-light" : "exg-share-bg-dark" ]}">',
                '<td class="place-cell">',
                '<tpl if="xindex &gt;= 1 && xindex &lt;= 3">',
                '<div class="place-{[xindex]}"><img width="76" height="24" src="{[ this.getPlaceImage(xindex) ]}"></div>',
                '<tpl else>',
                '<span>{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('rating_place') + '",{place:xindex})]}</span>',
                '</tpl>',
                '</td>',
                '<td class="username-cell">',
                '{[ ExGods.printUser(values.user, {fields: "name,rank,level,infoicon"}) ]}',
                '</td>',
                '<td class="count-cell">',
                '{[this.printValue(values.count)]}',
                '</td>',
                '</tr>',
                '</tpl>',
                '</table>',
                '</tpl>',
                '</div>',
                {
                    templateHelpers: templateHelpers,
                    printValue: function(value) {
                        return '<span class="rating-value" style="background-image: url(' + IMAGE_URL + cfg.guild_points_img + ')">' + value + '</span>';
                    },
                    getStageCompleteIcon: function(stage, index) {
                        return stage >= index ? IMAGE_URL + 'icons/done.png' : IMAGE_URL + 'icons/undone.png';
                    },
                    getPlaceImage: function(rank) {
                        return ExGods.ref('images|rating_place_icons').image['place' + rank];
                    }
                }
            ];
        var collapsed = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{title}</h4>',
                '<div class="view-change-selector collapsed"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url(' + IMAGE_URL + '{image})"></div>',
                '</div>',
                '<div class="quest-timer{[this.templateHelpers.getCompleteCls(values)]}">',
                '<span class="dropdown">',
                '{[this.templateHelpers.printDailyTimer(values)]}',
                '</span>',
                '</div>',
                '</div>',
                '<div class="wide-column">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_aim'] + ');"></div>',
                '<div class="info-box-content guild-short-description">',
                '{description_short} ({params.points}/{[values.stages[values.stages.length - 1].counter]})',
                '</div>',
                '</div>',
                '</div>',
                '</div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        me.expanded = me.setTpl(expanded);
        me.collapsed = me.setTpl(collapsed);
        me.callParent(arguments);
        me.on('render', function() {
            if (me.record.get('expanded') == true) {
                me.expand();
            } else {
                me.collapse();
            }
        });
    },
    getRewards: function() {
        var me = this,
            rewards = [];
        Ext.Array.each(me.record.get('stages'), function(stage) {
            if (stage.reward && stage.reward.length)  {
                rewards.push(stage.reward[0]);
            }
            
        });
        if (rewards.length) {
            var rewardsHtml = ExGods.stuff.StuffManager.image(rewards),
                rewardsEl = document.createElement('div'),
                ul = me.el && me.el.down('.info-box-rewards ul');
            rewardsEl.innerHTML = rewardsHtml;
            Ext.get(rewardsEl).select('li').addCls('info-box-itembox');
            if (ul) {
                ul.update(rewardsEl.firstChild.innerHTML);
                for (var i = rewards.length; i < 7; i++) {
                    ul.insertHtml('beforeEnd', '<li class="info-box-itembox"></li>');
                }
            }
        }
    },
    collapse: function() {
        var me = this;
        me.collapsed.overwrite(me.el, me.record.data);
        me.record.set('expanded', false);
        me.callParent();
    },
    expand: function() {
        var me = this;
        me.expanded.overwrite(me.el, me.record.data);
        me.getRewards();
        me.record.set('expanded', true);
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            cfg = me.service.init_config;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'quests/bg.png',
                IMAGE_URL + 'quests/top_1.png',
                IMAGE_URL + 'quests/top_2.png',
                IMAGE_URL + 'quests/top_3.png',
                IMAGE_URL + 'quests/side_left.png',
                IMAGE_URL + 'quests/side_right.png',
                IMAGE_URL + 'quests/bottom_1.png',
                IMAGE_URL + 'quests/bottom_2.png',
                IMAGE_URL + 'quests/bottom_3.png',
                IMAGE_URL + 'quests/item_box.jpg',
                IMAGE_URL + 'quests/button_task_close.png',
                IMAGE_URL + 'scrollbar/thumb.png',
                IMAGE_URL + 'scrollbar/bg_midle.png',
                IMAGE_URL + 'scrollbar/bg_top.png',
                IMAGE_URL + 'scrollbar/bg_bottom.png',
                IMAGE_URL + 'shop/btn_buy.png',
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.Groups', {
    extend: Ext.container.Container,
    alias: 'widget.guildgroups',
    id: 'guild_groups',
    layout: 'card',
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    },
    //me.showGroupsList();
    showGroupsList: function(data) {
        var me = this;
        if (!me.listCard) {
            me.listCard = Ext.widget('guildgroupsearch', {
                store: me.groupsStore,
                service: me.service,
                loot_types: data.loot_types
            });
            me.add(me.listCard);
        }
        me.getLayout().setActiveItem(me.listCard);
    },
    showGroupInfo: function(data) {
        var me = this;
        if (!me.infoCard) {
            me.infoCard = Ext.widget('guildgroupinfo', {
                service: me.service,
                autoShow: false
            });
            ExGods.Resources.load(me.infoCard, function() {
                me.infoCard.show();
            });
            me.add(me.infoCard);
        }
        me.infoCard.update(data);
        me.getLayout().setActiveItem(me.infoCard);
    }
});

Ext.define('ExGods.view.guild.GroupSearch', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildgroupsearch',
    id: 'guild_group_search',
    layout: 'fit',
    padding: '6 10 12',
    plugins: [
        'paperdeco'
    ],
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: [
                    '<div class="paper-title"><h4>' + cfg.group_search_title + '</h4></div>',
                    '<div class="guild-info-description">' + cfg.group_search_description + '</div>',
                    '<div class="paper-separator"></div>'
                ]
            },
            {
                xtype: 'toolbar',
                dock: 'bottom',
                vertical: true,
                layout: {
                    align: 'center',
                    pack: 'center'
                },
                items: [
                    {
                        xtype: 'textfield',
                        fieldLabel: cfg.group_create_input,
                        emptyText: cfg.group_create_input_text,
                        labelWidth: 130,
                        labelCls: 'guild-group-create-input-label',
                        width: 300,
                        margin: '5 0'
                    },
                    {
                        xtype: 'textbutton',
                        text: cfg.group_create_btn,
                        itemId: 'create_guild_group',
                        width: 130,
                        margin: '0 0 5 0',
                        cls: 'no_border'
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        if (me.loot_types.length) {
            var lootTypesRadio = {
                    xtype: 'radiogroup',
                    layout: {
                        type: 'hbox',
                        align: 'stretch',
                        pack: 'center'
                    },
                    margin: '0 0 10 0',
                    items: []
                };
            Ext.Array.each(me.loot_types, function(type, i) {
                lootTypesRadio.items.push({
                    boxLabel: cfg['group_loottype_' + type],
                    inputValue: type,
                    name: 'loot_type',
                    checked: !i
                });
            });
            me.dockedItems[1].items.splice(1, 0, lootTypesRadio);
        }
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                items: [
                    {
                        xtype: 'dataview',
                        store: me.store,
                        autoEl: 'ul',
                        cls: 'guild-groups-list',
                        itemSelector: 'li',
                        tpl: [
                            '<tpl for=".">',
                            '<li class="{[this.getBgCls(xindex)]}">',
                            '<div class="guild-groups-shape" style="background-image: url({[this.getShape(values)]})"></div>',
                            '<div class="guild-groups-creator">',
                            '{[this.getCreatorInfo(values)]}',
                            '</div>',
                            '<div class="guild-groups-description">',
                            '"{description}" [{users.length} ' + ExGods.getMsgByKey('view_guild_people_text_short') + ']',
                            '</div>',
                            '<div class="guild-groups-join-btn">',
                            '<div class="component">',
                            '<span role="xtype">textbutton</span>',
                            '<span role="cls">no_border_double</span>',
                            '<span role="text">' + cfg.group_join_btn + '</span>',
                            '<span role="minWidth">90</span>',
                            '<span role="action">guild_group_join</span>',
                            '<span role="group_id">{id}</span>',
                            '</div>',
                            '</div>',
                            '</li>',
                            '</tpl>',
                            {
                                getBgCls: function(i) {
                                    return i % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
                                },
                                getShape: function(values) {
                                    var creator,
                                        i = values.users.length;
                                    while (i--) {
                                        if (values.users[i].is_creator) {
                                            creator = values.users[i];
                                            break;
                                        }
                                    }
                                    return ExGods.ref('user_shape|' + creator.shape).thumb;
                                },
                                getCreatorInfo: function(values) {
                                    var creator,
                                        i = values.users.length;
                                    while (i--) {
                                        if (values.users[i].is_creator) {
                                            creator = values.users[i];
                                            break;
                                        }
                                    }
                                    return ExGods.printUser(creator, {
                                        fields: 'infoiconleft,name,rank,level',
                                        maxNameWidth: 270
                                    });
                                }
                            }
                        ],
                        listeners: {
                            beforerefresh: function(view) {
                                ExGods.util.Helper.destroyComponents(view.el);
                            },
                            refresh: function(view) {
                                ExGods.util.Helper.renderComponents(view.el, view);
                            }
                        }
                    }
                ]
            }
        ];
        me.callParent();
    },
    // store.on('datachanged',me.updateBtns,me);
    // store.on('update',me.updateBtns,me);
    updateBtns: function(store) {
        var me = this;
        if (me.guild.isUserHead() && me.guild.getMembersCount() > 1) {
            me.down('#change_guild_head').show();
            me.down('#leave_guild').hide();
        } else {
            me.down('#change_guild_head').hide();
            me.down('#leave_guild').show();
        }
    },
    onDestroy: function() {
        var me = this;
        // store.un('datachanged',me.updateBtns,me);
        // store.un('update',me.updateBtns,me);
        me.callParent(arguments);
    }
});

Ext.define('ExGods.view.guild.GroupInfo', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildgroupinfo',
    id: 'guild_group_info',
    layout: 'fit',
    padding: '6 10 12',
    plugins: [
        'paperdeco'
    ],
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.store = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.BasicUser',
            proxy: {
                type: 'memory'
            },
            sorters: [
                {
                    property: 'is_creator',
                    direction: 'ASC'
                }
            ]
        });
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                data: {},
                tpl: [
                    '<div class="paper-title"><h4>{[this.getTitleTpl(values)]}</h4></div>',
                    {
                        getTitleTpl: function(values) {
                            return ExGods.app.applyTpl(cfg.group_title_tpl, values);
                        }
                    }
                ]
            },
            {
                xtype: 'toolbar',
                dock: 'bottom',
                layout: {
                    pack: 'center'
                },
                items: [
                    {
                        xtype: 'textbutton',
                        text: cfg.group_change_leader,
                        itemId: 'change_guild_group_leader',
                        cls: 'no_border',
                        width: 150,
                        margin: '0 15 0 0'
                    },
                    {
                        xtype: 'textbutton',
                        text: cfg.group_leave,
                        itemId: 'leave_guild_group',
                        cls: 'no_border',
                        width: 150
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                items: [
                    {
                        xtype: 'dataview',
                        store: me.store,
                        autoEl: 'ul',
                        cls: 'guild-info-list',
                        itemSelector: 'li.guild-group-member',
                        tpl: [
                            '<tpl for=".">',
                            '<li class="guild-group-member {[this.getBgCls(xindex)]}">',
                            '<div class="guild-groups-shape" style="background-image: url({[this.getShape(values)]})"></div>',
                            '<div class="guild-groups-creator">',
                            '{[this.printLeader(values)]}{[ExGods.printUser(values,{fields:"infoiconleft,name,rank,level",maxNameWidth:270})]}',
                            '<div class="guild-groups-mask-group">{mask_group}</div>',
                            '<div class="mask-grade-line">{[this.getMaskGrade(values)]}</div>',
                            '</div>',
                            '<div class="guild-groups-description">',
                            '{[ExGods.util.User.printUserStats(values.stats.stats,{inline:true})]}',
                            '</div>',
                            '<tpl if="this.canKick(values)">',
                            '<div class="guild-group-kick-btn"></div>',
                            '</tpl>',
                            '</li>',
                            '</tpl>',
                            {
                                getBgCls: function(i) {
                                    return i % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
                                },
                                getShape: function(values) {
                                    return ExGods.ref('user_shape|' + values.shape).thumb;
                                },
                                printLeader: function(values) {
                                    return values.display_title == me.group.creator ? cfg.leader : '';
                                },
                                canKick: function(values) {
                                    return me.group.creator == ExGods.app.getUser().get('display_title') && values.display_title != me.group.creator;
                                },
                                getMaskGrade: function(values) {
                                    var proto = ExGods.app.getItemPrototypesStore().data.getByKey(values.mask_proto_id),
                                        html = '',
                                        i = proto ? proto.data.data.item_grade : 0;
                                    while (i--) {
                                        html += '<div></div>';
                                    }
                                    return html;
                                }
                            }
                        ],
                        getResources: function() {
                            var arr_images = [];
                            for (var i = 0; i < me.store.data.items.length; i++) {
                                arr_images.push(ExGods.ref('user_shape|' + me.store.data.items[i].data.shape).thumb);
                            }
                            return {
                                stuff: [],
                                images: [].concat(arr_images)
                            };
                        }
                    }
                ]
            }
        ];
        me.callParent();
    },
    update: function(data) {
        var me = this;
        me.group = data;
        me.getDockedComponent(0).update(data);
        me.updateBtns();
        me.store.loadRawData(data.users);
    },
    updateBtns: function(store) {
        var me = this,
            changeLeaderBtn = me.down('#change_guild_group_leader');
        if (me.group.creator == ExGods.app.getUser().get('display_title') && me.group.users.length > 1) {
            changeLeaderBtn.show();
        } else {
            changeLeaderBtn.hide();
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'guild/paper_skull_bg.png'
            ].concat(arr_images)
        };
    }
});

/**
 * Cетка элементов на лоскутах кожи
 */
Ext.define('ExGods.view.grid.SkinGrid', {
    extend: ExGods.view.grid.Grid,
    alias: 'widget.exg_skin_grid',
    cellWidth: 105,
    cellHeight: 112,
    /**
     * isEnabled {Function} метод шаблона, принимает values (все параметры модели), возврашает true/false
     */
    isEnabled: Ext.emptyFn,
    /**
     * getImage {Function} метод шаблона, принимает values (все параметры модели), возврашает ссылку на картинку
     */
    getImage: Ext.emptyFn,
    initComponent: function() {
        var me = this;
        if (me.pager) {
            me.calcWidth();
            me.pager = Ext.apply({
                textTop: -31,
                textLeft: me.width / 2 - 112 / 2 - 10
            }, me.pager);
        }
        me.callParent(arguments);
    },
    /**
     * Инициализация шаблона для элемента грида
     * @override
     */
    initItemTemplate: function() {
        var me = this;
        me.itemTpl = [
            '<div class="exg-grid-skin-item{[this.isEnabled(values)]}">',
            '<div class="exg-grid-skin-frm"></div>',
            '<img class="image" src="{[this.getImage(values)]}">',
            '<div class="notify_i"></div>',
            '<div class="x-clear"></div>',
            '</div>',
            {
                isEnabled: function(values) {
                    return me.isEnabled(values) ? ' enabled' : '';
                },
                getImage: me.getImage.bind(me)
            }
        ];
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.addCls('exg-grid-skin');
        me.itemsView.on({
            refresh: me.renderEmptySlots,
            scope: me
        });
    },
    renderEmptySlots: function() {
        var me = this,
            pager = me.getPager(),
            ul = me.el.down('.exg-grid-items');
        var itemsPerPage = me.rowsCount * me.columnsCount,
            i = itemsPerPage - me.store.getCount() % itemsPerPage;
        while (i--) {
            ul.insertHtml('beforeEnd', [
                '<li class="exg-grid-item" style="width:' + me.cellWidth + 'px;height:' + me.cellHeight + 'px">',
                '<div class="exg-grid-skin-item empty">',
                '<div class="exg-grid-skin-frm"></div>',
                '<img class="image" src="' + IMAGE_URL + 'locations/monster_absent.jpg">',
                '<div class="x-clear"></div>',
                '</div>',
                '</li>'
            ].join(''));
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'locations/monster_absent.jpg',
                IMAGE_URL + 'locations/monster_frame_green.png',
                IMAGE_URL + 'locations/monster_frame_neutral.png',
                IMAGE_URL + 'mask/panel.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.Raids', {
    extend: ExGods.view.grid.SkinGrid,
    alias: 'widget.guildraids',
    itemId: 'guild_raids',
    layout: 'fit',
    padding: 20,
    rowsCount: 3,
    columnsCount: 7,
    isEnabled: function(values) {
        return values.counter > 0;
    },
    getImage: function(values) {
        if (values.counter && values.counter > 0) {
            return IMAGE_URL + values.image;
        } else {
            return IMAGE_URL + values.image2;
        }
    },
    initComponent: function() {
        var me = this;
        if (me.store.getCount() > me.rowsCount * me.columnsCount) {
            me.pager = {
                marginLeft: -63,
                marginRight: -84,
                textTop: -13
            };
        }
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        for (var i = 0; i < 0; i++) {
            arr_images.push(me.store.data.items[i].data.image);
            arr_images.push(me.store.data.items[i].data.image2);
        }
        var parent = me.callParent();
        return {
            stuff: [].concat(parent.stuff),
            images: [].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 * Контроллер гильдии
 */
Ext.define('ExGods.controller.Guild', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /**
         * @method getGuildButton
         * Возвращает кнопку "Гильдия"
         * @return {ExGods.view.menu.MainMenuButton}
         */
            ref: 'guildButton',
            selector: '#mainmenu-guild-button'
        },
        {
            /**
         * @method getRequestsTab
         * Возвращает таб "Запросы"
         * @return {ExGods.view.skin.Tab}
         */
            ref: 'requestsTab',
            selector: '#guild_help_tab'
        },
        {
            /**
         * @method getGroups
         * Возвращает компонент "Группы"
         * @return {ExGods.view.guild.Groups}
         */
            ref: 'groups',
            selector: '#guild_groups'
        }
    ],
    views: [
        'List',
        'guild.Container',
        'guild.Search',
        'guild.ListItem',
        'guild.GuildsList',
        'guild.CreateForm',
        'guild.GuildInfo',
        'guild.TabPanel',
        'guild.Help',
        'guild.RequestsList',
        'guild.Shop',
        'guild.Quests',
        'guild.QuestListItem',
        'guild.WaitBid',
        'guild.Groups',
        'guild.GroupSearch',
        'guild.GroupInfo',
        'guild.Raids',
        'guild.RaidInfoWindow'
    ],
    stores: [
        'Guilds',
        'GuildMembers',
        'GuildGroupOnlineList',
        'GuildRaids',
        'GuildRequests',
        'GuildGroups'
    ],
    models: [
        'GuildQuest',
        'GuildRaid',
        'GuildRequest',
        'GuildGroup'
    ],
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'Guild:'
    },
    newRequests: 0,
    init: function(app) {
        var me = this;
        me.service = ExGods.Services.get('guilds');
        if (me.service.on) {
            me.service.on('update', me.onServiceUpdate, me);
        }
        me.app.getGuildsStore().service = me.service;
        //создаю сторы реквестов, заполняться они будут в методе updateRequests
        me.myRequestsStore = Ext.create('ExGods.store.GuildRequests');
        me.requestsStore = Ext.create('ExGods.store.GuildRequests');
        //создаю стор групп
        me.groupsStore = Ext.create('ExGods.store.GuildGroups');
        //создаю стор рейдов
        me.raidsStore = ExGods.app.getGuildRaidsStore();
        me.raidsStore.loadRawData(ExGods.references.get('guild_raids').getArray());
        //создаю сторы квестов, заполняться они будут в методе updateQuests
        me.questsStore = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.GuildQuest',
            proxy: {
                type: 'memory'
            },
            sorters: [
                {
                    sorterFn: function(m1, m2) {
                        var v = 0;
                        // Порядок сортировки
                        // 
                        // 1. не выполненные задания, самые новые сверху
                        // 2. завершенные задания самые новые сверху
                        m1_c = m1.get('create_date') ? ExGods.util.Date.normalizeServerDateTime(m1.get('create_date')).getTime() : 0 , m2_c = m2.get('create_date') ? ExGods.util.Date.normalizeServerDateTime(m2.get('create_date')).getTime() : 0 , m1_d = m1.get('done_date') ? ExGods.util.Date.normalizeServerDateTime(m1.get('done_date')).getTime() : 0 , m2_d = m2.get('done_date') ? ExGods.util.Date.normalizeServerDateTime(m2.get('done_date')).getTime() : 0;
                        // Алгоритм
                        // 
                        // 1) Все невыполненные задания отображаются первыми. Они сортируются по ВРЕМЕНИ СОЗДАНИЯ ЗАДАНИЯ. Самые новые наверху.
                        // 2) Все выполненые задания отображаются после невыполненых, они сортируются ПО ВРЕМЕНИ ВЫПОЛНЕНИЯ ЗАДАНИЯ, самые новые наверху
                        // В начале проверяем не выполненные квесты
                        if (m1_d == 0 && m1_d != m2_d) {
                            return -1;
                        }
                        if (m2_d == 0 && m1_d != m2_d) {
                            return 1;
                        }
                        // Этот блок работает если время завершения квестов равно(или оба квеста не выполнены)
                        if (m1_c > m2_c)  {
                            v = -1;
                        }
                        
                        if (m1_c < m2_c)  {
                            v = 1;
                        }
                        
                        if (m1_d > m2_d)  {
                            v = -1;
                        }
                        
                        if (m1_d < m2_d)  {
                            v = 1;
                        }
                        
                        return v;
                    }
                }
            ]
        });
        me.control({
            '#show_create_form': {
                click: me.showCreate
            },
            '#back_to_guild_search': {
                click: me.showSearch
            },
            '#create_guild': {
                click: me.createGuild
            },
            '#guild_search textfield': {
                keyup: me.searchForGuild
            },
            '#guild_info dataview': {
                itemclick: me.doActionWithMember
            },
            '#leave_guild': {
                click: me.leaveGuild
            },
            '#change_guild_head': {
                click: me.changeGuildHead
            },
            '#guild_search combo': {
                select: me.onSorterSelect
            },
            '#guild_search radiogroup': {
                change: me.onGuildTypeChange
            },
            '#guild_info': {
                change_description: me.onChangeDescription
            },
            'guildlistitem': {
                join_guild: me.joinGuild
            },
            'textbutton[action="guild_help"]': {
                click: me.onGuildHelpClick
            },
            'guildquestlistitem': {
                expand: me.onQuestExpand
            },
            '#guild-shop dataview': {
                itemclick: me.onShopItemClick
            },
            'guildtabpanel': {
                tabchange: me.onActivateTab
            },
            '#guild_create': {
                optioninfoclick: me.onInfoClick
            },
            '#call_back_bid': {
                click: me.callBackBid
            },
            'guildrequestslist': {
                infoclick: me.onInfoClick
            },
            '#create_guild_group': {
                click: me.onCreateGroupClick
            },
            'textbutton[action="guild_group_join"]': {
                click: me.onGroupJoinClick
            },
            '#change_guild_group_leader': {
                click: me.changeGroupLeader
            },
            '#leave_guild_group': {
                click: me.onGroupLeaveClick
            },
            '#guild_group_info dataview': {
                itemclick: me.doActionWithGroup
            },
            '#guild_raids': {
                itemclick: me.showRaidInfo
            }
        });
        me.user.on('guildchanged', me.onGuildChange, me);
        me.app.chatcn.on({
            command_update_guild_requests: me.onUpdateRequests,
            command_chat_update_group: me.updateGroups,
            scope: me
        });
        ExGods.Components.addComponentInitializer('guild', me.initGuildComponent, me);
    },
    onServiceUpdate: function() {
        var me = this,
            store = me.app.getGuildsStore(),
            guilds = me.service.data.guilds || [
                Ext.clone(me.service.data.guild)
            ];
        //если юзер в гильдии - то в сервисе не приходит идентификатор гильдии, берем его из юзера
        if (me.service.data.guild && !me.service.data.guild.id)  {
            me.service.data.guild.id = ExGods.app.getUser().getGuild();
        }
        
        if (!me.guildCard || !me.service.data.guild)  {
            store.loadRawData(guilds);
        }
        
        var guild = store.getUserGuild();
        if (guild && guild.isUserHead()) {
            //ставлю бидам флаг что они биды для обработки в сторе
            Ext.Array.each(me.service.data.bids, function(bid) {
                bid.isBid = true;
            });
            guild.set('bids', me.service.data.bids || []);
            guild.set(me.service.data.guild);
        }
    },
    updateRequests: function() {
        var me = this;
        me.service.command('guilds_requests', {}, function(data) {
            me.myRequestsStore.loadRawData(me.prepareMyRequests(data.my_request, data.types_request));
            me.requestsStore.loadRawData(me.prepareRequests(data.requests));
            me.onRequestsEmpty();
        });
    },
    updateShop: function() {
        var me = this;
        if (!me.service.shopService) {
            me.service.shopService = ExGods.Services.factory(me.service.data.shop_service_id);
        }
        me.service.shopService.init(null, function() {});
    },
    //
    updateQuests: function() {
        var me = this;
        if (!me.service.data.guild_noob) {
            me.service.command('guild_tasks', {}, function(data) {
                if (data.tasks) {
                    me.questsStore.loadRawData(data.tasks);
                    if (me.questsStore.getAt(0))  {
                        me.questsStore.getAt(0).set('expanded', true);
                    }
                    
                }
            });
        }
    },
    updateGroups: function(cb) {
        var me = this;
        if (ExGods.app.getUser().getBattle())  {
            return;
        }
        
        //в бою нельзя сервис запросить
        me.service.command('guild_groups', {}, function(data) {
            if (data.groups) {
                me.groupsStore.loadRawData(data.groups);
                me.getGroups().showGroupsList(data);
            } else  {
                me.showGroupInfo(data);
            }
            
            if (typeof cb == 'function')  {
                cb();
            }
            
        });
    },
    updateRaids: function(cb) {
        var me = this;
        me.service.command('guild_raids_info', {}, function(data) {
            if (data.raids) {
                Ext.Array.each(data.raids, function(raid) {
                    me.raidsStore.getById(Number(raid.entry)).set(raid);
                });
            }
            if (typeof cb == 'function')  {
                cb();
            }
            
        });
    },
    prepareMyRequests: function(requests, types_request) {
        var me = this,
            preparedRequests = [],
            myTypes = Ext.Array.map(requests, function(el) {
                return Number(el.type);
            });
        ExGods.references.get('guild_request_types').each(function(k, el) {
            var index = myTypes.indexOf(Number(el.entry));
            if (index != -1) {
                preparedRequests.push(requests[index]);
            } else {
                var request = {
                        type: el.entry
                    };
                var type_request = types_request ? Ext.Array.findBy(types_request, function(t) {
                        return t.entry == el.entry;
                    }) : null;
                if (type_request)  {
                    request.timeout = /*Math.floor(Math.random()*15) + 5*/
                    type_request.timeout;
                }
                
                preparedRequests.push(request);
            }
        });
        preparedRequests.reverse(function(r) {
            var c = 0;
            if (r.owner)  {
                c = 5;
            }
            
            if (!r.timeout)  {
                c++;
            }
            
            return c;
        });
        for (var i = 0; i < preparedRequests.length; i++) {
            preparedRequests[i].index = i;
        }
        return preparedRequests;
    },
    prepareRequests: function(requests) {
        //сортировать тут, т.к. иначе не получится сделать чередующиеся светлые с темными бекграунды в датавью,
        //т.к. xindex при обновлении любого элемента почему-то передается со значением 1, поэтому приходится сетить индекс
        //в каждом реквесте
        for (var i = 0; i < requests.length; i++) {
            requests[i].index = i;
        }
        return requests || [];
    },
    /**
     * Открывает интерфейс поиска гильдий
     */
    showSearch: function() {
        var me = this,
            store = me.app.getGuildsStore();
        if (!me.searchCard) {
            me.searchCard = Ext.widget('guildsearch', {
                store: store,
                service: me.service
            });
            me.cmp.add(me.searchCard);
        }
        me.cmp.getLayout().setActiveItem(me.searchCard);
    },
    /**
     * Открывает интерфейс гильдии со списком членов
     */
    showGuild: function() {
        var me = this,
            store = me.app.getGuildsStore();
        if (!me.guildCard) {
            me.guildCard = Ext.widget('guildtabpanel', {
                service: me.service,
                guild: store.getAt(0),
                myRequestsStore: me.myRequestsStore,
                requestsStore: me.requestsStore,
                questsStore: me.questsStore,
                groupsStore: me.groupsStore,
                raidsStore: me.raidsStore,
                listeners: {
                    afterrender: function() {
                        if (me.newRequests)  {
                            me.markRequestsTab(me.newRequests);
                        }
                        
                    }
                }
            });
            me.cmp.add(me.guildCard);
        }
        me.cmp.getLayout().setActiveItem(me.guildCard);
    },
    /**
     * Открывает интерфейс создания гильдии
     */
    showCreate: function() {
        var me = this;
        if (!me.createFormCard) {
            me.createFormCard = Ext.widget('guildcreate', {
                service: me.service
            });
            me.cmp.add(me.createFormCard);
        }
        me.cmp.getLayout().setActiveItem(me.createFormCard);
    },
    /**
     * Открывает интерфейс ожидания заявки в гильдию
     */
    showWait: function() {
        var me = this;
        if (!me.waitCard) {
            me.waitCard = Ext.widget('guildwait', {
                service: me.service
            });
            me.cmp.add(me.waitCard);
        }
        me.cmp.getLayout().setActiveItem(me.waitCard);
    },
    createGuild: function(btn) {
        var me = this,
            form = btn.up('guildcreate').down('form').getForm(),
            store = me.app.getGuildsStore();
        if (form.isValid()) {
            var params = form.getValues();
            if (params.options == 0)  {
                delete params.options;
            }
            
            if (params.description)  {
                params.description = params.description.replace(/\r?\n/g, '<br />');
            }
            
            Ext.widget('confirmdialog', {
                title: '',
                message: me.service.init_config.confirm_create,
                handler: function() {
                    me.service.command('create_guild', params, function(data) {
                        me.afterEnterGuildRequest(data);
                    });
                }
            });
        } else {
            form.markInvalid();
        }
    },
    joinGuild: function(guild) {
        var me = this,
            store = me.app.getGuildsStore();
        me.service.command('guild_add_user', {
            guild_id: guild.get('id')
        }, function(data) {
            me.afterEnterGuildRequest(data);
        });
    },
    afterEnterGuildRequest: function(data) {
        var me = this;
        if (data.success) {
            me.service.update(null, function() {
                if (ExGods.app.getUser().getGuild()) {
                    me.updateQuests();
                    me.updateRequests();
                    //me.updateShop();
                    me.showGuild();
                } else {
                    me.showWait();
                }
                me.destroyCards('searchCard');
            });
        }
    },
    searchForGuild: Ext.Function.createBuffered(function(textfield, e) {
        var me = this,
            value = textfield.getValue(),
            store = me.app.getGuildsStore();
        if (value) {
            me.service.command('search_guild', {
                title: textfield.getValue()
            }, function(data) {
                if (data.success)  {
                    store.loadRawData(data.guilds);
                }
                
            });
        } else {
            me.service.update();
        }
    }, 500),
    doActionWithMember: function(dataview, record, dom, index, e) {
        var me = this;
        if (e.target.className.indexOf('kick') != -1) {
            Ext.widget('confirmdialog', {
                title: '',
                message: me.service.init_config.confirm_kick,
                handler: function() {
                    me.service.command('remove_user_from_guild', {
                        user_to: record.get('display_title')
                    }, function(data) {
                        if (data.success) {
                            if (data.guilds) {
                                me.showSearch();
                                me.service.update(me.service.parseData(data));
                                me.destroyCards('guildCard');
                            } else {
                                me.service.update(me.service.parseData(data));
                            }
                        }
                    });
                }
            });
        } else if (e.target.className.indexOf('accept') != -1 || e.target.className.indexOf('decline') != -1) {
            Ext.widget('confirmdialog', {
                width: 350,
                title: '',
                message: me.service.init_config[e.target.className.indexOf('accept') != -1 ? 'confirm_confirm_bid' : 'confirm_refuse_bid'],
                handler: function() {
                    me.service.command(e.target.className.indexOf('accept') != -1 ? 'confirm_bid' : 'refuse_bid', {
                        user_to: record.get('display_title')
                    }, function(data) {
                        if (data.success) {
                            me.service.update(me.service.parseData(data));
                        }
                    });
                }
            });
        } else if (e.target.className.indexOf('send-social-message') != -1 && e.target.className.indexOf('disabled') == -1) {
            me.app.getSocialController().sendUserToUserMessage([
                record.get('social').social_net_id
            ], me.service.data.guild.snet_notice_inactive, function() {
                me.service.command('guild_snet_notice_inactive_sent', {
                    user_id: record.get('social').user_id
                });
                Ext.get(e.target).addCls('disabled');
            });
        }
    },
    leaveGuild: function() {
        var me = this;
        Ext.widget('confirmdialog', {
            title: '',
            message: me.service.init_config.confirm_leave,
            handler: function() {
                me.service.command('leave_guild', {}, function(data) {
                    if (data.success) {
                        me.service.update(null, function() {
                            me.showSearch();
                            me.destroyCards('guildCard');
                        });
                    }
                }, {
                    queue: false
                });
            }
        });
    },
    changeGuildHead: function() {
        var me = this,
            cfg = me.service.init_config,
            usersStore = me.app.getGuildsStore().getUserGuild().get('users'),
            users = usersStore.queryBy(function(rec) {
                return !rec.get('isBid') && rec.get('display_title') != ExGods.app.getUser().get('display_title');
            }).items;
        var wnd = ExGods.Components.factory('USER_TARGET_PANEL', {
                windowTitle: cfg.guild_change_head_wnd_title,
                users: users,
                searchEmptyText: cfg.guild_change_head_empty_text,
                buttonText: cfg.guild_change_head,
                listeners: {
                    select: function(panel, record) {
                        me.service.command('change_head_guild', {
                            user_to: record.get('display_title')
                        }, function(data) {
                            if (data.success) {
                                me.service.update(me.service.parseData(data));
                                var guildInfo = me.guildCard.down('#guild_info');
                                if (guildInfo && guildInfo.isVisible()) {
                                    guildInfo.down('#guild_description').update(data.guild);
                                }
                                wnd.close();
                            }
                        });
                    }
                }
            });
    },
    changeGroupLeader: function() {
        var me = this,
            cfg = me.service.init_config,
            usersStore = me.getGroups().getLayout().getActiveItem().store,
            users = usersStore.queryBy(function(rec) {
                return rec.get('display_title') != ExGods.app.getUser().get('display_title');
            }).items;
        var wnd = ExGods.Components.factory('USER_TARGET_PANEL', {
                windowTitle: cfg.group_change_head_wnd_title,
                users: users,
                searchEmptyText: cfg.group_change_head_empty_text,
                buttonText: cfg.group_change_leader,
                listeners: {
                    select: function(view, record) {
                        me.service.command('guild_change_group_creator', {
                            title: record.get('display_title')
                        }, function(data) {
                            if (data.success) {
                                me.updateGroups(function() {
                                    wnd.close();
                                });
                            }
                        });
                    }
                }
            });
    },
    callBackBid: function() {
        var me = this;
        me.service.command('callback_bid', {}, function(data) {
            if (data.success) {
                me.service.update(null, function() {
                    me.showSearch();
                    me.destroyCards('waitCard');
                });
            }
        });
    },
    onSorterSelect: function(combo, selected) {
        var me = this,
            value = selected.data.value,
            store = me.app.getGuildsStore();
        store.getSorters().getAt(0).setDirection(value);
        store.sort();
    },
    onGuildTypeChange: function(radiogroup, newValue, oldValue) {
        var me = this,
            value = newValue.guild_type,
            store = me.app.getGuildsStore();
        store.removeFilter('guild_type');
        if (value == 1) {
            store.addFilter(Ext.util.Filter({
                filterFn: function(rec) {
                    return rec.get('open') == 1;
                },
                id: 'guild_type'
            }));
        } else if (value == 2) {
            store.addFilter(Ext.util.Filter({
                filterFn: function(rec) {
                    return rec.get('open') == 0;
                },
                id: 'guild_type'
            }));
        }
    },
    onChangeDescription: function(guild, component) {
        var me = this,
            cfg = me.service.init_config;
        Ext.widget('floatwindow', {
            width: 400,
            buttonAlign: 'center',
            buttons: {
                defaultType: 'textbutton',
                items: [
                    {
                        text: cfg.guild_save_description_btn,
                        cls: 'no_border',
                        handler: function() {
                            var _me = this,
                                wnd = _me.up('floatwindow'),
                                value = wnd.down('textarea').getValue();
                            me.service.command('change_description', {
                                description: value.replace(/\r?\n/g, '<br />')
                            }, function(data) {
                                if (data.success) {
                                    guild.set('description', value.replace(/\r?\n/g, '<br />'));
                                    if (component && component.isVisible())  {
                                        component.down('#guild_description').update(guild.data);
                                    }
                                    
                                    wnd.close();
                                }
                            });
                        }
                    },
                    {
                        text: cfg.guild_cancel_change_descr_btn,
                        cls: 'no_border x-btn-txt-red',
                        handler: function() {
                            this.up('floatwindow').close();
                        }
                    }
                ]
            },
            items: [
                {
                    xtype: 'textarea',
                    height: 100,
                    margin: '7 5',
                    value: guild.get('description').replace(/<br\s*\/?>/mg, "\n")
                }
            ]
        });
    },
    onGuildHelpClick: function(btn) {
        var me = this;
        me.service.command('answer_request', {
            request_id: btn.request_id
        }, function(data) {
            me.updateRequests();
        });
    },
    onQuestExpand: function(listitem) {
        var me = this,
            r = listitem.record;
        if (r.task_pcp_requested)  {
            return;
        }
        
        r.task_pcp_requested = true;
        me.service.command('guild_task_pcp', {
            task_id: r.get('task_id')
        }, function(data) {
            if (data.pcp) {
                r.set('pcp', data.pcp);
                //запрашивать информацию о пцп можно раз в 15 сек. Без делея не обойтись, т.к. на сет срабатывает экспанд и попадает в замкнутый цикл
                setTimeout(function() {
                    r.task_pcp_requested = false;
                }, 15000);
            } else {
                r.task_pcp_requested = false;
            }
        });
    },
    onActivateTab: function(tabpanel, activeCmp) {
        var me = this;
        if (activeCmp.id == 'guild-shop') {
            me.updateShop();
        } else if (activeCmp.id == 'guild_help') {
            me.unmarkMenuBtn();
            me.unmarkRequestTab();
        } else if (activeCmp.id == 'guild_groups') {
            me.updateGroups();
        } else if (activeCmp.xtype == 'guildraids') {
            me.updateRaids();
        }
    },
    onInfoClick: function(view, optEl, desc) {
        var me = this;
        if (me.optToolTip)  {
            me.optToolTip.close();
        }
        
        me.optToolTip = Ext.widget('parchmentwindow', {
            itemElement: optEl,
            html: [
                '<div class="chest-info-tooltip-text">',
                desc,
                '</div>'
            ].join('')
        });
    },
    onGuildChange: function(guild_id) {
        var me = this;
        //если интерфейс не открыт - то не актуально
        if (!me.wnd || !me.wnd.isVisible())  {
            return;
        }
        
        var card = me.cmp.getLayout().getActiveItem();
        if (guild_id && card.xtype == 'guildwait') {
            me.service.update(null, function() {
                me.updateQuests();
                me.updateRequests();
                //me.updateShop();
                me.showGuild();
                me.destroyCards('waitCard');
            });
        } else if (!guild_id && card.xtype == 'guildtabpanel') {
            me.service.update(null, function() {
                me.showSearch();
                me.destroyCards('guildCard');
            });
        }
    },
    /**
     * Вызываю на команду чата update_guild_requests
     */
    onUpdateRequests: function(chatcn, data) {
        var me = this;
        if (me.user.get('id') == data.body.user)  {
            return;
        }
        
        me.newRequests++;
        //если интерфейс не открыт - маркаю кнопку
        if (!me.wnd || !me.wnd.isVisible())  {
            return me.markMenuBtn();
        }
        
        var card = me.cmp.getLayout().getActiveItem();
        if (card.xtype == 'guildtabpanel') {
            me.updateRequests();
            if (card.getActiveTab().xtype != 'guildhelp') {
                me.markMenuBtn();
                me.markRequestsTab();
            } else {
                me.newRequests--;
            }
        } else  {
            me.markMenuBtn();
        }
        
    },
    /**
     * Кнопка меню и таб гильдии маркаются на команду чата в методе onUpdateRequests,
     * но если во время загрузки у меня обновится стор реквестов и он пустой - мне надо убрать марки
     */
    onRequestsEmpty: function() {
        var me = this,
            count = me.requestsStore.getCount();
        if (!count) {
            me.unmarkMenuBtn();
            if (me.wnd && me.wnd.isVisible())  {
                me.unmarkRequestTab();
            }
            
        }
    },
    onCreateGroupClick: function(btn) {
        var me = this,
            title = btn.up('toolbar').down('textfield').getValue(),
            loot_type = btn.up('toolbar').down('radiogroup') ? btn.up('toolbar').down('radiogroup').getValue() : '';
        me.service.command('guild_create_group', {
            title: title,
            loot_type: loot_type
        }, me.showGroupInfo.bind(me));
    },
    onGroupJoinClick: function(btn) {
        var me = this;
        me.service.command('guild_join_group', {
            entry: btn.group_id
        }, me.showGroupInfo.bind(me));
    },
    onGroupLeaveClick: function() {
        var me = this;
        Ext.widget('confirmdialog', {
            title: '',
            message: me.service.init_config.confirm_leave_group,
            handler: function() {
                me.service.command('guild_unjoin_group', {}, function(data) {
                    if (data.success) {
                        me.updateGroups();
                    }
                });
            }
        });
    },
    //me.app.getChatGroupController().deactivateGroup();
    doActionWithGroup: function(dataview, record, dom, index, e) {
        var me = this;
        if (e.target.className.indexOf('kick') != -1) {
            Ext.widget('confirmdialog', {
                title: '',
                message: me.service.init_config.confirm_kick_group,
                handler: function() {
                    me.service.command('guild_kick_user_group', {
                        title: record.get('display_title')
                    }, function(data) {
                        if (data.success) {
                            me.updateGroups();
                        }
                    });
                }
            });
        }
    },
    showRaidInfo: function(dataview, record, dom, index, e) {
        var me = this,
            rewards = record.get('rewards'),
            show = function() {
                Ext.widget('raidinfowindow', {
                    complete: record.isComplete(),
                    record: record,
                    show_rewards: dataview.up('guildraids').show_rewards,
                    itemElement: dom
                });
            };
        if (record.get('empty'))  {
            return;
        }
        
        if (rewards && rewards.length) {
            var me = this,
                missedProtos = [],
                protos = ExGods.app.getItemPrototypesStore(),
                i = rewards.length;
            while (i--) {
                if (parseInt(rewards[i].params.id) && !protos.data.getByKey(rewards[i].params.id))  {
                    missedProtos.push(rewards[i].params.id);
                }
                
            }
            protos.loadNew(missedProtos, show);
        } else {
            show();
        }
    },
    showGroupInfo: function(data) {
        if (!data.group)  {
            return;
        }
        
        if (!this.getGroups())  {
            return;
        }
        
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            i = data.group.users.length;
        while (i--) {
            if (!protos.data.getByKey(data.group.users[i].mask_proto_id))  {
                missedProtos.push(data.group.users[i].mask_proto_id);
            }
            
        }
        protos.loadNew(missedProtos, function() {
            if (me.getGroups())  {
                me.getGroups().showGroupInfo(data.group);
            }
            
        });
    },
    markMenuBtn: function() {
        var me = this;
        me.getGuildButton().reset();
        me.getGuildButton().addCount(me.newRequests);
    },
    markRequestsTab: function(count) {
        this.getRequestsTab().addCount(count || 1);
    },
    unmarkMenuBtn: function() {
        this.getGuildButton().reset();
        this.newRequests = 0;
    },
    unmarkRequestTab: function() {
        this.getRequestsTab().reset();
        this.newRequests = 0;
    },
    initGuildComponent: function(config, id) {
        var me = this,
            user_guild = me.app.getUser().getGuild();
        me.onServiceUpdate();
        me.cmp = Ext.widget('guildcontainer', config);
        me.service.init_config = config;
        me.wnd = Ext.widget('window2', {
            id: id,
            items: [
                me.cmp
            ],
            autoShow: false,
            onDestroy: function() {
                me.destroyCards();
                this.callParent();
            }
        });
        if (user_guild && me.service.data.guild) {
            me.updateQuests();
            me.updateRequests();
            //me.updateShop();
            me.showGuild();
        } else if (me.service.data.guild) {
            me.showWait();
        } else {
            me.showSearch();
        }
        ExGods.app.block();
        ExGods.Resources.load(me.wnd, function() {
            ExGods.app.unblock();
            me.wnd.show();
        });
        return me.wnd;
    },
    destroyCards: function(card_name) {
        var me = this;
        if (card_name) {
            if (me[card_name]) {
                me[card_name].destroy();
                me[card_name] = false;
            }
        } else {
            me.destroyCards('guildCard');
            me.destroyCards('searchCard');
            me.destroyCards('waitCard');
            me.destroyCards('createFormCard');
        }
    },
    /**
     * Обработка клика по предмету в магазине
     */
    onShopItemClick: function(itemView, shopItem, itemEl, zero, event) {
        var me = this,
            target = event.target || event.srcElement;
        if (!target.getTarget('.x-btn')) {
            me.app.getController('Shop').buyItem(shopItem, 1, me.service.shopService);
            event.stopPropagation();
        }
    }
});

/**
 * Хранилище гильдейцев онлайн
 */
Ext.define('ExGods.store.GuildOnlineList', {
    extend: ExGodsCore.store.ChatContacts,
    model: 'ExGods.model.BasicUser'
});

/**
 * Контроллер списка гильдейцев в чате
 */
Ext.define('ExGods.controller.GuildOnline', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    views: [],
    //
    models: [
        'BasicUser'
    ],
    stores: [
        'GuildOnlineList'
    ],
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'GuildOnline:'
    },
    init: function(app) {
        var me = this;
        me.control({
            '#guild-chat-messages': {
                render: me.onChatMessagesRender,
                destroy: me.onChatMessagesDestroy
            }
        });
        me.app.getChatConnection().on({
            command_online_guild_user: me.onOnlineUser,
            command_offline_guild_user: me.onOfflineUser,
            scope: me
        });
        me.callParent(arguments);
    },
    /*********** PRIVATES *************

    /**
     * @private
     * Получает список гильдейцев
     */
    getGuildOnlineList: function(callback) {
        var me = this,
            user = me.getUser();
        me.request({
            url: 'game.pl?cmd=guild_online',
            method: 'GET',
            queue: false,
            success: function(result) {
                var userList = result.guild_online,
                    users = me.getBasicUserModel().proxy.reader.read(userList).records,
                    onlineList = [],
                    type, user, i;
                for (i = 0; i < users.length; i++) {
                    user = users[i];
                    onlineList.push(user);
                }
                callback(onlineList);
            }
        });
    },
    /**
     * @private
     * Обработчик создания вкладки сообщений гильдии
     */
    onChatMessagesRender: function() {
        var me = this;
        me.getGuildOnlineList(function(records) {
            me.app.getStore('GuildOnlineList').loadRecords(records);
        });
    },
    /**
     * @private
     * Обработчик удаления вкладки сообщений гильдии
     */
    onChatMessagesDestroy: function() {
        var me = this;
        me.app.getStore('GuildOnlineList').removeAll();
    },
    /**
     * @private
     * Обработчик команды чата "online_guild_user"
     */
    onOnlineUser: function(conn, data) {
        var me = this,
            store = me.app.getStore('GuildOnlineList'),
            index = store.findBy(function(rec) {
                return rec.data.display_title == data.body.user.display_title;
            });
        if (index == -1) {
            store.add(data.body.user);
        }
    },
    /**
     * @private
     * Обработчик команды чата "offline_guild_user"
     */
    onOfflineUser: function(conn, data) {
        var me = this,
            store = me.app.getStore('GuildOnlineList'),
            index = store.findBy(function(rec) {
                return rec.data.display_title == data.body.user.display_title;
            });
        if (index != -1) {
            store.removeAt(index);
        }
    }
});

/**
 * Контейнер распределения лута
 */
Ext.define('ExGods.view.loot.Container', {
    extend: Ext.panel.Panel,
    alias: 'widget.lmcontainer',
    id: 'loot_manager_container',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    padding: '6 10 11',
    //margin:4,
    plugins: [
        'paperdeco'
    ],
    initComponent: function() {
        var me = this;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-title"><h4>' + ExGods.getMsgByKey('loot_title') + '</h4></div>'
            },
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="loot-description">' + ExGods.getMsgByKey('loot_descr') + '</div>',
                padding: '0 17'
            },
            {
                dock: 'top',
                xtype: 'lootslots'
            },
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.inventoryType = {
            xtype: 'loottype',
            id: 'loottypeInventoryTypeId',
            margin: '0 0 0 1',
            loot_type: 'inventory'
        };
        me.guildType = {
            xtype: 'loottype',
            id: 'loottypeGuildTypeId',
            loot_type: 'guild'
        };
        me.groupType = {
            xtype: 'loottype',
            id: 'loottypeGroupTypeId',
            loot_type: 'group',
            width: 242
        };
        me.items = [
            me.inventoryType,
            {
                xtype: 'component',
                html: '<div class="v-separator"></div>'
            },
            me.guildType,
            {
                xtype: 'component',
                html: '<div class="v-separator"></div>'
            },
            me.groupType
        ];
        me.inventoryType = undefined;
        me.guildType = undefined;
        me.groupType = undefined;
        me.callParent();
    },
    initLootTypes: function() {
        if (!this.inventoryType) {
            this.inventoryType = Ext.getCmp('loottypeInventoryTypeId');
            this.guildType = Ext.getCmp('loottypeGuildTypeId');
            this.groupType = Ext.getCmp('loottypeGroupTypeId');
        }
    },
    highlight: function(types) {
        var me = this,
            i = types.length;
        me.initLootTypes();
        while (i--) {
            me[types[i] + 'Type'].highlight();
        }
    },
    unhighlight: function() {
        var me = this;
        me.initLootTypes();
        this.inventoryType.unhighlight();
        this.guildType.unhighlight();
        this.groupType.unhighlight();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        return {
            images: []
        };
    }
});

/**
 * Контейнер распределения лута
 */
Ext.define('ExGods.view.loot.Slots', {
    extend: ExGods.view.grid.SlotsGrid,
    alias: 'widget.lootslots',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.InventoryDragHighlight
    ],
    margin: '0 17 5',
    initComponent: function() {
        var me = this;
        // настройки грида
        me.rowsCount = 2;
        me.columnsCount = 11;
        me.pager = {
            hideIfSinglePage: true,
            tpl: null
        };
        me.cls += ' virtual-store';
        me.store = ExGods.app.getStore('Loot');
        me.itemTpl = [
            '{[ExGods.stuff.StuffManager.image(values)]}'
        ];
        me.callParent(arguments);
        me.view = me.down('dataview');
        me.view.on('afterrender', function() {
            me.initDrag({
                view: me.view
            });
            me.initDragHighlight();
        });
    },
    collectData: function(records) {
        var me = this,
            data = [];
        Ext.Array.each(records, function(rec) {
            data.push({
                type: 'virtual_store_stuff',
                sourceModel: rec,
                params: {
                    stuff: {
                        params: {
                            id: rec.data.stuff.params.id,
                            quantity: rec.data.stuff.params.quantity
                        },
                        type: rec.data.stuff.type
                    }
                }
            });
        });
        return data;
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            var itm = me.store.data.items[i];
            stuff_arr.push(itm.data.stuff);
        }
        return {
            stuff: stuff_arr,
            images: []
        };
    }
});

/**
 * Контейнер распределения лута
 */
Ext.define('ExGods.view.loot.Type', {
    extend: Ext.panel.Panel,
    alias: 'widget.loottype',
    mixins: [
        ExGods.mixin.ItemDroppable
    ],
    cls: 'loot-type',
    layout: 'fit',
    width: 241,
    initComponent: function() {
        var me = this;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                //width:246,
                html: '<div class="paper-title"><h4>' + ExGods.getMsgByKey('loot_type_title_' + me.loot_type) + '</h4></div>'
            }
        ];
        me.html = [
            //'<div class="loot-type-description">'+ExGods.getMsgByKey('loot_type_descr_'+me.loot_type)+'</div>',
            '<div class="loot-type-image" style="background-image:url(' + ExGods.ref('images|loot_slots').image[me.loot_type] + ')"></div>'
        ];
        me.callParent();
    },
    highlight: function() {
        this.el.down('.loot-type-image').addCls('highlight');
    },
    unhighlight: function() {
        this.el.down('.loot-type-image').removeCls('highlight');
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.initDrop({
            onNodeDrop: function(target, dd, e, data) {
                if (target.className.indexOf('highlight') != -1 || (target.childNodes[0] && target.childNodes[0].className && target.childNodes[0].className.indexOf('highlight') != -1)) {
                    me.fireEvent('drop', me, target, data.item, data.itemEl);
                    return false;
                } else  {
                    return false;
                }
                
            }
        });
    },
    getResources: function() {
        var me = this,
            arr_images = [];
        var img = ExGods.ref('images|loot_slots').image[me.loot_type];
        return {
            images: [
                img
            ].concat(arr_images)
        };
    }
});

/**
 * Контроллер управления распределением лута
 */
Ext.define('ExGods.controller.LootManager', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    views: [
        'loot.Container',
        'loot.Slots',
        'loot.Type'
    ],
    init: function(app) {
        var me = this;
        me.lootStore = ExGods.app.getStore('Loot');
        me.vsctrl = ExGods.app.getInventoryVirtualStoreController();
        me.inventory = ExGods.app.getInventoryInventoryController();
        me.control({
            '#loot_manager_btn': {
                click: me.onOpenBtnClick
            },
            'lootslots': {
                startdrag: me.onStartDrag,
                stopdrag: me.onStopDrag
            },
            'loottype': {
                drop: me.onDrop
            },
            '#self_loot_btn': {
                click: me.onSelfLootBtnClick
            }
        });
    },
    onSelfLootBtnClick: function() {
        var me = this;
        me.app.block();
        me.inventory.service.command('put_from_store_loot', {}, function(json) {
            me.app.unblock();
        });
    },
    onOpenBtnClick: function(btn, e) {
        var inventory = Ext.getCmp('INVENTORY');
        if (inventory && inventory.down('#loot_manager_btn')) {
            var counterEl = inventory.down('#loot_manager_btn').el.down('.newitems-counter');
            if (counterEl) {
                counterEl.remove();
            }
        }
        this.openLootManager();
    },
    onStartDrag: function(data) {
        var rec = data.item,
            destinations = [],
            rec_destinations = rec.get('destinations');
        if (rec_destinations.indexOf('inventory') != -1)  {
            destinations.push('inventory');
        }
        
        if (rec_destinations.indexOf('guild_store') != -1)  {
            destinations.push('guild');
        }
        
        if (rec_destinations.indexOf('group') != -1)  {
            destinations.push('group');
        }
        
        Ext.getCmp('VIRTUAL_STORE').down('lmcontainer').highlight(destinations);
    },
    onStopDrag: function(data) {
        Ext.getCmp('VIRTUAL_STORE').down('lmcontainer').unhighlight();
    },
    onDrop: function(cmp, target, rec, el) {
        var me = this;
        switch (cmp.loot_type) {
            case 'inventory':
                me.toInventory(rec);
                break;
            case 'guild':
                me.toGuild(rec);
                break;
            case 'group':
                me.toGroup(rec);
                break;
        }
    },
    toInventory: function(rec) {
        this.vsctrl.doPutItems.call(this.vsctrl, rec, 1);
    },
    toGuild: function(rec) {
        this.vsctrl.doPutItems.call(this.vsctrl, rec, 1, false, {
            destination: 'guild_store'
        });
    },
    toGroup: function(rec) {
        this.vsctrl.doPutOnGroup.call(this.vsctrl, rec, 1);
    },
    openLootManager: function() {
        ExGods.Components.factory("VIRTUAL_STORE");
    }
});

Ext.define('ExGods.view.pet.Info', {
    extend: Ext.panel.Panel,
    alias: 'widget.petinfo',
    cls: 'pet-info',
    plugins: [
        'extraparchmentdeco'
    ],
    closable: false,
    width: 218,
    height: 370,
    /**
     * @required
     * @cfg pet - модель питомца
     */
    initComponent: function() {
        var me = this;
        me.data = me.pet.data;
        if (!me.data.title) {
            me.data.title = me.data.item_proto.title || ExGods.app.getItemPrototypesStore().data.getByKey(me.data.item_proto).data.title;
        }
        if (!me.data.actions || !me.data.actions.length) {
            me.data.actions = me.data.item_proto.action_full || ExGods.app.getItemPrototypesStore().data.getByKey(me.data.item_proto).data.action_full;
        }
        me.tpl = [
            '<h6 class="pet-info-title ellipsis">{title}</h6>',
            '<div class="pet-info-group ellipsis">{group}</div>',
            '<div class="parchment-separator"></div>',
            '<tpl if="stats">',
            '<div class="paper-title">' + me.clientConfig.stats_title + '</div>',
            '<div class="pet-stats">',
            '{[ ExGods.util.User.printUserStats(values.fit_stats || ExGods.app.user.data.stats.stats, {visibleValue: 1, align: "right", changes: this.getChanges(values)}) ]}',
            '</div>',
            '<div class="parchment-separator"></div>',
            '</tpl>',
            '<tpl if="actions.length">',
            '<div class="paper-title">' + me.clientConfig.actions_title + '</div>',
            '<div class="pet-actions">',
            '<tpl if="actions.length &gt; 1">',
            '<tpl for="actions">',
            '<tpl if="xindex < 4">',
            '<div class="action" data-qtip="{label}" data-type="feature">',
            '<div class="notify_i"></div>',
            '<img height="50" width="50" src="{[IMAGE_URL + values.images.main]}">',
            '{title}',
            '</div>',
            '</tpl>',
            '</tpl>',
            '<tpl else>',
            '<tpl for="actions">',
            '{[this.printFeature(values)]}',
            '</tpl>',
            '</tpl>',
            '</div>',
            '<div class="parchment-separator"></div>',
            '</tpl>',
            '<div class="paper-title">' + me.clientConfig.battle_actions_title + '</div>',
            '<tpl if="battle_actions.length">',
            '<div class="pet-battle-actions">',
            '<tpl for="battle_actions">',
            '<tpl if="xindex < 4">',
            '<div class="action{[this.getBattleActionCls(parent)]}" data-id="{id}" data-type="{type}" data-qtip="{title}">',
            '<div class="notify_i"></div>',
            '<img height="50" width="50" src="{img}">',
            '<strong>{title}</strong>',
            '</div>',
            '</tpl>',
            '</tpl>',
            '</div>',
            '<tpl else>',
            '<div class="pet-battle-actions-empty">' + me.clientConfig.battle_actions_empty + '</div>',
            '</tpl>',
            '<div class="parchment-separator"></div>',
            '<div class="paper-title">' + me.clientConfig.control_title + '</div>',
            '<tpl if="has">',
            '<div class="pet-info-state">',
            '<div class="component">',
            '<span role="xtype">petstate</span>',
            '<span role="pet_id">{entry}</span>',
            //'<span role="clientConfig:object">' + Ext.encode(me.clientConfig) + '</span>',
            '</div>',
            '</div>',
            '<tpl else>',
            '<div class="pet-no-pet">' + me.clientConfig.no_pet_text + '</div>',
            '</tpl>',
            //'<div class="parchment-separator"></div>',
            {
                printFeature: function(values) {
                    return me.printFeatureTpl(values);
                },
                getBattleActionCls: function(values) {
                    return values.battle_actions.length == 1 || (values.battle_actions.length == 2 && !values.actions.length && !values.stats) ? ' single' : '';
                },
                getChanges: function(values) {
                    var user = ExGods.app.user,
                        changes = {};
                    if (values.fit_stats) {
                        Ext.each(config.references.user_stat, function(item) {
                            if (item.visible == 1 && !item.param.fill) {
                                var cur_stat = values.fit_stats[item.name],
                                    was_stat = user.data.stats.stats[item.name],
                                    change = Number(cur_stat) - Number(was_stat);
                                changes[item.name] = change;
                            }
                        });
                    }
                    return changes;
                }
            }
        ];
        //форматирую кнопки
        // me.buttons = {
        //  vertical: true,
        //  margin: '13 31',
        //  defaults: {
        //      xtype: 'textbutton',
        //      cls: 'no_border',
        //      width: 150,
        //      margin: '0 0 10'
        //  },
        //  items: [{
        //      text: me.clientConfig.pet_control_btn,
        //      disabled: !me.pet.get('has'),
        //      itemId: 'pet_control_btn'
        //  }].concat(me.buttons || [])
        // }
        me.callParent();
        if (me.pet.get('has')) {
            me.addCls('has');
        }
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.on('click', me.onItemClick, me, {
            delegate: '.action'
        });
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Helper.destroyComponents(me.el);
        me.callParent(arguments);
    },
    update: function(data) {
        var me = this;
        me[data.has ? 'addCls' : 'removeCls']('has');
        //me.down('#pet_control_btn').setDisabled(!data.has);
        me.callParent(arguments);
        ExGods.util.Helper.renderComponents(me.el, me);
    },
    onItemClick: function(e, el) {
        var me = this,
            id = el.getAttribute('data-id'),
            type = el.getAttribute('data-type'),
            title = el.getAttribute('data-qtip'),
            info = ExGods.ref(type + '|' + id);
        if (info) {
            if (type == 'battle_turn') {
                info.turn_type = ExGods.getMsgByKey('masks_turn_type_name');
            } else if (type == 'battle_prep') {
                info.turn_type = ExGods.getMsgByKey('masks_prep_type_name');
            } else if (type == 'battle_actions') {
                info.turn_type = ExGods.getMsgByKey('masks_action_type_name');
            }
            Ext.widget('commondetailswindow', {
                itemElement: el,
                data: {
                    label: info.label,
                    image: IMAGE_URL + (info.desc.images ? info.desc.images['active'] : info.desc.img),
                    rows: [
                        {
                            content: info.turn_type
                        },
                        {
                            content: info.desc.desc || info.desc.description
                        }
                    ]
                }
            });
        } else if (type == 'feature') {
            //Бонус от группы IV
            var feature_data = Ext.Array.findBy(me.pet.get('actions'), function(el) {
                    return el.label == title;
                });
            Ext.widget('commondetailswindow', {
                itemElement: el,
                padding: '6 0 12',
                headerTpl: me.printFeatureTpl(feature_data),
                data: feature_data
            });
        }
    },
    printFeatureTpl: function(data) {
        var me = this;
        return new Ext.XTemplate('<div class="display_like_table item_feature">', '<tpl if="images.main">', '<div class="cell_align_middle feature-image" style="background-image: url({[IMAGE_URL + values.images.main]})"></div>', '</tpl>', '<div class="cell_align_middle feature-content{[this.getFeatureCls(values)]}">', '<div class="feature-label" style="color:{[this.getFeatureColor()]}">{label}</div>', '<tpl if="grade">', '<div class="item_grade_stars">', '<div class="item_star_bg" style="width:' + ExGods.ref('constants|item_feature_stars').value * 14 + 'px">', '<div class="item_star" style="{[this.getStarsStyle(values)]}"></div>', '</div>', '</div>', '</tpl>', '<div>{description2}</div>', '</div>', '</div>', {
            getFeatureCls: function(values) {
                return values.images.main && typeof values.grade == 'number' ? ' left-line' : '';
            },
            getFeatureColor: function() {
                var item_grade = Number(me.pet.get('item_proto').data.item_grade);
                return ExGods.references.get('constants_list').item_grades.value[Math.max(item_grade, 0)];
            },
            getStarsStyle: function(values) {
                return [
                    'height: 14px;',
                    'width: ' + values.grade * 14 + 'px;',
                    'max-width:' + ExGods.ref('constants|item_feature_stars').value * 14 + 'px'
                ].join('');
            }
        }).apply(data);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        for (var i = 0; i < me.data.battle_actions.length; i++) {
            arr_images.push(me.data.battle_actions[i].img);
        }
        var act = me.pet.get('actions');
        for (var i = 0; i < act.length; i++) {
            for (var it in act[i].images) {
                if (act[i].images[it]) {
                    arr_images.push(act[i].images[it]);
                }
            }
        }
        return {
            images: [
                me.data.image
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.pet.Tape', {
    extend: ExGods.view.Tape,
    alias: 'widget.pettape',
    cls: 'mask-items',
    bodyStyle: {
        overflow: 'visible'
    },
    cellWidth: 86,
    cellHeight: 82,
    initComponent: function() {
        var me = this;
        me.itemTpl = [
            '<div class="qh-object item {[this.getClass(values)]}" data-qh_otype="room_pet" data-qh_oid="{item_proto.entry}" id="petid-{entry}" data-qtip="{[this.getEscapedTitle(values)]}" >',
            '<div class="mask_frm"></div>',
            '<img class="image" src="{[this.getImage(values)]}" width="50" height="50">',
            '<div class="sticker"{[ this.getStickerStyle(values) ]}></div>',
            '</div>',
            {
                getClass: function(values) {
                    return values.has ? ' has' : '';
                },
                checkDur: function(values) {
                    return values.item_proto.param.nonbr == 0;
                },
                getEscapedTitle: function(values) {
                    return Ext.String.htmlEncode(values.item_proto.title);
                },
                getImage: function(values) {
                    return values.has ? values.item_proto.images.on : values.item_proto.images.off;
                },
                getStickerStyle: function(values) {
                    var style = '';
                    if (values.steepness > 1) {
                        var images = ExGods.ref('images|pets_images').image,
                            image = values.has ? images.trophies_rare : images.trophies_rare_bw;
                        style = ' style="background-image: url(' + image + ')"';
                    }
                    return style;
                }
            }
        ];
        me.scrollDuration = ExGods.ref('constants|mask_scroll_time').value * 1000;
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.printSelector();
    },
    printSelector: function() {
        var me = this;
        me.el.insertHtml('beforeEnd', '<div class="mask_selected_frame"></div>');
    },
    /**
     * override
     */
    getNodeByRecord: function(record) {
        return this.el.down('#petid-' + record.get('entry'));
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var parent = me.callParent();
        var images_trophies = ExGods.ref('images|pets_images').image;
        for (var it in images_trophies) {
            arr_images.push(images_trophies[it]);
        }
        return {
            stuff: [].concat(parent.stuff),
            images: [
                IMAGE_URL + 'mask/mask_select.png'
            ].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 * Окно в котором петы отображаются таблицей
 */
Ext.define('ExGods.view.pet.AllPets', {
    extend: Ext.panel.Panel,
    alias: 'widget.allpets',
    bodyPadding: '7 8 0 6',
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'panel',
                layout: 'absolute',
                height: 415,
                items: [
                    {
                        xtype: 'petinfo',
                        clientConfig: me.clientConfig,
                        pet: me.pet,
                        x: 6,
                        y: 0,
                        //height: 415,
                        padding: '0 0 6'
                    },
                    // buttons: [{
                    //  text: me.clientConfig.pet_leave_btn,
                    //  cls: 'no_border x-btn-txt-red',
                    //  itemId: 'pet_release_btn'
                    // }]
                    {
                        xtype: 'petsgrid',
                        x: 240,
                        y: 32,
                        store: me.store,
                        pager: {
                            marginLeft: -278,
                            marginRight: -41,
                            textTop: -20
                        },
                        listeners: {
                            viewready: function() {
                                me.setPet();
                            }
                        }
                    },
                    {
                        // xtype: 'textbutton',
                        // itemId: 'feed_all_pets',
                        // cls: 'x-btn-txt-green',
                        // disabled: !me.store.isAnyPet() || me.store.isAllFeed(),
                        // text: me.clientConfig.feed_all_text,
                        cls: 'x-btn-txt-green',
                        xtype: 'textbutton',
                        text: me.clientConfig.pet_control_btn,
                        itemId: 'pet_control_btn',
                        disabled: !me.pet.get('has'),
                        x: 64,
                        /*235*/
                        y: 374
                    }
                ]
            }
        ];
        /*, {
                xtype: 'textbutton',
                itemId: 'release_all_pets',
                cls: 'x-btn-txt-red',
                disabled: !me.store.isAnyPet(),
                text: me.clientConfig.release_all_text,
                x: 630,
                y: 374
            }*/
        me.callParent();
    },
    setPet: function(record, stats) {
        record = record || this.pet;
        var me = this,
            dataview = me.down('dataview'),
            info = me.down('petinfo'),
            controlBtn = me.down('#pet_control_btn');
        info.pet = record;
        info.update(Ext.apply({
            fit_stats: stats
        }, record.data));
        controlBtn.setDisabled(!record.get('has'));
        dataview.select(record);
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Окно контроля питомца
 */
Ext.define('ExGods.view.pet.Control', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.petcontrol',
    autoShow: true,
    width: 298,
    bodyPadding: 5,
    y: 180,
    // по высоте центрирую относительно локации
    plugins: [
        'skindeco'
    ],
    cls: 'pet-control',
    buttonAlign: 'center',
    /**
     * @required
     * @cfg pet - модель питомца
     */
    initComponent: function() {
        var me = this,
            value = me.pet.get('item').param.dur,
            max = me.pet.get('item_proto').param.dur,
            to_feed = Math.max(max - value, 1),
            has_price_stuff = !Ext.isEmpty(me.pet.get('price_stuff')) && me.pet.get('price_stuff').type;
        if (has_price_stuff) {
            me.y -= 40;
        }
        me.items = [
            {
                plugins: [
                    'paperdeco'
                ],
                width: me.width - 10,
                height: has_price_stuff ? 291 : 205,
                padding: '7 10 20',
                data: me.pet.data,
                tpl: [
                    '<div class="paper-title"><h4>{title}</h4></div>',
                    '<div class="pet-control-img">',
                    '<img src="{item_proto.images.on}">',
                    '</div>',
                    '<div class="pet-control-state">',
                    '<div class="component">',
                    '<span role="xtype">petstate</span>',
                    '<span role="pet_id">{entry}</span>',
                    //'<span role="clientConfig:object">' + Ext.encode(me.clientConfig) + '</span>',
                    '</div>',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    '<tpl if="this.hasPriceStuff(values)">',
                    '<div class="pet-feed-stuff-image">',
                    '{[ExGods.stuff.StuffManager.image(values.price_stuff)]}',
                    '</div>',
                    '<div class="pet-feed-stuff-title">{[ExGods.stuff.StuffManager.title(values.price_stuff)]}</div>',
                    '<div class="pet-feed-stuff-count">{[this.printStuffCount(values.count_price_stuff)]}</div>',
                    '<div class="paper-separator"></div>',
                    '</tpl>',
                    {
                        hasPriceStuff: function(values) {
                            return has_price_stuff;
                        },
                        printStuffCount: function(count) {
                            return ExGods.app.applyTpl(me.clientConfig.count_price_stuff, {
                                count: count
                            });
                        }
                    }
                ],
                dockedItems: [
                    {
                        dock: 'bottom',
                        xtype: 'container',
                        layout: {
                            type: 'vbox',
                            align: 'center',
                            pack: 'center'
                        },
                        items: [
                            {
                                xtype: 'exg_slider',
                                width: 250,
                                value: to_feed,
                                maxValue: to_feed,
                                disabled: !(max - value),
                                title: me.clientConfig.slider_title,
                                upperScale: me.getUpperScale(to_feed),
                                listeners: {
                                    change: me.updateFeedBtn,
                                    scope: me
                                },
                                hidden: !me.pet.get('active')
                            },
                            {
                                xtype: 'textbutton',
                                itemId: 'feed_pet',
                                cls: 'no_border x-btn-txt-green',
                                text: me.printFeedText(to_feed),
                                disabled: !(max - value),
                                width: 220,
                                hidden: !me.pet.get('active')
                            },
                            {
                                xtype: 'textbutton',
                                itemId: 'resurrect_pet',
                                cls: 'no_border',
                                text: ExGods.app.applyTpl(me.clientConfig.resurrect_pet_btn, {
                                    cost: ExGods.util.Stuff.printStuff(me.pet.get('price_live'))
                                }),
                                width: 240,
                                margin: '0 0 24 0',
                                hidden: !!me.pet.get('active')
                            }
                        ]
                    }
                ]
            }
        ];
        me.buttons = {
            margin: '-5 0 15 0',
            defaults: {
                xtype: 'textbutton',
                minWidth: 100
            },
            items: [
                {
                    cls: 'x-btn-txt-red',
                    text: me.clientConfig.pet_release_in_control_btn,
                    itemId: 'pet_release_btn'
                },
                {
                    text: me.clientConfig.pet_off_btn,
                    itemId: 'pet_off_btn',
                    hidden: me.can_put_on
                },
                {
                    text: me.clientConfig.fitText,
                    cls: 'x-btn-txt-green',
                    itemId: 'pet_on_btn',
                    hidden: !me.can_put_on
                }
            ]
        };
        me.callParent();
        me.view = me.items.getAt(0);
        me.view.on({
            render: function() {
                ExGods.util.Helper.renderComponents(me.view.el, me.view);
            },
            destroy: function() {
                ExGods.util.Helper.destroyComponents(me.view.el);
            }
        });
    },
    getUpperScale: function(value) {
        return value / this.clientConfig.scale_count;
    },
    update: function(data) {
        var me = this;
        me.callParent(arguments);
        ExGods.util.Helper.renderComponents(me.view.el, me.view);
        me.updateFeedBtn();
        me.updateResurrectBtn();
    },
    updateFeedBtn: function() {
        var me = this,
            value = me.down('exg_slider').getValue();
        me.down('#feed_pet').setText(me.printFeedText(value));
    },
    updateResurrectBtn: function() {
        var me = this;
        me.down('#resurrect_pet').setText(ExGods.app.applyTpl(me.clientConfig.resurrect_pet_btn, {
            cost: ExGods.util.Stuff.printStuff(me.pet.get('price_live'))
        }));
    },
    printFeedText: function(count) {
        var me = this,
            cost = Ext.clone(me.pet.get('price')),
            count_price_stuff = me.pet.get('count_price_stuff') || 0;
        count = count || 1;
        var cost_count = Math.max(count - count_price_stuff, 0);
        cost.value = cost.value * cost_count;
        if (cost_count) {
            return ExGods.app.applyTpl(me.clientConfig.feed_pet_btn, {
                days: count + ' ' + Ext.util.Format.plural(count, ExGods.getMsgByKey('date_format_days_text').split(',')),
                cost: ExGods.printMoney(cost)
            });
        } else {
            return ExGods.app.applyTpl(me.clientConfig.feed_pet_btn_free, {
                days: count + ' ' + Ext.util.Format.plural(count, ExGods.getMsgByKey('date_format_days_text').split(','))
            });
        }
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        var pet_data = me.pet.data;
        for (var it in pet_data.item_proto.images) {
            arr_images.push(pet_data.item_proto.images[it]);
        }
        for (var i = 0; i < me.pet.data.price_stuff.length; i++) {
            stuff_arr.push(me.pet.data.price_stuff[i]);
        }
        for (var i = 0; i < me.pet.data.price_garanted.length; i++) {
            stuff_arr.push(me.pet.data.price_garanted[i]);
        }
        for (var i = 0; i < me.pet.data.price_live.length; i++) {
            stuff_arr.push(me.pet.data.price_live[i]);
        }
        return {
            images: [
                me.pet.data.image
            ].concat(arr_images)
        };
    }
});

/**
 * Модель питомца
 */
Ext.define('ExGods.model.Pet', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'chance_domestication',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'group',
            type: 'string'
        },
        {
            name: 'image',
            type: 'string',
            convert: function(v, r) {
                return IMAGE_URL + v;
            }
        },
        {
            name: 'item_proto',
            type: 'auto',
            convert: function(v, r) {
                var proto_data = ExGods.app.getItemPrototypesStore().data.getByKey(v).data,
                    stats;
                setTimeout(function() {
                    r.data.title = proto_data.title;
                    r.data.actions = proto_data.action_full;
                    for (var key in proto_data.data.stats) {
                        if (proto_data.data.stats[key]) {
                            if (!stats) {
                                stats = {};
                            }
                            stats[key] = proto_data.data.stats[key];
                        }
                    }
                    r.data.stats = stats;
                }, 0);
                return proto_data;
            }
        },
        {
            name: 'order',
            type: 'int'
        },
        {
            name: 'g_order',
            type: 'int'
        },
        {
            //цена кормления за 1 единицу
            name: 'price',
            type: 'auto'
        },
        {
            //stuff
            name: 'price_garanted',
            type: 'auto'
        },
        {
            //стоимость оживления
            name: 'price_live',
            type: 'auto'
        },
        {
            //стоимость кормления, если не валютой
            name: 'price_stuff',
            type: 'auto'
        },
        {
            name: 'productivity',
            type: 'int'
        },
        {
            name: 'steepness',
            type: 'int'
        },
        {
            name: 'time_tame',
            type: 'int'
        },
        {
            name: 'battle_actions',
            type: 'auto',
            convert: function(v, r) {
                var battle_actions = [];
                if (v.battle_instants && v.battle_instants.length) {
                    Ext.Array.each(v.battle_instants, function(item) {
                        var id = item.name,
                            info = ExGods.ref('battle_prep|' + id);
                        battle_actions.push({
                            id: id,
                            type: 'battle_prep',
                            title: info.label,
                            img: IMAGE_URL + info.desc.images['active'],
                            desc: info.desc.desc
                        });
                    });
                }
                if (v.battle_turns && v.battle_turns.length) {
                    Ext.Array.each(v.battle_turns, function(item) {
                        var id = item.name,
                            info = ExGods.ref('battle_turn|' + id);
                        battle_actions.push({
                            id: id,
                            type: 'battle_turn',
                            title: info.label,
                            img: IMAGE_URL + info.desc.images['active'],
                            desc: info.desc.desc
                        });
                    });
                }
                if (v.battle_actions && v.battle_actions.length) {
                    Ext.Array.each(v.battle_actions, function(item) {
                        var id = item.id,
                            info = ExGods.ref('battle_actions|' + id);
                        battle_actions.push({
                            id: id,
                            type: 'battle_actions',
                            title: info.label,
                            img: IMAGE_URL + info.desc.img,
                            desc: info.desc.description
                        });
                    });
                }
                // сортирую действия по типу: "основное, предварительное, расходка"
                battle_actions = Ext.Array.sort(battle_actions, function(a, b) {
                    if (a.type == b.type) {
                        return 0;
                    } else if (a.type == 'battle_turn') {
                        return -1;
                    } else if (a.type == 'battle_actions') {
                        return 1;
                    } else if (b.type == 'battle_turn') {
                        return 1;
                    } else {
                        return -1;
                    }
                });
                return battle_actions;
            }
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'has',
            type: 'int'
        },
        {
            name: 'active',
            type: 'int'
        },
        {
            //предмет пета в слотах юзера, приходит в сервисе
            name: 'item',
            type: 'auto'
        },
        {
            //количество имущества для кормления, приходит в сервисе
            name: 'count_price_stuff',
            type: 'int'
        },
        {
            //заполняются из предмета
            name: 'actions',
            type: 'auto',
            convert: function(v, r) {
                //TEST
                //return ExGods.app.getUser().slots().data.getByKey(3102).get('items').findRecord('proto_id',68).get('features');
                return v || [];
            }
        },
        {
            //заполняются из предмета
            name: 'stats',
            type: 'auto'
        }
    ],
    canFeed: function() {
        return this.data.item && this.data.item.param.dur != 0 && this.data.item.param.dur != this.data.item_proto.param.dur;
    }
});

/**
 * Хранилище питомцев
 */
Ext.define('ExGods.store.Pets', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Pet',
    proxy: 'memory',
    sorters: [
        {
            property: 'active',
            direction: 'DESC'
        },
        {
            property: 'has',
            direction: 'DESC'
        },
        {
            property: 'order',
            direction: 'DESC'
        }
    ],
    /**
     * привожу всех петов к состоянию, когда их у юзера нет
     */
    updateFromService: function(data, silent) {
        var me = this,
            need_reload_protos = false;
        me.each(function(rec) {
            rec.set({
                active: 0,
                has: 0,
                item: null
            });
        });
        Ext.Array.each(data.active_pets, function(pet) {
            var rec = me.data.getByKey(pet.proto.entry);
            //start TEST
            //pet.item.param.dur = 5;
            //end TEST
            if (rec) {
                rec.set(Ext.apply({
                    active: 1,
                    has: 1,
                    item: pet.item
                }, pet.current));
            } else  {
                need_reload_protos = true;
            }
            
        });
        Ext.Array.each(data.passive_pets, function(pet) {
            var rec = me.data.getByKey(pet.proto.entry);
            if (rec) {
                rec.set(Ext.apply({
                    active: 0,
                    has: 1,
                    item: pet.item
                }, pet.current));
            } else  {
                need_reload_protos = true;
            }
            
        });
        me.sort();
        if (need_reload_protos && !silent) {
            me.fireEvent('request_protos');
        }
    },
    /**
     * вернет есть ли вообще петы у юзера
     */
    isAnyPet: function() {
        var has = false;
        this.each(function(rec) {
            if (rec.get('has')) {
                has = true;
            }
        });
        return has;
    },
    /**
     * вернет все ли петы покормлены
     */
    isAllFeed: function() {
        var feed = true;
        this.each(function(rec) {
            if (rec.canFeed()) {
                feed = false;
            }
        });
        return feed;
    }
});

/**
 * Компонент состояния питомца
 */
Ext.define('ExGods.view.pet.State', {
    extend: Ext.Component,
    alias: 'widget.petstate',
    cls: 'pet-state-cmp',
    /**
     * @required
     * @cfg pet_id - entry питомца
     */
    width: 200,
    initComponent: function() {
        var me = this;
        me.store = ExGods.app.getPetsController().store;
        me.data = me.store.data.getByKey(me.pet_id).data;
        me.clientConfig = ExGods.app.getPetsController().clientConfig;
        me.tpl = [
            '<div class="pet-state">{[this.getState(values)]}</div>',
            '<div class="pet-state-food exg-share-bg-dark" style="width:' + me.width + 'px">',
            '<div class="pet-state-food-label">' + me.clientConfig.satiety + '</div>',
            '<div class="pet-state-food-value">&nbsp;{[this.getPercent(values)]}%</div>',
            '<div class="pet-state-food-progress">',
            '<div class="pet-state-food-progress-value" style="width:{[this.getProgress(values)]}px"></div>',
            '</div>',
            '{[this.getLeftTime(values)]}',
            '</div>',
            {
                getState: function(values) {
                    return values.active ? me.clientConfig.pet_active : me.clientConfig.pet_inactive;
                },
                getPercent: function(values) {
                    return Math.floor(values.item.param.dur * 100 / values.item_proto.param.dur);
                },
                getProgress: function(values) {
                    //84 - ширина прогресс бара
                    return Math.floor(values.item.param.dur * 84 / values.item_proto.param.dur);
                },
                getLeftTime: function(values) {
                    if (!values.active || !values.item.checked)  {
                        return '';
                    }
                    
                    var check_date = ExGods.util.Date.normalizeServerDateTime(values.item.checked);
                    date = check_date.getTime() + values.item.param.dur * Number(me.clientConfig.service.data.period_to_eat) * 60 * 60 * 1000;
                    return [
                        '<div class="pet-state-left">',
                        ExGods.app.applyTpl(me.clientConfig.timer, {
                            time: ExGods.util.Timers.printTimer('rest', 'pet-timer' + values.entry, new Date(date), {
                                needNormalized: false,
                                format: 'twonums'
                            })
                        }),
                        '</div>'
                    ].join('');
                }
            }
        ];
        me.callParent();
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: []
        };
    }
});

/**
 * Окно контроля питомца
 */
Ext.define('ExGods.view.pet.Grid', {
    extend: ExGods.view.grid.SkinGrid,
    alias: 'widget.petsgrid',
    cls: 'pets-grid',
    rowsCount: 3,
    columnsCount: 5,
    cellHeight: 124,
    //height: 365,
    //количество уже имеющихся пустых ячеек
    empty_cells: 0,
    //DOM Objects, список dom заголовков по строкам. Если нет заголовка - undefined
    rowHeaders: [],
    isEnabled: function(values) {
        return values.has;
    },
    getImage: function(values) {
        return values.has ? values.item_proto.images.on : values.item_proto.images.off;
    },
    initComponent: function() {
        var me = this,
            petsStore = me.store;
        me.store = Ext.create('ExGods.store.Pets', {
            sorters: [
                {
                    property: 'g_order',
                    direction: 'DESC'
                },
                {
                    property: 'order',
                    direction: 'DESC'
                }
            ]
        });
        me.store.loadRecords(petsStore.data.items);
        me.mon(petsStore, 'datachanged', function() {
            me.store.loadRecords(petsStore.data.items);
        });
        me.callParent();
    },
    /**
     * override
     * считаю количество страниц с учетом пустых ячеек
     */
    getTotalPagesCount: function() {
        var me = this,
            rec_group, index, next_rec, i;
        me.empty_cells = 0;
        me.store.each(function(rec) {
            rec_group = rec.get('group');
            index = me.store.indexOf(rec);
            next_rec = me.store.getAt(index + 1);
            i = me.columnsCount - (index + me.empty_cells) % me.columnsCount - 1;
            if (!next_rec || next_rec.get('group') != rec_group) {
                me.empty_cells += i;
            }
        });
        return Math.ceil((me.store.getCount() + me.empty_cells) / (me.rowsCount * me.columnsCount)) || 1;
    },
    /**
     * override
     * заполняю пробелы пустыми ячейками с учетом групп
     */
    renderEmptySlots: function() {
        var me = this,
            rec_group, index, node, i, next_rec, header,
            headersHtml = '',
            ul = me.el.down('.exg-grid-items'),
            itemsPerPage = me.rowsCount * me.columnsCount,
            emptyNode = [
                '<li class="exg-grid-item" style="width:' + me.cellWidth + 'px;height:' + me.cellHeight + 'px">',
                '<div class="exg-grid-skin-item empty">',
                '<div class="exg-grid-skin-frm"></div>',
                '<img class="image" src="' + IMAGE_URL + 'locations/monster_absent.jpg">',
                '<div class="x-clear"></div>',
                '</div>',
                '</li>'
            ].join('');
        me.empty_cells = 0;
        me.rowHeaders = [];
        me.store.each(function(rec) {
            rec_group = rec.get('group');
            index = me.store.indexOf(rec);
            next_rec = me.store.getAt(index + 1);
            node = me.itemsView.getNodeByRecord(rec);
            i = me.columnsCount - (index + me.empty_cells) % me.columnsCount - 1;
            if ((index + me.empty_cells) % (3 * me.columnsCount) == 0) {
                me.rowHeaders[(index + me.empty_cells) / me.columnsCount] = rec_group;
            }
            if (!next_rec || next_rec.get('group') != rec_group) {
                me.empty_cells += i;
                if (next_rec) {
                    me.rowHeaders[Math.ceil((index + me.empty_cells) / me.columnsCount)] = next_rec.get('group');
                }
                while (i--) {
                    Ext.get(node).insertSibling(emptyNode, 'after');
                }
            }
        });
        ul = me.el.down('.exg-grid-items');
        i = itemsPerPage - (me.store.getCount() + me.empty_cells) % itemsPerPage;
        while (i--) {
            ul.insertHtml('beforeEnd', emptyNode);
        }
        //выставляю заголовки
        i = me.rowHeaders.length;
        me.headersEl = document.createElement('div');
        me.headersEl.className = 'all-pets-headers';
        me.headersEl.style.marginTop = ul.getStyle('margin-top');
        while (i--) {
            if (me.rowHeaders[i]) {
                header = document.createElement('div');
                header.className = 'all-pets-header';
                header.style.top = me.cellHeight * i + 'px';
                header.innerHTML = me.rowHeaders[i] + '<div>' + me.rowHeaders[i] + '</div>';
                if (i >= 3) {
                    header.style.display = 'none';
                }
                me.rowHeaders[i] = header;
                me.headersEl.appendChild(header);
            }
        }
        me.el.appendChild(me.headersEl);
        //проставляю стикеры "редкий". Делаю здесь, т.к. в группе 
        me.store.each(function(rec) {
            node = me.itemsView.getNodeByRecord(rec);
            if (rec.get('steepness') > 1) {
                var el = document.createElement('div'),
                    images = ExGods.ref('images|pets_images').image,
                    image = rec.get('has') ? images.trophies_rare : images.trophies_rare_bw;
                el.className = 'sticker';
                el.style.top = node.offsetTop + 'px';
                el.style.left = node.offsetLeft + 'px';
                el.style.backgroundImage = 'url(' + image + ')';
                me.headersEl.appendChild(el);
            }
        });
    },
    initPager: function(ct) {
        var me = this;
        me.callParent(arguments);
        ct.openPage = function(pageIndex) {
            var ul = me.getEl().down('.exg-grid-items'),
                margin = (pageIndex - 1) * me.rowsCount * me.cellHeight,
                startI = (pageIndex - 1) * 3,
                endI = pageIndex * 3;
            ul.setStyle('margin-top', '-' + margin + 'px');
            if (me.headersEl) {
                me.headersEl.style.marginTop = -margin + 'px';
                Ext.Array.each(me.rowHeaders, function(header, i) {
                    if (!header)  {
                        return;
                    }
                    
                    if (i >= startI && i < endI) {
                        header.style.display = 'block';
                    } else {
                        header.style.display = 'none';
                    }
                });
                var i = me.headersEl.childNodes.length,
                    sticker;
                while (i--) {
                    if (me.headersEl.childNodes[i].className.indexOf('sticker') != -1) {
                        sticker = me.headersEl.childNodes[i];
                        if (parseInt(sticker.style.top) >= Math.abs(ul.dom.offsetTop) && parseInt(sticker.style.top) < Math.abs(ul.dom.offsetTop) + ul.dom.parentNode.offsetHeight) {
                            sticker.style.display = 'block';
                        } else {
                            sticker.style.display = 'none';
                        }
                    }
                }
            }
        };
    },
    /**
     * Ресурсы вью предзагрузка
     */
    getResources: function() {
        var me = this,
            images,
            arr_images = [];
        me.store.each(function(rec) {
            if (rec.get('steepness') > 1) {
                var el = document.createElement('div'),
                    images = ExGods.ref('images|pets_images').image,
                    image = rec.get('has') ? images.trophies_rare : images.trophies_rare_bw;
                arr_images.push(image);
            }
        });
        images = ExGods.ref('images|pets_images').image;
        for (var it in images) {
            arr_images.push(images[it]);
        }
        for (var i = 0; i < me.store.data.items.length; i++) {
            var imgs = me.store.data.items[i].data.item_proto.images;
            for (var it in imgs) {
                arr_images.push(imgs[it]);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * Контроллер петов
 */
Ext.define('ExGods.controller.Pets', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /**
         * @method getBackInTown
         * Возвращает кнопку "В город"
         */
            ref: 'backInTown',
            selector: '#back_in_town'
        },
        {
            /**
         * @method getPetInfo
         * Возвращает вью информации о питомце
         * @return {ExGods.view.pet.Info}
         */
            ref: 'petInfo',
            selector: '#pet_info'
        },
        {
            /**
         * @method getPetImage
         * Возвращает компонент с картинкой пета
         * @return {Ext.Component}
         */
            ref: 'petImage',
            selector: '#pet_image'
        },
        {
            /**
         * @method getAllPets
         * Возвращает окно с гридом всех питомцев
         * @return {ExGods.view.pet.AllPets}
         */
            ref: 'allPets',
            selector: 'allpets'
        },
        {
            /**
         * @method getTape
         * Возвращает ленту питомцев
         * @return {ExGods.pet.Tape}
         */
            ref: 'tape',
            selector: 'pettape'
        },
        {
            /**
         * @method getPetControlBtn
         * Возвращает кнопку управления петом
         * @return {ExGods.view.TextButton}
         */
            ref: 'petControlBtn',
            selector: '#pet_control_btn'
        }
    ],
    views: [
        'pet.Tape',
        'pet.Info',
        'pet.AllPets',
        'pet.State',
        'pet.Control',
        'grid.SkinGrid',
        'pet.Grid'
    ],
    models: [
        'Pet'
    ],
    stores: [
        'Pets'
    ],
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'Pets:'
    },
    init: function(app) {
        var me = this;
        me.store = Ext.create('ExGods.store.Pets');
        me.store.on('request_protos', me.updateProtos, me);
        me.control({
            'pettape': {
                select: me.onPetSelect
            },
            'allpets dataview': {
                itemclick: me.onPetItemClick
            },
            '#pet_control_btn': {
                click: me.onControlBtnClick
            },
            '#pet_release_btn': {
                click: me.onReleaseBtnClick
            },
            '#pet_off_btn': {
                click: me.onOffBtnClick
            },
            '#pet_on_btn': {
                click: me.onOnBtnClick
            },
            '#feed_all_pets': {
                click: me.onFeedAllPetsBtnClick
            },
            '#feed_pet': {
                click: me.onFeedPetClick
            },
            '#resurrect_pet': {
                click: me.onResurrectPetClick
            },
            '#release_all_pets': {
                click: me.onReleaseAllPetsBtnClick
            }
        });
        ExGods.Components.addComponentInitializer('pets', me.initPetsComponent, me);
    },
    onServiceUpdate: function() {
        var me = this,
            allPets = me.getAllPets();
        me.store.updateFromService(me.service.data);
        if (allPets) {
            allPets.down('#feed_all_pets').setDisabled(!me.store.isAnyPet() || me.store.isAllFeed());
            allPets.down('#release_all_pets').setDisabled(!me.store.isAnyPet());
        }
    },
    onPetSelect: Ext.Function.createBuffered(function(tape, dataview, record, index) {
        var me = this;
        me.setPet(record);
    }, 400),
    onPetItemClick: Ext.Function.createBuffered(function(grid, record, dom) {
        var me = this;
        me.getTape().setActiveEl(record, {
            silent: true
        });
        me.setPet(record);
    }, 400),
    onControlBtnClick: function(btn) {
        var me = this,
            price_stuff = Ext.Array.clean([
                me.currentPet.get('price_stuff')
            ]);
        ExGods.helpme.loadProtosFromStuff(price_stuff, function() {
            var wnd = Ext.widget('petcontrol', {
                    pet: me.currentPet,
                    autoShow: false,
                    can_put_on: me.canPutOn(me.currentPet),
                    clientConfig: me.clientConfig
                });
            ExGods.Resources.load(wnd, function() {
                wnd.show();
            });
        });
    },
    onReleaseBtnClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol');
        Ext.widget('confirmdialog', {
            message: me.clientConfig.confirm_pet_remove,
            handler: function() {
                me.service.command('pet_remove', {
                    slot: me.currentPet.get('item').slot_id,
                    item: me.currentPet.get('item').item_id
                }, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update(null, function() {
                        if (wnd)  {
                            wnd.close();
                        }
                        
                    });
                });
            }
        });
    },
    onFeedAllPetsBtnClick: function(btn) {
        var me = this;
        Ext.widget('confirmdialog', {
            message: ExGods.app.applyTpl(me.clientConfig.confirm_pets_repair_all, {
                cost: me.calcTotalFeedPrice()
            }),
            handler: function() {
                me.service.command('pets_repair_all', {}, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update();
                });
            }
        });
    },
    onReleaseAllPetsBtnClick: function(btn) {
        var me = this;
        Ext.widget('confirmdialog', {
            message: me.clientConfig.confirm_pet_remove_all,
            handler: function() {
                me.service.command('pet_remove_all', {}, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update();
                });
            }
        });
    },
    onFeedPetClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol'),
            value = wnd.down('exg_slider').getValue();
        Ext.widget('confirmdialog', {
            message: me.clientConfig.confirm_pets_repair,
            handler: function() {
                me.service.command('pets_repair', {
                    slot: me.currentPet.get('item').slot_id,
                    item: me.currentPet.get('item').item_id,
                    value: value
                }, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update(null, function() {
                        wnd.close();
                    });
                });
            }
        });
    },
    onResurrectPetClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol');
        Ext.widget('confirmdialog', {
            message: me.clientConfig.confirm_pets_live,
            handler: function() {
                me.service.command('pets_live', {
                    slot: me.currentPet.get('item').slot_id,
                    item: me.currentPet.get('item').item_id
                }, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update(null, function() {
                        wnd.close();
                    });
                });
            }
        });
    },
    onOffBtnClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol');
        me.service.command('pets_off', {
            slot: me.currentPet.get('item').slot_id
        }, function(resp) {
            if (!resp.success)  {
                return;
            }
            
            me.service.update(null, function() {
                if (wnd)  {
                    wnd.close();
                }
                
            });
        });
    },
    onOnBtnClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol');
        me.putOnPet(function() {
            if (wnd)  {
                wnd.close();
            }
            
        });
    },
    calcTotalFeedPrice: function() {
        var me = this,
            prices = {},
            money = [];
        me.store.each(function(rec) {
            if (!rec.get('active'))  {
                return;
            }
            
            var price = rec.get('price'),
                value = rec.get('item').param.dur,
                max = rec.get('item_proto').param.dur,
                to_feed = max - value;
            if (to_feed) {
                if (!prices[price.name]) {
                    prices[price.name] = 0;
                }
                prices[price.name] += price.value * to_feed;
            }
        });
        for (var name in prices) {
            money.push({
                name: name,
                value: prices[name]
            });
        }
        return ExGods.printMoney(money);
    },
    /**
     * обновляю информацию о питомце во всех вьюшках
     */
    setPet: function(record) {
        var me = this,
            cur_pet = me.getCurrent(),
            _setPet = function(stats) {
                var info = me.getPetInfo(),
                    allPets = me.getAllPets(),
                    imgCmp = me.getPetImage(),
                    controlBtn = me.getPetControlBtn(),
                    fitBtn = me.getBackInTown(),
                    tape = me.getTape();
                ExGods.app.block();
                ExGods.Resources.load({
                    getResources: function() {
                        return {
                            images: [
                                me.clientConfig.fitText,
                                me.clientConfig.closeText,
                                record.get('image')
                            ]
                        };
                    }
                }, function() {
                    ExGods.app.unblock();
                    if (!info) {
                        return;
                    }
                    me.currentPet = record;
                    info.pet = record;
                    info.update(Ext.apply({
                        fit_stats: stats
                    }, record.data));
                    if (allPets) {
                        allPets.setPet(record, stats);
                    }
                    tape.setActiveEl(record, {
                        silent: true
                    });
                    if (me.canPutOn(record)) {
                        fitBtn.setText(me.clientConfig.fitText);
                        fitBtn.el.set({
                            'data-qh_oid': 1
                        });
                    } else {
                        fitBtn.setText(me.clientConfig.closeText);
                        fitBtn.el.set({
                            'data-qh_oid': 0
                        });
                    }
                    controlBtn[record.get('has') ? 'show' : 'hide']();
                    var speed = parseInt(ExGods.ref('constants|mask_house_change_speed').value),
                        wait = parseInt(ExGods.ref('constants|mask_house_change_wait_time').value);
                    if (!me.prevImagePets) {
                        me.prevImagePets = '';
                    }
                    if (me.prevImagePets != record.get('image')) {
                        me.prevImagePets = record.get('image');
                        imgCmp.el.animate({
                            duration: speed,
                            to: {
                                opacity: 0
                            },
                            listeners: {
                                afteranimate: function() {
                                    imgCmp.el.setStyle('background-image', 'url(' + record.get('image') + ')');
                                }
                            }
                        }).animate({
                            delay: wait,
                            duration: speed,
                            to: {
                                opacity: 1
                            }
                        });
                    }
                });
            };
        // resources load
        if (record == cur_pet) {
            _setPet();
        } else {
            me.service.command('fit_pet', {
                id: record.get('entry')
            }, function(resp) {
                if (!resp.success)  {
                    return;
                }
                
                try {
                    _setPet(resp.fit.stats);
                } catch (e) {
                    me.log('warn', 'Компонент закрыт');
                }
            });
        }
    },
    canPutOn: function(record) {
        var me = this,
            slots = ExGods.app.getUser().slots(),
            active_pet_slot = slots.findRecord('type', 25);
        //25 слот - слот активного питомца
        if (!active_pet_slot) {
            return;
        }
        var active_pets_store = active_pet_slot.get('items');
        return record.get('active') && !active_pets_store.findRecord('item_id', record.get('item').item_id);
    },
    getCurrent: function() {
        var me = this,
            slots = ExGods.app.getUser().slots(),
            active_pet_slot = slots.findRecord('type', 25);
        //25 слот - слот активного питомца
        if (!active_pet_slot) {
            return false;
        }
        var active_pets_store = active_pet_slot.get('items'),
            fit_pet;
        me.store.each(function(rec) {
            var item = rec.get('item');
            if (item && active_pets_store.findRecord('item_id', item.item_id)) {
                fit_pet = rec;
            }
        });
        return fit_pet;
    },
    /**
     * Xclicked - флаг, что кликнули на крестик
     */
    checkFitOnClose: function(Xclicked) {
        var me = this,
            prevent_close = false,
            closeWindow = function() {
                if (prevent_close)  {
                    return;
                }
                
                var fittedPet = me.getCurrent() || me.currentPet,
                    callback = function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            Ext.getCmp('PETS').close();
                        }, {
                            img: me.clientConfig.backImg
                        });
                    };
                if (fittedPet) {
                    me.getTape().setActiveEl(fittedPet, {
                        animate: true,
                        silent: true,
                        forced: true,
                        callback: callback
                    });
                } else  {
                    callback();
                }
                
            };
        if (me.currentPet && me.canPutOn(me.currentPet)) {
            if (Xclicked) {
                Ext.widget('confirmdialog', {
                    message: me.clientConfig.check_on_fit_message_no_close,
                    handler: function(btn) {
                        prevent_close = true;
                        me.putOnPet(function() {
                            prevent_close = false;
                            closeWindow();
                        });
                    },
                    listeners: {
                        close: closeWindow
                    }
                });
            } else {
                Ext.widget('confirmdialog', {
                    message: me.clientConfig.check_on_fit_message,
                    handler: function(btn) {
                        me.putOnPet();
                    }
                });
            }
        } else  {
            closeWindow();
        }
        
        return false;
    },
    putOnPet: function(cb) {
        var me = this;
        if (!me.currentPet || !me.currentPet.get('item')) {
            /***/
            me.log('warn', 'Нет текущего пета! ');
            return;
        }
        me.service.command('pets_on', {
            slot: me.currentPet.get('item').slot_id,
            item: me.currentPet.get('item').item_id
        }, function(resp) {
            if (!resp.success)  {
                return;
            }
            
            me.service.update(null, function() {
                if (cb)  {
                    cb();
                }
                
            });
        });
    },
    updateProtos: function() {
        var me = this;
        ExGods.Services.get('pets').command('pets_proto', {}, function(resp) {
            if (resp.list) {
                var ref = ExGods.references.get('pets');
                ref.clear();
                Ext.Array.each(resp.list, function(item) {
                    ref.add(item.entry, item);
                });
                me.store.loadRawData(resp.list);
                if (me.service) {
                    me.store.updateFromService(me.service.data, true);
                }
                if (me.cmp && me.cmp.isVisible()) {
                    me.setPet(me.store.first());
                }
            }
        });
    },
    initPetsComponent: function(config) {
        var me = this,
            pets = ExGods.references.get('pets').getValues(),
            wnd = Ext.getCmp('PETS'),
            closeCallback = function() {
                ExGods.loaderCt.loadAndRemove(function() {
                    wnd.close();
                }, {
                    img: me.clientConfig.backImg
                });
                return false;
            };
        me.service = config.service;
        me.service.onUpdate = function(data) {
            me.store.updateFromService(data);
            me.setPet(me.currentPet);
        };
        me.clientConfig = config;
        me.cmp = Ext.create('ExGods.view.Room', {
            cls: 'pets',
            backgroundImage: config.backImg,
            closeText: config.closeText,
            closeColor: config.closeColor,
            closeCallback: Ext.Function.bind(me.checkFitOnClose, me, []),
            rightPanelX: 715,
            margin: '0 10 10 0',
            closable: true,
            items: [
                {
                    xtype: 'component',
                    margin: '0 0 0 722',
                    html: '<div class="mask_header" style="background: url(' + IMAGE_URL + config.icon + ');"></div>'
                }
            ],
            listeners: {
                beforeclose: function() {
                    me.service.onUpdate = Ext.emptyFn;
                    return me.checkFitOnClose(true);
                }
            }
        });
        if (wnd) {
            wnd.close();
        }
        wnd = Ext.widget('window1', {
            id: 'PETS',
            autoShow: false,
            items: [
                me.cmp
            ],
            getResources: function() {
                var me = this;
                return {
                    images: [
                        config.backImg
                    ]
                };
            }
        });
        ExGods.app.getController('Location').maskLocation(function() {
            // подгрузка ресурсов
            ExGods.helpme.loadProtos(pets, 'item_proto', function() {
                me.store.loadRawData(Ext.clone(pets));
                me.store.updateFromService(me.service.data);
                me.currentPet = me.getCurrent() || me.store.first();
                if (me.currentPet) {
                    me.cmp.add({
                        xtype: 'petinfo',
                        id: 'pet_info',
                        clientConfig: me.clientConfig,
                        pet: me.currentPet,
                        x: 10,
                        y: 6
                    }, {
                        xtype: 'component',
                        id: 'pet_image',
                        style: {
                            backgroundImage: 'url(' + me.currentPet.get('image') + ')'
                        },
                        x: 205,
                        y: 0,
                        width: 440,
                        height: 410,
                        getResources: function() {
                            return {
                                images: [
                                    me.currentPet.get('image')
                                ]
                            };
                        }
                    }, {
                        xtype: 'pettape',
                        itemId: 'petTape',
                        x: 615,
                        y: 40,
                        width: 225,
                        height: 325,
                        store: me.store,
                        startRecord: me.currentPet
                    }, {
                        height: 30,
                        x: 55,
                        y: 375,
                        width: 120,
                        xtype: 'textbutton',
                        text: me.clientConfig.all_pets_btn,
                        handler: function(btn) {
                            var wnd = Ext.widget('window2', {
                                    autoShow: false,
                                    items: [
                                        {
                                            xtype: 'allpets',
                                            clientConfig: me.clientConfig,
                                            store: me.store,
                                            pet: me.currentPet
                                        }
                                    ]
                                });
                            ExGods.Resources.load(wnd, function() {
                                wnd.show();
                            });
                        }
                    }, {
                        style: {
                            right: '113px',
                            top: '373px'
                        },
                        //cls: 'x-btn-txt-green',
                        xtype: 'textbutton',
                        text: me.clientConfig.pet_control_btn,
                        itemId: 'pet_control_btn',
                        hidden: !me.currentPet.get('has')
                    });
                }
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    if (me.currentPet) {
                        me.setPet(me.currentPet);
                    }
                    me.getBackInTown().el.set({
                        'data-qh_otype': 'room_pet_button_puton'
                    });
                    //дожидаюсь пока отрисуются компоненты
                    setTimeout(function() {
                        ExGods.app.getController('Location').unmaskLocation();
                    }, 100);
                });
            });
        }, {
            img: me.clientConfig.backImg
        });
        return wnd;
    }
});

/**
 * Котроллер по управлению указаниями
 *
 * Указание - это директива сервера, запустить тот или иной сервис.
 * Такая директива вшита в текстовое сообщение, источником которого может быть чат, ответ сервера и т.д.
 *
 * Задача контроллера источника вызвать метод {@link ExGods.controller.Direction#processText}, который призван отыскать директиву
 * в текстовом сообщении источника.
 *
 * @author Олег Михайлов
 *
 */
Ext.define('ExGods.controller.Direction', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Direction:'
    },
    disabled: true,
    init: function() {
        var me = this;
        me.storage = Ext.util.LocalStorage.get('directions');
        me.storage.directionsItemId = 'directions';
        me.control({
            '#battle-result': {
                destroy: {
                    fn: me.showDirections,
                    delay: 100
                }
            }
        });
        var directions = me.storage.getItem(me.storage.directionsItemId) || [];
        Ext.Array.each(directions, function(d) {
            if (d.data.object_name) {
                me.listenComponent(d.data.object_name);
            }
        });
        ExGods.Components.addComponentInitializer('direction', me.initDirectionDialogComponent, me);
        // метод для теста указаний
        ExGods.testDirection = function(directionName) {
            me.processText('[# ' + directionName + ' #]');
        };
    },
    shown: {},
    onLaunch: function(app) {
        var me = this;
        me.showDirections();
    },
    /**
     * Заблокировать / cнять блокировку с показа указаний
     */
    setDisabled: function(disabled) {
        var me = this;
        if (me.disabled !== disabled) {
            me.disabled = disabled;
            if (!me.disabled) {
                me.showDirections();
            }
        }
    },
    canShowDirections: function() {
        var me = this;
        return !me.disabled;
    },
    isBattle: function() {
        var me = this;
        return me.user.isBattle() || me.app.getController('battle.BattleView').isRendered() || Ext.getCmp('battle-result');
    },
    /**
     * Показывает указания 
     */
    showDirections: function(cmpId) {
        var me = this,
            directions = me.storage.getItem(me.storage.directionsItemId) || [],
            _waitAndShow = function(cmp, d) {
                var times = 0,
                    interval;
                interval = setInterval(function() {
                    if (cmp && cmp.isVisible() && !ExGods.loaderCt.isVisible()) {
                        me.runDirection(d);
                        Ext.Array.remove(directions, d);
                        me.storage.setItem(me.storage.directionsItemId, directions);
                        clearInterval(interval);
                    } else {
                        if (++times > 10) {
                            clearInterval(interval);
                        }
                    }
                }, 250);
            };
        if (!me.canShowDirections()) {
            return;
        }
        Ext.Array.sort(directions, function(a, b) {
            return b.priority - a.priority;
        });
        /***/
        me.log('Показываю указания');
        var showen = [],
            lc = ExGods.loaderCt;
        Ext.Array.each(directions, function(d) {
            if (d.data.object_name && !d.data.not_show_with_open_component) {
                var cmp = Ext.getCmp(d.data.object_name);
                if (cmp) {
                    if (cmp.isVisible()) {
                        me.runDirection(d);
                        showen.push(d);
                    } else {
                        _waitAndShow(cmp, d);
                    }
                }
            } else if (me.isBattle() && d.data.show_in_battle != 1) {}
            //
            else if (lc.isVisible()) {
                lc.on('loader_removed', function() {
                    me.runDirection(d);
                }, me, {
                    single: true
                });
                showen.push(d);
            } else {
                me.runDirection(d);
                showen.push(d);
            }
        });
        directions = Ext.Array.difference(directions, showen);
        me.storage.setItem(me.storage.directionsItemId, directions);
    },
    /**
     * Выполняет директиву
     */
    runDirection: function(d) {
        var me = this;
        /***/
        me.log('Выполняю указание', d);
        var fn = function() {
                if (d.data.make == 'service') {
                    // выполняю клиентское действие из указания
                    ExGods.ClientActions.createAndInvoke({
                        actionId: d.data.make_data.id
                    }, null, function(err) {
                        /***/
                        me.log('error', err);
                    });
                } else if (d.data.make == 'component') {
                    if (d.data.make_data.object_name) {
                        // показываю компонент из указания
                        var cmp = ExGods.Components.factory(d.data.make_data.object_name);
                        if (cmp == 'wrong_setting') {
                            /***/
                            me.log('info', 'Пользователь отключил указания и подсказки', d);
                            return;
                        } else if (cmp && !cmp.error) {
                            if (cmp.config.auto_run && cmp.directionAutoRun) {
                                cmp.directionAutoRun();
                                cmp.destroy();
                            } else if (cmp.autoShow !== false && !cmp.rendered) {
                                if (typeof cmp.getResources == 'function') {
                                    ExGods.Resources.load(cmp, function() {
                                        cmp.show();
                                    });
                                } else {
                                    cmp.show();
                                }
                            }
                        } else {
                            /***/
                            me.log('error', cmp ? cmp.error : 'Компонент для указания не создан ', d);
                        }
                    }
                } else {
                    /***/
                    me.log('error', 'Пустое указание - не указан ни клиентский объект, ни сервис');
                }
                if (d.data.sound) {
                    var sound = ExGods.ref('sounds|' + d.data.sound);
                    if (sound) {
                        ExGods.app.getSoundController().play(sound.audio);
                    }
                }
                if (d.data.caption) {
                    me.blinkTitle(d.data.caption);
                }
            };
        if (d.data.ask_direction && d.data.ask_direction.length) {
            var requests = Ext.Array.map(d.data.ask_direction, function(cfg) {
                    return me.askDirection.bind(me, cfg.command, function() {
                        requests.shift();
                        if (requests[0]) {
                            requests[0]();
                        } else  {
                            fn();
                        }
                        
                    });
                });
            requests[0]();
        } else {
            fn();
        }
    },
    askDirection: function(cmd, callback) {
        var me = this;
        me.request({
            url: '/game.pl',
            params: {
                cmd: 'ask_direction',
                ask: cmd
            },
            success: function(result) {
                me.onAskDirectionSuccess(result);
                callback();
            },
            failure: callback
        });
    },
    onAskDirectionSuccess: function(result) {
        if (result.ask_direction.mainmenu) {
            Ext.getCmp('mainmenu').updateMenu(result.ask_direction.mainmenu);
        }
    },
    /**
     * Обрабатывает текст на момент наличия директивы.
     *
     * Директива в тексте должна выглядеть следующим образом:
     *
     *  "... [# <direction_name> #]...."
     *  
     * direction_name - имя директивы из соответствующего справочника
     *
     * или:
     *
     *  "... [# hint_<hint_id> #]...."
     *
     * hint_id - ID подсказки.
     *
     * @param {String} Text
     * @return {String} Обработанный текст (все директивы вырезаются)
     */
    processText: function(text) {
        var me = this,
            pattern = /\[#\s([\w\d-_]+)\s#\]/ig,
            directions = [],
            hints = [],
            matches, d;
        while ((matches = pattern.exec(text)) != null) {
            if (/^hint_/.test(matches[1])) {
                if (me.user.getSetting('disable_hints') != 1)  {
                    hints.push(matches[1].replace('hint_', ''));
                }
                
            } else {
                d = ExGods.references.get('user_directions').get(matches[1]);
                if (d) {
                    directions.push(d);
                }
            }
        }
        if (directions.length) {
            Ext.Array.each(directions, function(d) {
                me.addDirection(d);
            });
            me.showDirections();
        }
        if (hints.length) {
            var hintsController = me.app.getController('Hints');
            Ext.Array.each(hints, function(h) {
                hintsController.showHintById(h);
            });
        }
        return text.replace(pattern, '');
    },
    /**
     * @private
     */
    addDirection: function(d) {
        var me = this,
            saved = me.storage.getItem(me.storage.directionsItemId) || [],
            alreadyHas = false;
        if (d.data.not_show_with_open_component == 1 && d.data.object_name && Ext.getCmp(d.data.object_name) && Ext.getCmp(d.data.object_name).isVisible()) {
            return;
        }
        // не добавляю указание, если стоит галочка "не показывать когда открыт" и компонент открыт
        /***/
        me.log('Добавляю указание в хранилище', d);
        Ext.Array.each(saved, function(sd) {
            if (sd.entry == d.entry) {
                alreadyHas = true;
            }
        });
        if (!alreadyHas) {
            saved.push(d);
            me.storage.setItem(me.storage.directionsItemId, saved);
            if (d.data.object_name) {
                me.listenComponent(d.data.object_name);
            }
        }
    },
    listenComponent: function(cmpId) {
        var me = this,
            listener = {};
        me.listened = me.listened || [];
        if (Ext.Array.indexOf(me.listened, cmpId) == -1) {
            /****/
            me.log('Добавляю обработчик на показ компонента', cmpId);
            listener['#' + cmpId] = {
                show: {
                    fn: function() {
                        me.showDirections(cmpId);
                    },
                    single: false
                }
            };
            me.control(listener);
            me.listened.push(cmpId);
        }
    },
    /**
     * Метод вызывается автоматически при инициализации компонента
     */
    initDirectionDialogComponent: function(config, componentId) {
        var me = this,
            action,
            opts = {},
            view;
        //не показываю компонент если соответствующая настройка
        if (me.user.getSetting('disable_hints') == 1 && config.close_btn && config.close_btn != 0 && config.close_btn != 'Нет')  {
            return 'wrong_setting';
        }
        
        if (Ext.getCmp('LETTER_' + componentId)) {
            return false;
        }
        if (config.serviceId && config.serviceId.id) {
            if (config.extra_service_opts) {
                opts = Ext.decode(config.extra_service_opts);
            }
            action = ExGods.ClientActions.factory({
                actionId: config.serviceId.id,
                src: 'direction',
                options: opts
            });
        }
        config.action = action;
        config.btn = {
            handler: function() {
                // закрываю все окна
                if (config.closeAll) {
                    me.app.getController('Viewport').closeAllWindows();
                }
                // выполняю клиентское действие
                if (action) {
                    ExGods.ClientActions.doAction(action, function(res) {
                        if (res.error) {
                            /***/
                            me.log('error', res.error);
                        }
                    });
                }
                // удаляю контейнер указания
                this.up('direction').close();
            }
        };
        view = Ext.widget('direction', {
            id: 'LETTER_' + componentId,
            //добавляю буквы в начало ID, т.к. 5-й экст ругается на ID начинающиеся с цифры
            layer: 'directions-layer',
            autoShow: false,
            config: config
        });
        ExGods.Resources.load(view, function() {
            view.show();
        });
        return view;
    },
    blinkTitle: function(text) {
        var originalTitle = document.title,
            duration = ExGods.ref('constants|direction_title_blink_duration').value,
            blinkTime = ExGods.ref('constants|direction_title_blink_time').value,
            pauseTime = ExGods.ref('constants|direction_title_blink_time').value,
            spentTime = 0,
            started = new Date(),
            phase, now;
        document.title = text;
        phase = {
            type: 'blink',
            started: started,
            dur: blinkTime
        };
        var interval = setInterval(function() {
                now = new Date();
                spentTime = now - started;
                if (spentTime > duration) {
                    clearInterval(interval);
                    document.title = originalTitle;
                } else {
                    if (now - phase.started > phase.dur) {
                        if (phase.type == 'blink') {
                            document.title = originalTitle;
                            phase = {
                                type: 'pause',
                                started: now,
                                dur: pauseTime
                            };
                        } else {
                            document.title = text;
                            phase = {
                                type: 'blink',
                                started: now,
                                dur: blinkTime
                            };
                        }
                    }
                }
            }, 100);
    }
});

/**
 * Панель со смайликами для чата
 * @author Oleg Mikhailov
 */
Ext.define('ExGods.view.chat.Smiles', {
    extend: Ext.Panel,
    alias: 'widget.chatsmiles',
    id: 'chat-smiles-panel',
    tabConfig: {
        hidden: true
    },
    plugins: [
        {
            ptype: 'scroller',
            autoHide: true,
            scrollDeltaY: 23
        }
    ],
    padding: '5 5 5 10',
    initComponent: function() {
        var me = this;
        me.items = [
            this.getSmilesPanel()
        ];
        me.callParent(arguments);
        me.on('afterrender', me.onAfterRender, me);
    },
    onAfterRender: function() {
        var me = this;
        me.getEl().on('click', function(e, t) {
            /**
             * @event smileclick
             * param {String} smileCode
             */
            me.fireEvent('smileclick', Ext.fly(t).getAttribute('data-code'));
        }, me, {
            delegate: '.chat-smiles-icon'
        });
    },
    getSmilesPanel: function() {
        var me = this,
            iconCodes = ExGods.ref('images|chat_message_icons').image,
            html = '';
        Ext.Object.each(iconCodes, function(key, value) {
            var keys = key.split('|');
            html += '<span class="chat-smiles-icon" data-code="' + keys[0] + '" data-qtip="' + keys.join(' ' + ExGods.getMsgByKey('view_chat_smiles_delimiter') + ' ') + '" style="background-image: url(' + value + ');" /></span>';
        });
        return {
            xtype: 'component',
            html: html
        };
    }
});

/**
 * Всплывающее меню контактов
 */
Ext.define('ExGods.view.chat.ContactsMenu', {
    extend: ExGods.view.parchment.Window,
    alias: 'widget.chatcontactsmenu',
    cls: 'chat-menu-list',
    width: 180,
    height: 91,
    padding: '7 12',
    autoShow: true,
    header: false,
    xyOffset: [
        75,
        18
    ],
    /**
     * @cfg DOM элемент возле которого отобразить меню
     */
    clickedEl: null,
    tpl: [
        '<ul>',
        '<tpl foreach=".">',
        '<li menu-element-id="{id_element}">{label}</li>',
        '</tpl>',
        '</ul>'
    ],
    initComponent: function() {
        var me = this;
        me.prepareData();
        me.calcSize();
        me.calcPosition();
        me.callParent(arguments);
    },
    prepareData: function() {
        var me = this;
        me.data = Ext.Array.sort(config.menu.contacts || [], function(a, b) {
            var pos1 = parseInt(a.position);
            var pos2 = parseInt(b.position);
            return pos1 - pos2;
        });
    },
    calcSize: function() {
        var me = this;
        me.height = (me.data.length + 1) * 20 + 19;
    },
    calcPosition: function() {
        var me = this,
            pos,
            bodyEl = Ext.getBody(),
            htmlEl = bodyEl.parent();
        pos = Ext.get(me.clickedEl).getXY();
        me.x = pos[0] + me.xyOffset[0];
        me.y = pos[1] + me.xyOffset[1];
        if (me.y + me.height - bodyEl.dom.scrollTop > htmlEl.dom.clientHeight) {
            me.y = htmlEl.dom.clientHeight + bodyEl.dom.scrollTop - me.height;
        }
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.getEl().on('click', function(e) {
            var el = e.getTarget(),
                menuElementId = el.getAttribute('menu-element-id');
            me.fireEvent('itemclick', menuElementId);
            me.close();
        }, me, {
            delegate: 'li'
        });
    }
});

/**
 * Всплывающее меню контактов
 */
Ext.define('ExGods.view.chat.MessagesMenu', {
    extend: ExGods.view.chat.ContactsMenu,
    alias: 'widget.chatmessagesmenu',
    xyOffset: [
        -20,
        12
    ],
    prepareData: function() {
        var me = this;
        me.data = Ext.Array.sort(config.menu.messages || [], function(a, b) {
            var pos1 = parseInt(a.position);
            var pos2 = parseInt(b.position);
            return pos1 - pos2;
        });
    }
});

/**
 * Контроллер отображения чата
 */
Ext.define('ExGods.controller.Chat', {
    extend: ExGodsCore.controller.Chat,
    logConfig: {
        enabled: {
            info: true,
            error: true,
            warn: true
        },
        prefix: 'ChatView:'
    },
    views: [
        'chat.Smiles',
        'chat.ContactsMenu',
        'chat.MessagesMenu'
    ],
    refs: [
        {
            /**
             * @method getArena
             * Получет отображение арены
             * @return {ExGods.view.chat.MessageList}
             */
            ref: 'arena',
            selector: '#arena-location'
        },
        {
            /**
             * @private
             * @method getContactTabPanel
             */
            ref: 'contactTabPanel',
            selector: '#contact-tab-panel'
        },
        {
            /**
             * @private
             * @method getContactTabPanel
             */
            ref: 'contactsFilterView',
            selector: '#chat-contacts-filter'
        },
        {
            /**
             * @method getChatContactsView
             * Возвращает отображение списка контактов в чате
             * @return {Ext.view.View}
             */
            ref: 'chatContactsView',
            selector: '#chat-contact-list dataview'
        },
        {
            /**
             * @method getSmilesPanel
             */
            ref: 'smilesPanel',
            selector: '#chat-smiles-panel'
        }
    ],
    /**
     * @property {Object[]} channelPatterns
     * Шаблоны (регулярные выражения) каналов вида:
     *
     *      [
     *          {
     *              xtype: <компонента_отображения>
     *              id: <идентификатор>
     *              pattern: <регулярка_для_определения_типа_канала>
     *              title: <название_вкладки_канала>
     *              type: <тип_канала>
     *          },
     *          ...
     *      ]
     */
    channelPatterns: [],
    /**
     * @property {ExGods.view.chat.MessageList} activeTab
     * Текущая отображаемая вкладка чата
     */
    init: function(app) {
        var me = this,
            user = app.user;
        me.channelPatterns = [
            {
                xtype: 'chatmessagelist',
                id: 'world-chat-messages',
                pattern: /^world#\d+$/,
                title: ExGods.getMsgByKey('chat_world_title'),
                name: 'worldChatMessageList',
                type: {
                    world: true,
                    input: true,
                    'private': false
                }
            },
            {
                xtype: 'chatmessagelist',
                id: 'guild-chat-messages',
                pattern: /^guild#\d+$/,
                title: ExGods.getMsgByKey('chat_guild_title'),
                name: 'guildChatMessageList',
                type: {
                    'guild': true,
                    'input': true,
                    'private': true
                },
                autoshow: false,
                autoremove: true
            },
            {
                xtype: 'chatmessagelist',
                id: 'guild-group-messages',
                pattern: /^guild_group#\d+$/,
                title: ExGods.getMsgByKey('chat_guild_group_title'),
                name: 'guildChatMessageList',
                type: {
                    'guild_group': true,
                    'input': true,
                    'private': true
                },
                autoshow: false,
                autoremove: true
            },
            {
                xtype: 'chatmessagelist',
                id: 'location-chat-messages',
                pattern: /^\d+$/,
                title: ExGods.getMsgByKey('chat_location_title'),
                name: 'locationChatMessageList',
                type: {
                    location: true,
                    'default': true,
                    input: true,
                    'private': true
                },
                autoshow: true
            }
        ];
        /*{
            xtype: 'chatmessagelist',
            id: 'battle-chat-messages',
            pattern: /^battle_log#\d+$/,
            title: 'Сражение',
            name:'battleChatMessageList',
            type: {
                battle:true
            },
            autoshow:true
        }, {
            xtype: 'chatmessagelist',
            id: 'group-chat-messages',
            pattern: /^common_group#\d+$/,
            title: 'Группа',
            name:'groupChatMessageList',
            type: {
                group:true,
                input:true,
                'private':true
            },
            autoremove:true
        },*/
        me.channels = new Ext.util.MixedCollection();
        me.control({
            '#chat-tab-panel': {
                tabchange: me.onChatTabChange
            },
            'chatmessagelist': {
                'addmessage': me.onChatMessageAdd,
                'message-menu-click': me.showMessageMenu,
                'user-menu-click': me.showContactsMenu,
                'user-click': function(user, type) {
                    me.addUserToMessage(user, type);
                }
            },
            'chatinputfield': {
                'user-menu-click': me.showContactsMenu
            },
            '#chat-toolbar button[action="togglesmiles"]': {
                click: me.toggleSmilesPanel
            },
            '#contact-tab-panel': {
                tabchange: me.onContactTabChange
            },
            '#chat-contact-list': {
                afterstorechanged: me.onChatContactsStoreChanged
            },
            '#chat-contacts-filter textfield': {
                keyup: {
                    fn: me.onContactsFilterChanged,
                    buffer: 100
                }
            },
            '#chat-smiles-panel': {
                smileclick: me.onSmileClick
            },
            '#chat-off-panel textbutton': {
                click: function() {
                    me.toggleChat();
                }
            },
            '#chat-off-btn': {
                click: function() {
                    me.toggleChat();
                }
            },
            '#chat-question-btn': {
                click: me.onQuestionBtnClick
            },
            '#chat-question-big-btn': {
                click: me.onQuestionBtnClick
            },
            '#chat-expand-btn': {
                click: me.toggleExpand
            }
        });
        app.getChatConnection().on({
            command_noticeboard: me.onNoticeBoardMessage,
            scope: me
        });
        // настроиваю каналы чата в соответствии с настройками пользователя
        me.getUser().on('settingschanged', me.applyUserSettings, me);
        me.applyUserSettings();
        me.initNotebook();
        me.initIgnoreList();
        me.createCSSRules();
        me.callParent(arguments);
    },
    onLaunch: function(app) {
        var me = this,
            user = app.user,
            tabs = me.getChatTabPanel(),
            worldPattern = me.getChannelPatternByType('world'),
            locationPattern = me.getChannelPatternByType('location');
        tabs.add({
            xtype: worldPattern.xtype,
            channelId: '',
            channelType: worldPattern.type,
            channelParams: worldPattern,
            id: worldPattern.id,
            title: worldPattern.title,
            user: user,
            hidden: (me.isWorldChatDisable() || me.isChatDisable())
        }, {
            xtype: locationPattern.xtype,
            channelId: '',
            channelType: locationPattern.type,
            id: locationPattern.id,
            title: ExGods.app.user.location.data.name,
            //locationPattern.title,
            user: user
        });
        if (!me.isChatDisable() && !me.isWorldChatDisable()) {
            tabs.setActiveTab(0);
        } else {
            tabs.setActiveTab(1);
        }
    },
    /**
     * Добавляет пользователя в сообщение.
     * @param {Object} user Данные юзера
     * @param {String} type Тип сообщения
     * @param {Boolean} strongType true, если type однозначно определяет тип
     *
     */
    addUserToMessage: function(user, type, strongType) {
        var me = this;
        if (typeof user == 'object') {
            this.notebook.add(user);
            me.addNickToMessage(user.display_title, type, strongType);
        } else {
            me.addNickToMessage(user, type, strongType);
        }
    },
    /**
     * @private
     * Обрабатывает смену вкладок чата. Включает/выключает поел вводи и
     * кнопку отправки
     */
    onChatTabChange: function(chatTabs, newCard) {
        var me = this,
            contactTabs = me.getContactTabPanel();
        if (newCard.tab.hasCls('x-tab-new-private')) {
            chatTabs.items.each(function(item) {
                item.tab.removeClsWithUI('new-private');
            });
        }
        if (newCard.tab.hasCls('x-tab-new-room')) {
            newCard.tab.removeClsWithUI('new-room');
        }
        if (!me.isChatDisable()) {
            if ((newCard.channelType.battle) || (newCard.channelType.battle_obs)) {
                me.disableInput();
            } else {
                me.enableInput();
            }
        }
        contactTabs.suspendEvents();
        if (newCard.channelType.guild) {
            contactTabs.setActiveTab('guild-contact-list');
        } else if (newCard.channelType.guild_group) {
            contactTabs.setActiveTab('guild-group-list');
        } else if (newCard.channelType.group) {
            contactTabs.setActiveTab('chat-group');
        } else {
            contactTabs.setActiveTab('chat-contact-list');
        }
        contactTabs.resumeEvents();
    },
    onContactTabChange: function(contactTabs, newCard) {
        var me = this,
            chatTabs = me.getChatTabPanel();
        if (!contactTabs.eventsSuspended) {
            // suspendEvents игнорируется событиями, наложенными через Ext.app.Controller#method-control
            switch (newCard.getId()) {
                case 'chat-smiles-panel':
                    break;
                case 'chat-group':
                    chatTabs.setActiveTab('group-chat-messages');
                    break;
                default:
                    if (!me.isChatDisable() && !me.isWorldChatDisable()) {
                        chatTabs.setActiveTab('world-chat-messages');
                    } else {
                        chatTabs.setActiveTab('location-chat-messages');
                    };
                    break;
            }
        }
    },
    /**
     * Оверрайд метода ExGodsCore.controller.Chat
     */
    onMessageTypeRoom: function(chatcn, data) {
        var me = this;
        if (!me.ignoreList.users[data.from]) {
            if (data.x && data.x.users_info) {
                data.x.users_info = Ext.JSON.decode(data.x.users_info);
            }
            me.callParent(arguments);
        }
    },
    /**
     * Оверрайд метода ExGodsCore.controller.Chat
     */
    onMessageTypePrivate: function(chatcn, data) {
        var me = this;
        if (!data.x || !me.ignoreList.users[data.x.from_realuser]) {
            if (data.x && data.x.users_info) {
                data.x.users_info = Ext.JSON.decode(data.x.users_info);
            }
            me.callParent(arguments);
            if (!me.user.isChatOn()) {
                Ext.getCmp('chat-off-panel').incCounter();
            }
        }
    },
    // END: Блок получения и обработки сообщений от сервера
    /**
     * @private
     * Клик по нику в списке контактов чата
     */
    onContactListItemClick: function(view, record, item, index, e) {
        var me = this;
        if (e.getTarget('.action-icon')) {
            if (e.getTarget('.private-msg-icon')) {
                me.addUserToMessage(record.data, 'private', true);
            } else if (e.getTarget('.user-info-icon')) {
                me.app.fireEvent('nickinfoclick', record.get('display_title'));
            }
        } else if (e.getTarget('.menu-icon')) {
            me.showContactsMenu(item, record.data);
        } else {
            me.addUserToMessage(record.data);
        }
    },
    onChatMessageAdd: function(data, panel) {
        var me = this,
            activeTab = me.getChatTabPanel().getActiveTab();
        // если сообщение приватное и панель поддерживает приватные сообщения, и сообщение не показано в текущей вкладке - то показываю индикацию нового сообщения
        if (data.type == 'private' && panel.channelType["private"] && !activeTab.channelType["private"]) {
            panel.tab.addClsWithUI('new-private');
        }
        // если сообщением комнатное и адресовано мне и текущая вкладка не эта комната, то тоже показываю индикацию
        if (data.type == 'room' && me.isMessageToMe(data) && activeTab != panel) {
            panel.tab.addClsWithUI('new-room');
        }
    },
    /**
     * @private
     * Возвращает ID комнаты, в которую отсылается сообщение
     *
     * @return {String}
     */
    getChatRoomName: function() {
        var me = this,
            tabs = me.getChatTabPanel(),
            tab = tabs.getActiveTab(),
            room;
        if (tab.channelType.location) {
            room = ExGods.app.user.location.get('chat_room_name');
        } else if (tab.channelType.world) {
            room = me.getWorld().get('chat_room_name');
        } else {
            room = tab.channelId;
        }
        return room || false;
    },
    /*
    * Определяет мое ли сообщение для сообщений с типом "to" и "private"
     */
    isMyMessage: function(data) {
        var me = this,
            type = data.type;
        if (data.x.to) {
            type = 'to';
        }
        if (type == 'private' || type == 'to') {
            if (data.x.from_realuser == me.user.get('display_title')) {
                return true;
            }
        }
        return false;
    },
    /*
    * Определяет адресовано ли сообщение мне
     */
    isMessageToMe: function(data) {
        var me = this,
            type = data.type;
        if (data.x.to) {
            type = 'to';
        }
        if (type == 'private' || type == 'to') {
            var recipients = [];
            if (type == 'private' && data.x.to_realuser) {
                recipients = data.x.to_realuser.split(',');
            } else if (type == 'to') {
                recipients = Ext.decode(data.x.to);
            }
            if (Ext.Array.indexOf(recipients, me.user.get('display_title')) != -1) {
                return true;
            }
        }
        return false;
    },
    /**
     * Возвращает объект {messages:просроченные сообщения, signes:длина символов}, удаляет просроченные сообщения из хранилища сообщений юзера
     */
    getMessagesFromStorage: function() {
        var storage = Ext.util.LocalStorage.get('chat-user-messages'),
            messages = storage.getItem('messages') || [],
            i = messages.length,
            time = new Date().getTime(),
            signes = 0,
            timeout = parseInt(ExGods.ref('constants|chat_message_expire_time').value) * 1000;
        while (i > 0) {
            i--;
            if (messages[i] && messages[i].time + timeout < time) {
                messages.splice(i, 1);
            } else if (messages[i]) {
                signes += messages[i].msg.length;
            }
        }
        storage.setItem('messages', messages);
        return {
            messages: messages,
            signes: signes
        };
    },
    /**
     * добавляет сообщение в хранилище сообщений юзера
     */
    pushMessageToStorage: function(msg) {
        var storage = Ext.util.LocalStorage.get('chat-user-messages'),
            messages = storage.getItem('messages') || [];
        msg = {
            msg: msg,
            time: new Date().getTime()
        };
        messages.push(msg);
        storage.setItem('messages', messages);
        return msg;
    },
    /**
     * Отправка сообщения. Здесь фильтруются сообщения по спам фильтру, все остальное наследуется.
     */
    sendMessage: function() {
        var me = this,
            message = me.getSendMessageData(),
            content = Ext.String.trim(message.content),
            msgObject = me.getMessagesFromStorage(),
            maxMsgs = parseInt(ExGods.ref('constants|chat_messages_cap').value),
            maxSignes = parseInt(ExGods.ref('constants|chat_signes_cap').value),
            d = ExGods.util.Date.normalizeServerDateTime(new Date()),
            field = me.getInputField(),
            attrs = {};
        if (!content) {
            return;
        }
        if (ExGods.app.getUser().get('moder') == 0 && (msgObject.messages.length >= maxMsgs || msgObject.signes + content.length > maxSignes)) {
            field.setMessage();
            me.onMessageTypeDefault(null, {
                x: {},
                //time:d.getHours()+':'+d.getMinutes()+':'+d.getSeconds()
                type: 'message',
                body: {
                    body: ExGods.ref('message_client|message_limit')
                }
            });
            return;
        }
        if (message.to) {
            attrs.users_info = Ext.JSON.encode(me.notebook.prepareInfo(message));
        }
        message.from = ExGods.app.user.get('display_title');
        message.roomId = me.getChatRoomName();
        message.content = content;
        me.pushMessageToStorage(message.content);
        me.app.getChatConnection().sendMessage(message, attrs);
        field.setMessage();
    },
    // End: Обработка сообщения пользователя
    /**
     * Оверрайд метода из core
     */
    onClearBtnClick: function() {
        var me = this,
            field = me.getInputField(),
            message = field.getMessage();
        if (message.content) {
            message.content = '';
            field.setMessage(message);
        } else if (message.to && message.to.length) {
            message.to = [];
            message.type = 'room';
            field.setMessage(message);
        } else {
            me.callParent(arguments);
        }
    },
    onQuestionBtnClick: function() {
        var me = this;
        if (Ext.getCmp('ERROR_REPORT')) {
            Ext.getCmp('ERROR_REPORT').destroy();
        } else {
            ExGods.Components.factory('ERROR_REPORT');
        }
    },
    /**
     * Открывает чат на всю высоту окна
     */
    toggleExpand: function() {
        var me = this;
        me.app.getController('Viewport').toggleChatExpand();
        me.expanded = !me.expanded;
    },
    /**
     * Показывает/скрывает панель со смайликами
     */
    toggleSmilesPanel: function() {
        var me = this,
            smilesPanel = me.getSmilesPanel(),
            contactTabPanel = me.getContactTabPanel();
        if (!smilesPanel) {
            smilesPanel = Ext.widget('chatsmiles');
        }
        if (contactTabPanel) {
            if (contactTabPanel.layout.getActiveItem() == smilesPanel) {
                contactTabPanel.suspendEvents();
                // чтобы не переключалась вкладка с сообщениями чата
                contactTabPanel.layout.setActiveItem(smilesPanel.previousTab);
                contactTabPanel.resumeEvents();
            } else {
                smilesPanel.previousTab = contactTabPanel.layout.getActiveItem();
                contactTabPanel.layout.setActiveItem(smilesPanel);
            }
        }
    },
    /**
     * @private
     * Обработчик сообщения чата "noticeboard"
     */
    onNoticeBoardMessage: function() {
        var me = this;
        me.request({
            url: '/game.pl?cmd=noticeboard'
        });
    },
    /**
     * @private
     * Срабатывает на изменение в поле фильтра контактов
     */
    onContactsFilterChanged: function(f) {
        var me = this;
        me.doFilterContacts(f.getValue());
    },
    /**
     * @private
     * Срабатывает, когда к вьюхе контактов присоединено новое хранилище
     */
    onChatContactsStoreChanged: function() {
        var me = this,
            filterView = me.getContactsFilterView();
        if (filterView) {
            me.doFilterContacts(filterView.down('textfield').getValue());
        }
    },
    /**
     * @private
     * Клик по смайлику в панеле выбора смайлов
     */
    onSmileClick: function(smileCode) {
        var me = this,
            message = me.getSendMessageData(),
            maxLength = parseInt(ExGods.ref('constants|chat_message_max_length').value);
        if (parseInt(message.content.length + 3) < maxLength) {
            // размер иконки смайлика берем равным 3 символа
            message.content += smileCode;
            me.updateSendMessageField(message);
        }
    },
    /**
     * @private 
     * Отфильтровывает контакты чата
     * @param filterValue {String} Значение фильтра (required)
     */
    doFilterContacts: function(filterValue) {
        var me = this;
        filterValue = filterValue.toLowerCase().trim() , contacts = me.getChatContactsView().getStore();
        contacts.clearFilter();
        if (filterValue) {
            contacts.filter([
                {
                    filterFn: function(contact) {
                        return contact.get('display_title').toLowerCase().indexOf(filterValue) != -1;
                    }
                }
            ]);
        } else {
            contacts.sort();
        }
    },
    // принудительно сортируем после очищения фильтров
    /**
     * @private
     * Обработка блокировки коннекции к чату
     */
    onChatDisabled: function() {
        var me = this;
        // скрываю вкладку мирового чата
        var tabs = me.getChatTabPanel();
        if (tabs && tabs.rendered) {
            tabs.items.getAt(0).hide();
            tabs.tabBar.items.getAt(0).hide();
        }
        if (tabs.getActiveTab() == tabs.items.getAt(0)) {
            // если активна вкладка мирового чата - делаю активной вкладку локаций, она всегда доступна 
            tabs.setActiveTab('location-chat-messages');
        }
        // блокирую поле ввода
        me.disableInput();
    },
    /**
     * @private
     * Обработка разблокировки коннекции к чату
     */
    onChatEnabled: function() {
        var me = this;
        if (!me.isWorldChatDisable()) {
            // показываю вкладку мирового чата
            var tabs = me.getChatTabPanel();
            if (tabs && tabs.rendered) {
                tabs.items.getAt(0).show();
                tabs.tabBar.items.getAt(0).show();
            }
        }
        // разрешаю поле ввода
        me.enableInput();
    },
    /**
     * Оверрайд метода из core
     */
    getSendMessageData: function() {
        var me = this;
        return me.getInputField().getMessage();
    },
    /**
     * Оверрайд метода из core
     */
    updateSendMessageField: function(newMessage) {
        var me = this;
        me.getInputField().setMessage(newMessage ? newMessage : me.getSendMessageData());
    },
    /**
     * Показать меню для пользователя в списке контактов или в списке сообщений
     */
    showContactsMenu: function(el, user) {
        var me = this,
            query;
        // если окно уже открыто - закрываю его
        query = Ext.ComponentQuery.query('chatcontactsmenu');
        if (query.length) {
            for (var i = 0; i < query.length; i++) {
                if (query[i].clickedEl == el) {
                    query[i].close();
                    return;
                }
            }
        }
        Ext.widget('chatcontactsmenu', {
            clickedEl: el,
            xyOffset: Ext.get(el).up('.message') ? [
                -30,
                10
            ] : [
                75,
                18
            ],
            listeners: {
                itemclick: function(itemId) {
                    if (itemId == 'info') {
                        me.app.fireEvent('nickinfoclick', typeof user == 'object' ? user.display_title : user);
                    } else if (itemId == 'private') {
                        me.addUserToMessage(user, 'private', true);
                    }
                }
            }
        });
    },
    /**
     * Показать меню для сообщения в списке сообщений
     */
    showMessageMenu: function(el, message) {
        var me = this;
        // если окно уже открыто - закрываю его
        query = Ext.ComponentQuery.query('chatmessagesmenu');
        if (query.length) {
            for (var i = 0; i < query.length; i++) {
                if (query[i].clickedEl == el) {
                    query[i].close();
                    return;
                }
            }
        }
        Ext.widget('chatmessagesmenu', {
            clickedEl: el,
            listeners: {
                itemclick: function(itemId) {
                    if (itemId == 'complain') {
                        me.doComplainMessage(message);
                    }
                }
            }
        });
    },
    /**
     * Пожаловаться на сообщение
     */
    doComplainMessage: function(message) {
        var me = this;
        Ext.widget('confirmdialog', {
            message: ExGods.getMsgByKey('message_complain_confirm'),
            handler: function() {
                ExGods.app.block();
                me.request({
                    url: 'game.pl',
                    params: {
                        cmd: 'chat_complain',
                        chunk: message.x.chunk,
                        mid: message.x.mid
                    },
                    success: function(resp) {
                        ExGods.app.unblock();
                        if (resp && resp.success == 1) {
                            if (message.from) {
                                me.ignoreList.add(message.from);
                            } else if (message.x.from_realuser) {
                                me.ignoreList.add(message.x.from_realuser);
                            }
                        }
                    }
                });
            }
        });
    },
    /**
     * Выкл чат
     */
    chatOff: function() {
        var me = this,
            chatOffPanel = Ext.getCmp('chat-off-panel');
        me.user.setChatOn(false);
        Ext.getCmp('chat-container').hide();
        chatOffPanel.resetCounter();
        chatOffPanel.show();
    },
    /**
     * Вкл чат
     */
    chatOn: function() {
        var me = this,
            chatOffPanel = Ext.getCmp('chat-off-panel'),
            chatContainer = Ext.getCmp('chat-container'),
            chatTabs = Ext.getCmp('chat-tab-panel');
        me.user.setChatOn(true);
        chatOffPanel.hide();
        chatContainer.show();
        chatContainer.scrollChatToBottom();
        chatTabs.items.each(function(cmp) {
            if (cmp.rendered) {
                cmp.scroller.scrollToBottom();
            }
        });
    },
    /**
     * Переключить чат
     */
    toggleChat: function() {
        var me = this;
        if (me.user.isChatOn()) {
            me.chatOff();
        } else {
            me.chatOn();
        }
    },
    /**
     * @private Применяет юзерские настройки чата
     */
    applyUserSettings: function() {
        var me = this,
            showPrivateInLocation = parseInt(me.user.getSetting('chat_private_location')) || 0,
            showPrivateInGuild = parseInt(me.user.getSetting('chat_private_guild')) || 0;
        me.channelPatterns.forEach(function(pattern) {
            if (pattern.type.location) {
                pattern.type["private"] = !!showPrivateInLocation;
            }
            if (pattern.type.guild) {
                pattern.type["private"] = !!showPrivateInGuild;
            }
        });
    },
    /**
     * Записная книжка, хранит информацию о пользователе чата и дополняет эту информациею в сообщение перед отправкой
     */
    initNotebook: function() {
        this.notebook = {
            users: {},
            add: function(user) {
                if (Ext.isArray(user)) {
                    for (var i = 0; i < user.length; i++) {
                        this.users[user[i].display_title] = user[i];
                    }
                } else if (typeof user == 'object') {
                    this.users[user.display_title] = user;
                } else {
                    this.users[user] = {
                        display_title: user
                    };
                }
            },
            prepareInfo: function(message) {
                var info = {};
                if (message.to && message.to.length) {
                    for (var i = 0; i < message.to.length; i++) {
                        if (this.users[message.to[i]]) {
                            info[this.users[message.to[i]].display_title] = {
                                race: this.users[message.to[i]].race || 0,
                                moder: this.users[message.to[i]].moder || 0
                            };
                        } else {
                            info[this.users[message.to[i]].display_title] = {
                                race: 0,
                                moder: 0
                            };
                        }
                    }
                }
                return info;
            }
        };
    },
    /**
     * Игнор-лист игрока.
     *
     * Игнор-лист заполняется после того как игрок пожаловался на сообщение другого игрока.
     * Хранится только во время сессии игрока.
     *
     */
    initIgnoreList: function() {
        var me = this;
        me.ignoreList = {
            users: {},
            add: function(displayTitle) {
                this.users[displayTitle] = 1;
            }
        };
    },
    /**
     * @private Создает стили для вьюшек 
     */
    createCSSRules: function() {
        var me = this;
        Ext.util.CSS.createStyleSheet([
            '#chat-contact-list .userlist-item.moder { background-color: ' + ExGods.ref('constants|chat_moder_color').value + ';}',
            '.chat-messages .moder-message .message-info { background-color: ' + ExGods.ref('constants|chat_moder_color').value + ';}'
        ].join(''));
    }
});

/**
 * Модель прототипа предмета
 */
Ext.define('ExGods.model.ItemPrototype', {
    extend: ExGodsCore.model.ItemPrototype,
    id: 'item-prototypes',
    canPutInWareHouse: function() {
        var action_full = this.get('action_full'),
            valid = false;
        if (action_full && action_full.length) {
            var i = action_full.length;
            while (i--) {
                if (action_full[i].type == 'warehouse') {
                    valid = true;
                    break;
                }
            }
        }
        return valid;
    },
    getWareHouseCost: function() {
        var action_full = this.get('action_full'),
            cost;
        if (action_full && action_full.length) {
            var i = action_full.length;
            while (i--) {
                if (action_full[i].type == 'warehouse') {
                    cost = action_full[i].cost;
                    break;
                }
            }
        }
        return cost;
    }
});

/**
 * Список предметов
 */
Ext.define('ExGods.store.ItemPrototypes', {
    extend: ExGodsCore.store.ItemPrototypes,
    model: 'ExGods.model.ItemPrototype'
});

Ext.define('ExGods.store.Skills', {
    extend: Ext.data.Store,
    model: 'ExGods.model.SkillGroup',
    idProperty: 'entry',
    proxy: {
        type: 'memory'
    },
    filters: [
        function(item) {
            return item.get('visible') == 1;
        }
    ],
    /**
     * Вернет Ext.data.Model скилла по имени
     */
    getSkillByName: function(name) {
        var me = this,
            found;
        me.each(function(group) {
            if (found)  {
                return;
            }
            
            group.get('skills').each(function(skill) {
                if (!found && skill.get('name') == name) {
                    found = skill;
                }
            });
        });
        return found;
    },
    /**
     * Вернет true или false, учится сейчас скилл или нет
     */
    isLearning: function() {
        var me = this,
            learning = false;
        me.each(function(group) {
            if (learning)  {
                return;
            }
            
            group.getSource().each(function(skill) {
                if (!learning && skill.get('progress') && !skill.get('progress').pause) {
                    learning = true;
                }
            });
        });
        return learning;
    },
    /**
     * Вернет Ext.data.Model скилла, который сейчас изучается
     */
    getLearningSkill: function() {
        var me = this,
            learning;
        me.each(function(group) {
            if (learning)  {
                return;
            }
            
            group.getSource().each(function(skill) {
                if (!learning && skill.get('progress') && !skill.get('progress').pause) {
                    learning = skill;
                }
            });
        });
        return learning;
    },
    /**
     * Вернет Ext.data.Model группы, скилл которой сейчас изучается
     */
    getLearningGroup: function() {
        var me = this,
            learning;
        me.each(function(group) {
            if (learning)  {
                return;
            }
            
            group.getSource().each(function(skill) {
                if (!learning && skill.get('progress') && !skill.get('progress').pause) {
                    learning = group;
                }
            });
        });
        return learning;
    },
    /**
     * вернет массив всех скиллов
     */
    getAll: function() {
        var me = this,
            skills = [];
        me.each(function(group) {
            group.getSource().each(function(skill) {
                skills.push(skill);
            });
        });
        return skills;
    },
    /**
     * вернет все картинки для подгрузки
     */
    getImages: function() {
        var me = this,
            images = [];
        me.each(function(group) {
            images = images.concat(group.getImages());
        });
        return images;
    }
});

Ext.define('ExGods.store.SpecialDeals', {
    extend: Ext.data.Store,
    model: 'ExGods.model.SpecialDeal',
    proxy: {
        type: 'memory'
    }
});

/**
 * Хранилище лута для распределения
 */
Ext.define('ExGods.store.Loot', {
    extend: Ext.data.Store,
    model: 'ExGods.model.VirtualStoreStuff',
    proxy: 'memory',
    filters: [
        function(item) {
            return !item.isExpired() && [
                'item',
                'currency'
            ].indexOf(item.data.stuff.type) != -1;
        }
    ]
});

/**
 * Хранилище масок юзера
 */
Ext.define('ExGods.store.Masks', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Mask',
    proxy: 'memory',
    sorters: [
        {
            sorterFn: function(o1, o2) {
                return parseInt(o1.data.has) > parseInt(o2.data.has) ? -1 : parseInt(o1.data.has) < parseInt(o2.data.has) ? 1 : 0;
            }
        },
        {
            sorterFn: function(o1, o2) {
                return parseInt(o1.data.l_order) > parseInt(o2.data.l_order) ? -1 : parseInt(o1.data.l_order) < parseInt(o2.data.l_order) ? 1 : 0;
            }
        }
    ],
    /**
     * вернет текущую маску юзера
     */
    getCurrent: function() {
        return this.findRecord('slot_on', 1);
    },
    /**
     * проверит маску на то, может ли ее одеть юзер или нет (если маска одета - вернет false);
     */
    canFitAndUse: function(record) {
        if (!record)  {
            return false;
        }
        
        var id = record.isModel ? record.get('id') : record;
        //на случай если придет айди маски
        record = this.findRecord('id', id);
        return record.get('has') && this.getCurrent() != record;
    },
    /**
     * вернет сгруппированный и сортированный список масок
     */
    getGroups: function() {
        var me = this,
            groups = [];
        me.each(function(record) {
            var group = record.get('group'),
                g_order = record.get('g_order'),
                type = record.get('type');
            if (!groups[g_order]) {
                groups[g_order] = {
                    g_order: g_order,
                    type: type,
                    name: group,
                    records: []
                };
            }
            groups[g_order].records.push(record);
        });
        groups = Ext.Array.clean(groups);
        Ext.Array.each(groups, function(group) {
            Ext.Array.sort(group.records, function(o1, o2) {
                return Number(o1.data.l_order) > Number(o2.data.l_order) ? -1 : Number(o1.data.l_order) < Number(o2.data.l_order) ? 1 : 0;
            });
        });
        Ext.Array.sort(groups, function(g1, g2) {
            return Number(g1.g_order) > Number(g2.g_order) ? -1 : Number(g1.g_order) < Number(g2.g_order) ? 1 : 0;
        });
        return groups;
    }
});

/**
 * @property {Boolean} isMobile
 * true - если запущено на планшете или телефоне,
 * false - на обычном компьютере
 */
var isMobile = Ext.is.iOS || Ext.is.Android;
if (!isMobile) {
    // поддержка touch нужна только для мобильной платформы
    Ext.supports.Touch = false;
    Ext.supports.TouchEvents = false;
}
var isVK = config.user.payment == 'vka';
var isOK = config.user.payment == 'oka';
var isMM = config.user.payment == 'mma';
var isFB = config.user.payment == 'fba';
var isKG = config.user.payment == 'kga';
/**
 * @property {Boolean} isSocialApp
 * Признак социальной версии игры
 */
var isSocialApp = isVK || isOK || isMM || isFB || isKG;
/**
 * @property {Boolean} isCompact
 * @deprecated В новой версии этот флаг не должен использоваться
 * Признак компактного режима отображения.
 */
var isCompact = false;
//isVK || !!config.force_compact;
/**
 * @property {String} IMAGE_URL
 * URL для картинок, берётся из справочника
 */
var IMAGE_URL;
/**
 * @class ExGods
 * @singleton
 *
 * Namespace нашего приложения ExGods.app
 */
Ext.ns('ExGods');
var references;
Ext.Loader.setConfig({
    enabled: true,
    paths: {
        'Ext': '/j/extjs/src',
        'ExGods': '/j/exgods2/app',
        'ExGodsCore': '/j/exgodscore'
    }
});
;
if (isMobile) {
    Ext.getBody().parent().addCls('mobile');
}
Ext.getBody().parent().addCls('app');
setTimeout(function() {
    Ext.getBody().addCls('loading');
}, 0);
Ext.onReady(function() {
    var i, j;
    if ((top == window) && isSocialApp) {
        Ext.util.Cookies.set(config.auth_cookie.name, null, new Date("January 1, 1970"), '/', config.auth_cookie.domain);
        Ext.create('Ext.form.Panel', {
            renderTo: Ext.getBody(),
            hidden: true
        }).getForm().submit({
            url: '/reg.pl?cmd=error',
            method: 'POST',
            params: {
                message: 'Данным персонажем нельзя играть вне приложения в социальной сети. Для игры с главной страницы зарегистрируйте нового персонажа.'
            },
            standardSubmit: true
        });
        return;
    }
    if (Ext.supports.Touch && !Ext.is.Phone) {
        new NoClickDelay(Ext.getBody().dom);
    }
    Ext.apply(Ext.util.Format, {
        thousandSeparator: ' ',
        /**
         * Возвращает единицу измерения с правильным окончанием
         * @member Ext.util.Format
         * 
         * @param {Number} num Число
         * @param {String[]} cases Варианты слова, например ['час', 'часа', 'часов']
         * @return {String}
         */
        plural: function(num, cases) {
            num = Math.abs(num);
            var word = '';
            if (num != NaN) {
                if (num.toString().indexOf('.') > -1) {
                    word = cases[1];
                } else {
                    word = (num % 10 == 1 && num % 100 != 11 ? cases[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? cases[1] : cases[2]);
                }
            }
            return word;
        },
        /**
         * Преобразует текстовые ссылки в гиперссылки
         * [rickyrosario.com](http://rickyrosario.com/blog/converting-a-url-into-a-link-in-javascript-linkify-function/)
         * @member Ext.util.Format
         *
         * @param {String} text Текст            
         * @return {String}
         */
        linkify: function(text) {
            var valid_urls;
            if (text) {
                valid_urls = ExGods.references.get('constants_list').valid_urls.value;
                text = text.replace(/<br\/?>/g, '\n');
                // чтобы корректно обрабатывался список ссылок, разделенный <br/>
                // TODO: по-хорошему, нужно добавить <br> и другие разделители (запятая например) в регулярку
                text = text.replace(/(https?\:\/\/)?([a-zа-яё0-9_\-]+\.)?([a-zа-яё0-9_\-]+)\.([a-z]{2,4}|рф)(\/\S*|#\S*)?/gi, function(url) {
                    //проверю урл на смайлики
                    // var spl = url.split(':'),
                    //  smiles = [],
                    //  i = spl.length;
                    // while(i > 0){
                    //  i--;
                    //  if(!spl[i] || spl[i].match('[a-zа-яё0-9_\-]+\.')[0] === spl[i]){
                    //      if(spl[i]) smiles.unshift(spl[i]);
                    //      spl.pop();
                    //  }else{
                    //      break;
                    //  }
                    // }
                    // url = spl.join(':');
                    var full_url = url,
                        i = 0;
                    full_url = ExGods.util.Helper.processTextWithSmiles(full_url);
                    var smiles = full_url.split('<');
                    full_url = smiles[0];
                    smiles.shift();
                    smiles = smiles.length ? '<' + smiles.join('<') : '';
                    if (!full_url.match('^https?://')) {
                        full_url = 'http://' + full_url;
                    }
                    for (; i < valid_urls.length; i++) {
                        if (full_url.match('^https?://([^.]+.)?' + valid_urls[i]))  {
                            return '<a href="' + full_url + '" target="_blank">#' + ExGods.getMsgByKey('chat_link_text') + '</a>' + smiles;
                        }
                        
                    }
                    return '<' + ExGods.getMsgByKey('chat_censor_text') + '>';
                });
                text = text.replace(/\n/g, '<br/>');
            }
            return text;
        },
        /**
         * Преобразует время обратного отсчёта в форматированную строку
         * @member Ext.util.Format
         *
         * @param {Number} time Время в секундах
         * @return {String}
         */
        countdown: ExGods.util.Time.printTime,
        /**
         * Отформатирует валюту в строку: '123 456 рублей'
         * @param {Number} value Значение валюты
         * @param {String} type Тип валюты - "crystal", "real"
         * @param {String} format Строка для стандартного строкового темплейтера Ext.String.format вида '{0} {1}',
         *   где 0 - значение валюты, 1 - название валюты
         * @return {String}
         */
        money: function(value, type, format) {
            var curValue = 0,
                curLabel = '',
                format = format ? format : '{0} {1}';
            curValue = Ext.util.Format.number(value, '0,0');
            if (type) {
                if (type == 'crystal') {
                    labels = ExGods.getMsgByKey('crystal_name').split(',');
                } else if (type == 'real') {
                    if (isVK) {
                        labels = ExGods.getMsgByKey('payment_vka');
                    } else if (isOK) {
                        labels = ExGods.getMsgByKey('payment_oka');
                    } else if (isMM) {
                        labels = ExGods.getMsgByKey('payment_mma');
                    } else {
                        labels = ExGods.getMsgByKey('roubles_names').split(',');
                    }
                }
                if (labels)  {
                    curLabel = Ext.util.Format.plural(value, labels);
                }
                
            }
            return Ext.String.format(format, curValue, curLabel);
        }
    });
    exGodsLoader.setPercentage(20, 40);
    /**
     * Инициализация объекта приложения
     */
    Ext.application({
        extend: ExGodsCore.Application,
        appFolder: '/j/exgods2/app',
        appProperty: 'app',
        mainView: 'ExGods.view.Viewport',
        enableQuickTips: isMobile ? false : true,
        name: 'ExGods',
        logConfig: {
            enabled: {
                info: false,
                warn: true,
                error: true
            },
            prefix: 'ExGodsApp:'
        },
        controllers: [
            'Error',
            // всегда первый, чтобы подписаться на все AJAX запросы
            'Services',
            'Layers',
            'Components',
            'ClientActions',
            'CSS',
            'Announcments',
            'Arena',
            'Arena2',
            'Action',
            'Bank',
            'Bank2',
            'BattleChain',
            'battle.Battle',
            'battle.BattleView',
            'battle.Animation',
            'battle.Stability',
            'ChatGroup',
            'Communication',
            'Resources',
            'Dialog',
            'Shop',
            'inventory.Inventory',
            'inventory.VirtualStore',
            'Item',
            'Hints',
            'Location',
            'Log',
            'Market',
            'Masks',
            'OnlineList',
            // 'PerformanceTest',
            'Preloader',
            'Ratings',
            'Robbery',
            'Settings',
            'social.VK',
            'social.OK',
            'social.MM',
            'social.FB',
            'social.KG',
            'Sound',
            'SpecialDeal',
            'Surging',
            'Teleport',
            'ToolsMenu',
            'TooltipManager',
            'Quest',
            'QuestHelper',
            'QuickSlot',
            'User',
            'Viewport',
            'Lair',
            'Skills',
            'Fucina',
            'Chests',
            'Guild',
            'GuildOnline',
            'LootManager',
            'Pets',
            'Direction',
            // должен запускаться после Viewport
            'Chat'
        ],
        // всегда последний, чтобы начать авторизацию в чате после инициализации всех контроллеров
        models: [
            'Shop',
            'User',
            'Ability',
            'FeaturePrototype'
        ],
        stores: [
            /**
             * @method getChatContactsStore
             * Возвращает хранилище контактов в чате
             * @return {ExGods.store.ChatContacts}
             */
            'ChatContacts@ExGodsCore.store',
            /**
             * @method getItemPrototypesStore
             * Возвращает хранилище прототипов предметов
             * @return {ExGods.store.ItemPrototypes}
             */
            'ItemPrototypes',
            /**
             * @method getAbilityPrototypesStore
             * Возвращает хранилище прототипов абилок
             * @return {ExGods.store.AbilityPrototypes}
             */
            'AbilityPrototypes',
            /**
             * @method getFeaturePrototypesStore
             * Возвращает хранилище прототипов абилок
             * @return {ExGods.store.FeaturePrototypes}
             */
            'FeaturePrototypes',
            /**
             * @method getMonsterStore
             * Возвращает хранилище ботов в данной локации
             * @return {ExGods.store.Monster}
             */
            'Monster',
            /**
             * @method getLocationsStore
             * Возвращает хранилище всех локаций во всех мирах
             * @return {ExGods.store.Locations}
             */
            'Locations',
            /**
             * @method getSkillsStore
             * Возвращает хранилище навыков юзера
             * @return {ExGods.store.Skills}
             */
            'Skills',
            /**
             * @method getSpecialDealsStore
             * Возвращает хранилище специальных предложений
             * @return {ExGods.store.SpecialDeals}
             */
            'SpecialDeals',
            /**
             * @method getChestsStore
             * Возвращает хранилище сундуков
             * @return {ExGods.store.Chests}
             */
            'Chests',
            /**
             * @method getGuildsStore
             * Возвращает хранилище гильдий
             * @return {ExGods.store.Guilds}
             */
            'Guilds',
            /**
             * @method getGuildRaidsStore
             * Возвращает хранилище рейдов гильдий
             * @return {ExGods.store.GuildRaids}
             */
            'GuildRaids',
            /**
             * @method getLootStore
             * Возвращает хранилище лута для распределения
             * @return {ExGods.store.Loot}
             */
            'Loot',
            /**
             * @method getWorldsStore
             * Возвращает хранилище миров игры
             * @return {ExGods.store.Worlds}
             */
            'Worlds',
            /**
             * @method getMasksStore
             * Возвращает хранилище масок юзера
             * @return {ExGods.store.Masks}
             */
            'Masks'
        ],
        /**
         * Вернёт модель пользователя приложения
         * @return {Ext.data.Model}
         */
        getUser: function() {
            return this.user;
        },
        /**
         * Вернёт модель текущей локации
         * @return {Ext.data.Model}
         */
        getLocation: function() {
            var me = this,
                user = me.getUser(),
                locations = me.getLocationsStore();
            return locations.data.getByKey(user.getLocation());
        },
        /**
         * Вернёт модель текущего мира
         * @return {Ext.data.Model}
         */
        getWorld: function() {
            var me = this,
                user = me.getUser(),
                worlds = me.getWorldsStore();
            return worlds.data.getByKey(user.getWorld());
        },
        getImageUrl: function() {
            if (typeof ExgMobile != 'undefined') {
                return ExgMobile.config.image_url;
            } else {
                return this.callParent(arguments);
            }
        },
        getHostUrl: function() {
            if (typeof ExgMobile != 'undefined') {
                return ExgMobile.config.host_url;
            } else {
                return this.callParent(arguments);
            }
        },
        /**
         * @cfg {Array} serverRequestKeyHandlerSequence см. {@link ExGodsCore.AjaxRequest#keyHandlersSequence keyHandlersSequence}
         */
        serverRequestKeyHandlerSequence: [
            'user',
            'quests',
            'bots',
            'trace_quest'
        ],
        init: function() {
            var me = this;
            /***/
            me.log('info', 'начинаю инициализацию приложения');
            me.callParent(arguments);
            //  ссылки на справочники.. в дальнейшем справочники должны использоваться только через app
            ExGods.references = references = me.references;
            // обработчики коннекции чата
            me.getChatConnection().on({
                ping: me.onPing,
                scope: me
            });
            /***/
            me.log('info', 'инициализация завершена');
        },
        /**
         * Запуск приложения
         */
        launch: function() {
            var me = this;
            me.callParent(arguments);
            // Инициализация SDK соц.сети
            if (isSocialApp) {
                me.getSocialController().initSDK();
            }
        },
        /**
         * Вернет контроллер социальной сети
         */
        getSocialController: function() {
            var me = this;
            switch (config.user.payment) {
                case 'vka':
                    return me.getController('social.VK');
                case 'oka':
                    return me.getController('social.OK');
                case 'mma':
                    return me.getController('social.MM');
                case 'fba':
                    return me.getController('social.FB');
                case 'kga':
                    return me.getController('social.KG');
            }
        },
        /**
         * Функция для преобразования шаблона
         * @author Тимур Нурутдинов
         * 
         * @param {String} tpl Шаблон
         * @param {Object} data Данные
         * @return {ExGods.view.Template}
         */
        applyTpl: function(tpl, data) {
            var me = this;
            if (!me.template) {
                me.template = Ext.create('ExGods.view.Template', {
                    compiled: false,
                    disableFormats: false
                });
            }
            tpl = tpl.replace('\\', '&#92;');
            me.template.set(tpl, false);
            return me.template.apply(data);
        },
        /**
         * Глобальная блокировка интерфейса
         *
         * @param {String} [msg="Подождите…"] Сообщения для показа
         */
        block: function(msg) {
            Ext.getBody().mask((msg || ExGods.getMsgByKey('wait_message')), 'global-mask-msg').addCls('global-mask');
        },
        /**
         * Разблокирует интерфейс игры
         */
        unblock: function() {
            Ext.getBody().unmask();
        },
        /**
         * Обработка пинга
         */
        onPing: function(data) {
            // обновляю сдвиг времени относительно сервера
            ExGods.util.Date.serverTimeOffset = parseInt(new Date().getTime() / 1000, 10) - data.now;
        }
    });
});

/**
 * Окно сообщения об ошибке
 */
Ext.define('ExGods.view.ErrorReport', {
    extend: Ext.panel.Panel,
    alias: 'widget.errorreport',
    cls: 'report-error',
    //layout: 'fit',
    plugins: [
        'paperdeco'
    ],
    padding: '0 0 20 0',
    margin: 10,
    /**
     * @cfg {ExGods.model.User} user (required)
     * Пользователь
     */
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser(),
            formItems = [];
        formItems.push({
            xtype: 'hiddenfield',
            name: 'cmd',
            value: 'bugs'
        }, {
            xtype: 'radiogroup',
            fieldLabel: ExGods.getMsgByKey('view_error_cat'),
            //показать проблемного кота
            labelAlign: 'top',
            vertical: true,
            columns: 1,
            items: [
                {
                    boxLabel: ExGods.getMsgByKey('view_error_senderror'),
                    name: 'type',
                    inputValue: '2',
                    checked: true
                },
                /*{
                boxLabel: ExGods.getMsgByKey('view_error_ask'),
                name: 'type',
                inputValue: '1'
            }, */
                {
                    boxLabel: ExGods.getMsgByKey('view_error_complain'),
                    name: 'type',
                    inputValue: '7'
                }
            ]
        });
        formItems.push({
            xtype: 'textfield',
            name: 'subject',
            fieldLabel: ExGods.getMsgByKey('view_error_theme') + '<span class="required">*</span>',
            labelAlign: 'top',
            allowBlank: false
        }, {
            xtype: 'textareafield',
            name: 'message',
            fieldLabel: ExGods.getMsgByKey('view_error_problem') + '<span class="required">*</span>',
            labelAlign: 'top',
            allowBlank: false,
            height: /*140*/
            160
        }, {
            xtype: 'component',
            html: ExGods.getMsgByKey('view_error_comment')
        });
        me.items = [
            {
                xtype: 'component',
                html: '<h2 class="paper-title">' + ExGods.getMsgByKey('error_report_title') + '</h2>'
            },
            {
                xtype: 'form',
                url: '/game.pl',
                margin: '0 20',
                defaults: {
                    xtype: 'component',
                    anchor: '100%'
                },
                items: formItems,
                buttonAlign: 'center',
                buttons: {
                    items: [
                        {
                            xtype: 'textbutton',
                            type: 'submit',
                            id: 'submit',
                            text: ExGods.getMsgByKey('view_error_publish'),
                            width: 150,
                            cls: 'no_border x-btn-txt-green'
                        },
                        {
                            xtype: 'tbspacer',
                            width: 50
                        },
                        {
                            xtype: 'textbutton',
                            type: 'reset',
                            text: ExGods.getMsgByKey('view_error_clear'),
                            id: 'reset',
                            itemId: 'reset',
                            width: 150,
                            cls: 'no_border x-btn-txt-red'
                        }
                    ]
                }
            }
        ];
        me.callParent();
        me.down('radiogroup').on('change', me.onChange, me);
    },
    onChange: function(radiogroup, value) {
        var me = this,
            label_title, desc_title;
        switch (value.type) {
            case '2':
                label_title = ExGods.getMsgByKey('view_error_theme');
                desc_title = ExGods.getMsgByKey('view_error_problem');
                break;
            case '1':
                label_title = ExGods.getMsgByKey('view_error_question_theme');
                desc_title = ExGods.getMsgByKey('view_error_question_problem');
                break;
            case '7':
                label_title = ExGods.getMsgByKey('view_error_complain_theme');
                desc_title = ExGods.getMsgByKey('view_error_complain_problem');
                break;
            default:
                break;
        }
        if (label_title) {
            me.down('textfield').setFieldLabel(label_title + '<span class="required">*</span>');
        }
        if (desc_title) {
            me.down('textareafield').setFieldLabel(desc_title + '<span class="required">*</span>');
        }
    }
});

