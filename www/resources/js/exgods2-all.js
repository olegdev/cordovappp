/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var stropheMD5 = (function () {
    /*
     * Configurable variables. You may need to tweak these to be compatible with
     * the server-side, but the defaults work in most cases.
     */
    var hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase */
    var b64pad  = ""; /* base-64 pad character. "=" for strict RFC compliance */
    var chrsz   = 8;  /* bits per input character. 8 - ASCII; 16 - Unicode */

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    var safe_add = function (x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF);
        var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    };

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    var bit_rol = function (num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    };

    /*
     * Convert a string to an array of little-endian words
     * If chrsz is ASCII, characters >255 have their hi-byte silently ignored.
     */
    var str2binl = function (str) {
        var bin = [];
        var mask = (1 << chrsz) - 1;
        for(var i = 0; i < str.length * chrsz; i += chrsz)
        {
            bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (i%32);
        }
        return bin;
    };

    /*
     * Convert an array of little-endian words to a string
     */
    var binl2str = function (bin) {
        var str = "";
        var mask = (1 << chrsz) - 1;
        for(var i = 0; i < bin.length * 32; i += chrsz)
        {
            str += String.fromCharCode((bin[i>>5] >>> (i % 32)) & mask);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a hex string.
     */
    var binl2hex = function (binarray) {
        var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
        var str = "";
        for(var i = 0; i < binarray.length * 4; i++)
        {
            str += hex_tab.charAt((binarray[i>>2] >> ((i%4)*8+4)) & 0xF) +
                hex_tab.charAt((binarray[i>>2] >> ((i%4)*8  )) & 0xF);
        }
        return str;
    };

    /*
     * Convert an array of little-endian words to a base-64 string
     */
    var binl2b64 = function (binarray) {
        var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var str = "";
        var triplet, j;
        for(var i = 0; i < binarray.length * 4; i += 3)
        {
            triplet = (((binarray[i   >> 2] >> 8 * ( i   %4)) & 0xFF) << 16) |
                (((binarray[i+1 >> 2] >> 8 * ((i+1)%4)) & 0xFF) << 8 ) |
                ((binarray[i+2 >> 2] >> 8 * ((i+2)%4)) & 0xFF);
            for(j = 0; j < 4; j++)
            {
                if(i * 8 + j * 6 > binarray.length * 32) { str += b64pad; }
                else { str += tab.charAt((triplet >> 6*(3-j)) & 0x3F); }
            }
        }
        return str;
    };

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    var md5_cmn = function (q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q),safe_add(x, t)), s),b);
    };

    var md5_ff = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    };

    var md5_gg = function (a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    };

    var md5_hh = function (a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    };

    var md5_ii = function (a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    };

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length
     */
    var core_md5 = function (x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var a =  1732584193;
        var b = -271733879;
        var c = -1732584194;
        var d =  271733878;

        var olda, oldb, oldc, oldd;
        for (var i = 0; i < x.length; i += 16)
        {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
            d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
            b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
            d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
            c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
            d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
            d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

            a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
            d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
            c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
            b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
            d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
            c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
            d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
            c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
            a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
            d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
            c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
            b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
            d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
            b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
            d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
            c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
            d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
            a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
            d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
            b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
            d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
            c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
            d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
            d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
            a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
            d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
            b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    };


    /*
     * Calculate the HMAC-MD5, of a key and some data
     */
    var core_hmac_md5 = function (key, data) {
        var bkey = str2binl(key);
        if(bkey.length > 16) { bkey = core_md5(bkey, key.length * chrsz); }

        var ipad = new Array(16), opad = new Array(16);
        for(var i = 0; i < 16; i++)
        {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }

        var hash = core_md5(ipad.concat(str2binl(data)), 512 + data.length * chrsz);
        return core_md5(opad.concat(hash), 512 + 128);
    };

    var obj = {
        /*
         * These are the functions you'll usually want to call.
         * They take string arguments and return either hex or base-64 encoded
         * strings.
         */
        hexdigest: function (s) {
            return binl2hex(core_md5(str2binl(s), s.length * chrsz));
        },

        b64digest: function (s) {
            return binl2b64(core_md5(str2binl(s), s.length * chrsz));
        },

        hash: function (s) {
            return binl2str(core_md5(str2binl(s), s.length * chrsz));
        },

        hmac_hexdigest: function (key, data) {
            return binl2hex(core_hmac_md5(key, data));
        },

        hmac_b64digest: function (key, data) {
            return binl2b64(core_hmac_md5(key, data));
        },

        hmac_hash: function (key, data) {
            return binl2str(core_hmac_md5(key, data));
        },

        /*
         * Perform a simple self-test to see if the VM is working
         */
        test: function () {
            return stropheMD5.hexdigest("abc") === "900150983cd24fb0d6963f7d28e17f72";
        }
    };

    return obj;
})();
// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

var Base64 = (function () {
    var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

    var obj = {
        /**
         * Encodes a string in base64
         * @param {String} input The string to encode in base64.
         */
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) + keyStr.charAt(enc4);
            } while (i < input.length);

            return output;
        },

        /**
         * Decodes a base64 string.
         * @param {String} input The string to decode.
         */
        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3;
            var enc1, enc2, enc3, enc4;
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }
            } while (i < input.length);

            return output;
        }
    };

    return obj;
})();
/*
    This program is distributed under the terms of the MIT license.
    Please see the LICENSE file for details.

    Copyright 2006-2008, OGG, LLC
*/

/* jslint configuration: */
/*global document, window, setTimeout, clearTimeout, console,
    XMLHttpRequest, ActiveXObject,
    Base64, MD5,
    Strophe, $build, $msg, $iq, $pres */

/** File: strophe.js
 *  A JavaScript library for XMPP BOSH.
 *
 *  This is the JavaScript version of the Strophe library.  Since JavaScript
 *  has no facilities for persistent TCP connections, this library uses
 *  Bidirectional-streams Over Synchronous HTTP (BOSH) to emulate
 *  a persistent, stateful, two-way connection to an XMPP server.  More
 *  information on BOSH can be found in XEP 124.
 */

/** PrivateFunction: Function.prototype.bind
 *  Bind a function to an instance.
 *
 *  This Function object extension method creates a bound method similar
 *  to those in Python.  This means that the 'this' object will point
 *  to the instance you want.  See
 *  <a href='https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind'>MDC's bind() documentation</a> and 
 *  <a href='http://benjamin.smedbergs.us/blog/2007-01-03/bound-functions-and-function-imports-in-javascript/'>Bound Functions and Function Imports in JavaScript</a>
 *  for a complete explanation.
 *
 *  This extension already exists in some browsers (namely, Firefox 3), but
 *  we provide it to support those that don't.
 *
 *  Parameters:
 *    (Object) obj - The object that will become 'this' in the bound function.
 *    (Object) argN - An option argument that will be prepended to the 
 *      arguments given for the function call
 *
 *  Returns:
 *    The bound function.
 */
if (!Function.prototype.bind) {
    Function.prototype.bind = function (obj /*, arg1, arg2, ... */)
    {
        var func = this;
        var _slice = Array.prototype.slice;
        var _concat = Array.prototype.concat;
        var _args = _slice.call(arguments, 1);
        
        return function () {
            return func.apply(obj ? obj : this,
                              _concat.call(_args,
                                           _slice.call(arguments, 0)));
        };
    };
}

/** PrivateFunction: Array.prototype.indexOf
 *  Return the index of an object in an array.
 *
 *  This function is not supplied by some JavaScript implementations, so
 *  we provide it if it is missing.  This code is from:
 *  http://developer.mozilla.org/En/Core_JavaScript_1.5_Reference:Objects:Array:indexOf
 *
 *  Parameters:
 *    (Object) elt - The object to look for.
 *    (Integer) from - The index from which to start looking. (optional).
 *
 *  Returns:
 *    The index of elt in the array or -1 if not found.
 */
if (!Array.prototype.indexOf)
{
    Array.prototype.indexOf = function(elt /*, from*/)
    {
        var len = this.length;

        var from = Number(arguments[1]) || 0;
        from = (from < 0) ? Math.ceil(from) : Math.floor(from);
        if (from < 0) {
            from += len;
        }

        for (; from < len; from++) {
            if (from in this && this[from] === elt) {
                return from;
            }
        }

        return -1;
    };
}

/* All of the Strophe globals are defined in this special function below so
 * that references to the globals become closures.  This will ensure that
 * on page reload, these references will still be available to callbacks
 * that are still executing.
 */

(function (callback) {
var Strophe;

/** Function: $build
 *  Create a Strophe.Builder.
 *  This is an alias for 'new Strophe.Builder(name, attrs)'.
 *
 *  Parameters:
 *    (String) name - The root element name.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $build(name, attrs) { return new Strophe.Builder(name, attrs); }
/** Function: $msg
 *  Create a Strophe.Builder with a <message/> element as the root.
 *
 *  Parmaeters:
 *    (Object) attrs - The <message/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $msg(attrs) { return new Strophe.Builder("message", attrs); }
/** Function: $iq
 *  Create a Strophe.Builder with an <iq/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <iq/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $iq(attrs) { return new Strophe.Builder("iq", attrs); }
/** Function: $pres
 *  Create a Strophe.Builder with a <presence/> element as the root.
 *
 *  Parameters:
 *    (Object) attrs - The <presence/> element attributes in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder object.
 */
function $pres(attrs) { return new Strophe.Builder("presence", attrs); }

/** Class: Strophe
 *  An object container for all Strophe library functions.
 *
 *  This class is just a container for all the objects and constants
 *  used in the library.  It is not meant to be instantiated, but to
 *  provide a namespace for library objects, constants, and functions.
 */
Strophe = {
    /** Constant: VERSION
     *  The version of the Strophe library. Unreleased builds will have
     *  a version of head-HASH where HASH is a partial revision.
     */
    VERSION: "@VERSION@",

    /** Constants: XMPP Namespace Constants
     *  Common namespace constants from the XMPP RFCs and XEPs.
     *
     *  NS.HTTPBIND - HTTP BIND namespace from XEP 124.
     *  NS.BOSH - BOSH namespace from XEP 206.
     *  NS.CLIENT - Main XMPP client namespace.
     *  NS.AUTH - Legacy authentication namespace.
     *  NS.ROSTER - Roster operations namespace.
     *  NS.PROFILE - Profile namespace.
     *  NS.DISCO_INFO - Service discovery info namespace from XEP 30.
     *  NS.DISCO_ITEMS - Service discovery items namespace from XEP 30.
     *  NS.MUC - Multi-User Chat namespace from XEP 45.
     *  NS.SASL - XMPP SASL namespace from RFC 3920.
     *  NS.STREAM - XMPP Streams namespace from RFC 3920.
     *  NS.BIND - XMPP Binding namespace from RFC 3920.
     *  NS.SESSION - XMPP Session namespace from RFC 3920.
     */
    NS: {
        HTTPBIND: "http://jabber.org/protocol/httpbind",
        BOSH: "urn:xmpp:xbosh",
        CLIENT: "jabber:client",
        AUTH: "jabber:iq:auth",
        ROSTER: "jabber:iq:roster",
        PROFILE: "jabber:iq:profile",
        DISCO_INFO: "http://jabber.org/protocol/disco#info",
        DISCO_ITEMS: "http://jabber.org/protocol/disco#items",
        MUC: "http://jabber.org/protocol/muc",
        SASL: "urn:ietf:params:xml:ns:xmpp-sasl",
        STREAM: "http://etherx.jabber.org/streams",
        BIND: "urn:ietf:params:xml:ns:xmpp-bind",
        SESSION: "urn:ietf:params:xml:ns:xmpp-session",
        VERSION: "jabber:iq:version",
        STANZAS: "urn:ietf:params:xml:ns:xmpp-stanzas"
    },

    /** Function: addNamespace
     *  This function is used to extend the current namespaces in
     *  Strophe.NS.  It takes a key and a value with the key being the
     *  name of the new namespace, with its actual value.
     *  For example:
     *  Strophe.addNamespace('PUBSUB', "http://jabber.org/protocol/pubsub");
     *
     *  Parameters:
     *    (String) name - The name under which the namespace will be
     *      referenced under Strophe.NS
     *    (String) value - The actual namespace.
     */
    addNamespace: function (name, value)
    {
    Strophe.NS[name] = value;
    },

    /** Constants: Connection Status Constants
     *  Connection status constants for use by the connection handler
     *  callback.
     *
     *  Status.ERROR - An error has occurred
     *  Status.CONNECTING - The connection is currently being made
     *  Status.CONNFAIL - The connection attempt failed
     *  Status.AUTHENTICATING - The connection is authenticating
     *  Status.AUTHFAIL - The authentication attempt failed
     *  Status.CONNECTED - The connection has succeeded
     *  Status.DISCONNECTED - The connection has been terminated
     *  Status.DISCONNECTING - The connection is currently being terminated
     *  Status.ATTACHED - The connection has been attached
     */
    Status: {
        ERROR: 0,
        CONNECTING: 1,
        CONNFAIL: 2,
        AUTHENTICATING: 3,
        AUTHFAIL: 4,
        CONNECTED: 5,
        DISCONNECTED: 6,
        DISCONNECTING: 7,
        ATTACHED: 8
    },

    /** Constants: Log Level Constants
     *  Logging level indicators.
     *
     *  LogLevel.DEBUG - Debug output
     *  LogLevel.INFO - Informational output
     *  LogLevel.WARN - Warnings
     *  LogLevel.ERROR - Errors
     *  LogLevel.FATAL - Fatal errors
     */
    LogLevel: {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3,
        FATAL: 4
    },

    /** PrivateConstants: DOM Element Type Constants
     *  DOM element types.
     *
     *  ElementType.NORMAL - Normal element.
     *  ElementType.TEXT - Text data element.
     */
    ElementType: {
        NORMAL: 1,
        TEXT: 3,
        CDATA: 4
    },

    /** PrivateConstants: Timeout Values
     *  Timeout values for error states.  These values are in seconds.
     *  These should not be changed unless you know exactly what you are
     *  doing.
     *
     *  TIMEOUT - Timeout multiplier. A waiting request will be considered
     *      failed after Math.floor(TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 1.1, and with default wait, 66 seconds.
     *  SECONDARY_TIMEOUT - Secondary timeout multiplier. In cases where
     *      Strophe can detect early failure, it will consider the request
     *      failed if it doesn't return after
     *      Math.floor(SECONDARY_TIMEOUT * wait) seconds have elapsed.
     *      This defaults to 0.1, and with default wait, 6 seconds.
     */
    TIMEOUT: 1.1,
    SECONDARY_TIMEOUT: 0.1,

    /** Function: forEachChild
     *  Map a function over some or all child elements of a given element.
     *
     *  This is a small convenience function for mapping a function over
     *  some or all of the children of an element.  If elemName is null, all
     *  children will be passed to the function, otherwise only children
     *  whose tag names match elemName will be passed.
     *
     *  Parameters:
     *    (XMLElement) elem - The element to operate on.
     *    (String) elemName - The child element tag name filter.
     *    (Function) func - The function to apply to each child.  This
     *      function should take a single argument, a DOM element.
     */
    forEachChild: function (elem, elemName, func)
    {
        var i, childNode;

        for (i = 0; i < elem.childNodes.length; i++) {
            childNode = elem.childNodes[i];
            if (childNode.nodeType == Strophe.ElementType.NORMAL &&
                (!elemName || this.isTagEqual(childNode, elemName))) {
                func(childNode);
            }
        }
    },

    /** Function: isTagEqual
     *  Compare an element's tag name with a string.
     *
     *  This function is case insensitive.
     *
     *  Parameters:
     *    (XMLElement) el - A DOM element.
     *    (String) name - The element name.
     *
     *  Returns:
     *    true if the element's tag name matches _el_, and false
     *    otherwise.
     */
    isTagEqual: function (el, name)
    {
        return el.tagName.toLowerCase() == name.toLowerCase();
    },

    /** PrivateVariable: _xmlGenerator
     *  _Private_ variable that caches a DOM document to
     *  generate elements.
     */
    _xmlGenerator: null,

    /** PrivateFunction: _makeGenerator
     *  _Private_ function that creates a dummy XML DOM document to serve as
     *  an element and text node generator.
     */
    _makeGenerator: function () {
        var doc;

        if (document.implementation.createDocument === undefined) {
            doc = this._getIEXmlDom();
            doc.appendChild(doc.createElement('strophe'));
        } else {
            doc = document.implementation
                .createDocument('jabber:client', 'strophe', null);
        }

        return doc;
    },

    /** Function: xmlGenerator
     *  Get the DOM document to generate elements.
     *
     *  Returns:
     *    The currently used DOM document.
     */
    xmlGenerator: function () {
        if (!Strophe._xmlGenerator) {
            Strophe._xmlGenerator = Strophe._makeGenerator();
        }
        return Strophe._xmlGenerator;
    },

    /** PrivateFunction: _getIEXmlDom
     *  Gets IE xml doc object
     *
     *  Returns:
     *    A Microsoft XML DOM Object
     *  See Also:
     *    http://msdn.microsoft.com/en-us/library/ms757837%28VS.85%29.aspx
     */
    _getIEXmlDom : function() {
        var doc = null;
        var docStrings = [
            "Msxml2.DOMDocument.6.0",
            "Msxml2.DOMDocument.5.0",
            "Msxml2.DOMDocument.4.0",
            "MSXML2.DOMDocument.3.0",
            "MSXML2.DOMDocument",
            "MSXML.DOMDocument",
            "Microsoft.XMLDOM"
        ];

        for (var d = 0; d < docStrings.length; d++) {
            if (doc === null) {
                try {
                    doc = new ActiveXObject(docStrings[d]);
                } catch (e) {
                    doc = null;
                }
            } else {
                break;
            }
        }

        return doc;
    },

    /** Function: xmlElement
     *  Create an XML DOM element.
     *
     *  This function creates an XML DOM element correctly across all
     *  implementations. Note that these are not HTML DOM elements, which
     *  aren't appropriate for XMPP stanzas.
     *
     *  Parameters:
     *    (String) name - The name for the element.
     *    (Array|Object) attrs - An optional array or object containing
     *      key/value pairs to use as element attributes. The object should
     *      be in the format {'key': 'value'} or {key: 'value'}. The array
     *      should have the format [['key1', 'value1'], ['key2', 'value2']].
     *    (String) text - The text child data for the element.
     *
     *  Returns:
     *    A new XML DOM element.
     */
    xmlElement: function (name)
    {
        if (!name) { return null; }

        var node = Strophe.xmlGenerator().createElement(name);

        // FIXME: this should throw errors if args are the wrong type or
        // there are more than two optional args
        var a, i, k;
        for (a = 1; a < arguments.length; a++) {
            if (!arguments[a]) { continue; }
            if (typeof(arguments[a]) == "string" ||
                typeof(arguments[a]) == "number") {
                node.appendChild(Strophe.xmlTextNode(arguments[a]));
            } else if (typeof(arguments[a]) == "object" &&
                       typeof(arguments[a].sort) == "function") {
                for (i = 0; i < arguments[a].length; i++) {
                    if (typeof(arguments[a][i]) == "object" &&
                        typeof(arguments[a][i].sort) == "function") {
                        node.setAttribute(arguments[a][i][0],
                                          arguments[a][i][1]);
                    }
                }
            } else if (typeof(arguments[a]) == "object") {
                for (k in arguments[a]) {
                    if (arguments[a].hasOwnProperty(k)) {
                        node.setAttribute(k, arguments[a][k]);
                    }
                }
            }
        }

        return node;
    },

    /*  Function: xmlescape
     *  Excapes invalid xml characters.
     *
     *  Parameters:
     *     (String) text - text to escape.
     *
     *  Returns:
     *      Escaped text.
     */
    xmlescape: function(text)
    {
        text = text.replace(/\&/g, "&amp;");
        text = text.replace(/</g,  "&lt;");
        text = text.replace(/>/g,  "&gt;");
        text = text.replace(/'/g,  "&apos;");
        text = text.replace(/"/g,  "&quot;");
        return text;
    },

    /** Function: xmlTextNode
     *  Creates an XML DOM text node.
     *
     *  Provides a cross implementation version of document.createTextNode.
     *
     *  Parameters:
     *    (String) text - The content of the text node.
     *
     *  Returns:
     *    A new XML DOM text node.
     */
    xmlTextNode: function (text)
    {
        return Strophe.xmlGenerator().createTextNode(text);
    },

    /** Function: getText
     *  Get the concatenation of all text children of an element.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A String with the concatenated text of all text element children.
     */
    getText: function (elem)
    {
        if (!elem) { return null; }

        var str = "";
        if (elem.childNodes.length === 0 && elem.nodeType ==
            Strophe.ElementType.TEXT) {
            str += elem.nodeValue;
        }

        for (var i = 0; i < elem.childNodes.length; i++) {
            if (elem.childNodes[i].nodeType == Strophe.ElementType.TEXT) {
                str += elem.childNodes[i].nodeValue;
            }
        }

        return str;
    },

    /** Function: copyElement
     *  Copy an XML DOM element.
     *
     *  This function copies a DOM element and all its descendants and returns
     *  the new copy.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    A new, copied DOM element tree.
     */
    copyElement: function (elem)
    {
        var i, el;
        if (elem.nodeType == Strophe.ElementType.NORMAL) {
            el = Strophe.xmlElement(elem.tagName);

            for (i = 0; i < elem.attributes.length; i++) {
                el.setAttribute(elem.attributes[i].nodeName.toLowerCase(),
                                elem.attributes[i].value);
            }

            for (i = 0; i < elem.childNodes.length; i++) {
                el.appendChild(Strophe.copyElement(elem.childNodes[i]));
            }
        } else if (elem.nodeType == Strophe.ElementType.TEXT) {
            el = Strophe.xmlGenerator().createTextNode(elem.nodeValue);
        }

        return el;
    },

    /** Function: escapeNode
     *  Escape the node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An escaped node (or local part).
     */
    escapeNode: function (node)
    {
        return node.replace(/^\s+|\s+$/g, '')
            .replace(/\\/g,  "\\5c")
            .replace(/ /g,   "\\20")
            .replace(/\"/g,  "\\22")
            .replace(/\&/g,  "\\26")
            .replace(/\'/g,  "\\27")
            .replace(/\//g,  "\\2f")
            .replace(/:/g,   "\\3a")
            .replace(/</g,   "\\3c")
            .replace(/>/g,   "\\3e")
            .replace(/@/g,   "\\40");
    },

    /** Function: unescapeNode
     *  Unescape a node part (also called local part) of a JID.
     *
     *  Parameters:
     *    (String) node - A node (or local part).
     *
     *  Returns:
     *    An unescaped node (or local part).
     */
    unescapeNode: function (node)
    {
        return node.replace(/\\20/g, " ")
            .replace(/\\22/g, '"')
            .replace(/\\26/g, "&")
            .replace(/\\27/g, "'")
            .replace(/\\2f/g, "/")
            .replace(/\\3a/g, ":")
            .replace(/\\3c/g, "<")
            .replace(/\\3e/g, ">")
            .replace(/\\40/g, "@")
            .replace(/\\5c/g, "\\");
    },

    /** Function: getNodeFromJid
     *  Get the node portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the node.
     */
    getNodeFromJid: function (jid)
    {
        if (jid.indexOf("@") < 0) { return null; }
        return jid.split("@")[0];
    },

    /** Function: getDomainFromJid
     *  Get the domain portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the domain.
     */
    getDomainFromJid: function (jid)
    {
        var bare = Strophe.getBareJidFromJid(jid);
        if (bare.indexOf("@") < 0) {
            return bare;
        } else {
            var parts = bare.split("@");
            parts.splice(0, 1);
            return parts.join('@');
        }
    },

    /** Function: getResourceFromJid
     *  Get the resource portion of a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the resource.
     */
    getResourceFromJid: function (jid)
    {
        var s = jid.split("/");
        if (s.length < 2) { return null; }
        s.splice(0, 1);
        return s.join('/');
    },

    /** Function: getBareJidFromJid
     *  Get the bare JID from a JID String.
     *
     *  Parameters:
     *    (String) jid - A JID.
     *
     *  Returns:
     *    A String containing the bare JID.
     */
    getBareJidFromJid: function (jid)
    {
        return jid ? jid.split("/")[0] : null;
    },

    /** Function: log
     *  User overrideable logging function.
     *
     *  This function is called whenever the Strophe library calls any
     *  of the logging functions.  The default implementation of this
     *  function does nothing.  If client code wishes to handle the logging
     *  messages, it should override this with
     *  > Strophe.log = function (level, msg) {
     *  >   (user code here)
     *  > };
     *
     *  Please note that data sent and received over the wire is logged
     *  via Strophe.Connection.rawInput() and Strophe.Connection.rawOutput().
     *
     *  The different levels and their meanings are
     *
     *    DEBUG - Messages useful for debugging purposes.
     *    INFO - Informational messages.  This is mostly information like
     *      'disconnect was called' or 'SASL auth succeeded'.
     *    WARN - Warnings about potential problems.  This is mostly used
     *      to report transient connection errors like request timeouts.
     *    ERROR - Some error occurred.
     *    FATAL - A non-recoverable fatal error occurred.
     *
     *  Parameters:
     *    (Integer) level - The log level of the log message.  This will
     *      be one of the values in Strophe.LogLevel.
     *    (String) msg - The log message.
     */
    log: function (level, msg)
    {
        return;
    },

    /** Function: debug
     *  Log a message at the Strophe.LogLevel.DEBUG level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    debug: function(msg)
    {
        this.log(this.LogLevel.DEBUG, msg);
    },

    /** Function: info
     *  Log a message at the Strophe.LogLevel.INFO level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    info: function (msg)
    {
        this.log(this.LogLevel.INFO, msg);
    },

    /** Function: warn
     *  Log a message at the Strophe.LogLevel.WARN level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    warn: function (msg)
    {
        this.log(this.LogLevel.WARN, msg);
    },

    /** Function: error
     *  Log a message at the Strophe.LogLevel.ERROR level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    error: function (msg)
    {
        this.log(this.LogLevel.ERROR, msg);
    },

    /** Function: fatal
     *  Log a message at the Strophe.LogLevel.FATAL level.
     *
     *  Parameters:
     *    (String) msg - The log message.
     */
    fatal: function (msg)
    {
        this.log(this.LogLevel.FATAL, msg);
    },

    /** Function: serialize
     *  Render a DOM element and all descendants to a String.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The serialized element tree as a String.
     */
    serialize: function (elem)
    {
        var result;

        if (!elem) { return null; }

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }

        var nodeName = elem.nodeName;
        var i, child;

        if (elem.getAttribute("_realname")) {
            nodeName = elem.getAttribute("_realname");
        }

        result = "<" + nodeName;
        for (i = 0; i < elem.attributes.length; i++) {
               if(elem.attributes[i].nodeName != "_realname") {
                 result += " " + elem.attributes[i].nodeName.toLowerCase() +
                "='" + elem.attributes[i].value
                    .replace(/&/g, "&amp;")
                       .replace(/\'/g, "&apos;")
                       .replace(/</g, "&lt;") + "'";
               }
        }

        if (elem.childNodes.length > 0) {
            result += ">";
            for (i = 0; i < elem.childNodes.length; i++) {
                child = elem.childNodes[i];
                switch( child.nodeType ){
                  case Strophe.ElementType.NORMAL:
                    // normal element, so recurse
                    result += Strophe.serialize(child);
                    break;
                  case Strophe.ElementType.TEXT:
                    // text element to escape values
                    result += Strophe.xmlescape(child.nodeValue);
                    break;
                  case Strophe.ElementType.CDATA:
                    // cdata section so don't escape values
                    result += "<![CDATA["+child.nodeValue+"]]>";
                }
            }
            result += "</" + nodeName + ">";
        } else {
            result += "/>";
        }

        return result;
    },

    /** PrivateVariable: _requestId
     *  _Private_ variable that keeps track of the request ids for
     *  connections.
     */
    _requestId: 0,

    /** PrivateVariable: Strophe.connectionPlugins
     *  _Private_ variable Used to store plugin names that need
     *  initialization on Strophe.Connection construction.
     */
    _connectionPlugins: {},

    /** Function: addConnectionPlugin
     *  Extends the Strophe.Connection object with the given plugin.
     *
     *  Parameters:
     *    (String) name - The name of the extension.
     *    (Object) ptype - The plugin's prototype.
     */
    addConnectionPlugin: function (name, ptype)
    {
        Strophe._connectionPlugins[name] = ptype;
    }
};

/** Class: Strophe.Builder
 *  XML DOM builder.
 *
 *  This object provides an interface similar to JQuery but for building
 *  DOM element easily and rapidly.  All the functions except for toString()
 *  and tree() return the object, so calls can be chained.  Here's an
 *  example using the $iq() builder helper.
 *  > $iq({to: 'you', from: 'me', type: 'get', id: '1'})
 *  >     .c('query', {xmlns: 'strophe:example'})
 *  >     .c('example')
 *  >     .toString()
 *  The above generates this XML fragment
 *  > <iq to='you' from='me' type='get' id='1'>
 *  >   <query xmlns='strophe:example'>
 *  >     <example/>
 *  >   </query>
 *  > </iq>
 *  The corresponding DOM manipulations to get a similar fragment would be
 *  a lot more tedious and probably involve several helper variables.
 *
 *  Since adding children makes new operations operate on the child, up()
 *  is provided to traverse up the tree.  To add two children, do
 *  > builder.c('child1', ...).up().c('child2', ...)
 *  The next operation on the Builder will be relative to the second child.
 */

/** Constructor: Strophe.Builder
 *  Create a Strophe.Builder object.
 *
 *  The attributes should be passed in object notation.  For example
 *  > var b = new Builder('message', {to: 'you', from: 'me'});
 *  or
 *  > var b = new Builder('messsage', {'xml:lang': 'en'});
 *
 *  Parameters:
 *    (String) name - The name of the root element.
 *    (Object) attrs - The attributes for the root element in object notation.
 *
 *  Returns:
 *    A new Strophe.Builder.
 */
Strophe.Builder = function (name, attrs)
{
    // Set correct namespace for jabber:client elements
    if (name == "presence" || name == "message" || name == "iq") {
        if (attrs && !attrs.xmlns) {
            attrs.xmlns = Strophe.NS.CLIENT;
        } else if (!attrs) {
            attrs = {xmlns: Strophe.NS.CLIENT};
        }
    }

    // Holds the tree being built.
    this.nodeTree = Strophe.xmlElement(name, attrs);

    // Points to the current operation node.
    this.node = this.nodeTree;
};

Strophe.Builder.prototype = {
    /** Function: tree
     *  Return the DOM tree.
     *
     *  This function returns the current DOM tree as an element object.  This
     *  is suitable for passing to functions like Strophe.Connection.send().
     *
     *  Returns:
     *    The DOM tree as a element object.
     */
    tree: function ()
    {
        return this.nodeTree;
    },

    /** Function: toString
     *  Serialize the DOM tree to a String.
     *
     *  This function returns a string serialization of the current DOM
     *  tree.  It is often used internally to pass data to a
     *  Strophe.Request object.
     *
     *  Returns:
     *    The serialized DOM tree in a String.
     */
    toString: function ()
    {
        return Strophe.serialize(this.nodeTree);
    },

    /** Function: up
     *  Make the current parent element the new current element.
     *
     *  This function is often used after c() to traverse back up the tree.
     *  For example, to add two children to the same element
     *  > builder.c('child1', {}).up().c('child2', {});
     *
     *  Returns:
     *    The Stophe.Builder object.
     */
    up: function ()
    {
        this.node = this.node.parentNode;
        return this;
    },

    /** Function: attrs
     *  Add or modify attributes of the current element.
     *
     *  The attributes should be passed in object notation.  This function
     *  does not move the current element pointer.
     *
     *  Parameters:
     *    (Object) moreattrs - The attributes to add/modify in object notation.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    attrs: function (moreattrs)
    {
        for (var k in moreattrs) {
            if (moreattrs.hasOwnProperty(k)) {
                this.node.setAttribute(k, moreattrs[k]);
            }
        }
        return this;
    },

    /** Function: c
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function moves the current element pointer to the child,
     *  unless text is provided.  If you need to add another child, it
     *  is necessary to use up() to go back to the parent in the tree.
     *
     *  Parameters:
     *    (String) name - The name of the child.
     *    (Object) attrs - The attributes of the child in object notation.
     *    (String) text - The text to add to the child.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    c: function (name, attrs, text)
    {
        var child = Strophe.xmlElement(name, attrs, text);
        this.node.appendChild(child);
        if (!text) {
            this.node = child;
        }
        return this;
    },

    /** Function: cnode
     *  Add a child to the current element and make it the new current
     *  element.
     *
     *  This function is the same as c() except that instead of using a
     *  name and an attributes object to create the child it uses an
     *  existing DOM element object.
     *
     *  Parameters:
     *    (XMLElement) elem - A DOM element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    cnode: function (elem)
    {
        var xmlGen = Strophe.xmlGenerator();
        try {
            var impNode = (xmlGen.importNode !== undefined);
        }
        catch (e) {
            var impNode = false;
        }
        var newElem = impNode ?
                      xmlGen.importNode(elem, true) :
                      Strophe.copyElement(elem);
        this.node.appendChild(newElem);
        this.node = newElem;
        return this;
    },

    /** Function: t
     *  Add a child text element.
     *
     *  This *does not* make the child the new current element since there
     *  are no children of text elements.
     *
     *  Parameters:
     *    (String) text - The text data to append to the current element.
     *
     *  Returns:
     *    The Strophe.Builder object.
     */
    t: function (text)
    {
        var child = Strophe.xmlTextNode(text);
        this.node.appendChild(child);
        return this;
    }
};


/** PrivateClass: Strophe.Handler
 *  _Private_ helper class for managing stanza handlers.
 *
 *  A Strophe.Handler encapsulates a user provided callback function to be
 *  executed when matching stanzas are received by the connection.
 *  Handlers can be either one-off or persistant depending on their
 *  return value. Returning true will cause a Handler to remain active, and
 *  returning false will remove the Handler.
 *
 *  Users will not use Strophe.Handler objects directly, but instead they
 *  will use Strophe.Connection.addHandler() and
 *  Strophe.Connection.deleteHandler().
 */

/** PrivateConstructor: Strophe.Handler
 *  Create and initialize a new Strophe.Handler.
 *
 *  Parameters:
 *    (Function) handler - A function to be executed when the handler is run.
 *    (String) ns - The namespace to match.
 *    (String) name - The element name to match.
 *    (String) type - The element type to match.
 *    (String) id - The element id attribute to match.
 *    (String) from - The element from attribute to match.
 *    (Object) options - Handler options
 *
 *  Returns:
 *    A new Strophe.Handler object.
 */
Strophe.Handler = function (handler, ns, name, type, id, from, options)
{
    this.handler = handler;
    this.ns = ns;
    this.name = name;
    this.type = type;
    this.id = id;
    this.options = options || {matchbare: false};

    // default matchBare to false if undefined
    if (!this.options.matchBare) {
        this.options.matchBare = false;
    }

    if (this.options.matchBare) {
        this.from = from ? Strophe.getBareJidFromJid(from) : null;
    } else {
        this.from = from;
    }

    // whether the handler is a user handler or a system handler
    this.user = true;
};

Strophe.Handler.prototype = {
    /** PrivateFunction: isMatch
     *  Tests if a stanza matches the Strophe.Handler.
     *
     *  Parameters:
     *    (XMLElement) elem - The XML element to test.
     *
     *  Returns:
     *    true if the stanza matches and false otherwise.
     */
    isMatch: function (elem)
    {
        var nsMatch;
        var from = null;

        if (this.options.matchBare) {
            from = Strophe.getBareJidFromJid(elem.getAttribute('from'));
        } else {
            from = elem.getAttribute('from');
        }

        nsMatch = false;
        if (!this.ns) {
            nsMatch = true;
        } else {
            var that = this;
            Strophe.forEachChild(elem, null, function (elem) {
                if (elem.getAttribute("xmlns") == that.ns) {
                    nsMatch = true;
                }
            });

            nsMatch = nsMatch || elem.getAttribute("xmlns") == this.ns;
        }

        if (nsMatch &&
            (!this.name || Strophe.isTagEqual(elem, this.name)) &&
            (!this.type || elem.getAttribute("type") == this.type) &&
            (!this.id || elem.getAttribute("id") == this.id) &&
            (!this.from || from == this.from)) {
                return true;
        }

        return false;
    },

    /** PrivateFunction: run
     *  Run the callback on a matching stanza.
     *
     *  Parameters:
     *    (XMLElement) elem - The DOM element that triggered the
     *      Strophe.Handler.
     *
     *  Returns:
     *    A boolean indicating if the handler should remain active.
     */
    run: function (elem)
    {
        var result = null;
        try {
            result = this.handler(elem);
        } catch (e) {
            if (e.sourceURL) {
                Strophe.fatal("error: " + this.handler +
                              " " + e.sourceURL + ":" +
                              e.line + " - " + e.name + ": " + e.message);
            } else if (e.fileName) {
                if (typeof(console) != "undefined") {
                    console.trace();
                    console.error(this.handler, " - error - ", e, e.message);
                }
                Strophe.fatal("error: " + this.handler + " " +
                              e.fileName + ":" + e.lineNumber + " - " +
                              e.name + ": " + e.message);
            } else {
                Strophe.fatal("error: " + this.handler);
            }

            throw e;
        }

        return result;
    },

    /** PrivateFunction: toString
     *  Get a String representation of the Strophe.Handler object.
     *
     *  Returns:
     *    A String.
     */
    toString: function ()
    {
        return "{Handler: " + this.handler + "(" + this.name + "," +
            this.id + "," + this.ns + ")}";
    }
};

/** PrivateClass: Strophe.TimedHandler
 *  _Private_ helper class for managing timed handlers.
 *
 *  A Strophe.TimedHandler encapsulates a user provided callback that
 *  should be called after a certain period of time or at regular
 *  intervals.  The return value of the callback determines whether the
 *  Strophe.TimedHandler will continue to fire.
 *
 *  Users will not use Strophe.TimedHandler objects directly, but instead
 *  they will use Strophe.Connection.addTimedHandler() and
 *  Strophe.Connection.deleteTimedHandler().
 */

/** PrivateConstructor: Strophe.TimedHandler
 *  Create and initialize a new Strophe.TimedHandler object.
 *
 *  Parameters:
 *    (Integer) period - The number of milliseconds to wait before the
 *      handler is called.
 *    (Function) handler - The callback to run when the handler fires.  This
 *      function should take no arguments.
 *
 *  Returns:
 *    A new Strophe.TimedHandler object.
 */
Strophe.TimedHandler = function (period, handler)
{
    this.period = period;
    this.handler = handler;

    this.lastCalled = new Date().getTime();
    this.user = true;
};

Strophe.TimedHandler.prototype = {
    /** PrivateFunction: run
     *  Run the callback for the Strophe.TimedHandler.
     *
     *  Returns:
     *    true if the Strophe.TimedHandler should be called again, and false
     *      otherwise.
     */
    run: function ()
    {
        this.lastCalled = new Date().getTime();
        return this.handler();
    },

    /** PrivateFunction: reset
     *  Reset the last called time for the Strophe.TimedHandler.
     */
    reset: function ()
    {
        this.lastCalled = new Date().getTime();
    },

    /** PrivateFunction: toString
     *  Get a string representation of the Strophe.TimedHandler object.
     *
     *  Returns:
     *    The string representation.
     */
    toString: function ()
    {
        return "{TimedHandler: " + this.handler + "(" + this.period +")}";
    }
};

/** PrivateClass: Strophe.Request
 *  _Private_ helper class that provides a cross implementation abstraction
 *  for a BOSH related XMLHttpRequest.
 *
 *  The Strophe.Request class is used internally to encapsulate BOSH request
 *  information.  It is not meant to be used from user's code.
 */

/** PrivateConstructor: Strophe.Request
 *  Create and initialize a new Strophe.Request object.
 *
 *  Parameters:
 *    (XMLElement) elem - The XML data to be sent in the request.
 *    (Function) func - The function that will be called when the
 *      XMLHttpRequest readyState changes.
 *    (Integer) rid - The BOSH rid attribute associated with this request.
 *    (Integer) sends - The number of times this same request has been
 *      sent.
 */
Strophe.Request = function (elem, func, rid, sends)
{
    this.id = ++Strophe._requestId;
    this.xmlData = elem;
    this.data = Strophe.serialize(elem);
    // save original function in case we need to make a new request
    // from this one.
    this.origFunc = func;
    this.func = func;
    this.rid = rid;
    this.date = NaN;
    this.sends = sends || 0;
    this.abort = false;
    this.dead = null;
    this.age = function () {
        if (!this.date) { return 0; }
        var now = new Date();
        return (now - this.date) / 1000;
    };
    this.timeDead = function () {
        if (!this.dead) { return 0; }
        var now = new Date();
        return (now - this.dead) / 1000;
    };
    this.xhr = this._newXHR();
};

Strophe.Request.prototype = {
    /** PrivateFunction: getResponse
     *  Get a response from the underlying XMLHttpRequest.
     *
     *  This function attempts to get a response from the request and checks
     *  for errors.
     *
     *  Throws:
     *    "parsererror" - A parser error occured.
     *
     *  Returns:
     *    The DOM element tree of the response.
     */
    getResponse: function ()
    {
        var node = null;
        if (this.xhr.responseXML && this.xhr.responseXML.documentElement) {
            node = this.xhr.responseXML.documentElement;
            if (node.tagName == "parsererror") {
                Strophe.error("invalid response received");
                Strophe.error("responseText: " + this.xhr.responseText);
                Strophe.error("responseXML: " +
                              Strophe.serialize(this.xhr.responseXML));
                throw "parsererror";
            }
        } else if (this.xhr.responseText) {
            Strophe.error("invalid response received");
            Strophe.error("responseText: " + this.xhr.responseText);
            Strophe.error("responseXML: " +
                          Strophe.serialize(this.xhr.responseXML));
        }

        return node;
    },

    /** PrivateFunction: _newXHR
     *  _Private_ helper function to create XMLHttpRequests.
     *
     *  This function creates XMLHttpRequests across all implementations.
     *
     *  Returns:
     *    A new XMLHttpRequest.
     */
    _newXHR: function ()
    {
        var xhr = null;
        if (window.XMLHttpRequest) {
            xhr = new XMLHttpRequest();
            if (xhr.overrideMimeType) {
                xhr.overrideMimeType("text/xml");
            }
        } else if (window.ActiveXObject) {
            xhr = new ActiveXObject("Microsoft.XMLHTTP");
        }

        // use Function.bind() to prepend ourselves as an argument
        xhr.onreadystatechange = this.func.bind(null, this);

        return xhr;
    }
};

/** Class: Strophe.Connection
 *  XMPP Connection manager.
 *
 *  Thie class is the main part of Strophe.  It manages a BOSH connection
 *  to an XMPP server and dispatches events to the user callbacks as
 *  data arrives.  It supports SASL PLAIN, SASL DIGEST-MD5, and legacy
 *  authentication.
 *
 *  After creating a Strophe.Connection object, the user will typically
 *  call connect() with a user supplied callback to handle connection level
 *  events like authentication failure, disconnection, or connection
 *  complete.
 *
 *  The user will also have several event handlers defined by using
 *  addHandler() and addTimedHandler().  These will allow the user code to
 *  respond to interesting stanzas or do something periodically with the
 *  connection.  These handlers will be active once authentication is
 *  finished.
 *
 *  To send data to the connection, use send().
 */

/** Constructor: Strophe.Connection
 *  Create and initialize a Strophe.Connection object.
 *
 *  Parameters:
 *    (String) service - The BOSH service URL.
 *
 *  Returns:
 *    A new Strophe.Connection object.
 */
Strophe.Connection = function (service)
{
    /* The path to the httpbind service. */
    this.service = service;
    /* The connected JID. */
    this.jid = "";
    /* request id for body tags */
    this.rid = Math.floor(Math.random() * 4294967295);
    /* The current session ID. */
    this.sid = null;
    this.streamId = null;
    /* stream:features */
    this.features = null;

    // SASL
    this.do_session = false;
    this.do_bind = false;

    // handler lists
    this.timedHandlers = [];
    this.handlers = [];
    this.removeTimeds = [];
    this.removeHandlers = [];
    this.addTimeds = [];
    this.addHandlers = [];

    this._idleTimeout = null;
    this._disconnectTimeout = null;

    this.authenticated = false;
    this.disconnecting = false;
    this.connected = false;

    this.errors = 0;

    this.paused = false;

    // default BOSH values
    this.hold = 1;
    this.wait = 60;
    this.window = 5;

    this._data = [];
    this._requests = [];
    this._uniqueId = Math.round(Math.random() * 10000);

    this._sasl_success_handler = null;
    this._sasl_failure_handler = null;
    this._sasl_challenge_handler = null;

    // setup onIdle callback every 1/10th of a second
    this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);

    // initialize plugins
    for (var k in Strophe._connectionPlugins) {
        if (Strophe._connectionPlugins.hasOwnProperty(k)) {
        var ptype = Strophe._connectionPlugins[k];
            // jslint complaints about the below line, but this is fine
            var F = function () {};
            F.prototype = ptype;
            this[k] = new F();
        this[k].init(this);
        }
    }
};

Strophe.Connection.prototype = {
    /** Function: reset
     *  Reset the connection.
     *
     *  This function should be called after a connection is disconnected
     *  before that connection is reused.
     */
    reset: function ()
    {
        this.rid = Math.floor(Math.random() * 4294967295);

        this.sid = null;
        this.streamId = null;

        // SASL
        this.do_session = false;
        this.do_bind = false;

        // handler lists
        this.timedHandlers = [];
        this.handlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];

        this.authenticated = false;
        this.disconnecting = false;
        this.connected = false;

        this.errors = 0;

        this._requests = [];
        this._uniqueId = Math.round(Math.random()*10000);
    },

    /** Function: pause
     *  Pause the request manager.
     *
     *  This will prevent Strophe from sending any more requests to the
     *  server.  This is very useful for temporarily pausing while a lot
     *  of send() calls are happening quickly.  This causes Strophe to
     *  send the data in a single request, saving many request trips.
     */
    pause: function ()
    {
        this.paused = true;
    },

    /** Function: resume
     *  Resume the request manager.
     *
     *  This resumes after pause() has been called.
     */
    resume: function ()
    {
        this.paused = false;
    },

    /** Function: getUniqueId
     *  Generate a unique ID for use in <iq/> elements.
     *
     *  All <iq/> stanzas are required to have unique id attributes.  This
     *  function makes creating these easy.  Each connection instance has
     *  a counter which starts from zero, and the value of this counter
     *  plus a colon followed by the suffix becomes the unique id. If no
     *  suffix is supplied, the counter is used as the unique id.
     *
     *  Suffixes are used to make debugging easier when reading the stream
     *  data, and their use is recommended.  The counter resets to 0 for
     *  every new connection for the same reason.  For connections to the
     *  same server that authenticate the same way, all the ids should be
     *  the same, which makes it easy to see changes.  This is useful for
     *  automated testing as well.
     *
     *  Parameters:
     *    (String) suffix - A optional suffix to append to the id.
     *
     *  Returns:
     *    A unique string to be used for the id attribute.
     */
    getUniqueId: function (suffix)
    {
        if (typeof(suffix) == "string" || typeof(suffix) == "number") {
            return ++this._uniqueId + ":" + suffix;
        } else {
            return ++this._uniqueId + "";
        }
    },

    /** Function: connect
     *  Starts the connection process.
     *
     *  As the connection process proceeds, the user supplied callback will
     *  be triggered multiple times with status updates.  The callback
     *  should take two arguments - the status code and the error condition.
     *
     *  The status code will be one of the values in the Strophe.Status
     *  constants.  The error condition will be one of the conditions
     *  defined in RFC 3920 or the condition 'strophe-parsererror'.
     *
     *  Please see XEP 124 for a more detailed explanation of the optional
     *  parameters below.
     *
     *  Parameters:
     *    (String) jid - The user's JID.  This may be a bare JID,
     *      or a full JID.  If a node is not supplied, SASL ANONYMOUS
     *      authentication will be attempted.
     *    (String) pass - The user's password.
     *    (Function) callback - The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     */
    connect: function (jid, pass, callback, wait, hold)
    {
        this.jid = jid;
        this.pass = pass;
        this.connect_callback = callback;
        this.disconnecting = false;
        this.connected = false;
        this.authenticated = false;
        this.errors = 0;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;

        // parse jid for domain and resource
        this.domain = Strophe.getDomainFromJid(this.jid);

        // build the body tag
        var body = this._buildBody().attrs({
            to: this.domain,
            "xml:lang": "en",
            wait: this.wait,
            hold: this.hold,
            content: "text/xml; charset=utf-8",
            ver: "1.6",
            "xmpp:version": "1.0",
            "xmlns:xmpp": Strophe.NS.BOSH
        });

        this._changeConnectStatus(Strophe.Status.CONNECTING, null);

        this._requests.push(
            new Strophe.Request(body.tree(),
                                this._onRequestStateChange.bind(
                                    this, this._connect_cb.bind(this)),
                                body.tree().getAttribute("rid")));
        this._throttledRequestHandler();
    },

    /** Function: attach
     *  Attach to an already created and authenticated BOSH session.
     *
     *  This function is provided to allow Strophe to attach to BOSH
     *  sessions which have been created externally, perhaps by a Web
     *  application.  This is often used to support auto-login type features
     *  without putting user credentials into the page.
     *
     *  Parameters:
     *    (String) jid - The full JID that is bound by the session.
     *    (String) sid - The SID of the BOSH session.
     *    (String) rid - The current RID of the BOSH session.  This RID
     *      will be used by the next request.
     *    (Function) callback The connect callback function.
     *    (Integer) wait - The optional HTTPBIND wait value.  This is the
     *      time the server will wait before returning an empty result for
     *      a request.  The default setting of 60 seconds is recommended.
     *      Other settings will require tweaks to the Strophe.TIMEOUT value.
     *    (Integer) hold - The optional HTTPBIND hold value.  This is the
     *      number of connections the server will hold at one time.  This
     *      should almost always be set to 1 (the default).
     *    (Integer) wind - The optional HTTBIND window value.  This is the
     *      allowed range of request ids that are valid.  The default is 5.
     */
    attach: function (jid, sid, rid, callback, wait, hold, wind)
    {
        this.jid = jid;
        this.sid = sid;
        this.rid = rid;
        this.connect_callback = callback;

        this.domain = Strophe.getDomainFromJid(this.jid);

        this.authenticated = true;
        this.connected = true;

        this.wait = wait || this.wait;
        this.hold = hold || this.hold;
        this.window = wind || this.window;

        this._changeConnectStatus(Strophe.Status.ATTACHED, null);
    },

    /** Function: xmlInput
     *  User overrideable function that receives XML data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlInput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (XMLElement) elem - The XML data received by the connection.
     */
    xmlInput: function (elem)
    {
        return;
    },

    /** Function: xmlOutput
     *  User overrideable function that receives XML data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.xmlOutput = function (elem) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (XMLElement) elem - The XMLdata sent by the connection.
     */
    xmlOutput: function (elem)
    {
        return;
    },

    /** Function: rawInput
     *  User overrideable function that receives raw data coming into the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawInput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data received by the connection.
     */
    rawInput: function (data)
    {
        return;
    },

    /** Function: rawOutput
     *  User overrideable function that receives raw data sent to the
     *  connection.
     *
     *  The default function does nothing.  User code can override this with
     *  > Strophe.Connection.rawOutput = function (data) {
     *  >   (user code)
     *  > };
     *
     *  Parameters:
     *    (String) data - The data sent by the connection.
     */
    rawOutput: function (data)
    {
        return;
    },

    /** Function: send
     *  Send a stanza.
     *
     *  This function is called to push data onto the send queue to
     *  go out over the wire.  Whenever a request is sent to the BOSH
     *  server, all pending data is sent and the queue is flushed.
     *
     *  Parameters:
     *    (XMLElement |
     *     [XMLElement] |
     *     Strophe.Builder) elem - The stanza to send.
     */
    send: function (elem)
    {
        if (elem === null) { return ; }
        if (typeof(elem.sort) === "function") {
            for (var i = 0; i < elem.length; i++) {
                this._queueData(elem[i]);
            }
        } else if (typeof(elem.tree) === "function") {
            this._queueData(elem.tree());
        } else {
            this._queueData(elem);
        }

        this._throttledRequestHandler();
        clearTimeout(this._idleTimeout);
        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
    },

    /** Function: flush
     *  Immediately send any pending outgoing data.
     *
     *  Normally send() queues outgoing data until the next idle period
     *  (100ms), which optimizes network use in the common cases when
     *  several send()s are called in succession. flush() can be used to
     *  immediately send all pending data.
     */
    flush: function ()
    {
        // cancel the pending idle period and run the idle function
        // immediately
        clearTimeout(this._idleTimeout);
        this._onIdle();
    },

    /** Function: sendIQ
     *  Helper function to send IQ stanzas.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza to send.
     *    (Function) callback - The callback function for a successful request.
     *    (Function) errback - The callback function for a failed or timed
     *      out request.  On timeout, the stanza will be null.
     *    (Integer) timeout - The time specified in milliseconds for a
     *      timeout to occur.
     *
     *  Returns:
     *    The id used to send the IQ.
    */
    sendIQ: function(elem, callback, errback, timeout) {
        var timeoutHandler = null;
        var that = this;

        if (typeof(elem.tree) === "function") {
            elem = elem.tree();
        }
    var id = elem.getAttribute('id');

    // inject id if not found
    if (!id) {
        id = this.getUniqueId("sendIQ");
        elem.setAttribute("id", id);
    }

    var handler = this.addHandler(function (stanza) {
        // remove timeout handler if there is one
            if (timeoutHandler) {
                that.deleteTimedHandler(timeoutHandler);
            }

            var iqtype = stanza.getAttribute('type');
        if (iqtype == 'result') {
        if (callback) {
                    callback(stanza);
                }
        } else if (iqtype == 'error') {
        if (errback) {
                    errback(stanza);
                }
        } else {
                throw {
                    name: "StropheError",
                    message: "Got bad IQ type of " + iqtype
                };
            }
    }, null, 'iq', null, id);

    // if timeout specified, setup timeout handler.
    if (timeout) {
        timeoutHandler = this.addTimedHandler(timeout, function () {
                // get rid of normal handler
                that.deleteHandler(handler);

            // call errback on timeout with null stanza
                if (errback) {
            errback(null);
                }
        return false;
        });
    }

    this.send(elem);

    return id;
    },

    /** PrivateFunction: _queueData
     *  Queue outgoing data for later sending.  Also ensures that the data
     *  is a DOMElement.
     */
    _queueData: function (element) {
        if (element === null ||
            !element.tagName ||
            !element.childNodes) {
            throw {
                name: "StropheError",
                message: "Cannot queue non-DOMElement."
            };
        }

        this._data.push(element);
    },

    /** PrivateFunction: _sendRestart
     *  Send an xmpp:restart stanza.
     */
    _sendRestart: function ()
    {
        this._data.push("restart");

        this._throttledRequestHandler();
        clearTimeout(this._idleTimeout);
        this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
    },

    /** Function: addTimedHandler
     *  Add a timed handler to the connection.
     *
     *  This function adds a timed handler.  The provided handler will
     *  be called every period milliseconds until it returns false,
     *  the connection is terminated, or the handler is removed.  Handlers
     *  that wish to continue being invoked should return true.
     *
     *  Because of method binding it is necessary to save the result of
     *  this function if you wish to remove a handler with
     *  deleteTimedHandler().
     *
     *  Note that user handlers are not active until authentication is
     *  successful.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addTimedHandler: function (period, handler)
    {
        var thand = new Strophe.TimedHandler(period, handler);
        this.addTimeds.push(thand);
        return thand;
    },

    /** Function: deleteTimedHandler
     *  Delete a timed handler for a connection.
     *
     *  This function removes a timed handler from the connection.  The
     *  handRef parameter is *not* the function passed to addTimedHandler(),
     *  but is the reference returned from addTimedHandler().
     *
     *  Parameters:
     *    (Strophe.TimedHandler) handRef - The handler reference.
     */
    deleteTimedHandler: function (handRef)
    {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeTimeds.push(handRef);
    },

    /** Function: addHandler
     *  Add a stanza handler for the connection.
     *
     *  This function adds a stanza handler to the connection.  The
     *  handler callback will be called for any stanza that matches
     *  the parameters.  Note that if multiple parameters are supplied,
     *  they must all match for the handler to be invoked.
     *
     *  The handler will receive the stanza that triggered it as its argument.
     *  The handler should return true if it is to be invoked again;
     *  returning false will remove the handler after it returns.
     *
     *  As a convenience, the ns parameters applies to the top level element
     *  and also any of its immediate children.  This is primarily to make
     *  matching /iq/query elements easy.
     *
     *  The options argument contains handler matching flags that affect how
     *  matches are determined. Currently the only flag is matchBare (a
     *  boolean). When matchBare is true, the from parameter and the from
     *  attribute on the stanza will be matched as bare JIDs instead of
     *  full JIDs. To use this, pass {matchBare: true} as the value of
     *  options. The default value for matchBare is false.
     *
     *  The return value should be saved if you wish to remove the handler
     *  with deleteHandler().
     *
     *  Parameters:
     *    (Function) handler - The user callback.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String) type - The stanza type attribute to match.
     *    (String) id - The stanza id attribute to match.
     *    (String) from - The stanza from attribute to match.
     *    (String) options - The handler options
     *
     *  Returns:
     *    A reference to the handler that can be used to remove it.
     */
    addHandler: function (handler, ns, name, type, id, from, options)
    {
        var hand = new Strophe.Handler(handler, ns, name, type, id, from, options);
        this.addHandlers.push(hand);
        return hand;
    },

    /** Function: deleteHandler
     *  Delete a stanza handler for a connection.
     *
     *  This function removes a stanza handler from the connection.  The
     *  handRef parameter is *not* the function passed to addHandler(),
     *  but is the reference returned from addHandler().
     *
     *  Parameters:
     *    (Strophe.Handler) handRef - The handler reference.
     */
    deleteHandler: function (handRef)
    {
        // this must be done in the Idle loop so that we don't change
        // the handlers during iteration
        this.removeHandlers.push(handRef);
    },

    /** Function: disconnect
     *  Start the graceful disconnection process.
     *
     *  This function starts the disconnection process.  This process starts
     *  by sending unavailable presence and sending BOSH body of type
     *  terminate.  A timeout handler makes sure that disconnection happens
     *  even if the BOSH server does not respond.
     *
     *  The user supplied connection callback will be notified of the
     *  progress as this process happens.
     *
     *  Parameters:
     *    (String) reason - The reason the disconnect is occuring.
     */
    disconnect: function (reason)
    {
        this._changeConnectStatus(Strophe.Status.DISCONNECTING, reason);

        Strophe.info("Disconnect was called because: " + reason);
        if (this.connected) {
            // setup timeout handler
            this._disconnectTimeout = this._addSysTimedHandler(
                3000, this._onDisconnectTimeout.bind(this));
            this._sendTerminate();
        }
    },

    /** PrivateFunction: _changeConnectStatus
     *  _Private_ helper function that makes sure plugins and the user's
     *  callback are notified of connection status changes.
     *
     *  Parameters:
     *    (Integer) status - the new connection status, one of the values
     *      in Strophe.Status
     *    (String) condition - the error condition or null
     */
    _changeConnectStatus: function (status, condition)
    {
        // notify all plugins listening for status changes
        for (var k in Strophe._connectionPlugins) {
            if (Strophe._connectionPlugins.hasOwnProperty(k)) {
                var plugin = this[k];
                if (plugin.statusChanged) {
                    try {
                        plugin.statusChanged(status, condition);
                    } catch (err) {
                        Strophe.error("" + k + " plugin caused an exception " +
                                      "changing status: " + err);
                    }
                }
            }
        }

        // notify the user's callback
        if (this.connect_callback) {
            try {
                this.connect_callback(status, condition);
            } catch (e) {
                Strophe.error("User connection callback caused an " +
                              "exception: " + e);
            }
        }
    },

    /** PrivateFunction: _buildBody
     *  _Private_ helper function to generate the <body/> wrapper for BOSH.
     *
     *  Returns:
     *    A Strophe.Builder with a <body/> element.
     */
    _buildBody: function ()
    {
        var bodyWrap = $build('body', {
            rid: this.rid++,
            xmlns: Strophe.NS.HTTPBIND
        });

        if (this.sid !== null) {
            bodyWrap.attrs({sid: this.sid});
        }

        return bodyWrap;
    },

    /** PrivateFunction: _removeRequest
     *  _Private_ function to remove a request from the queue.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request to remove.
     */
    _removeRequest: function (req)
    {
        Strophe.debug("removing request");

        var i;
        for (i = this._requests.length - 1; i >= 0; i--) {
            if (req == this._requests[i]) {
                this._requests.splice(i, 1);
            }
        }

        // IE6 fails on setting to null, so set to empty function
        req.xhr.onreadystatechange = function () {};

        this._throttledRequestHandler();
    },

    /** PrivateFunction: _restartRequest
     *  _Private_ function to restart a request that is presumed dead.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _restartRequest: function (i)
    {
        var req = this._requests[i];
        if (req.dead === null) {
            req.dead = new Date();
        }

        this._processRequest(i);
    },

    /** PrivateFunction: _processRequest
     *  _Private_ function to process a request in the queue.
     *
     *  This function takes requests off the queue and sends them and
     *  restarts dead requests.
     *
     *  Parameters:
     *    (Integer) i - The index of the request in the queue.
     */
    _processRequest: function (i)
    {
        var req = this._requests[i];
        var reqStatus = -1;

        try {
            if (req.xhr.readyState == 4) {
                reqStatus = req.xhr.status;
            }
        } catch (e) {
            Strophe.error("caught an error in _requests[" + i +
                          "], reqStatus: " + reqStatus);
        }

        if (typeof(reqStatus) == "undefined") {
            reqStatus = -1;
        }

        // make sure we limit the number of retries
        if (req.sends > 5) {
            this._onDisconnectTimeout();
            return;
        }

        var time_elapsed = req.age();
        var primaryTimeout = (!isNaN(time_elapsed) &&
                              time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait));
        var secondaryTimeout = (req.dead !== null &&
                                req.timeDead() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait));
        var requestCompletedWithServerError = (req.xhr.readyState == 4 &&
                                               (reqStatus < 1 ||
                                                reqStatus >= 500));
        if (primaryTimeout || secondaryTimeout ||
            requestCompletedWithServerError) {
            if (secondaryTimeout) {
                Strophe.error("Request " +
                              this._requests[i].id +
                              " timed out (secondary), restarting");
            }
            req.abort = true;
            req.xhr.abort();
            // setting to null fails on IE6, so set to empty function
            req.xhr.onreadystatechange = function () {};
            this._requests[i] = new Strophe.Request(req.xmlData,
                                                    req.origFunc,
                                                    req.rid,
                                                    req.sends);
            req = this._requests[i];
        }

        if (req.xhr.readyState === 0) {
            Strophe.debug("request id " + req.id +
                          "." + req.sends + " posting");

            try {
                req.xhr.open("POST", this.service + '?' + Math.random(), true);
            } catch (e2) {
                Strophe.error("XHR open failed.");
                if (!this.connected) {
                    this._changeConnectStatus(Strophe.Status.CONNFAIL,
                                              "bad-service");
                }
                this.disconnect();
                return;
            }

            // Fires the XHR request -- may be invoked immediately
            // or on a gradually expanding retry window for reconnects
            var sendFunc = function () {
                req.date = new Date();
                req.xhr.send(req.data);
            };

            // Implement progressive backoff for reconnects --
            // First retry (send == 1) should also be instantaneous
            if (req.sends > 1) {
                // Using a cube of the retry number creates a nicely
                // expanding retry window
                var backoff = Math.min(Math.floor(Strophe.TIMEOUT * this.wait),
                                       Math.pow(req.sends, 3)) * 1000;
                setTimeout(sendFunc, backoff);
            } else {
                sendFunc();
            }

            req.sends++;

            if (this.xmlOutput !== Strophe.Connection.prototype.xmlOutput) {
                this.xmlOutput(req.xmlData);
            }
            if (this.rawOutput !== Strophe.Connection.prototype.rawOutput) {
                this.rawOutput(req.data);
            }
        } else {
            Strophe.debug("_processRequest: " +
                          (i === 0 ? "first" : "second") +
                          " request has readyState of " +
                          req.xhr.readyState);
        }
    },

    /** PrivateFunction: _throttledRequestHandler
     *  _Private_ function to throttle requests to the connection window.
     *
     *  This function makes sure we don't send requests so fast that the
     *  request ids overflow the connection window in the case that one
     *  request died.
     */
    _throttledRequestHandler: function ()
    {
        if (!this._requests) {
            Strophe.debug("_throttledRequestHandler called with " +
                          "undefined requests");
        } else {
            Strophe.debug("_throttledRequestHandler called with " +
                          this._requests.length + " requests");
        }

        if (!this._requests || this._requests.length === 0) {
            return;
        }

        if (this._requests.length > 0) {
            this._processRequest(0);
        }

        if (this._requests.length > 1 &&
            Math.abs(this._requests[0].rid -
                     this._requests[1].rid) < this.window) {
            this._processRequest(1);
        }
    },

    /** PrivateFunction: _onRequestStateChange
     *  _Private_ handler for Strophe.Request state changes.
     *
     *  This function is called when the XMLHttpRequest readyState changes.
     *  It contains a lot of error handling logic for the many ways that
     *  requests can fail, and calls the request callback when requests
     *  succeed.
     *
     *  Parameters:
     *    (Function) func - The handler for the request.
     *    (Strophe.Request) req - The request that is changing readyState.
     */
    _onRequestStateChange: function (func, req)
    {
        Strophe.debug("request id " + req.id +
                      "." + req.sends + " state changed to " +
                      req.xhr.readyState);

        if (req.abort) {
            req.abort = false;
            return;
        }

        // request complete
        var reqStatus;
        if (req.xhr.readyState == 4) {
            reqStatus = 0;
            try {
                reqStatus = req.xhr.status;
            } catch (e) {
                // ignore errors from undefined status attribute.  works
                // around a browser bug
            }

            if (typeof(reqStatus) == "undefined") {
                reqStatus = 0;
            }

            if (this.disconnecting) {
                if (reqStatus >= 400) {
                    this._hitError(reqStatus);
                    return;
                }
            }

            var reqIs0 = (this._requests[0] == req);
            var reqIs1 = (this._requests[1] == req);

            if ((reqStatus > 0 && reqStatus < 500) || req.sends > 5) {
                // remove from internal queue
                this._removeRequest(req);
                Strophe.debug("request id " +
                              req.id +
                              " should now be removed");
            }

            // request succeeded
            if (reqStatus == 200) {
                // if request 1 finished, or request 0 finished and request
                // 1 is over Strophe.SECONDARY_TIMEOUT seconds old, we need to
                // restart the other - both will be in the first spot, as the
                // completed request has been removed from the queue already
                if (reqIs1 ||
                    (reqIs0 && this._requests.length > 0 &&
                     this._requests[0].age() > Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait))) {
                    this._restartRequest(0);
                }
                // call handler
                Strophe.debug("request id " +
                              req.id + "." +
                              req.sends + " got 200");
                func(req);
                this.errors = 0;
            } else {
                Strophe.error("request id " +
                              req.id + "." +
                              req.sends + " error " + reqStatus +
                              " happened");
                if (reqStatus === 0 ||
                    (reqStatus >= 400 && reqStatus < 600) ||
                    reqStatus >= 12000) {
                    this._hitError(reqStatus);
                    if (reqStatus >= 400 && reqStatus < 500) {
                        this._changeConnectStatus(Strophe.Status.DISCONNECTING,
                                                  null);
                        this._doDisconnect();
                    }
                }
            }

            if (!((reqStatus > 0 && reqStatus < 500) ||
                  req.sends > 5)) {
                this._throttledRequestHandler();
            }
        }
    },

    /** PrivateFunction: _hitError
     *  _Private_ function to handle the error count.
     *
     *  Requests are resent automatically until their error count reaches
     *  5.  Each time an error is encountered, this function is called to
     *  increment the count and disconnect if the count is too high.
     *
     *  Parameters:
     *    (Integer) reqStatus - The request status.
     */
    _hitError: function (reqStatus)
    {
        this.errors++;
        Strophe.warn("request errored, status: " + reqStatus +
                     ", number of errors: " + this.errors);
        if (this.errors > 4) {
            this._onDisconnectTimeout();
        }
    },

    /** PrivateFunction: _doDisconnect
     *  _Private_ function to disconnect.
     *
     *  This is the last piece of the disconnection logic.  This resets the
     *  connection and alerts the user's connection callback.
     */
    _doDisconnect: function ()
    {
        Strophe.info("_doDisconnect was called");
        this.authenticated = false;
        this.disconnecting = false;
        this.sid = null;
        this.streamId = null;
        this.rid = Math.floor(Math.random() * 4294967295);

        // tell the parent we disconnected
        if (this.connected) {
            this._changeConnectStatus(Strophe.Status.DISCONNECTED, null);
            this.connected = false;
        }

        // delete handlers
        this.handlers = [];
        this.timedHandlers = [];
        this.removeTimeds = [];
        this.removeHandlers = [];
        this.addTimeds = [];
        this.addHandlers = [];
    },

    /** PrivateFunction: _dataRecv
     *  _Private_ handler to processes incoming data from the the connection.
     *
     *  Except for _connect_cb handling the initial connection request,
     *  this function handles the incoming data for all requests.  This
     *  function also fires stanza handlers that match each incoming
     *  stanza.
     *
     *  Parameters:
     *    (Strophe.Request) req - The request that has data ready.
     */
    _dataRecv: function (req)
    {
        try {
            var elem = req.getResponse();
        } catch (e) {
            if (e != "parsererror") { throw e; }
            this.disconnect("strophe-parsererror");
        }
        if (elem === null) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            this.xmlInput(elem);
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            this.rawInput(Strophe.serialize(elem));
        }

        // remove handlers scheduled for deletion
        var i, hand;
        while (this.removeHandlers.length > 0) {
            hand = this.removeHandlers.pop();
            i = this.handlers.indexOf(hand);
            if (i >= 0) {
                this.handlers.splice(i, 1);
            }
        }

        // add handlers scheduled for addition
        while (this.addHandlers.length > 0) {
            this.handlers.push(this.addHandlers.pop());
        }

        // handle graceful disconnect
        if (this.disconnecting && this._requests.length === 0) {
            this.deleteTimedHandler(this._disconnectTimeout);
            this._disconnectTimeout = null;
            this._doDisconnect();
            return;
        }

        var typ = elem.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // Don't process stanzas that come in after disconnect
            if (this.disconnecting) {
                return;
            }

            // an error occurred
            cond = elem.getAttribute("condition");
            conflict = elem.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            this.disconnect();
            return;
        }

        // send each incoming stanza through the handler chain
        var that = this;
        Strophe.forEachChild(elem, null, function (child) {
            var i, newList;
            // process handlers
            newList = that.handlers;
            that.handlers = [];
            for (i = 0; i < newList.length; i++) {
                var hand = newList[i];
                // encapsulate 'handler.run' not to lose the whole handler list if
                // one of the handlers throws an exception
                try {
                    if (hand.isMatch(child) &&
                        (that.authenticated || !hand.user)) {
                        if (hand.run(child)) {
                            that.handlers.push(hand);
                        }
                    } else {
                        that.handlers.push(hand);
                    }
                } catch(e) {
                    //if the handler throws an exception, we consider it as false
                }
            }
        });
    },

    /** PrivateFunction: _sendTerminate
     *  _Private_ function to send initial disconnect sequence.
     *
     *  This is the first step in a graceful disconnect.  It sends
     *  the BOSH server a terminate body and includes an unavailable
     *  presence if authentication has completed.
     */
    _sendTerminate: function ()
    {
        Strophe.info("_sendTerminate was called");
        var body = this._buildBody().attrs({type: "terminate"});

        if (this.authenticated) {
            body.c('presence', {
                xmlns: Strophe.NS.CLIENT,
                type: 'unavailable'
            });
        }

        this.disconnecting = true;

        var req = new Strophe.Request(body.tree(),
                                      this._onRequestStateChange.bind(
                                          this, this._dataRecv.bind(this)),
                                      body.tree().getAttribute("rid"));

        this._requests.push(req);
        this._throttledRequestHandler();
    },

    /** PrivateFunction: _connect_cb
     *  _Private_ handler for initial connection request.
     *
     *  This handler is used to process the initial connection request
     *  response from the BOSH server. It is used to set up authentication
     *  handlers and start the authentication process.
     *
     *  SASL authentication will be attempted if available, otherwise
     *  the code will fall back to legacy authentication.
     *
     *  Parameters:
     *    (Strophe.Request) req - The current request.
     */
    _connect_cb: function (req)
    {
        Strophe.info("_connect_cb was called");

        this.connected = true;
        var bodyWrap = req.getResponse();
        if (!bodyWrap) { return; }

        if (this.xmlInput !== Strophe.Connection.prototype.xmlInput) {
            this.xmlInput(bodyWrap);
        }
        if (this.rawInput !== Strophe.Connection.prototype.rawInput) {
            this.rawInput(Strophe.serialize(bodyWrap));
        }

        var typ = bodyWrap.getAttribute("type");
        var cond, conflict;
        if (typ !== null && typ == "terminate") {
            // an error occurred
            cond = bodyWrap.getAttribute("condition");
            conflict = bodyWrap.getElementsByTagName("conflict");
            if (cond !== null) {
                if (cond == "remote-stream-error" && conflict.length > 0) {
                    cond = "conflict";
                }
                this._changeConnectStatus(Strophe.Status.CONNFAIL, cond);
            } else {
                this._changeConnectStatus(Strophe.Status.CONNFAIL, "unknown");
            }
            return;
        }

        // check to make sure we don't overwrite these if _connect_cb is
        // called multiple times in the case of missing stream:features
        if (!this.sid) {
            this.sid = bodyWrap.getAttribute("sid");
        }
        if (!this.stream_id) {
            this.stream_id = bodyWrap.getAttribute("authid");
        }
        var wind = bodyWrap.getAttribute('requests');
        if (wind) { this.window = parseInt(wind, 10); }
        var hold = bodyWrap.getAttribute('hold');
        if (hold) { this.hold = parseInt(hold, 10); }
        var wait = bodyWrap.getAttribute('wait');
        if (wait) { this.wait = parseInt(wait, 10); }


        var do_sasl_plain = false;
        var do_sasl_digest_md5 = false;
        var do_sasl_anonymous = false;

        var mechanisms = bodyWrap.getElementsByTagName("mechanism");
        var i, mech, auth_str, hashed_auth_str;
        if (mechanisms.length > 0) {
            for (i = 0; i < mechanisms.length; i++) {
                mech = Strophe.getText(mechanisms[i]);
                if (mech == 'DIGEST-MD5') {
                    do_sasl_digest_md5 = true;
                } else if (mech == 'PLAIN') {
                    do_sasl_plain = true;
                } else if (mech == 'ANONYMOUS') {
                    do_sasl_anonymous = true;
                }
            }
        } else {
            // we didn't get stream:features yet, so we need wait for it
            // by sending a blank poll request
            var body = this._buildBody();
            this._requests.push(
                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, this._connect_cb.bind(this)),
                                    body.tree().getAttribute("rid")));
            this._throttledRequestHandler();
            return;
        }

        if (Strophe.getNodeFromJid(this.jid) === null &&
            do_sasl_anonymous) {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_success_handler = this._addSysHandler(
                this._sasl_success_cb.bind(this), null,
                "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "ANONYMOUS"
            }).tree());
        } else if (Strophe.getNodeFromJid(this.jid) === null) {
            // we don't have a node, which is required for non-anonymous
            // client connections
            this._changeConnectStatus(Strophe.Status.CONNFAIL,
                                      'x-strophe-bad-non-anon-jid');
            this.disconnect();
        } else if (do_sasl_digest_md5) {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_challenge_handler = this._addSysHandler(
                this._sasl_challenge1_cb.bind(this), null,
                "challenge", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "DIGEST-MD5"
            }).tree());
        } else if (do_sasl_plain) {
            // Build the plain auth string (barejid null
            // username null password) and base 64 encoded.
            auth_str = Strophe.getBareJidFromJid(this.jid);
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + Strophe.getNodeFromJid(this.jid);
            auth_str = auth_str + "\u0000";
            auth_str = auth_str + this.pass;

            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._sasl_success_handler = this._addSysHandler(
                this._sasl_success_cb.bind(this), null,
                "success", null, null);
            this._sasl_failure_handler = this._addSysHandler(
                this._sasl_failure_cb.bind(this), null,
                "failure", null, null);

            hashed_auth_str = Base64.encode(auth_str);
            this.send($build("auth", {
                xmlns: Strophe.NS.SASL,
                mechanism: "PLAIN"
            }).t(hashed_auth_str).tree());
        } else {
            this._changeConnectStatus(Strophe.Status.AUTHENTICATING, null);
            this._addSysHandler(this._auth1_cb.bind(this), null, null,
                                null, "_auth_1");

            this.send($iq({
                type: "get",
                to: this.domain,
                id: "_auth_1"
            }).c("query", {
                xmlns: Strophe.NS.AUTH
            }).c("username", {}).t(Strophe.getNodeFromJid(this.jid)).tree());
        }
    },

    /** PrivateFunction: _sasl_challenge1_cb
     *  _Private_ handler for DIGEST-MD5 SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The challenge stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_challenge1_cb: function (elem)
    {
        var attribMatch = /([a-z]+)=("[^"]+"|[^,"]+)(?:,|$)/;

        var challenge = Base64.decode(Strophe.getText(elem));
        var cnonce = stropheMD5.hexdigest("" + (Math.random() * 1234567890));
        var realm = "";
        var host = null;
        var nonce = "";
        var qop = "";
        var matches;

        // remove unneeded handlers
        this.deleteHandler(this._sasl_failure_handler);

        while (challenge.match(attribMatch)) {
            matches = challenge.match(attribMatch);
            challenge = challenge.replace(matches[0], "");
            matches[2] = matches[2].replace(/^"(.+)"$/, "$1");
            switch (matches[1]) {
            case "realm":
                realm = matches[2];
                break;
            case "nonce":
                nonce = matches[2];
                break;
            case "qop":
                qop = matches[2];
                break;
            case "host":
                host = matches[2];
                break;
            }
        }

        var digest_uri = "xmpp/" + this.domain;
        if (host !== null) {
            digest_uri = digest_uri + "/" + host;
        }

        var A1 = stropheMD5.hash(Strophe.getNodeFromJid(this.jid) +
                          ":" + realm + ":" + this.pass) +
            ":" + nonce + ":" + cnonce;
        var A2 = 'AUTHENTICATE:' + digest_uri;

        var responseText = "";
        responseText += 'username=' +
            this._quote(Strophe.getNodeFromJid(this.jid)) + ',';
        responseText += 'realm=' + this._quote(realm) + ',';
        responseText += 'nonce=' + this._quote(nonce) + ',';
        responseText += 'cnonce=' + this._quote(cnonce) + ',';
        responseText += 'nc="00000001",';
        responseText += 'qop="auth",';
        responseText += 'digest-uri=' + this._quote(digest_uri) + ',';
        responseText += 'response=' + this._quote(
            stropheMD5.hexdigest(stropheMD5.hexdigest(A1) + ":" +
                          nonce + ":00000001:" +
                          cnonce + ":auth:" +
                          stropheMD5.hexdigest(A2))) + ',';
        responseText += 'charset="utf-8"';

        this._sasl_challenge_handler = this._addSysHandler(
            this._sasl_challenge2_cb.bind(this), null,
            "challenge", null, null);
        this._sasl_success_handler = this._addSysHandler(
            this._sasl_success_cb.bind(this), null,
            "success", null, null);
        this._sasl_failure_handler = this._addSysHandler(
            this._sasl_failure_cb.bind(this), null,
            "failure", null, null);

        this.send($build('response', {
            xmlns: Strophe.NS.SASL
        }).t(Base64.encode(responseText)).tree());

        return false;
    },

    /** PrivateFunction: _quote
     *  _Private_ utility function to backslash escape and quote strings.
     *
     *  Parameters:
     *    (String) str - The string to be quoted.
     *
     *  Returns:
     *    quoted string
     */
    _quote: function (str)
    {
        return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"') + '"';
        //" end string workaround for emacs
    },


    /** PrivateFunction: _sasl_challenge2_cb
     *  _Private_ handler for second step of DIGEST-MD5 SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The challenge stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_challenge2_cb: function (elem)
    {
        // remove unneeded handlers
        this.deleteHandler(this._sasl_success_handler);
        this.deleteHandler(this._sasl_failure_handler);

        this._sasl_success_handler = this._addSysHandler(
            this._sasl_success_cb.bind(this), null,
            "success", null, null);
        this._sasl_failure_handler = this._addSysHandler(
            this._sasl_failure_cb.bind(this), null,
            "failure", null, null);
        this.send($build('response', {xmlns: Strophe.NS.SASL}).tree());
        return false;
    },

    /** PrivateFunction: _auth1_cb
     *  _Private_ handler for legacy authentication.
     *
     *  This handler is called in response to the initial <iq type='get'/>
     *  for legacy authentication.  It builds an authentication <iq/> and
     *  sends it, creating a handler (calling back to _auth2_cb()) to
     *  handle the result
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _auth1_cb: function (elem)
    {
        // build plaintext auth iq
        var iq = $iq({type: "set", id: "_auth_2"})
            .c('query', {xmlns: Strophe.NS.AUTH})
            .c('username', {}).t(Strophe.getNodeFromJid(this.jid))
            .up()
            .c('password').t(this.pass);

        if (!Strophe.getResourceFromJid(this.jid)) {
            // since the user has not supplied a resource, we pick
            // a default one here.  unlike other auth methods, the server
            // cannot do this for us.
            this.jid = Strophe.getBareJidFromJid(this.jid) + '/strophe';
        }
        iq.up().c('resource', {}).t(Strophe.getResourceFromJid(this.jid));

        this._addSysHandler(this._auth2_cb.bind(this), null,
                            null, null, "_auth_2");

        this.send(iq.tree());

        return false;
    },

    /** PrivateFunction: _sasl_success_cb
     *  _Private_ handler for succesful SASL authentication.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_success_cb: function (elem)
    {
        Strophe.info("SASL authentication succeeded.");

        // remove old handlers
        this.deleteHandler(this._sasl_failure_handler);
        this._sasl_failure_handler = null;
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        this._addSysHandler(this._sasl_auth1_cb.bind(this), null,
                            "stream:features", null, null);

        // we must send an xmpp:restart now
        this._sendRestart();

        return false;
    },

    /** PrivateFunction: _sasl_auth1_cb
     *  _Private_ handler to start stream binding.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_auth1_cb: function (elem)
    {
        // save stream:features for future usage
        this.features = elem;

        var i, child;

        for (i = 0; i < elem.childNodes.length; i++) {
            child = elem.childNodes[i];
            if (child.nodeName == 'bind') {
                this.do_bind = true;
            }

            if (child.nodeName == 'session') {
                this.do_session = true;
            }
        }

        if (!this.do_bind) {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        } else {
            this._addSysHandler(this._sasl_bind_cb.bind(this), null, null,
                                null, "_bind_auth_2");

            var resource = Strophe.getResourceFromJid(this.jid);
            if (resource) {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .c('resource', {}).t(resource).tree());
            } else {
                this.send($iq({type: "set", id: "_bind_auth_2"})
                          .c('bind', {xmlns: Strophe.NS.BIND})
                          .tree());
            }
        }

        return false;
    },

    /** PrivateFunction: _sasl_bind_cb
     *  _Private_ handler for binding result and session start.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_bind_cb: function (elem)
    {
        if (elem.getAttribute("type") == "error") {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }

        // TODO - need to grab errors
        var bind = elem.getElementsByTagName("bind");
        var jidNode;
        if (bind.length > 0) {
            // Grab jid
            jidNode = bind[0].getElementsByTagName("jid");
            if (jidNode.length > 0) {
                this.jid = Strophe.getText(jidNode[0]);

                if (this.do_session) {
                    this._addSysHandler(this._sasl_session_cb.bind(this),
                                        null, null, null, "_session_auth_2");

                    this.send($iq({type: "set", id: "_session_auth_2"})
                                  .c('session', {xmlns: Strophe.NS.SESSION})
                                  .tree());
                } else {
                    this.authenticated = true;
                    this._changeConnectStatus(Strophe.Status.CONNECTED, null);
                }
            }
        } else {
            Strophe.info("SASL binding failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }
    },

    /** PrivateFunction: _sasl_session_cb
     *  _Private_ handler to finish successful SASL connection.
     *
     *  This sets Connection.authenticated to true on success, which
     *  starts the processing of user handlers.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_session_cb: function (elem)
    {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            Strophe.info("Session creation failed.");
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            return false;
        }

        return false;
    },

    /** PrivateFunction: _sasl_failure_cb
     *  _Private_ handler for SASL authentication failure.
     *
     *  Parameters:
     *    (XMLElement) elem - The matching stanza.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _sasl_failure_cb: function (elem)
    {
        // delete unneeded handlers
        if (this._sasl_success_handler) {
            this.deleteHandler(this._sasl_success_handler);
            this._sasl_success_handler = null;
        }
        if (this._sasl_challenge_handler) {
            this.deleteHandler(this._sasl_challenge_handler);
            this._sasl_challenge_handler = null;
        }

        this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
        return false;
    },

    /** PrivateFunction: _auth2_cb
     *  _Private_ handler to finish legacy authentication.
     *
     *  This handler is called when the result from the jabber:iq:auth
     *  <iq/> stanza is returned.
     *
     *  Parameters:
     *    (XMLElement) elem - The stanza that triggered the callback.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _auth2_cb: function (elem)
    {
        if (elem.getAttribute("type") == "result") {
            this.authenticated = true;
            this._changeConnectStatus(Strophe.Status.CONNECTED, null);
        } else if (elem.getAttribute("type") == "error") {
            this._changeConnectStatus(Strophe.Status.AUTHFAIL, null);
            this.disconnect();
        }

        return false;
    },

    /** PrivateFunction: _addSysTimedHandler
     *  _Private_ function to add a system level timed handler.
     *
     *  This function is used to add a Strophe.TimedHandler for the
     *  library code.  System timed handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Integer) period - The period of the handler.
     *    (Function) handler - The callback function.
     */
    _addSysTimedHandler: function (period, handler)
    {
        var thand = new Strophe.TimedHandler(period, handler);
        thand.user = false;
        this.addTimeds.push(thand);
        return thand;
    },

    /** PrivateFunction: _addSysHandler
     *  _Private_ function to add a system level stanza handler.
     *
     *  This function is used to add a Strophe.Handler for the
     *  library code.  System stanza handlers are allowed to run before
     *  authentication is complete.
     *
     *  Parameters:
     *    (Function) handler - The callback function.
     *    (String) ns - The namespace to match.
     *    (String) name - The stanza name to match.
     *    (String) type - The stanza type attribute to match.
     *    (String) id - The stanza id attribute to match.
     */
    _addSysHandler: function (handler, ns, name, type, id)
    {
        var hand = new Strophe.Handler(handler, ns, name, type, id);
        hand.user = false;
        this.addHandlers.push(hand);
        return hand;
    },

    /** PrivateFunction: _onDisconnectTimeout
     *  _Private_ timeout handler for handling non-graceful disconnection.
     *
     *  If the graceful disconnect process does not complete within the
     *  time allotted, this handler finishes the disconnect anyway.
     *
     *  Returns:
     *    false to remove the handler.
     */
    _onDisconnectTimeout: function ()
    {
        Strophe.info("_onDisconnectTimeout was called");

        // cancel all remaining requests and clear the queue
        var req;
        while (this._requests.length > 0) {
            req = this._requests.pop();
            req.abort = true;
            req.xhr.abort();
            // jslint complains, but this is fine. setting to empty func
            // is necessary for IE6
            req.xhr.onreadystatechange = function () {};
        }

        // actually disconnect
        this._doDisconnect();

        return false;
    },

    /** PrivateFunction: _onIdle
     *  _Private_ handler to process events during idle cycle.
     *
     *  This handler is called every 100ms to fire timed handlers that
     *  are ready and keep poll requests going.
     */
    _onIdle: function ()
    {
        var i, thand, since, newList;

        // add timed handlers scheduled for addition
        // NOTE: we add before remove in the case a timed handler is
        // added and then deleted before the next _onIdle() call.
        while (this.addTimeds.length > 0) {
            this.timedHandlers.push(this.addTimeds.pop());
        }

        // remove timed handlers that have been scheduled for deletion
        while (this.removeTimeds.length > 0) {
            thand = this.removeTimeds.pop();
            i = this.timedHandlers.indexOf(thand);
            if (i >= 0) {
                this.timedHandlers.splice(i, 1);
            }
        }

        // call ready timed handlers
        var now = new Date().getTime();
        newList = [];
        for (i = 0; i < this.timedHandlers.length; i++) {
            thand = this.timedHandlers[i];
            if (this.authenticated || !thand.user) {
                since = thand.lastCalled + thand.period;
                if (since - now <= 0) {
                    if (thand.run()) {
                        newList.push(thand);
                    }
                } else {
                    newList.push(thand);
                }
            }
        }
        this.timedHandlers = newList;

        var body, time_elapsed;

        // if no requests are in progress, poll
        if (this.authenticated && this._requests.length === 0 &&
            this._data.length === 0 && !this.disconnecting) {
            Strophe.info("no requests during idle cycle, sending " +
                         "blank request");
            this._data.push(null);
        }

        if (this._requests.length < 2 && this._data.length > 0 &&
            !this.paused) {
            body = this._buildBody();
            for (i = 0; i < this._data.length; i++) {
                if (this._data[i] !== null) {
                    if (this._data[i] === "restart") {
                        body.attrs({
                            to: this.domain,
                            "xml:lang": "en",
                            "xmpp:restart": "true",
                            "xmlns:xmpp": Strophe.NS.BOSH
                        });
                    } else {
                        body.cnode(this._data[i]).up();
                    }
                }
            }
            delete this._data;
            this._data = [];
            this._requests.push(
                new Strophe.Request(body.tree(),
                                    this._onRequestStateChange.bind(
                                        this, this._dataRecv.bind(this)),
                                    body.tree().getAttribute("rid")));
            this._processRequest(this._requests.length - 1);
        }

        if (this._requests.length > 0) {
            time_elapsed = this._requests[0].age();
            if (this._requests[0].dead !== null) {
                if (this._requests[0].timeDead() >
                    Math.floor(Strophe.SECONDARY_TIMEOUT * this.wait)) {
                    this._throttledRequestHandler();
                }
            }

            if (time_elapsed > Math.floor(Strophe.TIMEOUT * this.wait)) {
                Strophe.warn("Request " +
                             this._requests[0].id +
                             " timed out, over " + Math.floor(Strophe.TIMEOUT * this.wait) +
                             " seconds since last activity");
                this._throttledRequestHandler();
            }
        }

        clearTimeout(this._idleTimeout);

        // reactivate the timer only if connected
        if (this.connected) {
            this._idleTimeout = setTimeout(this._onIdle.bind(this), 100);
        }
    }
};

if (callback) {
    callback(Strophe, $build, $msg, $iq, $pres);
}

})(function () {
    window.Strophe = arguments[0];
    window.$build = arguments[1];
    window.$msg = arguments[2];
    window.$iq = arguments[3];
    window.$pres = arguments[4];
});
/**
*
*  UTF-8 data encode / decode
*  http://www.webtoolkit.info/
*
**/
 
var Utf8 = {
 
    // public method for url encoding
    encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
 
        for (var n = 0; n < string.length; n++) {
 
            var c = string.charCodeAt(n);
 
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
 
        }
 
        return utftext;
    },
 
    // public method for url decoding
    decode : function (utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;
 
        while ( i < utftext.length ) {
 
            c = utftext.charCodeAt(i);
 
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
 
        }
 
        return string;
    }
 
}
if (typeof( XMPPChat ) == 'undefined') {
    XMPPChat = {};
}

//   XMPP
XMPPChat.XMPP_MT_PRIVATE = 'chat';
XMPPChat.XMPP_MT_ROOM    = 'groupchat';
XMPPChat.XMPP_MT_ERROR   = 'error';

//    
XMPPChat.MT_PRIVATE = 'private';
XMPPChat.MT_ROOM    = 'room';
XMPPChat.MT_ERROR   = 'error';
XMPPChat.MT_COMMAND = 'commands';

//   XMPP
XMPPChat.PT_UNAVAILABLE = 'unavailable';
XMPPChat.PT_ERROR       = 'error';

//    Connection
XMPPChat.BOSH_SERVICE        = '/chb/';
XMPPChat.XMPP_HOST           = 'localhost';
XMPPChat.XMPP_RESOURCE       = 'Game';
XMPPChat.XMPP_FORUM_RESOURCE = 'Forum';
XMPPChat.XMPP_MUC            = 'rooms.localhost';
XMPPChat.XMPP_MULTI_PRIVATE  = '#multi_private@localhost';
if (typeof(XMPPChat) == 'undefined') {
    XMPPChat = {};
}


/*******************************************************************************
 *    Connection    ejabberd.
 *
 *  Parameters:
 *    (String) realName -    .
 *    (String) password -     ejabberd.
 *    (String) resource -   .
 *    (Object) handlers - .
 *      (Function) handlers.onStatusChange -   
 *      (Function) handlers.onConnect -   "connected" 
 *      (Function) handlers.onDisconnect -   "disconnected" 
 *      (Function) handlers.onPresence -   "presence".
 *      (Function) handlers.onMessage -   "message".
 *      (Function) handlers.onQuery -   "iq".
 *
 *    :
 *    onStatusChange - (Integer) status
 *    onConnect - none
 *    onDisconnect - none
 *    onPresence - . _onPresence
 *    onMessage - . _onMessage
 *    onQuery - . _onQuery
 *
 *  Returns:
 *    Connection object.
 */
XMPPChat.Connection = function(realName, password, resource, handlers) {
    this._realName = realName;
    this._password = password;

    this._username = this.getChatUsername(this._realName);
    this._jid = this._getJIDFromRealName(this._realName, resource);
    this._isLog = false;

    Strophe.log = (function(level, message) {
        if (level == Strophe.LogLevel.WARN ||
            level == Strophe.LogLevel.ERROR ||
            level == Strophe.LogLevel.FATAL
           ) {
            this._log(message);
        }

    }).bind(this);

    this._storeHandlers(handlers);
    this._connection = new Strophe.Connection(XMPPChat.BOSH_SERVICE);
}


/*******************************************************************************
 *   .
 *   ,       ejabberd.
 */
XMPPChat.Connection.prototype.sendPresence = function() {
    var oPresence = $pres();
    this._connection.send(oPresence.tree());
}


/*******************************************************************************
 *     .
 *
 *  Parameters:
 *    (String) to -    ejabberd.
 */
XMPPChat.Connection.prototype.sendRoomPresence = function(to) {
    var toJID = this._getJIDFromRoomId(to);
    var oPresence = $pres({to : toJID + '/' + this._username});
    this._connection.send(oPresence.tree());
}


/*******************************************************************************
 *    'unavailable'  .
 *
 *  Parameters:
 *    (String) to -    ejabberd.
 */
XMPPChat.Connection.prototype.sendRoomPresenceUnavailable = function(to) {
    var toJID = this._getJIDFromRoomId(to);
    var oPresence = $pres({to : toJID, type : 'unavailable'});
    this._connection.send(oPresence.tree());
}


/*******************************************************************************
 *    .
 *
 *  Parameters:
 *    (String) to -    .
 *    (String) message - .
 *    (Object)    "x".
 */
XMPPChat.Connection.prototype.sendPrivateMessage = function(to, message, attrs) {
    var toJID = this._getJIDFromRealName(to);
    var xAttrs = this._addAttributes(attrs, {to_realuser : to});

    var oMessage = $msg({
        to : toJID,
        type : XMPPChat.XMPP_MT_PRIVATE
    }).c('x', xAttrs).up().c('body').t(message);

    this._connection.send(oMessage.tree());
}


/*******************************************************************************
 *      .
 *
 *  Parameters:
 *    (String) to -    .
 *    (String) message - .
 *    (Object)    "x".
 */
XMPPChat.Connection.prototype.sendMultiPrivateMessage = function(to, message, attrs) {
    var xAttrs = this._addAttributes(
        attrs, {to_realuser : to, to_users : this.getChatUsername(to)}
    );

    var oMessage = $msg({
        to : XMPPChat.XMPP_MULTI_PRIVATE,
        type : XMPPChat.XMPP_MT_PRIVATE
    }).c('x', xAttrs).up().c('body').t(message);

    this._connection.send(oMessage.tree());
}


/*******************************************************************************
 *    .
 *
 *  Parameters:
 *    (String) to -    ejabberd.
 *    (String) message - .
 *    (Object)    "x".
 */
XMPPChat.Connection.prototype.sendRoomMessage = function(to, message, attrs) {
    var toJID = this._getJIDFromRoomId(to);
    var xAttrs = attrs;

    var oMessage = $msg({
        to : toJID,
        type : XMPPChat.XMPP_MT_ROOM
    }).c('x', xAttrs).up().c('body').t(message);

    this._connection.send(oMessage.tree());
}


/*******************************************************************************
 *      ejabberd.
 *
 *  Parameters:
 *    (String) realName -    .
 *
 *  Returns:
 *       ejabberd.
 */
XMPPChat.Connection.prototype.getChatUsername = function(realName) {
    realName = '' + realName;
    var reg = new RegExp(/^[,\_\s\-A-Za-z\d]+$/);

    if (! reg.test(realName)) {
        return '';
    }

    realName = realName.replace(/\s/g, '_');
    realName = realName.toLowerCase();

    return realName;
}


/*******************************************************************************
 *       (  ).
 *
 *  Parameters:
 *    (String) username -    ejabberd.
 *
 *  Returns:
 *         .
 */
XMPPChat.Connection.prototype.getRealName = function(username) {
    if (! username) {
        return '';
    }

    username = username.replace(/_/g, ' ');

    return username;
}


/*******************************************************************************
 *  / .
 *
 *  Parameters:
 *    (Boolean) state - true  , false  .
 */
XMPPChat.Connection.prototype.setLogging = function(state) {
    this._isLog = state ? true : false;
}


/*******************************************************************************
 *    .
 */
XMPPChat.Connection.prototype.connect = function() {
    this._connection.connect(
        Utf8.encode(this._jid),
        this._password,
        this._onConnect.bind(this)
    );
}


/*******************************************************************************
 *    .
 */
XMPPChat.Connection.prototype.disconnect = function() {
    this._connection.disconnect();
}


/*******************************************************************************
 *   .
 *      ejabberd.
 *
 *  Parameters:
 *    (Integer) status -   .
 *
 *   :
 *  0 - Strophe.Status.ERROR
 *  1 - Strophe.Status.CONNECTING
 *  2 - Strophe.Status.CONNFAIL
 *  3 - Strophe.Status.AUTHENTICATING
 *  4 - Strophe.Status.AUTHFAIL
 *  5 - Strophe.Status.CONNECTED
 *  6 - Strophe.Status.DISCONNECTED
 *  7 - Strophe.Status.DISCONNECTING
 */
XMPPChat.Connection.prototype._onConnect = function(status) {
    if (status == Strophe.Status.ERROR) {
        this._log(status + ': Error from Strophe.');
    } else if (status == Strophe.Status.CONNECTING) {
        this._log(status + ': Strophe is connecting.');
    } else if (status == Strophe.Status.CONNFAIL) {
        this._log(status + ': Strophe connection failed.');
    } else if (status == Strophe.Status.AUTHENTICATING) {
        this._log(status + ': Strophe is authenticating.');
    } else if (status == Strophe.Status.AUTHFAIL) {
        this._log(status + ': Strophe authentication failed.');
    } else if (status == Strophe.Status.CONNECTED) {
        this._log(status + ': Strophe is connected.');

        this._connection.addHandler(
            this._onPresence.bind(this), null, 'presence', null, null, null
        );

        this._connection.addHandler(
            this._onMessage.bind(this), null, 'message', null, null, null
        );

        this._connection.addHandler(
            this._onQuery.bind(this), null, 'iq', null, null, null
        );

        if (this._onConnectHandler) {
            this._onConnectHandler();
        }

    } else if (status == Strophe.Status.DISCONNECTED) {
        this._log(status + ': Strophe is disconnected.');

        if (this._onDisconnectHandler) {
            this._onDisconnectHandler();
        }
    } else if (status == Strophe.Status.DISCONNECTING) {
        this._log(status + ': Strophe is disconnecting.');
    }

    if (this._onChangeStatusHandler) {
        this._onChangeStatusHandler(status);
    }
}


/*******************************************************************************
 *   .
 *    "presence"    .
 *
 *    :
 *    (Object) data - . _parsePresence
 *    (XMLElement) presence - 
 *
 *  Parameters:
 *    (XMLElement) presence - .
 */
XMPPChat.Connection.prototype._onPresence = function(presence) {
    if (! this._onPresenceHandler) {
        return true;
    }

    var data = this._parsePresence(presence);

    if (data.fromJID) {
        this._onPresenceHandler(data, presence);
    }

    return true;
}


/*******************************************************************************
 *   .
 *    "message"    .
 *
 *    :
 *    (Object) data - . _parseMessage
 *    (XMLElement) message - 
 *
 *  Parameters:
 *    (XMLElement) message - .
 */
XMPPChat.Connection.prototype._onMessage = function(message) {
    if (! this._onMessageHandler) {
        return true;
    }

    var data = this._parseMessage(message);

    if (data.fromJID) {
        try {
            this._onMessageHandler(data, message);
        } catch (e) {
            this._log(e);
        }
    }

    return true;
}


/*******************************************************************************
 *   .
 *    "iq"    .
 *
 *  Parameters:
 *    (XMLElement) iq - .
 */
XMPPChat.Connection.prototype._onQuery = function(iq) {
    if (! this._onQueryHandler) {
        return true;
    }

    var data = this._parseQuery(iq);
    this._onQueryHandler(data, iq);

    return true;
}


/*******************************************************************************
 *   .
 *   JID   ejabberd.
 *
 *  Parameters:
 *    (String) realName -    .
 *
 *  Returns:
 *    JID   ejabberd.
 */
XMPPChat.Connection.prototype._getJIDFromRealName = function(realName, resource) {
    if (! resource) {
        resource = XMPPChat.XMPP_RESOURCE;
    }

    return this.getChatUsername(realName) +
        '@' + XMPPChat.XMPP_HOST + '/' + resource;
}


/*******************************************************************************
 *   .
 *   JID   ejabberd.
 *
 *  Parameters:
 *    (String) roomId -    ejabberd.
 *
 *  Returns:
 *    JID   ejabberd.
 */
XMPPChat.Connection.prototype._getJIDFromRoomId = function(roomId) {
    return roomId + '@' + XMPPChat.XMPP_MUC;
}


/*******************************************************************************
 *   .
 *    "presence".
 *
 *  Parameters:
 *    (XMLElement) presence - .
 *
 *  Returns:
 *    (Object) data   :
 *      (String) type -   (, , )
 *      (String) from -  -  ejabberd
 *      (String) roomId -    ejabberd   
 *      (String) errorCode -     
 *      (String) fromJID - JID 
 *      (String) toJID - JID 
 *      (Object) x - ,    "x"  "presence"
 *      (XMLElement) xmlX -  "x"  xml-
 *      (XMLElement) xmlStatus -  "status"  xml-
 *      (XMLElement) xmlDestroy -  "destroy"  xml-
 */
XMPPChat.Connection.prototype._parsePresence = function(presence) {
    var data = {
        type : presence.getAttribute('type'),
        fromJID : presence.getAttribute('from'),
        toJID : presence.getAttribute('to'),
        x : this._getXParams(presence)
    };

    //    
    if (Strophe.getDomainFromJid(data.fromJID) == XMPPChat.XMPP_MUC) {
        data.from = Strophe.getResourceFromJid(data.fromJID);
        data.roomId = Strophe.getNodeFromJid(data.fromJID);
    }

    var statuses = presence.getElementsByTagName('status');

    if (statuses && statuses.length > 0) {
        data.xmlStatus = statuses[0];
    }

    var xs = presence.getElementsByTagName('x');

    if (xs && xs.length > 0) {
        data.xmlX = xs[0];
        var destroys = data.xmlX.getElementsByTagName('destroy');

        if (destroys && destroys.length > 0) {
            data.xmlDestroy = destroys[0];
        }
    }

    if (data.type == XMPPChat.PT_ERROR) {
        var errors = presence.getElementsByTagName('error');

        if (errors && errors.length > 0) {
            data.errorCode = errors[0].getAttribute('code');
        }
    }

    return data;
}


/*******************************************************************************
 *   .
 *    "message".
 *
 *  Parameters:
 *    (XMLElement) message - .
 *
 *  Returns:
 *    (Object) data   :
 *      (String) type -   (, , )
 *      (String) from -  -  ejabberd
 *      (String) roomId -    ejabberd   
 *      (String) errorCode -     
 *      (String) fromJID - JID 
 *      (String) toJID - JID 
 *      (Object) x - ,    "x"  "message"
 *      (String) body -   "body"
 *      (XMLElement) xmlBody -  "body"  xml-
 */
XMPPChat.Connection.prototype._parseMessage = function(message) {
    var bodies = message.getElementsByTagName('body');

    if (! bodies || bodies.length == 0) {
        this._log(
            'Error: Empty body received for stanza: ' +
            Strophe.serialize(message)
        );

        return {};
    }

    var data = {
        fromJID : message.getAttribute('from'),
        toJID : message.getAttribute('to'),
        x : this._getXParams(message),
        body : Strophe.getText(bodies[0]),
        xmlBody : bodies[0]
    };

    var type = message.getAttribute('type');

    if (type == XMPPChat.XMPP_MT_PRIVATE) {
        data.from = Strophe.getNodeFromJid(data.fromJID);

        if (data.x.command) {
            data.type = XMPPChat.MT_COMMAND;
        } else {
            data.type = XMPPChat.MT_PRIVATE;
        }
    } else if (type == XMPPChat.XMPP_MT_ROOM) {
        if (data.x.command) {
            data.type = XMPPChat.MT_COMMAND;
        } else {
            data.type = XMPPChat.MT_ROOM;
        }
        data.from = Strophe.getResourceFromJid(data.fromJID);
        data.roomId = Strophe.getNodeFromJid(data.fromJID);
    } else if (type == XMPPChat.XMPP_MT_ERROR) {
        data.type = XMPPChat.MT_ERROR;
        data.from = Strophe.getNodeFromJid(data.fromJID);

        var errors = message.getElementsByTagName('error');

        if (errors && errors.length > 0) {
            data.errorCode = errors[0].getAttribute('code');
        }
    }

    return data;
}


/*******************************************************************************
 *   .
 *    "iq".    
 *
 *  Parameters:
 *    (XMLElement) message - .
 *
 *  Returns: {}
 */
XMPPChat.Connection.prototype._parseQuery = function(iq) {
    return {};
}


/*******************************************************************************
 *   .
 *     "x" .
 *
 *  Parameters:
 *    (XMLElement) stanza - .
 *
 *  Returns:
 *        "x" .
 */
XMPPChat.Connection.prototype._getXParams = function(stanza) {
    var xs = stanza.getElementsByTagName('x');
    var x = {};

    if (xs && xs.length > 0) {
        for (var i = 0; i < xs[0].attributes.length; i++) {
            x[xs[0].attributes[i].name] = xs[0].getAttribute(
                xs[0].attributes[i].name
            );
        }
    }

    return x;
}


/*******************************************************************************
 *      .
 *
 *  Parameters:
 *    (Object) newAttrs -  .
 *    (Object) attrs -  .
 */
XMPPChat.Connection.prototype._addAttributes = function(newAttrs, attrs) {
    if (! newAttrs) {
        newAttrs = {};
    }

    if (! attrs) {
        attrs = {};
    }

    for (var name in newAttrs) {
        attrs[name] = newAttrs[name];
    }

    return attrs;
}


/*******************************************************************************
 *   .
 *     .       .
 *
 *  Parameters:
 *    (String) message - .
 */
XMPPChat.Connection.prototype._log = function(message) {
    if (this._isLog && console) {
        try {
            console.log(message);
        } catch (e) {
        }
    }
}


/*******************************************************************************
 *   .
 *    .
 *
 *  Parameters:
 *    (Object) handlers -   .
 */
XMPPChat.Connection.prototype._storeHandlers = function(handlers) {
    this._onStatusChangeHandler = null;
    this._onConnectHandler = null;
    this._onDisconnectHandler = null;
    this._onPresenceHandler = null;
    this._onMessageHandler = null;
    this._onQueryHandler = null;

    if (handlers) {
        if (handlers.onStatusChange) {
            this._onStatusChangeHandler = handlers.onStatusChange;
        }

        if (handlers.onConnect) {
            this._onConnectHandler = handlers.onConnect;
        }

        if (handlers.onDisconnect) {
            this._onDisconnectHandler = handlers.onDisconnect;
        }

        if (handlers.onPresence) {
            this._onPresenceHandler = handlers.onPresence;
        }

        if (handlers.onMessage) {
            this._onMessageHandler = handlers.onMessage;
        }

        if (handlers.onQuery) {
            this._onQueryHandler = handlers.onQuery;
        }
    }
}
if (typeof(XMPPChat) == 'undefined') {
    XMPPChat = {};
}


XMPPChat.GameChat = function() {
    this.connection = new XMPPChat.Connection(
        $('#username').get(0).value,
        $('#pass').get(0).value,
        'Game',
        {
            onChangeStatus : this.onChangeStatus.bind(this),
            onConnect : this.onConnect.bind(this),
            onPresence : this.onPresence.bind(this),
            onMessage : this.onMessage.bind(this)
        }
    );
}


XMPPChat.GameChat.prototype.sendPresence = function(to) {
    this.connection.sendPresence(to);
}


XMPPChat.GameChat.prototype.sendRoomPresence = function(to) {
    this.connection.sendRoomPresence(to);
}


XMPPChat.GameChat.prototype.sendPrivateMessage = function(to, message) {
    this.connection.sendPrivateMessage(to, message);
}


XMPPChat.GameChat.prototype.sendMultiPrivateMessage = function(to, message) {
    this.connection.sendMultiPrivateMessage(to, message);
}


XMPPChat.GameChat.prototype.sendRoomMessage = function(to, message) {
    this.connection.sendRoomMessage(to, message);
}


XMPPChat.GameChat.prototype.onChangeStatus = function(status) {
}


XMPPChat.GameChat.prototype.onConnect = function(status) {
    this.sendPresence();
}


XMPPChat.GameChat.prototype.onPresence = function(data, presence) {
    if (data.from) {
        log('Stanza: ' + Strophe.serialize(presence));
        log('From: ' + data.from);
        log('roomId: ' + data.roomId);
    }
}


XMPPChat.GameChat.prototype.onMessage = function(data, message) {
    log('Stanza: ' + Strophe.serialize(message));
    log('From: ' + data.from);
    log('Message: ' + data.body);

    if (data.errorCode) {
        log('Error code: ' + data.errorCode);
    }
}
;(function() {

/**
 *    Ext'
 */

//    AJAX POST   iOS 6+
if (Ext.is.iOS) {
    Ext.override(Ext.Ajax, {
        setOptions: function() {
            var options = this.callParent(arguments);

            if (options.method === 'POST') {
                options.url = Ext.String.urlAppend(options.url, this.disableCachingParam + '=' + (new Date().getTime()));
            }

            return options;
        }
    });
}

/*
 *    AJAX     
 *   *queue*
 */
// Ext.override(Ext.Ajax, {
//  queue: [],

//  request : function(options) {
//         options = options || {};
        
//         var me = this,
//             requestOptions, request;
        
//         if (me.fireEvent('beforerequest', me, options) !== false) {
//             requestOptions = me.setOptions(options, options.scope || Ext.global);
            
//             request = me.createRequest(options, requestOptions);
            
//          //  // override
//          if (options.operation && options.operation.queue) {
//              options.queue = true;
//          }

//          if (!options.queue) {
//              return request.start(requestOptions.data);
//          } else {
//              me.queue.push({
//                  request: request,
//                  data: requestOptions.data
//              });
//              if (!me.queue.length) {
//                  return request.start(requestOptions.data);
//              }
//          }
//          // end: override
//         }

//         Ext.callback(options.callback, options.scope, [options, undefined, undefined]);

//         return Ext.Deferred.rejected([options, undefined, undefined]);
//  }
// });

// function requestCallback(conn, response, options) {
//  var queue = conn.queue,
//      request, data;

//  if (options.queue) {
//      conn.queue.shift();

//      if (conn.queue.length) {
//          request = conn.queue[0].request;
//          data = conn.queue[0].data;
//          request.start(data);
//      }
//  }
// }

// Ext.Ajax.on({
//  requestcomplete: {
//      fn: requestCallback,
//      delay: 1
//  },

//  requestexception: {
//      fn: requestCallback,
//      delay: 1
//  }
// });


/**
 *   
 */
if (!Ext.is.iOS && !Ext.is.Android) {
    Ext.override(Ext.form.field.Radio, {
        afterRender: function() {
            var me = this,
                tooltip = me.qtip || me.tooltip;

            me.callParent(arguments);

            if (tooltip) {
                if (Ext.isObject(tooltip)) {
                    Ext.tip.QuickTipManager.register(Ext.apply({
                        target: me.id
                    }, tooltip));
                }
                else {
                    me.el.dom.setAttribute('data-qtip', tooltip);
                }
            }
        }
    });
}

Ext.Date.getMonthNumber = function(name) {
    return Ext.Date.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
};

Ext.Date.getShortDayName = function(day) {
    return Ext.Date.dayNames[day].substring(0, 3);
};

// Ext.override(Ext.form.field.Date, {
//  disabledDaysText    : ' ',
//  disabledDatesText   : ' ',
//  minText             : '       {0}',
//  maxText             : '       {0}',
//  invalidText         : '{0}     -       {1}',
//  format              : 'd.m.Y',
//  altFormats          : 'd.m.y|d/m/Y|d-m-y|d-m-Y|d/m|d-m|dm|dmy|dmY|d|Y-m-d',
//  startDay            : 1
// });

// Ext.override(Ext.form.field.Text, {
//  blankText: '    ',
//  minLengthText: '    {0}',
//  maxLengthText: '    {0}'
// });

// Ext.apply(Ext.form.field.VTypes, {
//  emailText: '         "user@example.com"'
// });

// Ext.override(Ext.picker.Date, {
//  todayText          : '',
//  minText            : '    ',
//  maxText            : '    ',
//  disabledDaysText   : '',
//  disabledDatesText  : '',
//  monthNames         : Ext.Date.monthNames,
//  dayNames           : Ext.Date.dayNames,
//  nextText           : '  (Control+)',
//  prevText           : '  (Control+)',
//  monthYearText      : '  (Control+/   )',
//  todayTip           : '{0} ()',
//  format             : 'd.m.Y',
//  startDay           : 1
// });

// Ext.override(Ext.picker.Month, {
//  okText             : '&#160;OK&#160;',
//  cancelText         : ''
// });

if (Ext.is.iOS) {
    Ext.override(Ext.form.field.TextArea, {
        afterRender: function() {
            var me = this;

            me.callParent(arguments);

            me.inputEl.on('click', function() {
                this.dom.focus();
            });
        }
    });
}

Ext.override(Ext.view.AbstractView, {
    loadingText: ''
});

Ext.data.Model.override({

    mixins: {
        observable: Ext.util.Observable
    },

    constructor: function(data, session) {

        //     ExtJS 4.1.2
        this.raw = Ext.clone(data); 

        this.mixins.observable.constructor.call(this);
        this.callParent(arguments);
        this.join(this); //     (,    afterEdit)
    },

    /**
     *      .
     *     (reader)       set    
     */
    setRawData: function(data) {
        var me = this,
            reader = me.getProxy().reader,
            record;

        me.raw = Ext.clone(data);

        //   ,     
        Ext.Object.each(me.data, function(key) {
            if (me.data.hasOwnProperty(key) && !data[key]) {
                me.data[key] = undefined;
            }
        });

        record = reader.read(data).records[0];
        me.set(record.data);
    },

    privates: {
        isEqual: function(a, b) {
            var me = this;
            
            if (Ext.isDate(a) && Ext.isDate(b)) {
                return a.getTime() === b.getTime();
            }
            
            if (Ext.isArray(a) && Ext.isArray(b)) {
                if (a.length != b.length) {
                    return false;
                } else {
                    var count = a.length;
                    Ext.Array.each(a, function(item, index) {
                        if (me.isEqual(a[index], b[index])) {
                            count--;
                        } else {
                            return false;
                        }
                    });
                    
                    return count ? false : true;
                }
            }
            
            if (Ext.isObject(a) && Ext.isObject(b)) {
                if (Ext.getClassName(a) && Ext.getClassName(b)) {
                    return true;
                }
                if (Ext.Object.getSize(a) != Ext.Object.getSize(b)) {
                    return false;
                } else {
                    var count = Ext.Object.getSize(a);
                    Ext.Object.each(a, function(key, value) {
                        if (me.isEqual(a[key], b[key])) {
                            count--;
                        } else {
                            return false;
                        }
                    });
                    
                    return count ? false : true;
                }
            }
            
            return a === b;
        }
    },

});

Ext.data.field.Field.override({

    isEqual: function(a, b) {
        var me = this;
        
        if (Ext.isDate(a) && Ext.isDate(b)) {
            return a.getTime() === b.getTime();
        }
        
        if (Ext.isArray(a) && Ext.isArray(b)) {
            if (a.length != b.length) {
                return false;
            } else {
                var count = a.length;
                Ext.Array.each(a, function(item, index) {
                    if (me.isEqual(a[index], b[index])) {
                        count--;
                    } else {
                        return false;
                    }
                });
                
                return count ? false : true;
            }
        }
        
        if (Ext.isObject(a) && Ext.isObject(b)) {
            if (Ext.getClassName(a) && Ext.getClassName(b)) {
                return true;
            }
            if (Ext.Object.getSize(a) != Ext.Object.getSize(b)) {
                return false;
            } else {
                var count = Ext.Object.getSize(a);
                Ext.Object.each(a, function(key, value) {
                    if (me.isEqual(a[key], b[key])) {
                        count--;
                    } else {
                        return false;
                    }
                });
                
                return count ? false : true;
            }
        }
        
        return a === b;
    }

});

/*
 * BUG: suspentEvents not honoured in Ext.app.EventBus
 *
 * note: this fix does not queue events when asked.
 *
 * http://www.sencha.com/forum/showthread.php?171525
 */
Ext.override(Ext.app.EventBus, {
    constructor: function() {
        this.mixins.observable.constructor.call(this);
        this.bus = {};

        var me = this;

        Ext.override(Ext.Component, {
            fireEvent: function(ev) {
                if (Ext.util.Observable.prototype.fireEvent.apply(this, arguments) !== false) {
                    if (!this.eventsSuspended) {
                        return me.dispatch.call(me, ev, this, arguments);
                    } else {
                        return true;
                    }
                }
                return false;
            }
        });
    }
});

// Ext.override(Ext.app.Application, {

//  getController: function(name) {
//         var me          = this,
//             controllers = me.controllers,
//             className, controller, fullName;

//         controller = controllers.get(name);

//         if (!controller) {
//             className  = me.getModuleClassName(name, 'controller');
//             fullName = Ext.app.Controller.getFullName(name, 'controller', me.$namespace);

//             controller = Ext.create(className, {
//                 application: me,
//                 id:          fullName.shortName // id      ,
//                                              //    "ClientAction@ExGodsCore.controller" id  "ClientAction"
//             });

//             controllers.add(controller);

//             if (me._initialized) {
//                 controller.doInit(me);
//             }
//         }

//         return controller;
//     }
// });

/**
 *     
 *   -    ,    autoRender    ( doAutoRender)    
 */
Ext.override(Ext.AbstractComponent, {
    initComponent: function() {
        if (this.layer) {
            if (typeof this.layer == 'string') {
                this.layer = ExGods.Layers.get(this.layer);
            }
            this.on('destroy', function(cmp) {
                delete cmp.layer;
            });
            this.autoRender = true;
            this.doAutoRender = function() {
                if (this.layer) {
                    this.layer.add(this);
                }
            };
        }
        this.callParent(arguments);
    }
});

/**
 *        ,   
 */
Ext.override(Ext.util.LocalStorage, {
    setItem: function() {
        arguments[1] = Ext.encode(arguments[1]);
        this.callOverridden(arguments);
    },
    getItem: function() {
        var value = this.callOverridden(arguments);
        return value ? Ext.decode(value) : '';
    }
});

})();/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
var hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */
var b64pad  = "";  /* base-64 pad character. "=" for strict RFC compliance   */

/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */
function hex_md5(s)    { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }
function b64_md5(s)    { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }
function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }
function hex_hmac_md5(k, d)
  { return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function b64_hmac_md5(k, d)
  { return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d))); }
function any_hmac_md5(k, d, e)
  { return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e); }

/*
 * Perform a simple self-test to see if the VM is working
 */
function md5_vm_test()
{
  return hex_md5("abc").toLowerCase() == "900150983cd24fb0d6963f7d28e17f72";
}

/*
 * Calculate the MD5 of a raw string
 */
function rstr_md5(s)
{
  return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
}

/*
 * Calculate the HMAC-MD5, of a key and some data (raw strings)
 */
function rstr_hmac_md5(key, data)
{
  var bkey = rstr2binl(key);
  if(bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);

  var ipad = Array(16), opad = Array(16);
  for(var i = 0; i < 16; i++)
  {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5C5C5C5C;
  }

  var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
}

/*
 * Convert a raw string to a hex string
 */
function rstr2hex(input)
{
  try { hexcase } catch(e) { hexcase=0; }
  var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
  var output = "";
  var x;
  for(var i = 0; i < input.length; i++)
  {
    x = input.charCodeAt(i);
    output += hex_tab.charAt((x >>> 4) & 0x0F)
           +  hex_tab.charAt( x        & 0x0F);
  }
  return output;
}

/*
 * Convert a raw string to a base-64 string
 */
function rstr2b64(input)
{
  try { b64pad } catch(e) { b64pad=''; }
  var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var output = "";
  var len = input.length;
  for(var i = 0; i < len; i += 3)
  {
    var triplet = (input.charCodeAt(i) << 16)
                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)
                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);
    for(var j = 0; j < 4; j++)
    {
      if(i * 8 + j * 6 > input.length * 8) output += b64pad;
      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);
    }
  }
  return output;
}

/*
 * Convert a raw string to an arbitrary string encoding
 */
function rstr2any(input, encoding)
{
  var divisor = encoding.length;
  var i, j, q, x, quotient;

  /* Convert to an array of 16-bit big-endian values, forming the dividend */
  var dividend = Array(Math.ceil(input.length / 2));
  for(i = 0; i < dividend.length; i++)
  {
    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
  }

  /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. All remainders are stored for later
   * use.
   */
  var full_length = Math.ceil(input.length * 8 /
                                    (Math.log(encoding.length) / Math.log(2)));
  var remainders = Array(full_length);
  for(j = 0; j < full_length; j++)
  {
    quotient = Array();
    x = 0;
    for(i = 0; i < dividend.length; i++)
    {
      x = (x << 16) + dividend[i];
      q = Math.floor(x / divisor);
      x -= q * divisor;
      if(quotient.length > 0 || q > 0)
        quotient[quotient.length] = q;
    }
    remainders[j] = x;
    dividend = quotient;
  }

  /* Convert the remainders to the output string */
  var output = "";
  for(i = remainders.length - 1; i >= 0; i--)
    output += encoding.charAt(remainders[i]);

  return output;
}

/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */
function str2rstr_utf8(input)
{
  var output = "";
  var i = -1;
  var x, y;

  while(++i < input.length)
  {
    /* Decode utf-16 surrogate pairs */
    x = input.charCodeAt(i);
    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)
    {
      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
      i++;
    }

    /* Encode output as utf-8 */
    if(x <= 0x7F)
      output += String.fromCharCode(x);
    else if(x <= 0x7FF)
      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0xFFFF)
      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
    else if(x <= 0x1FFFFF)
      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
                                    0x80 | ((x >>> 12) & 0x3F),
                                    0x80 | ((x >>> 6 ) & 0x3F),
                                    0x80 | ( x         & 0x3F));
  }
  return output;
}

/*
 * Encode a string as utf-16
 */
function str2rstr_utf16le(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,
                                  (input.charCodeAt(i) >>> 8) & 0xFF);
  return output;
}

function str2rstr_utf16be(input)
{
  var output = "";
  for(var i = 0; i < input.length; i++)
    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,
                                   input.charCodeAt(i)        & 0xFF);
  return output;
}

/*
 * Convert a raw string to an array of little-endian words
 * Characters >255 have their high-byte silently ignored.
 */
function rstr2binl(input)
{
  var output = Array(input.length >> 2);
  for(var i = 0; i < output.length; i++)
    output[i] = 0;
  for(var i = 0; i < input.length * 8; i += 8)
    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (i%32);
  return output;
}

/*
 * Convert an array of little-endian words to a string
 */
function binl2rstr(input)
{
  var output = "";
  for(var i = 0; i < input.length * 32; i += 8)
    output += String.fromCharCode((input[i>>5] >>> (i % 32)) & 0xFF);
  return output;
}

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length.
 */
function binl_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);
}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}
// End: md5


/*!
* screenfull
* v1.0.2 - 2012-10-15
* https://github.com/sindresorhus/screenfull.js
* (c) Sindre Sorhus; MIT License
*/
(function(e,t){"use strict";var n=typeof Element!="undefined"&&"ALLOW_KEYBOARD_INPUT"in Element,r=function(){var e,n,r=[["requestFullscreen","exitFullscreen","fullscreenElement","fullscreenEnabled","fullscreenchange","fullscreenerror"],["webkitRequestFullscreen","webkitExitFullscreen","webkitFullscreenElement","webkitFullscreenEnabled","webkitfullscreenchange","webkitfullscreenerror"],["webkitRequestFullScreen","webkitCancelFullScreen","webkitCurrentFullScreenElement","","webkitfullscreenchange","webkitfullscreenerror"],["mozRequestFullScreen","mozCancelFullScreen","mozFullScreenElement","mozFullScreenEnabled","mozfullscreenchange","mozfullscreenerror"]],i=0,s=r.length,o={};for(;i<s;i++){e=r[i];if(e&&e[1]in t){for(i=0,n=e.length;i<n;i++)o[r[0][i]]=e[i];return o}}return!1}(),i={request:function(e){var i=r.requestFullscreen;e=e||t.documentElement,/5\.1[\.\d]* Safari/.test(navigator.userAgent)?e[i]():e[i](n&&Element.ALLOW_KEYBOARD_INPUT)},exit:function(){t[r.exitFullscreen]()},toggle:function(e){this.isFullscreen?this.exit():this.request(e)},onchange:function(){},onerror:function(){}};if(!r)return e.screenfull=!1;Object.defineProperties(i,{isFullscreen:{get:function(){return!!t[r.fullscreenElement]}},element:{enumerable:!0,get:function(){return t[r.fullscreenElement]}},enabled:{enumerable:!0,get:function(){return t[r.fullscreenEnabled]}}}),t.addEventListener(r.fullscreenchange,function(e){i.onchange.call(i,e)}),t.addEventListener(r.fullscreenerror,function(e){i.onerror.call(i,e)}),e.screenfull=i})(window,document);


function getUID() {
    return hex_md5([(new Date()).getTime(), screen.width, screen.height].join('')).substr(16, 16);
}

function NoClickDelay(el) {
    this.element = typeof el == 'object' ? el : document.getElementById(el);
    //if ( window.Touch )
    if (this.element.addEventListener)
        this.element.addEventListener('touchstart', this, false);
}

NoClickDelay.prototype = {
    handleEvent: function(e) {
        var type = e.target.getAttribute('type');
        
        if (type == 'text')
            return;
        
        switch(e.type) {
            case 'touchstart': this.onTouchStart(e); break;
            case 'touchmove': this.onTouchMove(e); break;
            case 'touchend': this.onTouchEnd(e); break;
        }
    },

    onTouchStart: function(e) {
        e.preventDefault();
        this.moved = false;
        
        this.element.addEventListener('touchmove', this, false);
        this.element.addEventListener('touchend', this, false);
    },

    onTouchMove: function(e) {
        this.moved = true;
    },

    onTouchEnd: function(e) {
        this.element.removeEventListener('touchmove', this, false);
        this.element.removeEventListener('touchend', this, false);

        if ( !this.moved ) {
            // Place your code here or use the click simulation below
            var theTarget = document.elementFromPoint(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
            if (theTarget.nodeType == 3) theTarget = theTarget.parentNode;
            
            var theEvent = document.createEvent('MouseEvents');
            theEvent.initEvent('click', true, true);
            theTarget.dispatchEvent(theEvent);
        }
    }
};

/**
 *   
 */
var dateFormat = 'd.m.Y',
    timeFormat = 'H:i:s',
    dateTimeFormat = 'd.m.Y H:i:s',
    altDateFormats = '',
    serverDateFormat = 'Y-m-d',
    serverTimeFormat = 'H:i:s',
    serverDateTimeFormat = serverDateFormat + ' ' + serverTimeFormat;;(function() {

/*
 *       Ext JS
 */
Ext.override(Ext.LoadMask, {
    floating: {
        shadow: false
    },
    msg: '',
    ui: 'hourglass'
});

//   
Ext.override(Ext.AbstractComponent, {
    ui: 'exgods'
});

//   
Ext.override(Ext.tip.Tip, {
    alwaysFramed: false,
    shadow: 'frame',
    showDelay: 3000
});

//   
Ext.override(Ext.button.Button, {
    scale: ''
});

Ext.override(Ext.dom.Element, {
    mask: function(msg, msgCls) {
        var me = this,
            data = me.getData(),
            maskEl,
            maskMsg,
            startClass = msgCls;

        if (data.btn) {
            data.reloadBtn.destroy();
        }

        if (msg && msgCls != 'hourglass') {
            msgCls = 'x-mask-msg-reload';
        }

        this.callParent(arguments);

        maskEl = data.maskEl;
        maskMsg = Ext.get(maskEl.dom.firstChild);

        if (maskMsg.hasCls('x-mask-msg-reload') && startClass != 'local-mask') {
            data.reloadBtn = Ext.widget('button', {
                cls: 'h-46',
                handler: function() {
                    location.reload();
                },
                height: 46,
                icon: IMAGE_URL + 'loader-reload.png',
                renderTo: maskMsg,
                width: 46,
                ui: 'image'
            });
        }

        maskMsg.setDisplayed(false);

        setTimeout(function() {
            if (maskMsg && maskMsg.dom && me.dom) {
                maskMsg.setDisplayed(true);
                maskMsg.center(me);

                if (startClass == 'local-mask') {

                    if (msg) {
                        maskMsg.addCls('animating');
                    }

                    // 1  :
                    //    ,  ;
                    //    ,    - 1   . (    unmask() )
                    setTimeout(function() {
                        if (maskMsg && maskMsg.dom && me.dom) {

                            if ( maskMsg.hasCls('removed') ) {
                                maskMsg.removeCls('animating');
                                me.unmask();
                            }
                            else {
                                maskMsg.removeCls('animating');
                            }
                        }
                    }, 1000);
                }
            }
        }, 500);

        return maskEl;
    },

    unmask: function() {
        var maskEl = this.getData().maskEl,
            maskMsg = maskEl ? Ext.get(maskEl.dom.firstChild) : '';
        //   ,   . (    block()   );
        //    ,  .
        if (maskMsg && maskMsg.dom) {
            if ( maskMsg.hasCls('animating') ) {
                maskMsg.addCls('removed');
            }
            else {
                this.callParent(arguments);
            }
        }
    }
});

//   
Ext.override(Ext.Shadow, {
    offset: 6
});

Ext.override(Ext.view.AbstractView, {
    loadingText: ''
});

//     
Ext.override(Ext.dd.DragSource, {
    
    repairHighlightColor: false,

    afterRepair: function() {
        var me = this;
        if (Ext.enableFx && me.repairHighlightColor) {
            me.el.highlight(me.repairHighlightColor);
        }
        me.dragging = false;
    }

});

//      
Ext.override(Ext.tab.Panel, {
    getResources: function() {
        var me = this,
            images = [];
        if (me.tabBar && me.tabBar.items) {
            me.tabBar.items.each(function(item) {
                if (item.icon) {
                    images.push(item.icon);
                }
            });
        }
        return {
            images: images,
        }
    },
});



///    ,       
//   ,   ,   
//
Ext.Component.override({
    onHide: function(animateTarget, cb, scope) {
        var me = this,
            ghostPanel, fromSize, toBox;
        
        if (me.previousFocus && me.previousFocus.ignore_focus){
            me.previousFocus = null;
        }
        
        me.revertFocus();
        
        animateTarget = me.getAnimateTarget(animateTarget);
        
        if (!me.ghost) {
            animateTarget = null;
        }
        
        if (animateTarget) {
            toBox = {
                x: animateTarget.getX(),
                y: animateTarget.getY(),
                width: animateTarget.dom.offsetWidth,
                height: animateTarget.dom.offsetHeight
            };
            ghostPanel = me.ghost();
            ghostPanel.el.stopAnimation();
            fromSize = me.getSize();
            ghostPanel.el.animate({
                to: toBox,
                listeners: {
                    afteranimate: function() {
                        delete ghostPanel.componentLayout.lastComponentSize;
                        ghostPanel.el.hide();
                        ghostPanel.setHiddenState(true);
                        ghostPanel.el.setSize(fromSize);
                        me.afterHide(cb, scope);
                    }
                }
            });
        }
        me.el.hide();
        if (!animateTarget) {
            me.afterHide(cb, scope);
        }
    }
});

})();/**
 * Mixin,      
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGodsCore.util.Loggable', {
    logConfig: {
        enabled: {
            info: true,
            error: true,
            warn: true
        },
        prefix: ''
    },
    /**
     *    .
     *       ,     (info, error, warn).     -     info
     */
    log: function() {
        var args = Ext.Array.from(arguments),
            level, msg;
        //   
        if (args[0] == 'error' || args[0] == 'warn' || args[0] == 'info') {
            level = args.shift();
            msg = args;
        } else if (typeof this.logConfig.enabled == 'object' && this.logConfig.enabled[args[0]]) {
            //    
            level = args.shift();
            msg = args;
        } else {
            level = "info";
            msg = args;
        }
        // ,      
        if (this.logConfig.enabled === true || (typeof this.logConfig.enabled == 'object' && (this.logConfig.enabled[level]))) {
            //  
            if (this.logConfig.prefix) {
                msg.unshift(this.logConfig.prefix);
            }
            // ,   
            if (typeof window.console == 'object') {
                if (typeof window.console[level] == 'function') {
                    console[level].apply(console, msg);
                } else if (typeof console.log == 'function') {
                    console.log.apply(console, msg);
                }
            }
        }
    },
    /**
     *    ,           
     * @param {String} method   
     */
    logMethod: function(method) {
        var me = this,
            origFn = this[method];
        if (typeof origFn == 'function') {
            this[method] = Ext.Function.createInterceptor(origFn, function() {
                me.log(' ', method, ' ', arguments);
                return true;
            }, me);
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.stuff.Stuff', {
    extend: Ext.util.Observable,
    /**
     * @cfg stuff {Object}      ({type: <String>, params: <Object>})
     */
    stuff: {},
    /**
     * @cfg tooltip {Boolean}      
     */
    tooltip: true,
    /**
     * @property dblclickAction {String}     
     */
    dblclickAction: '',
    /**
     * @property printTpl {Mixed}   
     */
    printTpl: [
        '<span id="{id}" class="{[ this.getCls(values) ]}" style="{[ this.getStyle(values) ]}" {[ this.getAttributes(values) ]}>',
        '{text}',
        '</span>',
        {
            getCls: function(values) {
                var cls = 'exg-stuff-item exg-stuff-printed';
                cls += ' exg-stuff-item-' + values.stuff.type;
                if (values.tooltip) {
                    cls += ' exgtip';
                }
                return cls;
            },
            getStyle: function(values) {
                var style = '',
                    img;
                if (values.img) {
                    if (/^http/.test(values.img)) {
                        img = values.img;
                    } else {
                        img = IMAGE_URL + values.img;
                    }
                    style += 'background-image:url(' + img + ')';
                }
                return style;
            },
            getAttributes: function(values) {
                var attrs = [];
                if (values.tooltip) {
                    attrs.push('data-exgtip_type="stuff"');
                    attrs.push('data-exgtip_value="' + values.id + '"');
                }
                return attrs.join(' ');
            }
        }
    ],
    /**
     * @property imageTpl {Mixed}      
     */
    imageTpl: [
        '<div id="{id}" class="{[ this.getCls(values) ]}" {[ this.getAttributes(values) ]} >',
        '{[ this.decorate("before", values) ]}',
        '<div class="exg-stuff-img" style="background-image:url({[ /^http/.test(values.img) ? values.img : IMAGE_URL + values.img ]})"></div>',
        '{[ this.decorate("after", values) ]}',
        '</div>',
        {
            getCls: function(values) {
                var cls = [];
                cls.push('exg-stuff-item');
                cls.push('exg-stuff-imaged');
                cls.push('exg-stuff-item-' + values.stuff.type);
                if (values.tooltip) {
                    cls.push('exgtip');
                }
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator) {
                        var decoCls = decorator.getCls(values);
                        if (decoCls) {
                            cls.push(decoCls);
                        }
                    });
                }
                return cls.join(' ');
            },
            getAttributes: function(values) {
                var attrs = [];
                if (values.tooltip) {
                    attrs.push('data-exgtip_type="stuff"');
                    attrs.push('data-exgtip_value="' + values.id + '"');
                }
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator) {
                        var decoAttributes = decorator.getAttributes(values);
                        if (decoAttributes) {
                            attrs.push(decoAttributes);
                        }
                    });
                }
                return attrs.join(' ');
            },
            decorate: function(afterOrBefore, values) {
                var html = [];
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator, index) {
                        try {
                            if (afterOrBefore == 'after' && decorator.decorateAfter) {
                                html.push(decorator.decorateAfter(values));
                            } else if (decorator.decorateBefore) {
                                html.push(decorator.decorateBefore(values));
                            }
                        } catch (e) {
                            /***/
                            ExGods.stuff.StuffManager.log('error', '@decorate  ', values, index, e);
                        }
                    });
                }
                return html.join('');
            }
        }
    ],
    /**
     * @property detailsTpl {Mixed}   
     */
    detailsTpl: [
        '<div id="{id}" class="exg-stuff-item exg-stuff-item-{stuff.type} exg-stuff-details">',
        '<div class="header">',
        '<div style="display: table;">',
        '<div class="image {[ this.getDecoratorCls(values) ]}">',
        '{[ this.decorate("before", values) ]}',
        '<img src="{[ /^http/.test(values.img) ? values.img : IMAGE_URL + values.img ]}"/>',
        '{[ this.decorate("after", values) ]}',
        '</div>',
        '<span class="title {[ this.getTitleCls(values) ]}">{title}</span>',
        '</div>',
        '</div>',
        '<div class="details">',
        '<tpl if="description">',
        '<div class="exg-stuff-block-separator"></div>',
        '<div class="description">',
        '{[ ExGods.app.applyTpl(values.description) ]}',
        '</div>',
        '</tpl>',
        '{[ this.printBlocks(values) ]}',
        '<tpl if="values.buttons && values.buttons.length && (values.description || (values.blocks && values.blocks.length))">',
        '<div class="exg-stuff-block-separator"></div>',
        '</tpl>',
        '</div>',
        '</div>',
        {
            getDecoratorCls: function(values) {
                var cls = [];
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator) {
                        var decoCls = decorator.getCls ? decorator.getCls(values) : '';
                        if (decoCls) {
                            cls.push(decoCls);
                        }
                    });
                }
                return cls.join(' ');
            },
            decorate: function(afterOrBefore, values) {
                var html = [];
                if (values.decorators && values.decorators.length) {
                    values.decorators.forEach(function(decorator, index) {
                        try {
                            if (afterOrBefore == 'after' && decorator.decorateAfter) {
                                html.push(decorator.decorateAfter(values));
                            } else if (decorator.decorateBefore) {
                                html.push(decorator.decorateBefore(values));
                            }
                        } catch (e) {
                            /***/
                            ExGods.stuff.StuffManager.log('error', '@decorate  ', values, index, e);
                        }
                    });
                }
                return html.join('');
            },
            printBlocks: function(values) {
                var html = [];
                if (values.blocks && values.blocks.length) {
                    values.blocks.forEach(function(block, index) {
                        try {
                            var title = block.getTitle ? block.getTitle(values) : '',
                                content = block.getContent ? block.getContent(values) : '',
                                cls = "exg-stuff-block " + (block.getCls && block.getCls(values) ? block.getCls(values) : ''),
                                blockHtml;
                            if (content) {
                                blockHtml = '<div class="' + cls + '">';
                                if (title) {
                                    blockHtml += '<div class="exg-stuff-block-title">' + title + '</div>';
                                }
                                if (content) {
                                    if (Ext.isArray(content)) {
                                        blockHtml += '<table class="exg-stuff-block-content">';
                                        content.forEach(function(row) {
                                            blockHtml += '<tr>';
                                            if (Ext.isArray(row)) {
                                                row.forEach(function(cell) {
                                                    blockHtml += '<td>' + cell + '</td>';
                                                });
                                            } else {
                                                blockHtml += '<td>' + row + '</td>';
                                            }
                                            blockHtml += '</tr>';
                                        });
                                        blockHtml += '</table>';
                                    } else {
                                        blockHtml += '<div class="exg-stuff-block-content">' + content + '</div>';
                                    }
                                }
                                blockHtml += '</div>';
                                html.push(blockHtml);
                            }
                        } catch (e) {
                            /***/
                            ExGods.stuff.StuffManager.log('error', '@printBlocks    ', values, index, e);
                        }
                    });
                }
                if (html.length) {
                    return '<div class="exg-stuff-block-separator"></div>' + html.join('<div class="exg-stuff-block-separator"></div>');
                } else {
                    return '';
                }
            },
            // TODO    
            getTitleCls: function(values) {
                var cls = [];
                if (values.protoModel) {
                    cls.push('item-grade-color-' + (values.protoModel.data.data.item_grade || 1));
                }
                return cls.join(' ');
            }
        }
    ],
    constructor: function(config) {
        var me = this;
        me.id = Ext.id();
        me.callParent(arguments);
    },
    /**
     *     
     * @return {String}
     */
    print: function() {
        var me = this;
        if (!me.compiledPrintTpl) {
            me.compiledPrintTpl = new Ext.XTemplate(me.printTpl);
        }
        return me.compiledPrintTpl.apply(me.getPrintData());
    },
    /**
     *     .
     */
    getPrintData: function() {
        var me = this;
        return {
            id: me.id,
            img: '',
            text: me.stuff.type + ' x ' + (me.stuff.params.quantity ? me.stuff.params.quantity : ''),
            tooltip: me.tooltip,
            stuff: me.stuff
        };
    },
    /**
     *   
     */
    getTitle: function() {
        var me = this;
        return me.tooltip;
    },
    getDblClickAction: function() {
        var me = this;
        return me.dblclickAction;
    },
    /**
     *     
     * @return {String}
     */
    image: function() {
        var me = this;
        if (!me.compiledImageTpl) {
            me.compiledImageTpl = new Ext.XTemplate(me.imageTpl);
        }
        return me.compiledImageTpl.apply(me.getImageData());
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this;
        return {
            id: me.id,
            img: '',
            tooltip: me.tooltip,
            stuff: me.stuff,
            decorators: []
        };
    },
    /**
     *  - 
     */
    getDisabledImage: function() {
        return '';
    },
    /**
     *     
     * @param config
     *      clickedEl {Ext.dom.Element} DOM  ,   .   
            targetEl {Ext.dom.Element} DOM       
            asHTML {Boolean} true,     html  
            tooltip {Boolean} true,      
     */
    details: function(config) {
        var me = this,
            data = me.getDetailsData(),
            win;
        if (!me.compiledDetailsTpl) {
            me.compiledDetailsTpl = new Ext.XTemplate(me.detailsTpl);
        }
        if (config.tooltip && data.buttons && data.buttons.length) {
            data.buttons = [
                {
                    xtype: 'component',
                    style: {
                        'text-align': 'center'
                    },
                    html: ExGods.getMsgByKey('tooltip_text')
                }
            ];
        }
        if (config.targetEl) {
            Ext.widget('component', {
                tpl: me.compiledDetailsTpl,
                data: data,
                renderTo: config.targetEl
            });
        } else if (config.asHTML) {
            return me.compiledDetailsTpl.apply(data);
        } else {
            win = Ext.widget('parchmentwindow', {
                padding: '4 4 10 4',
                tpl: me.compiledDetailsTpl,
                data: data,
                closable: config.tooltip ? false : true,
                cascade: false,
                //config.tooltip ? false : true,
                itemElement: config.clickedEl,
                dockedItems: [
                    {
                        xtype: 'toolbar',
                        layout: 'anchor',
                        hidden: !data.buttons || !data.buttons.length,
                        defaults: {
                            anchor: '100%',
                            margin: '2 0',
                            cls: 'no_border',
                            handler: function(btn) {
                                me.fireEvent('action', me, btn.action, btn, win);
                            }
                        },
                        defaultType: 'textbutton',
                        dock: 'bottom',
                        itemId: 'actions',
                        margin: '5 0 10 0',
                        padding: '0 8 0 8',
                        items: data.buttons
                    }
                ]
            });
            return win;
        }
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this;
        return {
            id: me.id,
            img: '',
            title: '',
            description: '',
            decorators: [],
            blocks: [],
            buttons: [],
            stuff: me.stuff
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.stuff.StuffCollection', {
    extend: ExGods.stuff.Stuff,
    /**
     * @cfg stuff {Array}  
     */
    stuff: [],
    /**
     * @cfg sorted {Boolean} ,   
     */
    sorted: true,
    /**
     * @cfg printTpl {Mixed}   
     */
    printTpl: [
        '<ul class="exg-stuff-collection exg-stuff-printed">',
        '<tpl for="stuff">',
        '<li>{[ ExGods.stuff.StuffManager.print(values) ]}</li>',
        '</tpl>',
        '</ul>'
    ],
    imageTpl: [
        '<ul class="exg-stuff-collection exg-stuff-imaged">',
        '<tpl for="stuff">',
        '<li>{[ ExGods.stuff.StuffManager.image(values) ]}</li>',
        '</tpl>',
        '</ul>'
    ],
    detailsTpl: [
        '<ul class="exg-stuff-collection exg-stuff-details">',
        '<tpl for="stuff">',
        '<li>',
        '{[ ExGods.stuff.StuffManager.details(values) ]}',
        '<div class="info-icon"></div>',
        '<div class="exg-stuff-block-separator"></div>',
        '</li>',
        '</tpl>',
        '</ul>'
    ],
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        if (me.sorted) {
            me.stuff = me.sortStuff(me.stuff);
        }
    },
    sortStuff: function(stuff) {
        return Ext.Array.sort(stuff, function(a, b) {
            if (a.type == b.type)  {
                return 0;
            }
            
            if (a.type == 'item')  {
                return 1;
            }
            
            if (b.type == 'item')  {
                return -1;
            }
            
            if (a.type == 'trophy')  {
                return -1;
            }
            
            if (b.type == 'trophy')  {
                return 1;
            }
            
            if (a.type == 'expa')  {
                return -1;
            }
            
            if (b.type == 'expa')  {
                return 1;
            }
            
            if (a.type == 'valour')  {
                return -1;
            }
            
            if (b.type == 'valour')  {
                return 1;
            }
            
            if (a.type == 'currency')  {
                return -1;
            }
            
            if (b.type == 'currency')  {
                return 1;
            }
            
            if (a.type == 'ability')  {
                return -1;
            }
            
            if (b.type == 'ability')  {
                return 1;
            }
            
            if (a.type == 'feature')  {
                return -1;
            }
            
            if (b.type == 'feature')  {
                return 1;
            }
            
            if (a.type == 'timed')  {
                return -1;
            }
            
            if (b.type == 'timed')  {
                return 1;
            }
            
            return 1;
        });
    },
    /**
     *     .
     */
    getPrintData: function() {
        var me = this;
        return {
            stuff: me.stuff
        };
    },
    /**
     *     
     */
    getTitle: function() {
        return Ext.Array.map(me.stuff, function(el) {
            return ExGods.stuff.StuffManager.title(el);
        });
    }
});

/**
 *    .
 *   -      .     
 *         .
 *
 * Note:         :

        stuff: {
            params: {
                stuff: <Object> //    
            }
        }

 * 
 */
Ext.define('ExGods.stuff.Composite', {
    extend: ExGods.stuff.Stuff,
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        //      
        me.wrappedStuff = me.stuff.params.stuff;
        //   
        me.obj = ExGods.stuff.StuffManager.factory(me.wrappedStuff, true);
        //  id   id  ,   StuffManager  
        //       dom-  
        me.id = me.obj.id;
        //       
        me.relayEvents(me.obj, 'action');
    },
    /**
     *     .
     */
    getPrintData: function() {
        var me = this;
        return me.obj.getPrintData();
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this;
        return me.obj.getImageData();
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this;
        return me.obj.getDetailsData();
    },
    /**
     * ,       <typeName>
     */
    hasType: function(typeName) {
        var me = this,
            checkType = function(stuff, type) {
                if (stuff.type == type) {
                    return true;
                } else if (stuff.params.stuff) {
                    return checkType(stuff.params.stuff);
                } else {
                    return false;
                }
            };
        return checkType(me.stuff, typeName);
    }
});

/**
 *   .
 */
Ext.define('ExGods.stuff.Block', {
    inheritableStatics: {
        /**
         * ,       
         */
        getCls: function(data) {},
        //
        /**
         *   ,  
         */
        getTitle: function(data) {},
        //
        /**
         *   
         * @return {Mixed}   .     html-.    -   .
         *
         *          ExGods.stuff.block.item.Stats1
         */
        getContent: function(data) {}
    }
});
//              

/**
 *   .
 */
Ext.define('ExGods.stuff.Decorator', {
    inheritableStatics: {
        getCls: function(data) {},
        //
        getAttributes: function(data) {},
        //
        decorateBefore: function(data) {},
        //
        decorateAfter: function(data) {}
    }
});
//

/**
 *   ""

     :

        type: "expa"
        params:
            quantity: 12            
        

 */
Ext.define('ExGods.stuff.stuff.Expa', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            text: me.stuff.params.quantity,
            tooltip: me.getTitle(),
            img: ExGods.ref('images|user_stuff_icons').image.exp
        });
    },
    /**
     *   
     */
    getTitle: function() {
        return ExGods.getMsgByKey('stuff_tooltip_experience');
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            tooltip: ExGods.getMsgByKey('stuff_tooltip_experience'),
            img: ExGods.ref('user_hoard|expa').image_big,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            img: ExGods.ref('user_hoard|expa').image_big,
            title: ExGods.ref('user_hoard|expa').label,
            description: ExGods.getMsgByKey('currency_description_expa'),
            decorators: [],
            //
            blocks: []
        });
    },
    //
    /**
     *  - 
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('user_hoard|expa');
        return refData.image_disabled;
    }
});

/**
 *   ""

     :

        type: "trophy"
        params:
            quantity: 12            
        

 */
Ext.define('ExGods.stuff.stuff.Trophy', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            text: me.stuff.params.quantity,
            tooltip: me.getTitle(),
            img: ExGods.ref('images|user_stuff_icons').image.valour
        });
    },
    /**
     *   
     */
    getTitle: function() {
        return ExGods.getMsgByKey('stuff_tooltip_trophy');
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            tooltip: ExGods.getMsgByKey('stuff_tooltip_trophy'),
            img: ExGods.ref('user_hoard|trophy').image_big,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            img: ExGods.ref('user_hoard|trophy').image_big,
            title: ExGods.ref('user_hoard|trophy').label,
            description: ExGods.getMsgByKey('currency_description_trophy'),
            decorators: [],
            //
            blocks: []
        });
    },
    //
    /**
     *  - 
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('user_hoard|trophy');
        return refData.image_disabled;
    }
});

/**
 *   ""

     :

        type: "currency"
        params:
            id: "gold",
            quantity: 12            
        

 */
Ext.define('ExGods.stuff.stuff.Currency', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_money|' + me.stuff.params.id);
        return Ext.apply(data, {
            text: Ext.util.Format.number(me.stuff.params.quantity, "0,0"),
            tooltip: me.getTitle(),
            img: refData.image
        });
    },
    /**
     *   
     */
    getTitle: function() {
        var me = this;
        return ExGods.ref('user_money|' + me.stuff.params.id).label;
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_money|' + me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: refData.label,
            img: refData.image_big,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_money|' + me.stuff.params.id);
        return Ext.apply(data, {
            img: refData.image_big,
            title: refData.label,
            description: ExGods.getMsgByKey('currency_description_' + me.stuff.params.id),
            decorators: [],
            //
            blocks: []
        });
    },
    //
    /**
     *  - 
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('user_money|' + me.stuff.params.id);
        return refData.image_disabled;
    }
});

/**
 *   " "

     :

        type: "timed"
        params:
            id: "gold_chest_tries",
            quantity: 1
        

 */
Ext.define('ExGods.stuff.stuff.Timed', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_timed|' + me.stuff.params.id);
        return Ext.apply(data, {
            text: Ext.util.Format.number(me.stuff.params.quantity, "0,0"),
            tooltip: me.getTitle(),
            img: refData.img.img2
        });
    },
    /**
     *   
     */
    getTitle: function() {
        var me = this;
        return ExGods.ref('user_timed|' + me.stuff.params.id).img.label;
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_timed|' + me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: refData.img.label,
            img: refData.img.stuff,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            refData = ExGods.ref('user_timed|' + me.stuff.params.id);
        return Ext.apply(data, {
            img: refData.img.stuff,
            title: refData.img.label,
            description: refData.img.desc,
            decorators: [],
            //
            blocks: []
        });
    }
});
//

/**
 *   ""
 *

     :

        type: "item"
        params: 
            grade: 3
            id: "1894"
            quantity: 1
            slot_type: 0
            title: " "

 */
Ext.define('ExGods.stuff.stuff.Item', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            text: me.getTitle() + (me.stuff.params.quantity > 1 ? '&nbsp;(' + me.stuff.params.quantity + ')' : ''),
            tooltip: ExGods.getMsgByKey('stuff_tooltip_item'),
            img: ExGods.ref('images|user_stuff_icons').image.item
        });
    },
    /**
     *   
     */
    getTitle: function() {
        var me = this;
        return [
            '<span class="title item-grade-color-' + (me.stuff.params.grade || 1) + '">',
            me.stuff.params.title,
            '</span>'
        ].join('');
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.app.getItemPrototypesStore().getById(parseInt(me.stuff.params.id));
        return Ext.apply(data, {
            tooltip: proto.data.title,
            img: proto.data.images.info,
            protoModel: proto,
            decorators: [
                ExGods.stuff.decorator.Quantity,
                ExGods.stuff.decorator.ItemGrade
            ]
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.app.getItemPrototypesStore().getById(parseInt(me.stuff.params.id));
        return Ext.apply(data, {
            img: proto.data.images.info,
            title: proto.data.title,
            protoModel: proto,
            decorators: [
                ExGods.stuff.decorator.ItemGrade
            ],
            blocks: [
                ExGods.stuff.block.item.Stats1,
                ExGods.stuff.block.item.ExpireAfter,
                ExGods.stuff.block.item.Stats2,
                ExGods.stuff.block.item.Description,
                ExGods.stuff.block.item.ProtoFeatures
            ]
        });
    },
    /**
     *  - 
     */
    getDisabledImage: function() {
        var me = this,
            proto = ExGods.app.getItemPrototypesStore().getById(parseInt(me.stuff.params.id));
        return proto.get('images').disabled;
    }
});

/**
 *   " "

     :

        type: "kit"
        params: 
            id: "1"
            quantity: 12

 */
Ext.define('ExGods.stuff.stuff.Kit', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return Ext.apply(data, {
            text: me.getTitle() + (me.stuff.params.quantity > 1 ? '&nbsp;(' + me.stuff.params.quantity + ')' : ''),
            tooltip: proto.label,
            img: ExGods.ref('images|user_stuff_icons').image.item
        });
    },
    /**
     *   
     */
    getTitle: function() {
        var me = this,
            proto = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return '<span class="title">' + proto.label + '</span>';
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: proto.label,
            img: proto.params.image,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return Ext.apply(data, {
            img: proto.params.image,
            title: proto.label,
            //description: proto.params.description,
            decorators: []
        });
    },
    //
    /**
     *  - 
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('kit_proto|' + me.stuff.params.id);
        return refData.params.image;
    }
});

/**
 *   " "
 *

     :

        type: "iteminstance"
        params: 
            itemModel: <Object>

 */
Ext.define('ExGods.stuff.stuff.ItemInstance', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = me.stuff.params.itemModel.getProto(),
            quantity = me.stuff.params.itemModel.data.count;
        return Ext.apply(data, {
            text: me.getTitle() + (quantity > 1 ? '&nbsp;(' + quantity + ')' : ''),
            tooltip: ExGods.getMsgByKey('stuff_tooltip_item'),
            img: ExGods.ref('images|user_stuff_icons').image.item
        });
    },
    /**
     *   
     */
    getTitle: function() {
        var me = this,
            proto = me.stuff.params.itemModel.getProto();
        return [
            '<span class="title item-grade-color-' + (proto.data.data.item_grade || 1) + '">',
            proto.data.title,
            '</span>'
        ].join('');
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = me.stuff.params.itemModel.getProto();
        return Ext.apply(data, {
            tooltip: proto.data.title,
            img: proto.data.images.info,
            protoModel: proto,
            itemModel: me.stuff.params.itemModel,
            decorators: [
                ExGods.stuff.decorator.ItemGrade
            ]
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = me.stuff.params.itemModel.getProto();
        return Ext.apply(data, {
            img: proto.data.images.info,
            title: proto.data.title,
            protoModel: proto,
            itemModel: me.stuff.params.itemModel,
            decorators: [
                ExGods.stuff.decorator.ItemGrade
            ],
            blocks: [
                ExGods.stuff.block.item.Stats1,
                ExGods.stuff.block.item.ExpireTimer,
                ExGods.stuff.block.item.Stats2,
                ExGods.stuff.block.item.Description,
                ExGods.stuff.block.item.ProtoFeatures,
                ExGods.stuff.block.item.Features
            ]
        });
    }
});

/**
 *   ""

     :

        type: "ingredients"
        params: 
            id: "ore_1"
            quantity: 12

 */
Ext.define('ExGods.stuff.stuff.Ingredient', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('ingredients|' + me.stuff.params.id);
        return Ext.apply(data, {
            text: me.getTitle() + (me.stuff.params.quantity > 1 ? '&nbsp;(' + me.stuff.params.quantity + ')' : ''),
            tooltip: proto.label,
            img: ExGods.ref('images|user_stuff_icons').image.item
        });
    },
    /**
     *   
     */
    getTitle: function() {
        var me = this,
            proto = ExGods.ref('ingredients|' + me.stuff.params.id);
        return '<span class="title">' + proto.label + '</span>';
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('ingredients|' + me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: proto.label,
            img: proto.params.images.img_1,
            decorators: [
                ExGods.stuff.decorator.Quantity
            ]
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.ref('ingredients|' + me.stuff.params.id);
        return Ext.apply(data, {
            img: proto.params.images.img_1,
            title: proto.label,
            description: proto.params.description,
            decorators: []
        });
    },
    //
    /**
     *  - 
     */
    getDisabledImage: function() {
        var me = this,
            refData = ExGods.ref('ingredients|' + me.stuff.params.id);
        return refData.params.images.img_2;
    }
});

/**
 *   ""
 *

     :

        type: "feature"
        params: 
            grade: 3
            id: "1894"
            quantity: 1
            slot_type: 0
            title: " "

 */
Ext.define('ExGods.stuff.stuff.Feature', {
    extend: ExGods.stuff.Stuff,
    /**
     *     .
     */
    getPrintData: function() {
        var me = this,
            data = me.callParent(arguments);
        return Ext.apply(data, {
            text: me.getTitle(),
            tooltip: ExGods.getMsgByKey('stuff_tooltip_item'),
            img: ExGods.ref('images|user_stuff_icons').image.buff
        });
    },
    /**
     *   
     */
    getTitle: function() {
        var me = this;
        return [
            '<span class="title item-grade-color-' + (me.stuff.params.grade || 1) + '">',
            me.stuff.params.title,
            '</span>'
        ].join('');
    },
    /**
     *      .
     */
    getImageData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.app.getFeaturePrototypesStore().getById(me.stuff.params.id);
        return Ext.apply(data, {
            tooltip: proto.data.label,
            img: proto.data.images.main
        });
    },
    /**
     *      
     */
    getDetailsData: function() {
        var me = this,
            data = me.callParent(arguments),
            proto = ExGods.app.getFeaturePrototypesStore().getById(me.stuff.params.id);
        return Ext.apply(data, {
            img: proto.data.images.main,
            title: proto.data.label,
            description: proto.data.description,
            decorators: [],
            // 
            blocks: []
        });
    },
    //
    /**
     *  - 
     */
    getDisabledImage: function() {
        var me = this,
            proto = ExGods.app.getFeaturePrototypesStore().getById(me.stuff.params.id);
        return proto.get('images').main;
    }
});

/**
 *  ""
 */
Ext.define('ExGods.stuff.decorator.Disabled', {
    extend: ExGods.stuff.Decorator,
    statics: {
        /**
         * @override
         */
        getCls: function(data) {
            return 'exg-stuff-decorator-disabled';
        }
    }
});

/**
 *  ""
 */
Ext.define('ExGods.stuff.decorator.BonusStick', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="exg-stuff-decorator-bonusstick exg-stuff-decorator-bonusstick-image"></div>';
        }
    }
});

/**
 *  ""
 */
Ext.define('ExGods.stuff.decorator.SaleStick', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="exg-stuff-decorator-salestick exg-stuff-decorator-salestick-image"></div>';
        }
    }
});

/**
 *  ""
 */
Ext.define('ExGods.stuff.decorator.BestStick', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="exg-stuff-decorator-beststick exg-stuff-decorator-beststick-image"></div>';
        }
    }
});

/**
 *  ""
 */
Ext.define('ExGods.stuff.decorator.Quantity', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var quantity = this.getQuantity(data);
            if (quantity) {
                return '<div class="exg-stuff-decorator-quantity-counter"><span>' + quantity + '</span></div>';
            }
        },
        /**
         *  - .      -  false
         */
        getQuantity: function(data) {
            var quantity = data.stuff.params.quantity;
            if (quantity) {
                if (quantity == 1 && (data.stuff.type == 'item' || data.stuff.type == 'iteminstance')) {
                    return false;
                } else {
                    return quantity;
                }
            }
        }
    }
});

/**
 *  "  "
 */
Ext.define('ExGods.stuff.decorator.ItemGrade', {
    extend: ExGods.stuff.Decorator,
    inheritableStatics: {
        decorateAfter: function(data) {
            var html = '',
                grade = this.getGrade(data);
            if (grade) {
                html += '<div class="exg-stuff-decorator-itemgrade" style="width:' + (14 * grade) + 'px;"></div>';
            }
            return html;
        },
        /**
         *    .
         */
        getGrade: function(data) {
            if (data.itemModel && data.itemModel.isUpgraded()) {
                return data.itemModel.get('param').upgrades;
            } else {
                var proto = ExGods.app.getItemPrototypesStore().getById(parseInt(data.stuff.params.id));
                if (proto) {
                    return proto.get('param').upgrades;
                }
            }
        }
    }
});

/**
 *    , , 

    Note:      protoModel ,  , itemModel

 */
Ext.define('ExGods.stuff.block.item.Stats1', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        getContent: function(data) {
            var content = [];
            content.push(this.getLevel(data));
            content.push(this.getPrice(data));
            content.push(this.getDur(data));
            content = Ext.Array.clean(content);
            return content.length ? content : false;
        },
        getLevel: function(data) {
            if (data.protoModel.data.data.strict.level) {
                return [
                    ExGods.ref('user_hoard|level').label,
                    '',
                    data.protoModel.data.data.strict.level
                ];
            }
        },
        getPrice: function(data) {
            if (data.protoModel.data.data.price) {
                return [
                    ExGods.getMsgByKey('price_text'),
                    ExGods.util.Format.printMoney({
                        name: 'gold'
                    }),
                    data.protoModel.data.data.price
                ];
            }
        },
        getDur: function(data) {
            var type = ExGods.ref('item_type').getByKey(data.protoModel.data.type),
                breakable, label, value;
            if (data.itemModel && typeof data.itemModel.get('param').nonbr != 'undefined') {
                breakable = !parseInt(data.itemModel.get('param').nonbr);
            } else if (typeof data.protoModel.data.param.nonbr != 'undefined') {
                breakable = !parseInt(data.protoModel.data.param.nonbr);
            } else {
                breakable = !parseInt(type.param.nonbr);
            }
            if (breakable) {
                label = ExGods.getMsgByKey('durability');
                value = (data.itemModel ? data.itemModel.getDur() + '/' : '') + data.protoModel.data.param.dur;
                if (data.itemModel && data.itemModel.hasCriticalDurability()) {
                    label = '<span class="exg-stuff-criticaldur">' + label + '</span>';
                    value = '<span class="exg-stuff-criticaldur">' + value + '</span>';
                }
                return [
                    label,
                    '',
                    value
                ];
            }
        }
    }
});

/**
 *    , ,  ..

    Note:      protoModel ,  , itemModel

 */
Ext.define('ExGods.stuff.block.item.Stats2', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        getContent: function(data) {
            var content,
                stats = this.getItemStats(data);
            content = ExGods.util.User.printUserStats(stats, {
                visibleValue: 1,
                align: 'right',
                changes: this.getStatsChanged(data),
                maxStats: this.getStatsMax(data)
            });
            if (ExGods.util.User.printUserStats(stats, {
                visibleValue: 2
            })) {
                content += '<div style="padding: 5px 0 0 0;">' + ExGods.util.User.printUserStats(stats, {
                    visibleValue: 2
                }) + '</div>';
            }
            return content;
        },
        /**
         *    
         */
        getItemStats: function(data) {
            var itemStats = Ext.apply({}, data.protoModel.data.data.stats);
            if (data.itemModel && data.itemModel.data.param.stat) {
                Ext.Object.each(data.itemModel.data.param.stat, function(key, value) {
                    itemStats[key] = (itemStats[key] || 0) + value;
                });
            }
            return itemStats;
        },
        /**
         *          
         */
        getStatsChanged: function(data) {
            if (data.itemModel && data.itemModel.get('clothed')) {
                return {};
            }
            var protoTypeInfo = data.protoModel.getTypeInfo(),
                clothedItem = null,
                clothedItemStats = {},
                itemStats = {},
                changes = {};
            ExGods.app.user.slots().each(function(slot) {
                if (slot.data.type == protoTypeInfo.slot_on) {
                    clothedItem = slot.items().first();
                }
            });
            if (clothedItem) {
                //      ,   
                clothedItemStats = Ext.clone(clothedItem.getProto().data.data.stats);
                Ext.Object.each(clothedItem.data.param.stat, function(key, value) {
                    clothedItemStats[key] += value;
                });
                //   
                itemStats = this.getItemStats(data);
                //  
                Ext.Object.each(itemStats, function(key, value) {
                    changes[key] = value - clothedItemStats[key] || 0;
                });
            }
            return changes;
        },
        /**
         *     
         */
        getStatsMax: function(data) {
            return {};
        }
    }
});

/**
 *   ,       .
 *
 */
Ext.define('ExGods.stuff.block.item.ProtoFeatures', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        featureTpl: [
            '<div class="feature cf {[ Ext.isNumeric(values.feature.grade) ? "graded" : "" ]}">',
            '<tpl if="feature.images">',
            '<div class="image"><img src="{[ this.printImageUrl(values) ]}" /></div>',
            '</tpl>',
            '<div class="info">',
            '<div class="label item-grade-color-{item.grade}">{feature.label}</div>',
            '<tpl if="Ext.isNumeric(values.feature.grade)">',
            '<div class="grade">',
            '<div class="grade-inner" style="width: {[ ExGods.ref("constants|item_feature_stars").value*14 ]}px;">',
            '<div style="width: {[ 14*values.feature.grade ]}px"></div>',
            '</div>',
            '</div>',
            '</tpl>',
            '<div class="desc">{feature.description2}</div>',
            '</div>',
            '</div>',
            {
                printImageUrl: function(values) {
                    return IMAGE_URL + values.feature.images.main;
                }
            }
        ],
        /**
         * @override
         */
        getCls: function(data) {
            return 'exg-stuff-feature-block';
        },
        /**
         * @override
         */
        getContent: function(data) {
            var features = this.getFeaturesData(data),
                html = [],
                featureTpl;
            if (!this.compiledFeatureTpl) {
                this.compiledFeatureTpl = new Ext.XTemplate(this.featureTpl);
            }
            featureTpl = this.compiledFeatureTpl;
            features.forEach(function(feature) {
                html.push(featureTpl.apply({
                    item: {
                        grade: data.protoModel.data.data.item_grade || 1
                    },
                    feature: feature
                }));
            });
            return html.join('<div class="exg-stuff-block-separator"></div>');
        },
        /**
         *   
         */
        getFeaturesData: function(data) {
            var features = [];
            Ext.Array.each(data.protoModel.get('action_full') || [], function(action) {
                if (action.type == 'feature' && (!action.only_proto || !data.itemModel)) {
                    features.push(action);
                }
            });
            return features;
        }
    }
});

/**
 *     (itemModel.data.features)
 *
 */
Ext.define('ExGods.stuff.block.item.Features', {
    extend: ExGods.stuff.block.item.ProtoFeatures,
    inheritableStatics: {
        /**
         * @override
         */
        getFeaturesData: function(data) {
            return data.itemModel.data.features || [];
        }
    }
});

/**
 *        ( : ..)
 *
 */
Ext.define('ExGods.stuff.block.item.ExpireAfter', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        /**
         * @override
         */
        getContent: function(data) {
            var expireTime = this.getExpirationTime(data);
            if (expireTime) {
                return [
                    [
                        ExGods.getMsgByKey('item_expire_after'),
                        '',
                        ExGods.util.Time.printRestTime(expireTime, {
                            format: 'twonums'
                        })
                    ]
                ];
            }
        },
        /**
         *        ()
         */
        getExpirationTime: function(data) {
            var me = this,
                expire_after = data.protoModel.data.data.expire_after,
                validto = data.protoModel.data.data.validto;
            if (expire_after) {
                expire_after = ExGods.util.Date.parseString(expire_after) || Infinity;
            } else  {
                expire_after = Infinity;
            }
            
            if (validto) {
                validto = ExGods.util.Date.parseString(validto) || Infinity;
            } else  {
                validto = Infinity;
            }
            
            if (expire_after !== Infinity || validto !== Infinity) {
                return ExGods.util.Date.normalizeServerDateTime(new Date(Math.min(expire_after, validto)));
            }
        }
    }
});

/**
 *        ( : ..)
 *
 */
Ext.define('ExGods.stuff.block.item.ExpireTimer', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        /**
         * @override
         */
        getContent: function(data) {
            var expireTime = this.getExpirationTime(data);
            if (expireTime) {
                return [
                    [
                        ExGods.getMsgByKey('item_validto_label'),
                        '',
                        ExGods.util.Timers.printRestTimer('exg-stuff-item-timer', expireTime, {
                            format: 'twonums'
                        })
                    ]
                ];
            }
        },
        /**
         *        ()
         */
        getExpirationTime: function(data) {
            var me = this,
                expire_str = data.itemModel.data.param.expire_str,
                validto = data.protoModel.data.data.validto;
            if (expire_str) {
                expire_str = ExGods.util.Date.parseString(expire_str) || Infinity;
            } else  {
                expire_str = Infinity;
            }
            
            if (validto) {
                validto = ExGods.util.Date.parseString(validto) || Infinity;
            } else  {
                validto = Infinity;
            }
            
            if (expire_str !== Infinity || validto !== Infinity) {
                return ExGods.util.Date.normalizeServerDateTime(new Date(Math.min(expire_str, validto)));
            }
        }
    }
});

/**
 *    
 *
 */
Ext.define('ExGods.stuff.block.item.Description', {
    extend: ExGods.stuff.Block,
    inheritableStatics: {
        /**
         * @override
         */
        getContent: function(data) {
            var desc = data.protoModel.data.data.description;
            if (desc) {
                return ExGods.app.applyTpl(desc, {
                    item: data.itemModel,
                    itemPrototype: data.protoModel
                });
            }
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.stuff.StuffManager', {
    extend: Ext.util.Observable,
    singleton: true,
    mixins: {
        loggable: ExGodsCore.util.Loggable
    },
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'StuffManager:'
    },
    constructor: function(config) {
        var me = this;
        me.mixins.loggable.constructor.call(me, config);
        me.types = {};
        me.objects = [];
        me.callParent(arguments);
        //     
        me.register('expa', ExGods.stuff.stuff.Expa);
        me.register('trophy', ExGods.stuff.stuff.Trophy);
        me.register('currency', ExGods.stuff.stuff.Currency);
        me.register('timed', ExGods.stuff.stuff.Timed);
        me.register('item', ExGods.stuff.stuff.Item);
        me.register('kit', ExGods.stuff.stuff.Kit);
        me.register('iteminstance', ExGods.stuff.stuff.ItemInstance);
        me.register('ingredients', ExGods.stuff.stuff.Ingredient);
        me.register('feature', ExGods.stuff.stuff.Feature);
        //     
        Ext.getBody().on('click', function(e, t) {
            if (e.getTarget('.exg-stuff-details') && !Ext.fly(t).up('.exg-stuff-collection')) {
                return;
            }
            me.onStuffClick(Ext.get(t));
        }, me, {
            delegate: '.exg-stuff-item'
        });
        me.registerTooltipSource();
        //   
        me.gc();
    },
    /**
     *       .
     * @param type {String}  
     * @param classObj {Ext.Class}  .
     * @param listeners {Object}        {<event_name>: <event_handler>}
     */
    register: function(type, classObj, listeners) {
        var me = this;
        if (Ext.isObject(type)) {
            Ext.Object.each(type, function(key, value) {
                if (value.classObj) {
                    me.register(key, value.classObj, value.listeners);
                } else {
                    me.register(key, value);
                }
            });
            return;
        }
        me.types[type] = {
            classObj: classObj,
            listeners: listeners
        };
    },
    /**
     *   
     * @param stuff {Object}    
     * @param isInnerObject {Boolean}    .      
     * -,    -   (ExGods.stuff.StuffManager)
     */
    factory: function(stuff, isInnerObject) {
        var me = this;
        if (me.types[stuff.type]) {
            obj = new me.types[stuff.type].classObj({
                stuff: stuff
            });
            if (!isInnerObject) {
                me.objects.push(obj);
                obj.on('action', me.actionHandler, me);
            }
            return obj;
        } else {
            /****/
            me.log('warn', '@factory   "' + stuff.type + '"  ');
        }
    },
    /**
     *     
     * @param stuff {Mixed}     
     * @return {String}
     */
    print: function(stuff) {
        var me = this,
            obj, html;
        stuff = this.normalize(stuff);
        if (Ext.isArray(stuff)) {
            return (new ExGods.stuff.StuffCollection({
                stuff: stuff
            })).print();
        } else {
            obj = me.factory(stuff);
            if (obj) {
                try {
                    html = obj.print();
                    return html;
                } catch (e) {
                    /***/
                    me.log('error', '@print    ', e, stuff);
                }
            }
        }
    },
    /**
     *     
     * @param stuff {Object}  
     * @return {String}
     */
    image: function(stuff) {
        var me = this,
            obj, html;
        stuff = this.normalize(stuff);
        if (Ext.isArray(stuff)) {
            return (new ExGods.stuff.StuffCollection({
                stuff: stuff
            })).image();
        } else {
            obj = me.factory(stuff);
            if (obj) {
                try {
                    html = obj.image();
                    return html;
                } catch (e) {
                    /***/
                    me.log('error', '@image    ', e, stuff);
                }
            }
        }
    },
    /**
     *     
     * @param stuff {Object}  
     * @return {String}
     */
    title: function(stuff) {
        var me = this,
            obj, html;
        stuff = this.normalize(stuff);
        if (Ext.isArray(stuff)) {
            return (new ExGods.stuff.StuffCollection({
                stuff: stuff
            })).getTitle();
        } else {
            obj = me.factory(stuff);
            if (obj) {
                try {
                    html = obj.getTitle();
                    return html;
                } catch (e) {
                    /***/
                    me.log('error', '@image    ', e, stuff);
                }
            }
        }
    },
    /**
     *      
     * @param stuff {Object}  
     * @return {String}
     */
    details: function(stuff) {
        var me = this,
            obj, html;
        stuff = this.normalize(stuff);
        if (Ext.isArray(stuff)) {
            return (new ExGods.stuff.StuffCollection({
                stuff: stuff
            })).details({
                asHTML: true
            });
        } else {
            obj = me.factory(stuff);
            if (obj) {
                try {
                    html = obj.details({
                        asHTML: true
                    });
                    return html;
                } catch (e) {
                    /***/
                    me.log('error', '@details    ', e, stuff);
                }
            }
        }
    },
    /**
     *    
     */
    onStuffClick: function(el) {
        var me = this,
            obj = me.getObjectById(el.id);
        if (obj) {
            obj.clicks = obj.clicks ? obj.clicks + 1 : 1;
            me.stuffClickHandler(obj, el);
        } else {
            /***/
            me.log('warn', '@stuffClickHandler      ', el);
        }
    },
    /**
     *    
     */
    stuffClickHandler: Ext.Function.createBuffered(function(obj, el) {
        var me = this;
        if (obj.clicks > 1 && obj.getDblClickAction()) {
            me.actionHandler(obj, obj.getDblClickAction(), null, null);
        } else {
            obj.details({
                clickedEl: el
            });
        }
        obj.clicks = 0;
    }, 200),
    /**
     *      
     */
    actionHandler: function(obj, actionName, btn, win) {
        var me = this;
        if (actionName === false)  {
            return;
        }
        
        if (me.types[obj.stuff.type]) {
            if (me.types[obj.stuff.type].listeners && me.types[obj.stuff.type].listeners[actionName]) {
                me.types[obj.stuff.type].listeners[actionName].call(me.types[obj.stuff.type].listeners.scope || me, obj, btn, win);
            } else {
                /****/
                me.log('warn', '@actionHandler   ' + actionName + '  ' + obj.stuff.type + '  ');
            }
        }
    },
    /**
     *     id
     */
    getObjectById: function(id) {
        var me = this,
            obj;
        for (var i = 0; i < me.objects.length; i++) {
            if (me.objects[i].id == id) {
                obj = me.objects[i];
                break;
            }
        }
        return obj;
    },
    /**
     *      ,       .
     * ,      ,  {type: "currency", params: [<data1>,<data2>, etc]},    
     *     currency
     */
    normalize: function(stuff) {
        var me = this,
            result;
        if (Ext.isObject(stuff)) {
            if (stuff.type && stuff.params) {
                if (Ext.isArray(stuff.params)) {
                    result = [];
                    Ext.Array.each(stuff.params, function(item) {
                        result.push({
                            type: stuff.type,
                            params: item
                        });
                    });
                } else {
                    result = stuff;
                }
            } else {
                /***/
                me.log('error', '@normalize:     ', stuff);
            }
        } else if (Ext.isArray(stuff)) {
            result = [];
            Ext.Array.each(stuff, function(item) {
                var normalizedStuff = me.normalize(item);
                if (Ext.isArray(normalizedStuff)) {
                    result = result.concat(normalizedStuff);
                } else {
                    result.push(normalizedStuff);
                }
            });
        } else {
            /***/
            me.log('error', '@normalize:     ', stuff);
        }
        return result;
    },
    /**
     *   
     */
    gc: function() {
        var me = this,
            els = [],
            liveIds;
        setInterval(function() {
            liveIds = [];
            els = Ext.select('.exg-stuff-item').elements;
            for (var i = 0; i < els.length; i++) {
                liveIds.push(els[i].id);
            }
            for (var j = 0; j < me.objects.length; j++) {
                if (liveIds.indexOf(me.objects[j].id) == -1) {
                    me.objects[j] = null;
                }
            }
            me.objects = Ext.Array.clean(me.objects);
        }, 10 * 1000);
    },
    /**
     *        "stuff"
     */
    registerTooltipSource: function() {
        var me = this,
            interval,
            times = 0;
        interval = setInterval(function() {
            if (!ExGods.app || !ExGods.app.getController('TooltipManager')) {
                if (++times > 10) {
                    clearInterval(interval);
                }
            } else {
                ExGods.app.getController('TooltipManager').register(me, 'stuff');
                clearInterval(interval);
            }
        }, 1000);
    },
    // ,     
    /**
     *    
     */
    getTooltipData: function(type, value) {
        var me = this;
        return this.getObjectById(value);
    }
});

//@define ExGods.util.Stuff
/**
 *   
 * @author  
 */
Ext.ns('ExGods.util');
ExGods.util.Stuff = {
    /**
     * @property templates   
     */
    templates: {
        currency: function(item, ref) {
            var params = Ext.isArray(item.params) ? item.params : [
                    item.params
                ],
                //      
                html = [];
            Ext.Array.each(params, function(param) {
                html.push('<span data-qtip="' + ref.currency.get(param.id).label + '">' + '<span style="white-space: nowrap;">' + '<img src="' + ref.currency.get(param.id).image + '"/>' + Ext.util.Format.number(param.quantity, "0,0") + '</span>' + '</span>');
            });
            return html.join('');
        },
        expa: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_experience') + '" class="item-tpl" style="background-image: url(' + ref.icons.image.exp + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        valour: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_valour') + '" class="item-tpl" style="background-image: url(' + ref.icons.image.valour + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        item: function(item, ref, options) {
            var cls = options.simple ? '' : 'class="item" ',
                style = [
                    'color:' + ExGods.references.get('constants_list').item_grades.value[Number(item.params.grade) - 1 || 0]
                ];
            //if(!options.simple){
            style.push('background-image: url(' + ref.icons.image.item + ')');
            //}
            style = ' style="' + style.join(';') + '"';
            return '<span ' + cls + 'data-proto_id="' + (item.params.id || item.params.entry) + '">' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_item') + '" class="item-tpl ' + (options.simple ? '' : 'decorated ') + '"' + style + '>' + item.params.title + (item.params.quantity > 1 ? '</span>(' + item.params.quantity + ')' : '</span>') + '</span>';
        },
        ability: function(item, ref) {
            return '<span class="ability" data-ability_id="' + item.params.id + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        feature: function(item, ref) {
            return '<span class="feature" data-feature_id="' + item.params.id + '">' + "<span data-qtip=''+ ref.messages.get('stuff_tooltip_feature') +'' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.buff + ")'>" + item.params.title + '</span>' + '</span>';
        },
        timed: function(item, ref) {
            var img = ref.timed.get(item.params.id).img || {};
            return '<span>' + '<span data-qtip="' + ref.stats.get(item.params.id).label + '" class="item-tpl" style="background-image: url(' + IMAGE_URL + img.stuff + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        trophy: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_trophy') + '" class="item-tpl" style="background-image: url(' + IMAGE_URL + 'icons/ico_trophy.png)">' + item.params.quantity + '</span>' + '</span>';
        },
        ingredients: function(item, ref) {
            var label = ref.ingredients.get(item.params.id).label;
            return '<span>' + '<span data-qtip="' + label + '" class="item-tpl decorated clickable" style="background-image: url(' + ref.icons.image.item + ')"">' + label + (item.params.quantity > 1 ? '</span>(' + item.params.quantity + ')' : '</span>') + '</span>' + '</span>';
        }
    },
    /**
     *      HTML 
     * @param {Array} stuff   ,    :
     * 
     *   [{
     *      type: {String}  ,
     *      params: {
     *          id: {String}  
     *          quantity {Number}  
     *          title {String} ,   
     *          label {String} ,   
     *      }
     *   }]
     *
     * @param {Object} options .  :
     *
     *    display = "inline"|"block".      (display = 'inline').
     *                                     display = 'block'
     *
     *    delimiter {String}.  .   "&nbsp;"
     * 
     * @return {String}
     */
    printStuff: function(stuff, options) {
        if (!stuff)  {
            return '';
        }
        
        //   ,    
        if (stuff.stuff) {
            stuff = stuff.stuff;
        }
        //     . ({discount, old, stuff}).   ,   
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        options = Ext.applyIf(options || {}, {
            display: 'inline',
            delimiter: '&nbsp;'
        });
        var ref = {
                currency: ExGods.ref('user_money'),
                timed: ExGods.ref('user_timed'),
                stats: ExGods.ref('user_stat'),
                icons: ExGods.ref('images').get('user_stuff_icons'),
                ingredients: ExGods.ref('ingredients'),
                messages: ExGods.ref('message_client')
            },
            html = [],
            tplFn;
        Ext.each(stuff, function(item) {
            if (Ext.isObject(item) && !Ext.Object.isEmpty(item)) {
                tplFn = ExGods.util.Stuff.templates[item.type];
                if (tplFn) {
                    html = html.concat(tplFn(item, ref, options));
                } else {
                    /***/
                    ExGods.app.log('error', '    ' + item.type + '  .');
                }
            }
        });
        if (html.length > 1) {
            return '<ul class="exg-stuff exg-stuff-' + options.display + '">' + '<li>' + html.join(options.delimiter + '</li><li>') + '</li>' + '</ul>';
        } else {
            return '<span class="exg-stuff exg-stuff-' + options.display + '">' + html + '</span>';
        }
    }
};

//@define ExGods.util.Stuff2
/**
 *   
 * @author  
 */
Ext.ns('ExGods.util');
Ext.require([
    'ExGods.util.Stuff'
], function() {
    ExGods.util.Stuff2 = {
        /**
     *       
     * @params {Object} itemParams      (id, title, quantity, grade)
     * @params {Object} options
     *          disabledImage {Boolean}   
     *          checkUser {Boolean}     ,    -  
     *          noSort {Boolean}      
     *          skulls {Boolean}     
     * @return {String}
     */
        printBigRewards: function(all_stuff, options) {
            var me = this,
                protos = ExGods.app.getItemPrototypesStore(),
                items = curency = '',
                missedProtos = [],
                items_count = 0,
                sorterFn = function(rewards) {
                    return Ext.Array.sort(rewards, function(a, b) {
                        if (a.type == b.type)  {
                            return 0;
                        }
                        
                        if (a.type == 'item')  {
                            return 1;
                        }
                        
                        if (b.type == 'item')  {
                            return -1;
                        }
                        
                        if (a.type == 'trophy')  {
                            return -1;
                        }
                        
                        if (b.type == 'trophy')  {
                            return 1;
                        }
                        
                        if (a.type == 'expa')  {
                            return -1;
                        }
                        
                        if (b.type == 'expa')  {
                            return 1;
                        }
                        
                        if (a.type == 'valour')  {
                            return -1;
                        }
                        
                        if (b.type == 'valour')  {
                            return 1;
                        }
                        
                        if (a.type == 'currency')  {
                            return -1;
                        }
                        
                        if (b.type == 'currency')  {
                            return 1;
                        }
                        
                        if (a.type == 'ability')  {
                            return -1;
                        }
                        
                        if (b.type == 'ability')  {
                            return 1;
                        }
                        
                        if (a.type == 'feature')  {
                            return -1;
                        }
                        
                        if (b.type == 'feature')  {
                            return 1;
                        }
                        
                        if (a.type == 'timed')  {
                            return -1;
                        }
                        
                        if (b.type == 'timed')  {
                            return 1;
                        }
                        
                        return 1;
                    });
                };
            options = options || {};
            all_stuff = Ext.isArray(all_stuff) ? all_stuff : [
                all_stuff
            ];
            if (!options.noSort) {
                all_stuff = sorterFn(all_stuff);
            }
            for (var i = 0; i < all_stuff.length; i++) {
                var item_stuff = all_stuff[i];
                if (item_stuff.type == 'item' && item_stuff.item) {
                    //    
                    var proto_id = parseInt(item_stuff.params.id),
                        item = protos.data.getByKey(proto_id);
                    var stars = '<div class="upgrade_stars_container">';
                    for (var j = 0; j < item_stuff.item.param.upgrades; j++) {
                        stars += '<div class="upgrade_star"></div>';
                    }
                    stars += '</div>';
                    if (item) {
                        items += '<div class="info-box-itembox item" id="item_proto_' + proto_id + '" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + (item_stuff.params.quantity > 1 ? item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>' : '') + (item_stuff.item.param.upgrades ? stars : '') + '</div>';
                        items_count++;
                    } else {
                        missedProtos.push(proto_id);
                    }
                } else if (item_stuff.type == 'item' && options.skulls) {
                    var proto_id = parseInt(item_stuff.params.id),
                        item = protos.data.getByKey(proto_id);
                    if (item) {
                        items += '<div class="info-box-itembox item" id="item_proto_' + proto_id + '" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + '<span class="stack-counter big_counter"><span class="big_counter_mid"><span class="skull"><div></div>x ' + (item_stuff.params.quantity || 1) + '</span></span></span>' + '</div>';
                        items_count++;
                    } else {
                        missedProtos.push(proto_id);
                    }
                } else if (item_stuff.type == 'item') {
                    var proto_id = parseInt(item_stuff.params.id),
                        item = protos.data.getByKey(proto_id),
                        valid = options.checkUser && !ExGods.app.user.checkStuff([
                            item_stuff
                        ]),
                        haveItems = ExGods.app.user.getItemsCountByProto(proto_id);
                    if (item) {
                        items += '<div class="info-box-itembox item" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" ' + (valid ? 'class="missed-item" ' : '') + 'src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + ((item_stuff.params.quantity > 1 || options.checkUser) ? (item_stuff.params.quantity < 99 && !options.checkUser) ? ('<span class="stack-counter' + (valid ? ' red_color' : '') + '">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid' + (valid ? ' red_color' : (options.checkUser ? ' green_color' : '')) + '">' + (options.checkUser ? haveItems + '/' : '') + item_stuff.params.quantity + '</span></span>' : '') + (item_stuff.params.extra ? '<div class="extra-expa" style="background-image:url(' + ExGods.ref('images|common_text_images').image.bonus_on_items + ')"></div>' : '') + '</div>';
                        items_count++;
                    } else {
                        missedProtos.push(proto_id);
                    }
                } else if (item_stuff.type == 'currency') {
                    var proto = ExGods.ref('user_money|' + item_stuff.params.id);
                    items += '<div class="info-box-itembox item" data-big_stuff_img="' + proto.image_big + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.params.id + '" data-qtip="' + proto.label + '">' + '<img height="64" src="' + (options.disabledImage ? proto.image_disabled : proto.image_big) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa" style="background-image:url(' + ExGods.ref('images|common_text_images').image.bonus_on_items + ')"></div>' : '') + '</div>';
                    items_count++;
                } else if (item_stuff.type == 'ingredients') {
                    var proto = ExGods.ref('ingredients|' + item_stuff.params.id);
                    items += '<div class="info-box-itembox item" data-big_stuff_id = "' + item_stuff.params.id + '" data-big_stuff_img="' + IMAGE_URL + proto.params.images.img_1 + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="ingredients" data-qtip="' + proto.label + '">' + '<img height="64" src="' + IMAGE_URL + (options.disabledImage ? proto.params.images.img_2 : proto.params.images.img_1) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa" style="background-image:url(' + ExGods.ref('images|common_text_images').image.bonus_on_items + ')"></div>' : '') + '</div>';
                    items_count++;
                } else if (item_stuff.type == 'expa' || item_stuff.type == 'trophy') {
                    var proto = ExGods.ref('user_hoard|' + item_stuff.type),
                        image = options.disabledImage ? proto.image_disabled : proto.image_big;
                    items += '<div class="info-box-itembox item"  data-big_stuff_img="' + proto.image_big + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.type + '" data-qtip="' + proto.label + '">' + '<img height="64" src="' + (options.disabledImage ? proto.image_disabled : proto.image_big) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa" style="background-image:url(' + ExGods.ref('images|common_text_images').image.bonus_on_items + ')"></div>' : '') + '</div>';
                    items_count++;
                } else if (item_stuff.type == 'timed') {
                    var proto = ExGods.ref('user_timed|' + item_stuff.params.id),
                        timed = ExGods.app.user.get('timed')[item_stuff.params.id],
                        valid = options.checkUser && !ExGods.app.user.checkStuff([
                            item_stuff
                        ]),
                        image = IMAGE_URL + proto.img.stuff,
                        //options.disabledImage ? proto.image_disabled : proto.image_big;
                        label = proto.img.label,
                        desc = proto.img.desc;
                    /**
                 * timed - array
                 * timed[0] - Math.floor -  
                 * timed[1] -  
                 * timed[2] -   (   )
                 * timed[3] -   +1 ( 1426066955)
                 */
                    items += '<div class="info-box-itembox item" data-big_stuff_img="' + image + '" data-big_stuff_desc="' + Ext.String.htmlEncode(desc) + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.type + '" data-qtip="' + label + '">' + '<img class="' + (valid ? 'class="missed-item" ' : '') + '" height="64" src="' + image + '" width="64" />' + '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>' + '</div>';
                    items_count++;
                } else if (item_stuff.type == 'feature') {
                    var proto = ExGods.app.getFeaturePrototypesStore().getById(item_stuff.params.id);
                    if (proto) {
                        items += '<div class="info-box-itembox item feature" data-feature_id="' + item_stuff.params.id + '" data-qtip="' + proto.data.label + '">' + '<div style="background-image: url(' + IMAGE_URL + proto.data.images.main + ');"></div>' + '</div>';
                        items_count++;
                    }
                } else if (item_stuff.type == 'action') {
                    var proto = ExGods.ref("direct_actions|" + item_stuff.params.id);
                    if (proto) {
                        items += '<div class="info-box-itembox item action-item" data-action_id="' + item_stuff.params.id + '" data-qtip="' + proto.images.name + '">' + '<div style="background-image: url(' + IMAGE_URL + proto.images.simple + ');"></div>' + '</div>';
                        items_count++;
                    }
                } else {
                    curency += ExGods.util.Stuff.printStuff(item_stuff) + '&nbsp;';
                }
            }
            return {
                items: items,
                currency: curency,
                missedProtos: missedProtos,
                itemsCount: items_count
            };
        },
        printBigStuff: function(stuff, options) {
            stuff = Ext.isArray(stuff) ? stuff : [
                stuff
            ];
            return ExGods.util.Stuff2.printBigRewards(stuff, options).items;
        }
    };
});

//@define ExGods.util.User
/**
 *    
 * @author  
 */
Ext.ns('ExGods.util');
ExGods.util.User = {
    /**
     *    (, , )
     * @param {Object} user  
     * @param {Object} options :
     *  
     *  fields -  ,   .  , ['name', 'rank', 'level', 'infoicon'].    ,  
     *            : 'name', 'rank', 'level', 'infoicon', 'guild'
     *
     *  maxNameWidth -      .    .
     *
     *  cls - css ,     
     *
     *  hideLevelIcon -   
     *
     */
    printUser: function(user, options) {
        var tpl;
        options = Ext.applyIf(options || {}, {
            fields: 'name, rank, level, infoicon',
            cls: ''
        });
        if (typeof options.fields == 'string') {
            options.fields = Ext.Array.map(options.fields.split(','), function(item) {
                return Ext.String.trim(item);
            });
        }
        if (!ExGods.util.User.userinfoTpl) {
            ExGods.util.User.userinfoTpl = new Ext.XTemplate([
                '<span class="userinfo {options.cls} {[this.getCls(values.user)]}" style="{[this.getStyle(values.user)]}" data-uname="{user.display_title}" data-urace="{user.race}">',
                '<tpl if="this.isVisibleField(options, \'infoiconleft\')">',
                '<span class="userinfo-icon info-icon info-icon-left" style="background-image: url(',
                '<tpl if="user.gender == 1">',
                '' + IMAGE_URL + 'interface/icon_male.png',
                '<tpl else>',
                '' + IMAGE_URL + 'interface/icon_female.png',
                '</tpl>',
                ')',
                '" data-qtip="' + ExGods.getMsgByKey("user_info_tooltip") + '"></span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'guild\') && values.user.guild">',
                '<span class="guild-name" data-qtip="{user.guild.title}">',
                '[<strong>{user.guild.tag}</strong>]&nbsp;',
                '</span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'name\')">',
                '<span class="name" data-qtip="{[this.getTooltipText(values.user)]}" <tpl if="options.maxNameWidth">style="max-width: {options.maxNameWidth}px;"</tpl>>',
                '{user.display_title}',
                '</span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'rating_rank\') && this.getRankImg(values.user.rating_rank)">',
                '<span class="rank" ',
                'style="background-image: url({[this.getRankImg(values.user.rating_rank)]});"></span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'trophy_level\') && this.getTrophyLevelImg(values.user)">',
                '<span class="trophylevel-icon" data-qtip="{[this.getTrophyLevelTooltip(values.user)]}"',
                'style="background-image: url({[this.getTrophyLevelImg(values.user)]});"></span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'level\')">',
                '<tpl if="this.isVisibleField(options, \'name\') || this.isVisibleField(options, \'rank\')">',
                '&nbsp;',
                '</tpl>',
                '<span class="level" data-qtip="' + Ext.String.format(ExGods.getMsgByKey('user_level_tooltip'), '{user.hoard.level}') + '">',
                '<tpl if="!options.hideLevelIcon">',
                '<span class="level-icon" style="background-image: url(' + IMAGE_URL + 'icons/level.png' + ');"></span>',
                '</tpl>',
                '{user.hoard.level}',
                '</span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'infoicon\')">',
                '<span class="userinfo-icon info-icon" style="background-image: url(',
                '<tpl if="user.gender == 1">',
                '' + IMAGE_URL + 'interface/icon_male.png',
                '<tpl else>',
                '' + IMAGE_URL + 'interface/icon_female.png',
                '</tpl>',
                ')',
                '" data-qtip="' + ExGods.getMsgByKey("user_info_tooltip") + '"></span>',
                '</tpl>',
                '<tpl if="this.isVisibleField(options, \'menuicon\')">',
                '<span class="menu-icon"></span>',
                '</tpl>',
                '</span>',
                {
                    getCls: function(data) {
                        var cls = [];
                        if (data.race) {
                            cls.push('race-' + data.race);
                        }
                        if (data.moder) {
                            cls.push('moder');
                        }
                        return cls.join(' ');
                    },
                    getStyle: function(data) {
                        var style = [];
                        // if (data.moder) {
                        //  style.push('color:' + ExGods.ref('constants|chat_moder_color').value);
                        // }
                        return style.join(';');
                    },
                    isVisibleField: function(options, field) {
                        return Ext.Array.indexOf(options.fields, field) != -1;
                    },
                    getRankTitle: function(rank) {
                        var rec = ExGods.references.get('user_valour').getByKey(rank);
                        return rec.data.rank ? rec.data.rank : '';
                    },
                    getTrophyLevelImg: function(user) {
                        if (user.hoard && user.hoard.trophy_level && user.hoard.trophy_level >= 2) {
                            switch (user.hoard.trophy_level) {
                                case 2:
                                    return IMAGE_URL + 'icons/trophy_rank/bronze.png';
                                case 3:
                                    return IMAGE_URL + 'icons/trophy_rank/silver.png';
                                case 4:
                                    return IMAGE_URL + 'icons/trophy_rank/gold.png';
                                case 5:
                                    return IMAGE_URL + 'icons/trophy_rank/crystal.png';
                            }
                        }
                    },
                    getTrophyLevelTooltip: function(user) {
                        if (user.hoard && user.hoard.trophy_level && user.hoard.trophy_level >= 2) {
                            var refData = ExGods.ref('user_trophy|' + user.hoard.trophy_level);
                            if (refData && refData.description) {
                                return refData.description.label;
                            }
                        }
                    },
                    getRankImg: function(rank) {
                        var images = {
                                1: IMAGE_URL + 'place1.png',
                                2: IMAGE_URL + 'place2.png',
                                3: IMAGE_URL + 'place3.png'
                            };
                        return images[rank] || '';
                    },
                    getTooltipText: function(data) {
                        var tooltipText = data.display_title;
                        return tooltipText;
                    }
                }
            ]);
        }
        return ExGods.util.User.userinfoTpl.apply({
            user: user,
            options: options
        });
    },
    /**
     *      
     */
    printStat: function(name, value) {
        var stat = ExGods.ref('user_stat|' + name);
        if (!stat)  {
            return '';
        }
        
        if (!value)  {
            value = '';
        }
        
        return '<div class="exg-user-stat" data-qtip="' + stat.label + '" style="background-image:url(' + IMAGE_URL + stat.param.icon + ')">' + value + '</div>';
    },
    /**
     *      
     *  
     */
    getUserStatImages: function() {
        return [
            IMAGE_URL + 'icons/stats/ico_injury16.png',
            IMAGE_URL + 'icons/stats/ico_life16.png',
            IMAGE_URL + 'icons/stats/ico_shield16.png',
            IMAGE_URL + 'icons/stats/ico_mana16.png',
            IMAGE_URL + 'icons/stats/ico_fury16.png',
            IMAGE_URL + 'mask/ico_adroitness.png',
            IMAGE_URL + 'mask/star_red.png',
            IMAGE_URL + 'mask/star_green.png',
            IMAGE_URL + 'mask/star.png',
            IMAGE_URL + 'mask/stars_bg.png',
            IMAGE_URL + 'mask/ico_power.png',
            IMAGE_URL + 'mask/ico_armor.png',
            IMAGE_URL + 'mask/ico_accuracy.png'
        ];
    },
    /**
     *   .
     * @param {Array} stats 
     * @param {Object} options :
     *  visibleValue -   visible  ,    .
     *  column - - ,    .   1
     *  changes -    
     *  maxStats -     (  "(max. 4)")
     *  inline -  true -    ,   false
     *  colorize -  true -    ,  ,   false
     */
    printUserStats: function(stats, options) {
        var data = {
                stats: []
            },
            statsRef = ExGods.ref('user_stat'),
            statInfo,
            tpl = new Ext.XTemplate([
                '<tpl if="options.visibleValue == 1">',
                '<tpl if="options.inline">',
                '<ul class="inline-list">',
                '<tpl for="stats">',
                '<li>',
                '<span class="value icon">{[ this.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ ExGods.printNumber(this.printValue(values.value), 1000, "0", "0.0") ]}</span>',
                '</li>',
                '</tpl>',
                '</ul>',
                '<tpl elseif="options.align != \'right\'">',
                '<table class="user-stats user-stats-{options.visibleValue}">',
                '<tpl for="stats">',
                '<tr class="{[xindex % 2 === 0 ? "even" : ""]}">',
                '<td>{label}</td>',
                '<td>',
                '<span class="value icon">{[ this.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ this.printValue(values.value) ]}',
                '<tpl if="changes">',
                '<span class="changes">',
                '<small>(</small>',
                '<tpl if="Ext.isNumeric(values.changes)">',
                '<span class="{[ values.changes > 0 ? "up" : "down" ]}">{[values.changes > 0 ? "+" : ""]}{changes}</span>',
                '<tpl else>',
                '{changes}',
                '</tpl>',
                '<small>)</small>',
                '</span>',
                '</tpl>',
                '<tpl if="maxStat">',
                '<span><small>(</small><span style="color:' + ExGods.ref('constants|max_upgrade_color').value + '">max. {maxStat}</span><small>)</small></span>',
                '</tpl>',
                '</span>',
                '</td>',
                '</tr>',
                '</tpl>',
                '</table>',
                '<tpl else>',
                '<ul class="table-list">',
                '<tpl for="stats">',
                '<li class="{[xindex % 2 === 0 ? "even" : ""]}">',
                '<span class="label">{label}</span>',
                '<span class="value icon">{[ this.printIcon(values.param.icon) ]}</span>',
                '<span class="value{[ this.getValueClass(this.printValue(values.value)) ]}">{[ this.printValue(values.value) ]}',
                '<tpl if="changes">',
                '<span class="changes">',
                '<small>(</small>',
                '<tpl if="Ext.isNumeric(values.changes)">',
                '<span class="{[ values.changes > 0 ? "up" : "down" ]}">{[values.changes > 0 ? "+" : ""]}{changes}</span>',
                '<tpl else>',
                '{changes}',
                '</tpl>',
                '<small>)</small>',
                '</span>',
                '</tpl>',
                '<tpl if="maxStat">',
                '<span><small>(</small><span style="color:' + ExGods.ref('constants|max_upgrade_color').value + '">max. {maxStat}</span><small>)</small></span>',
                '</tpl>',
                '</span>',
                '</li>',
                '</tpl>',
                '</ul>',
                '</tpl>',
                '<tpl else>',
                '<table class="user-stats user-stats-{options.visibleValue}">',
                '<tpl if="options.visibleValue == 2">',
                '<tr>',
                '<tpl for="stats">',
                '<td data-qtip="{label} - {[ this.printValue(values.value) ]}">',
                '<div class="background" style="background: url(' + IMAGE_URL + '{param.empty})">',
                '<div class="icon" style="background: url(' + IMAGE_URL + '{param.icon})"></div>',
                '<div class="fill-red" style="{[ this.getRedStarsStyle(values.value) ]}"></div>',
                '<div class="fill-green" style="{[ this.getGreenStarsStyle(values.value) ]}"></div>',
                '<div class="fill" style="{[ this.getStarsStyle(values.value) ]};background: url(' + IMAGE_URL + '{param.fill});"></div>',
                '</div>',
                '</td>',
                '<tpl if="xindex % 2 == 0 && xindex < xcount">',
                '</tr><tr>',
                '</tpl>',
                '</tpl>',
                '</tr>',
                '</tpl>',
                '</table>',
                '</tpl>',
                {
                    printValue: function(v) {
                        return Ext.isArray(v) ? v[0] : /*+ '/' + v[1]*/
                        v;
                    },
                    getValueClass: function(v) {
                        if (options.colorize) {
                            return v > 0 ? ' up' : ' down';
                        } else  {
                            return '';
                        }
                        
                    },
                    getRedStarsStyle: function(v) {
                        var style = [];
                        style.push('background: url(' + IMAGE_URL + 'mask/star_red.png)');
                        if (Ext.isArray(v) && v[0] < v[1]) {
                            style.push('left: ' + (24 + v[0] * 14) + 'px');
                            style.push('width: ' + (Math.min(v[1] - v[0], 5 - v[0]) * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    getGreenStarsStyle: function(v) {
                        var style = [];
                        style.push('background: url(' + IMAGE_URL + 'mask/star_green.png)');
                        if (Ext.isArray(v) && v[0] > v[1]) {
                            style.push('left: ' + (24 + v[1] * 14) + 'px');
                            style.push('width: ' + (Math.min(v[0] - v[1], 5 - v[1]) * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    getStarsStyle: function(v) {
                        var style = [];
                        if (Ext.isArray(v)) {
                            style.push('width: ' + (Math.min(v[0], v[1]) * 14) + 'px');
                        } else {
                            style.push('width: ' + (v * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    printIcon: function(icon) {
                        return '<img width="16" height="16" style="margin: 0 2px -3px 0;" src="' + IMAGE_URL + icon + '"/>';
                    }
                }
            ]);
        data.options = Ext.applyIf(options || {}, {
            columns: 1,
            visibleValue: 1,
            inline: false,
            changes: {},
            maxStats: {}
        });
        var sorters = {
                damage: 1,
                fury: 5,
                hp: 2,
                mp: 4,
                shield: 3,
                stamina: 3,
                strength: 2,
                accuracy: 4,
                agility: 1
            };
        //    
        Ext.Object.each(stats, function(key, value) {
            statInfo = statsRef.get(key);
            if (!statInfo) {
                /***/
                //ExGods.app.log('error', '   ' + key + '    ');
                return;
            }
            if ((options.visibleValue == statInfo.visible) && (value !== null)) {
                // if(options.visibleValue == 2 && data.options.changes[key]){
                //  value = [value, value - data.options.changes[key]];
                // }
                data.stats.push({
                    name: key,
                    value: value,
                    label: statInfo.label,
                    visible: statInfo.visible,
                    param: statInfo.param,
                    changes: data.options.changes[key],
                    maxStat: data.options.maxStats[key]
                });
            }
        });
        if (data.stats.length) {
            Ext.Array.sort(data.stats, function(a, b) {
                return sorters[a.name] > sorters[b.name];
            });
            return tpl.apply(data);
        } else {
            return '';
        }
    }
};
// aliases
ExGods.printUser = ExGods.util.User.printUser;
ExGods.printStat = ExGods.util.User.printStat;

//@define ExGods.util.Sprite
/**
 *   
 * @author  
 */
Ext.ns('ExGods.util');
ExGods.util.Sprite = {
    /**
     *    
     * @param {Number} number - required - ;
     * @param {String} sprite -    ,     .   ,    css   util-sign
     * @param {Object} options - required - 
     * - @param {Boolean} horizontal - default:false. ,    
     * - @param {String} indent - ,     .    -
     *          .
     * - @param {String} cls - css  
     * - @param {String} tag - dom tag 
     * - @param {Number} width - required -  
     * - @param {Number} height - required -  
     * - @param {Boolean} lastZero - default: false    "0"    
     * - @param {Boolean} twoDigits - default: false     1  0  
     */
    printSprite: function(number, sprite, options) {
        var n = parseInt(number).toString(),
            w = options.width,
            h = options.height,
            tag = options.tag || 'div',
            cls = options.cls || '',
            i = 0,
            totalWidth = 0,
            numberHtml = '',
            left, top, sign, bgimg, bgpos;
        if (sprite) {
            sprite = (sprite.substr(0, 4) == 'http') ? sprite : IMAGE_URL + sprite;
        }
        if (options.twoDigits && n.length == 1)  {
            n = '0' + n;
        }
        
        for (; i < n.length; i++) {
            totalWidth += w;
            sign = parseInt(n.charAt(i));
            if (options.lastZero) {
                if (sign === 0) {
                    sign = 9;
                } else {
                    sign--;
                }
            }
            if (options.horizontal) {
                left = sign ? '-' + sign * w + 'px' : 0;
                top = options.indent || 0;
            } else {
                left = options.indent || 0;
                top = sign ? '-' + sign * h + 'px' : 0;
            }
            bgpos = 'background-position: ' + left + ' ' + top;
            bgimg = (sprite) ? 'background-image: url(' + sprite + ');' : '';
            numberHtml += '<div class="util-sign" style="' + bgimg + bgpos + ';width:' + w + 'px;height:' + h + 'px"></div>';
        }
        result = '<' + tag + ' class="util-sign-container ' + cls + '">' + '<div style="width:' + totalWidth + 'px;height:' + h + 'px">' + numberHtml + '</div>' + '</' + tag + '>';
        return result;
    }
};

//@define ExGods.util.Time
/**
 *   
 * @author  
 */
Ext.ns('ExGods.util');
ExGods.util.Time = {
    /**
     *     
     * @param {Number} time   
     * @param {Object} options .  :
     *
     *  format = "detailed"|"threenums"|"short" -  .  , "detailed"
     *
     *      : "detailed" - '7 . 10 . 10 . 10 ',
     *               "short" - '7 '  '10:10:10'
     *               "threenums" - '2  3 . 10 .'  '3  10 . 10 .'  '10 . 10 . 10 .' 
     *               "twonums" - '13  48 '
     *               "bignums" - '13:48'      
     *
     *  emptyText = <String> - ,   <= 0
     *
     */
    printTime: function(time, options) {
        var me = this,
            units,
            delimiter = ' ',
            digitFormat = 'd',
            output = [],
            messages = ExGods.ref('message_client'),
            value, i,
            //      
            // @param {Number} value  
            // @param {digitFormat}  . "dd" - '01', "d" - '1'
            // @param {String} label   
            printDigit = function(value, digitFormat, label) {
                var res = '';
                if (digitFormat == 'dd') {
                    res += (value < 10 ? '0' : '') + value;
                } else {
                    res += value;
                }
                if (label) {
                    if (Ext.isArray(label)) {
                        res += ' ' + Ext.util.Format.plural(value, units[i].label);
                    } else {
                        res += ' ' + label;
                    }
                }
                return res;
            };
        options = Ext.applyIf(options || {}, {
            format: 'detailed',
            emptyText: ''
        });
        if (time >= 1) {
            if (options.format == 'detailed') {
                units = [
                    {
                        max: 24 * 3600,
                        label: messages.get('date_format_days_dn') + '.'
                    },
                    {
                        max: 3600,
                        label: messages.get('date_format_hours_ch') + '.'
                    },
                    {
                        max: 60,
                        label: messages.get('date_format_minutes_min') + '.'
                    },
                    {
                        max: 1,
                        label: messages.get('date_format_seconds_s') + '.',
                        digitFormat: 'dd'
                    }
                ];
            } else if (options.format == 'threenums') {
                if (time / (7 * 24 * 3600) > 1) {
                    units = [
                        {
                            max: 7 * 24 * 3600,
                            label: messages.get('date_format_weeks_n') + '.'
                        },
                        // ['', '', '']
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d') + '.'
                        },
                        // ['', '', '']
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        }
                    ];
                }
                // ['', '', '']
                else if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_dn') + '.'
                        },
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m') + '.'
                        }
                    ];
                } else {
                    units = [
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m') + '.'
                        },
                        {
                            max: 1,
                            label: messages.get('date_format_seconds_s') + '.',
                            digitFormat: 'dd'
                        }
                    ];
                }
            } else if (options.format == 'twonums') {
                if (time / (7 * 24 * 3600) > 1) {
                    units = [
                        {
                            max: 7 * 24 * 3600,
                            label: messages.get('date_format_weeks_n')
                        },
                        // ['', '', '']
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d')
                        }
                    ];
                }
                // ['', '', '']
                else if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d')
                        },
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch')
                        }
                    ];
                } else if (time / (3600) > 1) {
                    units = [
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch')
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m')
                        }
                    ];
                } else {
                    units = [
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m')
                        },
                        {
                            max: 1,
                            label: messages.get('date_format_seconds_s'),
                            digitFormat: 'dd'
                        }
                    ];
                }
            } else if (options.format == 'bignums') {
                if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_text').split(',')
                        }
                    ];
                } else {
                    delimiter = ':';
                    digitFormat = 'dd';
                    units = [
                        {
                            max: 3600,
                            label: ''
                        },
                        {
                            max: 60,
                            label: ''
                        },
                        {
                            max: 1,
                            label: ''
                        }
                    ];
                }
            } else {
                if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_text').split(',')
                        }
                    ];
                } else {
                    delimiter = ':';
                    digitFormat = 'dd';
                    units = [
                        {
                            max: 3600,
                            label: ''
                        },
                        {
                            max: 60,
                            label: ''
                        },
                        {
                            max: 1,
                            label: ''
                        }
                    ];
                }
            }
            for (i = 0; i < units.length; i++) {
                value = Math.floor(time / units[i].max);
                if (value != 0 || (options.format == 'short' && units[i].max != 3600) || (options.format == 'threenums' && (units[i].max == 1 || output.length)) || (options.format == 'twonums' && (units[i].max == 1 || output.length)) || (options.format == 'bignums' && units[i].max != 3600)) {
                    output.push(printDigit(value, units[i].digitFormat || digitFormat, units[i].label));
                    time -= value * units[i].max;
                }
            }
            if (options.format == 'bignums') {
                var sprites = [];
                if (output.length == 1) {
                    output.unshift('0');
                }
                Ext.Array.each(output, function(num) {
                    sprites.push(ExGods.util.Sprite.printSprite(num, IMAGE_URL + '/numbers.png', {
                        width: 21,
                        height: 30,
                        twoDigits: true
                    }));
                });
                return sprites.slice(0, 2).join('<span class="bignum-delimiter"></span>');
            } else  {
                return output.join(delimiter);
            }
            
        } else {
            return options.emptyText;
        }
    },
    /**
     *  ,    (@param date)   
     * @param {Date} date
     * @param {Object} options :
     *
     *  format = "detailed"|"short" (.   ExGods.util.Time.printTime)
     *
     *  emptyText - ,   ,   
     */
    printRestTime: function(date, options) {
        var restTime;
        options = Ext.applyIf(options || {}, {
            emptyText: '',
            stringFormat: '{0}'
        });
        restTime = Math.ceil((date - new Date()) / 1000);
        if (restTime > 0) {
            return Ext.String.format(options.stringFormat, this.printTime(restTime, options));
        } else {
            return options.emptyText;
        }
    }
};

//@define ExGods.util.Format
/**
 * -.          
 * @author  
 */
Ext.ns('ExGods.util');
Ext.require([
    'ExGods.util.Stuff',
    'ExGods.util.Stuff2',
    'ExGods.util.User'
], function() {
    ExGods.util.Format = {
        /**
         *    
         * @params {Object} itemParams      (id, title, quantity, grade)
         * @return {String}
         */
        printItem: function(itemParams) {
            return ExGods.util.Stuff.printStuff({
                type: 'item',
                params: itemParams
            });
        },
        /**
         *    ()
         * @params {Object} abilityParams      ([{id, label}, ... ])
         * @return {String}
         */
        printAbility: function(abilityParams) {
            var stuff = [];
            abilityParams = Ext.isArray(abilityParams) ? abilityParams : [
                abilityParams
            ];
            for (var i = 0; i < abilityParams.length; i++) {
                stuff.push({
                    type: 'ability',
                    params: {
                        id: abilityParams[i].id,
                        label: abilityParams[i].label
                    }
                });
            }
            return ExGods.util.Stuff.printStuff(stuff);
        },
        /**
         *    ()
         * @params {Object} featureParams      ([{id, label}, ... ])
         * @return {String}
         */
        printFeature: function(featureParams) {
            var stuff = [];
            featureParams = Ext.isArray(featureParams) ? featureParams : [
                featureParams
            ];
            for (var i = 0; i < featureParams.length; i++) {
                stuff.push({
                    type: 'feature',
                    params: {
                        id: featureParams[i].id,
                        title: featureParams[i].label
                    }
                });
            }
            return ExGods.util.Stuff.printStuff(stuff);
        },
        /**
         *  money
         * @params {Object} moneyParams      ([{name, value}, ... ])
         * @return {String}
         */
        printMoney: function(moneyParams) {
            var stuff = [];
            moneyParams = Ext.isArray(moneyParams) ? moneyParams : [
                moneyParams
            ];
            for (var i = 0; i < moneyParams.length; i++) {
                stuff.push({
                    type: 'currency',
                    params: {
                        id: moneyParams[i].name,
                        quantity: moneyParams[i].value
                    }
                });
            }
            return ExGods.util.Stuff.printStuff(stuff);
        },
        /**
         *     .
         *
         * @param {Number/String} quantity    
         * @param {Number} shortFrom ,         ( "k/kk").   1000
         *   ,  shortFrom = 10000,  123456    "123",   1234567 - "1"
         * @param {String} format  ,   format  Ext.util.Format.number.  , '0,0'
         * @param {String} decimalFormat     
         */
        printNumber: function(quantity, shortFrom, format, decimalFormat) {
            var postfix = '';
            quantity = '' + quantity;
            //   
            shortFrom = shortFrom || 1000000000;
            format = format || '0,0';
            if (quantity >= shortFrom) {
                if (quantity >= 10000000) {
                    quantity = quantity.substr(0, quantity.length - 6);
                    postfix = 'kk';
                } else if (quantity >= 1000000) {
                    quantity = (parseInt(quantity.substr(0, quantity.length - 5)) / 10).toString();
                    postfix = 'kk';
                } else if (quantity >= 10000) {
                    quantity = quantity.substr(0, quantity.length - 3);
                    postfix = 'k';
                } else if (quantity >= 1000) {
                    quantity = (parseInt(quantity.substr(0, quantity.length - 2)) / 10).toString();
                    postfix = 'k';
                }
            }
            if (quantity.split('.').length > 1 && decimalFormat) {
                format = decimalFormat;
            }
            return Ext.util.Format.number(quantity, format) + postfix;
        }
    };
    //      .    !
    ExGods.util.Format.printUserInfo = ExGods.util.User.printUser;
    ExGods.util.Format.printStuff = ExGods.util.Stuff.printStuff;
    ExGods.printItem = ExGods.util.Format.printItem;
    ExGods.printAbility = ExGods.util.Format.printAbility;
    ExGods.printFeature = ExGods.util.Format.printFeature;
    ExGods.printBigStuff = ExGods.util.Stuff2.printBigStuff;
    // aliases
    ExGods.printNumber = ExGods.util.Format.printNumber;
    ExGods.printMoney = ExGods.util.Format.printMoney;
});

//@define ExGods.util.Date
/**
 *     
 *
 * @author  
 */
Ext.ns('ExGods.util');
ExGods.util.Date = {
    /**
     * @property {String} serverDateTimeFormat
     *     
     */
    serverDateTimeFormat: serverDateTimeFormat,
    /**
     * @property {Number} serverTimezoneOffset
     *   ()    
     */
    serverTimezoneOffset: -3 * 60,
    /**
     * @property {Number} serverTimeOffset
     *       
     */
    serverTimeOffset: parseInt(new Date().getTime() / 1000, 10) - window.now,
    /**
     *         ( )
     */
    parseString: function(str) {
        var me = this,
            dt;
        dt = Ext.Date.parse(str, this.serverDateTimeFormat);
        if (!dt) {
            //      timestamp - 'YmdHis'
            dt = Ext.Date.parse(str, 'YmdHis');
        }
        if (!dt) {
            //      "7d"  "eday"
            if (str == 'eday') {
                //                
                dt = new Date();
                dt.setHours(23);
                dt.setHours(23);
                dt.setHours(23);
            } else if (str.match(/^\d+[d,m,s]/)) {
                var count = str.match(/^\d+/)[0];
                var units = str.match(/[d,m,s]/)[0];
                if (units == "d") {
                    dt = Ext.Date.add(new Date(), Ext.Date.DAY, count);
                } else if (units == "m") {
                    dt = Ext.Date.add(new Date(), Ext.Date.MINUTE, count);
                } else if (units == "s") {
                    dt = Ext.Date.add(new Date(), Ext.Date.SECOND, count);
                }
            }
        }
        return dt;
    },
    /**
     *   ,   ,    serverDateTime
     * @param {String|Date} serverDateTime     ExGods.util.Date.serverDateTimeFormat   
     * @return {Date}  ,   
     */
    normalizeServerDateTime: function(serverDateTime) {
        var dt;
        if (typeof serverDateTime == 'string') {
            dt = this.parseString(serverDateTime);
        } else {
            dt = serverDateTime;
        }
        dt = Ext.Date.add(dt, Ext.Date.MINUTE, -dt.getTimezoneOffset() + this.serverTimezoneOffset);
        dt = Ext.Date.add(dt, Ext.Date.SECOND, this.serverTimeOffset);
        return dt;
    },
    /**
     *     unixtime  
     */
    normalizeUnixTime: function(time) {
        var me = this;
        return new Date((parseInt(time) + this.serverTimeOffset) * 1000);
    }
};

//@define ExGods.util.Ticker
/**
 * @class ExGods.util.Ticker
 *
 *      (   1 )
 *
 * @author  
 */
Ext.ns('ExGods.util');
ExGods.util.Ticker = (function() {
    var listeners = [];
    /**
     *   
     * @param {Function} fn (required)
     * @param {Object} scope
     * @param {Object} options 
     *
     *  :
     *    period -     .   - 1 
     *
     * @return {Function}  
     */
    function addListener(fn, scope, options) {
        options = Ext.applyIf(options || {}, {
            period: 1
        });
        listeners.push({
            fn: fn,
            options: options,
            left: options.period,
            scope: scope || window
        });
        return fn;
    }
    /**
     *  
     * @param {Function} fn (required)   
     * @param {Object} scope
     */
    function removeListener(fn, scope) {
        Ext.Array.each(listeners, function(listener, index) {
            if (listener.fn === fn && (!scope || listener.scope === scope)) {
                Ext.Array.erase(listeners, index, 1);
                return false;
            }
        });
    }
    //  
    window.setInterval(function() {
        Ext.Array.each(listeners, function(listener) {
            if (listener) {
                listener.left--;
                if (listener.left <= 0) {
                    listener.fn.call(listener.scope);
                    listener.left = listener.options.period;
                }
            }
        });
    }, 1000);
    return {
        addListener: addListener,
        removeListener: removeListener
    };
}());

//@define ExGods.util.Helper
/**
 *   
 * @author  
 */
Ext.ns('ExGods.util');
ExGods.util.Helper = {
    /**
    *  16-    RGB
    * @return Array
    */
    hexToRgb: function(hex) {
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16),
            parseInt(result[2], 16),
            parseInt(result[3], 16)
        ] : null;
    },
    /**
     *  .   
     */
    escapeRegexp: function(text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    },
    /**
     *  .      
     * @param {text/tpl} text       
     * @return {text/tpl} text       
     */
    processTextWithSmiles: function(text) {
        var iconCodes = ExGods.ref('images|chat_message_icons').image,
            maxSmiles = parseInt(ExGods.ref('constants|chat_smiles_cap').value),
            smilesCount = 0,
            regexp, keys, value;
        for (var key in iconCodes) {
            keys = key.split('|');
            value = iconCodes[key];
            for (j = 0; j < keys.length; j++) {
                regexp = new RegExp(ExGods.util.Helper.escapeRegexp(keys[j]));
                while (regexp.test(text)) {
                    if (smilesCount < maxSmiles) {
                        text = text.replace(regexp, '<span class="message-icon" style="background-image: url(' + value + ');"></span>');
                        smilesCount++;
                    } else {
                        text = text.replace(regexp, '', 'gi');
                    }
                }
            }
        }
        return text;
    },
    /**
     *    
     */
    censoreText: function(msg) {
        var me = this,
            mat = ExGods.references.get('constants_list').mat.value,
            msgArr = msg.split(' ');
        Ext.Array.each(msgArr, function(word, i) {
            if (mat.indexOf(word.toLowerCase().replace(/[^A-Za-z--]+/g, '')) != -1)  {
                msgArr[i] = '<' + ExGods.getMsgByKey('chat_censor_text') + '>';
            }
            
        });
        return msgArr.join(' ');
    },
    /**
     *    
     * @param {String} key   "ref_name|ref_item_key", ref_name -  ; ref_item_key -    ( )
     * @return {Mixin}    undefined  ,      
     */
    ref: function(key) {
        var parts = key.split('|'),
            ref = ExGods.app.references.get(parts[0]);
        if (ref) {
            if (parts.length > 1) {
                return ref.get(parts[1]);
            } else {
                return ref;
            }
        } else {
            return undefined;
        }
    },
    /**
     *      
     * @param {String} key    
     * @return {String}
     */
    getMsgByKey: function(key, defaultMsg) {
        return ExGods.ref('message_client|' + key) || defaultMsg || '';
    },
    /**
     *       .  
     * @param {socialNetName}
     * @param {socialNetId}
     */
    getUserSocialNetLink: function(socialNetName, socialNetId) {
        var link = '#';
        switch (socialNetName) {
            case 'fb':
                link = 'http://fb.com/profile.php?id=' + socialNetId;
                break;
            case 'vk':
                link = 'http://vk.com/id' + socialNetId;
                break;
            case 'vka':
                link = 'http://vk.com/id' + socialNetId;
                break;
            case 'ok':
                link = 'http://odnoklassniki.ru/profile/' + socialNetId;
                break;
            case 'oka':
                link = 'http://odnoklassniki.ru/profile/' + socialNetId;
                break;
            case 'tw':
                link = 'http://twitter.com/' + socialNetId;
                break;
            case 'mm':
                link = 'http://my.mail.ru/mail/' + socialNetId;
                break;
            case 'mma':
                link = socialNetId;
                break;
            default:
                break;
        }
        return link;
    },
    maskElement: function(element) {
        element.mask(ExGods.getMsgByKey('wait_message'), 'local-mask').addCls('global-mask');
    },
    /**
     *  html       ExtJS
     * @param {HTMLElement} el    
     * @param {Ext.container.Container} parent  ,     
     */
    renderComponents: function(el, parent) {
        var nodeToConfig = function(node) {
                var config;
                if (node.nodeName == 'SPAN' || node.nodeName == 'DIV' || node.nodeName == 'LI') {
                    config = {};
                    Ext.Array.each(node.children, function(child) {
                        if (child.attributes && child.attributes.role) {
                            var key = child.attributes.role.value.split(':'),
                                value;
                            value = nodeToConfig(child);
                            if (key.length > 1) {
                                //  value  
                                if (key[1] == 'int') {
                                    value = parseInt(value);
                                } else if (key[1] == 'bool') {
                                    value = value === 'true' || value == 1;
                                } else if (key[1] == 'object') {
                                    value = Ext.JSON.decode(value);
                                }
                            }
                            config[key[0]] = value;
                        }
                    });
                    if (Ext.Object.isEmpty(config)) {
                        config = node.innerHTML;
                    }
                } else if (node.nodeName == 'UL') {
                    config = [];
                    Ext.Array.each(node.children, function(child) {
                        config.push(nodeToConfig(child));
                    });
                }
                return config;
            };
        Ext.fly(el).select('.component').each(function() {
            var el = this,
                config, cmp;
            config = nodeToConfig(el.dom);
            config.renderTo = el;
            el.setHTML('');
            cmp = Ext.widget(config.xtype, config);
            if (parent) {
                if (parent.getRefItems) {
                    //    ,     getRefItems,       
                    // getRefItems -   ComponentQuery      query                 
                    var originalFn = parent.getRefItems;
                    parent.getRefItems = function(deep) {
                        var me = this,
                            items = originalFn.apply(parent, arguments);
                        items.push(cmp);
                        if (deep && cmp.getRefItems) {
                            items.push.apply(items, cmp.getRefItems(true));
                        }
                        return items;
                    };
                }
                cmp.mon(parent, 'afterlayout', function() {
                    if (cmp.updateLayout) {
                        cmp.updateLayout();
                    }
                });
                cmp.mon(parent, 'destroy', function() {
                    if (cmp.el.dom) {
                        cmp.destroy();
                    }
                });
            }
        });
    },
    /**
     *  ,   renderComponents
     * @param {HTMLElement} el   
     * @param {Ext.container.Container} parent  ,     
     */
    destroyComponents: function(el) {
        Ext.fly(el).select('.component').each(function() {
            var el = Ext.get(this),
                cmpEl, cmp;
            if (el) {
                cmpEl = el.child('*');
                if (cmpEl) {
                    cmp = Ext.getCmp(cmpEl.id);
                    if (cmp) {
                        cmp.destroy();
                    }
                }
            }
        });
    },
    /**
     *   (, , etc)
     * @param {Mixed} data ,    
     * @param {String} path   proto_id  data   "<key_name1>.<key_name2>.<..".    '|'
     * @param {String} typeOfProto  .   "item", "feature".  , "item".
     */
    loadProtos: function(data, path, callback, typeOfProto) {
        var store = typeOfProto == "feature" ? ExGods.app.getFeaturePrototypesStore() : ExGods.app.getItemPrototypesStore(),
            ids = [],
            findProtoIds = function(data, path, index) {
                var key = path[index++],
                    ids;
                if (key) {
                    if (data[key]) {
                        if (Ext.isArray(data[key])) {
                            ids = Ext.Array.map(data[key], function(item) {
                                return findProtoIds(item, path, index);
                            });
                            return Ext.Array.clean(Ext.Array.flatten(ids));
                        } else {
                            return findProtoIds(data[key], path, index);
                        }
                    } else {
                        if (Ext.isArray(data)) {
                            return Ext.Array.map(data, function(item) {
                                return findProtoIds(item[key], path, index);
                            });
                        } else {
                            return [];
                        }
                    }
                } else //   
                {
                    if (typeOfProto == 'feature') {
                        return data;
                    } else {
                        return [
                            parseInt(data) || null
                        ];
                    }
                }
            };
        callback = callback || Ext.emptyFn;
        Ext.Array.each(path.split('|'), function(path) {
            ids = ids.concat(findProtoIds(data, path.split('.'), 0));
        });
        if (ids.length) {
            store.loadNew(Ext.Array.unique(ids), function() {
                callback();
            });
        } else {
            callback();
        }
    },
    /**
     *    .
     *    , 
     */
    loadProtosFromStuff: function(stuff, callback) {
        var me = this,
            items = [],
            features = [];
        try {
            stuff = Ext.isArray(stuff) ? stuff : [
                stuff
            ];
            for (var i = 0; i < stuff.length; i++) {
                if (stuff[i].type == 'item') {
                    items.push(stuff[i]);
                } else if (stuff[i].type == 'feature') {
                    features.push(stuff[i]);
                }
            }
        } catch (err) {
            me.log('error', '  .', err);
            items = [];
        }
        me.loadProtos(items, 'params.id', function() {
            me.loadProtos(features, 'params.id', callback, 'feature');
        });
    },
    /**
     *    
     */
    sumStuff: function(stuff1, stuff2) {
        var result;
        stuff1 = Ext.isArray(stuff1) ? stuff1 : [
            stuff1
        ];
        stuff2 = Ext.isArray(stuff2) ? stuff2 : [
            stuff2
        ];
        result = Ext.clone(stuff1);
        Ext.Array.each(stuff2, function(s1) {
            var calculated = false;
            Ext.Array.each(result, function(s2) {
                if (s1.type == s2.type) {
                    if ((s1.type == 'expa' || s1.type == 'trophy') || ((s1.type == 'currency' || s1.type == 'timed') && s1.params.id == s2.params.id)) {
                        s2.params.quantity += s1.params.quantity;
                        calculated = true;
                    }
                }
            });
            if (!calculated) {
                result.push(s1);
            }
        });
        return result;
    },
    /**
     *     ,  
     * @param stuff 
     * @param options :
     *  - flatItems {Boolean}     .  ,  
     */
    flatStuff: function(stuff, options) {
        var result;
        options = options || {};
        stuff = Ext.clone(Ext.isArray(stuff) ? stuff : [
            stuff
        ]);
        result = [];
        Ext.Array.each(stuff, function(s1) {
            var calculated = false;
            Ext.Array.each(result, function(s2) {
                if (s1.type == s2.type) {
                    if ((s1.type == 'expa' || s2.type == 'trophy') || (s1.type == 'currency' || s1.type == 'timed' || s1.type == 'ingredients' || (s1.type == 'item' && options.flatItems)) && s1.params.id == s2.params.id) {
                        s2.params.quantity += s1.params.quantity;
                        calculated = true;
                    }
                }
            });
            if (!calculated) {
                result.push(s1);
            }
        });
        return result;
    },
    //      ExGods.util.Helper.startMenuTimer
    timerTickListener: [],
    /**
     *    ,   .
     *
     * menuId - string -      
     * timerId - string -   
     * endTime - time -      
     * callBackFunction - function -    
     */
    startMenuTimer: function(menuId, timerId, endTime, callBackFunction) {
        var me = this;
        me.stopMenuTimer(timerId);
        var el = Ext.fly(menuId).insertHtml('beforeEnd', ExGods.util.Timers.printRestTimer(timerId, endTime, {
                needNormalized: true,
                format: 'twonums',
                cls: 'mainmenu-timer'
            }), true);
        el.dom.id = timerId;
        ExGods.util.Timers.on(timerId + '-expire', callBackFunction || Ext.emptyFn);
    },
    stopMenuTimer: function(timerId) {
        if (Ext.fly(timerId)) {
            Ext.fly(timerId).remove();
        }
    },
    /**
     *     
     *
     * endTime - time -  
     * startTime - time -  
     * pauseTime - time -      ( ,    )
     * intervalsContainer - function -  
     * intervalId - string -     
     * elementId - string -     
     * squareWidthOfSide - int -    
     * aditionalTimer - function -  
     */
    createSquareTimer: function(endTime, startTime, pauseTime, intervalsContainer, intervalId, elementId, squareWidthOfSide, aditionalTimer) {
        //      ,            1 
        var end_sec_time, start_sec_time, pause_sec_time;
        if (typeof endTime != 'number' || endTime > 1000000) {
            end_sec_time = endTime;
            start_sec_time = startTime;
            pause_sec_time = pauseTime;
        } else {
            end_sec_time = startTime;
            start_sec_time = endTime;
            pause_sec_time = startTime - pauseTime;
        }
        if (end_sec_time == start_sec_time)  {
            return;
        }
        
        //    ,     (     )
        var isTimerFreeze = pauseTime;
        if (isTimerFreeze) {
            timeLeft = end_sec_time - pause_sec_time;
        } else {
            timeLeft = end_sec_time - new Date().getTime();
        }
        if (timeLeft) {
            var arr = [],
                curTime = new Date(),
                intervalFn = (intervalsContainer) ? intervalsContainer[intervalId] : undefined,
                x, y, i, poly, time, ticks, tickTime;
            //          
            if (isTimerFreeze) {
                i = Math.ceil(360 - timeLeft * 360 / (end_sec_time - start_sec_time));
                tickTime = Math.round((end_sec_time - start_sec_time) / 360);
            } else {
                i = Math.ceil(360 - timeLeft * 360 / (end_sec_time - start_sec_time));
                tickTime = Math.round((end_sec_time - start_sec_time) / 360);
            }
            if (intervalFn) {
                clearInterval(intervalFn);
            }
            for (; i < 361; i++) {
                if (i <= 45) {
                    x = Math.round(squareWidthOfSide / 2 + squareWidthOfSide * i / 90);
                    y = 0;
                } else if (i > 45 && i <= 135) {
                    x = squareWidthOfSide;
                    y = Math.round(squareWidthOfSide * (i - 45) / 90);
                } else if (i > 135 && i <= 225) {
                    x = Math.round(squareWidthOfSide * (90 - (i - 135)) / 90);
                    y = squareWidthOfSide;
                } else if (i > 225 && i <= 315) {
                    x = 0;
                    y = Math.round(squareWidthOfSide * (90 - (i - 225)) / 90);
                } else if (i > 315) {
                    x = Math.round(squareWidthOfSide * (i - 315) / 90);
                    y = 0;
                }
                arr.push([
                    x,
                    y
                ]);
            }
            if (arr.length) {
                arr.push([
                    squareWidthOfSide / 2,
                    squareWidthOfSide / 2
                ]);
            } else  {
                return;
            }
            
            if (!isTimerFreeze) {
                intervalsContainer[intervalId] = setInterval(function() {
                    var el = Ext.get(elementId);
                    if (arr.length) {
                        if (el) {
                            if (el.down('svg') && poly) {
                                poly.plot(arr);
                            } else {
                                if (el.down('svg'))  {
                                    el.down('svg').remove();
                                }
                                
                                var svg = SVG(elementId).size(squareWidthOfSide, squareWidthOfSide);
                                poly = svg.polygon(arr).fill('black').opacity(0.5);
                            }
                        }
                        time = new Date();
                        ticks = Math.round((time - curTime) / tickTime);
                        curTime = time;
                        arr.splice(0, ticks);
                    } else {
                        clearInterval(intervalsContainer[intervalId]);
                        delete intervalsContainer[intervalId];
                        if (el)  {
                            el.remove();
                        }
                        
                    }
                }, tickTime);
                if (aditionalTimer)  {
                    aditionalTimer();
                }
                
            }
            setTimeout(function() {
                var el = Ext.get(elementId);
                if (arr.length) {
                    if (el) {
                        if (!el.down('svg')) {
                            var svg = SVG(elementId).size(squareWidthOfSide, squareWidthOfSide);
                            poly = svg.polygon(arr).fill('black').opacity(0.5);
                        }
                    }
                }
            }, 0);
        }
    },
    /**
     *   
     * 
     * el {Ext.Element} -      
     * cls - css       -    
     * iters -    
     * deltaY -   
     * interval -   
     * callback -    
     */
    shine: function(el, cls, iters, deltaY, interval, callback) {
        var shine = el.insertHtml('beforeEnd', '<div class="' + cls + '"></div>', true),
            i = 0;
        (function() {
            if (i < iters) {
                i++;
                shine.setStyle('background-position', '0 ' + (deltaY * i) + 'px');
                setTimeout(arguments.callee, interval);
            } else {
                shine.remove();
                if (callback) {
                    callback();
                }
            }
        })();
        return shine;
    },
    /**
     *  
     *
     * @params
     *  ct - DOM-    
     *  stuff - 
     *  callback - fn  
     *  extraCls - .   
     *
     * @return DOM- 
     */
    animateCurrency: function(ct, stuff, callback, extraCls) {
        var me = this,
            _getDigits = function(num) {
                var digits = [];
                num = num + '';
                for (var i = 0; i < num.length; i++) {
                    digits.push(num.substr(i, 1));
                }
                return digits;
            },
            iters = 0,
            timePerIter = ExGods.ref('constants|bot_banish_anim_spf').value,
            interval, el, currency, digits, icon,
            html = [];
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        callback = callback || Ext.emptyFn;
        Ext.Array.each(stuff, function(s) {
            if (s.type == 'currency' && (s.params.id == 'gold' || s.params.id == 'crystal')) {
                currency = s;
            }
        });
        if (currency) {
            icon = IMAGE_URL + (currency.params.id == 'gold' ? 'currency/anim/coin.png' : 'currency/anim/crystal.png');
            digits = _getDigits(currency.params.quantity);
            html = [
                '<div class="currency-anim ' + extraCls + '">',
                '<div class="icon" style="background-image: url(' + icon + ')"></div>'
            ];
            for (var i = 0; i < digits.length; i++) {
                html.push('<div class="digit" style="background-image: url(' + IMAGE_URL + 'currency/anim/numbers.png); background-position: 0 ' + (-31 * digits[i] - 5) + 'px"></div>');
            }
            html.push('</div>');
            el = Ext.get(ct).insertHtml('beforeEnd', html.join(''), true);
            interval = setInterval(function() {
                iters = ++iters % 31;
                if (currency.params.id == 'gold') {
                    el.select('.icon').applyStyles({
                        'background-position': '-3px ' + (-33 * iters - 8) + 'px'
                    });
                } else {
                    el.select('.icon').applyStyles({
                        'background-position': '-3px ' + (-36 * iters - 13) + 'px'
                    });
                }
            }, timePerIter);
            el.animate({
                duration: ExGods.ref('constants|bot_banish_anim_time1').value,
                easing: 'cubic-bezier(0, 0, 1, 1)',
                from: {
                    top: ExGods.ref('constants|bot_banish_anim_y_from').value + 'px'
                },
                to: {
                    top: ExGods.ref('constants|bot_banish_anim_y_to').value + 'px'
                },
                callback: function() {
                    clearInterval(interval);
                    el.remove();
                    if (callback) {
                        callback();
                    }
                }
            });
            return el;
        } else {
            callback();
            return null;
        }
    },
    /**
     *    a  b,    , , ,   
     */
    isEqual: function(a, b) {
        var me = this;
        if (Ext.isDate(a) && Ext.isDate(b)) {
            return a.getTime() === b.getTime();
        }
        if (Ext.isArray(a) && Ext.isArray(b)) {
            if (a.length != b.length) {
                return false;
            } else {
                var count = a.length;
                Ext.Array.each(a, function(item, index) {
                    if (me.isEqual(a[index], b[index])) {
                        count--;
                    } else {
                        return false;
                    }
                });
                return count ? false : true;
            }
        }
        if (Ext.isObject(a) && Ext.isObject(b)) {
            if (Ext.getClassName(a) && Ext.getClassName(b)) {
                return true;
            }
            if (Ext.Object.getSize(a) != Ext.Object.getSize(b)) {
                return false;
            } else {
                var count = Ext.Object.getSize(a);
                Ext.Object.each(a, function(key, value) {
                    if (me.isEqual(a[key], b[key])) {
                        count--;
                    } else {
                        return false;
                    }
                });
                return count ? false : true;
            }
        }
        return a === b;
    },
    /**
     *   
     */
    translit: function(text) {
        return text.replace(/([-])|([\s_-])|([^a-z\d])/gi, function(all, ch, space, words, i) {
            if (space || words) {
                return space ? '-' : '';
            }
            var code = ch.charCodeAt(0),
                index = code == 1025 || code == 1105 ? 0 : code > 1071 ? code - 1071 : code - 1039,
                t = [
                    'yo',
                    'a',
                    'b',
                    'v',
                    'g',
                    'd',
                    'e',
                    'zh',
                    'z',
                    'i',
                    'y',
                    'k',
                    'l',
                    'm',
                    'n',
                    'o',
                    'p',
                    'r',
                    's',
                    't',
                    'u',
                    'f',
                    'h',
                    'c',
                    'ch',
                    'sh',
                    'shch',
                    '',
                    'y',
                    '',
                    'e',
                    'yu',
                    'ya'
                ];
            return t[index];
        });
    }
};
// aliases
ExGods.helpme = ExGods.util.Helper;
ExGods.ref = ExGods.util.Helper.ref;
ExGods.getMsgByKey = ExGods.util.Helper.getMsgByKey;

//@define ExGods.util.Timers
/**
 * @class ExGods.util.Timers
 *
 *     html   .      .
 *    ,   .
 *
 * @author  
 */
Ext.define('ExGods.util.Timers', {
    extend: Ext.util.Observable,
    singleton: true,
    constructor: function() {
        var me = this;
        me.callParent(arguments);
        ExGods.util.Ticker.addListener(me.onTick, me);
    },
    /**
     *   
     * @param type {String}  
     * @param name {String}   (  ).       (. @method this.onTimerExpired)
     * @param value {Mixed}   .    ,      - 
     * @param options {Object} :
     *  - format -    (twonums, short, etc).  , twonums
     *  - emptyText - ,    
     *  - needNormalized True,    .
     *  - cls ,     
     *  
     */
    printTimer: function(type, name, value, options) {
        var me = this,
            format, html;
        options = options || {};
        if (type == 'rest') {
            if (typeof value == 'string') {
                value = ExGods.util.Date.parseString(value);
            }
            if (options.needNormalized) {
                value = ExGods.util.Date.normalizeServerDateTime(value);
            }
        }
        format = options.format || 'twonums';
        html = '<span class="exg-timer ' + (options.cls ? options.cls : "") + '" data-type="' + type + '" data-name="' + name + '" data-format="' + format + '" data-value="' + value + '" ' + ' data-epmty-text="' + (options.emptyText || '') + '">';
        if (type == 'rest') {
            html += ExGods.util.Time.printRestTime(value, {
                format: format
            });
        }
        html += '</span>';
        return html;
    },
    /**
     *     
     *  .. ( @method this.printTimer)
     */
    printRestTimer: function(name, value, options) {
        return this.printTimer('rest', name, value, options);
    },
    /**
     * key: ID  
     * value:   
     */
    square_timers: {},
    /**
     *     
     *
     * end - Required {Date|Number} -  
     * start - {Date|Number} -  
     * pause - {Date|Number} -      ( ,    )
     * side - int -    
     */
    printSquareTimer: function(options) {
        var me = this,
            convert = function(value) {
                if (value instanceof Date) {
                    return value.getTime();
                } else  {
                    return Number(value) || 0;
                }
                
            },
            end = convert(options.end),
            start = convert(options.start),
            pause = convert(options.pause),
            now = Date.now(),
            side = options.side || 50,
            left = end - (pause || now),
            html = '';
        if (!left)  {
            return html;
        }
        
        var points = [],
            i = Math.ceil(360 - left * 360 / (end - start)),
            tick_time = Math.round((end - start) / 360),
            id = 'exg-square-timer-' + Ext.id();
        for (; i < 361; i++) {
            if (i <= 45) {
                points.push([
                    Math.round(side / 2 + side * i / 90),
                    0
                ]);
            } else if (i > 45 && i <= 135) {
                points.push([
                    side,
                    Math.round(side * (i - 45) / 90)
                ]);
            } else if (i > 135 && i <= 225) {
                points.push([
                    Math.round(side * (90 - (i - 135)) / 90),
                    side
                ]);
            } else if (i > 225 && i <= 315) {
                points.push([
                    0,
                    Math.round(side * (90 - (i - 225)) / 90)
                ]);
            } else if (i > 315) {
                points.push([
                    Math.round(side * (i - 315) / 90),
                    0
                ]);
            }
        }
        if (points.length) {
            points.push([
                side / 2,
                side / 2
            ]);
        }
        me.square_timers[id] = {
            pause: pause,
            started_at: pause || now,
            side: side,
            tick_time: tick_time,
            points: points
        };
        //   ,      
        setTimeout(function() {
            me.updateSquareTimer(id);
        }, 0);
        return '<div class="exg-square-timer" id="' + id + '"></div>';
    },
    /**
     * @private
     */
    onTick: function() {
        var me = this;
        Ext.select('.exg-timer').each(function(el) {
            if (el.hasCls('exg-timer-expired')) {
                return;
            }
            var timerName = el.dom.getAttribute('data-name'),
                type = el.dom.getAttribute('data-type'),
                value = el.dom.getAttribute('data-value'),
                format = el.dom.getAttribute('data-format'),
                emptyText = el.dom.getAttribute('data-epmty-text'),
                rest;
            if (type == 'rest') {
                value = new Date(Number(value) || value);
                rest = Math.ceil((value - new Date()) / 1000);
                if (rest > 0) {
                    el.setHTML(ExGods.util.Time.printTime(rest, {
                        format: format
                    }));
                } else {
                    el.setHTML(emptyText || '');
                    el.addCls('exg-timer-expired');
                    me.onTimerExpired(timerName, el);
                }
            }
        });
        for (var id in me.square_timers) {
            me.updateSquareTimer(id);
        }
    },
    /**
     * @private
     */
    updateSquareTimer: function(id) {
        var me = this,
            params = me.square_timers[id],
            el = document.getElementById(id),
            timestamp = params.pause || Date.now(),
            i = Math.round((timestamp - params.started_at) / params.tick_time),
            points = params.points.slice(i);
        if (!el)  {
            return;
        }
        
        if (!params.svg) {
            params.svg = SVG(id).size(params.side, params.side);
        }
        if (!params.poly) {
            params.poly = params.svg.polygon(points).fill('black').opacity(0.5);
        }
        if (points.length) {
            params.poly.plot(points);
        } else {
            delete me.square_timers[id];
            el.remove();
            me.fireEvent(id + '-expire');
        }
    },
    /**
     * @private   
     * @param timerName {String}  
     * @param el {Ext.dom.Element} DOM  
     * @param
     */
    onTimerExpired: function(timerName, el) {
        var me = this;
        me.fireEvent(timerName + '-expire', el);
    }
});

//@define ExGods.util.RemoteDebug
/**
 *         (      CMS )
 */
Ext.ns('ExGods.util');
(function() {
    var Debugger = function(config) {
            this.title = config.title;
            this.showInConsole = config.showInConsole;
            this.limit = config.limit;
            this.logs = [];
        };
    Debugger.prototype.log = function(msg) {
        this.logs.push(Ext.Date.format(new Date(), 'H:i:s') + ' ' + msg);
        if (this.showInConsole) {
            console.log(msg);
        }
    };
    Debugger.prototype.clear = function() {
        this.logs = [];
    };
    Debugger.prototype.send = function() {
        var message = '',
            logs = this.logs;
        if (this.limit) {
            logs = logs.slice(Math.max(logs.length - this.limit, 0), logs.length);
        }
        message += logs.join('<br/>');
        message += '<br/>' + Ext.Date.format(new Date(), 'H:i:s') + ' ' + navigator.userAgent;
        Ext.Ajax.request({
            url: 'game.pl?cmd=bugs&autorequest=1',
            params: {
                type: 8,
                subject: this.title,
                message: message
            }
        });
        this.clear();
    };
    ExGods.util.RemoteDebug = {
        debuggers: {},
        factory: function(name, config) {
            this.debuggers[name] = new Debugger(config);
            return this.debuggers[name];
        },
        get: function(name) {
            return this.debuggers[name];
        }
    };
}());

/**
 *  
 */
Ext.define('ExGodsCore.model.Location', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'action',
            type: 'auto'
        },
        {
            //  
            name: 'blob',
            convert: function(v) {
                if (v) {
                    //       :        ;
                    v.objects = (function() {
                        var objects = [];
                        Ext.Array.each(v.objects || [], function(item) {
                            var interactive = item.interactive;
                            Ext.Array.each(interactive, function(interactiveItem) {
                                var itemClone = Ext.clone(item);
                                itemClone.interactive = interactiveItem;
                                objects.push(itemClone);
                            });
                        });
                        return objects;
                    }());
                }
                return v;
            }
        },
        {
            //    
            name: 'chat_room_name',
            type: 'string'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            //  
            name: 'name',
            type: 'string'
        },
        {
            name: 'prototype',
            type: 'auto'
        },
        {
            //   
            name: 'to',
            type: 'auto'
        }
    ],
    /**
     *    
     * @return {String}  
     */
    getThumb: function() {
        return this.get('blob').thumb ? IMAGE_URL + this.get('blob').thumb : Ext.BLANK_IMAGE_URL;
    },
    /**
     *   
     * @return {String}  
     */
    getName: function() {
        return this.get('name');
    },
    /**
     *    
     * @return {String}  
     */
    getImage: function() {
        return IMAGE_URL + this.get('blob').image || Ext.BLANK_IMAGE_URL;
    },
    getType: function() {
        return this.get('prototype').type;
    },
    /**
     *     
     * @return {Array}   :
     *      {
     *          type -  ,
     *          params_type -   
     *          interactive -   
     *          description -   
     *      }
     */
    getObjects: function() {
        return this.get('blob').objects || [];
    },
    /**
     *   
     * @return {Object}
     */
    getProto: function() {
        var me = this,
            proto = me.get('prototype');
        if (typeof proto == "object") {
            return proto;
        } else {
            return ExGodsCore.references.get('prototypes_rooms').get(parseInt(proto, 10));
        }
    },
    /**
     *  true,   
     */
    isDanger: function() {
        var me = this;
        return this.getProto().blob.danger === "1";
    }
});

/**
 *   
 */
Ext.define('ExGods.store.Locations', {
    extend: Ext.data.Store,
    model: 'ExGodsCore.model.Location'
});

/**
 *   
 *
 *      .   set   
 *    Object.
 */
Ext.define('ExGodsCore.model.BasicUser', {
    extend: Ext.data.Model,
    idProperty: 'title',
    fields: [
        {
            // 
            name: 'binding',
            type: 'auto',
            convert: function(v, rec) {
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key, value, myself) {
                        if (value)  {
                            myself[key] = parseInt(myself[key]);
                        }
                        else  {
                            myself[key] = 0;
                        }
                        
                    });
                }
                return v;
            }
        },
        {
            //  
            name: 'display_title',
            type: 'string'
        },
        {
            // 
            name: 'gender',
            type: 'string'
        },
        {
            //  
            name: 'hoard',
            type: 'auto',
            convert: function(v, rec) {
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key, value, myself) {
                        if (value)  {
                            myself[key] = parseInt(myself[key]);
                        }
                        else  {
                            myself[key] = 0;
                        }
                        
                    });
                }
                return v;
            }
        },
        {
            name: 'id',
            type: 'int'
        },
        {
            //  
            name: 'is_mentor',
            type: 'int'
        },
        {
            //  
            name: 'moder',
            type: 'int'
        },
        {
            //  
            name: 'online',
            type: 'int'
        },
        {
            // 
            name: 'race',
            type: 'int'
        },
        {
            //    
            name: 'ready_pupil',
            type: 'int'
        },
        {
            name: 'reg_date',
            type: 'date',
            dateFormat: serverDateTimeFormat
        },
        {
            //   
            name: 'shape',
            type: 'auto'
        },
        {
            //  
            name: 'title',
            type: 'string'
        },
        {
            //  
            name: 'rating_rank',
            type: 'number'
        },
        /*
         *    
         */
        {
            name: 'bot_data',
            type: 'auto'
        },
        /*
         *  
         */
        {
            name: 'bot_state',
            type: 'auto'
        },
        {
            /**
         *  -   
         */
            name: 'attack_immune',
            type: 'int',
            convert: function(v) {
                if (v && typeof v == 'object') {
                    //      .                       
                    return 1;
                } else {
                    return parseInt(v, 10);
                }
            }
        },
        {
            //  
            name: 'stats',
            type: 'auto'
        }
    ],
    /**
     *   
     * 
     * @return {String}
     */
    getAvatar: function() {
        return this.getShape().avatar;
    },
    /**
     *     
     *
     * @return {String}
     */
    getInventoryAvatar: function() {
        return this.getShape().full;
    },
    /**
     *   
     * 
     * @return {Number}
     */
    getLevel: function() {
        return this.get('hoard').level;
    },
    getLocation: function() {
        return this.get('binding').room;
    },
    /**
     *         shapes (    )
     */
    getShape: function() {
        var shape = this.get('shape');
        if (typeof shape == 'object') {
            return {
                thumb: shape.small ? (/^http/.test(shape.small) ? shape.small : IMAGE_URL + shape.small) : Ext.BLANK_IMAGE_URL,
                avatar: shape.medium ? (/^http/.test(shape.medium) ? shape.medium : IMAGE_URL + shape.medium) : Ext.BLANK_IMAGE_URL,
                full: shape.large ? (/^http/.test(shape.large) ? shape.large : IMAGE_URL + shape.large) : Ext.BLANK_IMAGE_URL,
                battle: shape.battle ? (/^http/.test(shape.battle) ? shape.battle : IMAGE_URL + shape.battle) : Ext.BLANK_IMAGE_URL
            };
        } else {
            return ExGodsCore.app.references.get('user_shape').getByKey(shape);
        }
    },
    /**
     *  URL   
     * @return {String}
     */
    getThumb: function() {
        var shape = this.getShape();
        if (shape) {
            return shape.thumb;
        } else {
            return '';
        }
    },
    /**
     *      : ,  (   )  npc
     * @return {String}
     */
    getType: function() {
        var botData = this.get('bot_data');
        if (!botData) {
            return 'user';
        } else if (botData.hostile) {
            return 'bot';
        } else {
            return 'npc';
        }
    },
    getWorld: function() {
        return this.get('binding').world;
    },
    getGuild: function() {
        return this.get('binding').guild;
    }
});

/**
 *  
 */
Ext.define('ExGodsCore.model.Feature', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'comment',
            type: 'string'
        },
        {
            name: 'created',
            type: 'string'
        },
        {
            name: 'ended',
            type: 'auto'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'hidden',
            type: 'int',
            defaultValue: 0
        },
        {
            name: 'source',
            type: 'string'
        },
        {
            //     
            // ,    4  ( "turn")   - 2
            name: 'step',
            type: 'int'
        },
        {
            name: 'talant',
            type: 'int'
        },
        {
            //  
            name: 'proto',
            type: 'string'
        },
        {
            //  
            name: 'type',
            type: 'string'
        },
        {
            //      (.   "step")
            name: 'turn',
            type: 'int'
        },
        {
            name: 'value',
            type: 'auto'
        }
    ]
});

/**
 *  
 */
Ext.define('ExGodsCore.model.Item', {
    extend: Ext.data.Model,
    idProperty: 'item_id',
    fields: [
        {
            name: 'item_id',
            type: 'int'
        },
        {
            name: 'param',
            type: 'auto'
        },
        {
            name: 'features',
            type: 'auto'
        },
        {
            name: 'proto_id',
            type: 'int'
        },
        {
            name: 'slot_id',
            type: 'int'
        },
        {
            // ,   
            name: 'clothed',
            type: 'int'
        },
        //   
        {
            name: 'stack_ids',
            type: 'auto'
        },
        //   
        {
            name: 'groupdur',
            type: 'auto'
        },
        {
            name: 'count',
            type: 'int'
        }
    ],
    proxy: 'memory',
    /**
     *   
     * 
     * @return {ExGods.model.ItemPrototype}
     */
    getProto: function() {
        return ExGods.app.getItemPrototypesStore().data.getByKey(this.get('proto_id'));
    },
    getType: function() {
        var proto = this.getProto(),
            type = proto.get('type');
        return ExGodsCore.app.references.get('item_type').getByKey(type);
    },
    /**
     *    
     */
    getDur: function() {
        return parseInt(this.get('param').dur);
    },
    /**
     *    
     */
    getMaxDur: function() {
        var proto = this.getProto();
        if (proto) {
            return this.getProto().get('param').dur;
        }
    },
    /**
     *  ,   
     */
    isDamaged: function() {
        var me = this;
        return me.getDur() < me.getProto().get('param').dur;
    },
    /**
     * true,    
     */
    isUpgraded: function() {
        return this.get('param').upgrades > 0;
    },
    // isEqual: function(a, b) {
    //  if (Ext.isDate(a) && Ext.isDate(b)) {
    //      return a.getTime() === b.getTime();
    //  }
    //  return a === b;
    // },
    /**
     *    
     *
     * @return {Boolean}
     */
    isBreakable: function() {
        return !parseInt(this.get('param').nonbr);
    },
    /**
     * ,       
     *
     * @return {Boolean}
     */
    hasCriticalDurability: function() {
        var me = this,
            breakable = me.isBreakable(),
            dur = me.getDur(),
            maxDur = me.getMaxDur();
        //  .   == 1, ,        
        return breakable && dur && maxDur > 1 && dur <= ExGodsCore.app.references.get('constants').get('critical_item_durability').value;
    },
    /**
     *   
     *
     * @param {Number} cost   
     * @param {Boolean} allInStack   ,    ( ). Default false
     * @param {Boolean} format    . Default false
     *
     * @return {Number/String}  
     */
    calcPrice: function(cost, withStack, format) {
        var me = this,
            k = ExGodsCore.app.references.get('constants').get('sell_wear_percent').value / 100,
            dur = me.getDur(),
            maxDur = me.getProto().get('param').dur,
            count = me.get('count'),
            price = Math.floor(cost * (1 - (1 - dur / maxDur) * (1 - k)));
        if (withStack && count) {
            price *= count;
        }
        return format ? Ext.util.Format.number(price, '0,0') : price;
    },
    /**
     *  true,     
     */
    isExpired: function() {
        var me = this,
            validto = me.getProto().get("data").validto,
            expire = me.get('param').expire_str,
            now = new Date();
        if (validto) {
            validto = ExGodsCore.util.Date.normalizeServerDateTime(validto);
        } else {
            validto = 0;
        }
        if (expire) {
            expire = ExGodsCore.util.Date.normalizeServerDateTime(expire);
        } else {
            expire = 0;
        }
        expire = Math.max(expire, validto);
        if (expire != 0 && expire - now < 0) {
            return true;
        } else {
            return false;
        }
    }
});

/**
 *   
 */
Ext.define('ExGodsCore.model.Slot', {
    extend: Ext.data.Model,
    idProperty: 'ekey',
    fields: [
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'ekey',
            type: 'int'
        },
        {
            name: 'type',
            type: 'int'
        },
        {
            name: 'protect',
            type: 'auto'
        },
        {
            name: 'features',
            type: 'auto'
        },
        {
            name: 'items',
            type: 'auto',
            convert: function(itemsData, record) {
                if (!itemsData)  {
                    return itemsData;
                }
                
                var me = this,
                    items = record.itemsStore,
                    missedProtos = [],
                    protos = ExGodsCore.app.getItemPrototypesStore(),
                    cntByProtoId = new Ext.util.HashMap(),
                    cntByProtoIdNew = new Ext.util.HashMap();
                var collectIds = function(cntByProtoId) {
                        var res = [];
                        items.each(function(rec) {
                            if (rec.isExpired()) {
                                return;
                            }
                            var cnt = rec.get('count');
                            var cnt__ = cntByProtoId.get(rec.get('proto_id')) ? cntByProtoId.get(rec.get('proto_id')) : 0;
                            cnt += cnt__;
                            cntByProtoId.add(rec.get('proto_id'), cnt);
                            var stack_ids = rec.get('stack_ids');
                            if (Ext.isArray(stack_ids)) {
                                res = Ext.Array.merge(res, stack_ids);
                            } else {
                                res.push(rec.get('item_id'));
                            }
                        });
                        return res;
                    };
                //   ids     
                collectIds(cntByProtoId);
                //        
                Ext.Array.forEach(itemsData, function(item) {
                    var proto_id = parseInt(item.proto_id);
                    if (!protos.data.getByKey(proto_id) && !Ext.Array.contains(missedProtos, proto_id)) {
                        missedProtos.push(proto_id);
                    }
                });
                protos.loadNew(missedProtos, function() {
                    var grouped = record.groupItems(itemsData);
                    if (!items.isDestroyed) {
                        items.loadRawData(grouped);
                    }
                    //    
                    collectIds(cntByProtoIdNew);
                    var newCntItems = 0;
                    cntByProtoIdNew.each(function(rec, val) {
                        var oldVal = cntByProtoId.get(rec) ? cntByProtoId.get(rec) : 0;
                        val -= oldVal;
                        newCntItems += val;
                    });
                    if (newCntItems > 0) {
                        record.fireEvent('newitemsadded', record, {
                            length: newCntItems
                        });
                    }
                });
                return items;
            }
        }
    ],
    proxy: 'memory',
    constructor: function(config) {
        var me = this;
        me.itemsStore = Ext.create('Ext.data.Store', {
            model: 'ExGodsCore.model.Item'
        });
        me.callParent(arguments);
    },
    //
    // @oleg commented cause addEvents is deprecated in 5.1.1
    //
    // me.addEvents(
    //  /**
    //   * @event newitemsadded
    //   *       
    //   */
    //  'newitemsadded',
    //  *
    //   * @event highlight
    //   *     
    //  'highlight',
    //  /**
    //   * @event unhighlight
    //   *      
    //   */
    //  'unhighlight'
    // );
    /**
     *    
     * @private
     */
    afterEdit: function() {
        var me = this,
            changes = me.getChanges();
        /**
         * @event change
         * ,    
         * @param {Ext.Component} this
         */
        me.fireEvent('change', me);
        if (changes.protect) {
            me.fireEvent('protect', me);
        }
    },
    /**
     *    
     * @return {Ext.data.Store}  
     */
    items: function() {
        return this.itemsStore;
    },
    /**
     *   
     * 
     * Note:    .
     *   ,      .
     *
     * @param {Array} items 
     */
    groupItems: function(items) {
        var groups = new Ext.util.HashMap(),
            protos = ExGodsCore.app.getItemPrototypesStore(),
            newItems = [],
            groupedItem,
            i = 0,
            item;
        //   ,       ,       . ,
        //       (, )      
        items.sort(function(a, b) {
            if (a.param.from_shop == 1 && b.param.from_shop != 1) {
                return 1;
            } else if (b.param.from_shop == 1 && a.param.from_shop != 1) {
                return -1;
            } else {
                return 0;
            }
        });
        for (; i < items.length; i++) {
            var item = items[i],
                proto_id = parseInt(item.proto_id),
                proto = protos.data.getByKey(proto_id);
            if (proto.isStack()) {
                //     
                groupedItem = groups.get(proto_id);
                if (groupedItem) {
                    groupedItem.stack_ids.push(parseInt(item.item_id));
                    groupedItem.groupdur += parseInt(item.param.dur);
                    groupedItem.count += parseInt(item.param.count) || 1;
                } else {
                    item.stack_ids = [
                        parseInt(item.item_id)
                    ];
                    item.groupdur = parseInt(item.param.dur);
                    item.count = parseInt(item.param.count) || 1;
                    groups.add(proto_id, item);
                    newItems.push(item);
                }
            } else {
                item.count = parseInt(item.param.count) || 1;
                newItems.push(item);
            }
        }
        return newItems;
    },
    /**
     * @deprecated Instead use getSlotTypeInfo
     * 
     *   
     * @return {Object}  
     */
    getSlotType: function() {
        return ExGodsCore.app.references.get('slot_type').getByKey(this.get('type'));
    },
    /**
     *         
     * @return {Object}  
     */
    getSlotTypeInfo: function() {
        return ExGodsCore.app.references.get('slot_type').getByKey(this.get('type'));
    },
    /**
     *    
     */
    destroyStores: function() {
        var me = this;
        if (me.itemsStore) {
            me.itemsStore.destroyStore();
            me.itemsStore = null;
        }
    },
    checkExpired: function(onExpire) {
        var me = this,
            expired = [];
        me.itemsStore.each(function(item) {
            if (item.isExpired()) {
                expired.push(item);
            }
        });
        if (expired.length) {
            me.itemsStore.remove(expired);
            if (onExpire) {
                onExpire(expired);
            }
        }
    }
});

/**
 *  ,    
 */
Ext.define('ExGodsCore.store.Slots', {
    extend: Ext.data.Store,
    model: 'ExGodsCore.model.Slot',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'type',
            direction: 'ASC'
        }
    ],
    /**
     *     "",   
     * @return {Array}
     */
    getShapesSlots: function() {
        var me = this,
            result = [];
        me.each(function(slot) {
            var slotType = ExGodsCore.app.references.get('slot_type').getByKey(slot.get('type'));
            if (slotType && slotType.active == 3) {
                result.push(slot);
            }
        });
        return result;
    },
    /**
     *   Ext.data.AbstractStore
     */
    destroyStore: function() {
        var me = this;
        if (!me.isDestroyed) {
            //       
            me.each(function(item) {
                item.destroyStores();
            });
        }
        me.callParent(arguments);
    },
    /**
     * ,     
     */
    hasItem: function(protoId) {
        var me = this,
            hasItem = false;
        me.each(function(slot) {
            slot.items().each(function(slotItem) {
                if (slotItem.data.proto_id == protoId) {
                    hasItem = true;
                }
            });
        });
        return hasItem;
    },
    /**
     *  - ,    
     */
    getItemCount: function(protoId) {
        var me = this,
            count = 0;
        me.each(function(slot) {
            slot.items().each(function(slotItem) {
                if (slotItem.data.proto_id == protoId) {
                    count += slotItem.data.count;
                }
            });
        });
        return count;
    }
});

/**
 *   
 *
 *      .   set   
 *    Object.
 *
 *  <code>payment</code>    ,  
 *       .
 */
Ext.define('ExGodsCore.model.User', {
    extend: ExGodsCore.model.BasicUser,
    proxy: 'memory',
    //      ,   User     BasicUser, 
    //   
    /**
     * ,    
     */
    userVersion: 0,
    fields: [
        {
            name: 'achievements',
            type: 'auto'
        },
        {
            //   
            name: 'contact',
            type: 'auto'
        },
        {
            // 
            name: 'counters',
            type: 'auto'
        },
        {
            //  
            name: 'enterkey',
            type: 'auto'
        },
        {
            name: 'email',
            type: 'string'
        },
        {
            //    
            name: 'money',
            type: 'auto',
            convert: function(v, rec) {
                if (Ext.isObject(v)) {
                    //   , ..        
                    //     
                    ExGodsCore.app.references.get('user_money').eachKey(function(key, item) {
                        if (v[key]) {
                            v[key] = parseInt(v[key]);
                        } else {
                            v[key] = 0;
                        }
                    });
                }
                return v;
            }
        },
        {
            //  
            name: 'lastenter',
            type: 'auto'
        },
        {
            name: 'payment',
            type: 'string'
        },
        {
            //  
            name: 'public',
            type: 'auto'
        },
        {
            name: 'ratings',
            type: 'auto',
            convert: function(v) {
                if (Ext.isArray(v)) {
                    Ext.Array.sort(v, function(a, b) {
                        a.l_order = parseInt(a.l_order);
                        b.l_order = parseInt(b.l_order);
                        return a.l_order > b.l_order ? 1 : (a.l_order < b.l_order ? -1 : 0);
                    });
                }
                return v;
            }
        },
        {
            //  
            name: 'read_hints',
            type: 'auto'
        },
        {
            //  {Object}
            //   :  
            name: 'settings',
            type: 'auto'
        },
        {
            //     
            name: 'social',
            type: 'auto'
        },
        {
            //  
            name: 'timed',
            type: 'auto',
            defaultValue: null
        },
        {
            //  
            name: 'feature',
            type: 'auto',
            convert: function(v, record) {
                if (!v)  {
                    return v;
                }
                
                var features = record.initFeatures(),
                    counter = 0;
                if (Ext.isArray(v)) {
                    Ext.Array.forEach(v, function(feature) {
                        if (!feature.hidden && !features.data.getByKey(parseInt(feature.entry))) {
                            counter++;
                        }
                    });
                }
                features.loadRawData(v);
                if (counter) {
                    features.fireEvent('featuresadded', counter);
                }
                return features;
            }
        },
        {
            name: 'slots',
            type: 'auto',
            convert: function(v, record) {
                if (!v)  {
                    return v;
                }
                
                var slots = record.initSlots(),
                    i = 0,
                    slotData,
                    initial = slots.getCount() == 0;
                for (; i < v.length; i++) {
                    var slotData = v[i],
                        slot = slots.data.getByKey(parseInt(slotData.ekey));
                    // ,        .
                    if (slot) {
                        slot.set(slotData);
                    } else {
                        slots.loadRawData([
                            slotData
                        ], true);
                        if (!initial) {
                            slots.fireEvent('new_slot', slots.data.getByKey(parseInt(slotData.ekey)));
                        }
                    }
                }
                //  !
                slots.fireEvent('items_changed');
                return slots;
            }
        },
        {
            name: 'next_price_protect',
            //  
            type: 'auto'
        },
        /*
         *     (ekey, live, side)
         */
        {
            name: 'battle',
            type: 'auto',
            convert: function(v) {
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key, value, myself) {
                        if (!Ext.isObject(myself[key]))  {
                            myself[key] = parseInt(value);
                        }
                        
                    });
                }
                return v;
            }
        },
        {
            //    
            name: 'battle_state',
            type: 'auto'
        },
        {
            //   .     ,        -  .
            name: 'aura',
            type: 'auto'
        },
        /**
         *  -   .      .
         */
        {
            name: 'is_bot',
            type: 'int'
        },
        /**
         *  -   .      .
         */
        {
            name: 'real_user',
            type: 'auto'
        }
    ],
    /**
     * @property {Ext.data.Store} featureStore
     *  
     */
    /**
     * @property {Object} updateInterval
     *       
     */
    constructor: function() {
        var me = this;
        me.updateInterval = {};
        me.callParent(arguments);
    },
    initFeatures: function() {
        var me = this;
        if (!me.featureStore) {
            me.featureStore = Ext.create('Ext.data.Store', {
                model: 'ExGodsCore.model.Feature',
                avatar_ruin_count: 0,
                // ,  .
                proxy: {
                    type: 'ajax',
                    url: '/game.pl?cmd=feature.list',
                    limitParam: false,
                    pageParam: false,
                    startParam: false,
                    reader: {
                        type: 'json',
                        root: 'user.feature'
                    }
                }
            });
        }
        return me.featureStore;
    },
    initSlots: function() {
        var me = this;
        if (!me.slotsStore)  {
            me.slotsStore = Ext.create('ExGodsCore.store.Slots');
        }
        
        return me.slotsStore;
    },
    get: function(field) {
        var me = this;
        switch (field) {
            case 'feature':
                return me.initFeatures();
                break;
            case 'slots':
                return me.initSlots();
                break;
            default:
                return me.callParent(arguments);
                break;
        }
    },
    /**
     *   
     * @param {String} key    timed (   : hp, mp  endur)
     * @param {String} startTime      
     * @param {String} startkeyValue        
     */
    updateTimed: function(key, startTime, startkeyValue) {
        var me = this,
            timed = me.data.timed[key],
            curTimed = timed[0],
            now = Date.now();
        timed[0] = startkeyValue + (Math.round((now - startTime) / 1000) - 1) * timed[2];
        if (timed[0] >= timed[1]) {
            timed[0] = timed[1];
            clearInterval(me.updateInterval[key]);
        }
        if (me == ExGods.app.user && timed[3] && now - 3000 >= /* ,   2-4  */
        timed[3]) {
            if (me.loading_timed)  {
                return;
            }
            
            me.loading_timed = true;
            me.loadRemote(function() {
                me.loading_timed = false;
                me.fireEvent(key + 'changed', me.data.timed[key], me.data.timed[key][0] != curTimed);
            });
        }
        me.fireEvent(key + 'changed', timed, timed[0] != curTimed);
    },
    features: function() {
        return this.initFeatures();
    },
    slots: function() {
        return this.initSlots();
    },
    getBattle: function() {
        return parseInt(this.get('binding').battle);
    },
    /**
     *  
     * @param {String} key 
     */
    getBattleInfo: function(key) {
        var me = this,
            battle = me.get('battle');
        if (battle) {
            if (key) {
                return battle[key];
            } else {
                return battle;
            }
        }
        return false;
    },
    getBattleEkey: function() {
        return this.getBattleInfo('ekey');
    },
    /**
     *  ,    
     *
     * @return {Number}   1  2
     */
    getBattleSide: function() {
        var battle = this.get('battle');
        if (battle && battle.side != undefined) {
            return battle.side;
        } else {
            return false;
        }
    },
    /**
     *    ,    
     *
     * @return {String}
     */
    getSocialNet: function() {
        var social = this.get('social');
        return social ? social.social_net : false;
    },
    /**
     *     
     * @param {String} settingName
     * @param {String} defaultValue
     * @return {String}    defaultValue,    
     *
     */
    getSetting: function(settingName, defaultValue) {
        var me = this,
            setting = this.get('settings')[settingName];
        return typeof setting == 'object' ? setting.value : defaultValue;
    },
    setSetting: function(name, value) {
        var me = this,
            settings = me.get('settings');
        if (typeof settings[name] == 'object') {
            settings[name].value = value;
            me.set({
                settings: settings
            });
            me.fireEvent('setting_change', name, value);
        }
    },
    /**
     *  ,     
     * 
     * @return {Boolean}
     */
    isBattle: function() {
        return this.getBattle() ? true : false;
    },
    /**
     *         
     * 
     * @return {Boolean}
     */
    isLiveInBattle: function() {
        return this.getBattleInfo('live') === 1;
    },
    /**
     *  true,     
     */
    isChain: function() {
        var me = this;
        return parseInt(me.get('binding').battle_chain) ? true : false;
    },
    set: function() {
        var me = this;
        me.callParent(arguments);
        me.userVersion = me.userVersion + 1;
        me.fireEvent('change_user_version', me);
    },
    /**
     *    
     * @private
     */
    afterEdit: function() {
        var me = this;
        /**
         * @event change
         * ,    
         * @param {Ext.Component} this
         */
        me.fireEvent('change', me);
        var changes = me.getChanges();
        Ext.Object.each(changes, function(key, value) {
            /**
             * @event statschanged
             * ,    
             * @param {Ext.Component} this
             */
            /**
             * @event timedchanged
             * ,      (hp, mp, endur)
             * @param {Ext.Component} this
             */
            if (key != 'talant')  {
                // TODO:    , ..  talant   2- 
                me.fireEvent(key + 'changed', me, value, me.modified[key]);
            }
            
            if (value != null) {
                switch (key) {
                    case 'binding':
                        if (Ext.isObject(value)) {
                            var modified = me.modified[key] || {};
                            Ext.Object.each(value, function(key, value) {
                                if (value != modified[key]) {
                                    /**
                                     * @event roomchanged
                                     *    
                                     * @param {Number} newValue  
                                     * @param {Number} oldValue  
                                     */
                                    /**
                                     * @event worldchanged
                                     *    
                                     * @param {Number} newValue  
                                     * @param {Number} oldValue  
                                     */
                                    me.fireEvent(key + 'changed', value, modified[key]);
                                }
                            });
                        };
                        break;
                    case 'hoard':
                        if (Ext.isObject(value)) {
                            var modified = me.modified[key] || {};
                            Ext.Object.each(value, function(key, value) {
                                if (value != modified[key]) {
                                    /**
                                     * @event expachanged
                                     *    
                                     * @param {Number} newValue   
                                     * @param {Number} oldValue   
                                     * @param {ExGods.model.User} this 
                                     */
                                    /**
                                     * @event valourchanged
                                     *    
                                     * @param {Number} newValue   
                                     * @param {Number} oldValue   
                                     * @param {ExGods.model.User} this 
                                     */
                                    me.fireEvent(key + 'changed', value, modified[key], me);
                                }
                            });
                        };
                        break;
                    case 'money':
                        if (Ext.isObject(value)) {
                            var modified = me.modified[key] || {};
                            var hasChanges = false;
                            Ext.Object.each(value, function(subkey, value) {
                                if (value != modified[subkey]) {
                                    /**
                                     * @event moneycrystalchanged
                                     *       
                                     * @param {Number} newValue   
                                     * @param {Number} oldValue   
                                     * @param {ExGods.model.User} this 
                                     */
                                    /**
                                     * @event moneyglorychanged
                                     * @param {Number} newValue  
                                     * @param {Number} oldValue  
                                     * @param {ExGods.model.User} this 
                                     */
                                    /**
                                     * @event moneygoldchanged
                                     * @param {Number} newValue  
                                     * @param {Number} oldValue  
                                     * @param {ExGods.model.User} this 
                                     */
                                    /**
                                     * @event moneytalantchanged
                                     * @param {Number} newValue  
                                     * @param {Number} oldValue  
                                     * @param {ExGods.model.User} this 
                                     */
                                    me.fireEvent(key + subkey + 'changed', value, modified[subkey], me, subkey);
                                    hasChanges = true;
                                }
                            });
                            if (hasChanges) {
                                /**
                                 * @event moneychanged
                                 * @param {Object}  
                                 * @param {Object}  
                                 * @param {ExGods.model.User} this 
                                 */
                                me.fireEvent('moneychanged', value, modified, me);
                            }
                        };
                        break;
                    case 'timed':
                        Ext.Object.each(value, function(key, value) {
                            var current = value[0];
                            max = value[1] , speed = value[2];
                            /**
                             * @event hpchanged
                             *     
                             * @param {Number[]} hp   
                             */
                            /**
                             * @event mpchanged
                             *     
                             * @param {Number[]} hp   
                             */
                            /**
                             * @event shieldchanged
                             *     
                             * @param {Number[]} energy   
                             */
                            /**
                             * @event energychanged
                             *     
                             * @param {Number[]} energy   
                             */
                            me.fireEvent(key + 'changed', value);
                            if (me.updateInterval[key]) {
                                clearInterval(me.updateInterval[key]);
                                me.updateInterval[key] = 0;
                            }
                            if (speed && current < max) {
                                var startTime = Date.now(),
                                    startKeyValue = me.data.timed[key][0];
                                me.updateInterval[key] = setInterval(function() {
                                    me.updateTimed(key, startTime, startKeyValue);
                                }, 1000);
                            }
                        });
                        break;
                    default:
                        break;
                }
            }
        });
        me.commit();
    },
    /**
     *    
     */
    loadRemote: function(callback, scope) {
        var me = this;
        Ext.Ajax.request({
            url: HOST_URL + '/game.pl?cmd=user',
            queue: true,
            success: function(response) {
                var result = Ext.decode(response.responseText, true);
                if (result) {
                    me.set(result);
                }
                if (callback) {
                    callback.call(scope || me, result);
                }
            }
        });
    },
    /**
     * ,     
     * @param {featureName}  
     * @return {Boolean}
     */
    hasFeature: function(featureType) {
        var me = this,
            feature;
        feature = me.features().findBy(function(item) {
            return item.get('type') == featureType;
        });
        return feature != -1 ? true : false;
    },
    /**
     *    
     */
    destroyStores: function() {
        var me = this;
        if (me.featureStore) {
            me.featureStore.destroyStore();
            me.featureStore = null;
        }
        if (me.slotsStore) {
            me.slotsStore.destroyStore();
            me.slotsStore = null;
        }
        if (me.talentsStore) {
            me.talentsStore.destroyStore();
            me.talentsStore = null;
        }
    }
});

/**
 *   
 *
 *      .   set   
 *    Object.
 */
Ext.define('ExGods.model.BasicUser', {
    extend: ExGodsCore.model.BasicUser,
    idProperty: 'title',
    fields: [
        {
            //    
            name: 'ready_pupil',
            type: 'int'
        },
        {
            //   
            name: 'mask_proto_id',
            type: 'int'
        },
        {
            //  
            name: 'guild',
            type: 'auto',
            convert: function(v) {
                if (typeof v != 'object') {
                    return '';
                }
                return v;
            }
        },
        {
            //   
            name: 'mask_group',
            type: 'string'
        }
    ],
    /**
     *    
     * @return {String}
     */
    getRankName: function() {
        return ExGods.references.get('user_valour').getByKey(parseInt(this.get('hoard').rank)).data.rank;
    },
    /**
     *     
     * 
     * @return {Object}
     */
    getValourRef: function() {
        var hoard = this.get('hoard'),
            ref = false;
        if (!hoard || hoard.rank == undefined)  {
            return false;
        }
        
        ref = ExGods.references.get('user_valour').getByKey(hoard.rank);
        return ref;
    },
    /**
     *     
     * 
     * @return {Number}
     */
    getValourLevel: function() {
        var valour = this.get('hoard').valour,
            levels = ExGods.references.get('user_valour'),
            level = 0;
        levels.each(function(item, index, length) {
            if (valour < item.valour) {
                level = index;
                return false;
            }
        });
        return level;
    },
    /**
     *      
     */
    setRaidAchievements: function(achievements) {
        achievements = achievements || this.get('achievements') || [];
        var me = this,
            ids = Ext.Array.map(achievements, function(el) {
                return el.achievement_id || el.id;
            });
        ExGods.app.getGuildRaidsStore().each(function(rec) {
            var achievement = rec.get('achievement');
            if (!achievement)  {
                return;
            }
            
            if (ids.indexOf(achievement.id) != -1) {
                rec.set('counter', 1);
            } else {
                rec.set('counter', 0);
            }
        });
    }
});

/**
 *  
 */
Ext.define('ExGods.model.Feature', {
    extend: ExGodsCore.model.Feature,
    fields: [
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description2',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto',
            convert: function(v) {
                var images = {};
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key) {
                        images[key] = IMAGE_URL + v[key];
                    });
                }
                return images;
            }
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            // ,    
            name: 'trauma',
            type: 'int'
        },
        {
            // ,      (     )
            name: 'multiple',
            type: 'int'
        },
        {
            name: 'hidden',
            type: 'int'
        },
        {
            name: 'grade',
            type: 'int'
        }
    ]
});

/**
 *   
 *
 *      .   set   
 *    Object.
 *
 *  <code>payment</code>    ,  
 *       .
 */
Ext.define('ExGods.model.User', {
    extend: ExGodsCore.model.User,
    mixins: [
        ExGods.model.BasicUser
    ],
    proxy: 'memory',
    //      ,   User     BasicUser, 
    //   
    fields: [
        {
            name: 'achievements',
            type: 'auto'
        },
        {
            //     
            //      
            name: 'peril_rel',
            type: 'float'
        },
        {
            //   
            name: 'contact',
            type: 'auto'
        },
        {
            // 
            name: 'counters',
            type: 'auto'
        },
        {
            //  
            name: 'enterkey',
            type: 'auto'
        },
        {
            // elo ratings
            name: 'elo',
            type: 'auto',
            convert: function(v, rec) {
                var elo = {};
                Ext.Array.each(v, function(el) {
                    for (var key in el) {
                        elo[key] = el[key];
                    }
                });
                return elo;
            }
        },
        {
            name: 'email',
            type: 'string'
        },
        {
            //    
            name: 'money',
            type: 'auto',
            convert: function(v, rec) {
                if (Ext.isObject(v)) {
                    //   , ..        
                    //     
                    ExGods.app.references.get('user_money').eachKey(function(key, item) {
                        if (v[key]) {
                            v[key] = parseInt(v[key]);
                        } else {
                            v[key] = 0;
                        }
                    });
                } else {
                    v = "";
                }
                return v;
            }
        },
        {
            //  
            name: 'lastenter',
            type: 'auto'
        },
        {
            name: 'payment',
            type: 'string'
        },
        {
            //  
            name: 'public',
            type: 'auto'
        },
        {
            name: 'ratings',
            type: 'auto',
            convert: function(v) {
                if (Ext.isArray(v)) {
                    Ext.Array.sort(v, function(a, b) {
                        a.l_order = parseInt(a.l_order);
                        b.l_order = parseInt(b.l_order);
                        return a.l_order > b.l_order ? 1 : (a.l_order < b.l_order ? -1 : 0);
                    });
                }
                return v;
            }
        },
        {
            //  
            name: 'read_hints',
            type: 'auto'
        },
        {
            name: 'reg_date',
            type: 'date',
            dateFormat: serverDateTimeFormat
        },
        {
            //  {Object}
            //   :  
            name: 'settings',
            type: 'auto'
        },
        {
            //     
            name: 'social',
            type: 'auto'
        },
        {
            //  
            name: 'timed',
            type: 'auto',
            defaultValue: null,
            convert: function(v) {
                for (var k in v) {
                    if (v[k] && v[k][0])  {
                        v[k][0] = Number(v[k][0]);
                    }
                    
                    if (v[k] && v[k][3])  {
                        v[k][3] = ExGods.util.Date.normalizeUnixTime(v[k][3]);
                    }
                    
                }
                return v;
            }
        },
        /*
         *   
         */
        {
            name: 'trace_quest_proto',
            type: 'int'
        },
        {
            //available_quests
            name: 'available_quests',
            type: 'auto',
            convert: function(v, record) {
                var store = record.initAvailableQuests();
                Ext.each(v, function(quest) {
                    var q = store.findRecord('proto_id', quest.proto_id);
                    if (q && q.get('expanded')) {
                        quest.expanded = q.get('expanded');
                    }
                });
                store.loadRawData(v);
                return store;
            }
        },
        {
            name: 'is_creator',
            type: 'int'
        },
        /**
         *   
         */
        {
            name: 'bot_visible_battle_actions',
            type: 'auto'
        },
        {
            name: 'bot_visible_instants',
            type: 'auto'
        },
        {
            name: 'bot_visible_turns',
            type: 'auto'
        },
        {
            //    
            name: 'stores',
            type: 'auto',
            convert: function(v, record) {
                if (!v)  {
                    return;
                }
                
                v = v || [];
                //           
                var virtualStore = ExGods.app.getStore('VirtualStore'),
                    lootStore = ExGods.app.getStore('Loot'),
                    virtual = [],
                    loot = [];
                for (var i = 0; i < v.length; i++) {
                    for (var j = 0; j < v[i].stuff.length; j++) {
                        var recData = {
                                entry: v[i].entry,
                                add_time: v[i].add_time,
                                source_id: v[i].source_id,
                                source_name: v[i].source_name,
                                destinations: v[i].destinations,
                                params: v[i].params,
                                index: j,
                                stuff: v[i].stuff[j]
                            };
                        if (v[i].source_name == 'loot') {
                            loot.push(recData);
                        } else {
                            virtual.push(recData);
                        }
                    }
                }
                virtualStore.loadRawData(virtual);
                lootStore.loadRawData(loot);
                return virtualStore;
            }
        },
        {
            //   
            name: 'mask_proto_id',
            type: 'int'
        },
        {
            name: 'ingredients',
            type: 'auto',
            convert: function(v) {
                return v || [];
            }
        },
        {
            //  
            name: 'guild',
            type: 'auto',
            convert: function(v) {
                if (typeof v != 'object') {
                    return '';
                }
                return v;
            }
        }
    ],
    /**
     * @property {Ext.data.Store} featureStore
     *  
     */
    /**
     * @property {Object} updateInterval
     *       
     */
    constructor: function() {
        var me = this;
        me.updateInterval = {};
        me.callParent(arguments);
    },
    initAvailableQuests: function() {
        var me = this;
        if (!me.availableQuestsStore)  {
            me.availableQuestsStore = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.Quest',
                sorters: [
                    {
                        sorterFn: function(a, b) {
                            var ret = 0;
                            if (a.get('story') == 3 && b.get('story') != 3)  {
                                ret = -1;
                            }
                            
                            if (b.get('story') == 3 && a.get('story') != 3)  {
                                ret = 1;
                            }
                            
                            if (!a.get('repeat') && !a.get('timeout') && a.get('story') == 1 && (b.get('repeat') || b.get('timeout') || b.get('story') != 1))  {
                                ret = -1;
                            }
                            
                            if (!b.get('repeat') && !b.get('timeout') && b.get('story') == 1 && (a.get('repeat') || a.get('timeout') || a.get('story') != 1))  {
                                ret = 1;
                            }
                            
                            if (a.get('status') == 2 && b.get('status') != 2)  {
                                ret = 1;
                            }
                            
                            if (b.get('status') == 2 && a.get('status') != 2)  {
                                ret = -1;
                            }
                            
                            return ret;
                        }
                    }
                ]
            });
        }
        
        return me.availableQuestsStore;
    },
    initFeatures: function() {
        var me = this;
        if (!me.featureStore) {
            me.featureStore = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.Feature',
                avatar_ruin_count: 0,
                // ,  .
                getExpFeatures: function() {
                    var me = this,
                        ret = [];
                    me.each(function(feature) {
                        if (feature.data.type == 'battle_exp_add' || feature.data.type == 'experience') {
                            ret.push(feature);
                        }
                    });
                    Ext.Array.sort(ret, function(f1, f2) {
                        f1 = new Date(f1.get('ended').split('-').join('/')).getTime();
                        f2 = new Date(f2.get('ended').split('-').join('/')).getTime();
                        return f1 > f2;
                    });
                    return ret;
                },
                // proxy: {
                //  type: 'ajax',
                //  url: '/game.pl?cmd=feature.list',
                //  limitParam: false,
                //  pageParam: false,
                //  startParam: false,
                //  reader: {
                //      type: 'json',
                //      root: 'user.feature'
                //  }
                // },
                listeners: {
                    load: {
                        fn: function() {
                            var newAvatarRuinCount = 0;
                            this.each(function(feature) {
                                //  ,  .
                                if (feature.data.type == 'avatar_ruin') {
                                    newAvatarRuinCount++;
                                }
                            });
                            if (newAvatarRuinCount != me.featureStore.avatar_ruin_count) {
                                //  ,  , 
                                me.fireEvent('avatar_ruin_changed', me);
                                me.featureStore.avatar_ruin_count = newAvatarRuinCount;
                            }
                        }
                    }
                }
            });
        }
        return me.featureStore;
    },
    initSlots: function() {
        var me = this;
        if (!me.slotsStore) {
            me.slotsStore = Ext.create('ExGodsCore.store.Slots');
        }
        return me.slotsStore;
    },
    get: function(field) {
        var me = this;
        switch (field) {
            case 'feature':
                return me.initFeatures();
                break;
            case 'slots':
                return me.initSlots();
                break;
            default:
                return me.callParent(arguments);
                break;
        }
    },
    /**
     *    
     * @return {String}
     */
    getBattleAvatar: function() {
        return this.getShape().battle;
    },
    /**
     *     
     * 
     * @return {Number[]}
     */
    getEndurance: function() {
        try {
            return this.get('timed').endur;
        } catch (e) {
            return false;
        }
    },
    /**
     *     
     * 
     * @return {Number[]}
     */
    getEnergy: function() {
        try {
            return this.get('timed').energy;
        } catch (e) {
            return false;
        }
    },
    /**
     *     ,   -  true
     */
    checkStuff: function(stuff, options) {
        if (!stuff || stuff.length == 0)  {
            return true;
        }
        
        var me = this,
            valid = true;
        options = options || {};
        stuff = (Ext.isArray(stuff)) ? stuff : [
            stuff
        ];
        Ext.each(stuff, function(item) {
            if (!valid)  {
                return;
            }
            
            switch (item.type) {
                case 'timed':
                    valid = me.get('timed')[item.params.id][0] >= item.params.quantity;
                    break;
                case 'currency':
                    valid = me.get('money')[item.params.id] >= item.params.quantity;
                    break;
                case 'item':
                    var count = item.params.quantity,
                        haveItems = me.getItemsCountByProto(item.params.id, options.activeSlot);
                    valid = count <= haveItems;
                    break;
                case 'ingredients':
                    var count = item.params.quantity,
                        haveItems = me.getIngredientCountByName(item.params.id);
                    valid = count <= haveItems;
                    break;
                default:
                    break;
            }
        });
        return valid;
    },
    /**
     *       proto_id
     */
    getItemsCountByProto: function(proto_id, activeSlot) {
        var me = this,
            count = 0;
        me.slots().each(function(slot) {
            if (activeSlot && slot.get('type') != 14)  {
                return;
            }
            
            slot.itemsStore.each(function(el) {
                if (el.get('proto_id') == proto_id) {
                    var l = el.get('stack_ids') ? el.get('stack_ids').length || 1 : 1;
                    l = l * (Number(el.get('param').count) || 1);
                    count += l;
                }
            });
        });
        return count;
    },
    /**
     *         
     */
    getCriticallyDamagedEquippedItems: function() {
        var me = this,
            equipped = me.get('slots').queryBy(function(item) {
                return [
                    1,
                    2,
                    4,
                    5,
                    8,
                    11,
                    12,
                    13
                ].indexOf(item.get('type')) != -1;
            }),
            count = 0;
        equipped.each(function(slot) {
            var item = slot.get('items').getAt(0);
            if (item && item.hasCriticalDurability())  {
                count++;
            }
            
        });
        return count;
    },
    /**
     *    
     */
    destroyStores: function() {
        var me = this;
        if (me.featureStore) {
            me.featureStore.destroyStore();
            me.featureStore = null;
        }
        if (me.slotsStore) {
            me.slotsStore.destroyStore();
            me.slotsStore = null;
        }
    },
    isChatOn: function() {
        return Ext.util.Cookies.get('chat-on') === "1";
    },
    setChatOn: function(value) {
        Ext.util.Cookies.set('chat-on', value ? 1 : 0);
    },
    /**
     *    
     */
    getMaskSlot: function() {
        var me = this,
            slot, item,
            maskSlotType = ExGods.ref('constants|battle_mask_slot').value;
        me.slots().each(function(s) {
            if (s.data.type == maskSlotType) {
                slot = s;
            }
        });
        return slot;
    },
    /**
     *    
     */
    getMaskProto: function() {
        var me = this,
            protos = ExGods.app.getItemPrototypesStore(),
            protoId, proto,
            getProtoIdFromMaskSlot = function() {
                var slot = me.getMaskSlot(),
                    item;
                if (slot) {
                    item = slot.items().first();
                    if (item) {
                        return item.data.proto_id;
                    }
                }
            };
        if (me.get('mask_proto_id')) {
            protoId = me.get('mask_proto_id');
        } else if (ExGods.app.user.get('display_title') == me.get('display_title')) {
            protoId = getProtoIdFromMaskSlot();
        }
        if (protoId) {
            proto = protos.getById(parseInt(protoId));
        }
        if (proto) {
            return proto.data;
        }
    },
    /**
     *        
     *
     * @return {Number}
     */
    getIngredientCountByName: function(name) {
        var ingredients = this.data.ingredients,
            value;
        Ext.Object.each(ingredients, function(index, item) {
            if (name == item.name) {
                value = item.value;
            }
        });
        return value ? value : 0;
    },
    /**
     *    
     * @return {Array}
     */
    getIngredientsByGroup: function(group) {
        var ingredients = this.data.ingredients,
            ref = ExGods.ref('ingredients'),
            info,
            res = [];
        if (ingredients && ingredients.length) {
            Ext.Object.each(ingredients, function(index, item) {
                info = ref.get(item.name);
                if (info && info.group == group) {
                    res.push(item);
                }
            });
        }
        return res;
    },
    /**
     *  -   
     */
    getIngredientsGroupCount: function(group) {
        var ingredients = this.getIngredientsByGroup(group),
            count = 0;
        ingredients.forEach(function(item) {
            count += parseInt(item.value);
        });
        return count;
    }
});

/**
 *    (//npc)
 */
Ext.define('ExGods.store.Users', {
    extend: Ext.data.Store,
    model: 'ExGods.model.User',
    proxy: {
        type: 'memory'
    },
    /**
     *      
     *
     * @param {Number} ekey
     * @return {ExGods.model.User}
     */
    getByEkey: function(ekey) {
        var me = this;
        var index = me.findBy(function(record, id) {
                if (record.getBattleEkey() == ekey) {
                    return true;
                } else {
                    return false;
                }
            });
        if (index > -1) {
            return me.getAt(index);
        }
        return false;
    },
    /**
     *    
     *
     * @return {ExGods.model.User[]}
     */
    getBySide: function(side) {
        var me = this;
        var users = me.queryBy(function(record, id) {
                return record.getBattleSide() === side;
            });
        return users.getRange();
    },
    /**
     *   Ext.data.AbstractStore
     */
    destroyStore: function() {
        var me = this;
        if (!me.isDestroyed) {
            //      
            me.each(function(item) {
                item.destroyStores();
            });
        }
        me.callParent(arguments);
    }
});

/**
 *  
 */
Ext.define('ExGods.model.World', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            // .  
            name: 'blob',
            type: 'auto'
        },
        {
            //    
            name: 'chat_room_name',
            type: 'string'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'title',
            type: 'string'
        }
    ],
    /**
     * ,     
     * @return {Boolean}
     */
    isVisible: function() {
        var visible = this.get('blob').visible;
        return visible && parseInt(visible) ? true : false;
    },
    /**
     *   
     * @return {String}  
     */
    getTitle: function() {
        return this.get('title');
    },
    /**
     *   
     * @return {String}
     */
    getImage: function() {
        var image = this.get('blob').image;
        return image ? IMAGE_URL + this.get('blob').image : Ext.BLANK_IMAGE_URL;
    }
});

/**
 *   
 */
Ext.define('ExGods.store.Worlds', {
    extend: Ext.data.Store,
    model: 'ExGods.model.World'
});

/**
 *  // 
 */
Ext.define('ExGodsCore.model.Ability', {
    extend: Ext.data.Model,
    idProperty: 'name',
    fields: [
        {
            /*
             * Cooldown
             * [current, max]   
             * int -   
             */
            name: 'cd',
            type: 'auto'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            //   
            name: 'short',
            type: 'string'
        },
        {
            //   
            name: 'description',
            type: 'string'
        },
        //   ,    
        {
            // ,    
            name: 'status',
            type: 'int'
        }
    ],
    /**
     *  true,     
     */
    isAvailable: function() {
        var cd = this.get('cd');
        return (parseInt(cd[0]) === 0) ? true : false;
    }
});

/**
 *  // 
 *
 *       :
 * 
 * -   
 * -  
 *
 *   <code>strike</code>:
 * 
 * - strike -    
 * - choose -   (    ?)
 * - target -     
 */
Ext.define('ExGods.model.Ability', {
    extend: ExGodsCore.model.Ability,
    idProperty: 'name',
    fields: [
        {
            // current position for combo
            name: 'pos',
            type: 'int'
        },
        {
            name: 'list',
            type: 'auto'
        },
        {
            //  ,    
            name: 'need',
            type: 'int'
        },
        {
            name: 'count',
            type: 'int'
        },
        {
            name: 'counted',
            type: 'int'
        },
        {
            name: 'strike',
            type: 'auto'
        },
        {
            name: 'battle',
            type: 'int'
        },
        //   ,    
        {
            name: 'school',
            type: 'int'
        }
    ],
    /**
     *  
     */
    isChooseEnemy: function() {
        var me = this,
            strike = me.get('strike');
        return (strike && strike.target == 1);
    },
    /**
     *   (  ?)
     */
    isChooseTarget: function() {
        var me = this,
            strike = me.get('strike');
        return (strike && strike.choose == 1);
    },
    /**
     *      
     */
    isFinishBattleTurn: function() {
        var me = this,
            strike = me.get('strike');
        if (strike) {
            return strike.strike == 1;
        }
        return 0;
    }
});

/**
 *  
 */
Ext.define('ExGods.store.AbilityPrototypes', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Ability',
    proxy: {
        type: 'ajax',
        actionMethods: {
            read: 'POST'
        },
        limitParam: false,
        pageParam: false,
        reader: {
            type: 'json',
            rootProperty: 'list'
        },
        startParam: false
    },
    load: function(options) {
        var me = this;
        options = options || {};
        me.proxy.api = {
            read: HOST_URL + '/game.pl?cmd=battle.ability'
        };
        if (typeof options == 'function') {
            options = {
                callback: options
            };
        }
        options.addRecords = true;
        return me.callParent([
            options
        ]);
    },
    /**
     *     
     *
     * @param {String} protos ID 
     */
    check: function(protos) {
        var me = this,
            missed = [],
            i = 0,
            ln, proto_id;
        protos = Ext.Array.unique(protos);
        ln = protos.length;
        for (; i < ln; i++) {
            proto_id = protos[i];
            if (!me.data.getByKey(proto_id) && !Ext.Array.contains(missed, proto_id)) {
                missed.push(proto_id);
            }
        }
        return missed;
    },
    /**
     *    () 
     * 
     * @param {String} proto id  
     * @param {Function} callback
     */
    loadNew: function(proto, callback) {
        var me = this,
            missed;
        if (!Ext.isArray(proto))  {
            proto = [
                proto
            ];
        }
        
        missed = me.check(proto);
        if (missed.length) {
            me.load({
                params: {
                    ids: Ext.encode(missed)
                },
                callback: callback,
                scope: me
            });
            return true;
        } else {
            callback.call(me);
        }
        return false;
    }
});

/**
 *   
 */
Ext.define('ExGods.model.FeaturePrototype', {
    extend: Ext.data.Model,
    id: 'feature-prototype',
    idProperty: 'proto',
    fields: [
        {
            name: 'label',
            type: 'string'
        },
        {
            name: 'proto',
            type: 'string'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description2',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            name: 'hidden',
            type: 'int'
        },
        {
            name: 'params',
            type: 'auto'
        }
    ]
});

/**
 *  
 */
Ext.define('ExGods.store.FeaturePrototypes', {
    extend: Ext.data.Store,
    model: 'ExGods.model.FeaturePrototype',
    proxy: {
        type: 'ajax',
        actionMethods: {
            read: 'POST'
        },
        limitParam: false,
        pageParam: false,
        reader: {
            type: 'json',
            rootProperty: 'list'
        },
        startParam: false
    },
    load: function(options) {
        var me = this;
        options = options || {};
        me.proxy.api = {
            read: HOST_URL + '/game.pl?cmd=feature.proto'
        };
        if (typeof options == 'function') {
            options = {
                callback: options
            };
        }
        options.addRecords = true;
        return me.callParent([
            options
        ]);
    },
    /**
     *     
     *
     * @param {String} protos ID 
     */
    check: function(protos) {
        var me = this,
            missed = [],
            i = 0,
            ln, proto_id;
        protos = Ext.Array.unique(protos);
        ln = protos.length;
        for (; i < ln; i++) {
            proto_id = protos[i];
            if (!me.data.getByKey(proto_id) && !Ext.Array.contains(missed, proto_id)) {
                missed.push(proto_id);
            }
        }
        return missed;
    },
    /**
     *    () 
     * 
     * @param {String} proto id  
     * @param {Function} callback
     */
    loadNew: function(proto, callback) {
        var me = this,
            missed;
        if (!Ext.isArray(proto))  {
            proto = [
                proto
            ];
        }
        
        missed = me.check(proto);
        if (missed.length) {
            me.load({
                params: {
                    ids: Ext.encode(missed)
                },
                callback: callback,
                scope: me
            });
            return true;
        } else {
            callback.call(me);
        }
        return false;
    }
});

//@define ExGodsCore.util.SvgText
/**
 *     svg 
 *
 * @author  
 */
Ext.ns('ExGodsCore.util');
ExGodsCore.util.SvgText = {
    letters: {
        'a': 'M0,12Q2,0-5,12',
        '_': 'M0,12L4,6',
        'p': 'M0,0L10,5L5,10',
        'M': '221.9660,282.1146m220.2571,284.5800L218.5061,284.5800L218.5061,274.3824L218.5061,273.9342-218.7022,273.6821-219.2065,273.6821c219.7108,273.6821-219.9069,273.9342-219.9069,274.3824C219.9069,282.6469L219.9349,282.6469L221.2656,280.6718L221.2656,280.4477L221.2656,280.0135-221.4617,279.6073-221.9660,279.6073c222.4983,279.6073-222.6664,280.0135-222.6664,280.4477C222.6664,280.6718L223.9971,282.6469L224.0251,282.6469L224.0251,274.3824L224.0251,273.9342-224.2212,273.6821-224.7255,273.6821c225.2297,273.6821-225.4259,273.9342-225.4259,274.3824C225.4259,284.5800L223.6749,284.5800L221.9660,282.1146L',
        't': 'M89 0c-3 0 -9 1 -11 12c-4 13 -33 234 -33 324c0 89 17 232 23 248c2 6 6 10 12 10s12 -4 17 -12c10 -17 29 -99 29 -225c0 -111 -13 -325 -18 -343c-2 -7 -11 -14 -19 -14zM387 604c-29 5 -109 17 -158 17c-53 0 -99 -5 -117 -8c-9 0 -19 6 -22 15c0 30 117 45 149 45c28 0 163 -19 165 -60c-2 -4 -8 -9 -17 -9z'
    },
    printText: function(text, params) {
        var me = ExGodsCore.util.SvgText,
            id = 'svg-' + Ext.id();
        setTimeout(function() {
            console.log(id);
            var svgtext = SVG(id),
                height = 0,
                width = 0,
                fontSize = params.size || 14,
                fontWeight = params.weight || 1;
            for (var i = 0; i < text.length; i++) {
                var letter = svgtext.path(me.letters[text.charAt(i)] || me.letters['_']).stroke({
                        width: fontWeight
                    }).fill('none').move(width, 0),
                    letterParams = letter.bbox();
                letter.scale(fontSize / letterParams.height);
                letterParams = letter.bbox();
                height = (height < letterParams.height) ? letterParams.height : height;
                width += letterParams.width;
            }
            svgtext.size(width, height);
        }, 50);
        return '<div id="' + id + '"></div>';
    }
};
//alias
ExGodsCore.printSvgText = ExGodsCore.util.SvgText.printText;

//@define ExGodsCore.util.Date
/**
 *     
 *
 * @author  
 */
Ext.ns('ExGodsCore.util');
ExGodsCore.util.Date = {
    /**
     * @property {String} serverDateTimeFormat
     *     
     */
    serverDateTimeFormat: serverDateTimeFormat,
    /**
     * @property {Number} serverTimezoneOffset
     *   ()    
     */
    serverTimezoneOffset: -3 * 60,
    /**
     * @property {Number} serverTimeOffset
     *       
     */
    serverTimeOffset: parseInt(new Date().getTime() / 1000, 10) - window.now,
    /**
     *         ( )
     */
    parseString: function(str) {
        var me = this,
            dt;
        dt = Ext.Date.parse(str, this.serverDateTimeFormat);
        if (!dt) {
            //      timestamp - 'YmdHis'
            dt = Ext.Date.parse(str, 'YmdHis');
        }
        if (!dt) {
            //      "7d"  "eday"
            if (str == 'eday') {
                //                
                dt = new Date();
                dt.setHours(23);
                dt.setHours(23);
                dt.setHours(23);
            } else if (str.match(/^\d+[d,m,s]/)) {
                var count = str.match(/^\d+/)[0];
                var units = str.match(/[d,m,s]/)[0];
                if (units == "d") {
                    dt = Ext.Date.add(new Date(), Ext.Date.DAY, count);
                } else if (units == "m") {
                    dt = Ext.Date.add(new Date(), Ext.Date.MINUTE, count);
                } else if (units == "s") {
                    dt = Ext.Date.add(new Date(), Ext.Date.SECOND, count);
                }
            }
        }
        return dt;
    },
    /**
     *   ,   ,    serverDateTime
     * @param {String|Date} serverDateTime     ExGods.util.Date.serverDateTimeFormat   
     * @return {Date}  ,   
     */
    normalizeServerDateTime: function(serverDateTime) {
        var dt;
        if (typeof serverDateTime == 'string') {
            dt = this.parseString(serverDateTime);
        } else {
            dt = serverDateTime;
        }
        dt = Ext.Date.add(dt, Ext.Date.MINUTE, -dt.getTimezoneOffset() + this.serverTimezoneOffset);
        dt = Ext.Date.add(dt, Ext.Date.SECOND, this.serverTimeOffset);
        return dt;
    },
    /**
     *     unixtime  
     */
    normalizeUnixTime: function(time) {
        var me = this;
        return new Date((parseInt(time) + this.serverTimeOffset) * 1000);
    }
};

//@define ExGodsCore.util.Format
/**
 * -.          
 * @author  
 */
Ext.ns('ExGodsCore.util');
ExGodsCore.util.Format = {
    /**
     * @property templates     
     */
    templates: {
        currency: function(item, ref) {
            var params = Ext.isArray(item.params) ? item.params : [
                    item.params
                ],
                //      
                html = [];
            Ext.Array.each(params, function(param) {
                html.push('<span data-qtip="' + ref.currency.get(param.id).label + '">' + '<span style="white-space: nowrap;">' + '<img src="' + ref.currency.get(param.id).image + '"/>' + Ext.util.Format.number(param.quantity, "0,0") + '</span>' + '</span>');
            });
            return html.join('');
        },
        expa: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_experience') + '" class="item-tpl" style="background-image: url(' + ref.icons.image.exp + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        valour: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_valour') + '" class="item-tpl" style="background-image: url(' + ref.icons.image.valour + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        item: function(item, ref, options) {
            var cls = options.simple ? '' : 'class="item" ',
                style = [
                    'color:' + ExGods.references.get('constants_list').item_grades.value[Number(item.params.grade) - 1 || 0]
                ];
            //if(!options.simple){
            style.push('background-image: url(' + ref.icons.image.item + ')');
            //}
            style = ' style="' + style.join(';') + '"';
            return '<span ' + cls + 'data-proto_id="' + (item.params.id || item.params.entry) + '">' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_item') + '" class="item-tpl ' + (options.simple ? '' : 'decorated ') + '"' + style + '>' + item.params.title + (item.params.quantity > 1 ? '</span>&nbsp;(' + item.params.quantity + ')' : '</span>') + '</span>';
        },
        ability: function(item, ref) {
            return '<span class="ability" data-ability_id="' + item.params.id + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        feature: function(item, ref) {
            return '<span class="feature" data-feature_id="' + item.params.id + '">' + "<span data-qtip=''+ ref.messages.get('stuff_tooltip_feature') +'' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.buff + ")'>" + item.params.title + '</span>' + '</span>';
        },
        timed: function(item, ref) {
            var img = ref.timed.get(item.params.id).img || {};
            return '<span>' + '<span data-qtip="' + ref.stats.get(item.params.id).label + '" class="item-tpl" style="background-image: url(' + IMAGE_URL + img.stuff + ')">' + item.params.quantity + '</span>' + '</span>';
        },
        trophy: function(item, ref) {
            return '<span>' + '<span data-qtip="' + ref.messages.get('stuff_tooltip_trophy') + '" class="item-tpl" style="background-image: url(' + IMAGE_URL + 'icons/ico_trophy.png)">' + item.params.quantity + '</span>' + '</span>';
        },
        turn: function(item, ref) {
            return '<span class="turn-link" data-turn_name="' + item.params.name + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        prep: function(item, ref) {
            return '<span class="prep-link" data-prep_name="' + item.params.name + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        battleaction: function(item, ref) {
            return '<span class="battleaction-link" data-battleaction_id="' + item.params.id + '">' + "<span data-qtip='" + ref.messages.get('stuff_tooltip_ability') + "' class='item-tpl decorated clickable' style='background-image: url(" + ref.icons.image.combo + ")'>" + item.params.label + '</span>' + '</span>';
        },
        ingredients: function(item, ref) {
            return '<span>' + '<span data-qtip="' + (ref.ingredients.get(item.params.id).label) + '" class="">' + item.params.quantity + '</span>' + '</span>';
        }
    },
    /**
     *      HTML 
     * @param {Array} stuff   ,    :
     * 
     *   [{
     *      type: {String}  ,
     *      params: {
     *          id: {String}  
     *          quantity {Number}  
     *          title {String} ,   
     *          label {String} ,   
     *      }
     *   }]
     *
     * @param {Object} options .  :
     *
     *    display = "inline"|"block".      (display = 'inline').
     *                                     display = 'block'
     *
     *    delimiter {String}.  .   "&nbsp;"
     * 
     * @return {String}
     */
    printStuff: function(stuff, options) {
        if (!stuff)  {
            return '';
        }
        
        //   ,    
        if (stuff.stuff) {
            stuff = stuff.stuff;
        }
        //     . ({discount, old, stuff}).   ,   
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        options = Ext.applyIf(options || {}, {
            display: 'inline',
            delimiter: '&nbsp;'
        });
        var ref = {
                currency: ExGodsCore.app.references.get('user_money'),
                timed: ExGodsCore.app.references.get('user_timed'),
                stats: ExGodsCore.app.references.get('user_stat'),
                icons: ExGodsCore.app.references.get('images').get('user_stuff_icons'),
                ingredients: ExGodsCore.app.references.get('ingredients'),
                messages: ExGodsCore.app.references.get('message_client')
            },
            html = [],
            tplFn;
        Ext.each(stuff, function(item) {
            if (Ext.isObject(item) && !Ext.Object.isEmpty(item)) {
                tplFn = ExGodsCore.util.Format.templates[item.type];
                if (tplFn) {
                    html = html.concat(tplFn(item, ref, options));
                } else {
                    /***/
                    ExGods.app.log('error', '    ' + item.type + '  .');
                }
            }
        });
        if (html.length > 1) {
            return '<ul class="exg-stuff exg-stuff-' + options.display + '">' + '<li>' + html.join(options.delimiter + '</li><li>') + '</li>' + '</ul>';
        } else {
            return '<span class="exg-stuff exg-stuff-' + options.display + '">' + html + '</span>';
        }
    },
    /**
     *
     *   ()
     * @return {String} reference - 
     * @params {String} name -  
     *
     */
    printIcon: function(name, reference) {
        var iconHtml = '';
        var icon = reference == 'user_hoard' ? references.get(reference).getByKey(name).icon : reference == 'user_stat' ? references.get(reference).getByKey(name).param.icon : reference == 'user_summary' ? references.get(reference).getByKey(name).icon : name;
        if (icon) {
            iconHtml = '<img width="16" height="16" style="margin: 0 2px -3px 0;" src="' + IMAGE_URL + icon + '"/>';
        }
        return iconHtml;
    },
    /**
     *   .
     *
     * @param {Array} rewards     (. @method ExGodsCore.util.Format.printStuff)
     * @param {Object} options  (. @method ExGodsCore.util.Format.printStuff)
     */
    printRewards: function(rewards, options) {
        return ExGodsCore.util.Format.printStuff(rewards, options);
    },
    /**
     *    
     * @params {Object} itemParams      (id, title, quantity, grade)
     * @return {String}
     */
    printItem: function(itemParams) {
        return ExGodsCore.util.Format.printStuff({
            type: 'item',
            params: itemParams
        });
    },
    /**
     *   .
     *
     * @param {Array} rewards     (. @method ExGods.util.Format.printStuff)
     */
    sortRewards: function(rewards) {
        return Ext.Array.sort(rewards, function(a, b) {
            if (a.type == b.type)  {
                return 0;
            }
            
            if (a.type == 'item')  {
                return 1;
            }
            
            if (b.type == 'item')  {
                return -1;
            }
            
            if (a.type == 'trophy')  {
                return -1;
            }
            
            if (b.type == 'trophy')  {
                return 1;
            }
            
            if (a.type == 'expa')  {
                return -1;
            }
            
            if (b.type == 'expa')  {
                return 1;
            }
            
            if (a.type == 'valour')  {
                return -1;
            }
            
            if (b.type == 'valour')  {
                return 1;
            }
            
            if (a.type == 'trophy')  {
                return -1;
            }
            
            if (b.type == 'trophy')  {
                return 1;
            }
            
            if (a.type == 'currency')  {
                return -1;
            }
            
            if (b.type == 'currency')  {
                return 1;
            }
            
            if (a.type == 'ability')  {
                return -1;
            }
            
            if (b.type == 'ability')  {
                return 1;
            }
            
            if (a.type == 'feature')  {
                return -1;
            }
            
            if (b.type == 'feature')  {
                return 1;
            }
            
            if (a.type == 'timed')  {
                return -1;
            }
            
            if (b.type == 'timed')  {
                return 1;
            }
            
            return 1;
        });
    },
    /**
     *       
     * @params {Object} itemParams      (id, title, quantity, grade)
     * @params {Object} options
     *          disabledImage {Boolean}   
     *          checkUser {Boolean}     ,    -  
     *          noSort {Boolean}      
     *          skulls {Boolean}     
     * @return {String}
     */
    printBigRewards: function(all_stuff, options) {
        var me = this,
            protos = ExGods.app.getItemPrototypesStore(),
            items = curency = '',
            missedProtos = [],
            items_count = 0;
        options = options || {};
        if (!options.noSort)  {
            all_stuff = ExGodsCore.util.Format.sortRewards(all_stuff);
        }
        
        for (var i = 0; i < all_stuff.length; i++) {
            var item_stuff = all_stuff[i];
            if (item_stuff.type == 'item' && item_stuff.item) {
                //    
                var proto_id = parseInt(item_stuff.params.id),
                    item = protos.data.getByKey(proto_id);
                var stars = '<div class="upgrade_stars_container">';
                for (var j = 0; j < item_stuff.item.param.upgrades; j++) {
                    stars += '<div class="upgrade_star"></div>';
                }
                stars += '</div>';
                if (item) {
                    items += '<div class="info-box-itembox item" id="item_proto_' + proto_id + '" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + (item_stuff.params.quantity > 1 ? item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>' : '') + (item_stuff.item.param.upgrades ? stars : '') + '</div>';
                    items_count++;
                } else {
                    missedProtos.push(proto_id);
                }
            } else if (item_stuff.type == 'item' && options.skulls) {
                var proto_id = parseInt(item_stuff.params.id),
                    item = protos.data.getByKey(proto_id);
                if (item) {
                    items += '<div class="info-box-itembox item" id="item_proto_' + proto_id + '" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + '<span class="stack-counter big_counter"><span class="big_counter_mid"><span class="skull"><div></div>x ' + (item_stuff.params.quantity || 1) + '</span></span></span>' + '</div>';
                    items_count++;
                } else {
                    missedProtos.push(proto_id);
                }
            } else if (item_stuff.type == 'item') {
                var proto_id = parseInt(item_stuff.params.id),
                    item = protos.data.getByKey(proto_id),
                    valid = options.checkUser && !ExGods.app.user.checkStuff([
                        item_stuff
                    ]),
                    haveItems = ExGods.app.user.getItemsCountByProto(proto_id);
                if (item) {
                    items += '<div class="info-box-itembox item" data-proto_id="' + proto_id + '" data-qtip="' + item.get('title') + '">' + '<img height="64" ' + (valid ? 'class="missed-item" ' : '') + 'src="' + (options.disabledImage ? item.get('images').disabled : item.get('images').info) + '" width="64" />' + ((item_stuff.params.quantity > 1 || options.checkUser) ? (item_stuff.params.quantity < 99 && !options.checkUser) ? ('<span class="stack-counter' + (valid ? ' red_color' : '') + '">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid' + (valid ? ' red_color' : (options.checkUser ? ' green_color' : '')) + '">' + (options.checkUser ? haveItems + '/' : '') + item_stuff.params.quantity + '</span></span>' : '') + (item_stuff.params.extra ? '<div class="extra-expa"></div>' : '') + '</div>';
                    items_count++;
                } else {
                    missedProtos.push(proto_id);
                }
            } else if (item_stuff.type == 'currency') {
                var proto = ExGods.ref('user_money|' + item_stuff.params.id);
                items += '<div class="info-box-itembox item" data-big_stuff_img="' + proto.image_big + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.params.id + '" data-qtip="' + proto.label + '">' + '<img height="64" src="' + (options.disabledImage ? proto.image_disabled : proto.image_big) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa"></div>' : '') + '</div>';
                items_count++;
            } else if (item_stuff.type == 'ingredients') {
                var proto = ExGods.ref('ingredients|' + item_stuff.params.id);
                items += '<div class="info-box-itembox item" data-big_stuff_id = "' + item_stuff.params.id + '" data-big_stuff_img="' + IMAGE_URL + proto.params.images.img_1 + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="ingredients" data-qtip="' + proto.label + '">' + '<img height="64" src="' + IMAGE_URL + (options.disabledImage ? proto.params.images.img_2 : proto.params.images.img_1) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa"></div>' : '') + '</div>';
                items_count++;
            } else if (item_stuff.type == 'expa' || item_stuff.type == 'trophy') {
                var proto = ExGods.ref('user_hoard|' + item_stuff.type),
                    image = options.disabledImage ? proto.image_disabled : proto.image_big;
                items += '<div class="info-box-itembox item"  data-big_stuff_img="' + proto.image_big + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.type + '" data-qtip="' + proto.label + '">' + '<img height="64" src="' + (options.disabledImage ? proto.image_disabled : proto.image_big) + '" width="64" />' + (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>') + (item_stuff.params.extra ? '<div class="extra-expa"></div>' : '') + '</div>';
                items_count++;
            } else if (item_stuff.type == 'timed') {
                var proto = ExGods.ref('user_timed|' + item_stuff.params.id),
                    timed = ExGods.app.user.get('timed')[item_stuff.params.id],
                    valid = options.checkUser && !ExGods.app.user.checkStuff([
                        item_stuff
                    ]),
                    image = IMAGE_URL + proto.img.stuff,
                    //options.disabledImage ? proto.image_disabled : proto.image_big;
                    label = proto.img.label,
                    desc = proto.img.desc;
                /**
                 * timed - array
                 * timed[0] - Math.floor -  
                 * timed[1] -  
                 * timed[2] -   (   )
                 * timed[3] -   +1 ( 1426066955)
                 */
                items += '<div class="info-box-itembox item" data-big_stuff_img="' + image + '" data-big_stuff_desc="' + Ext.String.htmlEncode(desc) + '" data-big_stuff_value="' + item_stuff.params.quantity + '" data-big_stuff_type="' + item_stuff.type + '" data-qtip="' + label + '">' + '<img class="' + (valid ? 'class="missed-item" ' : '') + '" height="64" src="' + image + '" width="64" />' + '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>' + '</div>';
                items_count++;
            } else if (item_stuff.type == 'feature') {
                var proto = ExGods.app.getFeaturePrototypesStore().getById(item_stuff.params.id);
                if (proto) {
                    items += '<div class="info-box-itembox item feature" data-feature_id="' + item_stuff.params.id + '" data-qtip="' + proto.data.label + '">' + '<div style="background-image: url(' + IMAGE_URL + proto.data.images.main + ');"></div>' + '</div>';
                    items_count++;
                }
            } else if (item_stuff.type == 'action') {
                var proto = ExGods.ref("direct_actions|" + item_stuff.params.id);
                if (proto) {
                    items += '<div class="info-box-itembox item action-item" data-action_id="' + item_stuff.params.id + '" data-qtip="' + proto.images.name + '">' + '<div style="background-image: url(' + IMAGE_URL + proto.images.simple + ');"></div>' + '</div>';
                    items_count++;
                }
            } else {
                curency += ExGodsCore.util.Format.printStuff(item_stuff) + '&nbsp;';
            }
        }
        return {
            items: items,
            currency: curency,
            missedProtos: missedProtos,
            itemsCount: items_count
        };
    },
    /**
     *    ()
     * @params {Object} abilityParams      ([{id, label}, ... ])
     * @return {String}
     */
    printAbility: function(abilityParams) {
        var stuff = [];
        abilityParams = Ext.isArray(abilityParams) ? abilityParams : [
            abilityParams
        ];
        for (var i = 0; i < abilityParams.length; i++) {
            stuff.push({
                type: 'ability',
                params: {
                    id: abilityParams[i].id,
                    label: abilityParams[i].label
                }
            });
        }
        return ExGodsCore.util.Format.printStuff(stuff);
    },
    /**
     *    ()
     * @params {Object} featureParams      ([{id, label}, ... ])
     * @return {String}
     */
    printFeature: function(featureParams) {
        var stuff = [];
        featureParams = Ext.isArray(featureParams) ? featureParams : [
            featureParams
        ];
        for (var i = 0; i < featureParams.length; i++) {
            stuff.push({
                type: 'feature',
                params: {
                    id: featureParams[i].id,
                    title: featureParams[i].label
                }
            });
        }
        return ExGodsCore.util.Format.printStuff(stuff);
    },
    /**
     *  money
     * @params {Object} moneyParams      ([{name, value}, ... ])
     * @return {String}
     */
    printMoney: function(moneyParams) {
        var stuff = [];
        moneyParams = Ext.isArray(moneyParams) ? moneyParams : [
            moneyParams
        ];
        for (var i = 0; i < moneyParams.length; i++) {
            stuff.push({
                type: 'currency',
                params: {
                    id: moneyParams[i].name,
                    quantity: moneyParams[i].value
                }
            });
        }
        return ExGodsCore.util.Format.printStuff(stuff);
    },
    /**
     *     
     * @param {Number} time   
     * @param {Object} options .  :
     *
     *  format = "detailed"|"threenums"|"short" -  .  , "detailed"
     *
     *      : "detailed" - '7 . 10 . 10 . 10 ',
     *               "short" - '7 '  '10:10:10'
     *               "threenums" - '2  3 . 10 .'  '3  10 . 10 .'  '10 . 10 . 10 .' 
     *               "twonums" - '13  48 '
     *               "bignums" - '13:48'      
     *
     *  emptyText = <String> - ,   <= 0
     *
     */
    printTime: function(time, options) {
        var me = this,
            units,
            delimiter = ' ',
            digitFormat = 'd',
            output = [],
            messages = ExGodsCore.app.references.get('message_client'),
            value, i,
            //      
            // @param {Number} value  
            // @param {digitFormat}  . "dd" - '01', "d" - '1'
            // @param {String} label   
            printDigit = function(value, digitFormat, label) {
                var res = '';
                if (digitFormat == 'dd') {
                    res += (value < 10 ? '0' : '') + value;
                } else {
                    res += value;
                }
                if (label) {
                    if (Ext.isArray(label)) {
                        res += ' ' + Ext.util.Format.plural(value, units[i].label);
                    } else {
                        res += ' ' + label;
                    }
                }
                return res;
            };
        options = Ext.applyIf(options || {}, {
            format: 'detailed',
            emptyText: ''
        });
        if (time >= 1) {
            if (options.format == 'detailed') {
                units = [
                    {
                        max: 24 * 3600,
                        label: messages.get('date_format_days_dn') + '.'
                    },
                    {
                        max: 3600,
                        label: messages.get('date_format_hours_ch') + '.'
                    },
                    {
                        max: 60,
                        label: messages.get('date_format_minutes_min') + '.'
                    },
                    {
                        max: 1,
                        label: messages.get('date_format_seconds_s') + '.',
                        digitFormat: 'dd'
                    }
                ];
            } else if (options.format == 'threenums') {
                if (time / (7 * 24 * 3600) > 1) {
                    units = [
                        {
                            max: 7 * 24 * 3600,
                            label: messages.get('date_format_weeks_n') + '.'
                        },
                        // ['', '', '']
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d') + '.'
                        },
                        // ['', '', '']
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        }
                    ];
                }
                // ['', '', '']
                else if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_dn') + '.'
                        },
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m') + '.'
                        }
                    ];
                } else {
                    units = [
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch') + '.'
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m') + '.'
                        },
                        {
                            max: 1,
                            label: messages.get('date_format_seconds_s') + '.',
                            digitFormat: 'dd'
                        }
                    ];
                }
            } else if (options.format == 'twonums') {
                if (time / (7 * 24 * 3600) > 1) {
                    units = [
                        {
                            max: 7 * 24 * 3600,
                            label: messages.get('date_format_weeks_n')
                        },
                        // ['', '', '']
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d')
                        }
                    ];
                }
                // ['', '', '']
                else if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_d')
                        },
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch')
                        }
                    ];
                } else if (time / (3600) > 1) {
                    units = [
                        {
                            max: 3600,
                            label: messages.get('date_format_hours_ch')
                        },
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m')
                        }
                    ];
                } else {
                    units = [
                        {
                            max: 60,
                            label: messages.get('date_format_minutes_m')
                        },
                        {
                            max: 1,
                            label: messages.get('date_format_seconds_s'),
                            digitFormat: 'dd'
                        }
                    ];
                }
            } else if (options.format == 'bignums') {
                if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_text').split(',')
                        }
                    ];
                } else {
                    delimiter = ':';
                    digitFormat = 'dd';
                    units = [
                        {
                            max: 3600,
                            label: ''
                        },
                        {
                            max: 60,
                            label: ''
                        },
                        {
                            max: 1,
                            label: ''
                        }
                    ];
                }
            } else {
                if (time / (24 * 3600) > 1) {
                    units = [
                        {
                            max: 24 * 3600,
                            label: messages.get('date_format_days_text').split(',')
                        }
                    ];
                } else {
                    delimiter = ':';
                    digitFormat = 'dd';
                    units = [
                        {
                            max: 3600,
                            label: ''
                        },
                        {
                            max: 60,
                            label: ''
                        },
                        {
                            max: 1,
                            label: ''
                        }
                    ];
                }
            }
            for (i = 0; i < units.length; i++) {
                value = Math.floor(time / units[i].max);
                if (value != 0 || (options.format == 'short' && units[i].max != 3600) || (options.format == 'threenums' && (units[i].max == 1 || output.length)) || (options.format == 'twonums' && (units[i].max == 1 || output.length)) || (options.format == 'bignums' && units[i].max != 3600)) {
                    output.push(printDigit(value, units[i].digitFormat || digitFormat, units[i].label));
                    time -= value * units[i].max;
                }
            }
            if (options.format == 'bignums') {
                var sprites = [];
                if (output.length == 1) {
                    output.unshift('0');
                }
                Ext.Array.each(output, function(num) {
                    sprites.push(me.printSprite(num, IMAGE_URL + '/numbers.png', {
                        width: 21,
                        height: 30,
                        twoDigits: true
                    }));
                });
                return sprites.slice(0, 2).join('<span class="bignum-delimiter"></span>');
            } else  {
                return output.join(delimiter);
            }
            
        } else {
            return options.emptyText;
        }
    },
    /**
     *  ,    (@param date)   
     * @param {Date} date
     * @param {Object} options :
     *
     *  format = "detailed"|"short" (.   ExGodsCore.util.Format.printTime)
     *
     *  emptyText - ,   ,   
     */
    printRestTime: function(date, options) {
        var restTime;
        options = Ext.applyIf(options || {}, {
            emptyText: '',
            stringFormat: '{0}'
        });
        restTime = Math.ceil((date - new Date()) / 1000);
        if (restTime > 0) {
            return Ext.String.format(options.stringFormat, this.printTime(restTime, options));
        } else {
            return options.emptyText;
        }
    },
    /**
     *     .
     *
     * @param {Number/String} quantity    
     * @param {Number} shortFrom ,         ( "k/kk").   1000
     *   ,  shortFrom = 10000,  123456    "123",   1234567 - "1"
     * @param {String} format  ,   format  Ext.util.Format.number.  , '0,0'
     * @param {String} decimalFormat     
     */
    printNumber: function(quantity, shortFrom, format, decimalFormat) {
        var postfix = '';
        quantity = '' + quantity;
        //   
        shortFrom = shortFrom || 1000000000;
        format = format || '0,0';
        if (quantity >= shortFrom) {
            if (quantity >= 10000000) {
                quantity = quantity.substr(0, quantity.length - 6);
                postfix = '';
            } else if (quantity >= 1000000) {
                quantity = (parseInt(quantity.substr(0, quantity.length - 5)) / 10).toString();
                postfix = '';
            } else if (quantity >= 10000) {
                quantity = quantity.substr(0, quantity.length - 3);
                postfix = '';
            } else if (quantity >= 1000) {
                quantity = (parseInt(quantity.substr(0, quantity.length - 2)) / 10).toString();
                postfix = '';
            }
        }
        if (quantity.split('.').length > 1 && decimalFormat) {
            format = decimalFormat;
        }
        return Ext.util.Format.number(quantity, format) + postfix;
    },
    /**
     *    (, , )
     * @param {Object} user  
     * @param {Object} options :
     *  
     *  fields -  ,   .  , ['name', 'rank', 'level', 'infoicon'].    ,  
     *            : 'name', 'rank', 'level', 'infoicon', 'mentoricon', 'immuneicon'
     *
     *  maxNameWidth -      .    .
     *
     *  cls - css ,     
     *
     */
    printUserInfo: function(user, options) {},
    // 
    /**
     *   .
     * @param {Array} stats 
     * @param {Object} options :
     *  visibleValue -   visible  ,    .
     *  column - - ,    .   1
     *  changes -    
     *  inline -  true -    ,   false
     */
    printUserStats: function(stats, options) {
        var data = {
                stats: []
            },
            statsRef = ExGodsCore.app.references.get('user_stat'),
            statInfo,
            tpl = new Ext.XTemplate([
                '<tpl if="options.visibleValue == 1">',
                '<tpl if="options.inline">',
                '<ul class="inline-list">',
                '<tpl for="stats">',
                '<li>',
                '<span class="value icon">{[ ExGodsCore.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ ExGods.printNumber(this.printValue(values.value), 1000, "0", "0.0") ]}</span>',
                '</li>',
                '</tpl>',
                '</ul>',
                '<tpl elseif="options.align != \'right\'">',
                '<table class="user-stats user-stats-{options.visibleValue}">',
                '<tpl for="stats">',
                '<tr class="{[xindex % 2 === 0 ? "even" : ""]}">',
                '<td>{label}</td>',
                '<td>',
                '<span class="value icon">{[ ExGodsCore.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ this.printValue(values.value) ]}',
                '<tpl if="changes">',
                '<span class="changes"><small>(</small><span class="{[ values.changes > 0 ? "up" : "down" ]}">{[values.changes > 0 ? "+" : ""]}{changes}</span><small>)</small>',
                //maxStat
                '<tpl if="maxStat">',
                '<small>(</small><span style="color:' + ExGods.ref('constants|max_upgrade_color').value + '">max. {maxStat}</span><small>)</small>',
                '</tpl>',
                '</span>',
                '</tpl>',
                '</span>',
                '</td>',
                '</tr>',
                '</tpl>',
                '</table>',
                '<tpl else>',
                '<ul class="table-list">',
                '<tpl for="stats">',
                '<li class="{[xindex % 2 === 0 ? "even" : ""]}">',
                '<span class="label">{label}</span>',
                '<span class="value icon">{[ ExGodsCore.printIcon(values.param.icon) ]}</span>',
                '<span class="value">{[ this.printValue(values.value) ]}',
                '<tpl if="changes">',
                '<span class="changes"><small>(</small><span class="{[ values.changes > 0 ? "up" : "down" ]}">{[values.changes > 0 ? "+" : ""]}{changes}</span><small>)</small>',
                //maxStat
                '<tpl if="maxStat">',
                '<small>(</small><span style="color:' + ExGods.ref('constants|max_upgrade_color').value + '">max. {maxStat}</span><small>)</small>',
                '</tpl>',
                '</span>',
                '</tpl>',
                '</span>',
                '</li>',
                '</tpl>',
                '</ul>',
                '</tpl>',
                '<tpl else>',
                '<table class="user-stats user-stats-{options.visibleValue}">',
                '<tpl if="options.visibleValue == 2">',
                '<tr>',
                '<tpl for="stats">',
                '<td data-qtip="{label} - {[ this.printValue(values.value) ]}">',
                '<div class="background" style="background: url(' + IMAGE_URL + '{param.empty})">',
                '<div class="icon" style="background: url(' + IMAGE_URL + '{param.icon})"></div>',
                '<div class="fill-red" style="{[ this.getRedStarsStyle(values.value) ]}"></div>',
                '<div class="fill-green" style="{[ this.getGreenStarsStyle(values.value) ]}"></div>',
                '<div class="fill" style="{[ this.getStarsStyle(values.value) ]};background: url(' + IMAGE_URL + '{param.fill});"></div>',
                '</div>',
                '</td>',
                '<tpl if="xindex % 2 == 0 && xindex < xcount">',
                '</tr><tr>',
                '</tpl>',
                '</tpl>',
                '</tr>',
                '</tpl>',
                '</table>',
                '</tpl>',
                {
                    printValue: function(v) {
                        return Ext.isArray(v) ? v[0] : /*+ '/' + v[1]*/
                        v;
                    },
                    getRedStarsStyle: function(v) {
                        var style = [];
                        style.push('background: url(' + IMAGE_URL + 'mask/star_red.png)');
                        if (Ext.isArray(v) && v[0] < v[1]) {
                            style.push('left: ' + (24 + v[0] * 14) + 'px');
                            style.push('width: ' + (Math.min(v[1] - v[0], 5 - v[0]) * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    getGreenStarsStyle: function(v) {
                        var style = [];
                        style.push('background: url(' + IMAGE_URL + 'mask/star_green.png)');
                        if (Ext.isArray(v) && v[0] > v[1]) {
                            style.push('left: ' + (24 + v[1] * 14) + 'px');
                            style.push('width: ' + (Math.min(v[0] - v[1], 5 - v[1]) * 14) + 'px');
                        }
                        return style.join(';');
                    },
                    getStarsStyle: function(v) {
                        var style = [];
                        if (Ext.isArray(v)) {
                            style.push('width: ' + (Math.min(v[0], v[1]) * 14) + 'px');
                        } else {
                            style.push('width: ' + (v * 14) + 'px');
                        }
                        return style.join(';');
                    }
                }
            ]);
        data.options = Ext.applyIf(options || {}, {
            columns: 1,
            visibleValue: 1,
            inline: false,
            changes: {},
            maxStats: {}
        });
        var sorters = {
                damage: 1,
                fury: 5,
                hp: 2,
                mp: 4,
                shield: 3,
                stamina: 3,
                strength: 2,
                accuracy: 4,
                agility: 1
            };
        //    
        Ext.Object.each(stats, function(key, value) {
            statInfo = statsRef.get(key);
            if (!statInfo) {
                /***/
                ExGods.app.log('error', '   ' + key + '    ');
                return;
            }
            if ((options.visibleValue == statInfo.visible) && (value != null)) {
                // if(options.visibleValue == 2 && data.options.changes[key]){
                //  value = [value, value - data.options.changes[key]];
                // }
                data.stats.push({
                    name: key,
                    value: value,
                    label: statInfo.label,
                    visible: statInfo.visible,
                    param: statInfo.param,
                    changes: data.options.changes[key],
                    maxStat: data.options.maxStats[key]
                });
            }
        });
        if (data.stats.length) {
            Ext.Array.sort(data.stats, function(a, b) {
                return sorters[a.name] > sorters[b.name];
            });
            return tpl.apply(data);
        } else  {
            return '';
        }
        
    },
    /**
     *    
     * @param {Number} number - required - ;
     * @param {String} sprite -    ,     .   ,    css   util-sign
     * @param {Object} options - required - 
     * - @param {Boolean} horizontal - default:false. ,    
     * - @param {String} indent - ,     .    -
     *          .
     * - @param {String} cls - css  
     * - @param {String} tag - dom tag 
     * - @param {Number} width - required -  
     * - @param {Number} height - required -  
     * - @param {Boolean} lastZero - default: false    "0"    
     * - @param {Boolean} twoDigits - default: false     1  0  
     */
    printSprite: function(number, sprite, options) {
        var n = parseInt(number).toString(),
            w = options.width,
            h = options.height,
            tag = options.tag || 'div',
            cls = options.cls || '',
            i = 0,
            totalWidth = 0,
            numberHtml = '',
            left, top, sign, bgimg, bgpos;
        if (sprite) {
            sprite = (sprite.substr(0, 4) == 'http') ? sprite : IMAGE_URL + sprite;
        }
        if (options.twoDigits && n.length == 1)  {
            n = '0' + n;
        }
        
        for (; i < n.length; i++) {
            totalWidth += w;
            sign = parseInt(n.charAt(i));
            if (options.lastZero) {
                if (sign === 0) {
                    sign = 9;
                } else {
                    sign--;
                }
            }
            if (options.horizontal) {
                left = sign ? '-' + sign * w + 'px' : 0;
                top = options.indent || 0;
            } else {
                left = options.indent || 0;
                top = sign ? '-' + sign * h + 'px' : 0;
            }
            bgpos = 'background-position: ' + left + ' ' + top;
            bgimg = (sprite) ? 'background-image: url(' + sprite + ');' : '';
            numberHtml += '<div class="util-sign" style="' + bgimg + bgpos + ';width:' + w + 'px;height:' + h + 'px"></div>';
        }
        result = '<' + tag + ' class="util-sign-container ' + cls + '">' + '<div style="width:' + totalWidth + 'px;height:' + h + 'px">' + numberHtml + '</div>' + '</' + tag + '>';
        return result;
    }
};
// aliases
ExGodsCore.printUser = ExGodsCore.util.Format.printUserInfo;
ExGodsCore.printItem = ExGodsCore.util.Format.printItem;
ExGodsCore.printAbility = ExGodsCore.util.Format.printAbility;
ExGodsCore.printFeature = ExGodsCore.util.Format.printFeature;
ExGodsCore.printNumber = ExGodsCore.util.Format.printNumber;
ExGodsCore.printMoney = ExGodsCore.util.Format.printMoney;
ExGodsCore.printIcon = ExGodsCore.util.Format.printIcon;
ExGodsCore.printBigRewards = ExGodsCore.util.Format.printBigRewards;

/**
 *      ajax
 *
 * @oleg
 */
Ext.define('ExGodsCore.AjaxRequest', {
    singleton: true,
    mixins: {
        observable: Ext.util.Observable
    },
    /**
     * @property {Array} keyHandlersSequence      (. {@link this#addKeyHandler addKeyHandler}) 
     * @readonly
     */
    keyHandlersSequence: [],
    constructor: function(config) {
        config = config || {};
        Ext.apply(this, config);
        /**
         * @event jsondecodeerror
         *     
         * @param {String} response
         */
        /**
         * @event requestexception
         *  
         * @param {Ext.data.Connection} conn This Connection object.
         * @param {Object} response The XHR object containing the response data.
         * See [The XMLHttpRequest Object](http://www.w3.org/TR/XMLHttpRequest/) for details.
         * @param {Object} options The options config object passed to the {@link #request} method.
         */
        Ext.Ajax.on('requestexception', function(conn, response, options) {
            this.fireEvent('requestexception', conn, response, options);
        }, this);
        this.mixins.observable.constructor.call(this);
    },
    /**
     *     .  
     *
     *     ,      ,
     *      Ext.Ajax#request - . overrides
     *
     * @param {Object} args   {@link Ext.data.Connection#request Ext.Ajax.request}
     */
    request: function(args) {
        var me = this,
            success = args.success,
            failure = args.failure,
            callback = args.callback,
            app = this.application;
        if (HOST_URL) {
            args.url = HOST_URL + args.url;
            args.cors = true;
            args.withCredentials = true;
        }
        delete args.success;
        if (typeof success == 'function') {
            success = {
                afterKeyHandlers: success
            };
        }
        args = Ext.apply({
            success: function(response, options) {
                var result = Ext.decode(response.responseText, true);
                if (!result) {
                    me.fireEvent('jsondecodeerror', response, args);
                } else {
                    if (success && success.beforeKeyHandlers) {
                        success.beforeKeyHandlers.call(this, result, options);
                    }
                    me.invokeKeyHandlers(result);
                    if (success && success.afterKeyHandlers) {
                        success.afterKeyHandlers.call(this, result, options);
                    }
                }
            },
            scope: args.scope || this
        }, args);
        //      
        Ext.applyIf(args, {
            queue: true
        });
        return Ext.Ajax.request(args);
    },
    /** 
     *       (. {@link this#addKeyHandler addKeyHandler}) 
     *         addKeyHandler, ..       
     * @param {Array} sequence  
     */
    initKeyHandlersSequence: function(sequence) {
        this.keyHandlersSequence = sequence;
    },
    /**
     *          .
     *   
     *  @param {String} key   ,      .  ,       
     *  @param {Function} handler -  : data (  )
     *
     */
    addKeyHandler: function(key, handler, scope) {
        var me = this;
        if (!me.keyHandlers) {
            me.keyHandlers = [];
        }
        if (!me.keyHandlers[key]) {
            me.keyHandlers[key] = [];
        }
        me.keyHandlers[key].push({
            fn: handler,
            scope: scope || me
        });
        if (Ext.Array.indexOf(me.keyHandlersSequence, key) == -1) {
            //        -     
            me.keyHandlersSequence.push(key);
        }
    },
    /**
     * @private
     */
    invokeKeyHandlers: function(data) {
        var me = this;
        Ext.iterate(me.keyHandlersSequence, function(key, index) {
            if (data.hasOwnProperty(key) && me.keyHandlers && me.keyHandlers[key]) {
                Ext.Array.each(me.keyHandlers[key], function(handler) {
                    handler.fn.call(handler.scope, data);
                });
            }
        });
    }
});

/**
 * Mixin,    ajax 
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGodsCore.util.Ajaxable', {
    /**
     * Ajax-  
     * @param {Object} args   Ext.Ajax.request
     */
    ajaxRequest: function(args) {
        if (!args.scope) {
            args.scope = this;
        }
        return ExGodsCore.AjaxRequest.request(args);
    },
    /** 
     *   ajaxRequest
     */
    request: function() {
        return this.ajaxRequest.apply(this, arguments);
    },
    /**
     * . {@link ExGodsCore.AjaxRequest#addKeyHandler addKeyHandler}
     */
    addAjaxRequestKeyHandler: function(key, handler, scope) {
        return ExGodsCore.AjaxRequest.addKeyHandler(key, handler, scope);
    }
});

/**
 *     
 */
Ext.define('ExGodsCore.ChatConnection', {
    mixins: {
        observable: Ext.util.Observable,
        loggable: ExGodsCore.util.Loggable,
        ajaxable: ExGodsCore.util.Ajaxable
    },
    logConfig: {
        enabled: {
            info: false,
            error: true,
            warn: true
        },
        prefix: 'ChatConnection:'
    },
    //  requires:'ExGodsCore.controller.Direction',
    /**
     * @cfg {String} login (required)
     */
    /**
     * @cfg {String} password(required)
     */
    /**
     * @cfg {Boolean} disabled   
     */
    disabled: true,
    /**
      * @cfg {Number} pingPeriod
      *     
      */
    pingPeriod: 60,
    /**
      * @cfg {Number} privateMessages
      *      
      */
    privateMessages: 0,
    /**
      * @cfg {Number} publicMessages
      *      
      */
    publicMessages: 0,
    constructor: function(config) {
        var me = this;
        Ext.apply(me, config);
        me.mixins.observable.constructor.call(me, config);
        me.mixins.loggable.constructor.call(me, config);
        me.mixins.ajaxable.constructor.call(me, config);
        //
        // @oleg commented cause addEvents is deprecated in 5.1.1
        //
        // me.addEvents(
        //  /**
        //   * @event beforeconnect
        //   *    
        //   * @param this
        //   */
        //  'beforeconnect',
        //  /**
        //   * @event connect
        //   *      .      "ready"
        //   */
        //  'connect',
        //  /**
        //   * @event presenceinit
        //   *     
        //   * @param this
        //   */
        //  'presenceinit',
        //  /**
        //   * @event ready
        //   *     !
        //   * @param this
        //   * @param {Object} data   cmd=connect
        //   */
        //  'ready',
        //  /**
        //   * @event presenceavail
        //   *   
        //   * @param this
        //   * @param {Object} data
        //   * @param {Object} presence
        //   */
        //  'presenceavail',
        //  /**
        //   * @event presenceunavail
        //   *  
        //   * @param this
        //   * @param {Object} data
        //   * @param {Object} presence
        //   */
        //   'presenceunavail',
        //  /**
        //   * @event presenceerror
        //   *  
        //   * @param this
        //   * @param {Object} data
        //   * @param {Object} presence
        //   */
        //   'presenceerror',
        //   /**
        //   * @event disabled
        //   *    
        //   * @param this
        //   */
        //   'disabled',
        //   /**
        //   * @event enabled
        //   *    
        //   * @param this
        //   */
        //   'enabled',
        //   /**
        //    * @event ping
        //    *         ping
        //    * @param this
        //    * @param {Object} data   
        //    */
        //    'ping'
        // );
        window.onbeforeunload = function() {
            /***/
            me.log('info', '      window "onbeforeunload"');
            me.xmppChat.disconnect();
        };
        me.callParent(arguments);
    },
    /**
     *   
     */
    connect: function() {
        this.auth();
    },
    /**
     *  
     * @param {Object} message 
     *   {
     *      from -     
     *      to -  ,  
     *      type -   ("private"  "to")
     *      content -  
     *      roomId - id ,    .     
     *   }
     */
    sendMessage: function(message, attrs) {
        var me = this,
            to = message.to,
            content = message.content;
        attrs = attrs || {};
        if (content) {
            switch (message.type) {
                case 'private':
                    //  
                    if (to.length > 1) {
                        me.xmppChat.sendMultiPrivateMessage(to.join(','), content, attrs);
                    } else {
                        me.xmppChat.sendPrivateMessage(to[0], content, attrs);
                    };
                    me.privateMessages++;
                    break;
                case 'to':
                    //    ()
                    me.xmppChat.sendRoomMessage(message.roomId, content, Ext.apply(attrs, {
                        to: Ext.JSON.encode(message.to)
                    }));
                    me.publicMessages++;
                    break;
                default:
                    //   
                    me.xmppChat.sendRoomMessage(message.roomId, content, attrs);
                    me.publicMessages++;
                    break;
            }
        }
    },
    /**
     * @private
     *   
     * @param {String} login
     * @param {String} password
     */
    auth: function() {
        var me = this;
        /***/
        me.log('info', '   ');
        me.fireEvent('beforeconnect', me);
        XMPPChat.BOSH_SERVICE = HOST_URL + XMPPChat.BOSH_SERVICE;
        //    
        me.xmppChat = new XMPPChat.Connection(me.login, me.password, 'Game', {
            onConnect: Ext.bind(me.onConnect, me),
            onPresence: Ext.bind(me.onPresence, me),
            onMessage: Ext.bind(me.onMessage, me),
            onDisconnect: Ext.bind(me.onDisconnect, me)
        });
        me.xmppChat.connect();
    },
    /**
     * @private
     *    
     */
    onConnect: function() {
        var me = this;
        /***/
        me.log('info', '  -   ');
        me.xmppChat.sendPresence(me.xmppChat);
        me.fireEvent('connect');
    },
    /**
     * @private
     *   ""
     */
    onPresence: function(data, presence) {
        var me = this;
        /***/
        me.log('info', '', data);
        if (data.roomId) {
            if (data.type == 'error') {
                me.fireEvent('presenceerror', me, data, presence);
            } else if (data.type == 'unavailable') {
                me.fireEvent('presenceunavail', me, data, presence);
            } else {
                me.fireEvent('presenceavail', me, data, presence);
            }
        } else if (data.fromJID === data.toJID) {
            me.fireEvent('presenceinit', me);
            me.ajaxRequest({
                url: '/game.pl?cmd=connect',
                params: {
                    localtime: Ext.Date.format(new Date(), 'Y-m-d H:i:s')
                },
                success: function(result) {
                    if (result.success == 1) {
                        if (!me.pingTask) {
                            //      
                            me.pingTask = Ext.TaskManager.start({
                                interval: me.pingPeriod * 1000,
                                run: me.ping,
                                scope: me
                            });
                        }
                        me.fireEvent('ready', me, result);
                    }
                }
            });
        }
    },
    //       
    /**
     * @private
     *   
     * 
     * @param {Object} data
     * @param {Object} xml
     */
    onMessage: function(data, xml) {
        var me = this;
        /***/
        me.log('info', '   "' + data.type + '"', data);
        //   
        delete data.xmlBody;
        if (data.x) {
            if (me.disabled && data.type != XMPPChat.MT_COMMAND) {
                //    -    
                return;
            }
            if (data.type != XMPPChat.MT_COMMAND) {
                //    ,    
                data.body = Ext.String.htmlEncode(data.body);
            }
            switch (data.type) {
                case 'error':
                case 'room':
                case 'private':
                    /**
                     * @event message_error
                     *      "error"
                     * @param this
                     * @param {Object} data  
                     */
                    /**
                     * @event message_room
                     *      "room"
                     * @param this
                     * @param {Object} data  
                     */
                    /**
                     * @event message_private
                     *      "private"
                     * @param this
                     * @param {Object} data  
                     */
                    me.fireEvent('message_' + data.type, me, data);
                    break;
                case XMPPChat.MT_COMMAND:
                    var body = Ext.decode(data.body, true);
                    if (Ext.isArray(body)) {
                        //    log_id.  log_id   - 
                        body = Ext.Array.sort(body, function(a, b) {
                            if (!a.data.log_id)  {
                                return 1;
                            }
                            
                            if (!b.data.log_id)  {
                                return -1;
                            }
                            
                            return a.data.log_id - b.data.log_id;
                        });
                        for (var i in body) {
                            if (body[i]) {
                                var cmdData = Ext.clone(data);
                                cmdData.body = body[i];
                                if (!cmdData.body.remove)  {
                                    cmdData.body = Ext.decode(me.application.getController('Direction').processText(Ext.encode(cmdData.body)));
                                }
                                
                                try {
                                    /**
                                     *     
                                     */
                                    me.fireEvent('message_command', me, cmdData);
                                    /**
                                     *    "command_post", "command_user".
                                     *      
                                     */
                                    me.fireEvent('command_' + cmdData.body.type, me, cmdData);
                                } catch (e) {
                                    /***/
                                    me.log('error', '    ', cmdData, e);
                                }
                            }
                        }
                    };
                    break;
                default:
                    /**
                     * @event message_default
                     *      
                     * @param this
                     * @param {Object} data  
                     */
                    me.fireEvent('message_default', me, data);
                    break;
            }
        }
    },
    /**
     * @private
     *     
     */
    onDisconnect: function() {
        var me = this;
        /***/
        me.log('info', '    -    ');
        me.auth();
    },
    /**
     * / .
     */
    setDisabled: function(v) {
        var me = this;
        if (me.disabled !== v) {
            me.disabled = v;
            me.fireEvent(me.disabled ? 'disabled' : 'enabled', me);
        }
    },
    /**
     *    
     */
    addPingParam: function(param, value) {
        var me = this;
        me.pingParams = me.pingParams || {};
        me.pingParams[param] = value;
    },
    /**
     * @private
     *   
     */
    ping: function() {
        var me = this,
            params = {};
        if (me.pingParams) {
            for (var key in me.pingParams) {
                if (typeof me.pingParams[key] == 'function') {
                    params[key] = me.pingParams[key]();
                } else {
                    params[key] = me.pingParams[key];
                }
            }
        }
        //     
        if (me.privateMessages) {
            params.private_messages = me.privateMessages;
            me.privateMessages = 0;
        }
        if (me.publicMessages) {
            params.public_messages = me.publicMessages;
            me.publicMessages = 0;
        }
        me.request({
            url: '/ping.pl',
            params: params,
            success: function(result) {
                if (result.success != 1) {
                    window.location = isSocialApp ? '/logout-social.html' : '/';
                } else {
                    ExGodsCore.util.Date.serverTimeOffset = parseInt(new Date().getTime() / 1000, 10) - result.now;
                    me.fireEvent('ping', result);
                }
            },
            failure: function() {
                window.location = isSocialApp ? '/logout-social.html' : '/';
            }
        });
    }
});

/**
 *  ,      .
 *     .
 */
Ext.define('ExGodsCore.controller.Base', {
    extend: Ext.app.Controller,
    mixins: [
        ExGodsCore.util.Loggable,
        ExGodsCore.util.Ajaxable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BaseCtrl:'
    },
    /**
     *  , ,    ,      .
     */
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        if (me.superclass.config.refs) {
            me.ref(me.superclass.config.refs);
        }
    },
    doInit: function() {
        this.app = this.application;
        //      app
        this.user = this.app.user;
        //   
        this.callParent(arguments);
    },
    /**
     *   
     * 
     * @return {ExGods.model.User}
     */
    getUser: function() {
        return this.app.user;
    },
    /**
     *     
     * @return {Ext.data.Model}
     */
    getLocation: function() {
        return this.app.getLocation();
    },
    /**
     *     
     * @return {Ext.data.Model}
     */
    getWorld: function() {
        return this.app.getWorld();
    }
});

/**
 *   
 */
Ext.define('ExGodsCore.model.ChatMessage', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'body',
            type: 'auto'
        },
        {
            name: 'from',
            type: 'string'
        },
        {
            name: 'fromJID',
            type: 'string'
        },
        {
            name: 'roomId',
            type: 'string'
        },
        {
            name: 'toJID',
            type: 'string'
        },
        {
            name: 'tpl',
            type: 'string'
        },
        {
            name: 'type',
            type: 'string'
        },
        {
            name: 'x',
            type: 'auto'
        }
    ]
});

/**
 *   .
 *   ,    Ext.slider.Single .
 *        Ext.panel.Panel,
 * ..    dock    .
 */
Ext.define('ExGodsCore.view.plugin.Scroller', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.corescroller',
    /**
     * @cfg {Boolean} [autoHide=false]
     *     /  
     */
    autoHide: false,
    /**
     * @private
     * @property {Ext.Component} cmp
     * ,    
     */
    /**
     * @cfg {Number} scrollDeltaY     
     * {
     *  default:40
     * }
     */
    scrollDeltaY: 40,
    /**
     * @property {Ext.dom.Element} scrollEl
     *     
     */
    /**
     * @cfg {Boolean} [scrollToTopOnResize=false]
     *    
     */
    scrollToTopOnResize: false,
    /**
     * @cfg {String/Boolean} [snap=false]
     *       
     */
    snap: false,
    /**
     * @cfg {Boolean} autoRestorePosition        
     */
    autoRestorePosition: false,
    /**
     * @cfg {Object} scrollerConfig
     * Default:
     * {
     *  slider:{ < >
     *      animate: false,
     *      decimalPrecision: false,
     *      flex: 1,
     *      increment: 1,
     *      useTips: false,
     *      value: 100,
     *      vertical: true,
     *  },
     *  scrollTop:{ < >
     *      cls: 'scroll-top',
     *      height: 23
     *  },
     *  scrollBottom:{ < >
     *      cls: 'scroll-bottom',
     *      height: 23
     *  },
     *  toolbar:{ < ,   UI>
     *      dock: 'right',
     *      defaults: {
     *          margin: 0,
     *          width: 13
     *      },
     *      ui: 'scroller'
     *  }
     * }
     */
    scrollerConfig: {
        slider: {
            animate: false,
            decimalPrecision: false,
            flex: 1,
            increment: 1,
            useTips: false,
            value: 100,
            vertical: true
        },
        scrollTop: {
            cls: 'scroll-top',
            height: 22
        },
        scrollBottom: {
            cls: 'scroll-bottom',
            height: 22
        },
        toolbar: {
            dock: 'right',
            defaults: {
                margin: 0,
                width: 21
            },
            ui: 'scroller'
        }
    },
    init: function(cmp) {
        var me = this;
        if (!cmp.isPanel)  {
            return;
        }
        
        Ext.apply(me.scrollerConfig.slider, {
            listeners: {
                change: me.onSliderChange,
                changecomplete: {
                    fn: me.onSliderChangeComplete,
                    delay: 300
                },
                scope: me
            }
        });
        //   
        me.slider = Ext.widget('slider', me.scrollerConfig.slider);
        Ext.apply(me.scrollerConfig.toolbar, {
            padding: me.padding || 0,
            items: [
                Ext.apply(me.scrollerConfig.scrollTop, {
                    handler: me.scrollTop,
                    scope: me
                }),
                me.slider,
                Ext.apply(me.scrollerConfig.scrollBottom, {
                    handler: me.scrollBottom,
                    scope: me
                })
            ]
        });
        me.toolbar = Ext.widget('toolbar', me.scrollerConfig.toolbar);
        cmp.addDocked(me.toolbar);
        cmp.setAutoScroll(false);
        cmp.scroller = me;
        cmp.on({
            add: me.onItemAdd,
            afterlayout: me.afterCmpLayout,
            render: me.onCmpRender,
            resize: me.onCmpResize,
            scope: me
        });
    },
    onCmpRender: function(cmp) {
        var me = this;
        scrollEl = cmp.body;
        me.scrollEl = scrollEl;
        cmp.items.each(function(item) {
            me.onItemAdd(cmp, item);
        });
        scrollEl.on({
            mousewheel: me.onMouseWheel,
            scope: me
        });
        if (Ext.isGecko) {
            // Firefox
            scrollEl.el.dom.addEventListener('DOMMouseScroll', function(e) {
                me.onMouseWheel(e);
            }, false);
        }
        scrollEl.on({
            touchstart: me.onTouchStart,
            touchmove: me.onTouchMove,
            touchend: me.onTouchEnd,
            scope: me
        }, {
            translate: false
        });
    },
    /**
     * @private
     *    layout.   innerCt  layout.
     *   ,       .
     */
    afterCmpLayout: function(cmp, layout) {
        var me = this;
        if (me.autoRestorePosition) {
            me.restorePosition();
        }
    },
    onCmpResize: function(cmp) {
        this.onResize(cmp);
    },
    /**
     *       Ext.slider.Single
     * 
     * @return {Object}    :
     *
     *      {
     *          height: <Max  >,
     *          width: <Max  >
     *      }
     */
    getScrollSize: function() {
        var me = this,
            dom = me.scrollEl.dom,
            size = me.scrollEl.getSize();
        return {
            height: dom.scrollHeight - size.height,
            width: dom.scrollWidth - size.width
        };
    },
    /**
     *          
     *   
     */
    onItemAdd: function(cmp, item) {
        var me = this;
        if (item && item.isComponent)  {
            item.on({
                resize: me.onItemResize,
                scope: me
            });
        }
        
    },
    onItemResize: function(item) {
        this.onResize(item);
    },
    /**
     *  :     /
     *  
     */
    onResize: function() {
        var me = this,
            autoHide = me.autoHide,
            scrollEl = me.scrollEl,
            scrollSize = me.getScrollSize(),
            toolbar = me.toolbar,
            slider = me.slider;
        if (scrollEl.isScrollable() && scrollSize.height) {
            me.recalcSliderPos(scrollSize.height);
            if (autoHide) {
                if (!toolbar.isVisible()) {
                    toolbar.show();
                    me.cmp.updateLayout();
                }
            } else {
                toolbar.el.setStyle('visibility', 'visible');
            }
        } else {
            if (autoHide) {
                if (toolbar.isVisible()) {
                    toolbar.hide();
                    me.cmp.updateLayout();
                }
            } else {
                toolbar.el.setStyle('visibility', 'hidden');
            }
        }
        if (me.scrollToTopOnResize) {
            me.scrollToTop();
        }
    },
    /**
     *        
     *   
     *
     * @param {Number} [maxValue]    
     */
    recalcSliderPos: function(maxValue) {
        var me = this,
            slider = me.slider,
            oldValue = slider.getValue(),
            oldMaxValue = slider.maxValue,
            value;
        if (maxValue == undefined) {
            maxValue = me.scrollEl.getHeight();
        }
        value = maxValue - me.scrollEl.dom.scrollTop;
        //    
        slider.suspendEvents();
        slider.setMaxValue(maxValue);
        slider.setValue(value, false);
        slider.resumeEvents();
    },
    /**
     *    . ,  
     *  .
     */
    updateSliderPos: function() {
        var me = this,
            slider = me.slider,
            maxValue = slider.maxValue;
        value = maxValue - me.scrollEl.dom.scrollTop;
        slider.suspendEvents();
        slider.setValue(value, false);
        slider.resumeEvents();
    },
    onMouseWheel: function(e) {
        var me = this,
            slider = me.slider,
            delta;
        if (Ext.isGecko) {
            delta = -e.detail;
        } else {
            delta = e.getWheelDelta();
        }
        slider.setValue(slider.getValue() + delta * me.scrollDeltaY);
        e.preventDefault();
    },
    onSliderChange: function(slider, newValue) {
        var me = this,
            scrollEl = me.scrollEl;
        if (scrollEl) {
            scrollEl.scrollTo('top', slider.maxValue - newValue);
        }
        me.cmp.fireEvent('scroll', me);
    },
    onSliderChangeComplete: function() {
        var me = this;
        if (me.snap) {}
    },
    //me.snapToEl();
    snapToEl: function() {
        var me = this,
            cmp = me.cmp,
            scrollEl = me.scrollEl,
            slider = me.slider,
            snap = me.snap;
        scrollEl.select(snap).each(function(el, c, index) {
            var offset = el.getOffsetsTo(scrollEl);
            if (offset[1] == 0)  {
                return false;
            }
            
            if (offset[1] > 0) {
                var prev = c.item(index - 1),
                    prevOffset = prev.getOffsetsTo(scrollEl);
                slider.suspendEvents();
                if (-prevOffset[1] > offset[1]) {
                    slider.setValue(slider.getValue() - offset[1]);
                } else {
                    slider.setValue(slider.getValue() - prevOffset[1]);
                }
                slider.resumeEvents();
                scrollEl.scrollTo('top', slider.maxValue - slider.getValue(), true);
                return false;
            }
        });
    },
    touchStart: 0,
    onTouchStart: function(e) {},
    // this.touchStart = e.browserEvent.changedTouches[0].pageY;
    onTouchMove: function(e) {},
    // var me = this,
    //  slider = me.slider,
    //  touchMove = e.browserEvent.changedTouches[0].pageY,
    //  delta = touchMove - this.touchStart;
    // if (delta) {
    //  slider.setValue(slider.getValue() + delta);
    //  me.touchStart = touchMove;
    // }
    // e.preventDefault();
    snapTimeoutId: 0,
    onTouchEnd: function() {},
    // var me = this;
    // if (me.snap) {
    //  var id = me.snapTimeoutId;
    //  clearTimeout(id);
    //  id = Ext.Function.defer(me.snapToEl, 300, me);
    // }
    scrollTop: function() {
        var me = this,
            slider = me.slider;
        slider.setValue(slider.getValue() + me.scrollDeltaY);
    },
    scrollBottom: function() {
        var me = this,
            slider = me.slider;
        slider.setValue(slider.getValue() - me.scrollDeltaY);
    },
    /**
     *  
     */
    scrollToTop: function() {
        var me = this;
        me.slider.setValue(me.slider.maxValue);
    },
    /**
     *    
     */
    scrollToBottom: function() {
        var me = this,
            slider = me.slider;
        if (me.cmp.rendered) {
            if (slider.getValue()) {
                slider.setValue(0);
            } else {
                me.scrollEl.scrollTo('top', slider.maxValue);
            }
        }
    },
    /**
     * ,      
     *
     * @param {Number} accurancy  
     * @return {Boolean}
     */
    isTop: function(accurancy) {
        var me = this,
            slider = me.slider;
        if (typeof accurancy == 'undefined')  {
            accurancy = 0;
        }
        
        return (slider.getValue() + accurancy >= slider.maxValue);
    },
    /**
     * ,      
     *
     * @param {Number} accurancy  
     * @return {Boolean}
     */
    isBottom: function(accurancy) {
        var me = this,
            slider = me.slider;
        if (typeof accurancy == 'undefined')  {
            accurancy = 0;
        }
        
        return (slider.getValue() - accurancy <= 0);
    },
    /**
     *     ,      restorePosition
     */
    catchPosition: function() {
        var me = this;
        me._curPosition = {
            sliderValue: me.slider.getValue(),
            scrollSize: me.getScrollSize()
        };
    },
    /**
     *  ,    catchPosition
     */
    restorePosition: function() {
        var me = this,
            pos = me._curPosition,
            scrollSize = me.getScrollSize(),
            newValue;
        if (pos) {
            newValue = pos.sliderValue + (scrollSize.height - pos.scrollSize.height);
            me.slider.setValue(newValue);
            me.onSliderChange(me.slider, newValue);
        }
    },
    destroy: function() {
        var me = this;
        me.cmp.un({
            add: me.onItemAdd,
            afterlayout: {
                fn: me.afterCmpLayout,
                single: true
            },
            render: me.onCmpRender,
            resize: me.onCmpResize,
            scope: me
        });
        me.cmp.scroller = null;
        me.cmp = null;
        if (me.scrollEl) {
            me.scrollEl.un({
                mousewheel: me.onMouseWheel,
                touchstart: me.onTouchStart,
                touchmove: me.onTouchMove,
                touchend: me.onTouchEnd,
                scope: me
            });
            me.scrollEl = null;
        }
        me.slider = null;
        me.toolbar = null;
        me.callParent(arguments);
    }
});

/**
 *    
 */
Ext.define('ExGodsCore.view.chat.MessageList', {
    extend: Ext.panel.Panel,
    alias: 'widget.corechatmessagelist',
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: false,
        prefix: 'MessageListView: '
    },
    header: false,
    hideMode: 'offsets',
    //          
    /**
     * @cfg {Number} [limit=100]
     *        
     * {
     *  default:100
     * }
     */
    limit: 100,
    /**
     * @cfg {boolean}
     *     localStorage     . (
     * true -  store  , false - store     )
     */
    sync: true,
    plugins: [
        {
            ptype: 'corescroller',
            resetOnShow: false,
            scrollDeltaY: 20
        }
    ],
    /**
     * @property {Object} messageTplByType
     *   
     */
    /**
     * @property {String} storageId
     *       ""   
     */
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    messageTplByType: {
        room: [
            '{from}: {body:linkify}'
        ],
        to: [
            '{from} to {to}: {body:linkify}'
        ],
        message: [
            '{body.body:linkify}'
        ],
        'private': [
            '{from} private {to}: {body:linkify}'
        ]
    },
    initComponent: function() {
        var me = this,
            user = me.user;
        me.data = new Ext.util.MixedCollection();
        for (var key in me.messageTplByType) {
            if (Ext.isArray(me.messageTplByType[key])) {
                me.messageTplByType[key] = new Ext.XTemplate(me.messageTplByType[key]);
            }
        }
        Ext.apply(me, {
            html: '<ul></ul>',
            listeners: {
                afterrender: me.onAfterRender,
                scope: me
            }
        });
        if (me.sync) {
            //  ,  store 
            me.storage = Ext.util.LocalStorage.get('chat-messages');
            me.storageId = user.get('title') + '-' + me.getId();
            if (!me.channelType.world && !me.channelType.location) {
                var lastId = me.storage.getItem(me.channelType + 'Id') || '';
                if (lastId != me.channelId) {
                    me.storage.setItem(me.storageId, []);
                }
                me.storage.setItem(me.channelType + 'Id', me.channelId);
            }
            /**/
            me.log('     id', me.storageId);
            me.data.addAll(me.storage.getItem(me.storageId) || []);
        }
        me.callParent();
    },
    /** @private
     *     
     * @require 'ul'
     * @require 'li.message'
     */
    onAfterRender: function() {
        var me = this,
            html = '';
        me.data.each(function(msg) {
            html += me.parseMessage(msg);
        });
        me.listEl = me.getEl().down('ul');
        me.listEl.dom.innerHTML = html;
        (Ext.Function.createDelayed(function() {
            me.scroller.scrollToBottom();
        }, 10)());
    },
    /** @private
     *  
     */
    showMessage: function(msg) {
        var me = this;
        if (me.listEl && me.listEl.dom) {
            me.listEl.insertHtml('beforeEnd', me.parseMessage(msg));
        }
    },
    /** @private
     *    
     * @param {Number} msgIndex    
     */
    hideMessage: function(msgIndex) {
        var me = this,
            el = me.listEl && me.listEl.dom ? me.listEl.select('li').item(msgIndex) : null,
            scrollerValue = me.scroller.slider.getValue();
        if (el) {
            if (scrollerValue) {
                //           
                var h = el.getHeight();
                el.remove();
                me.scroller.slider.setValue(scrollerValue + h);
            } else {
                el.remove();
            }
        }
    },
    /**
     *    
     * 
     * @param {Object} msg  
     */
    addMessage: function(msg) {
        var me = this,
            rec = ExGods.app.getChatContactsStore().findRecord('title', msg.x.from_realuser);
        if (rec && rec.get('moder')) {
            msg.x.moder = rec.get('moder');
        }
        if (!msg)  {
            return;
        }
        
        var isBottom = me.scroller.isBottom();
        msg.id = Ext.id() + '-' + new Date().getTime();
        me.data.add(msg);
        me.showMessage(msg);
        if (me.data.getCount() > me.limit) {
            me.data.removeAt(0);
            me.hideMessage(0);
        }
        me.syncData();
        if (me.scroller.scrollEl) {
            me.scroller.onResize();
            if (isBottom) {
                me.scroller.scrollToBottom();
            }
        }
        /**
         * @event addmessage
         *      
         * @param {Object} data
         * @param {ExGods.view.chat.MessageList} this
         */
        me.fireEvent('addmessage', msg, me);
    },
    /**
     * @private
     *     HTML 
     * 
     * @param {Object} data  .     :
     *    (     . ).  
     *    {@link ExGods.controller.Chat#onMessage}
     * @return {String} HTML  
     */
    parseMessage: function(data) {
        var me = this,
            html = '<li class="message message-empty"></li>',
            type = data.type,
            msgId = data.id,
            xtpl;
        xtpl = me.messageTplByType[type];
        if (xtpl) {
            try {
                html = '<li class="message" id="' + msgId + '">' + me.prepareMessageText(xtpl, data) + '</li>';
            } catch (e) {}
        } else if (data.tpl) {
            try {
                html = '<li class="message" id="' + msgId + '">' + me.prepareMessageText(data.tpl, data) + '</li>';
            } catch (e) {}
        }
        return html;
    },
    /**
     * @private
     *   
     * @param {Object}/{String} tpl  
     * @param {object} data -   
     * @return {HTML}  
     */
    prepareMessageText: function(tpl, data) {
        var me = this;
        if (typeof tpl != 'object') {
            tpl = new Ext.XTemplate(tpl);
        }
        return tpl.apply(data);
    },
    /**
     *   
     */
    clear: function() {
        var me = this;
        me.data.clear();
        me.syncData();
        if (me.listEl && me.listEl.dom) {
            me.listEl.dom.innerHTML = '';
            me.scroller.onResize();
        }
    },
    // @private
    onDestroy: function() {
        var me = this;
        if (me.sync) {
            me.storage.setItem(me.storageId, []);
            if (me.syncDataTask) {
                Ext.util.TaskManager.stop(me.syncDataTask);
            }
        }
        me.callParent(arguments);
    },
    /**
     * @private
     */
    syncData: function() {
        var me = this;
        if (!me.sync)  {
            return;
        }
        
        //  
        me.data.sync_changes = false;
        if (!me.syncDataTask) {
            me.syncDataTask = Ext.TaskManager.start({
                run: function() {
                    if (!me.data.sync_changes) {
                        /**/
                        me.log('  -     .');
                        me.storage.setItem(me.storageId, me.data.getRange());
                        me.data.sync_changes = true;
                    }
                },
                interval: 5000
            });
        }
    }
});

/**
 *   
 */
Ext.define('ExGodsCore.controller.Chat', {
    extend: ExGodsCore.controller.Base,
    /**
     * @property {Object} logConfig
     *       
     * @param {Object} enabled
     * @param {Boolean} enabled.info   
     * @param {Boolean} enabled.error    
     * @param {Boolean} enabled.warn  
     * @param {String} prefix      
     */
    logConfig: {
        enabled: {
            info: false,
            error: true,
            warn: true
        },
        prefix: 'ChatView:'
    },
    views: [
        'chat.MessageList'
    ],
    refs: [
        {
            /**
             * @method getChatTabPanel
             *     
             * default selector: #chat-tab-panel
             * @return {ExGods.view.chat.MessageList}
             */
            ref: 'chatTabPanel',
            selector: '#chat-tab-panel'
        },
        {
            /**
             * @private
             * @method getInputField
             *    
             * default selector: #chat-text-field
             * @return {Ext.form.field.Text}
             */
            ref: 'inputField',
            selector: '#chat-text-field'
        },
        {
            /**
             * @private
             * @method getSendButton
             *     
             * default selector: #chat-send-button
             * @return {Ext.button.Button}
             */
            ref: 'sendButton',
            selector: '#chat-send-button'
        }
    ],
    /**
     * @property {Object[]} channelPatterns
     *  ( )  :
     *
     *      [
     *          {
     *              xtype: <_>
     *              name: <   >     
     *              id: <>
     *              pattern: <____>
     *              title: <__>
     *              type:{
     *                  input:{Boolean}
     *                  private:{Boolean}
     *                  default:{Boolean}
     *                  <    ,      >
     *              }
     *              autoshow:{Boolean} ,          
     *              autoremove: {Boolean} ,       "" 
     *          },
     *          ...
     *      ]
     */
    channelPatterns: null,
    /**
     * @property {Object} messagePatterns
     *  ( ) 
     */
    messagePatterns: {
        //  
        'private': /^\s*[\/\.\!\,](p|private|w|whisper|||)\s+([^:]*?)\s*:\s*(.*)\s*$/i,
        //     
        'to': /^\s*[\/\.\!\,](to)\s+([^:]*?)\s*:\s*(.*)\s*$/i,
        //  
        'room': /^\s*(.*)\s*$/i
    },
    init: function(app) {
        var me = this,
            user = app.user;
        if (!me.channelPatterns) {
            me.channelPatterns = [
                {
                    xtype: 'corechatmessagelist',
                    id: 'world-chat-messages',
                    pattern: /^world#\d+$/,
                    title: ExGodsCore.app.references.get('message_client').get('chat_world_title'),
                    name: 'worldChatMessageList',
                    type: {
                        world: true,
                        input: true,
                        'private': true
                    }
                },
                {
                    xtype: 'chatmessagelist',
                    id: 'location-chat-messages',
                    pattern: /^\d+$/,
                    title: ExGodsCore.app.references.get('message_client').get('chat_location_title'),
                    name: 'locationChatMessageList',
                    type: {
                        location: true,
                        'default': true,
                        input: true,
                        'private': true
                    },
                    autoshow: true
                }
            ];
        }
        me.channels = new Ext.util.MixedCollection();
        //    
        /**
         * @method getChannelName
         *       .   get<chatName>ChatMessageList, :
         * {
         *      getWorldChatMessageList()
         * }
         * @return {ExGods.view.chat.MessageList} Ext.Component  
         */
        var refs = [];
        for (var i = 0; i < me.channelPatterns.length; i++) {
            refs.push({
                ref: me.channelPatterns[i].name,
                selector: '#' + me.channelPatterns[i].id
            });
        }
        me.addRef(refs);
        me.control({
            'chatmessagelist': {
                nickclick: me.addNickToMessage
            },
            '#chat-text-field': {
                specialkey: me.onEnterTextField
            },
            '#chat-toolbar button[action="send"]': {
                click: me.sendMessage
            },
            '#chat-toolbar button[action="clear"]': {
                click: me.onClearBtnClick
            },
            '#contact-tab-panel dataview': {
                itemclick: {
                    fn: me.onContactListItemClick,
                    delay: 0
                }
            }
        });
        app.getChatConnection().on({
            connect: me.onChatConnect,
            disabled: me.onChatDisabled,
            enabled: me.onChatEnabled,
            presenceavail: me.onPresenseAvailable,
            presenceunavail: me.onPresenseUnavailable,
            message_error: me.onMessageTypeError,
            message_room: me.onMessageTypeRoom,
            message_private: me.onMessageTypePrivate,
            message_default: me.onMessageTypeDefault,
            command_message: me.onMessageTypeCommandMessage,
            command_prize: me.onMessageTypeCommandMessage,
            scope: me
        });
        me.getUser().features().on('load', me.checkChatDisablingFeature, me);
        me.getUser().features().on('datachanged', me.checkChatDisablingFeature, me);
    },
    /**
     *     
     *
     * @return {ExGods.view.chat.MessageList}
     */
    getActiveTab: function() {
        var me = this;
        return me.getChatTabPanel().getActiveTab();
    },
    /**
     * @private
     *    
     */
    onChatConnect: function(conn) {
        var me = this;
        if (!me.isChatDisable()) {
            me.enableInput();
        }
    },
    /**
     * @private
     *         
     *
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data
     */
    onPresenseAvailable: function(chatcn, data) {
        var me = this,
            user = me.getUser();
        Ext.each(me.channelPatterns, function(channel) {
            //    
            var match = data.roomId.match(channel.pattern);
            if (match) {
                // ,     
                var card = me.getChatTabPanel().down('#' + channel.id);
                if (card) {
                    //   ,   roomId  
                    card.channelId = data.roomId;
                } else {
                    //     (  " "   )
                    channel.sync = !(channel.type == 'battle_obs');
                    //   ,   
                    card = me.getChatTabPanel().add({
                        xtype: channel.xtype,
                        id: channel.id,
                        channelId: data.roomId,
                        channelType: channel.type,
                        channelParams: channel,
                        title: channel.title,
                        user: user,
                        sync: channel.sync,
                        autoremove: channel.autoremove
                    });
                    //  autoshow,     
                    if (channel.autoshow) {
                        me.getChatTabPanel().setActiveTab(card);
                    }
                }
                //       roomId
                me.channels.add(data.roomId, card);
            }
        });
    },
    /**
     * @private
     *   ""    
     * 
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data   
     */
    onPresenseUnavailable: function(chatcn, data) {
        var me = this,
            channel = me.channels.getByKey(data.roomId);
        if (channel) {
            me.channels.removeAtKey(data.roomId);
            if (channel.autoremove) {
                me.getChatTabPanel().remove(channel);
            }
        }
    },
    //       
    /**
     * @method getChannelByType
     *  {ExGods.view.chat.MessageList}   [{ExGods.view.chat.MessageList}]  
     * @param {String} type  
     *  :
     * {
     *      private - ,     
     *      input - ,      
     *      default -  ,        .    .
     * }
     * @return {Ext.Component}/[]     
     */
    getChannelByType: function(type) {
        var me = this,
            res = [];
        for (var i = 0; i < me.channelPatterns.length; i++) {
            if (me.channelPatterns[i].type[type]) {
                var cmp = Ext.ComponentQuery.query('#' + me.channelPatterns[i].id);
                if (cmp[0] && cmp[0].rendered) {
                    res.push(cmp[0]);
                }
            }
        }
        if (res.length == 1) {
            return res[0];
        } else if (!res.length) {
            return undefined;
        } else {
            return res;
        }
    },
    /**
     * @method getChannelPatternByType
     *  {Object}    [{Object}]   
     * @param {String} type  
     *  :
     * {
     *      private - ,     
     *      input - ,      
     *      default -  ,        .    .
     * }
     * @return {Object}/[{Object}]        
     */
    getChannelPatternByType: function(type) {
        var me = this,
            res = [];
        for (var i = 0; i < me.channelPatterns.length; i++) {
            if (me.channelPatterns[i].type[type]) {
                res.push(me.channelPatterns[i]);
            }
        }
        if (res.length == 1) {
            return res[0];
        } else if (!res.length) {
            return undefined;
        } else {
            return res;
        }
    },
    /**
     * @private
     * @method onMessageTypeDefault
     *    
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data   
     */
    onMessageTypeDefault: function(chatcn, data) {
        var me = this,
            channel = me.getChannelByType('default');
        if (channel) {
            if (Ext.isArray(channel)) {
                for (var i = 0; i < channel.length; i++) {
                    channel[i].addMessage(data);
                }
            } else {
                channel.addMessage(data);
            }
        }
    },
    /**
     * @private
     * @method onMessageTypeError
     *   
     *
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data   
     */
    onMessageTypeError: function(chatcn, data) {
        var me = this,
            messageTpl = me.application.references.get('message_client').get('chat_error_' + data.errorCode),
            from = data.from,
            arrayusers;
        // data.x.to_realuser   .        
        if (data.x.to_realuser) {
            arrayusers = data.x.to_realuser.split(',');
            for (var i = 0; i < arrayusers.length; i++) {
                var name = arrayusers[i].toLowerCase().replace(' ', '_');
                if (from === name) {
                    data.x.to_realuser = arrayusers[i];
                    break;
                }
            }
        }
        //     
        data.x.time = undefined;
        if (messageTpl && me.getActiveTab()) {
            data.tpl = messageTpl;
            me.getActiveTab().addMessage(data);
        }
    },
    /**
     * @private
     * @method onMessageTypeRoom
     *   
     *
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data   
     */
    onMessageTypeRoom: function(chatcn, data) {
        var me = this,
            channel = null;
        if (data.roomId) {
            channel = me.channels.getByKey(data.roomId);
        }
        if (channel) {
            channel.addMessage(data);
        }
    },
    /**
     * @private
     * @method onMessageTypePrivate
     *   
     * 
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data   
     */
    onMessageTypePrivate: function(chatcn, data) {
        var me = this,
            channels = me.getChannelByType('private');
        if (channels) {
            channels = Ext.isArray(channels) ? channels : [
                channels
            ];
            channels.forEach(function(ch) {
                ch.addMessage(data);
            });
        }
    },
    /**
     * @private
     * @method onMessageTypeCommandMessage
     *   c  message
     * 
     * @param {ExGodsCore.ChatConnection} chatcn
     * @param {Object} data   
     */
    onMessageTypeCommandMessage: function(chatcn, data) {
        var me = this,
            channel;
        if (data.body.template) {
            data.tpl = data.body.template;
        }
        channel = me.getCommandMessageChannel(data);
        if (channel) {
            if (Ext.isArray(channel)) {
                for (var i = 0; i < channel.length; i++) {
                    channel[i].addMessage(data);
                }
            } else {
                channel.addMessage(data);
            }
        }
    },
    // END:       
    //   
    /**
     * @method getSendMessageData
     *      
     * 
     * @return {ExGods.model.SendMessage}
     */
    getSendMessageData: function() {
        var me = this,
            field = me.getInputField(),
            text = field.getValue(),
            message = {
                from: me.getUser().get('display_title'),
                type: 'room',
                to: [],
                content: '',
                roomId: false
            };
        Ext.Object.each(me.messagePatterns, function(key, exp) {
            var match = text.match(exp);
            if (match) {
                switch (key) {
                    case 'private':
                        var nicks = match[2].split(',');
                        nicks = Ext.Array.map(nicks, function(item) {
                            return Ext.String.trim(item);
                        });
                        Ext.apply(message, {
                            type: key,
                            to: nicks,
                            content: match[3]
                        });
                        break;
                    case 'to':
                        var nicks = match[2].split(',');
                        nicks = Ext.Array.map(nicks, function(item) {
                            return Ext.String.trim(item);
                        });
                        Ext.apply(message, {
                            type: key,
                            to: nicks,
                            content: match[3],
                            roomId: me.getChatRoomName()
                        });
                        break;
                    case 'room':
                        Ext.apply(message, {
                            type: key,
                            content: match[1],
                            roomId: me.getChatRoomName()
                        });
                        break;
                    default:
                        break;
                }
                //  
                return false;
            }
        });
        return message;
    },
    /**
     * @private
     * @method updateSendMessageField
     *     ,     
     * 
     * @param {String} newMessage  
     */
    updateSendMessageField: function(newMessage) {
        var me = this,
            field = me.getInputField(),
            message = newMessage ? newMessage : me.getSendMessageData(),
            type = message.type,
            to = message.to,
            content = message.content,
            str = '';
        if (type && type != 'room')  {
            str += '/' + type;
        }
        
        if (to.length) {
            str += ' ' + to.join(', ') + ': ';
        }
        str += content;
        field.setValue(str).focus();
        field.selectText(str.length, str.length);
    },
    /**
     * @method addNickToMessage
     *      
     * 
     * @param {String} nick  
     * @param {String} [type]   (to  private)
     * @param {String} [strongType] true,  type    .
     */
    addNickToMessage: function(nick, type, strongType) {
        var me = this,
            message = me.getSendMessageData();
        if (!Ext.Array.contains(message.to, nick)) {
            if (!message.to.length) {
                message.type = type || 'to';
            }
            message.to.push(nick);
        } else {
            if (type && strongType) {
                message.type = type;
            } else if (message.type != 'private') {
                message.type = 'private';
            } else {
                message.type = 'to';
            }
        }
        me.updateSendMessageField(message);
    },
    /**
     * @method sendMessage
     *  ,   ,    : 
     * ,   - 
     */
    sendMessage: function() {
        var me = this,
            str = Ext.String.trim(me.getInputField().getValue());
        if (str) {
            me.app.getChatConnection().sendMessage(me.getSendMessageData());
            me.getInputField().setValue('');
        }
    },
    /**
     * @private
     * @method getChatRoomName
     *  ID ,    
     *
     * @return {String}
     */
    getChatRoomName: function() {
        var me = this,
            tabs = me.getChatTabPanel(),
            tab = tabs.getActiveTab(),
            room = tab.channelId;
        return room || false;
    },
    /**
     * @method getCommandMessageChannel
     *       
     * @param {Object} data  
     * @return {ExGods.view.chat.MessageList}       
     */
    getCommandMessageChannel: function(data) {
        var me = this,
            channel;
        if (data.fromJID == 'localhost') {
            //  
            channel = me.getChannelByType('localhost');
        } else if (data.roomId) {
            channel = me.channels.getByKey(data.roomId);
        }
        if (!channel) {
            channel = me.getChannelByType('default');
        }
        return channel;
    },
    /**
     * @private
     * @method onEnterTextField
     *   event    Enter,    
     * @param {Ext.form.field.Text} Ext.form.field.Text
     * @param {Object} event
     */
    onEnterTextField: function(field, e) {
        if (e.getKey() == e.ENTER) {
            this.sendMessage();
        }
    },
    // End:   
    onClearBtnClick: function() {
        var me = this;
        if (me.getInputField().getValue()) {
            //   
            me.getInputField().setValue('');
        } else {
            Ext.widget('confirmdialog', {
                title: '',
                message: ExGods.ref('message_client|chat_confirm_clear'),
                handler: function() {
                    me.clearChatChannel();
                }
            });
        }
    },
    /**
     * @method clearChatChannel
     *     
     */
    clearChatChannel: function() {
        var me = this,
            tab = me.getChatTabPanel().getActiveTab();
        if (tab) {
            tab.clear();
        }
    },
    /**
     * @method disableInput
     *   (     )
     */
    disableInput: function() {
        var me = this;
        me.getInputField().disable();
        me.getSendButton().disable();
    },
    /**
     * @method enableInput
     *  
     */
    enableInput: function() {
        var me = this;
        me.getInputField().enable();
        //me.getInputField().focus(false, true);
        me.getSendButton().enable();
    },
    /**
     * @private
     * @method onChatDisabled
     *     
     */
    onChatDisabled: function() {
        var me = this;
        //   
        me.disableInput();
    },
    /**
     * @private
     * @method onChatEnabled
     *     
     */
    onChatEnabled: function() {
        var me = this;
        //   
        me.enableInput();
    },
    /**
     * @method isChatDisable
     *    
     * @return {Boolean}
     */
    isChatDisable: function() {
        var me = this,
            chatcn = me.app.getChatConnection();
        return chatcn.disabled;
    },
    /**
     * @method isWorldChatDisable
     *     
     * @return {Boolean}
     */
    isWorldChatDisable: function() {
        return ExGods.ref('constants|world_chat_available') ? ExGods.ref('constants|world_chat_available').value == 0 : false;
    },
    /**
     * @private
     * @method checkChatDisablingFeature
     *        .     -  
     */
    checkChatDisablingFeature: function() {
        var me = this,
            chatcn = me.app.getChatConnection();
        if (me.getUser().features().find('type', 'chat_inactive') != -1) {
            chatcn.setDisabled(true);
        } else {
            chatcn.setDisabled(false);
        }
    }
});

/**
 * 
 */
Ext.define('ExGods.view.Direction', {
    extend: Ext.panel.Panel,
    alias: 'widget.direction',
    cls: 'direction-dialog',
    width: 800,
    height: 410,
    initComponent: function() {
        var me = this,
            config = me.config,
            user = ExGods.app.getUser();
        me.margin = '' + (config.y ? config.y : '104') + ' 0 0 ' + (config.x ? config.x : '104');
        me.btn = Ext.widget('textbutton', Ext.apply({
            x: 348,
            y: 261,
            width: 175,
            style: {
                zIndex: 2
            },
            text: ExGods.app.applyTpl(config.btnText || '', {
                u: user.data
            }) || ExGods.getMsgByKey('look_more'),
            cls: 'no_border' + (config.btnColor ? ' x-btn-txt-' + config.btnColor : ''),
            href: me.config.action ? me.config.action.href : undefined,
            hrefTarget: me.config.action ? me.config.action.hrefTarget : undefined
        }, config.btn || {}));
        me.items = [
            {
                xtype: 'container',
                //layout: 'absolute',
                items: [
                    {
                        xtype: 'component',
                        width: 587,
                        tpl: [
                            '<div class="npc" style="background-image: url({[ this.getNpcImage() ]})"></div>',
                            '<div class="pergament bg"></div>',
                            '<div class="pergament">',
                            '<div class="close-btn ' + (config.close_btn && config.close_btn != 0 ? "" : "hidden") + '"></div>',
                            '<h1>' + ExGods.app.applyTpl(config.label || '', {
                                u: user.data
                            }) + '</h1>',
                            '<p>' + ExGods.app.applyTpl(config.text || '', {
                                u: user.data
                            }) + '</p>',
                            '</div>',
                            {
                                getNpcImage: function() {
                                    return me.getNpcImage();
                                }
                            }
                        ],
                        data: {},
                        afterRender: function() {
                            this.getEl().on('click', function() {
                                me.close();
                            }, this, {
                                delegate: '.close-btn'
                            });
                        }
                    },
                    me.btn
                ]
            }
        ];
        me.callParent(arguments);
    },
    //    ,   - 
    directionAutoRun: function() {
        var me = this;
        me.btn.handler(me.btn);
    },
    getNpcImage: function() {
        var me = this,
            user = ExGods.app.user,
            u_gen = user.get('gender') == 1 ? 'm' : 'f',
            u_race = user.get('race') == 2 ? 'as' : 'van',
            imgName = 'npcImg_' + u_race + '_' + u_gen;
        if (me.config[imgName]) {
            return IMAGE_URL + me.config[imgName];
        } else if (me.config.npcImg) {
            return IMAGE_URL + me.config.npcImg;
        } else {
            return IMAGE_URL + 'direction/pers_fort_head.png';
        }
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                me.getNpcImage()
            ]
        };
    }
});

/**
 *    
 *
 *  -   ,     .
 *      ,     ,    ..
 *
 *      {@link ExGods.controller.Direction#processText},    
 *    .
 *
 * @author  
 *
 */
Ext.define('ExGodsCore.controller.Direction', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Direction:'
    },
    disabled: true,
    init: function() {
        var me = this;
        me.storage = Ext.create('Ext.state.LocalStorageProvider');
        me.storage.storageId = 'exg-directions';
        me.control({
            '#battle-result': {
                destroy: {
                    fn: me.showDirections,
                    delay: 100
                }
            }
        });
        var directions = me.storage.get(me.storage.storageId, []);
        Ext.Array.each(directions, function(d) {
            if (d.data.object_name) {
                me.listenComponent(d.data.object_name);
            }
        });
        ExGods.Components.addComponentInitializer('direction', me.initDirectionDialogComponent, me);
        //    
        ExGods.testDirection = function(directionName) {
            me.processText('[# ' + directionName + ' #]');
        };
    },
    shown: {},
    onLaunch: function(app) {
        var me = this;
        me.showDirections();
    },
    /**
     *  / c    
     */
    setDisabled: function(disabled) {
        var me = this;
        if (me.disabled !== disabled) {
            me.disabled = disabled;
            if (!me.disabled) {
                me.showDirections();
            }
        }
    },
    canShowDirections: function() {
        var me = this;
        return !me.disabled;
    },
    isBattle: function() {
        var me = this;
        return me.user.isBattle() || me.app.getController('battle.BattleView').isRendered() || Ext.getCmp('battle-result');
    },
    /**
     *   
     */
    showDirections: function(cmpId) {
        var me = this,
            directions = me.storage.get(me.storage.storageId, []),
            _waitAndShow = function(cmp, d) {
                var times = 0,
                    interval;
                interval = setInterval(function() {
                    if (cmp && cmp.isVisible() && !ExGods.loaderCt.isVisible()) {
                        me.runDirection(d);
                        Ext.Array.remove(directions, d);
                        me.storage.set(me.storage.storageId, directions);
                        clearInterval(interval);
                    } else {
                        if (++times > 10) {
                            clearInterval(interval);
                        }
                    }
                }, 250);
            };
        if (!me.canShowDirections()) {
            return;
        }
        Ext.Array.sort(directions, function(a, b) {
            return b.priority - a.priority;
        });
        /***/
        me.log(' ');
        var showen = [],
            lc = ExGods.loaderCt;
        Ext.Array.each(directions, function(d) {
            if (d.data.object_name && !d.data.not_show_with_open_component) {
                var cmp = Ext.getCmp(d.data.object_name);
                if (cmp) {
                    if (cmp.isVisible()) {
                        me.runDirection(d);
                        showen.push(d);
                    } else {
                        _waitAndShow(cmp, d);
                    }
                }
            } else if (me.isBattle() && d.data.show_in_battle != 1) {}
            //
            else if (lc.isVisible()) {
                lc.on('loader_removed', function() {
                    me.runDirection(d);
                }, me, {
                    single: true
                });
                showen.push(d);
            } else {
                me.runDirection(d);
                showen.push(d);
            }
        });
        directions = Ext.Array.difference(directions, showen);
        me.storage.set(me.storage.storageId, directions);
    },
    /**
     *  
     */
    runDirection: function(d) {
        var me = this;
        /***/
        me.log(' ', d);
        var fn = function() {
                if (d.data.make == 'service') {
                    //     
                    ExGods.ClientActions.createAndInvoke({
                        actionId: d.data.make_data.id
                    }, null, function(err) {
                        /***/
                        me.log('error', err);
                    });
                } else if (d.data.make == 'component') {
                    if (d.data.make_data.object_name) {
                        //    
                        var cmp = ExGods.Components.factory(d.data.make_data.object_name);
                        if (cmp == 'wrong_setting') {
                            /***/
                            me.log('info', '    ', d);
                            return;
                        } else if (cmp && !cmp.error) {
                            if (cmp.config.auto_run && cmp.directionAutoRun) {
                                cmp.directionAutoRun();
                                cmp.destroy();
                            } else if (cmp.autoShow !== false && !cmp.rendered) {
                                if (typeof cmp.getResources == 'function') {
                                    ExGods.Resources.load(cmp, function() {
                                        cmp.show();
                                    });
                                } else {
                                    cmp.show();
                                }
                            }
                        } else {
                            /***/
                            me.log('error', cmp ? cmp.error : '     ', d);
                        }
                    }
                } else {
                    /***/
                    me.log('error', '  -     ,  ');
                }
                if (d.data.sound) {
                    var sound = ExGods.ref('sounds|' + d.data.sound);
                    if (sound) {
                        ExGods.app.getSoundController().play(sound.audio);
                    }
                }
                if (d.data.caption) {
                    me.blinkTitle(d.data.caption);
                }
            };
        if (d.data.ask_direction && d.data.ask_direction.length) {
            var requests = Ext.Array.map(d.data.ask_direction, function(cfg) {
                    return me.askDirection.bind(me, cfg.command, function() {
                        requests.shift();
                        if (requests[0]) {
                            requests[0]();
                        } else  {
                            fn();
                        }
                        
                    });
                });
            requests[0]();
        } else {
            fn();
        }
    },
    askDirection: function(cmd, callback) {
        var me = this;
        me.request({
            url: '/game.pl',
            params: {
                cmd: 'ask_direction',
                ask: cmd
            },
            success: function(result) {
                me.onAskDirectionSuccess(result);
                callback();
            },
            failure: callback
        });
    },
    onAskDirectionSuccess: function(result) {
        if (result.ask_direction.mainmenu) {
            Ext.getCmp('mainmenu').updateMenu(result.ask_direction.mainmenu);
        }
    },
    /**
     *      .
     *
     *       :
     *
     *  "... [# <direction_name> #]...."
     *  
     * direction_name -     
     *
     * :
     *
     *  "... [# hint_<hint_id> #]...."
     *
     * hint_id - ID .
     *
     * @param {String} Text
     * @return {String}   (  )
     */
    processText: function(text) {
        var me = this,
            pattern = /\[#\s([\w\d-_]+)\s#\]/ig,
            directions = [],
            hints = [],
            matches, d;
        while ((matches = pattern.exec(text)) != null) {
            if (/^hint_/.test(matches[1])) {
                if (me.user.getSetting('disable_hints') != 1)  {
                    hints.push(matches[1].replace('hint_', ''));
                }
                
            } else {
                d = ExGods.references.get('user_directions').get(matches[1]);
                if (d) {
                    directions.push(d);
                }
            }
        }
        if (directions.length) {
            Ext.Array.each(directions, function(d) {
                me.addDirection(d);
            });
            me.showDirections();
        }
        if (hints.length) {
            var hintsController = me.app.getController('Hints');
            Ext.Array.each(hints, function(h) {
                hintsController.showHintById(h);
            });
        }
        return text.replace(pattern, '');
    },
    /**
     * @private
     */
    addDirection: function(d) {
        var me = this,
            saved = me.storage.get(me.storage.storageId, []),
            alreadyHas = false;
        if (d.data.not_show_with_open_component == 1 && d.data.object_name && Ext.getCmp(d.data.object_name) && Ext.getCmp(d.data.object_name).isVisible()) {
            return;
        }
        //   ,    "   "   
        /***/
        me.log('   ', d);
        Ext.Array.each(saved, function(sd) {
            if (sd.entry == d.entry) {
                alreadyHas = true;
            }
        });
        if (!alreadyHas) {
            saved.push(d);
            me.storage.set(me.storage.storageId, saved);
            if (d.data.object_name) {
                me.listenComponent(d.data.object_name);
            }
        }
    },
    listenComponent: function(cmpId) {
        var me = this,
            listener = {};
        me.listened = me.listened || [];
        if (Ext.Array.indexOf(me.listened, cmpId) == -1) {
            /****/
            me.log('    ', cmpId);
            listener['#' + cmpId] = {
                show: {
                    fn: function() {
                        me.showDirections(cmpId);
                    },
                    single: false
                }
            };
            me.control(listener);
            me.listened.push(cmpId);
        }
    },
    /**
     *      
     */
    initDirectionDialogComponent: function(config, componentId) {
        var me = this,
            action,
            opts = {},
            view;
        //     
        if (me.user.getSetting('disable_hints') == 1 && config.close_btn && config.close_btn != 0 && config.close_btn != '')  {
            return 'wrong_setting';
        }
        
        if (Ext.getCmp(componentId)) {
            return false;
        }
        if (config.serviceId && config.serviceId.id) {
            if (config.extra_service_opts) {
                opts = Ext.decode(config.extra_service_opts);
            }
            action = ExGods.ClientActions.factory({
                actionId: config.serviceId.id,
                src: 'direction',
                options: opts
            });
        }
        config.action = action;
        config.btn = {
            handler: function() {
                //   
                if (config.closeAll) {
                    me.app.getController('Viewport').closeAllWindows();
                }
                //   
                if (action) {
                    ExGods.ClientActions.doAction(action, function(res) {
                        if (res.error) {
                            /***/
                            me.log('error', res.error);
                        }
                    });
                }
                //   
                this.up('direction').close();
            }
        };
        view = Ext.widget('direction', {
            id: 'LETTER_' + componentId,
            //    ID, .. 5-    ID   
            layer: 'directions-layer',
            autoShow: true,
            config: config
        });
        return view;
    },
    blinkTitle: function(text) {
        var originalTitle = document.title,
            duration = ExGods.ref('constants|direction_title_blink_duration').value,
            blinkTime = ExGods.ref('constants|direction_title_blink_time').value,
            pauseTime = ExGods.ref('constants|direction_title_blink_time').value,
            spentTime = 0,
            started = new Date(),
            phase, now;
        document.title = text;
        phase = {
            type: 'blink',
            started: started,
            dur: blinkTime
        };
        var interval = setInterval(function() {
                now = new Date();
                spentTime = now - started;
                if (spentTime > duration) {
                    clearInterval(interval);
                    document.title = originalTitle;
                } else {
                    if (now - phase.started > phase.dur) {
                        if (phase.type == 'blink') {
                            document.title = originalTitle;
                            phase = {
                                type: 'pause',
                                started: now,
                                dur: pauseTime
                            };
                        } else {
                            document.title = text;
                            phase = {
                                type: 'blink',
                                started: now,
                                dur: blinkTime
                            };
                        }
                    }
                }
            }, 100);
    }
});

// @outdated //
/**
 *  
 *
 *           .
 */
Ext.define('ExGodsCore.controller.Feature', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: false,
        prefix: 'Feature:'
    },
    // views: [
    //  'feature.Description',
    //  'feature.Tabs'
    // ],
    init: function(app) {
        var me = this,
            user = me.getUser();
        // me.control({
        //  '#combos-and-features-button': {
        //      afterrender: me.afterCombosButtonRender
        //  },
        //  '#features': {
        //      itemclick: {
        //          fn: me.onFeatureClick,
        //          delay: 0
        //      }
        //  },
        //  '#right-container': {
        //      hide: me.onRightPanelHide
        //  }
        // });
        //app.getController('MainMenu').on('combos-and-features-show', me.onComboTabsShow, me);
        //   
        user.features().load();
    }
});
// user.features().on('load', me.onFeaturesUpdate, me);
// user.features().on('datachanged', me.onFeaturesUpdate, me);
// onLaunch: function() {
//  this.initComboTabs();
// },
// initComboTabs: function() {
//  var me = this;
//  if (!me.getCombosAndFeatures()) {
//      Ext.widget('combotabs', {
//          id: 'combos-and-features'
//      });
//  }
// },
/**
     *     ,  ,  
     * 
     * @param {Boolean} autoCreate
     * @return {ExGods.view.talent.Groups}
     */
// getSchoolTabs: function(autoCreate) {
//  var me = this,
//      tabs = me.getFeatureTabs(),
//      user = me.getUser();
//  if (!tabs && autoCreate === false)
//      return false;
//  if (!tabs) {
//      tabs = Ext.widget('featuretabs', {
//          store: user.features()
//      });
//  }
//  return tabs;
// },
// onComboTabsShow: function(mainMenu, tabs) {
//  var me = this;
//  if (!tabs.down('featuretabs')) {
//      tabs.add(me.getSchoolTabs());
//  }
// },
// afterCombosButtonRender: function(button) {
//  var me = this,
//      user = me.getUser();
//  user.features().on('featuresadded', function(count) {
//      button.addCount(count);
//      if (me.getCombosAndFeatures().getActiveTab() != me.getFeatureTabs())
//          me.getFeatureTabs().tab.addCount(count);
//  });
// },
/**
     *       
     * @private
     */
// onFeatureClick: function(view, record, item, index, e) {
//  var me = this,
//      target = Ext.get(e.getTarget()),
//      status = record.get('status'),
//      left = me.getLeft();
//  left.remove('feature-description');
//  me.comboDescription = Ext.widget('featuredescription', {
//      data: record.data,
//  });
//  left.getLayout().setActiveItem(me.comboDescription);
// },
// onRightPanelHide: function(right) {
//  var me = this,
//      left = me.getLeft(),
//      desc = me.comboDescription;
//  if (me.getSchoolTabs(false) && !me.getSchoolTabs().isVisible(true) && desc && desc.isVisible(true)) {
//      desc.close();
//  }
// },
/**
     * @private
     *    
     */
// onFeaturesUpdate: function(store) {
//  var me = this,
//      finishDate,
//      restTime;
//  /**/ me.log('  ..');
//  //      
//  store.each(function(feature) {
//      var featureFinishDate = feature.get('ended');
//      if (featureFinishDate) {
//          finishDate = finishDate && finishDate < featureFinishDate ? finishDate : featureFinishDate;
//      }
//  });
//  if (me.featureFinishTimeout) {
//      clearInterval(me.featureFinishTimeout);
//  }
//  if (finishDate) {
//      /**/ me.log('   ', finishDate);
//      restTime = Math.floor( (ExGods.util.Date.normalizeServerDateTime(finishDate) - new Date()) / 1000);
//      if (restTime > 0 && restTime < 24*60*60) { //      (setTimeout)       int
//                                                 //     
//          /**/ me.log('  ', restTime, '   ');
//          me.featureFinishTimeout = setTimeout(Ext.bind(me.onFeatureFinished, me), (restTime + 3)*1000); // 3 seconds delay   
//      }
//  } else {
//      /**/ me.log('    .');
//  }
// },
/**
     * @private
     *   .
     *             .    
     */
// onFeatureFinished: function() {
//  var me = this;
//  if (!me.getUser().isBattle()) {
//      /**/ me.log('    -  ');
//            me.application.getController('Location').updateLocation();
//  }
// }

/**
 *   
 */
Ext.define('ExGodsCore.model.ItemPrototype', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'type',
            type: 'int'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'param',
            type: 'auto'
        },
        {
            name: 'data',
            type: 'auto'
        },
        {
            name: 'images',
            type: 'auto',
            convert: function(v) {
                if (Ext.isObject(v)) {
                    Ext.Object.each(v, function(key, value, myself) {
                        myself[key] = IMAGE_URL + myself[key];
                    });
                }
                return v;
            }
        },
        {
            //  ,    
            name: 'action',
            type: 'auto'
        },
        {
            //  
            name: 'action_full',
            type: 'auto'
        },
        {
            //      ""
            name: 'action_value',
            type: 'auto'
        }
    ],
    /**
     *    
     * @return {Boolean}
     */
    isStack: function() {
        var data = this.get('data');
        return (Ext.isObject(data) && data.stack) ? true : false;
    },
    /**
     *  URL  
     * @return {String}
     */
    getImage: function(type) {
        return this.get('images')[type];
    },
    getLevel: function() {
        return this.get('data').strict.level;
    },
    /**
     *       (slot_on, slot_off, param)
     */
    getTypeInfo: function() {
        return ExGods.ref('item_type|' + this.get('type'));
    }
});

/**
 *  
 */
Ext.define('ExGodsCore.store.ItemPrototypes', {
    extend: Ext.data.Store,
    model: 'ExGodsCore.model.ItemPrototype',
    autoLoad: false,
    proxy: {
        type: 'ajax',
        actionMethods: {
            read: 'POST'
        },
        limitParam: false,
        pageParam: false,
        reader: {
            type: 'json',
            rootProperty: 'list'
        },
        startParam: false
    },
    load: function(options) {
        var me = this;
        options = options || {};
        me.proxy.api = {
            read: HOST_URL + '/game.pl?cmd=item.proto'
        };
        if (typeof options == 'function') {
            options = {
                callback: options
            };
        }
        // options.groupers = options.groupers ||  me.groupers.items;
        // options.page = options.page || me.currentPage;
        // options.start = (options.start !== undefined) ? options.start : (me.currentPage - 1) * me.pageSize;
        // options.limit = options.limit || me.pageSize;
        options.addRecords = true;
        if (me.buffered) {
            return me.loadToPrefetch(options);
        }
        return me.callParent([
            options
        ]);
    },
    /**
     *     
     *
     * @param {Number[]} protos IDs 
     * @return {Number[]}   ID  
     */
    check: function(protos) {
        var me = this,
            missed = [],
            i = 0,
            ln, proto_id;
        protos = Ext.Array.unique(protos);
        ln = protos.length;
        for (; i < ln; i++) {
            proto_id = parseInt(protos[i]);
            if (!me.data.getByKey(proto_id) && !Ext.Array.contains(missed, proto_id)) {
                missed.push(proto_id);
            }
        }
        return missed;
    },
    /**
     *    () 
     * 
     * @param {Number[]} protos  id  
     * @param {Function} callback
     * @return {Boolean} true -   , false -    
     */
    loadNew: function(protos, callback) {
        var me = this,
            missed;
        if (!Ext.isArray(protos))  {
            protos = [
                protos
            ];
        }
        
        missed = me.check(protos);
        if (missed.length) {
            me.read({
                params: {
                    ids: Ext.encode(missed)
                },
                callback: callback
            });
            return true;
        } else {
            callback();
        }
        return false;
    }
});

/**
 *   
 */
Ext.define('ExGodsCore.store.ChatContacts', {
    extend: Ext.data.Store,
    model: 'ExGodsCore.model.BasicUser',
    sorters: [
        {
            sorterFn: function(u1, u2) {
                var m1 = u1.get('moder') ? 1 : 0,
                    m2 = u2.get('moder') ? 1 : 0;
                return m1 < m2 ? -1 : (m1 > m2 ? 1 : 0);
            },
            direction: 'DESC'
        },
        {
            property: 'display_title',
            direction: 'ASC'
        }
    ]
});

/**
 *   
 *
 */
Ext.define('ExGodsCore.Application', {
    extend: Ext.app.Application,
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'App:'
    },
    namespaces: [
        'ExGodsCore'
    ],
    controllers: [
        'Chat',
        'Direction',
        'Feature'
    ],
    models: [
        'Location',
        'User',
        'Ability'
    ],
    stores: [
        'ItemPrototypes',
        'ChatContacts'
    ],
    /**
     * @property {Ext.data.Model} user  
     */
    /**
     * @property {Ext.util.HashMap} references  
     */
    /**
     * @property {ExGodsCore.ChatConnection} chatcn   
     * @readonly
     */
    /**
     * @property {Boolean} gameStarted ,   
     */
    gameStarted: false,
    /**
     * @cfg {Array} serverRequestKeyHandlerSequence . {@link ExGodsCore.AjaxRequest#keyHandlersSequence keyHandlersSequence}
     */
    serverRequestKeyHandlerSequence: [],
    /**
     *    
     * @return {Ext.data.Model}
     */
    getUser: Ext.emptyFn,
    /**
     *    
     * @return {Ext.data.Model}
     */
    getLocation: Ext.emptyFn,
    /**
     *    
     * @return {Ext.data.Model}
     */
    getWorld: Ext.emptyFn,
    /**
     *     
     * return {ExGodsCore.ChatConnection} connection
     */
    getChatConnection: function() {
        return this.chatcn;
    },
    /**
     *  
     */
    init: function() {
        var me = this,
            appProperty = me.config.appProperty,
            ns;
        /***/
        me.log('info', '    ');
        ns = Ext.namespace(me.config.name);
        // , ..       
        ns[appProperty] = me;
        ExGodsCore[appProperty] = me;
        IMAGE_URL = me.getImageUrl();
        HOST_URL = me.getHostUrl();
        /***/
        me.log('info', ' ');
        me.references = me.createReferences();
        me.applyLanguageDependedOverrides();
        /***/
        me.log('info', '    ');
        me.getItemPrototypesStore().loadRawData(config.references.item_proto);
        /***/
        me.log('info', '  ');
        me.user = me.createUser();
        /***/
        me.log('info', '   ajax-');
        ExGodsCore.AjaxRequest.initKeyHandlersSequence(me.serverRequestKeyHandlerSequence);
        /***/
        me.log('info', '   ');
        me.chatcn = new ExGodsCore.ChatConnection({
            login: config.chat.login,
            password: config.chat.password,
            application: me
        });
        me.callParent();
    },
    /**
     *  
     */
    launch: function() {
        var me = this;
        //   
        me.chatcn.on('ready', me.onChatConnectionReady, me);
        me.chatcn.connect();
    },
    /**
     *   
     *
     * @param {String} [msg=""]   
     */
    block: function() {},
    //
    /**
     *   
     */
    unblock: function() {},
    //
    /**
     * . {@link ExGodsCore.AjaxRequest#request ExGodsCore.AjaxRequest request}
     */
    request: function(args) {
        return ExGodsCore.AjaxRequest.request(args);
    },
    getImageUrl: function() {
        var imageUrl, imageHosts;
        Ext.util.Cookies.clear('image_url');
        //      
        if (/^https/.test(location.protocol)) {
            if (!(imageUrl = Ext.util.Cookies.get('img_url_https'))) {
                imageHosts = Ext.Array.findBy(config.references.constants_list, function(el) {
                    return el.name == 'image_hosts_https';
                }).value;
                imageUrl = location.protocol + '//' + imageHosts[Math.floor(Math.random() * imageHosts.length)].v + '/';
                Ext.util.Cookies.set('img_url_https', imageUrl);
            } else {
                imageHosts = Ext.Array.findBy(config.references.constants_list, function(el) {
                    return el.name == 'image_hosts_https';
                }).value;
                imageUrl = location.protocol + '//' + imageHosts[Math.floor(Math.random() * imageHosts.length)].v + '/';
                Ext.util.Cookies.set('img_url_https', imageUrl);
            }
        } else {
            if (!(imageUrl = Ext.util.Cookies.get('img_url'))) {
                imageHosts = Ext.Array.findBy(config.references.constants_list, function(el) {
                    return el.name == 'image_hosts';
                }).value;
                imageUrl = location.protocol + '//' + imageHosts[Math.floor(Math.random() * imageHosts.length)].v + '/';
                Ext.util.Cookies.set('img_url', imageUrl);
            }
        }
        Ext.apply(Ext, {
            BLANK_IMAGE_URL: imageUrl + 'blank.gif'
        });
        return imageUrl;
    },
    getHostUrl: function() {
        return '';
    },
    /**
     * @private
     *   
     */
    createReferences: function() {
        /**
         *    
         
        //       ExGods.
        //        ,       .
        // @oleg


         * - main_page
         * - mod_group
         * - market
         * - images
         * - constants_list
         * - user_hint
         * - user_stat
         * - user_modif
         * - user_hoard
         * - user_summary
         * - user_money
         * - user_level
         * - user_trophy
         * - user_shape
         * - user_stuff
         * - user_timed
         * - item_type
         * - slot_type
         * - prototypes_rooms
         * - referer_action
         * - battle_strike
         * - battle_ability_school
         * - battle_log
         * - battle_types
         * - battle_bids_types
         * - constants
         * - components - 
         * - components_objects - -
         * - components_instances -  
         * - client_actions -  
         * - service_protos -  
         * - message_client -  
         * - user_directions -  
         * - user_settings -  
         * - battle_animations - 
         * - battle_turn -    
         * - battle_prep -    
         * - battle_aura - aura  
         * - battle_continuing - 
         * - sounds - 
         * - direct_actions
        */
        var references = new Ext.util.HashMap();
        //   
        var mainPage = {};
        if (config.references.main_page.length) {
            for (var i = 0; i < config.references.main_page.length; i++) {
                var item = config.references.main_page[i];
                mainPage[item.name] = {
                    data: item.data,
                    value: item.value
                };
            }
        }
        references.add('main_page', mainPage);
        //    "prototypes_rooms"
        var roomProtos = new Ext.util.HashMap();
        Ext.each(config.references.prototypes_rooms, function(item) {
            roomProtos.add(parseInt(item.entry, 10), item);
        });
        references.add('prototypes_rooms', roomProtos);
        //   
        var mod_group = {
                0: {
                    images: {
                        main: Ext.BLANK_IMAGE_URL
                    },
                    label: ' ',
                    order: Infinity
                }
            };
        for (i = 0; i < config.references.mod_group.length; i++) {
            var item = config.references.mod_group[i];
            item.entry = parseInt(item.entry);
            item.order = item.order ? parseInt(item.order) : 0;
            item.images.main = item.images.main ? (IMAGE_URL + item.images.main) : Ext.BLANK_IMAGE_URL;
            mod_group[item.entry] = item;
        }
        references.add('mod_group', mod_group);
        //  
        var sounds = new Ext.util.HashMap();
        Ext.each(config.references.sounds, function(item) {
            var file = item.params.file,
                audio = document.createElement('audio'),
                source = document.createElement('source'),
                type = 'audio/ogg';
            audio.appendChild(source);
            if (Ext.isSafari || Ext.isIE || Ext.isGecko) {
                //ogg     ,  mp3 ,   
                file = file.substr(0, file.length - 3) + 'mp3';
                type = 'audio/mpeg';
            }
            source.src = IMAGE_URL + file;
            source.type = type;
            audio.autobuffer = true;
            if (!Ext.isSafari)  {
                audio.load();
            }
            
            sounds.add(item.name, {
                label: item.label,
                description: item.description,
                audio: audio,
                pause: item.params.pause,
                fading: item.params.fading
            });
        });
        references.add('sounds', sounds);
        //  
        var images = new Ext.util.HashMap();
        Ext.each(config.references.images, function(item) {
            var data = {};
            Ext.Array.forEach(item.data, function(image) {
                data[image.name] = IMAGE_URL + image.value;
            });
            images.add(item.name, {
                label: item.label,
                description: item.description,
                image: data
            });
        });
        references.add('images', images);
        var constants_list = references.add('constants_list', {});
        for (i = 0; i < config.references.constants_list.length; i++) {
            var item = config.references.constants_list[i],
                data = {};
            data.label = item.label;
            data.value = [];
            for (j = 0; j < item.value.length; j++) {
                data.value.push(item.value[j].v);
            }
            constants_list[item.name] = data;
        }
        //  
        var hints = {},
            hintsMap = new Ext.util.HashMap();
        for (i = 0; i < config.references.user_hint.length; i++) {
            var item = config.references.user_hint[i];
            if (!hints[item.label])  {
                hints[item.label] = [];
            }
            
            hints[item.label].push(item);
        }
        for (var key in hints) {
            Ext.Array.sort(hints[key], function(a, b) {
                return a.l_order > b.l_order;
            });
            hintsMap.add(key, hints[key]);
        }
        references.add('user_hint', hintsMap);
        //  
        var stats = new Ext.util.MixedCollection();
        Ext.each(config.references.user_stat, function(item) {
            stats.add(item.name, {
                label: item.label,
                visible: parseInt(item.visible),
                param: item.param
            });
        });
        references.add('user_stat', stats);
        //  
        var modifiers = new Ext.util.MixedCollection();
        Ext.each(config.references.user_modif, function(item) {
            modifiers.add(item.name, {
                label: item.label,
                visible: parseInt(item.visible)
            });
        });
        references.add('user_modif', modifiers);
        //   
        var accumulative = new Ext.util.MixedCollection();
        Ext.each(config.references.user_hoard, function(item) {
            accumulative.add(item.name, {
                label: item.label,
                icon: item.params.icon,
                image_big: IMAGE_URL + item.params.image,
                image_disabled: IMAGE_URL + item.params.image_disabled,
                visible: parseInt(item.visible)
            });
        });
        references.add('user_hoard', accumulative);
        //   
        var summable = new Ext.util.MixedCollection();
        Ext.each(config.references.user_summary, function(item) {
            summable.add(item.name, {
                label: item.label,
                icon: item.params.icon,
                visible: parseInt(item.visible)
            });
        });
        references.add('user_summary', summable);
        //  
        var currencies = new Ext.util.MixedCollection(false, function(item) {
                item.image = IMAGE_URL + item.param.image;
                item.image_big = IMAGE_URL + item.param.image_big;
                item.image_disabled = IMAGE_URL + item.param.image_disabled;
                item.visible = parseInt(item.visible);
                return item.name;
            });
        currencies.addAll(config.references.user_money);
        references.add('user_money', currencies);
        //  
        var levels = new Ext.util.MixedCollection(false, function(item) {
                item.level = parseInt(item.level);
                item.expa = parseInt(item.expa);
                return item.level;
            });
        levels.addAll(config.references.user_level);
        references.add('user_level', levels);
        //  
        var userValour = new Ext.util.MixedCollection(false, function(item) {
                item.level = parseInt(item.level);
                item.valour = parseInt(item.valour);
                item.data.img = item.data.img ? (IMAGE_URL + item.data.img) : '';
                return item.level;
            });
        userValour.sortByKey();
        userValour.addAll(config.references.user_valour);
        references.add('user_valour', userValour);
        //  
        var shapes = new Ext.util.MixedCollection(false, function(item) {
                item.thumb = item.small ? (IMAGE_URL + item.small) : Ext.BLANK_IMAGE_URL;
                item.avatar = item.medium ? (IMAGE_URL + item.medium) : Ext.BLANK_IMAGE_URL;
                item.full = item.large ? (IMAGE_URL + item.large) : Ext.BLANK_IMAGE_URL;
                item.battle = item.battle ? (IMAGE_URL + item.battle) : Ext.BLANK_IMAGE_URL;
                delete item.large;
                delete item.medium;
                delete item.small;
                return item.name;
            });
        shapes.addAll(config.references.user_shape);
        references.add('user_shape', shapes);
        //  
        var stuff = new Ext.util.HashMap();
        for (var i = 0; i < config.references.user_stuff.length; i++) {
            var item = config.references.user_stuff[i];
            stuff.add(item.name, item);
        }
        references.add('user_stuff', stuff);
        //   
        var timed = new Ext.util.HashMap({
                keyFn: function(item) {
                    item.visible = parseInt(item.visible);
                    return item.stat;
                }
            });
        Ext.each(config.references.user_timed, function(item) {
            timed.add(item);
        });
        references.add('user_timed', timed);
        //   
        var itemTypes = new Ext.util.MixedCollection();
        Ext.each(config.references.item_type, function(item) {
            itemTypes.add(parseInt(item.entry), {
                title: item.title,
                slot_on: parseInt(item.slot_on),
                slot_off: parseInt(item.slot_off),
                param: item.param
            });
        });
        references.add('item_type', itemTypes);
        //   
        var slotTypes = new Ext.util.MixedCollection();
        Ext.each(config.references.slot_type, function(item) {
            if (Ext.isObject(item.images))  {
                Ext.Object.each(item.images, function(key, value, myself) {
                    item.images[key] = IMAGE_URL + item.images[key];
                });
            }
            
            slotTypes.add(item.entry, {
                title: item.title,
                stack: parseInt(item.stack),
                active: parseInt(item.active),
                images: item.images
            });
        });
        references.add('slot_type', slotTypes);
        references.add('referer_action', new Ext.util.MixedCollection(false, function(item) {
            item.entry = parseInt(item.entry);
            return item.entry;
        })).addAll(config.references.referer_action);
        //   
        var battleStrikes = new Ext.util.MixedCollection();
        Ext.each(config.references.battle_strike, function(item) {
            battleStrikes.add(parseInt(item.entry), {
                action: item.action,
                image: IMAGE_URL + item.image,
                zone: parseInt(item.zone),
                label: item.label
            });
        });
        references.add('battle_strike', battleStrikes);
        //    
        var battleSchools = new Ext.util.MixedCollection();
        Ext.each(config.references.battle_ability_school, function(item) {
            battleSchools.add(parseInt(item.entry), {
                entry: parseInt(item.entry),
                label: item.label,
                images: item.images
            });
        });
        references.add('battle_ability_school', battleSchools);
        //   
        var battleLogs = new Ext.util.MixedCollection();
        Ext.each(config.references.battle_log, function(item) {
            battleLogs.add(item.type + '_' + (item.result || ''), {
                pattern: item.pattern,
                data: item.data
            });
        });
        references.add('battle_log', battleLogs);
        //   
        var battleTypes = new Ext.util.HashMap();
        Ext.each(config.references.battle_types, function(item) {
            item.params.img = item.params.img ? (IMAGE_URL + item.params.img) : Ext.BLANK_IMAGE_URL;
            item.params.img_list = item.params.img_list ? (IMAGE_URL + item.params.img_list) : Ext.BLANK_IMAGE_URL;
            item.params.img_stat = item.params.img_stat ? (IMAGE_URL + item.params.img_stat) : Ext.BLANK_IMAGE_URL;
            battleTypes.add(parseInt(item.entry), {
                label: item.label,
                params: item.params
            });
        });
        references.add('battle_types', battleTypes);
        //     
        var battleBidTypes = new Ext.util.HashMap();
        Ext.each(config.references.battle_bids_types, function(item) {
            battleBidTypes.add(parseInt(item.id), item);
        });
        references.add('battle_bids_types', battleBidTypes);
        // 
        var constants = new Ext.util.HashMap();
        Ext.each(config.references.constants, function(item) {
            constants.add(item.name, {
                label: item.label,
                value: item.value
            });
        });
        references.add('constants', constants);
        var components = new Ext.util.MixedCollection();
        Ext.each(config.references.client_components, function(item) {
            components.add(item.id, item);
        });
        references.add('components', components);
        var components_objects_old = new Ext.util.MixedCollection();
        Ext.each(config.references.client_objects, function(item) {
            Ext.applyIf(item, components.get(item.component_id));
            //   
            components_objects_old.add(item.id, item);
        });
        references.add('components_objects_old', components_objects_old);
        var components_instances = new Ext.util.MixedCollection();
        Ext.each(config.references.client_implementations, function(item) {
            components_instances.add(item.id, item);
        });
        references.add('components_instances', components_instances);
        var service_protos = new Ext.util.MixedCollection();
        Ext.each(config.references.service_protos, function(item) {
            service_protos.add(item.id, item);
        });
        references.add('service_protos', service_protos);
        var services = new Ext.util.MixedCollection();
        Ext.each(config.references.client_actions, function(item) {
            item.proto = service_protos.get(item.type);
            services.add(item.id, item);
        });
        references.add('services', services);
        var client_objects = new Ext.util.MixedCollection();
        Ext.each(config.references.client_objects, function(item) {
            Ext.applyIf(item, components.get(item.component_id));
            //   
            client_objects.add(item.name, item);
        });
        references.add('client_objects', client_objects);
        //    -    
        var client_actions = new Ext.util.MixedCollection();
        services.each(function(service) {
            client_actions.add(service.id, {
                id: service.id,
                serviceId: service.id,
                componentId: service.params.component_id,
                componentObjectName: service.params.object_name
            });
        });
        references.add('client_actions', client_actions);
        var login_days_bonus = new Ext.util.MixedCollection();
        Ext.Object.each(config.references.login_days_bonus, function(day_num, stuff) {
            stuff[0].login_day_index = day_num;
            login_days_bonus.add(stuff[0]);
        });
        references.add('login_days_bonus', login_days_bonus);
        var kit_proto = new Ext.util.MixedCollection();
        Ext.each(config.references.kit_proto, function(item) {
            kit_proto.add(item.entry, item);
        });
        references.add('kit_proto', kit_proto);
        //  
        var payment_preset = new Ext.util.MixedCollection();
        Ext.each(config.references.payment_preset, function(item) {
            payment_preset.add(item.entry, {
                entry: item.entry,
                price: item.price,
                count: item.count,
                bonus: item.bonus_ext
            });
        });
        references.add('payment_preset', payment_preset);
        //   
        var clientMessages = new Ext.util.HashMap();
        Ext.each(config.references.message_client, function(item) {
            clientMessages.add(item.name, item.label);
        });
        references.add('message_client', clientMessages);
        //   
        var userSettings = new Ext.util.HashMap();
        Ext.each(config.references.user_settings, function(item) {
            userSettings.add(item.name, item);
        });
        references.add('user_settings', userSettings);
        //  
        var directions = new Ext.util.HashMap();
        Ext.each(config.references.user_directions, function(item) {
            directions.add(item.name, item);
        });
        references.add('user_directions', directions);
        //  
        var animations = new Ext.util.HashMap();
        Ext.each(config.references.battle_animations, function(item) {
            for (var key in item) {
                if (Object.prototype.hasOwnProperty.call(item, key)) {
                    animations.add(key, item[key]);
                }
            }
        });
        references.add('battle_animations', animations);
        //    
        var battleTurns = new Ext.util.HashMap();
        Ext.each(config.references.battle_turn, function(item) {
            battleTurns.add(item.name, item);
        });
        references.add('battle_turn', battleTurns);
        //    
        var battlePreps = new Ext.util.HashMap();
        Ext.each(config.references.battle_prep, function(item) {
            battlePreps.add(item.name, item);
        });
        references.add('battle_prep', battlePreps);
        //   
        var battleAuras = new Ext.util.HashMap();
        Ext.each(config.references.battle_aura, function(item) {
            battleAuras.add(item.id, item);
        });
        references.add('battle_aura', battleAuras);
        //  
        var battleConts = new Ext.util.HashMap();
        Ext.each(config.references.battle_continuing, function(item) {
            battleConts.add(item.id, item);
        });
        references.add('battle_continuing', battleConts);
        //   
        var battleActions = new Ext.util.HashMap();
        Ext.each(config.references.battle_actions, function(item) {
            battleActions.add(item.id, item);
        });
        references.add('battle_actions', battleActions);
        //   
        var userTrophy = new Ext.util.HashMap();
        Ext.each(config.references.user_trophy, function(item) {
            userTrophy.add(item.entry, item);
        });
        references.add('user_trophy', userTrophy);
        //  elo
        var userElo = new Ext.util.HashMap();
        Ext.each(config.references.user_elo, function(item) {
            userElo.add(item.name, item);
        });
        references.add('user_elo', userElo);
        //   
        var ingredients = new Ext.util.HashMap();
        Ext.each(config.references.ingredients, function(item) {
            ingredients.add(item.name, item);
        });
        references.add('ingredients', ingredients);
        //    
        var directActions = new Ext.util.HashMap();
        Ext.each(config.references.direct_actions, function(item) {
            directActions.add(item.entry, item);
        });
        references.add('direct_actions', directActions);
        //   
        var guildRequests = new Ext.util.HashMap();
        Ext.each(config.references.guild_request_types, function(item) {
            guildRequests.add(item.entry, item);
        });
        references.add('guild_request_types', guildRequests);
        //   
        var guildRaids = new Ext.util.HashMap();
        Ext.each(config.references.guild_raids, function(item) {
            guildRaids.add(item.entry, item);
        });
        references.add('guild_raids', guildRaids);
        //  
        var marketRef = new Ext.util.HashMap();
        Ext.each(config.references.market, function(item) {
            marketRef.add(item.entry, item);
        });
        references.add('market', marketRef);
        //  
        var petsRef = new Ext.util.HashMap();
        Ext.each(config.references.pets, function(item) {
            petsRef.add(item.entry, item);
        });
        references.add('pets', petsRef);
        // 
        references.add('skill_groups', config.references.user_skill_groups);
        //
        var skillsRef = new Ext.util.HashMap();
        Ext.each(config.references.user_skill, function(item) {
            skillsRef.add(item.name, item);
        });
        references.add('skills', skillsRef);
        return references;
    },
    /**
     * @private
     * C   
     */
    createUser: function() {
        var me = this,
            userModel = me.getUserModel();
        return new userModel(config.user);
    },
    /**
     * @private 
     *    
     */
    onChatConnectionReady: function(conn, data) {
        var me = this;
        if (!me.gameStarted) {
            me.gameStarted = true;
            /**
             * @event gamestarted
             *      
             */
            me.fireEvent('gamestarted', data);
        }
    },
    /**
     * @private
     *  ,   
     */
    applyLanguageDependedOverrides: function() {
        Ext.Date.monthNames = [
            ExGodsCore.app.references.get('message_client').get('calendar_january'),
            ExGodsCore.app.references.get('message_client').get('calendar_february'),
            ExGodsCore.app.references.get('message_client').get('calendar_marth'),
            ExGodsCore.app.references.get('message_client').get('calendar_april'),
            ExGodsCore.app.references.get('message_client').get('calendar_may'),
            ExGodsCore.app.references.get('message_client').get('calendar_june'),
            ExGodsCore.app.references.get('message_client').get('calendar_july'),
            ExGodsCore.app.references.get('message_client').get('calendar_august'),
            ExGodsCore.app.references.get('message_client').get('calendar_september'),
            ExGodsCore.app.references.get('message_client').get('calendar_october'),
            ExGodsCore.app.references.get('message_client').get('calendar_november'),
            ExGodsCore.app.references.get('message_client').get('calendar_december')
        ];
        Ext.Date.shortMonthNames = [
            ExGodsCore.app.references.get('message_client').get('calendar_jan'),
            ExGodsCore.app.references.get('message_client').get('calendar_feb'),
            ExGodsCore.app.references.get('message_client').get('calendar_marth'),
            ExGodsCore.app.references.get('message_client').get('calendar_apr'),
            ExGodsCore.app.references.get('message_client').get('calendar_may'),
            ExGodsCore.app.references.get('message_client').get('calendar_june'),
            ExGodsCore.app.references.get('message_client').get('calendar_july'),
            ExGodsCore.app.references.get('message_client').get('calendar_aug'),
            ExGodsCore.app.references.get('message_client').get('calendar_sept'),
            ExGodsCore.app.references.get('message_client').get('calendar_oct'),
            ExGodsCore.app.references.get('message_client').get('calendar_nov'),
            ExGodsCore.app.references.get('message_client').get('calendar_dec')
        ];
        Ext.Date.monthNumbers = {
            '': 0,
            '': 1,
            '': 2,
            '': 3,
            '': 4,
            '': 5,
            '': 6,
            '': 7,
            '': 8,
            '': 9,
            '': 10,
            '': 11
        };
        Ext.Date.dayNames = [
            ExGodsCore.app.references.get('message_client').get('calendar_sunday'),
            ExGodsCore.app.references.get('message_client').get('calendar_monday'),
            ExGodsCore.app.references.get('message_client').get('calendar_tuesday'),
            ExGodsCore.app.references.get('message_client').get('calendar_wednesday'),
            ExGodsCore.app.references.get('message_client').get('calendar_thursday'),
            ExGodsCore.app.references.get('message_client').get('calendar_friday'),
            ExGodsCore.app.references.get('message_client').get('calendar_saturday')
        ];
    }
});

/**
 *    
 *
 * @author  
 */
Ext.define('ExGods.view.Template', {
    extend: Ext.XTemplate,
    apply: function() {
        var me = this;
        if (me.compiled != true) {
            delete me.fn;
        }
        return me.callParent(arguments);
    },
    isUserMan: function() {
        return ExGods.app.user.get('gender') == 1;
    },
    isUserGirl: function() {
        return ExGods.app.user.get('gender') == 2;
    },
    getUserRoom: function() {
        return ExGods.app.getController('Base').getLocation().getName();
    },
    getUserWorld: function() {
        return ExGods.app.getController('Base').getWorld().getTitle();
    },
    getUserDisplayTitle: function() {
        return ExGods.app.user.get('display_title');
    },
    getUserCls: function(user) {
        var cls = [];
        if (user[1] == ExGods.app.user.get('display_title'))  {
            cls.push('self');
        }
        
        return cls.join(' ');
    },
    getRank: function(rank) {
        return ExGods.references.get('user_valour').getByKey(parseInt(rank)).data.rank;
    }
});

/**
 *       Ext.panel.Panel
 */
Ext.define('ExGods.view.plugin.HintDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.hintdeco',
    init: function(cmp) {
        Ext.applyIf(cmp, {
            padding: '20 25',
            title: ' '
        });
        Ext.apply(cmp, {
            shadow: false
        });
        cmp.on('render', this.addDeco, this, {
            single: true
        });
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.setUI('hint');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="hint-tl"></div>' + '<div class="hint-tm"></div>' + '<div class="hint-tr"></div>' + '<div class="hint-mr"></div>' + '<div class="hint-br"></div>' + '<div class="hint-bm"></div>' + '<div class="hint-bl"></div>' + '<div class="hint-ml"></div>' + '<div class="hint-tm2"></div>' + '<div class="hint-bm2"></div>' + '<div class="hint-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'deco/hint/hint_t_corn_l.png',
                IMAGE_URL + 'deco/hint/hint_t_corn_r.png',
                IMAGE_URL + 'deco/hint/hint_btm_corn_l.png',
                IMAGE_URL + 'deco/hint/hint_btm_corn_r.png',
                IMAGE_URL + 'deco/hint/hint_t_bg.png',
                IMAGE_URL + 'deco/hint/hint_btm_bg.png',
                IMAGE_URL + 'deco/hint/hint_l.png',
                IMAGE_URL + 'deco/hint/hint_r.png',
                IMAGE_URL + 'deco/hint/hint_center.png',
                IMAGE_URL + 'deco/hint/hint_t_c.png',
                IMAGE_URL + 'deco/hint/hint_btm_c.png'
            ]
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.plugin.ParchmentDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.parchmentdeco',
    padding: true,
    init: function(cmp) {
        if (!cmp.title)  {
            cmp.title = ' ';
        }
        
        if (cmp.bodyBorder !== false) {
            cmp.bodyCls += ' parchment-content';
            if (this.padding == false) {
                cmp.bodyCls += ' parchment-content-nop';
            }
        }
        cmp.addCls('parchment-deco');
        if (cmp.isPanel)  {
            Ext.override(cmp, {
                addTool: function(tools) {
                    tools = [].concat(tools);
                    Ext.Array.forEach(tools, function(tool) {
                        tool.height = 31;
                        tool.width = 32;
                    });
                    this.callParent(arguments);
                }
            });
        }
        
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header)  {
            cmp.header.setHeight(0);
        }
        
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'close.png',
                IMAGE_URL + 'parchment-tl.jpg',
                IMAGE_URL + 'parchment-tm.jpg',
                IMAGE_URL + 'parchment-tr.jpg',
                IMAGE_URL + 'parchment-mr.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'parchment-br.jpg',
                IMAGE_URL + 'parchment-bm.jpg',
                IMAGE_URL + 'parchment-bl.jpg',
                IMAGE_URL + 'parchment-ml.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'separator-horizontal.jpg'
            ]
        };
    }
});

/**
 *   ""
 */
Ext.define('ExGods.view.plugin.PaperDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.paperdeco',
    init: function(cmp) {
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('x-paper');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="paper paper-tl"></div>' + '<div class="paper paper-tm"></div>' + '<div class="paper paper-tr"></div>' + '<div class="paper paper-mr"></div>' + '<div class="paper paper-br"></div>' + '<div class="paper paper-bm"></div>' + '<div class="paper paper-bl"></div>' + '<div class="paper paper-ml"></div>' + '<div class="paper paper-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'deco/paper/paper_top_left.png',
                IMAGE_URL + 'deco/paper/paper_top_middle.png',
                IMAGE_URL + 'deco/paper/paper_top_right.png',
                IMAGE_URL + 'deco/paper/paper_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_middle.png',
                IMAGE_URL + 'deco/paper/paper_bottom_left.png',
                IMAGE_URL + 'deco/paper/paper_left.png',
                IMAGE_URL + 'deco/paper/paper_center_tile.png'
            ]
        };
    }
});

/**
 *     - 
 */
Ext.define('ExGods.view.plugin.SkinDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.skindeco',
    init: function(cmp) {
        cmp.title = ' ';
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('x-skin');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="skin skin-tl"></div>' + '<div class="skin skin-tm"></div>' + '<div class="skin skin-tr"></div>' + '<div class="skin skin-mr"></div>' + '<div class="skin skin-br"></div>' + '<div class="skin skin-bm"></div>' + '<div class="skin skin-bl"></div>' + '<div class="skin skin-ml"></div>' + '<div class="skin skin-bg"></div>');
    },
    destroy: function() {
        var me = this;
        if (me.cmp) {
            me.cmp.un('render', me.addDeco, me);
            me.cmp = null;
        }
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'skin-tl.png',
                IMAGE_URL + 'skin-tm.png',
                IMAGE_URL + 'skin-tr.png',
                IMAGE_URL + 'skin-mr.png',
                IMAGE_URL + 'skin-br.png',
                IMAGE_URL + 'skin-bm.png',
                IMAGE_URL + 'skin-bl.png',
                IMAGE_URL + 'skin-ml.png',
                IMAGE_URL + 'skin-bg.png',
                IMAGE_URL + 'btn_close.png',
                IMAGE_URL + 'close.png',
                IMAGE_URL + 'skin-window-tl.png',
                IMAGE_URL + 'skin-window-tr.png',
                IMAGE_URL + 'skin-window-br.png',
                IMAGE_URL + 'skin-window-bl.png'
            ]
        };
    }
});

/**
 *      
 */
Ext.define('ExGods.view.plugin.StoneDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.stonedeco',
    init: function(cmp) {
        cmp.title = ' ';
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('x-stone');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="stone stone-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [
                IMAGE_URL + 'stone/forge_bg_stone.png',
                IMAGE_URL + 'stone/forge_button_x.png',
                IMAGE_URL + 'close.png'
            ].concat(arr_images)
        };
    }
});

/**
 *     - 
 */
Ext.define('ExGods.view.plugin.SkinParchmentDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.skinparchmentdeco',
    init: function(cmp) {
        Ext.applyIf(cmp, {
            padding: '13 16 17 15',
            title: ' '
        });
        Ext.apply(cmp, {
            shadow: false
        });
        cmp.on('render', this.addDeco, this, {
            single: true
        });
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.setUI('skinparchment');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="skin skin-tl"></div>' + '<div class="skin skin-tm"></div>' + '<div class="skin skin-tr"></div>' + '<div class="skin skin-mr"></div>' + '<div class="skin skin-br"></div>' + '<div class="skin skin-bm"></div>' + '<div class="skin skin-bl"></div>' + '<div class="skin skin-ml"></div>' + '<div class="skin skin-bg"></div>' + '<div class="parchment parchment-tl"></div>' + '<div class="parchment parchment-tm"></div>' + '<div class="parchment parchment-tr"></div>' + '<div class="parchment parchment-mr"></div>' + '<div class="parchment parchment-br"></div>' + '<div class="parchment parchment-bm"></div>' + '<div class="parchment parchment-bl"></div>' + '<div class="parchment parchment-ml"></div>' + '<div class="parchment parchment-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'skin-tl.png',
                IMAGE_URL + 'skin-tm.png',
                IMAGE_URL + 'skin-tr.png',
                IMAGE_URL + 'skin-mr.png',
                IMAGE_URL + 'skin-br.png',
                IMAGE_URL + 'skin-bm.png',
                IMAGE_URL + 'skin-bl.png',
                IMAGE_URL + 'skin-ml.png',
                IMAGE_URL + 'skin-bg.png',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'parchment-tl.jpg',
                IMAGE_URL + 'parchment-tm.jpg',
                IMAGE_URL + 'parchment-tr.jpg',
                IMAGE_URL + 'parchment-mr.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'parchment-br.jpg',
                IMAGE_URL + 'parchment-bm.jpg',
                IMAGE_URL + 'parchment-bl.jpg',
                IMAGE_URL + 'parchment-ml.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'separator-horizontal.jpg'
            ]
        };
    }
});

/**
 *     - 
 */
Ext.define('ExGods.view.plugin.SkinPaperDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.skinpaperdeco',
    init: function(cmp) {
        Ext.applyIf(cmp, {
            padding: '13 17 27 14',
            title: ' '
        });
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        Ext.apply(cmp, {
            shadow: false
        });
        cmp.on('render', this.addDeco, this, {
            single: true
        });
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('x-skin');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="skin skin-tl"></div>' + '<div class="skin skin-tm"></div>' + '<div class="skin skin-tr"></div>' + '<div class="skin skin-mr"></div>' + '<div class="skin skin-br"></div>' + '<div class="skin skin-bm"></div>' + '<div class="skin skin-bl"></div>' + '<div class="skin skin-ml"></div>' + '<div class="skin skin-bg"></div>' + '<div class="paper paper-tl"></div>' + '<div class="paper paper-tm"></div>' + '<div class="paper paper-tr"></div>' + '<div class="paper paper-mr"></div>' + '<div class="paper paper-br"></div>' + '<div class="paper paper-bm"></div>' + '<div class="paper paper-bl"></div>' + '<div class="paper paper-ml"></div>' + '<div class="paper paper-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'skin-tl.png',
                IMAGE_URL + 'skin-tm.png',
                IMAGE_URL + 'skin-tr.png',
                IMAGE_URL + 'skin-mr.png',
                IMAGE_URL + 'skin-br.png',
                IMAGE_URL + 'skin-bm.png',
                IMAGE_URL + 'skin-bl.png',
                IMAGE_URL + 'skin-ml.png',
                IMAGE_URL + 'skin-bg.png',
                IMAGE_URL + 'deco/paper/paper_top_right.png',
                IMAGE_URL + 'deco/paper/paper_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_middle.png',
                IMAGE_URL + 'deco/paper/paper_bottom_left.png',
                IMAGE_URL + 'deco/paper/paper_left.png',
                IMAGE_URL + 'deco/paper/paper_center_tile.png'
            ]
        };
    }
});

/**
 *     
 */
Ext.define('ExGods.view.plugin.WinDeco', {
    alias: 'plugin.windeco',
    extend: Ext.AbstractPlugin,
    init: function(cmp) {
        var me = this;
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 29;
                    tool.width = 25;
                });
                this.callParent(arguments);
            }
        });
        Ext.apply(cmp, {
            defaultDockWeights: {
                top: 7,
                bottom: 5,
                left: 3,
                right: 1
            },
            plain: true,
            shadow: false
        });
        cmp.header = Ext.apply(cmp.header || {}, {
            padding: '6 10 0 35',
            titleAlign: 'center'
        });
        cmp.padding = cmp.padding == undefined ? '0 17 19 18' : cmp.padding;
        cmp.on('render', me.addDeco, me);
        me.cmp = cmp;
    },
    /**
     *   
     */
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('window-deco');
        cmp.el.insertHtml('afterBegin', '<div class="battle-window-deco battle-window-tl window-frame window-tl"></div>' + '<div class="battle-window-deco battle-window-tm window-frame window-tm">' + '<div class="battle-window-title window-title"></div>' + '</div>' + '<div class="battle-window-deco battle-window-tr window-frame window-tr"></div>' + '<div class="battle-window-deco battle-window-mr window-frame window-mr"></div>' + '<div class="battle-window-deco battle-window-br window-frame window-br"></div>' + '<div class="battle-window-deco battle-window-bm window-frame window-bm"></div>' + '<div class="battle-window-deco battle-window-bl window-frame window-bl"></div>' + '<div class="battle-window-deco battle-window-ml window-frame window-ml"></div>' + '<div class="battle-window-deco battle-window-bg window-frame window-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [
                IMAGE_URL + 'battle-window-close.png',
                IMAGE_URL + 'battle-window-tl.png',
                IMAGE_URL + 'battle-window-tm.png',
                IMAGE_URL + 'battle-window-tr.png',
                IMAGE_URL + 'battle-window-mr.png',
                IMAGE_URL + 'battle-window-br.png',
                IMAGE_URL + 'battle-window-bm.png',
                IMAGE_URL + 'battle-window-bl.png',
                IMAGE_URL + 'battle-window-ml.png',
                IMAGE_URL + 'battle-window-bg.jpg'
            ].concat(arr_images)
        };
    }
});

/**
 * ""  
 */
Ext.define('ExGods.view.plugin.IronDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.irondeco',
    init: function(cmp) {
        cmp.title = ' ';
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.setStyle({
            padding: '5px'
        });
        cmp.el.insertHtml('afterBegin', '<div class="iron-deco-tl"></div>' + '<div class="iron-deco-tm"></div>' + '<div class="iron-deco-tr"></div>' + '<div class="iron-deco-mr"></div>' + '<div class="iron-deco-br"></div>' + '<div class="iron-deco-bm"></div>' + '<div class="iron-deco-bl"></div>' + '<div class="iron-deco-ml"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'deco/iron/iron_deco_tl.png',
                IMAGE_URL + 'deco/iron/iron_deco_tm.png',
                IMAGE_URL + 'deco/iron/iron_deco_tr.png',
                IMAGE_URL + 'deco/iron/iron_deco_mr.png',
                IMAGE_URL + 'deco/iron/iron_deco_br.png',
                IMAGE_URL + 'deco/iron/iron_deco_bm.png',
                IMAGE_URL + 'deco/iron/iron_deco_bl.png',
                IMAGE_URL + 'deco/iron/iron_deco_ml.png'
            ]
        };
    }
});

/**
 *       
 */
Ext.define('ExGods.view.plugin.FormSubText', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.formsubtext',
    init: function(form) {
        form.FormSubText = this;
        this.form = form;
    },
    removeSubText: function() {
        var formEl = this.form.getEl();
        if (formEl) {
            formEl.select(".form-subtext-elems").remove();
        }
        this.form.updateLayout();
    },
    update: function(result, color) {
        var me = this;
        formItems = me.form.items , length = formItems.items.length , formEl = me.form.getEl();
        if (!me.form.rendered) {
            return;
        }
        me.removeSubText();
        for (var i = 0; i < length; i++) {
            for (var j in result) {
                if (formItems.items[i].name === j) {
                    //   textfield     22 ,     
                    if (formItems.items[i].xtype === 'textfield') {
                        var html = '<td colspan="2" width="' + formItems.items[i].getWidth() + 'px"><b style="colspan: 2;color:' + color + ';">' + result[j] + '</b></td>';
                    } else {
                        var html = '<td colspan="2"><b style="colspan: 2;color:' + color + ';">' + result[j] + '</b></td>';
                    }
                    Ext.get(formItems.items[i].id).down('tbody').createChild({
                        tag: 'tr',
                        cls: 'form-subtext-elems',
                        html: html
                    });
                }
            }
        }
        me.form.updateLayout();
    },
    destroy: function() {
        var me = this;
        me.form = null;
        me.callParent(arguments);
    }
});

/**
 *    (-). , ,  
 */
Ext.define('ExGods.view.plugin.Pager', {
    alias: 'plugin.pager',
    extend: Ext.AbstractPlugin,
    mixins: {
        observable: Ext.util.Observable
    },
    /**
     * cfg
     * Number -   
     */
    marginLeft: 0,
    /**
     * cfg
     * Number -   
     */
    marginRight: 0,
    /**
     * cfg
     * Number -     
     */
    top: 0,
    /**
     * cfg
     * total -  
     */
    total: 1,
    /**
     * cfg
     * current -  
     */
    current: 1,
    /**
     * cfg
     * totalTabs -  
     */
    totalTabs: 0,
    /**
     * cfg
     * currentTab -  
     */
    currentTab: 0,
    /**
     * cfg
     * isWaitingForCenter -      center c -     center 
     */
    isWaitingForCenter: false,
    /**
     * cfg
     * hidden -   ? 
     */
    hidden: 0,
    /**
     * cfg
     * hideIfSinglePage -  ,    
     */
    hideIfSinglePage: 0,
    /**
     * cfg
     * tpl (Array) - template    
     */
    tpl: [
        '<div class="pager-text">',
        '<div class="pager-text-left"></div>',
        '<div class="pager-text-center">{[this.printPages(values)]}</div>',
        '<div class="pager-text-right"></div>',
        '</div>',
        {
            printPages: function(values) {
                return ExGods.app.applyTpl(ExGods.getMsgByKey('plugin_pager_pagestpl'), {
                    current: values.current,
                    total: values.total || 1
                });
            }
        }
    ],
    /**
     * cfg   " 1  1"
     */
    textTop: 341,
    textLeft: 491,
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        me.mixins.observable.constructor.call(me, config);
    },
    init: function(cmp) {
        var me = this;
        cmp.pager = me;
        cmp.on({
            afterlayout: me.addArrows,
            hide: me.hideArrows,
            close: me.hideArrows,
            scope: me
        });
        me.cmp = cmp;
        me.mon(Ext.getCmp('layer-over2'), 'show', me.refresh, me);
        me.mon(Ext.getCmp('layer-over2'), 'hide', me.refresh, me);
        me.mon(Ext.getCmp('center'), 'show', me.setVisible, me);
        me.mon(Ext.getCmp('center'), 'hide', me.setVisible, me);
        me.mon(cmp, 'show', me.onCmpShow, me);
        me.mon(cmp, 'render', function() {
            me.wnd = me.cmp.up('window1') || me.cmp.up('window2');
            me.onCmpShow();
        }, me);
    },
    onCmpShow: function() {
        this.setVisible();
    },
    setVisible: function() {
        var me = this;
        if (me.isVisible()) {
            this.showArrows();
            if (this.isWaitingForCenter) {
                this.setPosition();
                this.isWaitingForCenter = false;
            }
        } else {
            this.hideArrows();
        }
    },
    /**
     * ,   
     */
    isVisible: function() {
        var me = this,
            centerContainer = Ext.getCmp('center');
        if (!centerContainer.isVisible()) {
            return false;
        } else {
            if (this.cmp && this.cmp.isVisible(true) && (!this.wnd || (this.wnd.isVisible())) && // && (this.wnd.layout.getActiveItem().down(this.cmp.xtype) ? 
            //  this.wnd.layout.getActiveItem().down(this.cmp.xtype).id : 
            //  this.wnd.layout.getActiveItem().id) == this.cmp.id
            !this.hidden && (!this.hideIfSinglePage || me.total > 1)) {
                return true;
            } else {
                return false;
            }
        }
    },
    setPosition: function() {
        var me = this,
            cmp = me.cmp,
            viewport = Ext.get('viewport'),
            position = cmp.el.getPageBox();
        if (me.leftArrow) {
            me.leftArrow.style.left = (position.left - (document.body.scrollWidth - viewport.getWidth()) / 2) + 'px';
            me.leftArrow.style.top = me.rightArrow.style.top = (position.top + me.top) + 'px';
            me.leftArrow.style.marginLeft = me.marginLeft + 'px';
        }
        if (me.rightArrow) {
            me.rightArrow.style.right = (document.body.scrollWidth - position.left - position.width - (document.body.scrollWidth - viewport.getWidth()) / 2) + 'px';
            me.rightArrow.style.marginRight = me.marginRight + 'px';
        }
        if (me.pagerText) {
            me.pagerText.style.top = me.textTop + 'px';
            me.pagerText.style.left = me.textLeft + 'px';
        }
    },
    hideArrows: function() {
        if (this.leftArrow)  {
            this.leftArrow.style.display = 'none';
        }
        
        if (this.rightArrow)  {
            this.rightArrow.style.display = 'none';
        }
        
        if (this.pagerText)  {
            this.pagerText.style.display = 'none';
        }
        
        this.fireEvent('hide', this);
    },
    showArrows: function() {
        if (this.leftArrow)  {
            this.leftArrow.style.display = 'block';
        }
        
        if (this.rightArrow)  {
            this.rightArrow.style.display = 'block';
        }
        
        if (this.pagerText)  {
            this.pagerText.style.display = 'block';
        }
        
        //this.setZIndex();
        this.fireEvent('show', this);
    },
    /**
     *   
     */
    addArrows: function() {
        var me = this,
            cmp = me.cmp,
            viewport = Ext.get('viewport'),
            position = cmp.el.getPageBox();
        if (!Ext.getCmp('center').isVisible()) {
            me.isWaitingForCenter = true;
        } else {
            me.isWaitingForCenter = false;
        }
        if (!me.leftArrow) {
            me.leftArrow = viewport.insertHtml('beforeEnd', '<div class="pager-left-arrow"><div></div></div>');
            me.leftArrow.onclick = function() {
                if (me.current <= 1 && me.currentTab <= 0)  {
                    return;
                }
                
                me.current--;
                if (typeof me.cmp.prevPage == 'function') {
                    me.cmp.prevPage(me);
                } else {
                    me.cmp.fireEvent('prev', me);
                }
            };
            if (me.current <= 1 && me.currentTab <= 0)  {
                me.leftArrow.firstChild.className += ' disabled';
            }
            
        }
        if (!me.rightArrow) {
            me.rightArrow = viewport.insertHtml('beforeEnd', '<div class="pager-right-arrow"><div></div></div>');
            me.rightArrow.onclick = function() {
                if (me.current >= me.total && me.currentTab >= me.totalTabs - 1)  {
                    return;
                }
                
                me.current++;
                if (typeof me.cmp.nextPage == 'function') {
                    me.cmp.nextPage(me);
                } else {
                    me.cmp.fireEvent('next', me);
                }
            };
            if (me.current >= me.total && me.currentTab >= me.totalTabs - 1)  {
                me.rightArrow.firstChild.className += ' disabled';
            }
            
        }
        if (me.tpl && !me.pagerText) {
            me.tpl = Ext.create('ExGods.view.Template', me.tpl);
            me.pagerText = me.tpl.insertAfter(cmp.el, {
                current: me.current,
                total: me.total
            });
        }
        me.setPosition();
        me.setZIndex();
        if (!me.isVisible()) {
            me.hideArrows();
        }
        me.fireEvent('render', me);
        return true;
    },
    setZIndex: function() {
        var me = this;
        setTimeout(function() {
            if (me.wnd && me.wnd.layer.el && me.leftArrow)  {
                me.leftArrow.style.zIndex = parseInt(me.wnd.layer.el.getStyle('z-index'));
            }
            
            if (me.wnd && me.wnd.layer.el && me.rightArrow)  {
                me.rightArrow.style.zIndex = parseInt(me.wnd.layer.el.getStyle('z-index'));
            }
            
        }, 0);
    },
    refresh: function() {
        if (!this.cmp || !this.wnd)  {
            return;
        }
        
        var me = this,
            layer = me.wnd.layer,
            removeDisabled = function(cls) {
                cls = cls.split(' ');
                for (var i = cls.length - 1; i >= 0; i--) {
                    if (cls[i] == 'disabled') {
                        cls.splice(i, 1);
                    }
                }
                return cls.join(' ');
            },
            disabled = false;
        me.setVisible();
        if (layer) {
            disabled = layer.id == 'layer-over1' && Ext.getCmp('layer-over2').isVisible();
        }
        if (!me.leftArrow && !me.addArrows())  {
            return;
        }
        
        if (disabled || (me.current <= 1 && me.currentTab <= 0)) {
            if (me.leftArrow.firstChild.className.split(' ').indexOf('disabled') == -1)  {
                me.leftArrow.firstChild.className += ' disabled';
            }
            
        } else {
            me.leftArrow.firstChild.className = removeDisabled(me.leftArrow.firstChild.className);
        }
        if (disabled || (me.current >= me.total && me.currentTab >= me.totalTabs - 1)) {
            if (me.rightArrow.firstChild.className.split(' ').indexOf('disabled') == -1)  {
                me.rightArrow.firstChild.className += ' disabled';
            }
            
        } else {
            me.rightArrow.firstChild.className = removeDisabled(me.rightArrow.firstChild.className);
        }
        if (Ext.getClassName(me.tpl) && me.isVisible()) {
            me.pagerText.parentNode.removeChild(me.pagerText);
            me.pagerText = me.tpl.insertAfter(me.cmp.el, {
                current: me.current || 1,
                total: me.total || 1
            });
            me.pagerText.style.top = me.textTop + 'px';
            me.pagerText.style.left = me.textLeft + 'px';
        }
        me.fireEvent('refresh');
    },
    removeArrows: function() {
        if (this.leftArrow) {
            this.leftArrow.parentNode.removeChild(this.leftArrow);
        }
        if (this.rightArrow) {
            this.rightArrow.parentNode.removeChild(this.rightArrow);
        }
    },
    removePagerText: function() {
        if (this.pagerText) {
            this.pagerText.parentNode.removeChild(this.pagerText);
        }
    },
    destroy: function() {
        var me = this;
        me.cmp.un({
            render: me.addArrows,
            afterlayout: me.addArrows,
            hide: me.hideArrows,
            close: me.hideArrows,
            show: me.showArrows,
            scope: me
        });
        me.mun(Ext.getCmp('layer-over2'), 'show', me.refresh, me);
        me.mun(Ext.getCmp('layer-over2'), 'hide', me.refresh, me);
        me.mun(Ext.getCmp('center'), 'show', me.setVisible, me);
        me.mun(Ext.getCmp('center'), 'hide', me.setVisible, me);
        me.mun(me.cmp, 'show', me.onCmpShow, me);
        me.removeArrows();
        me.removePagerText();
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'pager/btn_left_bg.png',
                IMAGE_URL + 'pager/btn_right_bg.png',
                IMAGE_URL + 'pager/btn_left.png',
                IMAGE_URL + 'pager/btn_right.png',
                IMAGE_URL + 'page_num.png'
            ]
        };
    }
});

/**
 * ""  
 */
Ext.define('ExGods.view.plugin.InventoryFrame', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.inventory_frame',
    init: function(cmp) {
        cmp.title = ' ';
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        if (!cmp.noBorderImages) {
            cmp.el.setStyle({
                padding: '10px'
            });
            cmp.el.insertHtml('afterBegin', '<div class="inventorty-frame-ml"></div>' + '<div class="inventorty-frame-tm"></div>' + '<div class="inventorty-frame-bm"></div>' + '<div class="inventorty-frame-mr"></div>' + '<div class="inventorty-frame-br"></div>' + '<div class="inventorty-frame-bl"></div>' + '<div class="inventorty-frame-tr"></div>' + '<div class="inventorty-frame-tl"></div>');
        }
        cmp.el.insertHtml('afterBegin', '<div class="inventorty-frame-top"></div>');
        if (cmp.headerText) {
            cmp.el.insertHtml('afterBegin', '<div class="inventorty-frame-text inventory-frame-text-background">' + cmp.headerText + '</div>' + '<div class="inventorty-frame-text">' + cmp.headerText + '</div>');
        }
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'inventory/frm_top_left.jpg',
                IMAGE_URL + 'inventory/frm_top_center.jpg',
                IMAGE_URL + 'inventory/frm_top_right.jpg',
                IMAGE_URL + 'inventory/frm_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_center.jpg',
                IMAGE_URL + 'inventory/frm_bottom_left.jpg',
                IMAGE_URL + 'inventory/frm_left.jpg',
                IMAGE_URL + 'inventory/frm_top.png'
            ].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.ImageButton', {
    alias: 'widget.imagebutton',
    extend: Ext.button.Button,
    image: Ext.BLANK_IMAGE_URL,
    padding: 0,
    onRender: function(ct, position) {
        var me = this;
        me.callParent(arguments);
        me.setImage();
    },
    /**
     *   
     * @param {String} image URL 
     */
    setImage: function(image) {
        var me = this;
        if (image)  {
            me.image = image;
        }
        
        me.btnEl.setStyle({
            background: 'url(' + me.image + ') no-repeat 50% 50%'
        });
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   .
 *   ,    Ext.slider.Single .
 *        Ext.panel.Panel,
 * ..    dock    .
 */
Ext.define('ExGods.view.plugin.Scroller', {
    extend: ExGodsCore.view.plugin.Scroller,
    alias: 'plugin.scroller',
    scrollerConfig: {
        slider: {
            animate: false,
            decimalPrecision: false,
            flex: 1,
            increment: 1,
            useTips: false,
            value: 100,
            vertical: true
        },
        scrollTop: {
            cls: 'scroll-top',
            height: 22
        },
        scrollBottom: {
            cls: 'scroll-bottom',
            height: 20
        },
        toolbar: {
            dock: 'right',
            defaults: {
                margin: 0,
                width: 21
            },
            ui: 'scroller'
        }
    },
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [
                IMAGE_URL + 'scrollbar/thumb.png',
                IMAGE_URL + 'scrollbar/bg_midle.png',
                IMAGE_URL + 'scrollbar/bg_top.png',
                IMAGE_URL + 'scrollbar/bg_bottom.png'
            ].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.chat.ContactList', {
    extend: Ext.panel.Panel,
    alias: 'widget.chatcontactlist',
    plugins: [
        {
            ptype: 'scroller',
            autoHide: true,
            resetOnShow: false,
            scrollDeltaY: 23
        }
    ],
    title: '',
    cls: 'chat-contact-list',
    ignore_focus: true,
    //     
    /**
     * @cfg {Ext.data.Store} store   
     */
    store: null,
    initComponent: function() {
        var me = this;
        me.items = {
            xtype: 'dataview',
            itemId: 'contact-list',
            autoEl: 'ul',
            cls: 'contacts userlist',
            itemSelector: 'li.userlist-item',
            loadMask: false,
            store: me.store,
            tpl: [
                '<tpl for=".">',
                '<li class="userlist-item {[this.getCls(values)]}">',
                '<span class="action-icon private-msg-icon" data-qtip="' + ExGods.getMsgByKey('view_chat_contactlist_privatett') + '"></span>',
                '<span class="action-icon user-info-icon" data-qtip="' + ExGods.getMsgByKey('view_chat_contactlist_infott') + '"></span>',
                '{[ ExGods.printUser(values, {fields: ["name", "guild"], maxNameWidth: (values.guild ? 122 : 146) }) ]}',
                '<span class="right-col">',
                '{[ ExGods.printUser(values, {fields: ["level", "rating_rank", "trophy_level", "menuicon"], hideLevelIcon: true}) ]}',
                '</span>',
                '</li>',
                '</tpl>',
                {
                    getCls: function(data) {
                        var cls = [];
                        if (data.binding.battle) {
                            cls.push('exg-bgcolor-in-battle');
                        }
                        if (data.moder) {
                            cls.push('moder');
                        }
                        cls.push('gender-' + data.gender);
                        return cls.join(' ');
                    }
                }
            ]
        };
        me.callParent();
    },
    /**
     *      
     *    {@event afterstorechanged}   
     * @param {Ext.data.Store} store (required)
     */
    bindStore: function(store) {
        var me = this,
            dataview = me.down('dataview');
        dataview.bindStore(store);
        //     ,      ( , 
        // ,     )
        me.fireEvent('afterstorechanged', me);
    }
});

/**
 *    
 */
Ext.define('ExGods.view.chat.MessageList', {
    extend: ExGodsCore.view.chat.MessageList,
    alias: 'widget.chatmessagelist',
    cls: 'chat-messages',
    ignore_focus: true,
    //     
    /**
     * @property {String} storageId
     *       ""   
     */
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    initComponent: function() {
        var me = this;
        me.messageTplByType = {
            room: [
                '<span class="message-info">',
                '<span class="message-menu-icon"></span>',
                '<tpl if="x.time">',
                '<span class="time">{[ this.printTime(values.x.time) ]}</span>',
                '</tpl>',
                '{[ExGods.printUser({display_title: values.x.from_realuser, race: values.x.race, moder: values.x.moder}, {fields: ["name", "menuicon"] }) ]}',
                ': ',
                '</span>',
                '<span class="message-body">',
                '<span>{body:linkify}</span>',
                '</span>'
            ],
            to: [
                '<span class="message-info">',
                '<span class="message-menu-icon"></span>',
                '<tpl if="x.time">',
                '<span class="time">{[ this.printTime(values.x.time) ]}</span>',
                '</tpl>',
                '{[ExGods.printUser({display_title: values.x.from_realuser, race: values.x.race, moder: values.x.moder}, {fields: ["name", "menuicon"] }) ]}',
                '<img class="to-sign" height="11" src="' + IMAGE_URL + 'to_message.png" width="13" />',
                '<tpl for="Ext.JSON.decode(x.to)">',
                '{[ExGods.printUser({display_title: values, race: this.getRace(values, parent.x), moder: this.getModer(values, parent.x)}, {fields: ["name", "menuicon"] }) ]}',
                '<tpl if="xindex != xcount">, </tpl>',
                '</tpl>',
                ': ',
                '</span>',
                '<span class="message-body">',
                '<span>{body:linkify}</span>',
                '</span>'
            ],
            message: [
                '<tpl if="x.time">',
                '<span class="time">{[ this.printTime(values.x.time) ]}</span>',
                '</tpl>',
                '<span class="message-body">',
                '{body.body:linkify}',
                '</span>'
            ],
            'private': [
                '<span class="message-info">',
                '<span class="message-menu-icon"></span>',
                '<tpl if="x.time">',
                '<span class="time">{[ this.printTime(values.x.time) ]}</span>',
                '</tpl>',
                '{[ExGods.printUser({display_title: values.x.from_realuser, race: values.x.race, moder: values.x.moder}, {fields: ["name", "menuicon"] }) ]}',
                '<img class="private-sign" height="11" src="' + IMAGE_URL + 'private_message.png" width="13" />',
                '<tpl for="x.to_realuser.split(\',\')">',
                '{[ExGods.printUser({display_title: values, race: this.getRace(values, parent.x), moder: this.getModer(values, parent.x)}, {fields: ["name", "menuicon"] }) ]}',
                '<tpl if="xindex != xcount">, </tpl>',
                '</tpl>',
                ': ',
                '</span>',
                '<span class="message-body">',
                '<span>{body:linkify}</span>',
                '</span>'
            ],
            prize: ExGods.getMsgByKey('view_chat_you_get_reward')
        };
        Ext.Object.each(me.messageTplByType, function(key, tpl) {
            if (typeof tpl == 'object') {
                tpl.push({
                    printTime: function(time) {
                        return time.substr(0, 5);
                    },
                    getRace: function(nick, data) {
                        if (data.users_info && data.users_info[nick]) {
                            return data.users_info[nick].race || 0;
                        } else {
                            return 0;
                        }
                    },
                    getModer: function(nick, data) {
                        if (data.users_info && data.users_info[nick]) {
                            return data.users_info[nick].moder || 0;
                        } else {
                            return 0;
                        }
                    }
                });
            }
        });
        me.callParent(arguments);
    },
    // @private
    onAfterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.listEl.on('click', me.onMessageClick, me, {
            delegate: 'li.message'
        });
    },
    // me.listEl.on('mouseover', me.onMessageMouseOver, me, {delegate: 'li.message'});
    // me.listEl.on('mouseout', me.onMessageMouseOut, me, {delegate: 'li.message'});
    // addMessage: function(msg) {
    // },
    /**
     * @private
     *    ,     
     *  
     */
    onMessageClick: function(e, t) {
        var me = this,
            nickEl = Ext.get(e.getTarget('.name')),
            item = Ext.get(e.getTarget('.item')),
            message = Ext.get(e.getTarget('.message')),
            messageMenuEl = Ext.get(e.getTarget('.message-menu-icon')),
            userMenuEl = Ext.get(e.getTarget('.menu-icon')),
            msgData = me.data.get(message.id),
            nick, type;
        if (nickEl) {
            nick = nickEl.dom.innerText || nickEl.dom.textContent;
            if (message.hasCls('message-to') || message.hasCls('message-room'))  {
                type = 'to';
            }
            
            if (message.hasCls('message-private'))  {
                type = 'private';
            }
            
            /**
             * @event userclick
             *       
             * @param {Ext.Component} this
             */
            me.fireEvent('user-click', me.getUserInfoFromMessage(nick, msgData), type);
        }
        if (item) {
            if (msgData) {
                var itemProtoId;
                if (!item.getAttribute('data-proto_id')) {
                    if (msgData.body.body && msgData.body.body.stuff && !Ext.isArray(msgData.body.body.stuff)) {
                        itemProtoId = msgData.body.body.stuff.params.id;
                    } else if (msgData.body.data && msgData.body.data.stuff && !Ext.isArray(msgData.body.data.stuff)) {
                        itemProtoId = msgData.body.data.stuff.params.id;
                    }
                }
                if (itemProtoId) {
                    /**
                     * @event itemclick
                     *       
                     * @param {String} itemProtoId  
                     */
                    ExGods.app.fireEvent('itemclick', {
                        itemEl: item,
                        proto_id: itemProtoId
                    });
                }
            }
        }
        if (messageMenuEl) {
            me.fireEvent('message-menu-click', messageMenuEl, msgData);
        }
        if (userMenuEl) {
            var nick = userMenuEl.up('.userinfo').getAttribute('data-uname');
            me.fireEvent('user-menu-click', userMenuEl, me.getUserInfoFromMessage(nick, msgData));
        }
    },
    /**
     * @private
     *     HTML 
     * 
     * @param {Object} data  .     :
     *    (     . ).  
     *    {@link ExGods.controller.Chat#onMessage}
     * @return {String} HTML  
     */
    parseMessage: function(data) {
        var me = this,
            html = '<li class="message message-empty"></li>',
            type = data.type,
            msgId = data.id,
            xtpl,
            cls = [
                'message'
            ],
            isMessageWithMe = function(data) {
                var chat = ExGods.app.getController('Chat');
                return chat.isMyMessage(data) || chat.isMessageToMe(data);
            };
        if (data.x.moder) {
            cls.push('moder-message');
        }
        if (data.x.to) {
            type = 'to';
        }
        xtpl = me.messageTplByType[type];
        if (!xtpl && data.tpl) {
            xtpl = new Ext.XTemplate([
                '<span class="message-info">',
                '<tpl if="x && x.time">',
                '<span class="time">{[ this.printTime(values.x.time)]}</span>',
                '</tpl>',
                '</span>',
                '<span class="message-body">',
                data.tpl,
                '</span>',
                {
                    printTime: function(time) {
                        return time.substr(0, 5);
                    }
                }
            ]);
        }
        if (xtpl) {
            try {
                html = '<li id="' + msgId + '" class="' + cls.join(' ') + ' message-' + type + ' ' + (isMessageWithMe(data) ? 'message-my' : '') + '">' + me.prepareMessageText(xtpl, data) + '</li>';
            } catch (e) {}
        }
        //
        return html;
    },
    /**
     * @private
     *   
     */
    prepareMessageText: function(tpl, data) {
        var me = this,
            message;
        if (ExGods.app.getUser().get('moder') == 0 && typeof data.body == 'string') {
            data.body = ExGods.util.Helper.censoreText(data.body);
        }
        //  
        if (typeof tpl == 'object') {
            message = tpl.apply(data);
        } else {
            message = ExGods.app.applyTpl(tpl, data);
        }
        message = ExGods.util.Helper.processTextWithSmiles(message);
        return message;
    },
    getUserInfoFromMessage: function(nick, message) {
        var me = this;
        if (message.x && message.x.from_realuser == nick) {
            return {
                display_title: nick,
                race: message.x.race || 0,
                moder: message.x.moder || 0
            };
        } else if (message.x && message.x.users_info && message.x.users_info[nick]) {
            return {
                display_title: nick,
                race: message.x.users_info[nick].race || 0,
                moder: message.x.users_info[nick].moder || 0
            };
        } else {
            return {
                display_title: nick
            };
        }
    }
});
// onMessageMouseOver: function(e,t) {
//  var me = this,
//      el = Ext.get(t);
//  if (t == e.relatedTarget || Ext.fly(e.relatedTarget).parent('.message') == el) {
//      return;
//  }
//  if (me.mouseOverTimer) {                
//      clearTimeout(me.mouseOverTimer);
//  }
//  me.mouseOverTimer = setTimeout(function() {
//      el.addCls('selected');
//  }, ExGods.ref('constants|chat_messages_select_delay').value);
// },
// onMessageMouseOut: function(e,t) {
//  var me = this,
//      el = Ext.get(t);
//  if (t == e.relatedTarget || Ext.fly(e.relatedTarget).parent('.message') == el) {
//      return;
//  }
//  el.removeCls('selected');
//  clearTimeout(me.mouseOverTimer);
//  me.mouseOverTimer = null;       
// },

/**
 *      
 */
Ext.define('ExGods.view.chat.Tab', {
    extend: Ext.tab.Tab,
    alias: 'widget.chattab',
    ui: 'chat'
});

/**
 *    
 */
Ext.define('ExGods.view.chat.TabPanel', {
    extend: Ext.tab.Panel,
    alias: 'widget.chattabpanel',
    tabBar: {
        defaults: {
            height: 26,
            margin: 0,
            padding: '0 5'
        },
        height: 26
    },
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {
                xtype: 'chattab'
            };
        } else {
            Ext.applyIf(item.tabConfig, {
                xtype: 'chattab'
            });
        }
        me.callParent(arguments);
    }
});

/**
 *    
 */
Ext.define('ExGods.view.chat.InputField', {
    extend: Ext.container.Container,
    alias: 'widget.chatinputfield',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    ignore_focus: true,
    //     
    initComponent: function() {
        var me = this;
        me.message = me.emptyMessage();
        me.textField = Ext.widget('textfield', {
            itemId: 'textfield',
            emptyText: ExGods.getMsgByKey('view_chat_input_emptytext'),
            flex: 1,
            enforceMaxLength: true,
            maxLength: parseInt(ExGods.ref('constants|chat_message_max_length').value),
            padding: '0 0 0 0',
            disabled: me.disabled
        });
        me.items = [
            {
                xtype: 'dataview',
                itemId: 'nicks',
                data: {},
                itemSelector: 'li',
                maxWidth: 230,
                tpl: [
                    '<ul class="nick-list">',
                    '<tpl foreach="to">',
                    '<li data-index="{[ xindex -1 ]}" class="nick {parent.type}">',
                    '<div class="inner">',
                    '<span class="menu-icon"></span>',
                    '<span class="text">{.}</span>',
                    '<span class="close-icon"></span>',
                    '</div>',
                    '</li>',
                    '</tpl>',
                    '</ul>'
                ]
            },
            me.textField
        ];
        this.relayEvents(me.textField, [
            'specialkey'
        ]);
        // bubbling    
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent();
        me.getEl().on('click', function(e, el) {
            var index = Ext.get(el).parent('li').getAttribute("data-index");
            me.message.to.splice(index, 1);
            if (!me.message.to.length) {
                me.message.type = 'room';
            }
            me.updateNickList(me.message);
        }, me, {
            delegate: '.close-icon'
        });
        me.getEl().on('click', function(e, el) {
            var index = Ext.get(el).parent('li').getAttribute("data-index");
            me.fireEvent('user-menu-click', el, me.message.to[index]);
        }, me, {
            delegate: '.menu-icon'
        });
    },
    updateNickList: function(data) {
        var me = this,
            nicksDataView = me.getComponent('nicks'),
            listEl;
        nicksDataView.update(data);
        listEl = nicksDataView.getEl().down('.nick-list');
        //   ,    
        if (listEl.getWidth() >= 230) {
            listEl.setStyle('margin-left', (230 - listEl.getWidth()) + 'px');
        } else {
            listEl.setStyle('margin-left', 0);
        }
    },
    /**
     *   .
     * @param {Object} message     {type, content, to}
     */
    setMessage: function(message) {
        var me = this;
        if (!message) {
            message = me.emptyMessage();
        }
        me.message = message;
        me.updateNickList(message);
        me.setValue(message.content);
        setTimeout(function() {
            me.textField.focus();
        }, 0);
    },
    //   ,      ,   
    getMessage: function() {
        var me = this;
        me.message.content = me.textField.getValue();
        return this.message;
    },
    emptyMessage: function() {
        return {
            type: 'room',
            to: [],
            content: ''
        };
    },
    // 
    //     //
    //
    getValue: function() {
        var me = this;
        return me.textField.getValue();
    },
    setValue: function(value) {
        var me = this;
        return me.textField.setValue(value);
    },
    selectText: function(start, end) {
        var me = this;
        return me.textField.selectText(start, end);
    },
    disable: function() {
        var me = this;
        if (me.rendered) {
            me.textField.disable();
        }
        me.disabled = true;
    },
    enable: function() {
        var me = this;
        if (me.rendered) {
            me.textField.enable();
        }
        me.disabled = false;
    }
});

/**
 *      
 */
Ext.define('ExGods.view.chat.ContactsFilter', {
    extend: Ext.form.FieldContainer,
    alias: 'widget.contactsfilter',
    id: 'chat-contacts-filter',
    initComponent: function() {
        var me = this;
        Ext.apply(me, {
            layout: 'hbox',
            items: [
                {
                    xtype: 'textfield',
                    flex: 1,
                    enableKeyEvents: true,
                    margin: '0 0 0 0',
                    height: 22,
                    emptyText: ExGods.getMsgByKey('view_chat_contactfilter_emptytext')
                },
                {
                    xtype: 'button',
                    id: 'chat-search-button',
                    width: 22,
                    height: 22,
                    margin: '0 0 0 -11'
                }
            ]
        });
        me.callParent(arguments);
    }
});

/**
 *    
 */
Ext.define('ExGods.view.chat.Toolbar', {
    extend: Ext.toolbar.Toolbar,
    alias: 'widget.chattoolbar',
    id: 'chat-toolbar',
    defaults: {
        height: 22
    },
    height: 28,
    padding: '0 0 2 27',
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'chatinputfield',
                id: 'chat-text-field',
                disabled: true,
                height: 22,
                padding: '0 0 0 0',
                width: 480
            },
            {
                xtype: 'imagebutton',
                id: 'chat-send-button',
                action: 'send',
                margin: '0 0 0 -11',
                width: 22,
                tooltip: ExGods.getMsgByKey('view_chat_toolbar_send')
            },
            {
                xtype: 'imagebutton',
                id: 'chat-clear-button',
                action: 'clear',
                width: 22,
                margin: '0 0 0 6',
                tooltip: ExGods.getMsgByKey('view_chat_toolbar_clear')
            },
            {
                xtype: 'imagebutton',
                id: 'chat-togglesmiles-button',
                action: 'togglesmiles',
                width: 22,
                margin: '0 0 0 6',
                tooltip: ExGods.getMsgByKey('view_chat_toolbar_smiles')
            },
            {
                xtype: 'contactsfilter',
                width: 210,
                margin: '0 0 0 54'
            }
        ];
        me.callParent();
    }
});

/**
 *  
 */
Ext.define('ExGods.view.chat.ChatContainer', {
    extend: Ext.panel.Panel,
    alias: 'widget.chatcontainer',
    bodyPadding: '0 0 0 0',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    padding: '0 0 0 0',
    region: 'south',
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'component',
                width: 20,
                id: 'chat-separator-left',
                margin: '26 0 0 0'
            },
            {
                //    
                xtype: 'chattabpanel',
                id: 'chat-tab-panel',
                defaultType: 'chatmessagelist',
                flex: 1,
                bodyPadding: '4 0',
                margin: '0 -3 0 -3'
            },
            {
                xtype: 'component',
                width: 18,
                id: 'chat-separator-center',
                margin: '26 0 0 0'
            },
            {
                //  
                xtype: 'chattabpanel',
                id: 'contact-tab-panel',
                width: 263,
                items: [
                    {
                        xtype: 'chatcontactlist',
                        id: 'chat-contact-list',
                        store: ExGods.app.getStore('ChatContacts')
                    },
                    {
                        xtype: 'chatcontactlist',
                        id: 'guild-contact-list',
                        store: ExGods.app.getStore('GuildOnlineList')
                    },
                    {
                        xtype: 'chatcontactlist',
                        id: 'guild-group-list',
                        store: ExGods.app.getStore('GuildGroupOnlineList')
                    }
                ],
                bodyPadding: '4 0'
            },
            {
                xtype: 'component',
                width: 20,
                id: 'chat-separator-right',
                margin: '26 0 0 0'
            }
        ];
        me.bbar = {
            xtype: 'chattoolbar'
        };
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        //  
        Ext.DomHelper.insertFirst('chat-container-body', {
            id: 'chat-top-deco',
            tag: 'div'
        });
        //  
        Ext.DomHelper.append('chat-toolbar', {
            id: 'chat-bottom-deco',
            tag: 'div'
        });
        //  ""
        Ext.widget('button', {
            xtype: 'button',
            id: 'chat-expand-btn',
            renderTo: 'chat-container-body',
            cls: 'chat-header-btn',
            x: 766,
            y: 2,
            floating: true,
            shadow: false,
            width: 26,
            height: 24,
            tooltip: ExGods.getMsgByKey('view_chat_container_fullchattt')
        });
        //  " "
        Ext.widget('button', {
            xtype: 'button',
            id: 'chat-question-btn',
            renderTo: 'chat-container-body',
            cls: 'chat-header-btn',
            x: 794,
            y: 2,
            floating: true,
            shadow: false,
            width: 26,
            height: 24,
            tooltip: ExGods.getMsgByKey('view_chat_container_questionchattt')
        });
        //  " "
        Ext.widget('button', {
            xtype: 'button',
            id: 'chat-off-btn',
            renderTo: 'chat-container-body',
            cls: 'chat-header-btn',
            x: 822,
            y: 2,
            floating: true,
            shadow: false,
            width: 26,
            height: 24,
            tooltip: ExGods.getMsgByKey('view_chat_container_hidechattt')
        });
    },
    scrollChatToBottom: function() {
        var me = this,
            tabPanel = me.rendered ? Ext.getCmp('chat-tab-panel') : null,
            tab;
        if (tabPanel) {
            tab = tabPanel.getActiveTab();
            if (tab) {
                tab.scroller.onResize();
                tab.scroller.scrollToBottom();
            }
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.chat.ChatOffPanel', {
    extend: Ext.panel.Panel,
    alias: 'widget.chatoffpanel',
    height: 56,
    padding: '0 32 0 32',
    layout: {
        type: 'hbox',
        align: 'middle',
        pack: 'center'
    },
    initComponent: function() {
        var me = this;
        me.btn = Ext.widget('textbutton', {
            width: 175,
            cls: 'double_text_btn',
            text: '<div class="text-btn-image" style="background-image: url(' + ExGods.ref('images|chat_images').image['message_btn_text'] + ')"></div>',
            listeners: {
                afterrender: function() {
                    me.resetCounter();
                }
            }
        });
        me.items = [
            me.btn
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        //  " c"
        Ext.widget('button', {
            xtype: 'button',
            id: 'chat-question-big-btn',
            renderTo: 'chat-off-panel',
            x: 807,
            y: 7,
            floating: true,
            shadow: false,
            width: 40,
            height: 40,
            tooltip: ExGods.getMsgByKey('view_chat_container_questionchattt')
        });
    },
    //     
    resetCounter: function() {
        var me = this;
        me.counter = 0;
        me.updateCounter();
    },
    //     
    incCounter: function() {
        var me = this;
        me.counter++;
        me.updateCounter();
    },
    //     
    updateCounter: function() {
        var me = this,
            el;
        el = me.btn.el.down('.text-btn-image');
        el.dom.innerHTML = '<div>' + ExGods.util.Sprite.printSprite(me.counter, 'chat/counter_nums.png', {
            width: 10,
            height: 21,
            horizontal: true,
            lastZero: true
        });
    }
});

/**
 * Mixin,    
 *
 * @author Max Dvortsov
 */
Ext.define('ExGods.mixin.ItemDraggable', {
    /**
     * config -      DragZone
     * config.view - ,    
     * config.cancelFn {Function} - ,        
     * config.getItem {Function} (view,sourceEl)   ,      .
     *         ,  
     * config.getSourceEl {Function} (event,view)   ,  Ext.dom.Element   
     *             itemSelector,    view.el
     * config.getItemEl {Function} (sourceEl)   Ext.dom.Element,   ,  Ext.dom.Element,
     *         .     
     */
    initDrag: function(config) {
        config = config || {};
        var me = this,
            view = config.view || me,
            cancelFn = config.cancelFn || Ext.emptyFn;
        delete config.view;
        delete config.cancelFn;
        me.dragZone = new Ext.dd.DragZone(view.getEl(), Ext.apply({
            animRepair: false,
            ddGroup: 'all',
            getDragData: function(e) {
                var sourceEl = this.getSourceEl(e, view);
                if (sourceEl && sourceEl.dom.firstChild) {
                    var d = sourceEl.dom.firstChild.cloneNode(true),
                        d_el = Ext.fly(d),
                        item = this.getItem(view, sourceEl),
                        slot = view.slot;
                    if (!item)  {
                        return false;
                    }
                    
                    if (ExGods.app.user.isBattle())  {
                        return false;
                    }
                    
                    if (!slot) {
                        slot = ExGods.app.user.slots().getById(item.get('slot_id'));
                    }
                    d.id = Ext.id();
                    d_el.setSize(sourceEl.getSize());
                    //     , ..      
                    if (d_el.hasCls('qh-object')) {
                        d_el.removeCls('qh-object');
                    }
                    if (d_el.down('.qh-object')) {
                        d_el.down('.qh-object').removeCls('qh-object');
                    }
                    if (d.querySelector('.qh-pointer')) {
                        d.querySelector('.qh-pointer').remove();
                    }
                    //   
                    if (d.querySelector('.exg-timer')) {
                        d.querySelector('.exg-timer').remove();
                    }
                    return {
                        ddel: d,
                        item: item,
                        slot: slot,
                        itemEl: this.getItemEl(sourceEl),
                        cancel: function() {
                            sourceEl.setStyle('opacity', '');
                            cancelFn();
                        }
                    };
                }
            },
            getItem: function(view, sourceEl) {
                return view.getRecord(sourceEl);
            },
            getSourceEl: function(e, view) {
                return view.itemSelector ? Ext.get(e.getTarget(view.itemSelector)) : view.el;
            },
            getItemEl: function(sourceEl) {
                return sourceEl;
            },
            getView: function() {
                return view;
            },
            onStartDrag: function() {
                var dragData = this.dragData,
                    sourceEl = Ext.fly(dragData.itemEl),
                    quantityEl = sourceEl.down('.exg-stuff-decorator-quantity-counter');
                sourceEl.setStyle('opacity', 0.5);
                if (sourceEl.down('.qh-pointer'))  {
                    sourceEl.down('.qh-pointer').hide();
                }
                
                if (quantityEl && quantityEl.isVisible()) {
                    dragData.isCounter = true;
                    quantityEl.hide();
                }
                me.fireEvent('startdrag', dragData);
            },
            beforeInvalidDrop: function(e) {
                var dragData = this.dragData,
                    sourceEl = Ext.fly(dragData.itemEl);
                sourceEl.setStyle('opacity', '');
                if (sourceEl.down('.qh-pointer')) {
                    sourceEl.down('.qh-pointer').show();
                }
                if (dragData.isCounter) {
                    sourceEl.down('.exg-stuff-decorator-quantity-counter').show();
                }
                me.fireEvent('stopdrag', dragData);
            },
            setDelta: function(iDeltaX, iDeltaY) {
                this.deltaX = 32;
                this.deltaY = 32;
            }
        }, config));
        me.on('destroy', function() {
            me.dragZone.destroy();
            me.dragZone = null;
        }, me);
    }
});

/**
 * Mixin,    
 *
 * @author Max Dvortsov
 */
Ext.define('ExGods.mixin.ItemDroppable', {
    /**
     * config -      DragZone
     * config.view - ,    
     */
    initDrop: function(config) {
        config = config || {};
        var me = this,
            view = config.view || me;
        delete config.view;
        me.dropZone = new Ext.dd.DropZone(view.getEl(), Ext.apply({
            ddGroup: 'all',
            getTargetFromEvent: function(e) {
                return e.getTarget();
            },
            getView: function() {
                return view;
            },
            onNodeDrop: function(target, dd, e, data) {
                var sourceEl = Ext.fly(data.itemEl),
                    counter = sourceEl.down('.exg-stuff-decorator-quantity-counter');
                if (sourceEl.down('.qh-pointer')) {
                    sourceEl.down('.qh-pointer').show();
                }
                if (counter && counter.dom.innerHTML) {
                    counter.show();
                }
                me.fireEvent('drop', target, data);
                return this.onDrop(target, dd, e, data);
            },
            onDrop: function(target, dd, e, data) {
                return true;
            }
        }, config));
        me.on('destroy', function() {
            me.dropZone.destroy();
            me.dropZone = null;
        }, me);
    }
});

/**
 * Mixin,         
 *
 * @author Max Dvortsov
 */
Ext.define('ExGods.mixin.InventoryDragHighlight', {
    initDragHighlight: function() {
        this.on({
            startdrag: this.onStartDrag,
            stopdrag: this.onStopDrag,
            drop: this.onItemDrop,
            destroy: function() {
                this.un({
                    startdrag: this.onStartDrag,
                    stopdrag: this.onStopDrag,
                    drop: this.onItemDrop,
                    scope: this
                });
            },
            scope: this
        });
    },
    onStartDrag: function(data) {
        var proto = ExGods.app.getItemPrototypesStore().data.getByKey(data.item.get('proto_id')),
            active = data.slot ? data.slot.getSlotType().active : true,
            potion = data.slot && data.slot.get('type') == 14;
        if (data.item.get('proto_id')) {
            var type = data.item.getType().slot_on;
            ExGods.app.user.slots().each(function(slot) {
                if ((active && !slot.getSlotType().active) || (!active && slot.get('type') == type) || (potion && slot.get('type') == 14)) //    ,     
                {
                    slot.fireEvent('highlight', slot);
                }
            });
            if (!active && proto.canPutInWareHouse()) {
                ExGods.app.getStore('WareHouse').fireEvent('highlight', data.item);
            }
        }
    },
    onStopDrag: function(data) {
        ExGods.app.user.slots().each(function(slot) {
            slot.fireEvent('unhighlight', slot);
        });
        ExGods.app.getStore('WareHouse').fireEvent('unhighlight', data.item);
        ExGods.app.getController('Item').afterDrop = true;
    },
    onItemDrop: function(target, data) {
        ExGods.app.user.slots().each(function(slot) {
            slot.fireEvent('unhighlight', slot);
        });
        ExGods.app.getStore('WareHouse').fireEvent('unhighlight', data.item);
    }
});

/**
 *   
 */
Ext.define('ExGods.model.Action', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    statics: {
        //   "  -"
        ONLINE_LIST_TARGET: 1,
        //   " "
        STRING: 2,
        //   ""
        ITEM_TARGET: 3,
        //   "  black-"
        BLACK_LIST_USER_TARGET: 4,
        //   ""
        USER_TARGET: 5,
        //   " "
        CONTEXT_TARGET: 6,
        //   "   "
        ITEM_FILTER_TARGET: 7,
        //   "  "
        ITEM_UPGRADED_TARGET: 8
    },
    fields: [
        {
            // id 
            name: 'condition_action',
            type: 'int'
        },
        {
            // id 
            name: 'entry',
            type: 'int'
        },
        {
            name: 'confirm',
            type: 'auto'
        },
        {
            //  
            name: 'type',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            //  ,      
            // 0 -  ;  
            // 1 -  
            // 3 -  
            name: 'target',
            type: 'int'
        },
        {
            //   .
            name: 'selected_target',
            type: 'auto'
        },
        {
            //   - ,    . , 
            name: 'source',
            type: 'auto'
        },
        {
            //       ( ExGods.util.Stuff.printStuff)
            name: 'costs',
            type: 'auto'
        },
        {
            //  
            name: 'params',
            type: 'auto'
        },
        {
            //  
            name: 'target_params',
            type: 'auto'
        },
        {
            // ,       .      
            name: 'side',
            type: 'int'
        },
        {
            //     
            name: 'dead',
            type: 'int'
        },
        {
            //  
            name: 'hints',
            type: 'auto'
        },
        {
            //  ,   .
            name: 'service_id',
            type: 'string'
        }
    ],
    /**
     *  true,   
     */
    isBattleAction: function() {
        return this.get('type') == 'battle';
    },
    isInventoryAction: function() {
        return this.get('type') == 'map.inventory';
    },
    isLocationAction: function() {
        return this.get('type') == 'map.location';
    },
    isServiceAction: function() {
        return this.get('service_id');
    },
    /**
     *  true,    
     */
    hasConfirmation: function() {
        return this.get('hints') && this.get('hints').length;
    },
    /**
     *  true,   
     */
    hasCost: function() {
        return this.get('costs') && this.get('costs').length;
    },
    proxy: 'memory'
});

/**
 * ""  
 */
Ext.define('ExGods.view.QuickSlots', {
    extend: Ext.view.View,
    alias: 'widget.quickslots',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.InventoryDragHighlight
    ],
    id: 'quick-slots',
    deferEmptyText: false,
    itemSelector: '.exg-stuff-item-quick_slot',
    ignore_focus: true,
    //     
    /**
     * @property {Ext.data.Store} store
     *   
     */
    initComponent: function() {
        var me = this;
        me.store = Ext.StoreMgr.lookup('quick-slots');
        me.tpl = [
            '<div class="top">',
            '<span>' + ExGods.getMsgByKey('view_quick_belt') + '</span>',
            '</div>',
            '<tpl for=".">',
            '<tpl if="item">',
            '{[ExGods.stuff.StuffManager.image(values.item)]}',
            '<tpl else>',
            '<div class="exg-stuff-item-quick_slot empty-quick-slot exgtip" data-exgtip_type="slot" data-exgtip_value="{ekey}" style="background-image: {[this.getEmptyBg(values)]}"></div>',
            '</tpl>',
            '</tpl>',
            '{[this.fillBuySlots(values)]}',
            '<div class="bottom"></div>',
            {
                getEmptyBg: function(values) {
                    if (values.protect) {
                        return 'url(' + IMAGE_URL + 'slots/new/frm.png), ' + 'url(' + ExGods.ref('slot_type|' + values.type).images.prot + ')';
                    } else {
                        return 'url(' + ExGods.ref('slot_type|' + values.type).images.empty + ')';
                    }
                },
                fillBuySlots: function() {
                    var buySlots = ExGods.app.getController('inventory.Inventory').service.data.next_buy_slot[14],
                        html = [];
                    if (buySlots) {
                        var i = buySlots.max - me.store.getCount();
                        while (i--) {
                            html.push('<div class="quick-slot-sale">', '<div data-qtip="' + ExGods.getMsgByKey('view_quickslots_buyslottt') + '" class="dummy"></div>', '</div>');
                        }
                    }
                    return html.join('');
                }
            }
        ];
        me.callParent();
        me.store.each(function(slot) {
            slot.on({
                highlight: me.highlight.bind(me, slot, true),
                unhighlight: me.highlight.bind(me, slot, false),
                scope: me
            });
        });
        me.on('refresh', function() {
            if (me.isDisabled()) {
                me.el.mask();
            }
        });
        me.getSelectionModel().preventFocus = true;
    },
    //  Ext  body
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.initDD();
        me.el.on('click', function(e, el) {
            var service = ExGods.app.getController('inventory.Inventory').service,
                text = new Ext.XTemplate(ExGods.ref('message_client|buy_slot_confirm')).apply({
                    cost: ExGods.util.Stuff.printStuff(service.data.next_buy_slot[14].price)
                });
            Ext.widget('confirmdialog', {
                message: text,
                handler: function() {
                    ExGods.Services.get('inventory').command('buy_slot', {
                        slot_type: 14
                    });
                }
            });
        }, me, {
            delegate: '.quick-slot-sale'
        });
    },
    collectData: function(slots) {
        return Ext.Array.map(slots, function(slot) {
            data = Ext.clone(slot.data);
            var item = slot.items().data.items[0];
            if (item) {
                data.item = {
                    type: 'quick_slot',
                    params: {
                        slot: slot,
                        itemModel: item
                    }
                };
            }
            return data;
        });
    },
    highlight: function(slot, lightOn) {
        var me = this,
            node = me.getNode(slot),
            nodes = [],
            i = node.childNodes.length,
            classes, index;
        if (i) {
            while (i--) {
                if (node.childNodes[i].className.indexOf('slot-protect') != -1 || node.childNodes[i].className.indexOf('exg-stuff-img') != -1) {
                    node = node.childNodes[i];
                    break;
                }
            }
        }
        classes = node.className.split(' ');
        index = classes.indexOf('exg-highlighted');
        if (lightOn) {
            if (index == -1) {
                classes.push('exg-highlighted');
                node.className = classes.join(' ');
            }
        } else if (index != -1) {
            classes.splice(index, 1);
            node.className = classes.join(' ');
        }
    },
    /**
     * @private
     *  Drag&Drop
     */
    initDD: function() {
        var me = this;
        me.initDrag({
            getItem: function(view, sourceEl) {
                return view.getRecord(sourceEl).items().first();
            }
        });
        me.initDrop({
            onDrop: function(target, dd, e, data) {
                if (Ext.getClassName(data.item) != 'ExGodsCore.model.Item')  {
                    return false;
                }
                
                var type = data.item.getType().slot_on,
                    targetSlot = me.getRecord(target) || me.getRecord(target.parentNode),
                    isValid = false,
                    fn = function() {
                        ExGods.app.getController('Item').putOn(data.item, data.cancel, targetSlot);
                        return true;
                    };
                if (!targetSlot)  {
                    return false;
                }
                
                if (data.itemEl && data.itemEl.setStyle)  {
                    data.itemEl.setStyle('opacity', '');
                }
                
                me.store.each(function(slot) {
                    if (slot.get('type') == type) {
                        isValid = true;
                    }
                });
                if (!isValid)  {
                    return false;
                }
                
                var target_item = targetSlot.items().first();
                if (!target_item)  {
                    return fn();
                }
                
                var item_proto_id = data.item.get('proto_id'),
                    target_proto_id = target_item.get('proto_id'),
                    target_stack = ExGods.ref('slot_type|' + type).stack,
                    item_proto = ExGods.app.getItemPrototypesStore().data.getByKey(item_proto_id),
                    item_stack = item_proto.get('data').stack,
                    target_items_count = target_item.get('count');
                if (item_proto_id == target_proto_id && (!item_stack || !target_stack || Math.floor(target_stack / item_stack) == target_items_count)) {
                    return false;
                }
                return fn();
            }
        });
        me.initDragHighlight();
    },
    setDisabled: function(disabled) {
        var me = this;
        if (me.f_disabled !== disabled) {
            me.f_disabled = disabled;
            if (disabled) {
                me.getEl().mask();
            } else {
                me.getEl().unmask();
            }
        }
    },
    isDisabled: function() {
        return this.f_disabled;
    },
    applyMarks: function(actions, items) {
        var me = this,
            slots = [],
            time = parseInt(ExGods.ref('constants|bat_anim_pointer_speed').value) + 50;
        Ext.Array.each(actions, function(action_id) {
            me.store.each(function(slot) {
                var item = slot.get('items').getAt(0);
                if (!item)  {
                    return;
                }
                
                var proto_id = item.get('proto_id'),
                    proto = ExGods.app.getItemPrototypesStore().getById(proto_id);
                if (proto) {
                    Ext.each(proto.get('action'), function(action) {
                        if (action.value.action == action_id) {
                            slots.push(slot);
                        }
                    });
                }
            });
        });
        Ext.Array.each(items, function(item_id) {
            me.store.each(function(slot) {
                var item = slot.get('items').getAt(0);
                if (!item)  {
                    return;
                }
                
                var proto_id = item.get('proto_id'),
                    proto = ExGods.app.getItemPrototypesStore().getById(proto_id);
                if (proto && proto.get('entry') == item_id) {
                    slots.push(slot);
                }
            });
        });
        if (me.marksInterval)  {
            clearInterval(me.marksInterval);
        }
        
        if (slots.length) {
            me.marksInterval = setInterval(function() {
                if (me.isDisabled()) {
                    clearInterval(me.marksInterval);
                } else {
                    me.showPointer(slots[0]);
                }
            }, time);
        }
    },
    /**
     *      
     */
    showPointer: function(slot) {
        var me = this,
            node = me.getNodeByRecord(slot),
            turn = Ext.get(node),
            container = me.up('#viewport'),
            style = [
                'left:' + (turn.getX() - container.getX() + 1) + 'px',
                'top:' + (turn.getY() - container.getY() + 1) + 'px'
            ].join(';'),
            html = [
                '<div class="finger" style="' + style + '">',
                '<div class="finger-image"></div>',
                '<div class="finger-text"></div>',
                '</div>'
            ].join(''),
            animEl = container.el.insertHtml('beforeEnd', html, true),
            img = animEl.down('.finger-image').dom,
            text = animEl.down('.finger-text').dom,
            cycles = ExGods.ref('constants|bat_anim_pointer_cycles').value,
            time_text_shown = ExGods.ref('constants|bat_anim_pointer_text_hidden').value,
            time_text_hidden = ExGods.ref('constants|bat_anim_pointer_text_shown').value,
            time = ExGods.ref('constants|bat_anim_pointer_speed').value,
            deltaOpacity = (time / (time - time_text_hidden - time_text_shown)).toFixed(2),
            startOpacity = (deltaOpacity * (time - time_text_hidden) / time).toFixed(2),
            i = maxI = 50 * cycles,
            showing = true,
            deltaX = 10,
            deltaY = 5,
            timestamp;
        animEl.on('click', function(e, el) {
            node.click();
        });
        (function() {
            // 
            text.style.opacity = startOpacity - Math.abs((i - maxI / (2)) / (maxI / (2))) * deltaOpacity;
            // 
            img.style.left = (24 + Math.abs(deltaX * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            img.style.top = (-18 - Math.abs(deltaY * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            // 
            if (i % (maxI / cycles) == maxI / (2 * cycles))  {
                ExGods.helpme.shine(animEl, 'finger-sprite', 34, -62, 25);
            }
            
            if (i > 0) {
                i--;
                var curTime = new Date().getTime();
                if (!me.is_shown_pointer && !timestamp) {
                    timestamp = curTime + time / maxI * i + 100;
                }
                if (timestamp && curTime > timestamp) {
                    animEl.remove();
                    return;
                }
                setTimeout(arguments.callee, time / maxI);
            } else {
                i = maxI;
                if (me.is_shown_pointer) {
                    setTimeout(arguments.callee, time / maxI);
                } else {
                    animEl.remove();
                }
            }
        })();
    },
    getResources: function() {
        var me = this,
            images = [
                'slots/new/frm.png'
            ];
        me.store.each(function(item) {
            if (item.data.proto && item.data.proto.images) {
                for (var key in item.data.proto.images) {
                    images.push(item.data.proto.images[key]);
                }
            }
            if (item.data.item && item.data.item.proto && item.data.item.proto.images) {
                for (var key in item.data.item.proto.images) {
                    images.push(item.data.item.proto.images[key]);
                }
            }
        });
        return {
            images: images
        };
    }
});

/**
 *   
 *
 *       
 */
Ext.define('ExGods.view.menu.MainMenuButton', {
    extend: Ext.button.Button,
    alias: 'widget.mainmenubutton',
    border: 0,
    cls: Ext.baseCSSPrefix + 'mainmenu-btn',
    /**
     * @cfg {Number} counter 
     *   
     */
    counter: 0,
    /**
     * @cfg {String} menuId  ,    
     */
    menuId: '',
    /**
     * @cfg {String} conditionMessage    -         
     */
    conditionMessage: '',
    disabledByController: false,
    height: 60,
    width: 60,
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        //      -   "menu"
        me.el.addCls('qh-object');
        me.el.set({
            'data-qh_otype': 'menu',
            'data-qh_oid': me.menuId
        });
        me.counterEl = me.btnEl.insertHtml('beforeEnd', '<div class="damaged-counter"></div>', true);
        //      me.counterEl.setStyle({
        //          backgroundImage: 'url(' + ExGods.references.get('images').get('new_icon').image.new_icon + ')'
        //      });
        me.counterEl.setVisibilityMode(Ext.Element.DISPLAY);
        me.counterEl[me.counter ? 'show' : 'hide']();
        if (me.conditionMessage) {
            me.el.addCls('x-btn-blocked');
        }
    },
    //    
    //me.btnEl.insertHtml('beforeEnd', '<div class="condition-text">'+ me.conditionMessage +'</div>', true);
    //     
    //      if(me.menuId == 'inventory'){
    //          //var damaged = ExGods.app.getUser().getCriticallyDamagedEquippedItems();
    //          var damaged = me.counter;
    //          me.btnEl.insertHtml('beforeEnd', '<div class="damaged-counter" style="display:'+(damaged ? 'block' : 'none')+'">' + damaged + '</div>');
    //      }
    /**
     *    
     * @param {Number} value ,    
     */
    addCount: function(value) {
        var me = this;
        me.counter += parseInt(value);
        if (me.menuId == 'combos-and-features')  {
            me.counterEl.setHTML('!');
        }
        else {
            me.counterEl.setHTML(me.counter);
        }
        me.counterEl[me.counter ? 'show' : 'hide']();
        if (me.menuId == 'quests')  {
            me.drawLocationCount();
        }
        
    },
    //      if(value) {
    //          me.fireEvent('addcount', me);
    //      }
    /**
     *      
     */
    reset: function() {
        var me = this;
        if (me.counter) {
            me.counter = 0;
            me.counterEl.hide();
        }
    },
    drawLocationCount: function(redraw) {
        var me = this;
        if (me.menuId == 'quests') {
            if (Ext.get('LOB_QUEST_BUTTON')) {
                if (redraw) {
                    me.loctionEl = undefined;
                    delete me.loctionEl;
                }
                if (!me.loctionEl) {
                    me.loctionEl = Ext.get('LOB_QUEST_BUTTON').insertHtml('beforeEnd', '<div class="damaged-counter">' + me.counter + '</div>', true);
                    me.loctionEl.setVisibilityMode(Ext.Element.DISPLAY);
                    me.loctionEl.setStyle({
                        right: '-2px',
                        top: '-2px',
                        'z-index': 3
                    });
                } else {
                    me.loctionEl.setHTML(me.counter);
                }
            }
        }
        if (me.loctionEl && me.loctionEl.dom) {
            me.loctionEl[me.counter ? 'show' : 'hide']();
        }
    }
});

/**
 *  
 *
 *  .
 */
Ext.define('ExGods.view.menu.MainMenu', {
    extend: Ext.panel.Panel,
    alias: 'widget.mainmenu',
    id: 'mainmenu',
    /**
     * @property {Ext.panel.Panel} btnCnt
     *    
     */
    layout: {
        type: 'vbox',
        align: 'center'
    },
    /**
     * @cfg {Object}    
     * 
     */
    menuConfig: {},
    /**
     * @property {Ext.button.Button} toggle
     *  / 
     */
    width: 70,
    bodyPadding: '0 0 0 8',
    defaultType: 'mainmenubutton',
    maskOnDisable: false,
    initComponent: function() {
        var me = this;
        me.items = me.prepareMenuButtons();
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: ExGods.getMsgByKey('menu_title'),
                cls: 'main-menu-title'
            }
        ];
        me.callParent();
    },
    /**
     * @private
     */
    prepareMenuButtons: function() {
        var me = this,
            buttons = [],
            styleSheet = [],
            menuConfig = Ext.Array.sort(me.menuConfig, function(a, b) {
                var pos1 = parseInt(a.position);
                var pos2 = parseInt(b.position);
                if (pos1 > pos2) {
                    return 1;
                } else if (pos1 < pos2) {
                    return -1;
                } else {
                    return 0;
                }
            });
        Ext.Array.each(menuConfig, function(item) {
            buttons.push({
                id: item.id_menu + '-' + item.id_element + '-button',
                menuId: item.id_element,
                //tooltip: item.label,
                disabled: item.message ? true : false,
                conditionMessage: item.message,
                menuConfig: item,
                action: item.params.id,
                href: item.type == 'link' ? item.params.advanced_param.link : undefined,
                hrefTarget: item.type == 'link' ? item.params.advanced_param.target : undefined,
                listeners: {
                    render: function(panel) {
                        this.tooltip = Ext.create('Ext.tip.ToolTip', {
                            target: panel.el,
                            anchor: Ext.getBody().getWidth() < 1400 ? 'right' : undefined,
                            anchorOffset: 20,
                            maxWidth: parseInt(ExGods.ref('constants|tooltip_max_width').value),
                            cls: 'paperdeco-tooltip',
                            plugins: [
                                'paperdeco'
                            ],
                            html: '<div class="paper-title ellipsis">' + item.label + '</div>' + '<div class="tooltip-paper-body">' + item.description + '</div>'
                        });
                    }
                }
            });
            styleSheet.push([
                '#' + item.id_menu + '-' + item.id_element + '-button {',
                'background-image: url(' + IMAGE_URL + item.images.image + ');',
                'background-position:' + item.images.offset + 'px 0;',
                '}',
                '#' + item.id_menu + '-' + item.id_element + '-button.x-btn-over {',
                'background-position:' + item.images.offset + 'px -60px;',
                '}',
                '#' + item.id_menu + '-' + item.id_element + '-button.x-btn-pressed {',
                'background-position:' + item.images.offset + 'px -120px;',
                '}',
                '#' + item.id_menu + '-' + item.id_element + '-button.x-btn-disabled {',
                'background-position:' + item.images.offset + 'px -180px;',
                'cursor: default;',
                '}',
                '#' + item.id_menu + '-' + item.id_element + '-button.x-btn-blocked {',
                'background-position:' + item.images.offset + 'px -240px;',
                'cursor: default;',
                '}'
            ].join(''));
        });
        Ext.util.CSS.createStyleSheet(styleSheet.join(''));
        return buttons;
    },
    /**
     *  ( )  
     * @param {Array} exceptItems  id  ,    
     */
    disableMenu: function(exceptItems) {
        var me = this;
        exceptItems = exceptItems || [];
        me.items.each(function(item) {
            if (Ext.Array.indexOf(exceptItems, item.menuConfig.id_element) == -1) {
                item.disable();
            } else {
                item.enable();
            }
        });
    },
    /**
     *   
     */
    enableMenu: function() {
        var me = this;
        me.items.each(function(item) {
            if (!item.disabledByController)  {
                item.enable();
            }
            
        });
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            images = [];
        Ext.Array.each(me.menuConfig, function(item) {
            if (item.images.image && Ext.Array.indexOf(images, item.images.image) === -1) {
                images.push(item.images.image);
            }
        });
        return {
            images: images
        };
    },
    updateMenu: function(menuConfig) {
        var me = this;
        me.menuConfig = menuConfig;
        me.removeAll();
        me.add(me.prepareMenuButtons());
    }
});

/**
 *   
 */
Ext.define('ExGods.view.menu.SystemMenu', {
    extend: Ext.toolbar.Toolbar,
    alias: 'widget.systemmenu',
    padding: 0,
    /**
     * @cfg {Object} menuConfig  
     */
    menuConfig: {},
    initComponent: function() {
        var me = this,
            items = [],
            styleSheet = [],
            menuConfig = Ext.Array.sort(me.menuConfig, function(a, b) {
                var pos1 = parseInt(a.position);
                var pos2 = parseInt(b.position);
                if (pos1 > pos2) {
                    return 1;
                } else if (pos1 < pos2) {
                    return -1;
                } else {
                    return 0;
                }
            });
        me.layout = {
            pack: 'start'
        };
        me.defaults = {
            height: 30,
            padding: 0
        };
        Ext.Array.each(menuConfig, function(item) {
            var itemId = Ext.id(),
                action = ExGods.ClientActions.factory({
                    actionId: item.params.id,
                    src: 'menu'
                });
            items.push({
                id: itemId,
                href: action.href,
                hrefTarget: action.hrefTarget,
                disabled: item.message ? true : false,
                action: action,
                text: !item.images.image ? item.label : undefined,
                width: item.images.width
            });
            if (item.images.image) {
                styleSheet.push([
                    '#' + itemId + ' {',
                    'background-image: url(' + IMAGE_URL + item.images.image + ');',
                    'background-position:' + item.images.offset + 'px 0;',
                    '}',
                    '#' + itemId + ':hover {',
                    'background-position:' + item.images.offset + 'px -30px;',
                    '}',
                    '#' + itemId + '.x-btn-pressed {',
                    'background-position:' + item.images.offset + 'px -60px;',
                    '}',
                    '#' + itemId + '.x-btn-disabled {',
                    'background-position:' + item.images.offset + 'px -90px;',
                    '}'
                ].join(''));
            }
        });
        Ext.util.CSS.createStyleSheet(styleSheet.join(''));
        me.items = items;
        me.callParent();
    },
    getResources: function() {
        var me = this,
            images = [];
        Ext.Array.each(me.menuConfig, function(item) {
            if (item.images.image && Ext.Array.indexOf(images, item.images.image) === -1) {
                images.push(item.images.image);
            }
        });
        return {
            images: images
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.menu.ToolsMenuButton', {
    extend: Ext.button.Button,
    alias: 'widget.toolsmenubutton',
    /**
     * @cfg buttonData {Object}    
     */
    initComponent: function() {
        var me = this,
            styleSheet = [];
        var itemId = Ext.id();
        Ext.apply(me, {
            id: itemId,
            cls: "qh-object " + me.buttonData.id_element + '-button ' + me.id_cls_uniq ? me.id_cls_uniq : '',
            action: me.buttonData.id_element,
            text: !me.buttonData.images.image ? me.buttonData.label : undefined,
            width: me.buttonData.images.width,
            tooltip: me.buttonData.label || '',
            listeners: {
                afterrender: function(btn) {
                    var el = btn.getEl();
                    el.dom.setAttribute("data-qh_otype", "tools_menu_" + me.buttonData.id_element + '_button');
                    el.dom.setAttribute("data-qh_oid", "1");
                }
            }
        });
        if (me.buttonData.images.image) {
            styleSheet.push([
                '#' + itemId + ' {',
                'background-image: url(' + IMAGE_URL + me.buttonData.images.image + ');',
                'background-position:' + me.buttonData.images.offset + 'px 0;',
                '}',
                '#' + itemId + ':hover {',
                'background-position:' + me.buttonData.images.offset + 'px -30px;',
                '}',
                '#' + itemId + '.x-btn-pressed {',
                'background-position:' + me.buttonData.images.offset + 'px -60px;',
                '}',
                '#' + itemId + '.x-btn-disabled {',
                'background-position:' + me.buttonData.images.offset + 'px -90px;',
                '}',
                '#' + itemId + '.state2 {',
                'background-image: url(' + IMAGE_URL + me.buttonData.images.image + ');',
                'background-position:' + me.buttonData.images.offset + 'px -120px;',
                '}',
                '#' + itemId + '.state2:hover {',
                'background-position:' + me.buttonData.images.offset + 'px -150px;',
                '}',
                '#' + itemId + '.state2.x-btn-pressed {',
                'background-position:' + me.buttonData.images.offset + 'px -180px;',
                '}',
                '#' + itemId + '.state2.x-btn-disabled {',
                'background-position:' + me.buttonData.images.offset + 'px -210px;',
                '}'
            ].join(''));
        }
        Ext.util.CSS.createStyleSheet(styleSheet.join(''));
        me.callParent(arguments);
    },
    getResources: function() {
        me = this;
        return {
            images: [
                IMAGE_URL + me.buttonData.images.image
            ]
        };
    }
});

/**
 *        
 */
Ext.define('ExGods.view.menu.ToolsMenuLangSelector', {
    extend: Ext.button.Button,
    alias: 'widget.toolsmenulangselect',
    id: 'tools_menu_lang_select',
    defaultValue: 'ru',
    langs: [
        'ru',
        'en'
    ],
    cls: 'tools-menu-lang-select',
    width: 82,
    height: 30,
    action: 'lang_select',
    initComponent: function() {
        var me = this,
            menu = [];
        me.lang = me.defaultValue;
        me.addCls(me.lang);
        // , ".ru"  ".en"
        //   ,   
        me.menu = {
            cls: 'tools-menu-lang-select-dropdown-list',
            items: [],
            padding: '6 0 6 0',
            shadow: false
        };
        me.langs.forEach(function(lang) {
            me.menu.items.push({
                cls: lang,
                lang: lang,
                height: 16,
                width: 85,
                margin: '0 0 3 0',
                listeners: {
                    click: me.onLangButtonClick,
                    scope: me
                }
            });
        });
        me.callParent(arguments);
    },
    /**
     *   
     */
    setLang: function(lang) {
        var me = this;
        me.removeCls(me.lang);
        me.lang = lang;
        me.addCls(me.lang);
    },
    /**
     *    
     */
    getLang: function() {
        return this.lang;
    },
    /********************  PRIVATES **************************/
    onLangButtonClick: function(btn) {
        var me = this;
        if (btn.lang != me.lang) {
            me.setLang(btn.lang);
            me.fireEvent('langselect', me.lang);
        }
    }
});

/**
 *    (,     ..)
 */
Ext.define('ExGods.view.menu.ToolsMenu', {
    extend: Ext.toolbar.Toolbar,
    alias: 'widget.toolsmenu',
    layout: {
        type: 'hbox',
        pack: 'center'
    },
    /**
     * @cfg {Array} menuConfig  
     */
    menuConfig: [],
    width: 230,
    height: 48,
    initComponent: function() {
        var me = this,
            items = [],
            styleSheet = [],
            menuConfig = Ext.Array.sort(me.menuConfig || [], function(a, b) {
                var pos1 = parseInt(a.position);
                var pos2 = parseInt(b.position);
                if (pos1 > pos2) {
                    return 1;
                } else if (pos1 < pos2) {
                    return -1;
                } else {
                    return 0;
                }
            });
        me.defaults = {
            height: 30,
            padding: 0
        };
        Ext.Array.each(menuConfig, function(item) {
            if (!item.message) {
                //  message ,      
                if (item.id_element == 'lang_select') {
                    items.push({
                        xtype: 'toolsmenulangselect',
                        buttonData: item
                    });
                } else if (item.id_element == 'fullscreen' && (Ext.browser.is.IE11 || Ext.browser.is.Safari)) {
                    items.push({
                        xtype: 'toolsmenubutton',
                        buttonData: item,
                        id_cls_uniq: 'fullScrBtn',
                        listeners: {
                            afterrender: function() {
                                var dom_ = Ext.query(".fullScrBtn")[0];
                                dom_.addEventListener("click", function() {
                                    ExGods.app.getController('Viewport').doFullscreen();
                                }, false);
                            }
                        }
                    });
                } else {
                    items.push({
                        xtype: 'toolsmenubutton',
                        buttonData: item
                    });
                }
            }
        });
        me.items = items;
        me.callParent();
    },
    getResources: function() {
        var me = this,
            images = [];
        Ext.Array.each(me.menuConfig, function(item) {
            if (item.images.image && Ext.Array.indexOf(images, item.images.image) === -1) {
                images.push(item.images.image);
            }
        });
        for (var i = 0; i < me.menuConfig.length; i++) {
            if (me.menuConfig[i].id_element == "lang_select") {
                images.push(IMAGE_URL + 'top-menu/top_menu_language_btn.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_bg_top.png');
                images.push(IMAGE_URL + 'top_menu_language_bg_bottom.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_ru.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_en.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_bg.png');
                images.push(IMAGE_URL + 'top-menu/top_menu_language_bg_hover.png');
            }
        }
        return {
            images: images
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.Viewport', {
    extend: Ext.container.Container,
    id: 'viewport',
    isViewport: true,
    layout: {
        type: 'border',
        regionWeights: {
            west: 20,
            east: 10,
            north: 30,
            south: -20
        }
    },
    renderTo: 'viewport-wrapper',
    initComponent: function() {
        var me = this;
        Ext.applyIf(me, {
            width: 1000,
            height: 555
        });
        //      
        me.items = [
            {
                //  
                xtype: 'container',
                id: 'header',
                height: 95,
                layout: {
                    type: 'border',
                    regionWeights: {
                        west: 20,
                        east: 10,
                        north: -10,
                        south: -20
                    }
                },
                region: 'north',
                items: [
                    {
                        region: 'north',
                        layout: 'absolute',
                        style: {
                            'z-index': 1
                        },
                        height: 60,
                        items: [
                            {
                                xtype: 'container',
                                layout: {
                                    type: 'hbox',
                                    pack: 'center'
                                },
                                items: [
                                    {
                                        xtype: 'toolsmenu',
                                        id: 'tools-menu',
                                        menuConfig: config.menu.tools
                                    }
                                ],
                                style: {
                                    top: '15px'
                                }
                            },
                            {
                                xtype: 'systemmenu',
                                id: 'system-menu',
                                menuConfig: config.menu.system,
                                width: '100%'
                            }
                        ]
                    },
                    {
                        xtype: 'container',
                        id: 'tech-info-container',
                        layout: 'fit',
                        region: 'west',
                        width: 285
                    },
                    {
                        xtype: 'container',
                        id: 'header-right',
                        cls: 'header-right-container',
                        region: 'east',
                        width: 285
                    },
                    {
                        xtype: 'container',
                        id: 'header-center',
                        layout: 'card',
                        region: 'center',
                        margin: '-37 0 0 0'
                    }
                ]
            },
            {
                //  
                xtype: 'quickslots',
                region: 'west',
                width: 70
            },
            {
                xtype: 'container',
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                region: 'center',
                items: [
                    {
                        //   
                        xtype: 'container',
                        id: 'center',
                        height: 430,
                        layout: 'fit',
                        region: 'center'
                    },
                    {
                        //   
                        xtype: 'chatcontainer',
                        id: 'chat-container',
                        hidden: !ExGods.app.user.isChatOn()
                    },
                    {
                        xtype: 'chatoffpanel',
                        id: 'chat-off-panel',
                        hidden: ExGods.app.user.isChatOn(),
                        height: 56
                    },
                    {
                        xtype: 'announcmentsview'
                    }
                ]
            },
            {
                xtype: 'mainmenu',
                menuConfig: config.menu.mainmenu,
                region: 'east'
            }
        ];
        me.callParent();
    }
});

/**
 *    
 */
Ext.define('ExGods.model.ShopItem', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'count',
            type: 'int'
        },
        {
            name: 'order',
            type: 'int',
            convert: function(v, r) {
                return v || 0;
            }
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'item',
            type: 'auto'
        },
        {
            name: 'params',
            type: 'auto'
        },
        {
            name: 'new_price',
            type: 'auto',
            defaultValue: ''
        },
        {
            name: 'price',
            type: 'auto',
            convert: function(v, rec) {
                if (!v || !v.length) {
                    var proto_id = rec.get('item') ? parseInt(rec.get('item').item) : parseInt(rec.get('kit')),
                        proto = ExGods.app.getItemPrototypesStore().data.getByKey(proto_id) || ExGods.ref('kit_proto').getByKey(proto_id),
                        name, price;
                    if (!proto.get) {
                        name = proto.params.price[0].name;
                        price = proto.params.price[0].value;
                    } else {
                        name = references.get('constants').get('currency').value;
                        price = proto.get('data').price;
                    }
                    return {
                        name: name,
                        value: price
                    };
                }
                return v;
            }
        },
        {
            name: 'shop_id',
            type: 'int'
        },
        {
            name: 'start_count',
            type: 'int'
        },
        {
            //   
            name: 'basket_count',
            type: 'int'
        },
        {
            //   
            name: 'message',
            type: 'string'
        },
        {
            name: 'kit',
            type: 'int'
        },
        {
            name: 'item_proto',
            type: 'auto',
            convert: function(v, rec) {
                var proto;
                if (rec.get('item') && rec.get('item').item) {
                    proto = ExGods.app.getItemPrototypesStore().data.getByKey(parseInt(rec.get('item').item));
                }
                if (rec.get('kit')) {
                    proto = Ext.clone(ExGods.ref('kit_proto').getByKey(parseInt(rec.get('kit'))));
                    //    
                    proto.data = {
                        data: {
                            strict: {
                                level: proto.params.level
                            },
                            stats: {
                                item_grade: '1'
                            }
                        },
                        images: {
                            info: IMAGE_URL + proto.params.image
                        },
                        title: proto.label
                    };
                }
                return proto;
            }
        }
    ],
    getLevel: function() {
        return parseInt(this.data.item_proto.data.data.strict.level);
    },
    getTitle: function() {
        return this.data.item_proto.data.title;
    },
    getImage: function() {
        return this.data.item_proto.data.images.info;
    },
    getGrade: function() {
        return parseInt(this.data.item_proto.data.data.item_grade || 1);
    }
});

/**
 *   
 */
Ext.define('ExGods.store.ShopItems', {
    extend: Ext.data.Store,
    model: 'ExGods.model.ShopItem',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'order',
            direction: 'DESC'
        },
        {
            sorterFn: function(o1, o2) {
                var level1 = o1.getLevel(),
                    level2 = o2.getLevel();
                if (level1 === level2) {
                    var grade1 = o1.getGrade(),
                        grade2 = o2.getGrade();
                    if (grade1 === grade2) {
                        var title1 = o1.getTitle(),
                            title2 = o2.getTitle();
                        if (title1 === title2)  {
                            return 0;
                        }
                        
                        return title1 < title2 ? 1 : -1;
                    }
                    return grade1 < grade2 ? 1 : -1;
                }
                return level1 < level2 ? 1 : -1;
            }
        }
    ]
});

/**
 *  
 */
Ext.define('ExGods.model.Shop', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'blob',
            type: 'auto'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'type',
            type: 'int'
        },
        {
            //   
            name: 'items',
            type: 'auto',
            convert: function(itemsData, record) {
                var data = [];
                if (itemsData) {
                    data = data.concat(itemsData);
                }
                if (record.data.kits) {
                    data = data.concat(record.data.kits);
                }
                record.itemsStore.loadRawData(data);
                return record.itemsStore;
            }
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            //    
            name: 'kits',
            type: 'auto'
        }
    ],
    proxy: 'memory',
    statics: {
        getMissedProtos: function(data) {
            var me = this,
                protos = ExGods.app.getItemPrototypesStore(),
                missedProtos = [],
                protoId, kitProto;
            if (data.items && data.items.length) {
                data.items.forEach(function(item) {
                    var protoId = parseInt(item.item.item);
                    if (!protos.data.getByKey(protoId)) {
                        missedProtos.push(protoId);
                    }
                });
            }
            if (data.kits && data.kits.length) {
                data.kits.forEach(function(item) {
                    var kitProto = ExGods.ref('kit_proto').getByKey(parseInt(item.entry));
                    for (var k = 0; k < kitProto.params.items.length; k++) {
                        var protoId = parseInt(kitProto.params.items[k].item);
                        if (!protos.data.getByKey(protoId)) {
                            missedProtos.push(protoId);
                        }
                    }
                });
            }
            return missedProtos;
        }
    },
    constructor: function(config) {
        this.itemsStore = Ext.create('ExGods.store.ShopItems');
        this.callParent(arguments);
    },
    items: function() {
        return this.itemsStore;
    },
    getIcons: function() {
        return this.get('blob').images;
    },
    getIcon: function(type) {
        return this.getIcons()[type];
    },
    /**
     *    ,    
     */
    getMissedProtos: function() {
        var me = this;
        return ExGods.model.Shop.getMissedProtos(me.raw);
    }
});

/**
 *  ,      .
 *     .
 */
Ext.define('ExGods.controller.Base', {
    extend: ExGodsCore.controller.Base
});
// some functions here

/**
 *     ( )   
 */
Ext.define('ExGods.view.CommonWindow', {
    extend: Ext.window.Window,
    alias: 'widget.commonwindow',
    bodyPadding: 10,
    draggable: false,
    modal: true,
    plugins: [
        'skinpaperdeco'
    ],
    resizable: false,
    initComponent: function() {
        var me = this,
            i = 0,
            button;
        if (Ext.isObject(me.buttons)) {
            var buttons = me.buttons.items;
            for (; i < buttons.length; i++) {
                button = buttons[i];
                button.margin = '0 10';
            }
        }
        me.callParent();
    },
    /**
     *    
     */
    mask: function() {
        var me = this;
        if (me.rendered) {
            ExGods.util.Helper.maskElement(me.body);
        }
    },
    /**
     *    
     */
    unmask: function() {
        var me = this;
        if (me.rendered) {
            me.body.unmask();
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: []
        };
    }
});

/**
 *  
 */
// Notes:          cls: 'x-btn-txt-red'
Ext.define('ExGods.view.TextButton', {
    extend: Ext.button.Button,
    alias: 'widget.textbutton',
    config: {
        border: 0,
        minWidth: 100,
        ui: 'txt'
    },
    /**
     *   div  ,      
     * ,  mousedown     (div  text),  mouseup    
     *     mouseclick.
     *
     */
    hoverDiv: '<div style="height: 100%; width: 100%; background-color: black; opacity: 0; position: absolute; top:0; left: 0px;"></div>',
    initComponent: function() {
        var me = this;
        if (me.config.text.length && me.config.text.substr(0, 4) == 'img:') {
            me.textImage = (me.config.text.substr(4, 4) == 'http' ? '' : IMAGE_URL) + me.config.text.substr(4);
            me.config.text = '<div class="text-btn-image" style="background-image:url(' + me.textImage + ')"></div>';
        }
        me.text = me.hoverDiv + me.config.text;
        this.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        if (me.qh)  {
            me.el.set(me.qh);
        }
        
        me.callParent();
    },
    setText: function(text) {
        if (text.length && text.substr(0, 4) == 'img:') {
            text = (text.substr(0, 4) == 'http' ? '' : IMAGE_URL) + text.substr(4);
            text = '<div class="text-btn-image" style="background-image:url(' + text + ')"></div>';
        }
        this.callParent([
            this.hoverDiv + text
        ]);
    },
    getResources: function() {
        var me = this;
        if (me.textImage) {
            return {
                images: [
                    me.textImage
                ]
            };
        }
    }
});

/**
 *   .
 *
 *    AJAX .
 */
Ext.define('ExGods.controller.Error', {
    extend: ExGods.controller.Base,
    views: [
        'CommonWindow',
        'TextButton'
    ],
    refs: [
        {
            /**
             * @method getErrorWindow
             *   
             */
            ref: 'errorWindow',
            selector: '#ajax-fail-error'
        },
        {
            /**
             * @method getReportErrorWin
             *       
             * @return {ExGods.view.ErrorReport}
             */
            ref: 'reportErrorWin',
            selector: '#report-error-window'
        }
    ],
    init: function() {
        var me = this;
        ExGodsCore.AjaxRequest.on({
            requestexception: me.onRequestException,
            jsondecodeerror: me.onDecodeError,
            scope: me
        });
        me.control({
            'errorreport #submit': {
                click: me.onReportErrorSubmit
            },
            'errorreport #reset': {
                click: me.onReportErrorReset
            }
        });
    },
    onLaunch: function() {
        ExGods.Components.addComponentInitializer('error_report', this.initErrorReportComponent, this);
    },
    onRequestException: function(conn, response, options) {
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@error request exception. response: ' + response.status + ' ' + response.statusText);
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@error request exception. response: ' + response.status + ' ' + response.statusText);
        if (response.status !== 0) {
            this.onFailure(response, options);
        }
    },
    /**
     *  HTTP- AJAX-
     */
    onFailure: function(response, options) {
        var me = this,
            timeNow = new Date(),
            getErrorAutoRequestMessage = function(time, response) {
                var tpl = [
                        '<div>{time}</div>',
                        '<div>url: <b>{url}</b></div>',
                        '<div>status: {status}</div>',
                        '<div>text: {statusText}</div>',
                        '<div>params: {params}</div>',
                        '<div>bindings: {bindings}</div>',
                        '<div>agent: {agent}</div>',
                        '<div>cookie: {cookie}</div>'
                    ];
                var data = {
                        time: Ext.Date.format(time, 'Y:m:d H:i:s'),
                        url: response.request.options.url,
                        status: response.status,
                        statusText: response.statusText,
                        params: (function() {
                            var params = response.request.options.params || {},
                                paramsArr = [];
                            Ext.Object.each(params, function(key) {
                                paramsArr.push(key + '=' + params[key]);
                            });
                            return paramsArr.join(', ');
                        }()),
                        bindings: (function() {
                            var str = '',
                                bindings = ExGods.app.user.get('binding');
                            Ext.Object.each(bindings, function(key) {
                                str += key + ':' + bindings[key] + ' ';
                            });
                            return str;
                        }()),
                        cookie: (function() {
                            var cookie = document.cookie.split(';'),
                                str = '';
                            if (cookie.length) {
                                str = cookie[0];
                                for (var i = 1; i < cookie.length; i++) {
                                    str += '<br/><span style="padding: 0 0 0 38px;">' + cookie[i] + '</span>';
                                }
                            }
                            return str;
                        }()),
                        agent: navigator.userAgent
                    };
                return (new Ext.XTemplate(tpl)).apply(data);
            };
        if (/^\/online_list/.test(options.url)) {
            return;
        }
        //    /online_list -  
        switch (response.status) {
            //  
            case 401:
                if (isSocialApp) {
                    window.location.href = '/logout-social.html';
                } else {
                    window.location = '/';
                };
                break;
            //   
            case 503:
                if (isSocialApp) {
                    window.location = '/stopofwork-vka.html';
                } else {
                    location.reload();
                };
                break;
            //   
            default:
                if (response.request && response.request.options && /cmd=bugs&autorequest=1/.test(response.request.options.url)) {
                    return;
                };
                //   ,       
                var win = me.getErrorWindow();
                if (win) {
                    win.close();
                };
                Ext.widget('commonwindow', {
                    id: 'ajax-fail-error',
                    html: Ext.String.format(ExGods.getMsgByKey('server_error_alert_text'), response.status, options.url) + '<br />' + response.statusText,
                    autoShow: true,
                    plugins: [
                        'windeco'
                    ],
                    buttonAlign: 'center',
                    buttons: [
                        {
                            xtype: 'textbutton',
                            handler: function(button) {
                                //      
                                if (response.request && response.request.options && !/cmd=bugs&autorequest=1/.test(response.request.options.url)) {
                                    Ext.Ajax.request({
                                        url: 'game.pl?cmd=bugs&autorequest=1',
                                        params: {
                                            type: 6,
                                            subject: ' ',
                                            message: getErrorAutoRequestMessage(timeNow, response)
                                        }
                                    });
                                }
                                button.up('commonwindow').close();
                            },
                            text: ExGods.getMsgByKey('close_btn_text')
                        }
                    ]
                });
                ExGods.app.unblock();
                break;
        }
    },
    /**
     *    ,    json-
     */
    onDecodeError: function(response, args) {
        Ext.log('onDecodeError');
        if (args.url.indexOf('ping') != -1) {
            window.location = '/main.pl';
        }
    },
    initErrorReportComponent: function(config) {
        var me = this,
            errRep = Ext.widget('errorreport', {
                config: config
            }),
            wnd;
        errRep.on('success_report', function(type) {
            html = type == '2' ? ExGods.getMsgByKey('error_report_success_text') : ExGods.getMsgByKey('error_report_success_complain_text');
            errRep.removeAll();
            errRep.add({
                xtype: 'component',
                padding: '12 18',
                html: html
            });
            errRep.addDocked({
                dock: 'bottom',
                xtype: 'toolbar',
                layout: {
                    pack: 'center'
                },
                margin: '0 0 12',
                items: [
                    {
                        xtype: 'textbutton',
                        dock: 'bottom',
                        cls: 'no_border',
                        width: 120,
                        margin: '0 5',
                        text: ExGods.getMsgByKey('close_btn_text'),
                        handler: function() {
                            wnd.close();
                        }
                    }
                ]
            });
        });
        wnd = Ext.widget('window2', {
            id: 'ERROR_REPORT',
            items: [
                errRep
            ],
            autoShow: false
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
        });
        return wnd;
    },
    onReportErrorSubmit: function(button) {
        var me = this,
            app = me.application,
            form = button.up('form');
        if (form.isValid()) {
            app.block();
            html2canvas(document.getElementById('viewport-wrapper'), {
                //logging:true,
                useCORS: true
            }).then(function(canvas) {
                var screenshot = canvas.toDataURL('image/jpeg', 0.5).replace(/data:image\/jpeg;base64,/, '');
                form.submit({
                    params: {
                        screenshot: screenshot
                    },
                    success: function(form, action) {
                        var json = action.result;
                        app.unblock();
                        button.up('errorreport').fireEvent('success_report', form.getValues().type);
                    },
                    failure: function(form, action) {
                        var json = action.result;
                        app.unblock();
                    }
                });
            });
        }
    },
    /**
     *   
     */
    onReportErrorReset: function(button) {
        button.up('form').down('textareafield').setValue('');
    }
});

/**
 *   
 */
Ext.define('ExGods.service.Base', {
    mixins: {
        observable: Ext.util.Observable,
        loggable: ExGodsCore.util.Loggable,
        ajaxable: ExGodsCore.util.Ajaxable
    },
    logConfig: {
        enabled: {
            info: false,
            error: true,
            warn: true
        },
        prefix: 'Service:'
    },
    inheritableStatics: {
        /**
         * @property  single,      
         */
        single: true,
        /**
         * @property  true,       (,
         *      ,   )
         */
        multipleInit: false,
        /**
         * @property  
         */
        initUrl: '/game.pl?cmd=get_service_data',
        /**
         * @property  
         */
        commandsUrl: '/map.pl'
    },
    /**
     * @cfg Id 
     */
    id: undefined,
    /**
     * @property   
     */
    info: undefined,
    /**
     * @property  
     */
    data: null,
    /**
     * @property  
     */
    initialized: false,
    constructor: function(config) {
        this.mixins.observable.constructor.call(this, config);
        this.id = config.id;
        this.info = ExGods.ref('services|' + this.id);
    },
    /**
     *  
     */
    init: function(data, callback) {
        var me = this,
            callback = callback || Ext.emptyFn;
        if (me.requestingInit)  {
            return;
        }
        
        if (me.initialized && !Ext.getClass(me).multipleInit) {
            callback(me);
        } else {
            if (me.fireEvent('beforeinit', me)) {
                if (!data && Ext.getClass(me).initUrl) {
                    me.requestingInit = true;
                    me.request({
                        url: Ext.getClass(me).initUrl,
                        params: {
                            service_id: me.id
                        },
                        success: function(json) {
                            if (json.success) {
                                if (json.service) {
                                    me.data = json.service;
                                }
                                me.initialized = true;
                                me.onInit();
                                me.fireEvent('init', me);
                                callback(me);
                            } else {
                                callback({
                                    error: '   : ' + (json.msg ? json.msg : '')
                                });
                            }
                            me.requestingInit = false;
                        }
                    });
                } else {
                    me.initialized = true;
                    me.data = data;
                    me.onInit();
                    me.fireEvent('init', me);
                    callback(me);
                }
            } else {
                callback({
                    error: '   '
                });
            }
        }
    },
    /**
     * @template 
     */
    onInit: function() {},
    //
    /**
     *   
     */
    update: function(data, callback) {
        var me = this,
            oldData = me.data;
        callback = callback || Ext.emptyFn;
        if (!data) {
            me.request({
                url: Ext.getClass(me).initUrl,
                params: {
                    service_id: me.id
                },
                success: function(json) {
                    if (json.success) {
                        if (json.service) {
                            me.data = json.service;
                        }
                        me.onUpdate(me.data, oldData);
                        me.fireEvent('update', me, me.data, oldData);
                        callback(me);
                    } else {
                        callback({
                            error: '   . ' + (json && json.msg ? json.msg : '')
                        });
                    }
                }
            });
        } else {
            me.data = data;
            me.onUpdate(me.data, oldData);
            me.fireEvent('update', me, me.data, oldData);
            callback(me);
        }
    },
    /**
     * @template
     */
    onUpdate: function(newData, oldData) {},
    //
    /**
     *   
     */
    command: function(cmd, params, callback, options) {
        var me = this;
        params = params || {};
        params.service_id = me.id;
        options = options || {};
        callback = callback || {};
        if (typeof callback == 'function') {
            callback = {
                callback: callback
            };
        }
        me.request({
            url: (options.url ? options.url : Ext.getClass(me).commandsUrl) + '?cmd=' + cmd,
            queue: options.queue != undefined ? options.queue : true,
            params: params,
            success: {
                beforeKeyHandlers: callback.beforeKeyHandlers,
                afterKeyHandlers: function(json) {
                    if (json.success) {
                        if (json.service) {
                            me.update(json.service);
                        }
                    }
                    if (callback.callback) {
                        callback.callback(json);
                    }
                }
            },
            failure: callback.failure
        });
    }
});

/**
 * C 
 */
Ext.define('ExGods.service.Room', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 * C 
 */
Ext.define('ExGods.service.Link', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 * C  
 */
Ext.define('ExGods.service.MapAction', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    },
    /**
     * @property   ,     
     */
    mapAction: null,
    onInit: function() {
        var me = this;
        if (me.data.map_action.length) {
            me.mapAction = Ext.create('ExGods.model.Action', me.data.map_action[0]);
            me.mapAction.set('service_id', me.id);
        }
    }
});

/**
 *  C 

    :
        teleport

 */
Ext.define('ExGods.service.Teleport', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 * C 
 */
Ext.define('ExGods.service.ShowComponent', {
    extend: ExGods.service.Base,
    statics: {
        single: false,
        initUrl: null
    }
});

/**
 *  C 

    :
        skills_master
        skills_pause
        skills_unpause
        skills_complete
        skills_boost
        skills_boost_complete

 */
Ext.define('ExGods.service.Skills', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  C 

    :
        quests_get
        quests_finish
        quests_delete
        quests_reroll
 */
Ext.define('ExGods.service.Quests', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        commandsUrl: '/game.pl'
    }
});

/**
 *  C 
    
    :
        item_on
        item_off
        item_del
        buy_slot
        protect_slot
        get_item_action
        put_from_store
        remove_from_store

 */
Ext.define('ExGods.service.Inventory', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  C 

    :
        save_setting

 */
Ext.define('ExGods.service.Settings', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        commandsUrl: '/game.pl'
    }
});

/**
 *  C 

    :
        group_info
        join_group
        unjoin_group
        search_group
        kick_user_group
        change_group_creator

 */
Ext.define('ExGods.service.Group', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        commandsUrl: '/game.pl'
    }
});

/**
 *  C 

    :
        banish_quest_bot
        attack_quest_bot

 */
Ext.define('ExGods.service.Location', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  C . 

    :
        use_special_deal

 */
Ext.define('ExGods.service.SpecialDeal', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  C 

    :
        messages_remove
        messages_remove_list_rest
        messages_take_attach
        messages_update_state

 */
Ext.define('ExGods.service.Messages', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        commandsUrl: '/game.pl'
    },
    initialized: true,
    data: {
        messages: {
            new_count: 0,
            rest_count: 0
        }
    }
});

/**
 *  C 

    :
        shop_buy        

 */
Ext.define('ExGods.service.Shop', {
    extend: ExGods.service.Base,
    statics: {
        single: false,
        multipleInit: false
    }
});

/**
 *  C  

    :
        fit_mask
        put_on_mask
        buy_mask
        upgrade_mask

 */
Ext.define('ExGods.service.Masks', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 

    :
        arena_queue
        arena_unqueue
        arena_accept
        arena_refuse
        arena_revenge
        arena_buy
        arena_get_foes

 */
Ext.define('ExGods.service.Arena', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 2

    :
        arena2_search

 */
Ext.define('ExGods.service.Arena2', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    },
    getRewardByPlace: function(place) {
        if (!this.data || !this.data.arena)  {
            return;
        }
        
        place = Number(place);
        var me = this,
            rewards = me.data.arena.reward_list,
            reward = [],
            i = rewards.length;
        while (i--) {
            if (place >= rewards[i].begin_place && place <= rewards[i].end_place) {
                reward = rewards[i].prize;
            }
        }
        return reward;
    }
});

/**
 *  C 

    :
        robbery_start
        robbery_request
        robbery_foe(title)

 */
Ext.define('ExGods.service.Robbery', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 

    :
        change_real_money_service
        email_assign
        payment_reward

 */
Ext.define('ExGods.service.Payment', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        multipleInit: true,
        commandsUrl: '/game.pl'
    }
});

/**
 *  C 

    :
        lair_start
        lair_drop_timeout

 */
Ext.define('ExGods.service.Lairs', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 

    : 

 */
Ext.define('ExGods.service.Empty', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 

    :
        banish_bot
        battle_bot_surging

 */
Ext.define('ExGods.service.Surging', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 

     :
     make
     replay
     finish

 */
Ext.define('ExGods.service.Fucina', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        multipleInit: true
    }
});

/**
 *  C 

    : 
        ratings_map_action

 */
Ext.define('ExGods.service.Ratings', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 

    :
    - start_chain
    - surrender_chain

 */
Ext.define('ExGods.service.BattleChains', {
    extend: ExGods.service.Base,
    statics: {
        single: true
    }
});

/**
 *  C 

    :
        chest_open
        chest_take
        chest_open_by_key
        chest_take_all
 */
Ext.define('ExGods.service.Chests', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        multipleInit: true
    }
});

/**
 *  C 

    :
        guild_add_user
        create_guild
        search_guild
        callback_bid
        refuse_bid
        confirm_bid
        guilds_requests
        answer_request
        create_request
        leave_guild
        remove_user_from_guild
        change_description
        change_head_guild
        guild_tasks
        guild_task_pcp
        guild_groups
        guild_create_group
        guild_group_info
        guild_join_group
        guild_unjoin_group
        guild_kick_user_group
        guild_change_group_creator
        guild_raids_info
        guild_snet_notice_inactive_sent
 */
Ext.define('ExGods.service.Guilds', {
    extend: ExGods.service.Base,
    statics: {
        single: true,
        multipleInit: true
    },
    /**
     * ..            success -    
     */
    parseData: function(data) {
        var me = this,
            keys = [
                'bids',
                'guilds',
                'guild',
                'timed',
                'shop_service_id',
                'guild_noob'
            ];
        for (var key in data) {
            if (keys.indexOf(key) == -1)  {
                delete data[key];
            }
            
        }
        if (!data.timed)  {
            data.timed = me.data.timed;
        }
        
        if (!data.shop_service_id)  {
            data.shop_service_id = me.data.shop_service_id;
        }
        
        return data;
    }
});

/**
 *  C 

    :
        market_buy_product
        product_from_market
 */
Ext.define('ExGods.service.Market', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 

    :
        pets_repair
        pets_on
        pets_live
        pets_off
        pets_off
        charge_trap
        open_trap
        pet_tame
        pet_tame_garanted
        pets_proto
 */
Ext.define('ExGods.service.Pets', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *  C 

    : 

 */
Ext.define('ExGods.service.Command', {
    extend: ExGods.service.Base,
    statics: {
        single: false
    }
});

/**
 *   
 * 
 * @author  
 *
 */
Ext.define('ExGods.controller.Services', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Services:'
    },
    services: {},
    init: function() {
        var me = this;
        ExGods.Services = me;
        //    
        Ext.each(config.services, function(data) {
            var service = me.factory(data.service_id);
            if (!service.error) {
                service.init(data.service);
            } else {
                /***/
                me.log('error', '  : ' + service.error);
            }
        });
        //        "services"
        me.addAjaxRequestKeyHandler('services', function(data) {
            me.updateGroupOfServices(data.services);
        }, me);
        me.callParent();
    },
    onLaunch: function() {
        var me = this;
        Ext.each(config.services, function(data) {
            ExGodsCore.AjaxRequest.invokeKeyHandlers(data);
        });
    },
    //   
    /**
     *     id
     */
    factory: function(serviceId) {
        var me = this,
            info = ExGods.ref('services|' + serviceId),
            serviceClass = me.getServiceClass(serviceId);
        if (info && serviceClass) {
            if (serviceClass.single) {
                if (!me.services[info.proto['package']]) {
                    me.services[info.proto['package']] = Ext.create(serviceClass.getName(), {
                        id: serviceId
                    });
                }
                return me.services[info.proto['package']];
            } else {
                return Ext.create(serviceClass.getName(), {
                    id: serviceId
                });
            }
        } else {
            return {
                error: !info ? '      ' + serviceId : '    ' + info.proto['package']
            };
        }
    },
    /**
     *     (single)    (package)
     */
    get: function(name) {
        var me = this,
            service = me.services[name];
        if (!service) {
            ExGods.ref('services').each(function(info) {
                if (info.proto['package'] == name) {
                    service = me.factory(info.id);
                }
            });
        }
        return service || {
            error: '  '
        };
    },
    /**
     *     
     * @param group          
     */
    updateGroupOfServices: function(group) {
        var me = this,
            _updateServices = function(services) {
                Ext.each(services, function(data) {
                    var service = me.factory(data.service_id);
                    if (!service.error) {
                        service.update(data.service);
                    } else {
                        /***/
                        me.log('error', '  : ' + service.error);
                    }
                    ExGodsCore.AjaxRequest.invokeKeyHandlers(data);
                });
            };
        //   
        if (typeof group == 'string') {
            me.request({
                url: '/game.pl',
                params: {
                    cmd: 'get_service_group_data',
                    group: group
                },
                success: function(json) {}
            });
        } else // ,       {services: ..},
        //        
        {
            _updateServices(group);
        }
    },
    /**
     *   
     */
    getServiceClass: function(serviceId) {
        var me = this,
            info = ExGods.ref('services|' + serviceId),
            parts,
            name = '';
        if (info) {
            parts = info.proto['package'].split('_');
            for (var i = 0; i < parts.length; i++) {
                name += parts[i].charAt(0).toUpperCase() + parts[i].substring(1);
            }
            return ExGods.service[name];
        }
    }
});

/**
 *  .
 *  -    Ext.Container,         
 */
(function() {
    Ext.define('ExGods.controller.Layers', {
        extend: ExGods.controller.Base,
        requires: [],
        // 
        logConfig: {
            enabled: {
                info: true,
                wrap: true,
                error: true
            },
            prefix: 'Layers:'
        },
        /**
     * @property   
     */
        layers: {},
        init: function() {
            var me = this;
            ExGods.Layers = me;
            me.callParent();
        },
        factory: function(config) {
            var me = this;
            if (config.type == 'single') {
                me.layers[config.id] = new SingleLayer(config);
            } else if (config.type == 'stack') {
                me.layers[config.id] = new StackLayer(config);
            } else {
                me.layers[config.id] = new BaseLayer(config);
            }
            return me.layers[config.id];
        },
        get: function(layerName) {
            return this.layers[layerName];
        }
    });
    /*  Internal Layer classes */
    var BaseLayer = Ext.define(null, {
            extend: 'Ext.Container',
            defaultStyles: {
                position: 'absolute',
                width: '100%',
                height: '100%',
                top: 0,
                left: 0
            },
            onRender: function() {
                var me = this;
                me.getEl().applyStyles(me.defaultStyles);
                me.callParent(arguments);
            },
            clear: function() {
                var me = this;
                me.items.each(function(item) {
                    if (item.close) {
                        item.close();
                    } else {
                        item.destroy();
                    }
                });
            }
        });
    var SingleLayer = Ext.define(null, {
            extend: BaseLayer,
            show: function(cmp) {
                var me = this,
                    tries = 200;
                if (me.adding)  {
                    return;
                }
                
                var interval = setInterval(function() {
                        tries--;
                        if (cmp.isVisible()) {
                            me.fireEvent('cmp_visible');
                            clearInterval(interval);
                        } else if (!tries) {
                            clearInterval(interval);
                        }
                    }, 10);
                me.callParent(arguments);
            },
            hide: function() {
                var me = this,
                    hasVisibleItems = me.hasVisibleItems();
                if (me.adding)  {
                    return;
                }
                
                if (!hasVisibleItems)  {
                    me.callParent(arguments);
                }
                
            },
            hasVisibleItems: function() {
                var me = this,
                    hasVisibleItems = false;
                me.items.each(function(item) {
                    hasVisibleItems = hasVisibleItems || item.isVisible();
                });
                return hasVisibleItems;
            },
            add: function(cmp) {
                var me = this;
                me.adding = true;
                me.clear();
                cmp = me.callParent(arguments);
                cmp.on('beforeshow', me.clear, me);
                cmp.on('show', me.show.bind(me, cmp));
                cmp.on('hide', me.hide, me);
                cmp.on('destroy', me.hide, me);
                me.adding = false;
                me.show(cmp);
            }
        });
    var StackLayer = Ext.define(null, {
            extend: BaseLayer,
            _stack: [],
            initComponent: function() {
                var me = this;
                me.callParent();
            },
            add: function(cmp) {
                var me = this;
                cmp = Ext.widget(cmp);
                if (Ext.Array.indexOf(me._stack, cmp) == -1) {
                    me._stack.push(cmp);
                }
                if (me._stack.length == 1) {
                    me._showItem(cmp);
                }
            },
            _showItem: function(cmp) {
                var me = this;
                cmp.on('destroy', me._onDestroy, me, {
                    single: true
                });
                me.superclass.add.apply(this, [
                    cmp
                ]);
                me.show();
            },
            _onDestroy: function(cmp) {
                var me = this;
                me._stack.shift();
                if (me._stack.length) {
                    me._showItem(me._stack[0]);
                } else {
                    me.hide();
                }
            }
        });
})();

/**
 *  
 *
 * @author  
 *
 */
Ext.define('ExGods.controller.Components', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            wrap: true,
            error: true
        },
        prefix: 'Components:'
    },
    initializers: {},
    init: function() {
        var me = this;
        ExGods.Components = me;
    },
    //  
    factory: function(componentId, params) {
        var me = this,
            data = ExGods.ref('client_objects|' + componentId),
            cls, cmp;
        if (data) {
            params = Ext.applyIf(params || {}, data.params);
            if (me.initializers[data.xtype]) {
                cmp = me.initializers[data.xtype].fn.call(me.initializers[data.xtype].scope, params, componentId);
                if (cmp) {
                    return cmp;
                } else {
                    return {
                        error: ' ' + data.xtype + '  . -  '
                    };
                }
            } else {
                cls = Ext.ClassManager.getByAlias(data.xtype);
                if (cls) {
                    return new cls(Ext.apply({
                        id: componentId
                    }, params));
                } else {
                    return {
                        error: '   "' + data.xtype + '"  .'
                    };
                }
            }
        } else {
            return {
                error: '      ' + componentId
            };
        }
    },
    /**
     *     
     */
    createAndShow: function(componentId, params) {
        var me = this,
            cmp;
        cmp = me.factory(componentId, params);
        if (cmp && !cmp.error) {
            if (!cmp.rendered) {
                cmp.show();
            }
        }
        return cmp;
    },
    /**
     * / .    , 
     */
    toggle: function(componentId, params) {
        var me = this,
            cmp = Ext.getCmp(componentId);
        if (cmp) {
            if (cmp.isVisible()) {
                cmp.hide();
            } else {
                cmp.show();
            }
        } else {
            cmp = me.factory(componentId, params);
            if (cmp && !cmp.error) {
                if (!cmp.rendered) {
                    cmp.show();
                }
            }
        }
        return cmp;
    },
    addComponentInitializer: function(type, initializer, scope) {
        var me = this;
        me.initializers[type] = {
            fn: initializer,
            scope: scope || this
        };
    }
});

/*
 *     
 * 
 * @author  
 *
 */
Ext.define('ExGods.controller.ClientActions', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            wrap: true,
            error: true
        },
        prefix: 'ClientActions:'
    },
    init: function() {
        var me = this;
        ExGods.ClientActions = me;
    },
    /**
     *    
     * @param config
     *      actionId - id  
     *      src -   ,  "menu"  "chat"
     */
    factory: function(config) {
        var me = this,
            action;
        action = {
            id: config.actionId,
            src: config.src,
            options: config.options || {},
            info: ExGods.ref('client_actions|' + config.actionId),
            doAction: function(callback) {
                me.doAction(this, callback);
            }
        };
        if (action.info) {
            if (action.info.serviceId) {
                action.service = ExGods.Services.factory(action.info.serviceId);
                if (!action.service.error) {
                    //     ,  .       
                    if (action.service.info.params && action.service.info.params.link) {
                        action.href = action.service.info.params.link;
                        action.hrefTarget = action.service.info.params.target;
                    }
                    return action;
                } else {
                    return {
                        error: '      : ' + action.service.error
                    };
                }
            }
        } else {
            return {
                error: '     ' + config.actionId + '  '
            };
        }
    },
    /**
     *   
     */
    doAction: function(action, callback) {
        var me = this,
            callback = callback || Ext.emptyFn,
            afterActionAndCallback = function(result) {
                me.afterAction(action, result);
                callback.apply(this, arguments);
            };
        if (me.beforeAction(action) !== false) {
            switch (action.service.info.proto['package']) {
                case 'room':
                    {
                        me.invokeRoomAction(action, afterActionAndCallback);
                        break;
                    };
                case 'link':
                    {
                        me.invokeLinkAction(action, afterActionAndCallback);
                        break;
                    };
                case 'map_action':
                    {
                        me.invokeMapAction(action, afterActionAndCallback);
                        break;
                    };
                case 'show_component':
                    {
                        me.invokeComponentAction(action, function(res) {
                            afterActionAndCallback(res);
                        });
                        break;
                    };
                case 'command':
                    {
                        me.invokeCommandAction(action, afterActionAndCallback);
                        break;
                    };
                default:
                    {
                        if (action.service.info.proto.need_component == 1) {
                            me.invokeComponentAction(action, function(res) {
                                afterActionAndCallback(res);
                            });
                        } else {
                            afterActionAndCallback({
                                error: '   '
                            });
                        }
                    };
            }
        }
    },
    /**
     *   
     *   false   
     */
    beforeAction: function(action) {
        var me = this;
        if (action.src == 'location-object') {
            //         
            if (action.options.locationObject.interactive.image_mask) {
                me.app.getController('Location').maskLocation(null, {
                    img: action.options.locationObject.interactive.image_mask
                });
            }
        }
    },
    /**
     *   
     */
    afterAction: function(action, result) {
        var me = this;
        if (!result || result.error) {
            me.app.getController('Location').unmaskLocation();
        }
    },
    /**
     *     (   factory + doAction)
     */
    createAndInvoke: function(config, onsuccess, onerror) {
        var me = this,
            action = me.factory(config);
        if (!action.error) {
            action.doAction(function(res) {
                if (!res.error) {
                    if (onsuccess) {
                        onsuccess(res);
                    }
                } else {
                    if (onerror) {
                        onerror(res.error);
                    }
                }
            });
        } else {
            if (onerror) {
                onerror(action.error);
            }
        }
    },
    invokeRoomAction: function(action, callback) {
        var me = this,
            locationController = me.app.getController('Location');
        action.service.init(null, function(service) {
            if (!service.error) {
                callback(action);
            } else {
                callback({
                    error: service.error
                });
            }
        });
    },
    invokeLinkAction: function(action, callback) {
        var me = this;
        return;
    },
    //       ,   
    invokeMapAction: function(action, callback) {
        var me = this;
        action.service.init(null, function(service) {
            if (!service.error) {
                if (action.options.selected_target) {
                    service.mapAction.set('selected_target', action.options.selected_target);
                }
                me.app.getController('Action').doAction(service.mapAction, callback);
            } else {
                callback({
                    error: service.error
                });
            }
        });
    },
    invokeCommandAction: function(action, callback) {
        var me = this,
            command = action.service.info.params.command,
            cmd = command ? command.split(':')[0] : null,
            param = command ? command.split(':')[1] : null;
        switch (cmd) {
            case 'show_chat':
                if (!ExGods.app.user.isChatOn()) {
                    ExGods.app.getChatController().chatOn();
                };
                var chatTabs = Ext.getCmp('chat-tab-panel');
                if (param) {
                    chatTabs.setActiveTab(param);
                };
                break;
            default:
                callback({
                    error: '  ' + cmd
                });
                break;
        }
    },
    invokeComponentAction: function(action, callback) {
        var me = this,
            component = Ext.getCmp(action.info.componentObjectName);
        if (!component) {
            ExGods.app.block();
            action.service.init(null, function(service) {
                ExGods.app.unblock();
                if (!service.error) {
                    component = ExGods.Components.factory(action.info.componentObjectName, {
                        clientAction: action,
                        service: service
                    });
                    if (component && !component.error) {
                        if (component.autoShow !== false && !component.rendered) {
                            component.show();
                        }
                        callback(action);
                    } else {
                        callback({
                            error: component ? component.error : '  .'
                        });
                    }
                } else {
                    callback({
                        error: service.error
                    });
                }
            });
        } else {
            if (action.src == 'menu' && component.isVisible()) {
                component.close();
            } else if (component.onClientAction) {
                component.onClientAction(action);
            } else {
                if (!component.isVisible()) {
                    component.show();
                }
            }
            callback(action);
        }
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.CSS', {
    extend: ExGods.controller.Base,
    init: function() {
        var me = this;
        me.initUserStyles();
        me.initItemsStyles();
        me.initStuffStyles();
    },
    /**
     * @private   
     *

        .exg-bgcolor-in-battle

     *
     */
    initUserStyles: function() {
        var me = this,
            constants = ExGods.ref('constants'),
            inBattleRgb = ExGods.util.Helper.hexToRgb(constants.get('bgcolor-in-battle').value),
            opacity = constants.get('bgcolor-opacity').value;
        if (inBattleRgb) {
            Ext.util.CSS.createStyleSheet([
                '.exg-bgcolor-in-battle { background: rgba(' + inBattleRgb.join(',') + ', ' + opacity + ');}'
            ].join(''));
        }
    },
    /**
     * @private   

        .item-grade-color-1
        .item-grade-color-2
        .item-grade-color-3
        .item-grade-color-4

     */
    initItemsStyles: function() {
        var me = this,
            styles = [];
        ExGods.ref('constants_list').item_grades.value.forEach(function(item, index) {
            styles.push('.item-grade-color-' + (index + 1) + '{color: ' + item + '}');
        });
        Ext.util.CSS.createStyleSheet(styles.join(''));
    },
    /**
     * @private   

        .exg-stuff-decorator-bonusstick-image
        .exg-stuff-decorator-salestick-image
        .exg-stuff-decorator-beststick-image

     */
    initStuffStyles: function() {
        var me = this,
            styles = [],
            images = ExGods.ref('images|common_text_images').image;
        styles.push('.exg-stuff-decorator-bonusstick-image {background-image: url(' + images.bonus_on_items + ')}');
        styles.push('.exg-stuff-decorator-salestick-image {background-image: url(' + images.sale + ')}');
        styles.push('.exg-stuff-decorator-beststick-image {background-image: url(' + images.best + ')}');
        Ext.util.CSS.createStyleSheet(styles.join(''));
    }
});

/**
 *   ""
 */
Ext.define('ExGods.view.plugin.LacePaperDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.lacepaperdeco',
    init: function(cmp) {
        Ext.override(cmp, {
            addTool: function(tools) {
                tools = [].concat(tools);
                Ext.Array.forEach(tools, function(tool) {
                    tool.height = 31;
                    tool.width = 32;
                });
                this.callParent(arguments);
            }
        });
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        cmp.addCls('lace-paper');
        if (cmp.header) {
            cmp.header.setHeight(0);
        }
        cmp.el.insertHtml('afterBegin', '<div class="lace-paper-part lace-paper-tl"></div>' + '<div class="lace-paper-part lace-paper-tm"></div>' + '<div class="lace-paper-part lace-paper-tr"></div>' + '<div class="lace-paper-part lace-paper-mr"></div>' + '<div class="lace-paper-part lace-paper-br"></div>' + '<div class="lace-paper-part lace-paper-bm"></div>' + '<div class="lace-paper-part lace-paper-bl"></div>' + '<div class="lace-paper-part lace-paper-ml"></div>' + '<div class="lace-paper-part lace-paper-bg"></div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addDeco, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'deco/lacepaper/scroll2_top_l.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_top_m.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_top_r.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_center_r.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_bottom_l.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_bottom_m.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_bottom_r.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_center_l.jpg',
                IMAGE_URL + 'deco/lacepaper/scroll2_center_m.jpg',
                IMAGE_URL + 'deco/lacepaper/bg_table_title_l.jpg',
                IMAGE_URL + 'deco/lacepaper/bg_table_title_r.jpg',
                IMAGE_URL + 'deco/lacepaper/bg_table_title_m.jpg'
            ]
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.AnnouncmentsView', {
    extend: Ext.panel.Panel,
    alias: 'widget.announcmentsview',
    data: {
        label: '',
        image: '',
        link: '',
        start_date: ''
    },
    id: 'announcments-view',
    plugins: [
        {
            ptype: 'lacepaperdeco'
        }
    ],
    margin: '0 6 0 6',
    minHeight: 200,
    bodyPadding: '0 0 25 0',
    layout: 'fit',
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<tpl if="label">',
            '<h1 class="paper-title">{label}<span class="date">{[this.printDate(values.start_date)]}</span></h1>',
            '<div class="image">',
            '<img src="' + IMAGE_URL + '{image}"/>',
            '</div>',
            '<a target="_blank" href="{link}">' + ExGods.getMsgByKey('view_anons_more') + '</a>',
            '<tpl else>',
            //
            '</tpl>',
            {
                printDate: function(date) {
                    date = Ext.Date.parse(date, "Y-m-d H:i:s");
                    return Ext.Date.format(new Date(date), "d.m.Y H:i");
                }
            }
        ];
        me.callParent(arguments);
    },
    updateView: function(data) {
        var me = this,
            img,
            _update = function() {
                me.update(data);
                me.fireEvent('viewupdate', me);
            };
        if (data.image) {
            //   ,         
            img = new Image();
            img.onload = _update;
            img.src = IMAGE_URL + data.image;
        } else {
            _update();
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Announcments', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: true,
            error: true
        },
        prefix: 'Announcments:'
    },
    views: [
        'AnnouncmentsView'
    ],
    refs: [
        {
            ref: 'announcmentsView',
            selector: '#announcments-view'
        }
    ],
    init: function() {
        var me = this;
        me.announcments = [];
        me.current = 0;
        me.startRerollInterval();
        var chatConnection = ExGods.app.getChatConnection();
        chatConnection.addPingParam('announcements_last_time', function() {
            return me.lastTimeUpdate;
        });
        chatConnection.on({
            ping: me.onPing,
            scope: me
        });
        me.control({
            '#announcments-view': {
                afterrender: function() {
                    if (me.announcments.length) {
                        me.updateView();
                    }
                }
            }
        });
        me.callParent(arguments);
    },
    startRerollInterval: function() {
        var me = this;
        me.rerollAnnounceTimer = setInterval(function() {
            if (me.announcments.length) {
                if (me.current >= me.announcments.length - 1) {
                    me.current = 0;
                } else {
                    me.current++;
                }
                me.updateView();
            }
        }, ExGods.ref('constants|announcments_reroll_interval').value);
    },
    updateAnnouncments: function(data, lastTimeUpdate) {
        var me = this;
        me.announcments = data;
        me.lastTimeUpdate = lastTimeUpdate;
        me.current = 0;
        me.updateView();
    },
    updateView: function() {
        var me = this,
            view = me.getAnnouncmentsView(),
            data = me.announcments[me.current];
        if (view && data) {
            view.updateView(data);
        }
    },
    onPing: function(data) {
        var me = this;
        if (data.announcements) {
            me.updateAnnouncments(data.announcements, data.announcements_last_time);
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.model.Arena', {
    extend: Ext.data.Model,
    idProperty: 'id',
    fields: [
        {
            //     
            name: 'can_unqueue',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            //  
            name: 'l_order',
            type: 'int'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            //        
            name: 'stuff_cost',
            type: 'auto'
        },
        {
            //    
            name: 'stuff_refuse',
            type: 'auto'
        },
        {
            //      
            name: 'wait_queue',
            type: 'int'
        },
        {
            //     
            name: 'wait_ready',
            type: 'int'
        },
        {
            //    
            name: 'queue_time',
            type: 'string'
        },
        {
            //    ( ,    )
            name: 'ready_time',
            type: 'string'
        },
        {
            //   - wait, queue, ready, accept, start
            name: 'state',
            type: 'string',
            convert: function(v, data) {
                if (v) {
                    return v;
                } else {
                    if (data.data.queue_time) {
                        return 'queue';
                    } else if (data.data.ready_time) {
                        return 'ready';
                    } else if (data.data.accepted) {
                        return 'accept';
                    } else {
                        return 'wait';
                    }
                }
            }
        },
        {
            //      {elo: .., rival:..}
            name: 'info',
            type: 'auto',
            defaultValue: {},
            convert: function(v, r) {
                if (v && v.rival) {
                    var arr_stuff = r.getRivalStuff(v.rival);
                    r.set({
                        'rival_stuff': arr_stuff,
                        'rival_image': r.getUserImages(v.rival)
                    });
                }
                return v;
            }
        },
        {
            name: 'message',
            type: 'string'
        },
        {
            //   
            name: 'season',
            type: 'int'
        },
        {
            //   
            name: 'elo_value',
            type: 'int'
        },
        {
            //   
            name: 'finish_date',
            type: 'string'
        },
        {
            //  
            name: 'rating_top_list',
            type: 'auto'
        },
        {
            //    
            name: 'rating_info',
            type: 'auto'
        },
        {
            //   
            name: 'foes',
            type: 'auto',
            defaultValue: []
        },
        {
            //    
            name: 'rank_rewards',
            type: 'auto'
        },
        {
            //   
            name: 'series',
            type: 'auto',
            convert: function(v) {
                if (!v) {
                    v = {
                        koef: 0,
                        counter: 0
                    };
                } else if (v.counter == null) {
                    v.counter = 0;
                }
                return v;
            }
        },
        {
            //      (,   -  ,   1  0)
            name: 'trophy_reward',
            type: 'auto'
        },
        {
            name: 'shop_service',
            type: 'int'
        },
        {
            name: 'rival_stuff',
            type: 'auto'
        },
        {
            name: 'rival_image',
            type: 'auto'
        }
    ],
    /**
     *   
     *
     * @param {Object} rival   
     * return {string} 
     */
    getUserImages: function(data) {
        if (typeof data.shape == 'object') {
            if (/^http/.test(data.shape.small)) {
                return [
                    data.shape.small
                ];
            } else {
                return [
                    IMAGE_URL + data.shape.small
                ];
            }
        } else {
            return [
                ExGods.ref('user_shape|' + data.shape).thumb
            ];
        }
    },
    /**
     *    getResources()
     *
     * @param {Object} rival   
     * return {} 
     */
    getRivalStuff: function(rival) {
        var stuff_arr = [];
        //    ,    
        if (rival) {
            for (var i = 0; i < rival.slots.length; i++) {
                for (var j = 0; j < rival.slots[i].items.length; j++) {
                    var obj = rival.slots[i].items[j];
                    stuff_arr.push({
                        params: {
                            id: obj.proto_id,
                            quantity: 1
                        },
                        type: 'item'
                    });
                }
            }
            if (rival.mask_proto_id) {
                stuff_arr.push({
                    params: {
                        id: rival.mask_proto_id,
                        quantity: 1
                    },
                    type: 'item'
                });
            }
        }
        return stuff_arr;
    }
});

/**
 *     
 */
(function() {
    Ext.define('ExGods.view.arena.ArenaSlotItems', {
        extend: Ext.panel.Panel,
        alias: 'widget.arenaslotitems',
        cls: 'arena-slots',
        /**
     * @cfg slots   (required)
     */
        slots: null,
        initComponent: function() {
            var me = this,
                arena = Ext.getCmp(me.parent_id).arena.data;
            me.slots = arena.info.rival.slots;
            me.items = [
                {
                    xtype: 'container',
                    height: 64,
                    items: [
                        new Slot({
                            slot: me.getSlotByType(2)
                        }),
                        new Slot({
                            slot: me.getSlotByType(5)
                        }),
                        new Slot({
                            slot: me.getSlotByType(1)
                        }),
                        new Slot({
                            slot: me.getSlotByType(8),
                            cls: 'slot last'
                        })
                    ],
                    margin: '0 0 2 0'
                },
                {
                    xtype: 'container',
                    height: 74,
                    items: [
                        new Slot({
                            slot: me.getSlotByType(13)
                        }),
                        new Slot({
                            slot: me.getSlotByType(12)
                        }),
                        new Slot({
                            slot: me.getSlotByType(4)
                        }),
                        new Slot({
                            slot: me.getSlotByType(11),
                            cls: 'slot last'
                        })
                    ]
                }
            ];
            me.callParent(arguments);
        },
        getSlotByType: function(type) {
            var me = this,
                slot;
            Ext.Array.each(me.slots, function(item) {
                if (item.type == type) {
                    slot = item;
                }
            });
            return slot;
        }
    });
    var Slot = Ext.define(null, {
            extend: 'Ext.Component',
            slot: {},
            cls: 'slot',
            initComponent: function() {
                var me = this,
                    info = ExGods.ref('slot_type|' + me.slot.type);
                me.tpl = [
                    '<div class="slot-inner" style="background-image: url(' + info.images.empty + ')">',
                    '<tpl if="item">',
                    '{[ExGods.stuff.StuffManager.image(values.item)]}',
                    '</tpl>',
                    '</div>'
                ];
                me.data = {};
                if (me.slot.items.length) {
                    me.data.item = {
                        type: 'iteminstance',
                        params: {
                            itemModel: new ExGods.model.Item(me.slot.items[0])
                        }
                    };
                }
                me.callParent(arguments);
            }
        });
}());

/**
 *   ,     textbutton
 */
(function() {
    Ext.define('ExGods.view.TimedTimer', {
        extend: Ext.Component,
        alias: 'widget.timedtimer',
        cls: 'timedtimer',
        /**
     * @cfg
     * Object
     *    
     */
        textbutton: undefined,
        /**
     * @cfg
     * Object
     *    
     */
        buybutton: undefined,
        /**
     * @cfg
     * required
     * String
     *  ,  
     */
        timed: undefined,
        /**
     * @cfg
     * Number
     *      
     */
        quantity: 1,
        /**
     * @cfg
     * Boolean
     *      
     * default:true
     */
        checkUser: true,
        width: 85,
        initComponent: function() {
            var me = this,
                proto = ExGods.ref('user_timed|' + me.timed),
                timed = ExGods.app.user.get('timed')[me.timed];
            me.itemId = me.itemId || Ext.id();
            me.html = '<div class="stuff"></div>' + '<div class="stuff-timer"></div>' + '<div class="timedtimer-btn" id="timedtimer-btn-' + me.itemId + '"></div>' + '<div class="timedtimerbuy-btn" id="timedtimerbuy-btn-' + me.itemId + '"></div>' , me.stuff = [
                {
                    params: {
                        id: me.timed,
                        quantity: me.quantity
                    },
                    type: 'timed'
                }
            ];
            if (!proto || !timed) {
                console.error('   ');
                me.callParent(arguments);
                return;
            }
            if (proto.price.length)  {
                me.price = proto.price;
            }
            
            me.callParent(arguments);
            me.on('afterrender', function() {
                if (me.textbutton)  {
                    me.renderBtn();
                }
                
                me._printStuff();
                me._setState();
                var user = ExGods.app.getUser();
                me.updateTimed(user.get('timed')[me.timed], true);
                ExGods.app.getUser().on(me.timed + 'changed', function() {
                    me.updateTimed.apply(me, arguments);
                });
            });
        },
        //me.updateData();
        //ExGods.util.Ticker.addListener(me.updateData, me);
        renderBtn: function() {
            var me = this;
            me.textbutton = Ext.widget('textbutton', Ext.apply({
                renderTo: 'timedtimer-btn-' + me.itemId,
                cls: 'x-btn-txt-red double_text_btn' + (me.qh ? ' qh-object' : ''),
                text: ExGods.getMsgByKey('arena_go_battle_btn_title'),
                width: (this.width - 1) + 'px',
                minWidth: (this.width - 1),
                disabled: me.is_disabled || !ExGods.app.user.checkStuff(me.stuff)
            }, me.textbutton));
            me.buybutton = Ext.widget('textbutton', Ext.apply({
                renderTo: 'timedtimerbuy-btn-' + me.itemId,
                cls: 'x-btn-txt-red double_text_btn' + (me.qh ? ' qh-object' : ''),
                text: ExGods.getMsgByKey('arena_go_battle_btn_title'),
                width: (this.width - 1) + 'px',
                minWidth: (this.width - 1),
                hidden: true,
                //disabled:!ExGods.app.user.checkStuff(me.price),
                handler: me.buyTimed.bind(me)
            }, me.buybutton));
            if (me.qh)  {
                me.textbutton.el.set(me.qh);
            }
            
        },
        buyTimed: function(btn) {
            var me = this;
            new BuyTimedConfirmationInner({
                timed: me.timed,
                onSuccess: function() {
                    me._printStuff();
                    me._setState();
                }
            });
        },
        updateTimed: function(timed, value_changed) {
            var me = this,
                time = new Date(timed[3]) - new Date() + 1000;
            // 
            if (!me.el || !me.el.dom)  {
                return;
            }
            
            var el = me.el.down('.stuff-timer');
            time = Math.max(1, time / 1000);
            if (timed[3] && timed[0] != timed[1]) {
                el.setStyle({
                    opacity: 1
                });
                el.setHTML(ExGods.util.Time.printTime(time, {
                    format: 'twonums'
                }));
            } else {
                el.setStyle({
                    opacity: 0
                });
            }
            if (value_changed) {
                me._printStuff();
                me._setState();
            }
        },
        setDisable: function() {
            this.is_disabled = true;
            this._setState();
        },
        setEnable: function() {
            this.is_disabled = false;
            this._setState();
        },
        updateQuantity: function(quantity) {
            var me = this;
            me.stuff[0].params.quantity = Number(quantity);
            me._printStuff();
            me.textbutton[ExGods.app.user.checkStuff(me.stuff) ? 'enable' : 'disable']();
        },
        onDestroy: function() {
            var me = this;
            //ExGods.util.Ticker.removeListener(me.updateData);
            me.callParent(arguments);
        },
        _printStuff: function() {
            var me = this,
                proto = ExGods.ref('user_timed|' + me.timed),
                timed = ExGods.app.user.get('timed')[me.timed],
                curTimed = Math.floor(timed[0]),
                image = IMAGE_URL + proto.img.img2,
                label = proto.img.label,
                desc = proto.img.desc;
            /**
         * timed - array
         * timed[0] - Math.floor -  
         * timed[1] -  
         * timed[2] -   (   )
         * timed[3] -   +1 ( 1426066955)
         */
            var html = '<div class="info-box-itembox item exgtip" data-big_stuff_id="' + me.timed + '" data-big_stuff_value="' + curTimed + '" data-big_stuff_type="timed" data-exgtip_type="timed" data-exgtip_value="' + me.timed + '">' + '<div class="item-img" style="background-image:url(' + image + ')">' + '<span class="stack-counter big_counter"><span class="big_counter_mid">' + curTimed + '/' + timed[1] + '</span></span>' + '</div>' + '</div>';
            this.el.down('.stuff').setHTML(html);
        },
        _setState: function() {
            var me = this,
                hasStuff = ExGods.app.user.checkStuff(me.stuff),
                enabled = hasStuff && !me.is_disabled;
            me.textbutton[enabled ? 'enable' : 'disable']();
            if (!hasStuff && me.price) {
                me.textbutton.hide();
                me.buybutton.show();
            } else {
                me.buybutton.hide();
                me.textbutton.show();
            }
            if (me.el) {
                var clsArr = me.el.dom.className.split(' ');
                if (enabled && clsArr.indexOf('disabled') != -1) {
                    me.el.removeCls('disabled');
                } else if (!enabled && clsArr.indexOf('disabled') == -1) {
                    me.el.addCls('disabled');
                }
            }
        },
        getResources: function() {
            var me = this;
            return {
                stuff: me.stuff
            };
        }
    });
    /**
 *   -     -
 */
    var BuyTimedConfirmationInner = Ext.define(null, {
            /**
     * @cfg {String} timed  
     */
            timed: '',
            /**
     * @cfg {Function} onSuccess   
     */
            onSuccess: Ext.emptyFn,
            constructor: function(config) {
                var me = this,
                    proto = ExGods.ref('user_timed|' + config.timed);
                if (proto) {
                    if (proto.extra.guild_request_id) {
                        if (ExGods.app.user.get('binding').guild) {
                            ExGods.app.block();
                            ExGods.Services.get('guilds').command('create_request', {
                                type: proto.extra.guild_request_id,
                                only_check: 1
                            }, function(resp) {
                                ExGods.app.unblock();
                                me.showPriceAndRequestConfirmation(proto.extra.guild_request_id, resp, proto.price);
                            });
                        } else {
                            me.showPriceAndRequestConfirmation(proto.extra.guild_request_id, null, proto.price);
                        }
                    } else if (proto.price.length) {
                        me.showPriceConfirmation(proto.price);
                    }
                }
                Ext.apply(me, config || {});
                me.callParent(arguments);
            },
            showPriceConfirmation: function(price) {
                var me = this;
                Ext.widget('confirmdialog', {
                    message: ExGods.app.applyTpl(ExGods.getMsgByKey('buy_timed'), {
                        cost: ExGods.util.Stuff.printStuff(price)
                    }),
                    handler: function() {
                        ExGods.Services.get('inventory').command('buy_timed', {
                            stat_name: me.timed
                        }, function() {
                            me.onSuccess();
                        });
                    }
                });
            },
            showPriceAndRequestConfirmation: function(requestId, requestData, price) {
                var me = this,
                    timerId = 'buy-timed-request-button-timer',
                    timeoutDate, requestBtn, buyBtn, requestBtnText, requestBtnCls, win;
                if (!requestData) {
                    //    
                    requestBtnText = ExGods.getMsgByKey('buy_timed_request_btn_text_3');
                    requestBtnCls = 'no_border_double double_text';
                } else if (requestData.timeout > 0) {
                    //   ,     
                    timeoutDate = Ext.Date.add(new Date(), Ext.Date.SECOND, requestData.timeout);
                    requestBtnText = ExGods.app.applyTpl(ExGods.getMsgByKey('buy_timed_request_btn_text_2'), {
                        counter: ExGods.util.Timers.printTimer('rest', timerId, timeoutDate, {
                            needNormalized: false
                        })
                    });
                    requestBtnCls = 'no_border_double double_text';
                } else {
                    //        
                    requestBtnText = ExGods.getMsgByKey('buy_timed_request_btn_text_1');
                    requestBtnCls = 'no_border_double double_text';
                }
                requestBtn = Ext.widget('textbutton', {
                    width: 160,
                    cls: requestBtnCls,
                    text: requestBtnText,
                    margin: '0 0 0 10',
                    disabled: (!requestData || requestData.success != 1 || requestData.timeout > 0),
                    handler: function() {
                        ExGods.app.block();
                        ExGods.Services.get('guilds').command('create_request', {
                            type: requestId
                        }, function(resp) {
                            ExGods.app.unblock();
                            win.close();
                            me.onSuccess();
                        });
                    }
                });
                requestBtn.mon(ExGods.util.Timers, timerId + '-expire', function() {
                    requestBtn.setDisabled(false);
                    requestBtn.removeCls('double_text');
                    requestBtn.setText(ExGods.getMsgByKey('buy_timed_request_btn_text_1'));
                });
                buyBtn = Ext.widget('textbutton', {
                    width: 160,
                    cls: 'no_border_double',
                    text: ExGods.app.applyTpl(ExGods.getMsgByKey('buy_timed_buy_btn_text'), {
                        cost: ExGods.util.Stuff.printStuff(price)
                    }),
                    margin: '0 10 0 0',
                    hidden: !price,
                    handler: function() {
                        ExGods.Services.get('inventory').command('buy_timed', {
                            stat_name: me.timed
                        }, function() {
                            win.close();
                            me.onSuccess();
                        });
                    }
                });
                var win = Ext.widget('commonwindow', {
                        width: 450,
                        bodyStyle: 'text-align: center; line-height: 18px; overflow: visible;',
                        bodyPadding: '20 0',
                        buttonAlign: 'center',
                        y: 260,
                        //     
                        html: ExGods.getMsgByKey('buy_timed_with_request'),
                        autoShow: true,
                        buttons: [
                            buyBtn,
                            requestBtn
                        ]
                    });
            }
        });
}());

/**
 *  -        
 */
Ext.define('ExGods.view.arena.Arena', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena',
    plugins: [
        'paperdeco'
    ],
    /**
     * @cfg {Object} arena  
     */
    arena: {},
    /**
     * @cfg {Object} service  
     */
    service: {},
    cls: 'arena arenaview',
    /**
     * @cfg clientObject {Object}     -
     */
    clientObject: {},
    //  
    animationSpeed: 1000,
    //ms
    initComponent: function() {
        var me = this;
        me.data = me.arena.data;
        me.tpl = [
            '<div class="section section1">',
            '<div class="paper-title title">',
            '<tpl if="(info && info.rival) || this.isQueueState(values) || !this.hasArenaShop()">',
            '<h4>' + ExGods.getMsgByKey('view_arena_arena_enemy_title') + '</h4>',
            '<tpl else>',
            '<h4>' + ExGods.getMsgByKey('arena_hint_title') + '</h4>',
            '</tpl>',
            '</div>',
            '<div class="content"><div style="text-align: center">',
            '<tpl if="info && info.rival">',
            '<div class="enemy-info">',
            '<div class="exg-share-base-info exg-share-bg-light">',
            '<span>{[ ExGods.printUser(values.info.rival, {fields: "name,rank", maxNameWidth: 112})]}</span>',
            '<span>{[this.printTrophy(values.info.rival.elo || [],true)]}</span>',
            '<span>{[this.printTrophy(values.info.rival.elo_value || 0,true)]}</span>',
            '<div class="image-frame" style="background-image: url({[ this.getUserImage(values.info.rival) ]})"></div>',
            '</div>',
            '<div class="stats-title exg-share-bg-dark">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
            '<div class="stats1 exg-share-bg-light">',
            '{[ ExGods.util.User.printUserStats(values.info.rival.stats.stats, {visibleValue: 1, align: "right", changes: this.getStatsChanges(values.info.rival.stats.stats)}) ]}',
            '</div>',
            '<tpl if="this.getMaskLabel(values.info.rival)">',
            '<div class="stats-title exg-share-bg-dark">{[this.getMaskLabel(values.info.rival)]}</div>',
            '</tpl>',
            '<div class="stats2 exg-share-bg-light">',
            '{[ ExGods.util.User.printUserStats(values.info.rival.stats.stats, {visibleValue: 2, changes: this.getStatsChanges(values.info.rival.stats.stats)}) ]}',
            '</div>',
            '</div>',
            '<tpl elseif="this.isQueueState(values)">',
            '<div class="queue-timer" id="arena-queue-time-{id}">',
            '{[this.printQueuePercent(values)]}',
            '{[this.printQueueTime(values)]}',
            '<div class="queue-separators"></div>',
            '</div>',
            '<tpl elseif="this.hasArenaShop()">',
            '<p class="hint">',
            '{[this.getHint()]}',
            '</p>',
            '<tpl if="this.getHasShopItems().length">',
            '<ul class="shop-items-list exg-share-bg-dark">',
            '<tpl foreach="this.getHasShopItems()">',
            '<li class="shop-items-list-item" data-id="{id}" style="background-image: url(' + IMAGE_URL + '{desc.img});"><div>{[this.printHasItemEndTimed(values.end)]}</div></li>',
            '</tpl>',
            '</ul>',
            '<tpl else>',
            '<div class="no-shop-items exg-share-bg-dark">',
            ExGods.getMsgByKey('arena_has_no_items_text'),
            '</div>',
            '</tpl>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena_show_shop</span>',
            '<span role="arena_id">{id}</span>',
            '<span role="text">',
            ExGods.getMsgByKey('arena_go_shop_btn_title'),
            '</span>',
            '<span role="cls">x-btn-txt double_text_btn goto-shop-btn</span>',
            '<span role="flex:int">1</span>',
            '<span role="margin">3 5 0 0</span>',
            '<span role="width">116px</span>',
            '<span role="disabled:bool">1</span>',
            '</div>',
            '<tpl else>',
            '<div class="queue-timer"></div>',
            '</tpl>',
            '</div>',
            '</div>',
            '</div>',
            '<div class="v-separator"></div>',
            '<div class="section section2" style="height: {[ values.info && values.info.rival ? 165 : 143 ]}px;">',
            '<div class="paper-title title">',
            '<tpl if="info && info.rival">',
            '<h4>' + ExGods.getMsgByKey('view_arena_arena_enemy_equipment') + '</h4>',
            '<tpl else>',
            '<h4>{[this.printArenaTitle(values)]}</h4>',
            '</tpl>',
            '</div>',
            '<div class="content">',
            '<tpl if="info && info.rival">',
            '<tpl if="info.rival.data && info.rival.data.app">',
            '<div class="social-rival-message">' + me.clientObject.social_rival_text + '</div>',
            '<tpl elseif="info.rival.slots">',
            '<div class="slots">',
            '<div class="component">',
            '<span role="xtype">arenaslotitems</span>',
            '<span role="parent_id">' + me.id + '</span>',
            '</div>',
            '</div>',
            '<tpl else>',
            //
            '</tpl>',
            '<tpl else>',
            '<div class="rules">',
            '{[ this.getDescription(values) ]}',
            '</div>',
            '<div class="awards">',
            '{[ this.getAwards(values) ]}',
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            '<tpl if="info && info.rival">',
            '<div class="separator"></div>',
            '<tpl else>',
            '<div class="separator" style="top: 146px;"></div>',
            '<div class="section section3">',
            '{[ this.printSeriesInfo(values) ]}',
            '</div>',
            '</tpl>',
            '<div class="separator separator2"></div>',
            '<div class="section section4">',
            '<tpl if="info && info.rival">',
            '<div class="paper-title title">',
            '<h4>' + ExGods.getMsgByKey('arena_rewards_title') + '</h4>',
            '</div>',
            '</tpl>',
            '<div class="content">',
            '<tpl if="info && info.rival">',
            '<tpl if="info.elo && info.elo.length">',
            '<div class="rewards">',
            '<span class="reward"><strong>' + ExGods.getMsgByKey('view_arena_arena_for_win') + ' </strong><span style="color: #008C00;">{[this.printTrophy("+" + values.info.elo[0].win)]}</span></span>',
            '<span class="reward"><strong>' + ExGods.getMsgByKey('view_arena_arena_for_lose') + ' </strong><span style="color: #ff0000;">{[this.printTrophy(""  + values.info.elo[0].lose)]}</span></span>',
            '</div>',
            '</tpl>',
            '<div class="component">',
            '<span role="xtype">container</span>',
            '<span role="layout">',
            '<span role="type">hbox</span>',
            '<span role="align">middle</span>',
            '</span>',
            '<span role="padding">0 10</span>',
            '<ul role="items">',
            '<li>',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena_accept</span>',
            '<span role="arena_id">{id}</span>',
            '<span role="text">',
            '<tpl if="this.isAcceptState(values)">',
            Ext.String.format(ExGods.getMsgByKey('view_arena_start_text_1'), '<b id="arena-ready-time-{id}">{[this.printReadyTime(values)]}</b>'),
            '<tpl else>',
            Ext.String.format(ExGods.getMsgByKey('view_arena_start_text_2'), '<b id="arena-ready-time-{id}">{[this.printReadyTime(values)]}</b>'),
            '</tpl>',
            '</span>',
            '<span role="cls">x-btn-txt-red no_border_double</span>',
            '<span role="flex:int">1</span>',
            '<span role="margin">0 5 0 0</span>',
            '<span role="disabled:bool">{[this.isAcceptState(values)]}</span>',
            '</li>',
            '<li>',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena_refuse</span>',
            '<span role="arena_id">{id}</span>',
            '<span role="text">' + ExGods.getMsgByKey('view_arena_arena_new_enemy_btn') + ' {[ExGods.util.Stuff.printStuff(values.stuff_refuse)]}</span>',
            '<span role="cls">no_border_double double_text</span>',
            '<span role="disabled:bool">{[this.isAcceptState(values)]}</span>',
            '<span role="flex:int">1</span>',
            '</li>',
            '</ul>',
            '</div>',
            '<tpl else>',
            '<span class="description">' + ExGods.getMsgByKey('arena_go_battle_description') + '</div>',
            '<div class="v-separator"></div>',
            '<tpl if="this.isQueueState(values)">',
            '<div class="component battle-btn">',
            '<tpl else>',
            '<div class="component battle-btn qh-object" data-qh_otype="arena_button_battle" data-qh_oid="1">',
            '</tpl>',
            '<span role="xtype">timedtimer</span>',
            '<span role="timed">{stuff_cost.params.id}</span>',
            '<span role="quantity">{stuff_cost.params.quantity}</span>',
            '<span role="is_disabled:bool">{[this.isQueueState(values) || this.isAcceptState(values)]}</span>',
            '<span role="textbutton">',
            '<span role="action">arena_queue</span>',
            '<span role="arena_id">{id}</span>',
            '</span>',
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            {
                printArenaTitle: function(data) {},
                // var me = this,
                //  tpl = ExGods.getMsgByKey('arena_title'),
                //  dt = ExGods.util.Date.normalizeServerDateTime(data.finish_date);
                // tpl = tpl.replace('{time}', '<span id="arena-finish-season-rest-time-{id}" style="font-weight: bold;">'+
                //      ExGods.util.Time.printRestTime(dt, {format: 'threenums', emptyText: ExGods.getMsgByKey('arena_season_finish_msg'), stringFormat: ExGods.getMsgByKey('view_arena_arenaseasontimeoutformat')}) +
                //  '</span>');
                // return ExGods.app.applyTpl(tpl, data);
                hasArenaShop: function() {
                    return me.service.data.arena_shop && me.service.data.arena_shop.types.length;
                },
                getHint: function() {
                    if (me.service.data.arena_shop.has && me.service.data.arena_shop.has.length && me.service.data.arena_shop.has.length > 6) {
                        return '';
                    } else {
                        return ExGods.getMsgByKey('arena_hint_text');
                    }
                },
                getHasShopItems: function() {
                    if (Ext.isArray(me.service.data.arena_shop.has)) {
                        return me.service.data.arena_shop.has.slice(0, 9);
                    } else {
                        return me.service.data.arena_shop.has;
                    }
                },
                printHasItemEndTimed: function(date) {
                    if (date) {
                        date = ExGods.util.Date.normalizeServerDateTime(date);
                        return '<span class="exg-timer" data-date="' + date + '" data-format="twonums">' + ExGods.util.Time.printRestTime(date, {
                            format: 'twonums'
                        }) + '</span>';
                    }
                },
                getAwards: function(data) {
                    var html = [],
                        trophyRewardsHash = data.trophy_reward || {},
                        rating, lowLevelRating, ratingReward;
                    ExGods.ref('user_trophy').each(function(key, value, myself) {
                        if (value.description.prize) {
                            var reward = '<div class="reward_container nonevented" data-id="' + key + '">' + '<img class="reward_img" src="' + IMAGE_URL + value.description.img + '" />' + '<div class="reward_name">' + '<img src="' + IMAGE_URL + 'icons/' + (trophyRewardsHash[value.level] == "1" ? 'done.png' : 'undone.png') + '"/>' + value.description.label + '</div>' + '</div>';
                            html.push(reward);
                        }
                    });
                    // ,     
                    Ext.Object.each(me.arena.data.rank_rewards, function(key, value, myself) {
                        if (me.arena.data.rating_info && value.start <= me.arena.data.rating_info.rank && me.arena.data.rating_info.rank <= value.end) {
                            rating = {
                                key: key,
                                value: value
                            };
                        }
                        if (!lowLevelRating || lowLevelRating.value.start < value.start) {
                            lowLevelRating = {
                                key: key,
                                value: value
                            };
                        }
                    });
                    rating = rating || lowLevelRating;
                    ratingReward = '<div class="reward_container nonevented rankreward" data-id="' + rating.key + '">' + '<img class="reward_img" src="' + IMAGE_URL + rating.value.image + '" />' + '<div class="reward_name">' + ((me.arena.data.rating_info && (rating.value.start <= me.arena.data.rating_info.rank) && (me.arena.data.rating_info.rank <= rating.value.end)) ? '<img src="' + IMAGE_URL + 'icons/done.png"/>' : '<img src="' + IMAGE_URL + 'icons/undone.png"/>') + rating.value.label + '</div>' + '</div>';
                    html.push(ratingReward);
                    return html.slice(0, 5).join('');
                },
                // max 5 elements
                getDescription: function(data) {
                    return ExGods.app.applyTpl(data.description, {
                        u: ExGods.app.user.data
                    });
                },
                isQueueState: function(data) {
                    return data.state == 'queue';
                },
                isAcceptState: function(data) {
                    return data.state == 'accept';
                },
                printQueueTime: function(data) {
                    var queueDate = ExGods.util.Date.normalizeServerDateTime(data.queue_time),
                        queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), data.wait_queue);
                    x = (queueTime % 9) * 103 + 36 , y = Math.floor(queueTime / 9) * 104 + 36;
                    return '<div class="queue-timer-value" style="background-position:-' + x + 'px -' + y + 'px"></div>';
                },
                printQueuePercent: function(data) {
                    var queueDate = ExGods.util.Date.normalizeServerDateTime(data.queue_time),
                        queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), data.wait_queue);
                    queuePercent = Math.min(Math.floor(queueTime * 100 / data.wait_queue), 100) , x = (queuePercent % 9) * 103 + 10 , y = Math.floor(queuePercent / 9) * 104 + 10;
                    return '<div class="queue-timer-counter" style="background-position:-' + x + 'px -' + y + 'px"></div>';
                },
                printReadyTime: function(data) {
                    var readyDate = ExGods.util.Date.normalizeServerDateTime(data.ready_time),
                        readyTime = Math.max(0, data.wait_ready * 1000 - (Date.now() - readyDate));
                    return ExGods.util.Time.printTime(readyTime / 1000, {
                        format: 'detailed',
                        emptyText: '..'
                    });
                },
                printRestTime: function(data) {
                    var dt = ExGods.util.Date.normalizeServerDateTime(data.finish_date);
                    return ExGods.util.Time.printRestTime(dt, {
                        format: 'threenums',
                        emptyText: ExGods.ref('message_client|arena_season_finish_msg')
                    });
                },
                getMaskLabel: function(data) {
                    var proto = ExGods.app.getItemPrototypesStore().data.getByKey(parseInt(data.mask_proto_id));
                    if (proto) {
                        return Ext.String.htmlEncode(proto.data.title);
                    }
                },
                printSeriesInfo: function(data) {
                    return ExGods.Tooltips.createTip({
                        tag: 'span',
                        type: 'text',
                        value: 'arena-series-descr',
                        html: ExGods.app.applyTpl(ExGods.getMsgByKey('arena_series_str'), data.series)
                    });
                },
                printTrophy: function(num, printDelta) {
                    var user = ExGods.app.getUser(),
                        html = '';
                    if (Ext.isArray(num)) {
                        Ext.Array.each(num, function(el) {
                            for (var key in el) {
                                var eloRef = ExGods.references.get('user_elo').get(key),
                                    userElo = user.get('elo')[key];
                                if (eloRef) {
                                    html += '<span class="trophy-num" style="background-image:url(' + IMAGE_URL + eloRef.image.img_3 + ')">' + el[key] + '</span>';
                                    if (el[key] != userElo && printDelta) {
                                        var cls = el[key] > userElo ? 'up' : 'down',
                                            sign = el[key] > userElo ? '+' : '';
                                        html += '<span class="changes"><small>(</small>' + '<span class="' + cls + '">' + sign + (el[key] - userElo) + '</span><small>)</small></span>';
                                    }
                                }
                            }
                        });
                    } else {
                        var trophy = user.get('hoard').trophy,
                            html = '<span class="trophy-num">' + num + '</span>';
                        if (num != trophy && printDelta) {
                            var cls = num > trophy ? 'up' : 'down',
                                sign = num > trophy ? '+' : '';
                            html += '<span class="changes"><small>(</small>' + '<span class="' + cls + '">' + sign + (num - trophy) + '</span><small>)</small></span>';
                        }
                    }
                    return html;
                },
                getUserImage: function(data) {
                    if (typeof data.shape == 'object') {
                        if (/^http/.test(data.shape.small)) {
                            return data.shape.small;
                        } else {
                            return IMAGE_URL + data.shape.small;
                        }
                    } else {
                        return ExGods.ref('user_shape|' + data.shape).thumb;
                    }
                },
                getStatsChanges: function(stats) {
                    //    
                    var changes = {},
                        myStats = ExGods.app.user.get('stats').stats;
                    Ext.Object.each(stats, function(k, v) {
                        if (typeof myStats[k] != 'undefined') {
                            changes[k] = v - myStats[k];
                        }
                    });
                    return changes;
                }
            }
        ];
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            me.section(1).renderComponents();
            me.section(2).renderComponents();
            me.section(4).renderComponents();
        }, me, {
            single: true
        });
        //     
        me.getEl().on('click', function(e) {
            var el = e.getTarget(),
                itemId = el.getAttribute('data-id'),
                itemInfo;
            itemInfo = Ext.Array.findBy(me.service.data.arena_shop.has, function(item) {
                return item.id == itemId;
            });
            Ext.widget('commondetailswindow', {
                itemElement: el,
                data: {
                    label: itemInfo.desc.label,
                    description: itemInfo.desc.description,
                    image: IMAGE_URL + itemInfo.desc.img
                }
            });
        }, me, {
            delegate: '.shop-items-list-item'
        });
        ExGods.util.Ticker.addListener(me.updateQueueTime, me);
        ExGods.util.Ticker.addListener(me.updateReadyTime, me);
        if (me.arena.data.finish_date) {
            ExGods.util.Ticker.addListener(me.updateFinishSeasonTime, me);
        }
        me.on('afterlayout', function() {
            if (this.getEl().down('.reward_container.nonevented')) {
                Ext.Array.each(this.getEl().query('.reward_container.nonevented'), function(item) {
                    var el = Ext.get(item);
                    el.removeCls('nonevented');
                    el.on('click', function() {
                        var item_object = this;
                        if (!el.hasCls('rankreward')) {
                            //   
                            var reward = ExGods.ref('user_trophy|' + item.getAttribute('data-id')).description;
                            var reward_items = reward.prize;
                        } else {
                            var reward = me.arena.data.rank_rewards[item.getAttribute('data-id')];
                            var reward_items = reward.stuff;
                        }
                        ExGods.Resources.loadStuff(reward_items, function() {
                            var wdj = Ext.widget('commondetailswindow', {
                                    itemElement: item_object,
                                    imageSize: 64,
                                    autoShow: false,
                                    data: {
                                        label: reward.label,
                                        description: reward.description,
                                        image: IMAGE_URL + (reward.image || reward.img),
                                        rows: [
                                            {
                                                title: ExGods.getMsgByKey('view_arena_arena_rewards'),
                                                cls: 'stuff-list',
                                                content: '<ul>' + ExGods.stuff.StuffManager.image(reward_items) + '</ul>'
                                            }
                                        ]
                                    }
                                });
                            ExGods.Resources.load(wdj, function() {
                                wdj.show();
                            });
                        });
                    });
                });
            }
        });
    },
    /**
     * @private  -     
     */
    section: function(sectionIndex) {
        var me = this,
            el = me.getEl().select('.section' + sectionIndex).elements[0],
            // dom el 
            components = [];
        return {
            setTitle: function(text) {
                Ext.fly(el).select('.title h4').setHTML(text);
                return this;
            },
            setContent: function(html) {
                Ext.fly(el).select('.content').setHTML(html);
                return this;
            },
            renderComponents: function() {
                ExGods.util.Helper.renderComponents(el, me);
                return this;
            },
            destroyComponents: function() {
                ExGods.util.Helper.destroyComponents(el);
                return this;
            }
        };
    },
    update: function(data) {
        var me = this;
        if (me.rendered) {
            me.section(1).destroyComponents();
            me.section(2).destroyComponents();
            me.section(4).destroyComponents();
        }
        me.arena.data = data;
        me.callParent(arguments);
        if (me.rendered) {
            me.section(1).renderComponents();
            me.section(2).renderComponents();
            me.section(4).renderComponents();
        }
    },
    updateQueueTime: function() {
        var me = this,
            viewEl = me.getEl(),
            queueDate, queueTime, queuePercent, el, val_el;
        if (me.arena.data.state == 'queue' && me.arena.data.queue_time) {
            queueDate = ExGods.util.Date.normalizeServerDateTime(me.arena.data.queue_time);
            //queueTime = Math.max(0, me.arena.data.wait_queue*1000 - (Date.now() - queueDate));
            queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), me.arena.data.wait_queue);
            queuePercent = Math.min(Math.floor(queueTime * 100 / me.arena.data.wait_queue), 99);
            if (viewEl) {
                el = viewEl.select('.queue-timer-counter');
                val_el = viewEl.select('.queue-timer-value');
                var x = (queuePercent % 9) * 103 + 10,
                    y = Math.floor(queuePercent / 9) * 104 + 10,
                    val_x = (queueTime % 9) * 103 + 36,
                    val_y = Math.floor(queueTime / 9) * 104 + 36;
                el.setStyle('background-position', '-' + x + 'px -' + y + 'px');
                val_el.setStyle('background-position', '-' + val_x + 'px -' + val_y + 'px');
            }
        }
    },
    updateReadyTime: function() {
        var me = this,
            viewEl = me.getEl(),
            readyDate, readyTime, el;
        if (me.arena.data.state == 'ready') {
            readyDate = ExGods.util.Date.normalizeServerDateTime(me.arena.data.ready_time);
            readyTime = Math.max(0, me.arena.data.wait_ready * 1000 - (Date.now() - readyDate));
            if (viewEl) {
                el = viewEl.select('#arena-ready-time-' + me.arena.data.id);
                el.setHTML(ExGods.util.Time.printTime(readyTime / 1000, {
                    format: 'detailed',
                    emptyText: '..'
                }));
            }
        }
    },
    updateFinishSeasonTime: function() {
        var me = this,
            viewEl = me.getEl(),
            finishDate = ExGods.util.Date.normalizeServerDateTime(me.arena.data.finish_date),
            el;
        if (finishDate && viewEl) {
            el = viewEl.select('#arena-finish-season-rest-time-' + me.arena.data.id);
            el.setHTML(ExGods.util.Time.printRestTime(finishDate, {
                format: 'threenums',
                emptyText: ExGods.ref('message_client|arena_season_finish_msg'),
                stringFormat: ExGods.getMsgByKey('view_arena_arenaseasontimeoutformat')
            }));
        }
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateQueueTime);
        ExGods.util.Ticker.removeListener(me.updateReadyTime);
        ExGods.util.Ticker.removeListener(me.updateFinishSeasonTime);
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [];
        var arr_images = [];
        if (me.data.rival_stuff) {
            stuff_arr = stuff_arr.concat(me.data.rival_stuff);
        }
        for (var i = 0; i < me.data.rank_rewards.length; i++) {
            arr_images.push(me.data.rank_rewards[i].image);
        }
        var img_user_rival = me.data.rival_image || [];
        return {
            stuff: [].concat(me.data.stuff_refuse.stuff).concat([
                me.data.stuff_cost
            ]).concat(stuff_arr),
            images: [
                IMAGE_URL + 'icons/done.png',
                IMAGE_URL + 'icons/undone.png',
                IMAGE_URL + 'btn_wide_standart.png',
                IMAGE_URL + 'button-text-30red.png'
            ].concat(arr_images).concat(ExGods.util.User.getUserStatImages()).concat(img_user_rival)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.arena.EnemyList', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena_enemylist',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'arena enemy-list',
    itemsPerPage: 3,
    textFilter: '',
    /**
     * @cfg {Array} list  
     */
    list: null,
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'container',
                layout: 'fit',
                height: 284,
                items: [
                    {
                        itemId: 'list',
                        cls: 'list',
                        tpl: [
                            '<tpl if="list && list.length">',
                            '<tpl for="list">',
                            '<div class="enemy-wrap">',
                            '<div class="paper paper-tl"></div>',
                            '<div class="paper paper-tm"></div>',
                            '<div class="paper paper-tr"></div>',
                            '<div class="paper paper-mr"></div>',
                            '<div class="paper paper-br"></div>',
                            '<div class="paper paper-bm"></div>',
                            '<div class="paper paper-bl"></div>',
                            '<div class="paper paper-ml"></div>',
                            '<div class="paper paper-bg"></div>',
                            '<div class="exg-share-base-info exg-share-bg-light gender-{gender}" style="background-image: url({[ this.getUserImage(values) ]})">',
                            '<span>{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank", maxNameWidth: 84})]}</span>',
                            '<span>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {hoard.level}</span>',
                            '<span>{[ this.printArenaRating(values) ]}</span>',
                            '<div class="image-frame"></div>',
                            '</div>',
                            '<div class="paper-separator" style="position: relative;"></div>',
                            '<h5 class="exg-share-bg-dark">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</h5>',
                            '<div class="stats1">',
                            '{[ ExGods.util.User.printUserStats(values.stats.stats, {visibleValue: 1, align: "right", changes: this.getStatsChanges(values)}) ]}',
                            '</div>',
                            '<div class="paper-separator" style="position: relative;"></div>',
                            '<div class="component">',
                            '<span role="xtype">textbutton</span>',
                            '<span role="cls">x-btn-txt-red no_border_double x-item-disabled ',
                            '<tpl if="can_revenge == 0">',
                            'x-disabled x-btn-disabled x-btn-txt-disabled',
                            '</tpl>',
                            '</span>',
                            '<span role="text">' + ExGods.getMsgByKey('view_arena_enemylist_revenge_btn') + '</span>',
                            '<span role="margin">9 0 0 0</span>',
                            '<span role="action">arena_revenge</span>',
                            '<span role="can_revenge">{can_revenge}</span>',
                            '<span role="arena_id">{parent.arena.id}</span>',
                            '<span role="user_title">{display_title}</span>',
                            '<span role="action">arena_revenge</span>',
                            '</div>',
                            '</div>',
                            '</tpl>',
                            '<tpl else>',
                            '<div class="empty-msg">' + ExGods.ref('message_client|arena_enemylist_empty_msg') + '</div>',
                            '</tpl>',
                            {
                                getUserImage: function(data) {
                                    return ExGods.ref('user_shape|' + data.shape).thumb;
                                },
                                printArenaRating: function(data) {
                                    var user = ExGods.app.getUser(),
                                        ratingName, ratingValue, eloRef, userElo,
                                        html = '';
                                    if (data.elo && data.elo.length) {
                                        ratingName = Object.keys(data.elo[0])[0];
                                        ratingValue = data.elo[0][ratingName];
                                        eloRef = ExGods.references.get('user_elo').get(ratingName);
                                        userElo = user.get('elo')[ratingName];
                                        if (eloRef) {
                                            html += '<span class="trophy-num" data-qtip="' + eloRef.label + '"style="background-image:url(' + IMAGE_URL + eloRef.image.img_3 + ')">' + ratingValue + '</span>';
                                            if (ratingValue != userElo) {
                                                var cls = ratingValue > userElo ? 'up' : 'down',
                                                    sign = ratingValue > userElo ? '+' : '';
                                                html += '<span class="changes"><small>(</small>' + '<span class="' + cls + '">' + sign + (ratingValue - userElo) + '</span><small>)</small></span>';
                                            }
                                        }
                                    }
                                    return html;
                                },
                                getStatsChanges: function(data) {
                                    var changes = {},
                                        myStats = ExGods.app.user.get('stats').stats;
                                    Ext.Object.each(data.stats.stats, function(k, v) {
                                        if (typeof myStats[k] != 'undefined') {
                                            changes[k] = v - myStats[k];
                                        }
                                    });
                                    return changes;
                                }
                            }
                        ],
                        data: {
                            arena: me.arena,
                            list: me.list ? me.list.slice(0, me.itemsPerPage) : null
                        }
                    }
                ]
            }
        ];
        me.plugins = me.plugins || [];
        me.plugins.push({
            ptype: 'pager',
            marginLeft: -27,
            marginRight: -27,
            top: 127,
            textTop: -32,
            textLeft: 249,
            total: Math.ceil((me.list ? me.list.length : 0) / me.itemsPerPage)
        });
        me.listeners = {
            prev: me.updateList,
            next: me.updateList,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me, {
            single: true
        });
    },
    setList: function(list) {
        var me = this;
        //      -  ,  
        me.list = Ext.Array.sort(list, function(a, b) {
            if (a.add_time > b.add_time) {
                return -1;
            } else if (b.add_time > a.add_time) {
                return 1;
            } else {
                return 0;
            }
        });
        ExGods.Resources.load({
            list: me.list,
            getResources: me.getResources
        }, function() {
            me.updateList();
        });
    },
    updateList: function() {
        var me = this,
            items = me.filtered || me.list;
        items = items.slice((me.pager.current - 1) * me.itemsPerPage, me.pager.current * me.itemsPerPage);
        me.items.items[0].getComponent('list').update({
            arena: me.arena,
            list: items
        });
        ExGods.util.Helper.renderComponents(me.el, me);
        me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        me.pager.refresh();
    },
    setTextFilter: function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        if (me.textFilter) {
            me.filtered = Ext.Array.filter(me.list, function(item) {
                return (item.display_title).toLowerCase().indexOf(me.textFilter) != -1;
            });
            me.pager.total = Math.ceil(me.filtered.length / me.itemsPerPage);
        } else {
            delete me.filtered;
            me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        }
        me.pager.current = 1;
        me.updateList();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        if (me.list) {
            for (var i = 0; i < me.list.length; i++) {
                arr_images.push(ExGods.ref('user_shape|' + me.list[i].shape).thumb);
            }
        }
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'btn_red_high.png'
            ].concat(arr_images).concat(ExGods.util.User.getUserStatImages())
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.arena.Rating', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena_rating',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'arena rating',
    itemsPerPage: 7,
    textFilter: '',
    /**
     * @cfg {Object} arena  
     */
    arena: {},
    /**
     * @cfg {Array} list 
     */
    list: [],
    initComponent: function() {
        var me = this;
        //   
        me.list = Ext.Array.sort(me.list, function(a, b) {
            return a.rank - b.rank;
        });
        me.items = [
            {
                xtype: 'container',
                plugins: [
                    'paperdeco'
                ],
                height: 284,
                items: [
                    {
                        itemId: 'list',
                        tpl: [
                            '<div class="paper-title title">',
                            '<tpl if="arena.season">',
                            '<h4>{[this.applyTitleTpl(values.arena)]}</h4>',
                            '<tpl else >',
                            '<h4>{[this.applyNoSeasonTpl(values.arena)]}</h4>',
                            '</tpl>',
                            '</div>',
                            '<div class="subtitle">{[this.applyTrophyTpl(values.arena)]}</div>',
                            '<div class="separator"></div>',
                            '<tpl if="list.length">',
                            '<table class="list">',
                            '<tpl for="list">',
                            '<tr class="{[ xindex % 2 ? "exg-share-bg-light" : "exg-share-bg-dark" ]}">',
                            '<td class="place-cell">',
                            '<tpl if="rank &gt;= 1 && rank &lt;= 3">',
                            '<div class="place-{rank}"><img width="76" height="24" src="{[ this.getPlaceImage(values.rank) ]}"></div>',
                            '<tpl else>',
                            '<span>{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('rating_place') + '",{place:values.rank})]}</span>',
                            '</tpl>',
                            '</td>',
                            '<td class="username-cell">',
                            '{[ ExGods.printUser(values.info, {fields: "name,rank,level,infoicon", maxNameWidth: 112}) ]}',
                            '</td>',
                            '<td class="count-cell">',
                            '{[this.printTrophy(values.value)]}',
                            '</td>',
                            '</tr>',
                            '</tpl>',
                            '</table>',
                            '<tpl else>',
                            '<div class="empty-msg">' + ExGods.ref('message_client|arena_rating_empty_msg') + '</div>',
                            '</tpl>',
                            {
                                applyTitleTpl: function(arena) {
                                    var strFin = ExGods.getMsgByKey('arena_season_finish_msg'),
                                        restTime = '';
                                    strFin = strFin.replace(/["]/g, "'");
                                    restTime = '<span id="arena-rating-rest-time-' + arena.id + '">' + ExGods.util.Timers.printRestTimer('arena-rating-rest-time-' + arena.id, arena.finish_date, {
                                        format: 'threenums',
                                        emptyText: strFin
                                    }) + '</span>';
                                    code = ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_title'), {
                                        season: arena.season,
                                        time: restTime
                                    });
                                    return code;
                                },
                                applyNoSeasonTpl: function(arena) {
                                    return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_no_season_title'), {
                                        label: arena.label
                                    });
                                },
                                applyTrophyTpl: function(arena) {
                                    if (arena.rating_info && arena.rating_info.value && arena.rating_info.rank) {
                                        var params = {
                                                place: arena.rating_info.rank,
                                                trophy: this.printTrophy(arena.rating_info.value) + Ext.util.Format.plural(arena.rating_info.value, ExGods.getMsgByKey('trophy_name').split(','))
                                            };
                                        if (arena.rating_top_list) {
                                            return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace'), Ext.apply({
                                                time: this.printDate(arena.rating_top_list.info.last_time)
                                            }, params));
                                        } else {
                                            return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace_no_time'), params);
                                        }
                                    } else if ((arena.elo_value || arena.elo_value == 0) && arena.rating_info && arena.rating_info.value != null) {
                                        var trophy = this.printTrophy(arena.rating_info.value) + Ext.util.Format.plural(arena.rating_info.value, ExGods.getMsgByKey('trophy_name').split(','));
                                        return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace_after_season'), {
                                            trophy: trophy
                                        });
                                    } else {
                                        return ExGods.getMsgByKey('view_arena_rating_curplace_no_trophy');
                                    }
                                },
                                printTrophy: function(num) {
                                    return '<span class="trophy-num">' + num + '</span>';
                                },
                                printDate: function(dateStr) {
                                    var dt = ExGods.util.Date.normalizeServerDateTime(dateStr);
                                    return Ext.Date.format(dt, 'd.m.Y H:i');
                                },
                                getPlaceImage: function(rank) {
                                    return ExGods.ref('images|rating_place_icons').image['place' + rank];
                                }
                            }
                        ],
                        data: {
                            arena: me.arena,
                            list: me.list.slice(0, me.itemsPerPage)
                        }
                    }
                ]
            }
        ];
        me.plugins = me.plugins || [];
        me.plugins.push({
            ptype: 'pager',
            marginLeft: -27,
            marginRight: -27,
            top: 127,
            textTop: -32,
            textLeft: 249,
            total: Math.ceil(me.list.length / me.itemsPerPage)
        });
        me.listeners = {
            prev: me.updateList,
            next: me.updateList,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
    },
    updateList: function() {
        var me = this,
            items = me.filtered || me.list;
        items = items.slice((me.pager.current - 1) * me.itemsPerPage, me.pager.current * me.itemsPerPage);
        me.items.items[0].getComponent('list').update({
            arena: me.arena,
            list: items
        });
        me.pager.refresh();
    },
    setTextFilter: function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        if (me.textFilter) {
            me.filtered = Ext.Array.filter(me.list, function(item) {
                return (item.info.display_title).toLowerCase().indexOf(me.textFilter) != -1;
            });
            me.pager.total = Math.ceil(me.filtered.length / me.itemsPerPage);
        } else {
            delete me.filtered;
            me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        }
        me.pager.current = 1;
        me.updateList();
    },
    onDestroy: function() {
        var me = this;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'icons/ico_trophy.png'
            ].concat(arr_images)
        };
    }
});

/**
 * 
 */
Ext.define('ExGods.view.shop.Shop', {
    extend: Ext.view.View,
    alias: 'widget.shop',
    cls: 'shop',
    /**
     * @cfg {Ext.data.Store} store    (ExGods.model.ShopItem)
     */
    store: null,
    /**
     * @cfg {Boolean} filterByLevel  ,     
     */
    filterByLevel: true,
    /**
     * @cfg {String} textFilterString       
     */
    textFilterString: '',
    /**
     * @cfg {String} emptyText     
     */
    emptyText: '',
    height: 290,
    autoRender: true,
    itemSelector: 'li.item',
    deferEmptyText: false,
    initComponent: function() {
        var me = this;
        me.setFilters();
        me.tpl = [
            '<ul class="shop-items" >',
            '<tpl for=".">',
            '<li class="item qh-object {[ values.new_price ? "discounted" : "" ]}" data-qh_otype="{qh_name}" data-qh_oid="{item_id}" {[this.checkIndex(xindex)]} >',
            '<tpl if="values.new_price">' + '<div class="best_choice" style="background-image:url(' + ExGods.ref('images|common_text_images').image.sale + ')"></div>',
            '<tpl else>',
            '<tpl if="values.level == ' + ExGods.app.user.data.hoard.level + '">',
            '<div class="best_choice" style="background-image:url(' + ExGods.ref('images|common_text_images').image.best + ')"></div>',
            '</tpl>',
            '</tpl>',
            '<div class="item-content">',
            '<div class="item_info"></div>',
            '{[this.getTitle(values)]}',
            '{[this.printImage(values)]}',
            '<div class="level">{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('view_shop_shop_itemlvl') + '",{level:values.level})]}</div>',
            '<tpl if="values.count != -1">',
            '<div class="count">{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('view_shop_shop_itemcount') + '",{level:values.level})]}</div>',
            '</tpl>',
            '<div class="price">{price}</div>',
            '<tpl if="new_price">',
            '<div>{new_price}</div>',
            '</tpl>',
            '<div class="component buy_button">',
            '<span role="xtype">textbutton</span>',
            '<span role="disable:bool">true</span>',
            '<span role="cls">no_border</span>',
            '<span role="text">' + ExGods.getMsgByKey('shop_buy_btn_text') + '</span>',
            '<span role="minWidth:int">90</span>',
            '</div>',
            '<div class="x-clear"></div>',
            '</div>',
            '</li>',
            '</tpl>',
            '</ul>',
            '<div class="x-clear"></div>',
            {
                getTitle: function(values) {
                    var html = '<div class="title';
                    if (values.count != -1) {
                        html += ' one_line';
                    }
                    html += '" style="';
                    if (values.grade) {
                        html += 'color:' + ExGods.references.get('constants_list').item_grades.value[Number(values.grade) - 1 || 0];
                    }
                    return html + '"><span>' + values.title + '</span></div>';
                },
                checkIndex: function(index) {
                    var cls = index == 1 ? ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : (index - 1) % 3 === 0 ? ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : '';
                    return cls;
                },
                printImage: function(values) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'shop_stuff',
                        locked: Boolean(values.message),
                        params: {
                            stuff: {
                                params: {
                                    id: values.item_id
                                },
                                type: values.kit ? 'kit' : 'item'
                            }
                        }
                    });
                }
            }
        ];
        me.emptyText = '<div class="empty-text">' + me.emptyText + '</div>';
        me.callParent(arguments);
        me.on({
            beforerefresh: me.onBeforeRefresh,
            refresh: me.onRefresh,
            scope: me
        });
    },
    /**
     *    
     */
    setFilterByLevel: function(value) {
        var me = this;
        if (me.filterByLevel != value) {
            me.filterByLevel = value;
            me.setFilters();
        }
    },
    /**
     *    
     */
    setTextFilter: function(value) {
        var me = this;
        if (me.textFilterString != value) {
            me.textFilterString = Ext.String.trim(value);
            me.setFilters();
        }
    },
    /**
     *       
     */
    setFilters: function() {
        var me = this,
            filters = [];
        if (me.filterByLevel) {
            filters.push(new Ext.util.Filter({
                filterFn: function(item) {
                    var level = parseInt(ExGods.app.user.getLevel()),
                        proto = item.data.item_proto;
                    return level >= proto.data.data.strict.level;
                }
            }));
        }
        if (me.textFilterString) {
            filters.push(new Ext.util.Filter({
                filterFn: function(item) {
                    var itemTitle = item.data.item_proto.data.title;
                    return itemTitle.toLowerCase().indexOf(me.textFilterString.toLowerCase()) == -1 ? false : true;
                }
            }));
        }
        me.store.clearFilter();
        me.store.filter(filters);
        me.store.sort();
    },
    // ============= PRIVATES ====================
    /**
     *      
     */
    prepareData: function(data) {
        var newData = {};
        Ext.Array.each(data, function(item) {
            var proto = item.item_proto;
            var prices = [],
                new_price = [];
            if (data.new_price == '') {
                Ext.Array.each(data.price, function(price, index) {
                    prices.push(ExGods.util.Format.printMoney(price));
                });
            } else {
                Ext.Array.each(data.new_price.old, function(price, index) {
                    prices.push('<span class="old-price-wrap">' + ExGods.util.Format.printMoney(price) + '<span class="old-price-sub">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></span>');
                });
                Ext.Array.each(data.new_price['new'], function(price, index) {
                    new_price.push(ExGods.util.Format.printMoney(price));
                });
            }
            Ext.apply(newData, {
                count: data.params.unlimit ? '-1' : data.count,
                //image: proto.data.images.info || '',
                level: proto.data.data.strict.level,
                price: prices.join(' '),
                new_price: new_price.join(' '),
                message: data.message,
                title: proto.data.title || proto.label,
                grade: proto.data.data.item_grade || 1,
                item_id: data.kit ? data.kit : proto.data.entry,
                kit: Boolean(data.kit),
                qh_name: data.kit ? 'shop_item_kit' : 'shop_item'
            });
        });
        return newData;
    },
    /**
     *  "beforerefresh"  dataview
     */
    onBeforeRefresh: function() {
        var me = this;
        if (me.rendered) {
            ExGods.helpme.destroyComponents(me.el, me);
        }
    },
    /**
     *  "refresh"  dataview
     */
    onRefresh: function() {
        var me = this;
        ExGods.helpme.renderComponents(me.el, me);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var images = ExGods.ref('images|common_text_images').image;
        for (var i = 0; i < images.length; i++) {
            arr_images.push(images[i]);
        }
        for (var i = 0; i < me.store.data.items.length; i++) {
            var imgs = me.store.data.items[i].data.item_proto.data.images;
            for (var it in imgs) {
                arr_images.push(imgs[it]);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.arena.ArenaShop', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena_shop',
    id: 'arena_shop',
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser();
        me.shopView = {
            xtype: 'shop',
            height: 283,
            store: me.store
        };
        me.items = [
            me.shopView
        ];
        me.plugins = [
            {
                ptype: 'pager',
                marginLeft: -27,
                marginRight: -27,
                top: 127,
                textTop: 283,
                textLeft: 237,
                total: Math.ceil(me.store.getCount() / 6)
            }
        ];
        me.mon(me.store, 'datachanged', me.updatePager, me);
        me.on({
            next: me.showNextPage,
            prev: me.showPrevPage,
            scope: me
        });
        me.callParent();
    },
    // =============== PRIVATES ============================
    updateFilters: function(filterName, value) {
        var me = this,
            shopView = me.down('shop');
        if (filterName == 'level') {
            shopView.setFilterByLevel(value);
        } else if (filterName == 'text') {
            shopView.setTextFilter(value);
        }
        me.updatePager();
    },
    updatePager: function() {
        var me = this;
        if (!me.pager) {
            return;
        }
        me.pager.current = 1;
        me.pager.total = Math.ceil(me.store.getCount() / 6);
        me.pager.refresh();
    },
    showNextPage: function() {
        var me = this;
        me.openPage(-1);
        me.pager.refresh();
    },
    showPrevPage: function() {
        var me = this;
        me.openPage(1);
        me.pager.refresh();
    },
    openPage: function(direction) {
        var me = this,
            shopView = me.down('shop');
        ul = shopView.getEl().down('.shop-items') , marginTop = parseInt(ul.getStyle('margin-top').split('p')[0]) , offsetHeight = 282;
        ul.setStyle('margin-top', (marginTop + offsetHeight * direction) + 'px');
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'icons/done.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 *
 * @author  
 *
 */
Ext.define('ExGods.controller.Arena', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Arena:'
    },
    models: [
        'Arena'
    ],
    views: [
        'arena.Arena',
        'arena.EnemyList',
        'arena.Rating',
        'arena.ArenaShop'
    ],
    stores: [
        'ShopItems'
    ],
    tooltips: [
        'text'
    ],
    isArenaBattle: false,
    init: function() {
        var me = this;
        me.arenas = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.Arena',
            sorters: {
                property: 'l_order'
            },
            listeners: {
                datachanged: me.onArenasChanged,
                update: me.onArenaUpdate,
                scope: me
            }
        });
        me.arenaShopStore = Ext.create('ExGods.store.ShopItems');
        me.control({
            'textbutton[action="arena_queue"]': {
                click: me.onQueueButtonClick
            },
            'textbutton[action="arena_accept"]': {
                click: me.onAcceptButtonClick
            },
            'textbutton[action="arena_refuse"]': {
                click: me.onRefuseButtonClick
            },
            'textbutton[action="arena_revenge"]': {
                click: me.onRevengeButtonClick
            },
            'textbutton[action="arena_show_shop"]': {
                click: me.onShowShopClick
            },
            'battleresult': {
                close: me.showArena
            }
        });
        me.app.chatcn.on('command_arena', me.onArenaChatCommand, me);
        ExGods.Components.addComponentInitializer('arena', me.initArenaComponent, me);
    },
    /**
     *    
     */
    initArenaComponent: function(config, componentId) {
        var me = this,
            cmp, store,
            items = [],
            icons = ExGods.ref('images|arena_icons').image,
            wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        /***/
        me.log('  ""');
        me.arenas.loadRawData(me.service.data.arenas);
        me.arenas.each(function(arena) {
            //  
            items.push({
                xtype: 'arena',
                itemId: 'arena-' + arena.data.id,
                service: me.service,
                arena: arena,
                tabConfig: {
                    tooltip: arena.data.label,
                    icon: icons.arena_tab
                },
                clientObject: config
            });
            // var testData = {"success":1,"rand":0.119676300309074,"service_id":"84","service":{"arenas":[{"rating_top_list":{"success":1,"info":{"ro":"user","last_time":"2014-09-29 10:02:27","id":"16","type":"1","limit":100},"data":{"ranks":[{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"van_guard","display_title":" ","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"772","rank":1},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"1","gender":"2","hoard":{"level":"5","rank":"1"},"online":"1"},"value":"723","rank":2},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"79","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"695","rank":3},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"686","rank":4},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"670","rank":5},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"617","rank":6},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"564","rank":7},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"561","rank":8},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"540","rank":9},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"522","rank":10},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"504","rank":11},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":" ","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"499","rank":12},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"bear","display_title":" ","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"485","rank":13},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"485","rank":13},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Vitalika","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"484","rank":15},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Varg","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"456","rank":16},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"tato","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"445","rank":17},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Warlk","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"442","rank":18},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Night Angel","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"442","rank":18},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"u001","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"441","rank":20},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Monkli","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"441","rank":20},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"440","rank":22},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"ReQuieM","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"439","rank":23},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"437","rank":24},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"davman","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"436","rank":25},{"info":{"race":"3","binding":{"battle":"1013816200","world":"2","room":"7"},"shape":"boar","display_title":"","gender":"2","hoard":{"level":"5","rank":"1"},"online":"1"},"value":"431","rank":26},{"info":{"race":"2","binding":{"battle":"1013816301","world":"2","room":"6"},"shape":"boar","display_title":"BlackMamba","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"430","rank":27},{"info":{"race":"3","binding":{"battle":"1013817201","world":"2","room":"7"},"shape":"boar","display_title":"XyliganAlex","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"429","rank":28},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Andal","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"429","rank":28},{"info":{"race":"3","binding":{"battle":"1013815500","world":"2","room":"7"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"426","rank":30},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Smilodon","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"418","rank":31},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"418","rank":31},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"A965","gender":"2","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"413","rank":33},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"412","rank":34},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"AndRe","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"409","rank":35},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"391","rank":36},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"2014","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"390","rank":37},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"KapaAV","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"387","rank":38},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"kirpich","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"386","rank":39},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Virus1710","gender":"1","hoard":{"level":"5","rank":"1"},"online":0},"value":"383","rank":40},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Jeanette","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"383","rank":40},{"info":{"race":"3","binding":{"battle":"1013216900","world":"2","room":"7"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"378","rank":42},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"vlad","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"375","rank":43},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"pisyuha","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"372","rank":44},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"371","rank":45},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"  ","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"369","rank":46},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"367","rank":47},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Ness","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"366","rank":48},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"del301","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"364","rank":49},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"EvilFila","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"361","rank":50},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"--","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"360","rank":51},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"Hayabusa","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"354","rank":52},{"info":{"race":"2","binding":{"battle":"1013817100","world":"2","room":"7"},"shape":"bear","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"350","rank":53},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"349","rank":54},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"bear","display_title":"Sykes","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"343","rank":55},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"red bull","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"342","rank":56},{"info":{"race":"3","binding":{"battle":"1013328500","world":"2","room":"6"},"shape":"boar","display_title":"","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"341","rank":57},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Granddoc","gender":"2","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"341","rank":57},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"  ","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"336","rank":59},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"JUNK","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"332","rank":60},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Tarakan","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"328","rank":61},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"van_guard","display_title":"lionel2020","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"327","rank":62},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"kamelot","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"323","rank":63},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"alinth","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"323","rank":63},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"77","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"315","rank":65},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"AlekseiChe","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"312","rank":66},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Devka","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"311","rank":67},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"Soul","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"311","rank":67},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"309","rank":69},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"asfagen","gender":"2","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"309","rank":69},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":" ","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"308","rank":71},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"werewolf","display_title":"Kowka-misti","gender":"2","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"307","rank":72},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"as_m","display_title":"Dar Veter","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"304","rank":73},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":" ","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"303","rank":74},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"vit","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"302","rank":75},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Vasa1880","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"301","rank":76},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"7"},"shape":"bear","display_title":"LightStar","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"298","rank":77},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"297","rank":78},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":0},"value":"294","rank":79},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"292","rank":80},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"INSANE","gender":"2","hoard":{"level":"4","rank":"1"},"online":0},"value":"288","rank":81},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"GRUV","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"286","rank":82},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Kasius","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"283","rank":83},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Zarazka","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"282","rank":84},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"282","rank":84},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"slepok","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"281","rank":86},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":" ","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"281","rank":86},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"rexwalker","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"280","rank":88},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"as_f","display_title":"Charlene","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"279","rank":89},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Den Desert Eagle","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"279","rank":89},{"info":{"race":"2","binding":{"battle":"1013817300","world":"2","room":"7"},"shape":"bear","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"276","rank":91},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"273","rank":92},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"2","hoard":{"level":"3","rank":"1"},"online":0},"value":"270","rank":93},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":" ","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"270","rank":93},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"7"},"shape":"boar","display_title":"alex18181","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"269","rank":95},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"bear","display_title":"12","gender":"1","hoard":{"level":"4","rank":"1"},"online":"1"},"value":"268","rank":96},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"MaximFB","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"266","rank":97},{"info":{"race":"2","binding":{"battle":"1013815700","world":"2","room":"7"},"shape":"boar","display_title":"desatro","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"266","rank":97},{"info":{"race":"2","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"","gender":"1","hoard":{"level":"3","rank":"1"},"online":0},"value":"265","rank":99},{"info":{"race":"3","binding":{"battle":0,"world":"2","room":"6"},"shape":"boar","display_title":"Wimpex","gender":"1","hoard":{"level":"3","rank":"1"},"online":"1"},"value":"261","rank":100}],"tag":"1","label":" "}},"queue_time":null,"id":"3","l_order":"0","wait_queue":"10","elo_value":"281","ready_time":null,"can_unqueue":0,"description":"<strong>  </strong>,        <strong></strong>, <br /><strong>  </strong> - <strong> </strong>.\n<div style=\"text-align: center;\"><br /> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1368\"><img src=\"http://img.exgods.ru/items/masks/as_assassin_male_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1369\"><img src=\"http://img.exgods.ru/items/masks/as_berserk_male_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1370\"><img src=\"http://img.exgods.ru/items/masks/as_warrior_male_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1379\"><img src=\"http://img.exgods.ru/items/masks/as_assassin_female_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1380\"><img src=\"http://img.exgods.ru/items/masks/as_berserk_female_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 2\"><span class=\"item\" data-proto_id=\"1381\"><img src=\"http://img.exgods.ru/items/masks/as_warrior_female_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1376\"><img src=\"http://img.exgods.ru/items/masks/van_assassin_male_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1377\"><img src=\"http://img.exgods.ru/items/masks/van_berserk_male_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 1 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1378\"><img src=\"http://img.exgods.ru/items/masks/van_warrior_male_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1382\"><img src=\"http://img.exgods.ru/items/masks/van_assassin_female_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1383\"><img src=\"http://img.exgods.ru/items/masks/van_berserk_female_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl> <tpl if=\"u.gender == 2 &amp;&amp; u.race == 3\"><span class=\"item\" data-proto_id=\"1384\"><img src=\"http://img.exgods.ru/items/masks/van_warrior_female_1.jpg\" width=\"64\" height=\"64\" alt=\" \" style=\"margin-left: 5px; margin-right: 5px; vertical-align: middle;\" /></span></tpl></div>","wait_ready":"30","elo_level":"1","foes":[{"elo_delta":"-2","elo_value":"723","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":"1","race":"2","add_time":"2014-09-28 18:09:16","shape":"werewolf","display_title":"1","gender":"2","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-14","elo_value":"391","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-16 22:08:51","shape":"boar","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"}},{"elo_delta":"-12","elo_value":"138","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-20 00:40:45","shape":"nidhegg","display_title":"Shargoh","gender":"1","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-2","elo_value":"670","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"2","add_time":"2014-09-28 00:15:57","shape":"boar","display_title":"","gender":"1","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-3","elo_value":"442","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-21 17:31:18","shape":"boar","display_title":"Warlk","gender":"1","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-6","elo_value":"383","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"2","add_time":"2014-09-21 14:09:27","shape":"bear","display_title":"Virus1710","gender":"1","hoard":{"level":"5","rank":"1"}},{"elo_delta":"-5","elo_value":"441","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-22 22:11:54","shape":"boar","display_title":"Monkli","gender":"1","hoard":{"level":"4","rank":"1"}},{"elo_delta":"-3","elo_value":"686","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-23 21:47:59","shape":"werewolf","display_title":"","gender":"1","hoard":{"level":"4","rank":"1"}},{"elo_delta":"-4","elo_value":"429","binding":{"battle":0,"world":"2","room":"6"},"elo_level":"1","online":0,"race":"3","add_time":"2014-09-25 03:16:15","shape":"bear","display_title":"Andal","gender":"1","hoard":{"level":"4","rank":"1"}}],"finish_date":"2014-09-28 23:59:59","rating_info":{"value":"281","rank":86},"label":" ","stuff_refuse":{"stuff":[{"params":{"quantity":100,"id":"gold"},"type":"currency"}],"discount":0,"old":[{"params":{"quantity":100,"id":"gold"},"type":"2"}]},"season":"1"}]}};
            //   
            items.push({
                xtype: 'arena_enemylist',
                arena: arena.data,
                tabConfig: {
                    tooltip: ExGods.getMsgByKey('arena_tooltip_enemy_list'),
                    icon: icons.enemy_list_tab
                }
            });
            //  
            if (arena.data.rating_top_list && !Ext.Object.isEmpty(arena.data.rating_top_list.data)) {
                items.push({
                    xtype: 'arena_rating',
                    arena: arena.data,
                    list: arena.data.rating_top_list.data.ranks,
                    tabConfig: {
                        tooltip: ExGods.getMsgByKey('arena_tooltip_rating'),
                        icon: icons.rating_tab
                    }
                });
            }
            //  
            if (arena.data.shop_service) {
                items.push({
                    xtype: 'arena_shop',
                    shopService: arena.data.shop_service,
                    store: me.arenaShopStore,
                    tabConfig: {
                        tooltip: ExGods.getMsgByKey('arena_tooltip_shop'),
                        icon: icons.arena_shop_tab
                    }
                });
            }
        });
        Ext.apply(config, {
            rightPanelX: 250,
            closeCallback: function() {
                ExGods.loaderCt.loadAndRemove(function() {
                    wnd.close();
                }, {
                    img: config.backgroundImage
                });
            },
            margin: '0 10 10 0',
            items: [
                {
                    xtype: 'skintabpanel',
                    items: items,
                    width: 580,
                    height: 363,
                    y: 10,
                    x: 250,
                    plugins: [
                        'skindeco'
                    ],
                    closable: true,
                    listeners: {
                        beforeclose: {
                            fn: function() {
                                ExGods.loaderCt.loadAndRemove(function() {
                                    wnd.close();
                                }, {
                                    img: config.backgroundImage
                                });
                                return false;
                            }
                        },
                        tabchange: me.onTabChange,
                        scope: me
                    }
                },
                {
                    xtype: 'form',
                    x: 530,
                    y: 20,
                    width: 270,
                    height: 30,
                    layout: {
                        type: 'hbox',
                        pack: 'end'
                    },
                    tbar: {
                        xtype: 'panel',
                        bodyCls: 'parchment-content-nop',
                        bodyPadding: 0,
                        height: 30,
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        margin: '0 0 5 0',
                        defaults: {
                            margin: '0 1'
                        },
                        items: [
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('arena_search_empty_text'),
                                itemId: 'text-search',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: me.filterBySearch,
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            },
                            {
                                xtype: 'checkboxfield',
                                boxLabel: ExGods.getMsgByKey('view_shop_tabs_avail'),
                                checked: true,
                                hidden: true,
                                itemId: 'availability',
                                style: {
                                    color: '#e3ac69'
                                },
                                listeners: {
                                    change: function(f, value) {
                                        me.updateFilters('level', value);
                                    },
                                    scope: me
                                },
                                margin: '0 10 0 0'
                            },
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('view_shop_tabs_seachbyname'),
                                itemId: 'title',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: {
                                        fn: function(f, value) {
                                            me.updateFilters('text', value);
                                        },
                                        buffer: 100
                                    },
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            }
                        ]
                    }
                }
            ]
        });
        var cmp = Ext.apply({
                xtype: 'room'
            }, config);
        //  me.startTimersUpdate(); // 
        wnd = Ext.widget('window1', {
            id: componentId,
            items: [
                cmp
            ],
            autoShow: false,
            /* 
            listeners: {
                close: function() {
                    me.stopTimersUpdate();
                },
                scope: me,
            },
            */
            /**
             *   
             */
            getResources: function() {
                var me = this;
                var arr_images = [];
                return {
                    images: [
                        icons.arena_tab,
                        icons.arena_shop_tab,
                        icons.rating_tab,
                        icons.enemy_list_tab
                    ].concat(arr_images)
                };
            }
        });
        me.cmp = wnd.down('room');
        me.cmp.getArenaComponent = function(id) {
            if (this.rendered) {
                return this.items.items[0].getComponent('arena-' + id);
            }
        };
        ExGods.app.getController('Location').maskLocation(function() {
            //  
            ExGods.Resources.load(wnd, function() {
                wnd.show();
                ExGods.app.getController('Location').unmaskLocation();
            });
        }, {
            img: config.backgroundImage
        });
        return wnd;
    },
    onArenasChanged: function() {
        var me = this;
        //   ,  
        ExGods.helpme.loadProtos(me.arenas.data, 'items.data.info.rival.slots.items.proto_id|items.data.info.rival.mask_proto_id', function() {
            if (me.cmp && me.cmp.rendered) {
                /***/
                me.log('    -  ');
                me.arenas.each(function(arena) {
                    var innerCmp = me.cmp.getArenaComponent(arena.get('id'));
                    if (innerCmp) {
                        innerCmp.update(arena.data);
                    } else {
                        /****/
                        me.log('warn', '   "' + arena.get('id') + '"  ');
                    }
                });
            }
        });
    },
    onArenaUpdate: function(store, arena) {
        var me = this;
        if (arena.data.state == 'start') {
            //         
            me.setButtonsDisable([
                'accept',
                'refuse'
            ], true);
        } else {
            //   ,  
            ExGods.helpme.loadProtos(arena, 'data.info.rival.slots.items.proto_id|data.info.rival.mask_proto_id', function() {
                if (me.cmp && me.cmp.rendered) {
                    ExGods.Resources.load({
                        getResources: function() {
                            var stuff_arr = [];
                            if (arena.data.rival_stuff) {
                                stuff_arr = stuff_arr.concat(arena.data.rival_stuff);
                            }
                            return {
                                stuff: stuff_arr,
                                images: [
                                    arena.data.rival_image
                                ].concat(ExGods.util.User.getUserStatImages())
                            };
                        }
                    }, function() {
                        /***/
                        me.log('   "' + arena.get('id') + '"  -  ');
                        var innerCmp = me.cmp.getArenaComponent(arena.get('id'));
                        if (innerCmp) {
                            innerCmp.update(arena.data);
                        } else {
                            /****/
                            me.log('warn', '   "' + arena.get('id') + '"  ');
                        }
                    });
                }
            });
        }
    },
    onQueueButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('      id-', btn.arena_id);
        delete me.f_arena_queue_success;
        me.service.command('arena_queue', {
            id: btn.arena_id
        }, function(json) {
            if (!me.f_arena_queue_success) {
                if (json.success) {
                    me.arenas.loadRawData(json.arenas);
                }
            }
        });
    },
    onUnQueueButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('      id-', btn.arena_id);
        me.setButtonsDisable([
            'queue'
        ], true);
        me.service.command('arena_unqueue', {
            id: btn.arena_id
        }, function(json) {
            if (json.success) {
                me.arenas.loadRawData(json.arenas);
            } else {
                me.setButtonsDisable([
                    'queue'
                ], false);
            }
        });
    },
    onAcceptButtonClick: function(btn) {
        var me = this,
            arena;
        /***/
        me.log('     id-', btn.arena_id);
        me.setButtonsDisable([
            'accept',
            'refuse'
        ], true);
        me.service.command('arena_accept', {
            id: btn.arena_id
        }, function(json) {
            me.isArenaBattle = me.service.id;
            if (json.success) {
                //     'accept'
                arena = me.arenas.getById(btn.arena_id);
                if (arena) {
                    arena.set('state', 'accept');
                }
            } else {
                me.setButtonsDisable([
                    'accept',
                    'refuse'
                ], false);
            }
        });
    },
    onRefuseButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('      id-', btn.arena_id);
        me.setButtonsDisable([
            'accept',
            'refuse'
        ], true);
        delete me.f_arena_queue_success;
        me.service.command('arena_refuse', {
            id: btn.arena_id
        }, function(json) {
            if (json.success && !me.f_arena_queue_success) {
                me.arenas.loadRawData(json.arenas);
            } else {
                me.setButtonsDisable([
                    'accept',
                    'refuse'
                ], false);
            }
        });
    },
    onRevengeButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('    id-', btn.arena_id);
        if (btn.can_revenge == 0)  {
            return;
        }
        
        me.setButtonsDisable([
            'revenge'
        ], true);
        me.service.command('arena_revenge', {
            id: btn.arena_id,
            title: btn.user_title
        }, function(json) {
            if (json.success) {} else //   
            {
                me.setButtonsDisable([
                    'revenge'
                ], false);
            }
        });
    },
    onArenaChatCommand: function(chatcn, data) {
        var me = this,
            arena;
        /***/
        me.log('   ""  ', data);
        arena = me.arenas.getById(data.body.id);
        if (arena) {
            data.body.data.state = data.body.state;
            Ext.apply(arena.raw, data.body.data);
            arena.setRawData(arena.raw);
            if (arena.get('message')) {
                me.application.fireEvent('logmessage', arena.get('message'));
            }
            /***/
            me.log('    - ', arena.get('state'));
            me.f_arena_queue_success = 1;
        }
    },
    onTabChange: function(panel, tab) {
        var me = this,
            form = me.cmp.items.findBy(function(item) {
                return item.xtype == 'form';
            }),
            searchField = form.down('#text-search'),
            shopTitleSearch = form.down('#title'),
            shopAvailability = form.down('#availability');
        if (tab.xtype == 'arena_enemylist' || tab.xtype == 'arena_rating') {
            searchField.el.select('input').elements[0].value = tab.textFilter || '';
            //      
            searchField.show();
        } else {
            searchField.hide();
        }
        if (tab.xtype == 'arena_shop') {
            shopTitleSearch.el.select('input').elements[0].value = '';
            //      
            shopTitleSearch.show();
            shopAvailability.show();
        } else {
            shopTitleSearch.hide();
            shopAvailability.hide();
        }
        if (tab.xtype == 'arena_enemylist' && !tab.list) {
            me.loadEnemyList(tab);
        }
        if (tab.xtype == 'arena_shop' && me.arenaShopStore.getCount() == 0) {
            me.updateShop(tab);
        }
    },
    updateFilters: function(filterName, value) {
        var me = this,
            shop = me.cmp.down('arena_shop');
        shop.updateFilters.apply(shop, arguments);
    },
    //    
    loadEnemyList: function(enemyListView) {
        var me = this;
        me.app.block();
        me.service.command('arena_get_foes', {}, function(resp) {
            me.app.unblock();
            if (resp && resp.result && resp.result.length) {
                enemyListView.setList(resp.result[0].foes);
            }
        });
    },
    updateShop: function(shopView) {
        if (typeof shopView.shopService != 'object') {
            shopView.shopService = ExGods.Services.factory(shopView.shopService);
        }
        shopView.shopService.init(null, function(service) {
            ExGods.helpme.loadProtos(service.data.shops[0].items, 'item.item', function() {
                shopView.store.loadRawData(service.data.shops[0].items);
            });
        });
    },
    filterBySearch: function(searchField) {
        var me = this,
            str = searchField.getValue(),
            tabs = me.cmp.query('tabpanel')[0],
            tab = tabs.getActiveTab();
        if (tab.setTextFilter) {
            tab.setTextFilter(str);
        }
    },
    setButtonsDisable: function(btnNames, disabled) {
        var me = this,
            query;
        if (me.cmp) {
            Ext.Array.each(btnNames, function(btn) {
                query = Ext.ComponentQuery.query('textbutton[action="arena_' + btn + '"]');
                if (query.length) {
                    query[0].setDisabled(disabled);
                }
            });
        }
    },
    onShowShopClick: function(btn) {
        var me = this,
            tabs = me.cmp.down('skintabpanel');
        tabs.setActiveTab('arena_shop');
    },
    showArena: function() {
        var me = this;
        if (me.isArenaBattle && ExGods.app.user.getSetting('reopen_interface') == 1) {
            ExGods.ClientActions.createAndInvoke({
                actionId: me.isArenaBattle
            }, null, function(err) {
                /***/
                me.log('error', err);
            });
            me.isArenaBattle = false;
        }
    },
    // startTimersUpdate: function() {
    //  var me = this,
    //      arenaViewEl,
    //      updateTimer = function(rooEl) {
    //          rootEl.select('.exg-timter').each(function(el) {
    //              if (!el.hasCls('exg-timer-expired')) {
    //                  var date = new Date(el.dom.getAttribute('data-value'));
    //                  var format = el.dom.getAttribute('data-format');
    //                  var restTime = Math.ceil((date - new Date()) / 1000);
    //                  if (restTime > 0) {
    //                      el.setHTML(ExGods.util.Time.printTime(restTime, {
    //                          format: format
    //                      }));
    //                  } else {
    //                      el.addCls('exg-timer-expired');
    //                      me.onTimerExpired();
    //                  }
    //              }
    //          });
    //      };
    //  /****/
    //  me.log('  ');
    //  me.timersUpdateInterval = setInterval(function() {
    //      if (arenaViewEl) {
    //          updateTimer(arenaViewEl)
    //      } else {
    //          arenaViewEl = me.cmp.getEl();
    //      }
    //  }, 1000);
    // },
    // stopTimersUpdate: function() {
    //  var me = this;
    //  /****/
    //  me.log('  ');
    //  clearInterval(me.timersUpdateInterval);
    // },
    // onTimerExpired: function() {
    //  var me = this;
    //  me.service.update(null, function() {
    //      me.arenas.loadRawData(me.service.data.arenas);
    //      me.updateComponents();
    //      ExGods.app.unblock();
    //  });
    // },
    /**
     *       
     */
    updateComponents: function() {
        var me = this;
        //   
        me.arenas.each(function(arena) {
            var innerCmp = me.cmp.getArenaComponent(arena.get('id'));
            if (innerCmp) {
                innerCmp.update(arena.data);
            }
        });
    },
    /**
     * @private   
     */
    get_user_test_data: function() {
        var u = {
                "msg": "",
                "success": 1,
                "rand": 0.101857223586318,
                "user_info": {
                    "moder": "10",
                    "achievements": [],
                    "binding": {
                        "battle": "0",
                        "world": "1",
                        "room": "1"
                    },
                    "contact": [],
                    "feature": [],
                    "public": {
                        "country": null,
                        "ii": {
                            "width": 150,
                            "date": "2012-11-23 14:40:50",
                            "height": 150
                        },
                        "name": null,
                        "motto": null,
                        "city": null,
                        "about": null,
                        "title": " ",
                        "birthday": null
                    },
                    "race": "1",
                    "gender": "1",
                    "timed": {
                        "hp": [
                            110,
                            110,
                            1
                        ],
                        "mp": [
                            100,
                            100,
                            5
                        ]
                    },
                    "stats": {
                        "stats": {
                            "stamina": 10,
                            "vitality": 2,
                            "peril": null,
                            "agility": 10,
                            "fury": 10,
                            "spirit": null,
                            "hard": 180,
                            "strength": 5
                        }
                    },
                    "social": {
                        "social_net_id": null,
                        "social_net": null
                    },
                    "can_mentor": null,
                    "can_pupil": "0",
                    "online": "1",
                    "counters": [
                        {
                            "params": {},
                            "entry": "1",
                            "ui": "doll",
                            "title": "  ",
                            "conditions": {
                                "cg": "",
                                "c": "",
                                "t": ""
                            },
                            "summ": 9
                        },
                        {
                            "params": {},
                            "entry": "2",
                            "ui": "doll",
                            "title": "  ",
                            "conditions": null,
                            "summ": 0
                        },
                        {
                            "params": {},
                            "entry": "3",
                            "ui": "doll",
                            "title": "  ",
                            "conditions": null,
                            "summ": 0
                        },
                        {
                            "params": {},
                            "entry": "4",
                            "ui": "doll",
                            "title": "  ",
                            "conditions": null,
                            "summ": 28
                        }
                    ],
                    "ratings": [],
                    "reg_date": "2012-05-30 11:08:03",
                    "title": " ",
                    "shape": "begin_m",
                    "gender_title": "",
                    "slots": [
                        {
                            "name": "",
                            "ekey": "111",
                            "protect": "0",
                            "type": "13",
                            "items": []
                        },
                        {
                            "name": "",
                            "ekey": "113",
                            "protect": "0",
                            "type": "5",
                            "items": []
                        },
                        {
                            "name": "",
                            "ekey": "114",
                            "protect": "0",
                            "type": "11",
                            "items": []
                        },
                        {
                            "name": "",
                            "ekey": "117",
                            "protect": "0",
                            "type": "9",
                            "items": []
                        },
                        {
                            "name": "",
                            "ekey": "118",
                            "protect": "0",
                            "type": "1",
                            "items": []
                        },
                        {
                            "name": "",
                            "ekey": "119",
                            "protect": "0",
                            "type": "10",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "119",
                                    "proto_id": "157",
                                    "param": {
                                        "dur": 78,
                                        "nonbr": 0
                                    },
                                    "item_id": "38"
                                }
                            ]
                        },
                        {
                            "name": "",
                            "ekey": "120",
                            "protect": "0",
                            "type": "6",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "120",
                                    "proto_id": "80",
                                    "param": {
                                        "dur": 76,
                                        "nonbr": 0
                                    },
                                    "item_id": "39"
                                }
                            ]
                        },
                        {
                            "name": "",
                            "ekey": "121",
                            "protect": "0",
                            "type": "8",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "121",
                                    "proto_id": "91",
                                    "param": {
                                        "dur": 76,
                                        "nonbr": 0
                                    },
                                    "item_id": "40"
                                }
                            ]
                        },
                        {
                            "name": "",
                            "ekey": "122",
                            "protect": "0",
                            "type": "12",
                            "items": []
                        },
                        {
                            "name": "",
                            "ekey": "124",
                            "protect": "0",
                            "type": "2",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "124",
                                    "proto_id": "113",
                                    "param": {
                                        "dur": 76,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": "0"
                                    },
                                    "item_id": "41"
                                }
                            ]
                        },
                        {
                            "name": "",
                            "ekey": "125",
                            "protect": "0",
                            "type": "7",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "125",
                                    "proto_id": "168",
                                    "param": {
                                        "dur": 78,
                                        "nonbr": 0
                                    },
                                    "item_id": "42"
                                }
                            ]
                        },
                        {
                            "name": "",
                            "ekey": "126",
                            "protect": "0",
                            "type": "4",
                            "items": []
                        },
                        {
                            "name": "",
                            "ekey": "127",
                            "protect": "0",
                            "type": "3",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31507"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31508"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31509"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31515"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31516"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31517"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31518"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31519"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31520"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31521"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31522"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31523"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31533"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31534"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31535"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31536"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31537"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31558"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31559"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31560"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31573"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31574"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "116",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "31575"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "36495"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "135",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "53133"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "58",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "53134"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56022"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56023"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56024"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56025"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56026"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56027"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56028"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56029"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "61",
                                    "param": {
                                        "dur": 100,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "56030"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "3",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "56031"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "56032"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "20",
                                    "param": {
                                        "dur": 100,
                                        "nonbr": 0
                                    },
                                    "item_id": "56033"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58289"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58292"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58320"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58428"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58429"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "58430"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 37,
                                        "nonbr": 0
                                    },
                                    "item_id": "64144"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 37,
                                        "nonbr": 0
                                    },
                                    "item_id": "64145"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 98,
                                        "nonbr": 0
                                    },
                                    "item_id": "64146"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 37,
                                        "nonbr": 0
                                    },
                                    "item_id": "64147"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 98,
                                        "nonbr": 0
                                    },
                                    "item_id": "64148"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "26",
                                    "param": {
                                        "dur": 37,
                                        "nonbr": 0
                                    },
                                    "item_id": "64149"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "64150"
                                },
                                {
                                    "action": null,
                                    "slot_id": "127",
                                    "proto_id": "32",
                                    "param": {
                                        "dur": 100,
                                        "taxable": null,
                                        "nonbr": 0
                                    },
                                    "item_id": "64151"
                                }
                            ]
                        },
                        {
                            "name": "   ",
                            "ekey": "128",
                            "protect": "0",
                            "type": "14",
                            "items": []
                        },
                        {
                            "name": "   ",
                            "ekey": "129",
                            "protect": "0",
                            "type": "14",
                            "items": []
                        },
                        {
                            "name": "   ",
                            "ekey": "130",
                            "protect": "0",
                            "type": "14",
                            "items": [
                                {
                                    "action": null,
                                    "slot_id": "130",
                                    "proto_id": "180",
                                    "param": {
                                        "dur": 100,
                                        "item_value": null,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "58336"
                                },
                                {
                                    "action": null,
                                    "slot_id": "130",
                                    "proto_id": "180",
                                    "param": {
                                        "dur": 100,
                                        "item_value": null,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "58337"
                                },
                                {
                                    "action": null,
                                    "slot_id": "130",
                                    "proto_id": "180",
                                    "param": {
                                        "dur": 100,
                                        "item_value": null,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "58338"
                                },
                                {
                                    "action": null,
                                    "slot_id": "130",
                                    "proto_id": "180",
                                    "param": {
                                        "dur": 100,
                                        "item_value": null,
                                        "nonrep": null,
                                        "nonbr": "0",
                                        "nonsale": null
                                    },
                                    "item_id": "58339"
                                }
                            ]
                        },
                        {
                            "name": "",
                            "ekey": "131",
                            "protect": "0",
                            "type": "11",
                            "items": []
                        },
                        {
                            "name": "",
                            "ekey": "132",
                            "protect": "0",
                            "type": "12",
                            "items": []
                        }
                    ],
                    "hoard": {
                        "level": "5",
                        "rank": "7"
                    },
                    "display_title": " "
                }
            };
        var stats = {
                "success": 1,
                "msg": "",
                "fit": {
                    "summary": {
                        "mass": 0
                    },
                    "rmodif": {
                        "antiabsorption": 0,
                        "mp_speed": 30000,
                        "damage": 0,
                        "mp_max": 0,
                        "antidodge": 0,
                        "dodge": 0,
                        "anticritical": 0,
                        "absorption": 0,
                        "shield_max": 0,
                        "capacity": 0,
                        "shield_speed": 0,
                        "critical": 0,
                        "hp_speed": 30000,
                        "hp_max": 0
                    },
                    "stats": {
                        "damage": 50,
                        "hp": 201,
                        "agility": 5,
                        "shield": 200,
                        "mp": 101,
                        "item_grade": 0,
                        "strength": 5002,
                        "stamina": 5,
                        "weightlift": 25,
                        "fury": 33,
                        "hard": 0,
                        "accuracy": 2
                    },
                    "shape": "boar",
                    "modif": {
                        "antiabsorption": 500200,
                        "mp_speed": 30101,
                        "damage": 50,
                        "mp_max": 101,
                        "antidodge": 500,
                        "dodge": 500,
                        "anticritical": 3300,
                        "absorption": 500,
                        "shield_max": 200,
                        "capacity": 25,
                        "shield_speed": 200,
                        "critical": 3300,
                        "hp_speed": 30201,
                        "hp_max": 201
                    }
                },
                "rand": 0.0935058950703045,
                "service_id": "137"
            };
        u.user_info.stats.stats = stats.fit.stats;
        return u;
    },
    /**
     *    
     */
    getTooltipData: function(type, value) {
        var me = this,
            arena = me.arenas.first();
        if (type == 'text') {
            if (value == 'arena-series-descr') {
                return ExGods.app.applyTpl(ExGods.getMsgByKey('arena_series_descr'), arena.data.series);
            }
        }
    }
});

/**
 *   .      :   
 */
Ext.define('ExGods.view.arena2.Rules', {
    extend: Ext.panel.Panel,
    alias: 'widget.arenarules',
    cls: 'arena-rules',
    layout: 'fit',
    plugins: [
        'paperdeco'
    ],
    padding: '0 10 13',
    margin: 4,
    /**
     * @cfg arena {Object}
     */
    /**
     * @cfg clientConfig {Object}
     */
    initComponent: function() {
        var me = this;
        me.dockedItems = [
            {
                xtype: 'component',
                dock: 'top',
                html: [
                    '<div class="paper-title title">',
                    '<h4>' + me.clientConfig.rules_title + '</h4>',
                    '</div>',
                    '<div class="arena-rules-description">' + me.clientConfig.rules_description + '</div>',
                    '<div class="paper-separator"></div>',
                    '<div class="paper-title arena-rewards-title">',
                    '<h4>' + me.clientConfig.rewards_list_title + '</h4>',
                    '</div>'
                ]
            }
        ];
        me.store = Ext.create('Ext.data.Store', {
            fields: [
                'begin_place',
                'end_place',
                'prize'
            ],
            data: me.arena.reward_list,
            proxy: {
                type: 'memory'
            }
        });
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                items: [
                    {
                        xtype: 'dataview',
                        store: me.store,
                        autoEl: 'ul',
                        cls: 'arena-rules-rewards',
                        itemSelector: '.arena-rules-reward',
                        tpl: [
                            '<tpl for=".">',
                            '<li class="arena-rules-reward">',
                            '<div class="arena-rules-place"{[this.getStyle(values)]}>',
                            '<tpl if="begin_place &gt; 3">',
                            //'<div class="arena-rules-place-text">{[ExGods.app.applyTpl("' + me.clientConfig.rules_place_tpl + '",values)]}</div>',
                            '{[this.printPlace(values)]}',
                            '</tpl>',
                            '</div>',
                            '{[ExGods.stuff.StuffManager.image(values.prize)]}',
                            '</li>',
                            '</tpl>',
                            {
                                getStyle: function(values) {
                                    if (values.begin_place >= 1 && values.begin_place <= 3) {
                                        //  3-     
                                        return ' style="background-image: url(' + ExGods.ref('images|rating_place_icons').image['place' + values.begin_place] + ')"';
                                    }
                                },
                                printPlace: function(values) {
                                    if (values.begin_place != values.end_place) {
                                        return [
                                            ExGods.util.Sprite.printSprite(values.begin_place, 'arena/place_numbers.png', {
                                                width: 10,
                                                height: 24,
                                                indent: '-5px',
                                                cls: 'inlineblock'
                                            }),
                                            '<div class="place-dash"></div>',
                                            ExGods.util.Sprite.printSprite(values.end_place, 'arena/place_numbers.png', {
                                                width: 10,
                                                height: 24,
                                                indent: '-5px',
                                                cls: 'inlineblock'
                                            }),
                                            '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>'
                                        ].join('');
                                    } else {
                                        return ExGods.util.Sprite.printSprite(values.begin_place, 'arena/place_numbers.png', {
                                            width: 10,
                                            height: 24,
                                            indent: '-5px',
                                            cls: 'inlineblock'
                                        }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                                    }
                                }
                            }
                        ]
                    }
                ]
            }
        ];
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [];
        var arr_images = [];
        for (var i = 0; i < me.arena.reward_list.length; i++) {
            for (var j = 0; j < me.arena.reward_list[i].prize.length; j++) {
                stuff_arr.push(me.arena.reward_list[i].prize[j]);
            }
        }
        return {
            stuff: stuff_arr,
            images: [
                IMAGE_URL + 'arena/place_numbers.png',
                IMAGE_URL + ExGods.getMsgByKey('place_img')
            ].concat(arr_images)
        };
    }
});

/**
 *  -        
 */
Ext.define('ExGods.view.arena2.Arena', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena2',
    plugins: [
        'paperdeco'
    ],
    /**
     * @cfg {Object} arena  
     */
    arena: {},
    /**
     * @cfg {Object} service  
     */
    service: {},
    cls: 'arena arenaview arena2',
    /**
     * @cfg clientConfig {Object}     -
     */
    clientConfig: {},
    //  
    animationSpeed: 1000,
    //ms
    initComponent: function() {
        var me = this;
        me.data = me.arena;
        me.tpl = [
            '<div class="section section1">',
            '<div class="paper-title title">',
            '<tpl if="this.hasShopItems() || this.hasArenaShop()">',
            '<h4>' + ExGods.getMsgByKey('arena_hint_title') + '</h4>',
            '<tpl else>',
            '<h4>' + me.clientConfig.enemy_search_title + '</h4>',
            '</tpl>',
            '</div>',
            '<div class="content"><div style="text-align: center">',
            '<tpl if="this.isQueueState(values)">',
            '<div class="queue-timer" id="arena2-queue-time">',
            '{[this.printQueuePercent(values)]}',
            '{[this.printQueueTime(values)]}',
            '<div class="queue-separators"></div>',
            '</div>',
            '<tpl elseif="this.hasShopItems() || this.hasArenaShop()">',
            '<p class="hint">',
            ExGods.getMsgByKey('arena_hint_text'),
            '</p>',
            '<tpl if="this.getHasShopItems().length">',
            '<ul class="shop-items-list exg-share-bg-dark">',
            '<tpl foreach="this.getHasShopItems()">',
            '<li class="shop-items-list-item" data-id="{id}" style="background-image: url(' + IMAGE_URL + '{desc.img});"><div>{[this.printHasItemEndTimed(values.end)]}</div></li>',
            '</tpl>',
            '</ul>',
            '<tpl else>',
            '<div class="no-shop-items exg-share-bg-dark">',
            ExGods.getMsgByKey('arena_has_no_items_text'),
            '</div>',
            '</tpl>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena2_show_shop</span>',
            '<span role="text">',
            ExGods.getMsgByKey('arena_go_shop_btn_title'),
            '</span>',
            '<span role="cls">x-btn-text double_text_btn goto-shop-btn</span>',
            '<span role="flex:int">1</span>',
            '<span role="margin">3 5 0 0</span>',
            '<span role="width">116px</span>',
            '<span role="disabled:bool">{[!this.hasArenaShop()]}</span>',
            '</div>',
            '<tpl else>',
            '<div class="queue-timer"></div>',
            '</tpl>',
            '</div>',
            '</div>',
            '</div>',
            '<div class="v-separator"></div>',
            '<div class="section section2" style="height: 179px;">',
            '<div class="paper-title title">',
            '<h4>{[this.printArenaTitle(values)]}</h4>',
            '</div>',
            '<div class="content">',
            '<div>' + me.clientConfig.your_place_title + '</div>',
            '<div class="arena2-current-place exg-share-bg-dark">{[this.printCurrentPlace(values)]}</div>',
            '<tpl if="time_to_reward">',
            '<div>' + me.clientConfig.your_reward_title + '</div>',
            '<div class="exg-share-bg-dark">',
            '{[this.printRewards(values)]}',
            '</div>',
            '<div>{[this.printNextPlace(values)]}</div>',
            '<tpl else>',
            '<div>',
            me.clientConfig.no_rating_description,
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            '<div class="separator separator2"></div>',
            '<div class="section section4">',
            '<div class="content">',
            '<span class="description">' + me.clientConfig.rules_short_description + '</div>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="action">arena2_show_rules</span>',
            '<span role="text">',
            me.clientConfig.rules_button_text,
            '</span>',
            '<span role="cls">x-btn-text double_text_btn arena-rules-btn</span>',
            '<span role="flex:int">1</span>',
            '<span role="width">116px</span>',
            '</div>',
            '<div class="v-separator"></div>',
            '<tpl if="this.isQueueState(values)">',
            '<div class="component battle-btn">',
            '<tpl else>',
            '<div class="component battle-btn qh-object" data-qh_otype="arena_button_battle" data-qh_oid="1">',
            '</tpl>',
            '<span role="xtype">timedtimer</span>',
            '<span role="timed">{[this.getTimedName(values)]}</span>',
            '<span role="quantity">{[this.getTimedValue(values)]}</span>',
            '<span role="is_disabled:bool">{[this.isQueueState(values) || values.current_place == 1]}</span>',
            '<span role="textbutton">',
            '<span role="action">arena2_queue</span>',
            '</span>',
            '</div>',
            '</div>',
            '</div>',
            {
                getTimedName: function(values) {
                    var cost = values.cost_battle ? values.cost_battle[0] : undefined;
                    return cost ? cost.params.id : null;
                },
                getTimedValue: function(values) {
                    var cost = values.cost_battle ? values.cost_battle[0] : undefined;
                    return cost ? cost.params.quantity : null;
                },
                printRewards: function(values) {
                    var rewards = me.service.getRewardByPlace(values.current_place);
                    if (rewards) {
                        return ExGods.stuff.StuffManager.image(rewards);
                    }
                },
                printNextPlace: function(values) {
                    if (!values.next_range_place) {
                        return me.clientConfig.next_place_max_text;
                    } else {
                        return ExGods.app.applyTpl(me.clientConfig.next_place_text, {
                            place: values.current_place - values.next_range_place
                        });
                    }
                },
                printCurrentPlace: function(values) {
                    if (values.current_place > 3) {
                        return ExGods.util.Sprite.printSprite(values.current_place, 'arena/place_numbers.png', {
                            width: 10,
                            height: 24,
                            indent: '-5px',
                            cls: 'inlineblock'
                        }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                    } else {
                        return '<img src="' + ExGods.ref('images|rating_place_icons').image['place' + values.current_place] + '" />';
                    }
                },
                printArenaTitle: function(values) {
                    var tpl;
                    if (values.time_to_reward) {
                        tpl = me.clientConfig.time_to_reward_tpl;
                    } else {
                        tpl = me.clientConfig.no_time_to_reward_tpl;
                    }
                    return ExGods.app.applyTpl(tpl, {
                        time: ExGods.util.Timers.printRestTimer('arenatitle', Date.now() + values.time_to_reward * 1000)
                    });
                },
                hasArenaShop: function() {
                    return me.service.data.arena_shop.service_id;
                },
                hasShopItems: function() {
                    return me.service.data.arena_shop.has.length;
                },
                getHasShopItems: function() {
                    return me.service.data.arena_shop.has;
                },
                printHasItemEndTimed: function(date) {
                    if (date) {
                        date = ExGods.util.Date.normalizeServerDateTime(date);
                        return '<span class="exg-timer" data-date="' + date + '" data-format="twonums">' + ExGods.util.Time.printRestTime(date, {
                            format: 'twonums'
                        }) + '</span>';
                    }
                },
                isQueueState: function(data) {
                    return data.status == 'search_process';
                },
                printQueueTime: function(data) {
                    var queueDate = ExGods.util.Date.normalizeServerDateTime(data.search_start),
                        queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), data.search_time);
                    x = (queueTime % 9) * 103 + 36 , y = Math.floor(queueTime / 9) * 104 + 36;
                    return '<div class="queue-timer-value" style="background-position:-' + x + 'px -' + y + 'px"></div>';
                },
                printQueuePercent: function(data) {
                    var queueDate = ExGods.util.Date.normalizeServerDateTime(data.search_start),
                        queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), data.search_time);
                    queuePercent = Math.min(Math.floor(queueTime * 100 / data.search_time), 100) , x = (queuePercent % 9) * 103 + 10 , y = Math.floor(queuePercent / 9) * 104 + 10;
                    return '<div class="queue-timer-counter" style="background-position:-' + x + 'px -' + y + 'px"></div>';
                }
            }
        ];
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me, {
            single: true
        });
        //     
        me.getEl().on('click', function(e) {
            var el = e.getTarget(),
                itemId = el.getAttribute('data-id'),
                itemInfo;
            itemInfo = Ext.Array.findBy(me.service.data.arena_shop.has, function(item) {
                return item.id == itemId;
            });
            Ext.widget('commondetailswindow', {
                itemElement: el,
                data: {
                    label: itemInfo.desc.label,
                    description: itemInfo.desc.description,
                    image: IMAGE_URL + itemInfo.desc.img
                }
            });
        }, me, {
            delegate: '.shop-items-list-item'
        });
        ExGods.util.Ticker.addListener(me.updateQueueTime, me);
    },
    update: function(data) {
        var me = this;
        if (me.rendered) {
            ExGods.util.Helper.destroyComponents(me.el);
        }
        me.arena = data;
        me.callParent(arguments);
        if (me.rendered) {
            ExGods.util.Helper.renderComponents(me.el, me);
        }
    },
    updateQueueTime: function() {
        var me = this,
            viewEl = me.getEl(),
            queueDate, queueTime, queuePercent, el, val_el;
        if (me.arena.status == 'search_process') {
            queueDate = ExGods.util.Date.normalizeServerDateTime(me.arena.search_start);
            //queueTime = Math.max(0, me.arena.search_time*1000 - (Date.now() - queueDate));
            queueTime = Math.min(Math.ceil((Date.now() - queueDate) / 1000), me.arena.search_time);
            queuePercent = Math.min(Math.floor(queueTime * 100 / me.arena.search_time), 99);
            if (viewEl) {
                el = viewEl.select('.queue-timer-counter');
                val_el = viewEl.select('.queue-timer-value');
                var x = (queuePercent % 9) * 103 + 10,
                    y = Math.floor(queuePercent / 9) * 104 + 10,
                    val_x = (queueTime % 9) * 103 + 36,
                    val_y = Math.floor(queueTime / 9) * 104 + 36;
                el.setStyle('background-position', '-' + x + 'px -' + y + 'px');
                val_el.setStyle('background-position', '-' + val_x + 'px -' + val_y + 'px');
            }
        }
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateQueueTime);
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [];
        var arr_images = [];
        if (me.data.cost_battle) {
            stuff_arr = stuff_arr.concat(me.data.cost_battle);
        }
        /*
        if (me.data.cost_search) {
            stuff_arr = stuff_arr.concat(me.data.cost_search);
        }
        */
        var places = ExGods.ref('images|rating_place_icons').image;
        for (var i in places) {
            arr_images.push(places[i]);
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [
                IMAGE_URL + 'button-text-30.png',
                IMAGE_URL + 'btn_wide_red.png',
                IMAGE_URL + ExGods.getMsgByKey('place_img')
            ].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.arena2.EnemyList', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena2_enemylist',
    layout: 'hbox',
    cls: 'robbery arena2 enemy-list',
    padding: '0 8',
    initComponent: function() {
        var me = this;
        me.items = [];
        Ext.Array.each(me.arena.enemy.users, function(user) {
            me.items.push({
                xtype: 'arena2_enemy',
                user: user,
                clientConfig: me.clientConfig,
                arena: me.arena,
                service: me.service
            });
        });
        me.dockedItems = [
            {
                dock: 'bottom',
                xtype: 'toolbar',
                layout: {
                    pack: 'center'
                },
                margin: '0 0 8',
                items: [
                    {
                        xtype: 'textbutton',
                        text: me.clientConfig.enemy_list_refresh_btn,
                        action: 'arena2_refresh'
                    }
                ]
            }
        ];
        me.callParent();
    },
    updateView: function(data) {
        var me = this;
        me.arena = data;
        me.removeAll();
        var arr_images = [];
        Ext.Array.each(me.arena.enemy.users, function(user) {
            var img = ExGods.ref('user_shape|' + user.shape).thumb;
            arr_images.push(img);
        });
        var wdgts = [];
        Ext.Array.each(me.arena.enemy.users, function(user) {
            wdgts.push(Ext.widget('arena2_enemy', {
                user: user,
                autoShow: false,
                clientConfig: me.clientConfig,
                arena: me.arena,
                service: me.service
            }));
        });
        ExGods.Resources.load({
            items: {
                items: wdgts
            },
            getResources: function() {
                return {
                    images: [].concat(arr_images)
                };
            }
        }, function() {
            me.add(wdgts);
        });
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: []
        };
    }
});

Ext.define('ExGods.view.arena2.Container', {
    extend: Ext.container.Container,
    alias: 'widget.arena2container',
    id: 'arena2_container',
    layout: 'card'
});

/**
 *   
 */
Ext.define('ExGods.view.arena2.Rating', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena_rating2',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'arena rating',
    itemsPerPage: 7,
    textFilter: '',
    /**
     * @cfg {Object} arena  
     */
    arena: {},
    /**
     * @cfg {Array} list 
     */
    list: [],
    initComponent: function() {
        var me = this;
        //   
        me.list = Ext.Array.sort(me.list, function(a, b) {
            return a.rank - b.rank;
        });
        me.items = [
            {
                xtype: 'container',
                plugins: [
                    'paperdeco'
                ],
                height: 284,
                items: [
                    {
                        itemId: 'list',
                        tpl: [
                            '<div class="paper-title title">',
                            '<tpl if="arena.season">',
                            '<h4>{[this.applyTitleTpl(values.arena)]}</h4>',
                            '<tpl else >',
                            '<h4>{[this.applyNoSeasonTpl(values.arena)]}</h4>',
                            '</tpl>',
                            '</div>',
                            '<div class="subtitle">{[this.applyTrophyTpl(values.arena)]}</div>',
                            '<div class="separator"></div>',
                            '<tpl if="list.length">',
                            '<table class="list">',
                            '<tpl for="list">',
                            '<tr class="{[ xindex % 2 ? "exg-share-bg-light" : "exg-share-bg-dark" ]}">',
                            '<td class="place-cell">',
                            '<tpl if="rank &gt;= 1 && rank &lt;= 3">',
                            '<div class="place-{rank}"><img width="76" height="24" src="{[ this.getPlaceImage(values.rank) ]}"></div>',
                            '<tpl else>',
                            '<span>{[this.printPlace(values.rank)]}</span>',
                            '</tpl>',
                            '</td>',
                            '<td class="username-cell">',
                            '{[ ExGods.printUser(values.info, {fields: "guild,name,rank,level,infoicon", maxNameWidth: 112}) ]}',
                            '</td>',
                            '</tr>',
                            '</tpl>',
                            '</table>',
                            '<tpl else>',
                            '<div class="empty-msg">' + ExGods.ref('message_client|arena_rating_empty_msg') + '</div>',
                            '</tpl>',
                            {
                                applyTitleTpl: function(arena) {
                                    var restTime = '<span id="arena-rating-rest-time-' + arena.id + '">' + ExGods.util.Time.printRestTime(ExGods.util.Date.normalizeServerDateTime(arena.finish_date), {
                                            format: 'threenums',
                                            emptyText: ExGods.getMsgByKey('arena_season_finish_msg')
                                        }) + '</span>';
                                    return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_title'), {
                                        season: arena.season,
                                        time: restTime
                                    });
                                },
                                applyNoSeasonTpl: function(arena) {
                                    return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_no_season_title'), {
                                        label: arena.label
                                    });
                                },
                                applyTrophyTpl: function(arena) {
                                    if (arena.rating_info && arena.rating_info.value && arena.rating_info.rank) {
                                        var params = {
                                                place: arena.rating_info.rank,
                                                trophy: this.printTrophy(arena.rating_info.value) + Ext.util.Format.plural(arena.rating_info.value, ExGods.getMsgByKey('trophy_name').split(','))
                                            };
                                        if (arena.rating_top_list) {
                                            return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace'), Ext.apply({
                                                time: this.printDate(arena.rating_top_list.info.last_time)
                                            }, params));
                                        } else {
                                            return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace_no_time'), params);
                                        }
                                    } else if ((arena.elo_value || arena.elo_value == 0) && arena.rating_info && arena.rating_info.value != null) {
                                        var trophy = this.printTrophy(arena.rating_info.value) + Ext.util.Format.plural(arena.rating_info.value, ExGods.getMsgByKey('trophy_name').split(','));
                                        return ExGods.app.applyTpl(ExGods.getMsgByKey('view_arena_rating_curplace_after_season'), {
                                            trophy: trophy
                                        });
                                    } else {
                                        return ExGods.getMsgByKey('view_arena_rating_curplace_no_trophy');
                                    }
                                },
                                printTrophy: function(num) {
                                    return '<span class="trophy-num">' + num + '</span>';
                                },
                                printDate: function(dateStr) {
                                    var dt = ExGods.util.Date.normalizeServerDateTime(dateStr);
                                    return Ext.Date.format(dt, 'd.m.Y H:i');
                                },
                                getPlaceImage: function(rank) {
                                    return ExGods.ref('images|rating_place_icons').image['place' + rank];
                                },
                                printPlace: function(place) {
                                    return ExGods.util.Sprite.printSprite(place, 'arena/place_numbers.png', {
                                        width: 10,
                                        height: 24,
                                        indent: '-5px',
                                        cls: 'inlineblock'
                                    }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                                }
                            }
                        ],
                        data: {
                            arena: me.arena,
                            list: me.list.slice(0, me.itemsPerPage)
                        }
                    }
                ]
            }
        ];
        me.plugins = me.plugins || [];
        me.plugins.push({
            ptype: 'pager',
            marginLeft: -27,
            marginRight: -27,
            top: 127,
            textTop: -32,
            textLeft: 249,
            total: Math.ceil(me.list.length / me.itemsPerPage)
        });
        me.listeners = {
            prev: me.updateList,
            next: me.updateList,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        ExGods.util.Ticker.addListener(me.updateRestTime, me);
    },
    updateRestTime: function() {
        if (!this.arena.finish_date) {
            return;
        }
        var me = this,
            viewEl = me.getEl(),
            finishDate = ExGods.util.Date.normalizeServerDateTime(me.arena.finish_date),
            el;
        if (viewEl) {
            el = viewEl.select('#arena-rating-rest-time-' + me.arena.id);
            el.setHTML(ExGods.util.Time.printRestTime(finishDate, {
                format: 'threenums',
                emptyText: ExGods.ref('message_client|arena_season_finish_msg')
            }));
        }
    },
    updateList: function() {
        var me = this,
            items = me.filtered || me.list;
        items = items.slice((me.pager.current - 1) * me.itemsPerPage, me.pager.current * me.itemsPerPage);
        me.items.items[0].getComponent('list').update({
            arena: me.arena,
            list: items
        });
        me.pager.refresh();
    },
    setTextFilter: function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        if (me.textFilter) {
            me.filtered = Ext.Array.filter(me.list, function(item) {
                return (item.info.display_title).toLowerCase().indexOf(me.textFilter) != -1;
            });
            me.pager.total = Math.ceil(me.filtered.length / me.itemsPerPage);
        } else {
            delete me.filtered;
            me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        }
        me.pager.current = 1;
        me.updateList();
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateRestTime);
        me.callParent(arguments);
    }
});

/**
 *     
 */
Ext.define('ExGods.view.arena2.Enemy', {
    extend: Ext.panel.Panel,
    alias: 'widget.arena2_enemy',
    cls: 'arena enemy-info',
    plugins: [
        'paperdeco'
    ],
    height: 274,
    width: 188,
    padding: '7 10',
    initComponent: function() {
        var me = this;
        me.data = me.user;
        me.tpl = [
            '<div class="exg-share-base-info exg-share-bg-light gender-{gender}" style="background-image: url({[ this.getUserImage(values) ]})">',
            '<span>{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank", maxNameWidth: 84})]}</span>',
            '<tpl if="guild">',
            '<span class="bold">[{guild.tag}]</span>',
            '</tpl>',
            //'<div class="arena-enemy-power">{stats.power}</div>',
            '<div class="image-frame"></div>',
            '</div>',
            '<div class="paper-separator"></div>',
            '<h5 class="exg-share-bg-dark">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</h5>',
            '<div class="stats1">',
            '{[ ExGods.util.User.printUserStats(values.stats, {visibleValue: 1, align: "right", changes: this.getStatsChanges(values)}) ]}',
            '</div>',
            '<div class="paper-separator"></div>',
            '<div class="arena-enemy-place">{[this.printPlace(values)]}</div>',
            {
                getUserImage: function(values) {
                    return ExGods.ref('user_shape|' + values.shape).thumb;
                },
                getStatsChanges: function(values) {
                    var changes = {},
                        myStats = ExGods.app.user.get('stats').stats;
                    Ext.Object.each(values.stats, function(k, v) {
                        if (typeof myStats[k] != 'undefined') {
                            changes[k] = v - myStats[k];
                        }
                    });
                    return changes;
                },
                printPlace: function(values) {
                    return ExGods.util.Sprite.printSprite(values.arena2_place, 'arena/place_numbers.png', {
                        width: 10,
                        height: 24,
                        indent: '-5px',
                        cls: 'inlineblock'
                    }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                }
            }
        ];
        me.dockedItems = [
            {
                dock: 'bottom',
                xtype: 'textbutton',
                text: me.clientConfig.attack_btn,
                cls: 'no_border x-btn-txt-red',
                margin: '0 25 15 25',
                action: 'arena2_attack',
                user_title: me.user.display_title
            }
        ];
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var img = ExGods.ref('user_shape|' + me.data.shape).thumb;
        return {
            images: [
                img,
                IMAGE_URL + ExGods.getMsgByKey('place_img')
            ].concat(arr_images)
        };
    }
});

/**
 *  
 *
 * @author  
 *
 */
Ext.define('ExGods.controller.Arena2', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Arena2:'
    },
    models: [
        'Arena'
    ],
    views: [
        'arena2.Arena',
        'arena2.Container',
        'arena2.Rating',
        'arena2.Rules',
        'arena2.EnemyList',
        'arena2.Enemy',
        'arena.ArenaShop'
    ],
    stores: [
        'ShopItems'
    ],
    tooltips: [
        'text'
    ],
    isArenaBattle: false,
    init: function() {
        var me = this;
        me.arenaShopStore = Ext.create('ExGods.store.ShopItems');
        me.control({
            'textbutton[action="arena2_queue"]': {
                click: me.onQueueButtonClick
            },
            'textbutton[action="arena2_attack"]': {
                click: me.onAttackButtonClick
            },
            'textbutton[action="arena2_refresh"]': {
                click: me.onRefreshButtonClick
            },
            'textbutton[action="arena2_show_shop"]': {
                click: me.onShowShopClick
            },
            'textbutton[action="arena2_show_rules"]': {
                click: me.onShowRulesClick
            }
        });
        me.app.chatcn.on('command_refresh_arena2', me.onArenaChatCommand, me);
        ExGods.Components.addComponentInitializer('arena2', me.initArenaComponent, me);
        ExGods.util.Timers.on('arenatitle-expire', me.onTimerExpired, me);
    },
    /**
     *    
     */
    initArenaComponent: function(config, componentId) {
        var me = this,
            items = [],
            wnd,
            icons = ExGods.ref('images|arena_icons').image;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        me.arena = me.service.data.arena;
        me.clientConfig = config;
        //  
        items.push({
            xtype: 'arena2container',
            service: me.service,
            arena: me.arena,
            tabConfig: {
                tooltip: me.arena.label,
                icon: icons.arena_tab
            },
            clientConfig: config
        });
        //  
        if (me.arena.rating_top_list && !Ext.Object.isEmpty(me.arena.rating_top_list.data)) {
            items.push({
                xtype: 'arena_rating',
                arena: me.arena,
                list: me.arena.rating_top_list.data.ranks,
                tabConfig: {
                    tooltip: ExGods.getMsgByKey('arena_tooltip_rating'),
                    icon: icons.rating_tab
                },
                clientConfig: config
            });
        }
        //  
        if (me.service.data.arena_shop.service_id) {
            items.push({
                xtype: 'arena_shop',
                shopService: me.service.data.arena_shop.service_id,
                store: me.arenaShopStore,
                tabConfig: {
                    tooltip: ExGods.getMsgByKey('arena_tooltip_shop'),
                    icon: icons.arena_shop_tab
                },
                clientConfig: config
            });
        }
        var closeCallback = function() {
                ExGods.loaderCt.loadAndRemove(function() {
                    wnd.close();
                }, {
                    img: config.backgroundImage
                });
            };
        Ext.apply(config, {
            rightPanelX: 250,
            closeCallback: closeCallback,
            margin: '0 10 10 0',
            items: [
                {
                    xtype: 'skintabpanel',
                    items: items,
                    width: 580,
                    height: 363,
                    y: 10,
                    x: 250,
                    plugins: [
                        'skindeco'
                    ],
                    closable: true,
                    listeners: {
                        beforeclose: {
                            fn: function() {
                                closeCallback();
                                return false;
                            }
                        },
                        tabchange: me.onTabChange,
                        scope: me
                    }
                },
                {
                    xtype: 'form',
                    x: 530,
                    y: 20,
                    width: 270,
                    height: 30,
                    layout: {
                        type: 'hbox',
                        pack: 'end'
                    },
                    tbar: {
                        xtype: 'panel',
                        bodyCls: 'parchment-content-nop',
                        bodyPadding: 0,
                        height: 30,
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        margin: '0 0 5 0',
                        defaults: {
                            margin: '0 1'
                        },
                        items: [
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('arena_search_empty_text'),
                                itemId: 'text-search',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: me.filterBySearch,
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            },
                            {
                                xtype: 'checkboxfield',
                                boxLabel: ExGods.getMsgByKey('view_shop_tabs_avail'),
                                checked: true,
                                hidden: true,
                                itemId: 'availability',
                                style: {
                                    color: '#e3ac69'
                                },
                                listeners: {
                                    change: function(f, value) {
                                        me.updateFilters('level', value);
                                    },
                                    scope: me
                                },
                                margin: '0 10 0 0'
                            },
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('view_shop_tabs_seachbyname'),
                                itemId: 'title',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: {
                                        fn: function(f, value) {
                                            me.updateFilters('text', value);
                                        },
                                        buffer: 100
                                    },
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            }
                        ]
                    }
                }
            ]
        });
        var cmp = Ext.apply({
                xtype: 'room'
            }, config);
        wnd = Ext.widget('window1', {
            itemId: componentId,
            items: [
                cmp
            ],
            autoShow: false,
            listeners: {
                close: function() {
                    me.enemiesCard = null;
                    me.searchCard = null;
                },
                scope: me
            }
        });
        me.cmp = wnd.down('room');
        me.cmp.getArenaComponent = function(id) {
            if (this.rendered) {
                return this.items.items[0].getComponent('arena-' + id);
            }
        };
        var all_stuff = Ext.Array.clean(Ext.Array.union(Ext.Array.union.apply(Ext.Array, Ext.Array.map(me.arena.reward_list, function(el) {
                return el.prize;
            })), me.arena.cost_battle, me.arena.cost_search));
        ExGods.app.getController('Location').maskLocation(function() {
            ExGods.helpme.loadProtosFromStuff(all_stuff, function() {
                //  
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    me.updateViews();
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.backgroundImage
        });
        return wnd;
    },
    onQueueButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('      id-', btn.arena_id);
        delete me.f_arena_queue_success;
        me.service.command('arena2_search', {
            id: 2
        }, function(json) {
            if (!me.f_arena_queue_success && json.success) {
                me.arena = json.info;
                me.updateViews();
            }
        });
    },
    onAttackButtonClick: function(btn) {
        var me = this,
            arena;
        /***/
        me.log('     id-', btn.arena_id);
        me.setButtonsDisable([
            'attack',
            'refresh'
        ], true);
        me.service.command('arena2_accept', {
            title: btn.user_title
        }, function(json) {
            if (!json.success) {
                me.setButtonsDisable([
                    'attack',
                    'refresh'
                ], false);
            }
        });
    },
    onRefreshButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('      id-', btn.arena_id);
        me.setButtonsDisable([
            'attack',
            'refresh'
        ], true);
        delete me.f_arena_queue_success;
        me.service.command('arena2_reroll', {}, function(json) {
            if (json.success) {
                me.arena = json.info;
                me.updateViews();
            }
            me.setButtonsDisable([
                'attack',
                'refresh'
            ], false);
        });
    },
    onArenaChatCommand: function(chatcn, data) {
        var me = this;
        /***/
        me.log('   ""  ', data);
        me.service.update(null, function() {
            me.arena = me.service.data.arena;
            me.updateViews();
        });
    },
    onTabChange: function(panel, tab) {
        var me = this,
            searchField = me.cmp.down('#text-search'),
            shopTitleSearch = me.cmp.down('#title'),
            shopAvailability = me.cmp.down('#availability');
        if (tab.xtype == 'arena_rating2') {
            searchField.el.select('input').elements[0].value = tab.textFilter || '';
            //      
            searchField.show();
        } else {
            searchField.hide();
        }
        if (tab.xtype == 'arena_shop') {
            shopTitleSearch.el.select('input').elements[0].value = '';
            //      
            shopTitleSearch.show();
            shopAvailability.show();
        } else {
            shopTitleSearch.hide();
            shopAvailability.hide();
        }
        if (tab.xtype == 'arena_shop' && me.arenaShopStore.getCount() == 0) {
            me.updateShop(tab);
        }
    },
    updateViews: function() {
        var me = this;
        if (!me.cmp.down) {
            return;
        }
        var container = me.cmp.down('arena2container');
        if (!container)  {
            return;
        }
        
        //     -  card ,  
        if (me.arena.enemy.users) {
            me.showEnemiesCard();
        } else {
            me.showSearchCard();
        }
    },
    showSearchCard: function() {
        var me = this,
            container = me.cmp.down('arena2container');
        if (!me.searchCard) {
            me.searchCard = Ext.widget('arena2', {
                service: me.service,
                arena: me.arena,
                autoShow: false,
                clientConfig: me.clientConfig
            });
            ExGods.Resources.load(me.searchCard, function() {
                container.add(me.searchCard);
            });
        } else {
            me.searchCard.update(me.arena);
        }
        container.getLayout().setActiveItem(me.searchCard);
    },
    showEnemiesCard: function() {
        var me = this,
            container = me.cmp.down('arena2container');
        if (!me.enemiesCard) {
            me.enemiesCard = Ext.widget('arena2_enemylist', {
                service: me.service,
                arena: me.arena,
                autoShow: false,
                clientConfig: me.clientConfig
            });
            ExGods.Resources.load(me.enemiesCard, function() {
                container.add(me.enemiesCard);
            });
        } else {
            me.enemiesCard.updateView(me.arena);
        }
        container.getLayout().setActiveItem(me.enemiesCard);
    },
    updateFilters: function(filterName, value) {
        var me = this,
            shop = me.cmp.down('arena_shop');
        shop.updateFilters.apply(shop, arguments);
    },
    updateShop: function(shopView) {
        if (typeof shopView.shopService != 'object') {
            shopView.shopService = ExGods.Services.factory(shopView.shopService);
        }
        shopView.shopService.init(null, function(service) {
            ExGods.helpme.loadProtos(service.data.shops[0].items, 'item.item', function() {
                shopView.store.loadRawData(service.data.shops[0].items);
            });
        });
    },
    filterBySearch: function(searchField) {
        var me = this,
            str = searchField.getValue(),
            tabs = me.cmp.query('tabpanel')[0],
            tab = tabs.getActiveTab();
        if (tab.setTextFilter) {
            tab.setTextFilter(str);
        }
    },
    setButtonsDisable: function(btnNames, disabled) {
        var me = this,
            query;
        if (me.cmp) {
            Ext.Array.each(btnNames, function(btnName) {
                Ext.Array.each(Ext.ComponentQuery.query('textbutton[action="arena2_' + btnName + '"]'), function(btn) {
                    btn.setDisabled(disabled);
                });
            });
        }
    },
    onShowShopClick: function(btn) {
        var me = this,
            tabs = me.cmp.down('skintabpanel');
        tabs.setActiveTab('arena_shop');
    },
    onShowRulesClick: function(btn) {
        var me = this,
            wnd;
        wnd = Ext.widget('window2', {
            width: 540,
            x: 160,
            autoShow: false,
            items: [
                {
                    xtype: 'arenarules',
                    arena: me.arena,
                    clientConfig: me.clientConfig
                }
            ]
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
        });
        return wnd;
    },
    onTimerExpired: function() {
        var me = this;
        me.service.update(null, function() {
            me.arena = me.service.data.arena;
            me.updateViews();
            ExGods.app.unblock();
        });
    },
    /**
     *       
     */
    updateComponents: function() {
        var me = this,
            innerCmp = me.cmp.getArenaComponent(me.arena.get('id'));
        if (innerCmp) {
            innerCmp.update(me.arena.data);
        }
    }
});

/**
 *  
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGods.view.ConfirmationDialog', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.confirmdialog',
    /**
     * @cfg {String} message  
     */
    message: '',
    /**
     * @cfg {Array} buttonsText   
     */
    buttonsText: null,
    minWidth: 250,
    y: 260,
    //     
    /**
     * @cfg {Function|Object} handler    -     {fn, scope}
     */
    handler: Ext.emptyFn,
    handler_negative: Ext.emptyFn,
    initComponent: function() {
        var me = this;
        if (!me.buttonsText)  {
            me.buttonsText = ExGods.getMsgByKey('view_confirm_yesno').split(';');
        }
        
        //  id ,    "  "
        var bbar_list = me.entry ? {
                layout: 'auto',
                items: {
                    xtype: 'container',
                    autoEl: 'center',
                    defaultType: 'button',
                    items: {
                        xtype: 'checkboxfield',
                        boxLabel: ExGods.getMsgByKey('view_confirm_closehint'),
                        itemId: 'not_show_next_time',
                        margin: '2 2 2 2'
                    }
                }
            } : '';
        Ext.apply(me, {
            autoShow: true,
            html: me.message,
            bodyStyle: 'text-align: center; max-width: 340px; line-height: 18px; overflow: visible;',
            buttonAlign: 'center',
            buttons: {
                defaultType: 'textbutton',
                items: [
                    {
                        text: me.buttonsText[0],
                        cls: 'no_border qh-object',
                        handler: function() {
                            var me = this;
                            //   "  " ()
                            if (me.down('#not_show_next_time') && me.down('#not_show_next_time').getValue()) {
                                ExGods.app.fireEvent('notshowhint', me.entry);
                            }
                            if (typeof me.handler == 'object') {
                                me.handler.fn.call(me.handler.scope ? me.handler.scope : me);
                            } else {
                                me.handler.call(me);
                            }
                            me.close();
                        },
                        listeners: {
                            render: function() {
                                if (me.quest_helper_id)  {
                                    // 
                                    this.el.set({
                                        'data-qh_otype': me.quest_helper_type,
                                        'data-qh_oid': me.quest_helper_id
                                    });
                                }
                                
                            }
                        },
                        scope: me
                    },
                    {
                        handler: function() {
                            //   "  " ()
                            if (me.down('#not_show_next_time') && me.down('#not_show_next_time').getValue()) {
                                ExGods.app.fireEvent('notshowhint', me.entry);
                            }
                            if (typeof me.handler_negative == 'object') {
                                me.handler_negative.fn.call(me.handler_negative.scope ? me.handler_negative.scope : me);
                            } else {
                                me.handler_negative.call(me);
                            }
                            me.close();
                        },
                        cls: 'x-btn-txt-red no_border',
                        text: me.buttonsText[1]
                    }
                ]
            },
            bbar: bbar_list
        });
        me.callParent();
    }
});

/**
 *     
 *
 *     ,   ExGods.model.Action,
 *         url.
 * 
 * @author  
 *
 */
Ext.define('ExGods.controller.Action', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'ActionController:'
    },
    models: [
        'Action'
    ],
    views: [
        'ConfirmationDialog'
    ],
    init: function() {},
    //
    /**
     *   
     *
     * @param {ExGods.model.Action} action  
     * @param {Function} callback ,   .    :
     *
     *      json {Object}   
     *
     * @param {Object} scope this  
     */
    doAction: function(action, callback, scope) {
        var me = this,
            target = action.get('target'),
            selectedTarget = action.get('selected_target');
        /**/
        me.log('  "' + action.get('label') + '"..', action.data);
        callback = callback || Ext.emptyFn;
        scope = scope || this;
        if (action.isBattleAction() && !me.getUser().isBattle()) {
            /**/
            me.log('warning >>     ');
            return;
        }
        if (target) {
            /**/
            me.log('     "' + target + '".    ..');
            if (selectedTarget) {
                /**/
                me.log('  ', selectedTarget);
                /**/
                me.log('    ..');
                me.doActionRequest(action, {
                    target: selectedTarget
                }, function(json) {
                    callback.call(scope, json);
                });
            } else if (target == ExGods.model.Action.ONLINE_LIST_TARGET) {
                me.showOnlineListTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log(' ', selectedTarget);
                    /**/
                    me.log('    ..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.up('window').close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.STRING) {
                me.showStringTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log(' ', selectedTarget);
                    /**/
                    me.log('    ..');
                    me.doActionRequest(action, {
                        target: null,
                        param: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.ITEM_TARGET) {
                me.showItemTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log(' ', selectedTarget);
                    /**/
                    me.log('    ..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.ITEM_FILTER_TARGET) {
                me.showItemFilterTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log(' ', selectedTarget);
                    /**/
                    me.log('    ..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.ITEM_UPGRADED_TARGET) {
                me.showItemUpgradeTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log(' ', selectedTarget);
                    /**/
                    me.log('    ..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.BLACK_LIST_USER_TARGET) {
                me.showBlackListTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log(' ', selectedTarget);
                    /**/
                    me.log('    ..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.USER_TARGET) {
                me.showUserTargetWindow(action, function(win, selectedTarget) {
                    /**/
                    me.log(' ', selectedTarget);
                    /**/
                    me.log('    ..');
                    me.doActionRequest(action, {
                        target: selectedTarget
                    }, function(json) {
                        win.close();
                        callback.call(scope, json);
                    });
                }, me);
            } else if (target == ExGods.model.Action.CONTEXT_TARGET) {
                me.doActionRequest(action, {}, function(json) {
                    callback.call(scope, json);
                });
            }
        } else {
            /**/
            me.log(' ');
            me.doActionRequest(action, {}, function(json) {
                callback.call(scope, json);
            });
        }
    },
    /**
     * @private
     *      -  
     * @param {ExGods.model.Action} action       
     * @param {Function} callback    ,     -      
     */
    showOnlineListTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('USER_TARGET_PANEL', {
                source: (action.isBattleAction()) ? 'battle' : 'contacts',
                dead: action.get('dead'),
                side: action.get('side'),
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, action.isBattleAction() ? target.getBattleEkey() : target.get('display_title'));
                    },
                    destroy: function(view) {
                        view.store.destroyStore();
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    /**
     * @private
     *     ()  black-
     * @param {ExGods.model.Action} action       
     * @param {Function} callback    ,     -      ()
     */
    showBlackListTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('USER_TARGET_PANEL', {
                source: 'blacklist',
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, target.get('display_title'));
                    },
                    destroy: function(view) {
                        view.store.destroyStore();
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    // cmp.up('window').mask();
    /**
     * @private
     *       
     * @param {ExGods.model.Action} action       
     * @param {Function} callback    ,     -      ( )
     */
    showUserTargetWindow: function(action, callback, scope) {
        var me = this,
            win,
            items = [];
        win = Ext.widget('commonwindow', {
            autoShow: true,
            width: 260,
            y: 150,
            bodyPadding: 0,
            layout: {
                type: 'vbox',
                align: 'stretch'
            },
            title: action.get('label'),
            items: [
                {
                    xtype: 'textfield',
                    emptyText: ExGods.getMsgByKey('user_target_empty_text'),
                    anchor: '100%'
                },
                {
                    xtype: 'textbutton',
                    itemId: 'applyButton',
                    text: ExGods.getMsgByKey('apply_btn_text'),
                    handler: function(btn) {
                        var targetName = Ext.String.trim(win.down('textfield').getValue());
                        if (targetName) {
                            callback.call(scope || me, win, targetName);
                        }
                    },
                    margin: '10 5 0 5',
                    cls: 'no_border'
                }
            ]
        });
    },
    /**
     * @private
     *      
     * @param {ExGods.model.Action} action       
     * @param {Function} callback    ,     -      (     "slot_id|item_id")
     */
    showItemTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('ITEM_TARGET_PANEL', {
                source: 'damaged',
                windowTitle: action.data.label,
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, target.get('slot_id') + '|' + target.get('item_id'));
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    showItemFilterTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('ITEM_TARGET_PANEL', {
                source: 'filtered',
                windowTitle: action.data.label,
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                targetParams: action.get('target_params'),
                actionParams: action.get("params"),
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, target.get('slot_id') + '|' + target.get('item_id'));
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    /**
     * @private
     *    ,     
     * @param {ExGods.model.Action} action       
     * @param {Function} callback    ,     -      (     "slot_id|item_id")
     */
    showItemUpgradeTargetWindow: function(action, callback, scope) {
        var me = this;
        var cmp = ExGods.Components.factory('ITEM_TARGET_PANEL', {
                source: 'upgraded',
                windowTitle: action.data.label,
                action: {
                    type: 'map_action',
                    params: {
                        map_action: [
                            action.data
                        ]
                    }
                },
                listeners: {
                    select: function(win, target) {
                        callback.call(scope || this, win, target.get('slot_id') + '|' + target.get('item_id'));
                    }
                }
            });
    },
    //cmp.setTitle(action.get('label'));
    /**
     * @private
     *     
     * @param {ExGods.model.Action} action       
     * @param {Function} callback    ,     -      (     "slot_id|item_id")
     */
    showStringTargetWindow: function(action, callback, scope) {
        var me = this;
        var win = Ext.widget('floatwindow', {
                autoShow: true,
                width: 360,
                height: 150,
                plugins: [
                    'skinpaperdeco'
                ],
                y: 100,
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                items: [
                    {
                        xtype: 'component',
                        cls: 'paper-title',
                        html: action.data.label,
                        margin: '2',
                        style: {
                            'font-weight': 'bold'
                        }
                    },
                    {
                        xtype: 'textfield',
                        padding: '10 20',
                        emptyText: ExGods.getMsgByKey('rename_action_placeholder_text')
                    }
                ],
                dockedItems: {
                    dock: 'bottom',
                    layout: {
                        type: 'hbox',
                        pack: 'center'
                    },
                    defaults: {
                        cls: 'no_border',
                        margin: '0 10'
                    },
                    items: [
                        {
                            xtype: 'textbutton',
                            text: ExGods.getMsgByKey('yes_btn_text'),
                            handler: function() {
                                callback.call(scope || this, win, win.down('textfield').getValue());
                            }
                        },
                        {
                            xtype: 'textbutton',
                            text: ExGods.getMsgByKey('no_btn_text'),
                            cls: 'no_border x-btn-txt-red',
                            handler: function() {
                                win.close();
                            }
                        }
                    ]
                }
            });
    },
    /**
     * @private
     *     
     *
     * @param {ExGods.model.Action} action
     * @param {Object} params  
     * @param {Function} callback 
     * @param {Object} scope this  
     */
    doActionRequest: function(action, params, callback, scope) {
        var me = this,
            beforeRequest = function(action, callback) {
                callback = callback || Ext.emptyFn;
                if (action.get('images') && action.get('images').special) {
                    locationCtrl.maskLocation(callback, {
                        img: action.get('images').special
                    });
                } else {
                    me.app.block();
                    callback();
                }
            },
            afterRequest = function(json, action, callback) {
                callback = callback || Ext.emptyFn;
                if (action.get('images') && action.get('images').special) {
                    if (locationEntry == me.user.location.get('entry')) {
                        //        ,   .       
                        locationCtrl.unmaskLocation(callback, {
                            img: action.get('images').special
                        });
                    } else {
                        callback();
                    }
                } else {
                    me.app.unblock();
                    callback();
                }
            },
            doRequest = function(action, params, callback) {
                var requestUrl;
                if (action.isBattleAction()) {
                    requestUrl = 'battle.pl';
                } else if (action.isServiceAction()) {
                    requestUrl = 'map.pl';
                } else {
                    requestUrl = 'map.pl';
                }
                params = params || {};
                if (action.isBattleAction()) {
                    params.cmd = 'battle_item';
                } else if (action.get('type') == 'repair') {
                    params.cmd = 'item_repair';
                } else if (action.isInventoryAction()) {
                    params.cmd = 'item_map_action';
                } else if (action.isLocationAction()) {
                    params.cmd = 'map_action_location';
                } else if (action.isServiceAction()) {
                    params.cmd = 'map_action_service';
                } else {
                    /***/
                    me.log('warn', '  ', action.data);
                    return;
                }
                params.service_id = action.get('service_id');
                params.entry = action.get('entry');
                if (action.isBattleAction()) {
                    params.round = me.app.getController('battle.Battle').state.round;
                    if (!action.get('target')) {
                        params.target = me.getUser().getBattleEkey();
                    }
                }
                if (action.get('source') instanceof ExGodsCore.model.Item) {
                    params.item = action.get('source').get('item_id');
                    params.slot = action.get('source').get('slot_id');
                }
                if (action.get('condition_action')) {
                    params.condition_action = action.get('condition_action');
                }
                /**/
                me.log('  ..');
                /**/
                me.log('url: ' + requestUrl);
                /**/
                me.log(': ', params);
                beforeRequest(action, function() {
                    me.request({
                        url: requestUrl,
                        params: params,
                        success: function(json) {
                            afterRequest(json, action, function() {
                                if (callback) {
                                    callback(json);
                                }
                                if (action.isBattleAction()) {
                                    //    -     
                                    me.app.getController('battle.Battle').onItemActionHandler(json);
                                }
                            });
                        }
                    });
                });
            },
            locationCtrl = me.app.getController('Location'),
            locationEntry = me.user.location.get('entry'),
            confirmation = action.get('confirm');
        if (confirmation && confirmation.confirmated) {
            //     -   
            Ext.widget('confirmdialog', {
                title: '',
                message: ExGods.app.applyTpl(confirmation.confirmated, action.data),
                handler: Ext.bind(doRequest, scope || me, [
                    action,
                    params,
                    callback
                ]),
                buttonsText: [
                    confirmation.btn_yes ? ExGods.app.applyTpl(confirmation.btn_yes) : ExGods.getMsgByKey('apply_btn_text'),
                    confirmation.btn_no ? ExGods.app.applyTpl(confirmation.btn_no) : ExGods.getMsgByKey('cancel_btn_text')
                ]
            });
        }
        //      } else if (action.hasConfirmation()) {
        //
        //          var hintsController = me.app.getController('Hints'),
        //              hintsArray;
        //          hintsArray = hintsController.getConfirmationHintsFromArray(action.get('hints')); //      " "      
        //          if (hintsArray.length) {
        //              hintsController.showConfirmations(
        //                  hintsArray,
        //                  function() { doRequest.apply(scope || me, [action, params, callback]); }
        //              );
        //          }
        else if (action.hasCost()) {
            //    -   
            Ext.widget('confirmdialog', {
                title: '',
                message: ExGods.app.applyTpl(ExGods.getMsgByKey('action_cost_confirmation'), action.data),
                handler: Ext.bind(doRequest, scope || me, [
                    action,
                    params,
                    callback
                ])
            });
        } else // buttonsText: ['', '']
        {
            doRequest.apply(scope || me, [
                action,
                params,
                callback
            ]);
        }
    }
});

Ext.define('ExGods.view.bank.stuff.BankBonus', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.stuff.decorator.BonusStick);
        return data;
    }
});

/**
 *     -  
 */
Ext.define('ExGods.view.skin.Tab', {
    extend: Ext.tab.Tab,
    alias: 'widget.skintab',
    border: 0,
    counter: 0,
    /**
     * @property {Ext.Element} counterEl
     *  
     * @private
     */
    height: 49,
    margin: 0,
    padding: 0,
    width: 53,
    ui: 'skin',
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.btnEl.insertHtml('beforeBegin', '<div class="skin-tab-left-border"></div>', true);
        me.btnEl.insertHtml('afterEnd', '<div class="skin-tab-right-border"></div>', true);
        me.counterEl = me.btnEl.insertHtml('beforeEnd', '<div class="counter"></div>', true);
        me.counterEl.setVisibilityMode(Ext.Element.DISPLAY);
        me.counterEl[me.counter ? 'show' : 'hide']();
        if (me.countLabel) {
            me.item.store.on('datachanged', me.onCountChange, me);
            me.onCountChange();
        }
    },
    onCountChange: function(store, filters) {
        var me = this,
            numbers = '',
            qcont = me.btnEl.down('.quantity-container'),
            quantity = me.item.store.data.length.toString();
        for (var i = 0; i < quantity.length; i++) {
            numbers += '<div class="tab-number" style="background-image:url(' + IMAGE_URL + 'quests/tasks_sprite_' + quantity.charAt(i) + '.png)"></div>';
        }
        if (qcont) {
            qcont.destroy();
        }
        me.btnEl.insertHtml('beforeEnd', '<div class="quantity-container" id="quantity-container" style="left:' + me.quantityLeft + 'px">' + numbers + '</div>');
    },
    addCount: function(value) {
        var me = this;
        me.counter += value;
        if (me.counterEl) {
            me.counterEl[me.counter ? 'show' : 'hide']();
            me.counterEl.setHTML(me.counter);
        }
    },
    reset: function() {
        var me = this;
        me.counter = 0;
        if (me.counterEl)  {
            me.counterEl.hide();
        }
        
        var mainMenuCounter = 0;
        me.up().items.each(function(tab) {
            mainMenuCounter += tab.counter;
        });
        if (!mainMenuCounter) {
            var mainMenuBtn = Ext.getCmp('mainmenu-' + me.up('panel').menuId + '-button');
            if (mainMenuBtn) {
                mainMenuBtn.reset();
            }
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.skin.TabPanel', {
    extend: Ext.tab.Panel,
    alias: 'widget.skintabpanel',
    activeTab: 0,
    /**
     * @cfg
     */
    tabUi: 'skin',
    // skin  skintext
    constructor: function(config) {
        var me = this;
        config.tabBar = Ext.apply({
            height: 49,
            layout: {
                align: 'top'
            },
            margin: 0,
            padding: '0 12 0 11',
            ui: 'skin'
        }, config.tabBar || {});
        me.callParent(arguments);
    },
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {};
        }
        Ext.applyIf(item.tabConfig, {
            xtype: 'skintab',
            ui: me.tabUi,
            width: me.cls == 'inventory_tabpanel' ? 120 : me.tabUi == 'skin' ? 53 : 198
        });
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'deco/skin-tabs.png',
                IMAGE_URL + 'deco/skin-tabs.png',
                IMAGE_URL + 'checkbox-checked.png',
                IMAGE_URL + 'checkbox.png',
                IMAGE_URL + 'tab_big_inactive.png',
                IMAGE_URL + 'tab_big_hover.png',
                IMAGE_URL + 'tab_big_active.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.bank.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.banktabpanel',
    id: 'bank-tabs',
    tabUi: 'skintext',
    bodyPadding: '0 12 8 5',
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    }
});

/**
 *  "".         -   ,    
 */
Ext.define('ExGods.model.Bank', {
    singleton: true,
    /**
     *      ()  
     * @return {Number}
     */
    getGameToGoldCurs: function() {
        return ExGods.references.get('constants').get('game_curs').value;
    },
    /**
     *      ()  
     * @return {Number}
     */
    getGameToRublesCurs: function() {
        return ExGods.references.get('constants').get('curs').value / 100;
    },
    /**
     *       ()    (, )
     * @return {Array}
     */
    getRealToGameExchangePresets: function() {
        var presetsRef = ExGods.references.get('payment_preset'),
            result = [],
            curs = this.getGameToRublesCurs();
        return presetsRef.getRange();
    },
    /**
     *      ()
     * @return {Object}    - image, label
     */
    getGameCuyrrencyInfo: function() {
        var constants = ExGods.references.get('constants'),
            key = constants.get('currency_real').value;
        return ExGods.references.get('user_money').get(key);
    }
});

/**
 *   
 */
Ext.define('ExGods.view.bank.Replenishment', {
    extend: Ext.container.Container,
    alias: 'widget.bankreplenishment',
    cls: 'bank-replenishment',
    header: false,
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            bank = ExGods.model.Bank,
            gold = ExGods.references.get('user_money').get('gold'),
            coins = ExGods.references.get('user_money').get('coins'),
            presets = me.service.data.payment_preset,
            items = [],
            fields = [
                {
                    name: 'bonus',
                    type: 'auto'
                },
                {
                    name: 'count',
                    type: 'int'
                },
                {
                    name: 'price',
                    type: 'float'
                },
                {
                    name: 'stuff_for_show',
                    type: 'auto'
                },
                {
                    name: 'game_currency',
                    type: 'string'
                },
                {
                    name: 'app',
                    type: 'string'
                },
                {
                    name: 'entry',
                    type: 'string'
                },
                {
                    name: 'order',
                    type: 'int'
                },
                {
                    name: 'special',
                    type: 'int'
                },
                {
                    name: 'description',
                    type: 'auto'
                },
                {
                    name: 'image',
                    type: 'string'
                },
                {
                    name: 'title',
                    type: 'string'
                }
            ];
        me.presetStore = Ext.create('Ext.data.Store', {
            fields: fields,
            data: presets,
            sorters: [
                {
                    property: 'order',
                    direction: 'ASC'
                }
            ]
        });
        me.items = [
            {
                xtype: 'panel',
                x: 0,
                y: 0,
                plugins: [
                    'paperdeco'
                ],
                data: {
                    isSocialApp: isSocialApp,
                    isVK: isVK,
                    isOK: isOK,
                    isMM: isMM,
                    isFB: isFB
                },
                tpl: [
                    '<div class="bank-header">',
                    '<tpl if="!isSocialApp">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('view_bank_repl_count_id') + '",{id:' + user.get('id') + '})]}</div>',
                    '<div>' + ExGods.getMsgByKey('view_bank_on_your_account') + ' <strong id="coins_value">' + Ext.util.Format.number(user.get('money').coins, '0,0') + ' ' + Ext.util.Format.plural(user.get('money').coins, ExGods.getMsgByKey('moneta_name').split(',')) + '</strong></div>',
                    '<div class="titan-button"></div>',
                    '</tpl>',
                    '<tpl if="isVK">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_vk') + '</div>',
                    '</tpl>',
                    '<tpl if="isOK">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_ok') + '</div>',
                    '</tpl>',
                    '<tpl if="isMM">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_mm') + '</div>',
                    '</tpl>',
                    '<tpl if="isFB">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_fb') + '</div>',
                    '</tpl>',
                    '</div>'
                ],
                width: '100%',
                height: isSocialApp ? 100 : 100
            },
            {
                xtype: 'bankpresets',
                store: me.presetStore,
                buy_btn_id: 'bank-buy'
            }
        ];
        me.mon(user, 'moneycoinschanged', function(value) {
            Ext.fly('coins_value').setHTML(Ext.util.Format.number(value, '0,0') + ' ' + Ext.util.Format.plural(value, ExGods.getMsgByKey('moneta_name').split(',')));
        }, me);
        me.callParent();
    },
    getStores: function(presets) {
        var presets_gold = [],
            presets_crystal = [];
        for (var i = 0; i < presets.length; i++) {
            if (presets[i].game_currency == "crystal") {
                presets_crystal.push(presets[i]);
            }
            if (presets[i].game_currency == "gold") {
                presets_gold.push(presets[i]);
            }
        }
        return [
            presets_gold,
            presets_crystal
        ];
    },
    onRender: function() {
        var me = this,
            btnPlace = me.el.down('.titan-button');
        if (btnPlace && !btnPlace.innerHTML) {
            me.processTitanButton(btnPlace, me.service.data.reward_button);
        }
        me.callParent(arguments);
    },
    processTitanButton: function(btnPlace, is_reward) {
        var me = this;
        if (Ext.getCmp('do-replenish')) {
            Ext.getCmp('do-replenish').destroy();
        }
        if (Ext.getCmp('do-get-reward')) {
            Ext.getCmp('do-get-reward').destroy();
        }
        if (is_reward) {
            Ext.widget('textbutton', {
                renderTo: btnPlace,
                cls: 'qh-object no_border_double x-btn-txt-green',
                minWidth: 110,
                text: ExGods.getMsgByKey('view_bank_reward_btn_text'),
                id: 'do-get-reward',
                handler: function() {
                    me.fireEvent('get_reward');
                },
                listeners: {
                    'afterrender': function() {
                        var protectBtn = me.el.down('#do-get-reward');
                        if (protectBtn) {
                            protectBtn.set({
                                'data-qh_otype': 'payment_buy_button',
                                'data-qh_oid': '1'
                            });
                        }
                    }
                }
            });
        } else {
            Ext.widget('textbutton', {
                renderTo: btnPlace,
                cls: 'qh-object no_border_double x-btn-txt-green',
                minWidth: 110,
                href: ExGods.ref('constants|bank_address').value + '/pay/?uid=' + ExGods.app.user.get('id'),
                text: ExGods.getMsgByKey('view_bank_replenishment_btn_text'),
                id: 'do-replenish',
                listeners: {
                    'afterrender': function() {
                        var protectBtn = me.el.down('#do-replenish');
                        if (protectBtn) {
                            protectBtn.set({
                                'data-qh_otype': 'payment_buy_button',
                                'data-qh_oid': '1'
                            });
                        }
                    }
                }
            });
        }
    },
    reloadReplenishment: function(service_data) {
        var me = this;
        me.processTitanButton(me.el.down('.titan-button'), service_data.reward_button);
        me.presetStore.loadRawData(service_data.payment_preset);
    },
    onDestroy: function() {
        var me = this,
            replenish_button = Ext.getCmp('do-replenish'),
            reward_button = Ext.getCmp('do-get-reward');
        if (replenish_button)  {
            replenish_button.destroy();
        }
        
        if (reward_button)  {
            reward_button.destroy();
        }
        
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'npc/human/trader_small.jpg',
                IMAGE_URL + 'button-text-30green.png',
                ExGods.getMsgByKey('view_bank_replenishment_btn_text')
            ].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.bank.Bonus', {
    extend: Ext.panel.Panel,
    alias: 'widget.bankbonus',
    bodyPadding: '4 4 10 4',
    cls: 'bank-bonus',
    header: false,
    layout: 'anchor',
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            socialNet = user.getSocialNet();
        var items = [];
        items.push({
            xtype: 'component',
            html: [
                '<p style="font-weight: bold;">',
                '<img height="16" src="' + IMAGE_URL + 'icons/' + ((socialNet && ((user.get('payment') != 'vka' && user.get('social').email_assign) || user.get('payment') == 'vka')) ? 'done' : 'undone') + '.png" style="vertical-align: text-bottom;" width="16" /> ',
                ExGods.app.applyTpl(ExGods.getMsgByKey('view_bank_bonus_addsocialtext'), {
                    gold_img: '<img title="' + ExGods.ref('user_money|gold').label + '" src="' + IMAGE_URL + 'currency/gold.png" class="stuff-icon" />'
                }),
                '</p>',
                '<div class="separator"></div>'
            ].join('')
        });
        if (!socialNet) {
            var socialConnect = Ext.widget('component', {
                    data: {
                        referralLink: '/game.pl?cmd=assign_social_net',
                        user: user.data
                    },
                    tpl: [
                        ExGods.app.applyTpl(ExGods.getMsgByKey('view_bank_bonus_socialdescr'), {
                            gold_img: '<img title="' + ExGods.ref('user_money|gold').label + '" src="' + IMAGE_URL + 'currency/gold.png" class="stuff-icon" />'
                        }),
                        '<ul class="social-icons" style="display: inline-block; vertical-align: middle;">',
                        /*'<li>',
                            '<a data-type="fb" class="social-fb" href="{referralLink}&type=fb" data-qtip="Facebook" onclick="return false;"></a>',
                        '</li>',*/
                        '<li>',
                        '<a data-type="vk" class="social-vk" href="{referralLink}&type=vk" data-qtip="" onclick="return false;"></a>',
                        '</li>',
                        '<li>',
                        '<a data-type="ok" class="social-ok" href="{referralLink}&type=ok" data-qtip="" onclick="return false;"></a>',
                        '</li>',
                        /*'<li>',
                            '<a data-type="tw" class="social-tw" href="{referralLink}&type=tw" data-qtip="" onclick="return false;"></a>',
                        '</li>',*/
                        '<li>',
                        '<a data-type="mm" class="social-mm" href="{referralLink}&type=mm" data-qtip=" " onclick="return false;"></a>',
                        '</li>',
                        '</ul>',
                        '<div class="separator"></div>'
                    ],
                    listeners: {
                        render: function(cmp) {
                            cmp.el.select('li a').each(function(el) {
                                Ext.get(el).on('click', me.onSocialConnectClick, me);
                            });
                        }
                    }
                });
            items.push(socialConnect);
        } else {
            var socialConnect = Ext.widget('component', {
                    data: user.data,
                    tpl: [
                        ExGods.getMsgByKey('view_bank_bonus_acceptedsocial'),
                        '<ul class="social-icons" style="display: inline-block; vertical-align: middle;">',
                        '<li>',
                        '<a class="social-{social.social_net}" href="{[this.getLink(values.social)]}" rel="external" target="_blank"></a>',
                        '</li>',
                        '</ul>',
                        '<div class="separator"></div>',
                        {
                            getLink: function(social) {
                                return ExGods.util.Helper.getUserSocialNetLink(social.social_net, social.social_net_id);
                            }
                        }
                    ]
                });
            items.push(socialConnect);
        }
        var email_assign = user.get('social').email_assign;
        if (!email_assign) {
            var assign = Ext.widget('form', {
                    margin: '0 0 10 14',
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [
                        {
                            xtype: 'textfield',
                            name: 'email',
                            fieldLabel: ExGods.getMsgByKey('view_bank_your_email'),
                            labelWidth: 60,
                            vtype: 'email',
                            width: 300
                        },
                        {
                            xtype: 'textbutton',
                            text: ExGods.getMsgByKey('view_bank_bonus_acceptsocialbtn'),
                            cls: 'no_border',
                            type: 'submit',
                            margin: '0 0 0 12',
                            handler: me.onEmailAssignClick,
                            scope: me
                        },
                        {
                            xtype: 'button',
                            height: 16,
                            hidden: true,
                            icon: IMAGE_URL + 'icons/done.png',
                            itemId: 'sent',
                            ui: 'image',
                            width: 16
                        }
                    ]
                });
            items.push({
                xtype: 'component',
                html: ExGods.app.applyTpl(ExGods.getMsgByKey('view_bank_bonus_emailassign'), {
                    gold_img: '<img title="' + ExGods.ref('user_money|gold').label + '" src="' + IMAGE_URL + 'currency/gold.png" class="stuff-icon" />'
                })
            }, assign);
        } else {
            items.push({
                xtype: 'component',
                html: '<p>' + ExGods.getMsgByKey('view_bank_bonus_emailprefix') + '<a href="mailto:' + email_assign + '">' + email_assign + '</a></p>'
            });
        }
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                bodyPadding: '4 4 10 4',
                items: items
            }
        ];
        me.callParent();
    },
    onSocialConnectClick: function(e, t) {
        Ext.Ajax.request({
            url: t.href,
            success: function(response) {
                var result = Ext.decode(response.responseText, true);
                if (result.success) {
                    window.location = result.redirect;
                }
            }
        });
    },
    onEmailAssignClick: function(button) {
        var me = this,
            panel = button.up('form'),
            form = panel.getForm();
        if (form.isValid()) {
            ExGods.app.getController('Bank').service.command('email_assign', form.getValues(), function(result) {
                panel.down('#sent').show();
            });
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            user = me.user,
            socialNet = user.getSocialNet();
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'icons/done.png',
                IMAGE_URL + 'currency/gold.png',
                IMAGE_URL + 'index/social.png',
                IMAGE_URL + 'icons/' + ((socialNet && ((user.get('payment') != 'vka' && user.get('social').email_assign) || user.get('payment') == 'vka')) ? 'done' : 'undone') + '.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.bank.Presets', {
    extend: Ext.view.View,
    alias: 'widget.bankpresets',
    cls: 'bank-presets',
    //margin:'17 0 0 22',
    x: 0,
    initComponent: function() {
        var me = this,
            data = [],
            constants = ExGods.references.get('constants'),
            key = constants.get('currency_real').value,
            gold = ExGods.references.get('user_money').get('gold'),
            currency = ExGods.references.get('user_money').get('crystal'),
            protosLoaded = false;
        me.tpl = [
            '<tpl for=".">',
            '<tpl if="xindex &lt; 5">',
            '<div class="bank-preset">',
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="bank-preset-content">',
            '<div class="bank-preset-image" style="background-image: url({[IMAGE_URL + values.image]});"></div>',
            '<span class="label">{title}</span>',
            '<div class="separator"></div>',
            '<div class="price">' + Ext.String.format(ExGods.getMsgByKey('view_bank_preset_price'), '<span>{[this.getGold(values)]}</span>') + '</div>',
            '<div class="separator"></div>',
            '<div class="paper-title"><h4>{[ExGods.getMsgByKey("bank_rewards_title")]}</h4></div>',
            '<div class="stuff">{[this.printStuff(values)]}</div>',
            '</div>',
            '<div class="component">',
            '<span role="xtype">container</span>',
            '<span role="layout">',
            '<span role="type">hbox</span>',
            '<span role="pack">center</span>',
            '</span>',
            '<ul role="items">',
            '<li>',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border qh-object</span>',
            '<span role="text">' + ExGods.getMsgByKey('view_bank_presets_buy_btn') + '</span>',
            '<span role="action">' + me.buy_btn_id + '</span>',
            '<span role="values">{[JSON.stringify(values)]}</span>',
            '<span role="qh:object">{[this.getJSON(values)]}</span>',
            '</li>',
            '<tpl if="this.isGiftable">',
            '<li>',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border x-btn-txt-green gift-btn</span>',
            '<span role="text">img:bank/btn_gift.png</span>',
            '<span role="action">bank-gift</span>',
            '<span role="width:int">34</span>',
            '<span role="minWidth:int">34</span>',
            '<span role="height:int">24</span>',
            '<span role="values">{[JSON.stringify(values)]}</span>',
            '<span role="tooltip">' + ExGods.getMsgByKey('view_bank_gift_btn_tip') + '</span>',
            '</li>',
            '</tpl>',
            '</ul>',
            '</div>',
            '</div>',
            '</tpl>',
            '</tpl>',
            {
                isGiftable: isFB,
                //    
                printStuff: function(values) {
                    var stuff = me.formStuff(values);
                    if (stuff && stuff.length > 2) {
                        return ExGods.util.Stuff.printStuff(stuff, {
                            display: 'block'
                        });
                    } else {
                        return protosLoaded ? ExGods.stuff.StuffManager.image(stuff) : '';
                    }
                },
                getJSON: function(values) {
                    return JSON.stringify({
                        'data-qh_otype': 'payment_exchange',
                        'data-qh_oid': values.entry
                    });
                },
                getCount: function(values) {
                    var value = values.count,
                        currency = ExGods.references.get('user_money').get(values.game_currency),
                        plurals = values.game_currency == 'gold' ? ExGods.getMsgByKey('gold_name').split(',') : ExGods.getMsgByKey('crystal_name').split(',');
                    return '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + '<strong>' + Ext.util.Format.number(value, '0,0') + '</strong> ' + Ext.util.Format.plural(value, plurals);
                },
                getGold: function(values) {
                    if (values.app != 'fba') {
                        var plurals = values.app == 'sa' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'vka' ? ExGods.getMsgByKey('payment_vka').split(',') : values.app == 'oka' ? ExGods.getMsgByKey('payment_oka').split(',') : values.app == 'mma' ? ExGods.getMsgByKey('payment_mma').split(',') : [
                                '',
                                '',
                                ''
                            ];
                        return '<strong>' + Ext.util.Format.number(values.price, '0,0') + '</strong> ' + Ext.util.Format.plural(values.price, plurals);
                    } else {
                        //     USD,       
                        if (FB.userCurrency) {
                            return '<strong>' + Ext.util.Format.number(values.price * FB.userCurrency.usd_exchange_inverse, '0,0.00') + '</strong> ' + FB.userCurrency.user_currency;
                        } else {
                            return '<strong>' + Ext.util.Format.number(values.price, '0,0.00') + '</strong> USD';
                        }
                    }
                }
            }
        ];
        me.itemSelector = '.bank-preset';
        protosLoaded = true;
        if (me.rendered) {
            me.refresh();
        }
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me, {
            single: true
        });
        me.on('refresh', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me);
    },
    formStuff: function(values) {
        var stuff = [
                {
                    type: 'currency',
                    params: {
                        id: values.game_currency,
                        quantity: values.count
                    }
                }
            ];
        Ext.Array.each(values.bonus, function(bonusArr) {
            Ext.Array.each(bonusArr, function(bonus) {
                stuff.push({
                    type: 'bank_bonus',
                    params: {
                        stuff: bonus
                    }
                });
            });
        });
        return stuff;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var stuffes = [];
        var items = me.store.data.items;
        for (var i = 0; i < items.length; i++) {
            arr_images.push(items[i].data.image);
            var stf = me.formStuff(items[i].data);
            //   bank_bonus    
            for (var j = 0; j < stf.length; j++) {
                if (stf[j].type == 'bank_bonus') {
                    stf[j] = stf[j].params.stuff;
                }
            }
            stuffes = stuffes.concat(stf);
        }
        return {
            stuff: stuffes,
            images: [
                IMAGE_URL + 'npc/human/trader_small.jpg',
                IMAGE_URL + 'bank/btn_gift.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Bank', {
    extend: ExGodsCore.controller.Base,
    views: [
        'bank.Bonus',
        'bank.Replenishment',
        'bank.Presets',
        'bank.TabPanel',
        'ConfirmationDialog'
    ],
    refs: [
        {
            ref: 'bankMenuBtn',
            selector: '#mainmenu-bank-button'
        }
    ],
    init: function(app) {
        var me = this;
        me.control({
            '#user-finance': {
                iconclick: me.toggleBankServices,
                adddefaultcurrency: me.toggleBankServices,
                addrealcurrency: me.toggleBankServices
            },
            'textbutton[action="bank-buy"]': {
                click: me.onBuyClickBtn
            },
            'textbutton[action="bank-gift"]': {
                click: me.onGiftClickBtn
            },
            'bankreplenishment': {
                get_reward: me.onGetReward
            }
        });
        app.on({
            socialnetassign: me.onSocialNetAssign,
            scope: me
        });
        ExGods.stuff.StuffManager.register({
            'bank_bonus': ExGods.view.bank.stuff.BankBonus
        });
        ExGods.Components.addComponentInitializer('bank', me.initBankComponent, me);
    },
    onGetReward: function() {
        var me = this;
        me.service.command('payment_reward', {}, function(service) {
            Ext.ComponentQuery.query('bankreplenishment')[0].reloadReplenishment(service);
        });
    },
    /**
     * /  
     */
    toggleBankServices: function(tabId) {
        var me = this,
            bankMenuBtn = me.getBankMenuBtn();
        me.initialTabId = typeof tabId == 'number' ? tabId : 0;
        bankMenuBtn.fireEvent('click', bankMenuBtn);
    },
    onBuyClickBtn: function(btn) {
        var me = this,
            values = JSON.parse(btn.values),
            value, currency, plurals, plurals2;
        if (isSocialApp) {
            me.app.getSocialController().buy(values);
        } else {
            value = values.count;
            currency = ExGods.references.get('user_money').get(values.game_currency);
            plurals = values.game_currency == 'gold' ? ExGods.getMsgByKey('gold_name').split(',') : ExGods.getMsgByKey('crystal_name').split(',') , plurals2 = values.app == 'sa' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'vka' ? ExGods.getMsgByKey('payment_vka').split(',') : values.app == 'oka' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'mma' ? ExGods.getMsgByKey('moneta_name').split(',') : [
                '',
                '',
                ''
            ];
            if (values.app == 'sa' && values.price > ExGods.app.user.get('money').coins) {
                Ext.widget('commonwindow', {
                    autoShow: true,
                    html: '<div style="padding: 10px;">' + ExGods.ref('message_client|not_enough_currency'),
                    minHeight: 150,
                    buttonAlign: 'center',
                    buttons: {
                        items: [
                            {
                                xtype: 'textbutton',
                                cls: 'no_border_double x-btn-txt-green',
                                minWidth: 110,
                                href: ExGods.ref('constants|bank_address').value + '/pay?uid=' + ExGods.app.user.get('id'),
                                text: ExGods.getMsgByKey('view_bank_replenishment_btn_text')
                            }
                        ]
                    }
                });
            } else {
                Ext.widget('confirmdialog', {
                    message: Ext.String.format(ExGods.getMsgByKey('bank_excahnge_confirmation'), '<strong>' + Ext.util.Format.number(values.price, '0,0') + '</strong> ' + Ext.util.Format.plural(values.price, plurals2), '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + '<strong>' + Ext.util.Format.number(value, '0,0') + '</strong> ' + Ext.util.Format.plural(value, plurals)),
                    handler: function() {
                        me.confirmExchange(values.entry);
                    }
                });
            }
        }
    },
    onGiftClickBtn: function(btn) {
        var me = this,
            values = JSON.parse(btn.values);
        if (isSocialApp) {
            me.app.getSocialController().gift(values);
        }
    },
    confirmExchange: function(money) {
        var me = this,
            user = me.getUser();
        ExGods.app.block();
        me.service.command('change_real_money_service', {
            preset: money
        }, function() {
            me.service.update(null, function() {
                var bankreplenishment = Ext.ComponentQuery.query('bankreplenishment')[0];
                if (bankreplenishment) {
                    bankreplenishment.reloadReplenishment(me.service.data);
                }
                ExGods.app.unblock();
            });
        });
    },
    /**
     *      
     * @private
     */
    onSocialNetAssign: function() {
        this.toggleBankServices(1);
    },
    initBankComponent: function(config, componentId) {
        var me = this,
            cmp, wnd;
        me.service = config.service;
        cmp = {
            xtype: 'banktabpanel',
            service: me.service,
            activeTab: me.initialTabId,
            items: [
                {
                    xtype: 'bankreplenishment',
                    user: ExGods.app.user,
                    icon: ExGods.ref('images|bank_icons').image.change_icon,
                    service: me.service
                },
                {
                    xtype: 'bankbonus',
                    user: ExGods.app.user,
                    icon: ExGods.ref('images|bank_icons').image.bonus_icon,
                    service: me.service,
                    hidden: isSocialApp
                }
            ]
        };
        delete me.initialTabId;
        wnd = Ext.widget('window2', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ]
        });
        ExGods.app.block();
        ExGods.Resources.load(wnd, function() {
            ExGods.app.unblock();
            wnd.show();
        });
        return wnd;
    }
});

/**
 *   
 */
Ext.define('ExGods.view.bank.Replenishment2', {
    extend: Ext.container.Container,
    alias: 'widget.bankreplenishment2',
    cls: 'bank-replenishment',
    header: false,
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            bank = ExGods.model.Bank,
            gold = ExGods.references.get('user_money').get('gold'),
            coins = ExGods.references.get('user_money').get('coins'),
            presets = me.service.data.payment_preset,
            items = [],
            fields = [
                {
                    name: 'bonus',
                    type: 'auto'
                },
                {
                    name: 'count',
                    type: 'int'
                },
                {
                    name: 'price',
                    type: 'float'
                },
                {
                    name: 'stuff_for_show',
                    type: 'auto'
                },
                {
                    name: 'game_currency',
                    type: 'string'
                },
                {
                    name: 'app',
                    type: 'string'
                },
                {
                    name: 'entry',
                    type: 'string'
                },
                {
                    name: 'order',
                    type: 'int'
                },
                {
                    name: 'special',
                    type: 'int'
                },
                {
                    name: 'description',
                    type: 'auto'
                },
                {
                    name: 'image',
                    type: 'string'
                },
                {
                    name: 'title',
                    type: 'string'
                }
            ];
        me.presetStore = Ext.create('Ext.data.Store', {
            fields: fields,
            data: presets,
            sorters: [
                {
                    property: 'order',
                    direction: 'ASC'
                }
            ]
        });
        me.items = [
            {
                xtype: 'panel',
                x: 0,
                y: 0,
                plugins: [
                    'paperdeco'
                ],
                data: {
                    isSocialApp: isSocialApp,
                    isVK: isVK,
                    isOK: isOK,
                    isMM: isMM,
                    isFB: isFB
                },
                tpl: [
                    '<div class="bank-header">',
                    '<tpl if="!isSocialApp">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('view_bank_repl_count_id') + '",{id:' + user.get('id') + '})]}</div>',
                    '<div>' + ExGods.getMsgByKey('view_bank_on_your_account') + ' <strong id="coins_value">' + Ext.util.Format.number(user.get('money').coins, '0,0') + ' ' + Ext.util.Format.plural(user.get('money').coins, ExGods.getMsgByKey('moneta_name').split(',')) + '</strong></div>',
                    '</tpl>',
                    '<tpl if="isVK">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_vk') + '</div>',
                    '</tpl>',
                    '<tpl if="isOK">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_ok') + '</div>',
                    '</tpl>',
                    '<tpl if="isMM">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_mm') + '</div>',
                    '</tpl>',
                    '<tpl if="isFB">' + '<div class="quest-giver-border"><img src="' + IMAGE_URL + 'npc/human/trader_small.jpg" /></div>',
                    '<div style="margin-top: 20px;">' + ExGods.ref('message_client|bank_text_fb') + '</div>',
                    '</tpl>',
                    '</div>'
                ],
                width: '100%',
                height: isSocialApp ? 100 : 100
            },
            {
                xtype: 'bankpresets',
                store: me.presetStore,
                buy_btn_id: 'bank2-buy'
            }
        ];
        me.mon(user, 'moneycoinschanged', function(value) {
            Ext.fly('coins_value').setHTML(Ext.util.Format.number(value, '0,0') + ' ' + Ext.util.Format.plural(value, ExGods.getMsgByKey('moneta_name').split(',')));
        }, me);
        me.callParent();
    },
    reloadReplenishment: function(service_data) {
        var me = this;
        me.presetStore.loadRawData(service_data.payment_preset);
    },
    onDestroy: function() {
        var me = this,
            replenish_button = Ext.getCmp('do-replenish'),
            reward_button = Ext.getCmp('do-get-reward');
        if (replenish_button)  {
            replenish_button.destroy();
        }
        
        if (reward_button)  {
            reward_button.destroy();
        }
        
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'npc/human/trader_small.jpg'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Bank2', {
    extend: ExGodsCore.controller.Base,
    views: [
        'bank.Bonus',
        'bank.Replenishment2',
        'bank.Presets',
        'bank.TabPanel'
    ],
    init: function(app) {
        var me = this;
        me.control({
            'textbutton[action="bank2-buy"]': {
                click: me.onBuyClickBtn
            }
        });
        ExGods.Components.addComponentInitializer('bank2', me.initBank2Component, me);
    },
    onBuyClickBtn: function(btn) {
        var me = this,
            values = JSON.parse(btn.values),
            value, currency, plurals, plurals2;
        if (isSocialApp) {
            me.app.getSocialController().buy(values);
        } else {
            value = values.count;
            currency = ExGods.references.get('user_money').get(values.game_currency);
            plurals = values.game_currency == 'gold' ? ExGods.getMsgByKey('gold_name').split(',') : ExGods.getMsgByKey('crystal_name').split(',') , plurals2 = values.app == 'sa' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'vka' ? ExGods.getMsgByKey('payment_vka').split(',') : values.app == 'oka' ? ExGods.getMsgByKey('moneta_name').split(',') : values.app == 'mma' ? ExGods.getMsgByKey('moneta_name').split(',') : [
                '',
                '',
                ''
            ];
            document.getElementById('modal_price').innerHTML = Ext.String.format(ExGods.getMsgByKey('bank_excahnge_confirmation'), '<strong>' + Ext.util.Format.number(values.price, '0,0') + '</strong> ' + Ext.util.Format.plural(values.price, plurals2), '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + '<strong>' + Ext.util.Format.number(value, '0,0') + '</strong> ' + Ext.util.Format.plural(value, plurals));
            openPaymentWindow({
                uid: ExGods.app.user.get('id'),
                purchase: {
                    amount: value,
                    currency: "RUB",
                    description: values.description
                },
                custom: {
                    preset: values.entry
                }
            });
        }
    },
    initBank2Component: function(config, componentId) {
        var me = this,
            cmp, wnd;
        me.service = config.service;
        cmp = {
            xtype: 'banktabpanel',
            service: me.service,
            activeTab: me.tab_id,
            items: [
                {
                    xtype: 'bankreplenishment2',
                    user: ExGods.app.user,
                    icon: ExGods.ref('images|bank_icons').image.change_icon,
                    service: me.service
                },
                {
                    xtype: 'bankbonus',
                    user: ExGods.app.user,
                    icon: ExGods.ref('images|bank_icons').image.bonus_icon,
                    service: me.service,
                    hidden: isSocialApp
                }
            ]
        };
        delete me.tab_id;
        wnd = Ext.widget('window2', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ],
            listeners: {
                close: function() {
                    var el = document.getElementById('payment_window');
                    if (el)  {
                        el.remove();
                    }
                    
                }
            }
        });
        ExGods.app.block();
        ExGods.Resources.load(wnd, function() {
            ExGods.app.unblock();
            wnd.show();
            me.appendWindowComponent();
        });
        return wnd;
    },
    appendWindowComponent: function() {
        if (document.getElementById('payment_window'))  {
            return;
        }
        
        var el = document.createElement('div');
        el.style.display = 'none';
        el.id = 'payment_window';
        el.className = 'modal-window';
        el.innerHTML = [
            '<div class="window">',
            '<div class="modal_head">',
            '<img src="' + IMAGE_URL + 'bank/logo.png">',
            '<a class="close" onclick="closePaymentWindow();"></a>',
            '</div>',
            '<div layout="row" layout-align="center" class="modal-price" id="modal_price"></div>',
            '<div id="payment_window_iframe" class="payment-window-iframe"></div>',
            '</div>'
        ].join('');
        document.body.appendChild(el);
    }
});

/**
 *   
 */
Ext.define('ExGods.view.battlechain.Dialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.battlechaindialog',
    id: 'battle-chain-dialog',
    cls: 'bot-dialog',
    bodyPadding: '7 8 0 6',
    /**
     * @cfg chain  
     **/
    initComponent: function() {
        var me = this;
        me.levelInfo = {};
        var chain = me.chain,
            service = me.service,
            levelInfo = me.levelInfo,
            i = chain.levels.length,
            chain_stuff = ExGods.helpme.flatStuff(chain.stuff);
        me.chain_stuff = chain_stuff;
        while (i > 0) {
            i--;
            if (chain.levels[i].level == chain.current_level) {
                levelInfo = chain.levels[i];
                break;
            }
        }
        if (!levelInfo.bot.name_with_level) {
            levelInfo.bot.name_with_level = ExGods.printUser({
                hoard: {
                    level: levelInfo.bot.level
                },
                display_title: levelInfo.bot.label
            }, {
                fields: 'level,name',
                maxNameWidth: '180'
            });
        }
        if (!levelInfo.bot.image) {
            levelInfo.bot.image = ExGodsCore.app.references.get('user_shape').getByKey(levelInfo.bot.shape).full;
        }
        var leftTime = ExGods.util.Date.normalizeServerDateTime(levelInfo.bot.chain_next_time) - Date.now();
        me.levelInfo = levelInfo;
        me.tplForContent = [
            '<div class="paper-title">' + chain.label + '</div>',
            '<div class="description">',
            ExGods.app.applyTpl(chain.desc.description, {
                total: chain.levels.length,
                current: chain.current_level,
                time_to_next: ExGods.util.Time.printRestTime(ExGods.util.Date.normalizeServerDateTime(chain.start_next_time), {
                    format: 'twonums'
                })
            }),
            '</div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('chain_level_loot') + '</div>',
            '<div id="level-rewards" class="npc_stuff_2">',
            //ExGods.stuff.StuffManager.image(levelInfo.bot.stuff),
            '</div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('chain_total_loot') + '</div>',
            '<div id="total-rewards" class="npc_stuff_2">',
            //ExGods.stuff.StuffManager.image(chain_stuff),
            '</div>'
        ].join('');
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                layout: 'absolute',
                height: 370,
                items: [
                    {
                        itemId: 'info',
                        cls: 'dialog-info',
                        style: {
                            borderRight: '1px solid #7d4b2a'
                        },
                        width: 230,
                        height: 350,
                        y: 7,
                        x: 11,
                        tpl: new Ext.XTemplate([
                            '<div class="paper-title">{bot.name_with_level}</div>',
                            '<div class="frame"></div>',
                            '<div class="image bot-info-stats-container" style="background-image: url({bot.image})">',
                            '<tpl if="this.isInfo()">',
                            '<div class="info-top-container">',
                            '<div class="paper paper-tl"></div>',
                            '<div class="paper paper-tm"></div>',
                            '<div class="paper paper-tr"></div>',
                            '<div class="paper paper-mr"></div>',
                            '<div class="paper paper-br"></div>',
                            '<div class="paper paper-bm"></div>',
                            '<div class="paper paper-bl"></div>',
                            '<div class="paper paper-ml"></div>',
                            '<div class="paper paper-bg"></div>',
                            '<div class="avatar-info-container">',
                            '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
                            '<div class="avatar-params stats-list">',
                            '{[ ExGods.util.User.printUserStats(values.bot.stats, {visibleValue: 1, align: "right"}) ]}',
                            '</div>',
                            '<div class="paper-separator"></div>',
                            '<div class="avatar-statsstars">',
                            '{[ ExGods.util.User.printUserStats(values.bot.stats, {visibleValue: 2}) ]}',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</tpl>',
                            '</div>',
                            {
                                isInfo: function() {
                                    return me.isInfo;
                                }
                            }
                        ]),
                        data: levelInfo
                    },
                    {
                        itemId: 'content-container',
                        width: 510,
                        height: 350,
                        style: {
                            borderLeft: '1px solid #7d4b2a'
                        },
                        x: 245,
                        y: 7,
                        items: [
                            {
                                itemId: 'content',
                                cls: 'dialog-content',
                                html: me.tplForContent
                            }
                        ]
                    },
                    {
                        itemId: 'v-separator',
                        width: 10,
                        height: 358,
                        html: '<div class="v-separator"></div>',
                        x: 240,
                        y: 0
                    },
                    {
                        itemId: 'separator',
                        width: 511,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 141
                    },
                    {
                        itemId: 'separator2',
                        width: 511,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 246
                    }
                ]
            },
            {
                xtype: 'container',
                style: {
                    padding: '0 0 0 385px',
                    height: '47px'
                },
                items: [
                    {
                        xtype: 'textbutton',
                        cls: 'qh-object double_text_btn x-btn-txt-red',
                        id: 'chain-attack',
                        margin: '0 0 0 -110',
                        text: 'img:' + ExGods.ref('images|bot_dialog_images').image['text_attack']
                    },
                    {
                        xtype: 'textbutton',
                        cls: 'qh-object double_text_btn double_text',
                        id: 'chain-forfeit',
                        margin: '0 0 0 10',
                        text: 'img:' + ExGods.ref('images|bot_dialog_images').image['text_surrender']
                    }
                ]
            }
        ];
        me.callParent();
        var stuff = (levelInfo.bot.stuff || []).concat(chain_stuff);
        ExGods.util.Helper.loadProtosFromStuff(stuff, function() {
            var update = function() {
                    me.el.down('#level-rewards').update(ExGods.stuff.StuffManager.image(levelInfo.bot.stuff));
                    me.el.down('#total-rewards').update(ExGods.stuff.StuffManager.image(chain_stuff));
                };
            if (me.rendered) {
                update();
            } else {
                me.on('afterrender', update);
            }
        });
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        //ExGods.util.Ticker.addListener(me.updateTime, me);
        me.el.on('click', function() {
            me.isInfo = !me.isInfo;
            me.onInfoChange();
        }, me, {
            delegate: '.info-btn'
        });
    },
    updateTime: function() {
        var me = this,
            time = ExGods.util.Date.normalizeServerDateTime(me.levelInfo.bot.chain_next_time) - Date.now();
        try {
            me.el.down('#chain-timer').setHTML(ExGods.util.Time.printTime(time / 1000));
        } catch (e) {}
        
    },
    onDestroy: function() {
        var me = this;
        //ExGods.util.Ticker.removeListener(me.updateTime);
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        stuff_arr = (me.levelInfo.bot.stuff || []).concat(me.chain_stuff);
        var imgs = ExGods.ref('images|bot_dialog_images').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        return {
            stuff: stuff_arr,
            images: [
                me.levelInfo.bot.image
            ].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.controller.BattleChain', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    views: [
        'battlechain.Dialog'
    ],
    stores: [],
    //
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BattleChain:'
    },
    init: function(app) {
        var me = this;
        me.service = ExGods.Services.get('battle_chains');
        me.control({
            '#LOB_BOT_LIST': {
                itemclick: {
                    fn: me.onSurgingBotClick,
                    delay: 0
                }
            },
            '#chain-attack': {
                click: function() {
                    me.service.command('start_chain');
                }
            },
            '#chain-forfeit': {
                click: me.onForfeit
            }
        });
        me.callParent();
    },
    /**
     *     
     */
    getChain: function() {
        var me = this;
        return ExGods.app.user.location.data.battle_chain;
    },
    /**
     *        
     */
    getSurgingChainEntry: function() {
        var me = this,
            chain = me.getChain(),
            entry;
        if (chain) {
            Ext.Array.each(chain.levels, function(data) {
                if (data.level == chain.current_level) {
                    entry = data.bot;
                    entry.count = 1;
                    entry.chain = 1;
                    entry.chain_next_time = chain.start_next_time;
                }
            });
        }
        return entry;
    },
    /**
     *   
     */
    showChainDialog: function() {
        var me = this;
        me.chainDialog = Ext.widget('window2', {
            autoShow: false,
            items: [
                {
                    xtype: 'battlechaindialog',
                    chain: me.getChain(),
                    service: me.service
                }
            ],
            closeAction: 'destroy'
        });
        ExGods.Resources.load(me.chainDialog, function() {
            me.chainDialog.show();
        });
    },
    /**
     * @private
     */
    onSurgingBotClick: function(view, item) {
        var me = this;
        if (item.data.chain) {
            me.showChainDialog();
        }
    },
    onForfeit: function() {
        var me = this;
        var dlg = Ext.widget('confirmdialog', {
                autoShow: false,
                message: new Ext.Template(ExGods.ref('message_client|surrender_chain')).apply({}),
                handler: function() {
                    me.service.command('surrender_chain', {}, function(json) {
                        if (json.success) {
                            me.app.getSurgingController().updateStore();
                            me.chainDialog.close();
                            Ext.getCmp('mainmenu').enableMenu();
                        }
                    });
                }
            });
        ExGods.Resources.load(dlg, function() {
            dlg.show();
        });
    }
});

/**
 *  .
 *
 * @author Oleg M.
 */
Ext.define('ExGods.controller.battle.Battle', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Battle:'
    },
    /**
     * @property {Ext.data.Store} list   
     */
    list: null,
    /**
     * @property {Object} state  
     */
    state: {},
    /**
     * @property {Object} pairs    .    
     */
    pairs: {},
    /**
     * @property {Object} result  
     */
    result: {},
    /**
     * @property {Object} hints 
     */
    hints: {},
    /**
     * @property {Number} battle_type   
     */
    battle_type: 0,
    /**
     * @property {Number} ekeys  ID  ,     display_title
     */
    ekeys: [],
    init: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.factory('battle_no_start', {
            title: '  ',
            showInConsole: false
        });
        /*****/
        ExGods.util.RemoteDebug.factory('battle_no_finish', {
            title: '  ',
            showInConsole: false,
            limit: 40
        });
        me.control({
            '#battle-result': {
                afterrender: function() {
                    clearInterval(ExGods.util.RemoteDebug.get('battle_no_finish').interval);
                    ExGods.util.RemoteDebug.get('battle_no_finish').interval = null;
                }
            }
        });
        me.app.getChatConnection().on({
            command_battle_log: me.onBattleLogMessage,
            command_buser: Ext.Function.createBuffered(me.reloadState, 250, me),
            command_battle_exit: me.onBattleExit,
            scope: me
        });
        //     
        me.battleView = me.app.getController('battle.BattleView');
        //     
        me.animation = me.app.getController('battle.Animation');
        //     
        me.stability = me.app.getController('battle.Stability');
        me.list = new Ext.util.MixedCollection();
        me.callParent();
    },
    /**
     *   .  : 'load_start'  'start'  'finish'
     */
    loadStart: function(callback) {
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').clear();
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').clear();
        /*****/
        if (ExGods.util.RemoteDebug.get('battle_no_start').interval) {
            clearInterval(ExGods.util.RemoteDebug.get('battle_no_start').interval);
            ExGods.util.RemoteDebug.get('battle_no_start').interval = null;
        }
        if (ExGods.util.RemoteDebug.get('battle_no_finish').interval) {
            clearInterval(ExGods.util.RemoteDebug.get('battle_no_finish').interval);
            ExGods.util.RemoteDebug.get('battle_no_finish').interval = null;
        }
        /*****/
        (function() {
            var now = new Date();
            var interval = setInterval(function() {
                    if (Ext.getCmp('battle-container') || Ext.getCmp('battle-result') || me.result) {
                        clearInterval(interval);
                    } else if (new Date() - now > 15 * 1000) {
                        ExGods.util.RemoteDebug.get('battle_no_start').send();
                        ExGods.util.RemoteDebug.get('battle_no_start').interval = null;
                        clearInterval(interval);
                    }
                }, 150);
            ExGods.util.RemoteDebug.get('battle_no_start').interval = interval;
        }());
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@battle   ');
        var me = this,
            _onSuccess = function(data) {
                me.pairs = data.pairs;
                me.battleRequestSuccess(data, function(data) {
                    //   
                    if (data.list) {
                        Ext.Array.each(data.list, function(u) {
                            me.list.add(u.battle.ekey, u);
                        });
                    }
                    //  ,     
                    if (me.preloadChanges.length) {
                        Ext.Array.each(me.preloadChanges, function(changes) {
                            me.applyChanges(changes, true);
                        });
                    }
                    if (data.hints) {
                        me.hints = {};
                        Ext.Array.each(data.hints, function(hint) {
                            me.hints[hint.key] = hint.hint;
                        });
                    }
                    me.battle_type = data.battle_type;
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_start').log('@battle   ,   "start"');
                    me.started = true;
                    //  ""  
                    /***/
                    me.fireEvent('start', me, me.state);
                    me.battleView.onBattleStart(me, me.state);
                });
            };
        //    
        me.result = null;
        me.resultLoading = false;
        me.list.removeAll();
        me.preloadChanges = [];
        me.pairs = {};
        /***/
        me.fireEvent('load_start', me, me.state);
        me.battleView.onBattleLoadStart(me, me.state);
        /***/
        me.log('  ');
        me.request({
            url: 'battle.pl?cmd=battle_list',
            success: function(json) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_start').log('@battle  : ' + Ext.encode(json));
                if (json && json.success) {
                    _onSuccess(json);
                    if (callback) {
                        callback();
                    }
                } else {
                    /***/
                    me.log('error', '    ', json);
                }
            }
        });
    },
    /**
     * @private  .   "load_finish"  "finish"
     */
    loadFinish: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle   (  "finish")');
        /*****/
        if (ExGods.util.RemoteDebug.get('battle_no_finish').interval) {
            clearInterval(ExGods.util.RemoteDebug.get('battle_no_finish').interval);
            ExGods.util.RemoteDebug.get('battle_no_finish').interval = null;
        }
        /*****/
        (function() {
            var now = new Date();
            var interval = setInterval(function() {
                    if (Ext.getCmp('battle-result') || ExGods.app.getController('Viewport').layout == 'main') {
                        clearInterval(interval);
                    } else if (new Date() - now > 20 * 1000) {
                        var emptySide = false;
                        if (me.result && me.result.participant && me.result.participant.length) {
                            me.result.participant.forEach(function(side) {
                                if (side.length === 0) {
                                    emptySide = true;
                                }
                            });
                        }
                        if (!emptySide) {
                            ExGods.util.RemoteDebug.get('battle_no_finish').send();
                        }
                        ExGods.util.RemoteDebug.get('battle_no_finish').interval = null;
                        clearInterval(interval);
                    }
                }, 150);
            ExGods.util.RemoteDebug.get('battle_no_finish').interval = interval;
        }());
        /***/
        me.fireEvent('load_finish');
        me.battleView.onBattleLoadFinish();
        /***/
        me.log('   ');
        me.request({
            url: 'battle.pl?cmd=battle_current',
            success: function(json) {
                if (json && json.success) {
                    me.battleRequestSuccess(json);
                } else {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle   !success - ' + Ext.encode(json));
                    /***/
                    me.log('error', '    ', json);
                }
            }
        });
    },
    /**
     * @private
     *   .  - 'load_round', 'round'  'finish'
     */
    loadRound: function(roundNum) {
        var me = this,
            triggerRound = function() {
                setTimeout(function() {
                    me.battleView.onBattleRound(me, me.state);
                }, 400);
            };
        /***/
        me.log('   #', roundNum);
        me.state.round = roundNum;
        /***/
        me.fireEvent('load_round', me);
        me.battleView.onBattleLoadRound(me);
        me.request({
            url: 'battle.pl?cmd=battle_current',
            success: function(json) {
                if (json && json.success) {
                    if (json.battle_in_finish) {
                        /***/
                        me.fireEvent('round', me, me.state);
                        triggerRound();
                    } else {
                        me.battleRequestSuccess(json, function() {
                            /***/
                            me.fireEvent('round', me, me.state);
                            triggerRound();
                        });
                    }
                } else {
                    /***/
                    me.log('error', '    ', json);
                }
            }
        });
    },
    /**
     *   
     * @param callback
     * @param force true - ,      
     */
    loadBattleResult: function(callback, force) {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle   ');
        if (!force && me.resultLoading) {
            return;
        }
        //    
        me.resultLoading = true;
        me.request({
            url: 'battle.pl?cmd=battle_result',
            success: function(json) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle  : ' + Ext.encode(json));
                if (!json || !json.success) {
                    //    ,   
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle    ,   ');
                    callback(null);
                } else if (json.battle_in_finish || json.battle_not_start) {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle    .  5    ');
                    setTimeout(function() {
                        me.loadBattleResult(callback, true);
                    }, 5000);
                } else {
                    callback(json.battle_result);
                }
            }
        });
    },
    /**
     *   . Co 'before_kick', 'kick'
     */
    doKick: function(name) {
        var me = this,
            kickInfo;
        if (me.state.can_kick) {
            kickInfo = Ext.Array.findBy(me.state.av_kick, function(item) {
                return item.name == name;
            });
            if (kickInfo && kickInfo.renew) {
                /***/
                me.log('      ');
                /***/
                me.fireEvent('before_reroll', me);
                me.battleView.onBattleBeforeReroll(me);
                me.battleActionRequest({
                    cmd: 'battle_kick',
                    kick: name,
                    round: me.state.round
                }, function() {
                    /***/
                    me.fireEvent('reroll', me);
                    me.battleView.onBattleReroll(me);
                });
            } else {
                /***/
                me.log('    ');
                /***/
                me.fireEvent('before_kick', me);
                me.battleView.onBattleBeforeKick(me);
                me.battleActionRequest({
                    cmd: 'battle_kick',
                    kick: name,
                    round: me.state.round
                }, function() {
                    /***/
                    me.fireEvent('kick', me.state.kick);
                    me.battleView.onBattleKick(me.state.kick);
                });
            }
        }
    },
    /**
     *   . Co 'before_prep', 'prep'
     */
    doPrep: function(prepName) {
        var me = this,
            user = me.getUser(),
            refData = ExGods.ref('battle_prep|' + prepName),
            prepData = Ext.Array.findBy(me.state.av_prep, function(prep) {
                return prep.name == prepName;
            }),
            doPrepInner = function(targetEkey) {
                /***/
                me.log('    ');
                /***/
                me.fireEvent('before_prep', me);
                me.battleView.onBattleBeforePrep(me);
                me.battleActionRequest({
                    cmd: 'battle_instant',
                    kick: prepName,
                    target: targetEkey,
                    round: me.state.round
                }, function() {
                    /***/
                    me.fireEvent('prep', me);
                    me.battleView.onBattlePrep(me);
                });
            },
            selectTarget = function(callback) {
                if (prepData.strike) {
                    ExGods.Components.factory('USER_TARGET_PANEL', {
                        windowTitle: refData.label,
                        source: 'battle',
                        side: prepData.strike.side == 0 ? user.getBattleSide() : 2,
                        dead: prepData.strike.is_dead,
                        listeners: {
                            select: function(wnd, rec) {
                                callback(rec.get('battle').ekey);
                                wnd.up().close();
                            }
                        }
                    });
                } else {
                    callback();
                }
            },
            doClientBeforePrep = function(callback) {
                if (prepData.client) {
                    if (prepData.client == 'invite') {
                        me.app.getSocialController().invite(callback);
                    }
                } else {
                    callback();
                }
            };
        if (prepData) {
            //  ,   "client"
            doClientBeforePrep(function() {
                //    
                selectTarget(function(targetEkey) {
                    doPrepInner(targetEkey);
                });
            });
        }
    },
    /**
     * ""  . Co 'before_reroll', 'reroll'
     */
    doReroll: function() {
        var me = this,
            user = me.getUser();
        /***/
        me.log('    ');
        /***/
        me.fireEvent('before_reroll', me);
        me.battleView.onBattleBeforeReroll(me);
        me.battleActionRequest({
            cmd: 'battle_reroll',
            kick: name,
            round: me.state.round
        }, function() {
            /***/
            me.fireEvent('reroll', me);
            me.battleView.onBattleReroll(me);
        });
    },
    /**
     *   .     (ExGods.controller.Action)
     *   "item"
     */
    onItemActionHandler: function(data) {
        var me = this;
        me.battleRequestSuccess(data);
        /***/
        me.fireEvent('item', me);
        me.battleView.onBattleItem(me);
    },
    onBattleLogMessage: function(chatcn, message) {
        var me = this,
            data = message.body.data;
        /***/
        me.log('     ' + data.type, data);
        switch (data.type) {
            case 'start':
                me.loadStart();
                break;
            case 'meddle':
                if (!me.started) {
                    me.loadStart();
                } else {
                    if (!me.list.getByKey(data.user.battle.ekey)) {
                        me.list.add(data.user.battle.ekey, data.user);
                        /***/
                        me.fireEvent('u_add', data.user);
                        me.battleView.onBattleUserAdd(data.user);
                        if (data.user.is_bot) {
                            me.ekeys.push(data.user.battle.ekey);
                            me.updateTitles();
                        }
                    }
                };
                break;
            case 'resurect':
                me.resurectUser(data);
                break;
            case 'finish':
                me.loadFinish();
                break;
            case 'newround':
                if (data.round != 1) {
                    me.loadRound(data.round);
                };
                me.pairs = data.pairs;
                break;
            case 'changes':
                {
                    if (me.started) {
                        me.applyChanges(data);
                    } else {
                        me.preloadChanges.push(data);
                    }
                    break;
                };
        }
        //          "user_kick", "enemy_kick"
        if (me.state.live != "0" && data.turn_name) {
            var u = data.u || data.u1,
                enemyBattleEkey = me.state.enemy;
            if (u && u[2] == me.user.getBattleEkey()) {
                /***/
                me.fireEvent('user_kick', data.turn_name);
                me.battleView.onBattleUserKick(data.turn_name);
            } else if (u && enemyBattleEkey && u[2] == enemyBattleEkey) {
                /***/
                me.fireEvent('enemy_kick', data.turn_name);
                me.battleView.onBattleEnemyKick(data.turn_name);
            }
        }
        //         ,
        //     (,      -   )
        if (data.prepare_name || data.action_id) {
            if (data.u1 && data.u2 && data.u1[2] != me.user.getBattleEkey() && data.u2[2] == me.user.getBattleEkey()) {
                me.reloadState();
            }
        }
    },
    /**
     * @private    "battle_exit" -    
     */
    onBattleExit: function() {
        var me = this;
        me.user.loadRemote(function() {
            /***/
            me.fireEvent('exit');
            me.battleView.onBattleExit();
        });
    },
    updateTitles: Ext.Function.createBuffered(function() {
        var me = this;
        if (me.ekeys.length) {
            me.battleActionRequest({
                cmd: 'battle_ut',
                ekeys: Ext.JSON.encode(me.ekeys)
            }, function(data) {
                me.ekeys = [];
                Ext.Object.each(data.list, function(ekey, title) {
                    var user = me.list.getByKey(ekey);
                    if (user) {
                        user.display_title = title;
                        /***/
                        me.fireEvent('u_title', ekey, title);
                        me.battleView.onBattleUserTitle(ekey, title);
                    }
                });
            });
        }
    }, 1000),
    /**
     * @private   
     */
    reloadState: function() {
        var me = this;
        /****/
        me.log('  ');
        me.request({
            url: 'battle.pl?cmd=battle_current',
            success: function(json) {
                if (json && json.success) {
                    if (json.buser) {
                        //    
                        me.state = Ext.apply(me.state, json.buser);
                        /***/
                        me.fireEvent('state_refresh');
                        me.battleView.onBattleStateRefresh();
                    }
                } else {
                    /***/
                    me.log('error', '    ', json);
                }
            }
        });
    },
    /**
     * @private    -   
     */
    battleActionRequest: function(params, callback) {
        var me = this;
        me.request({
            url: 'battle.pl',
            params: params,
            success: function(json) {
                me.battleRequestSuccess(json);
                if (callback) {
                    callback(json);
                }
            }
        });
    },
    /**
     *  
     */
    resurectUser: function(data) {
        var me = this;
        if (data.user) {
            me.list.each(function(u) {
                if (u.battle.ekey == data.user.battle.ekey) {
                    Ext.apply(u, data.user);
                    /***/
                    me.fireEvent('u_change', u);
                    me.battleView.onBattleUserChange(u);
                }
            });
        }
    },
    /**
     * @private    
     */
    applyChanges: function(data, silent) {
        var me = this,
            _applyChanges = function(u, changes) {
                var prepared = {};
                if (changes.timed) {
                    Ext.apply(u.timed, changes.timed);
                }
                //   timed  ,     changes.timed
                if (changes.aura) {
                    u.aura = changes.aura;
                }
                if (changes.stats) {
                    Ext.apply(u.stats.stats, changes.stats);
                }
                if (changes.died == "1") {
                    u.battle.live = 0;
                    //    
                    u.timed.hp[0] = 0;
                    //   hp  
                    u.timed.shield[0] = 0;
                }
                //   shield  
                if (changes.shape) {
                    u.shape = changes.shape;
                }
            };
        /***/
        me.log('', data);
        me.list.each(function(u) {
            if (data.list[u.battle.ekey]) {
                _applyChanges(u, data.list[u.battle.ekey]);
                if (!silent) {
                    /***/
                    me.fireEvent('u_change', u);
                    me.battleView.onBattleUserChange(u);
                }
            }
        });
    },
    /**
     *    
     */
    getEnemy: function() {
        var me = this,
            index;
        if (me.state.enemy) {
            return me.list.findBy(function(u) {
                return u.battle.ekey == me.state.enemy;
            });
        } else {
            return null;
        }
    },
    /**
     * @private    
     */
    battleRequestSuccess: function(json, onActiveBattle) {
        var me = this;
        if (json && json.success) {
            try {
                if (json.buser && json.buser.user) {
                    me.user.set(json.buser.user);
                }
                if (json.buser) {
                    me.state = json.buser;
                    if (json.buser.marks) {
                        /***/
                        me.fireEvent('apply_marks', json.buser.marks);
                        me.battleView.applyMarks(json.buser.marks);
                    }
                }
            } catch (e) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle      ' + e);
            }
            if (json.battle_is_done) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle   (battle_is_done) ');
                me.loadBattleResult(function(result) {
                    delete me.started;
                    me.result = result;
                    me.battle_type = 0;
                    /***/
                    me.fireEvent('finish', me, me.result);
                    me.battleView.onBattleFinish(me, me.result);
                });
            } else if (json.not_active_battle) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle   - not_active_battle');
                /***/
                me.fireEvent('not_active_battle', me);
                me.battleView.onNotActiveBattle(me);
            } else if (json.battle_not_start) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_start').log('@battle   - battle_not_start');
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle   - battle_not_start');
            }
            //    ,    "start"
            else if (onActiveBattle) {
                onActiveBattle.call(me, json);
            }
        } else {
            /***/
            me.log('error', '  . ', json);
        }
    },
    /**
     *      
     */
    restartBattle: function() {
        var me = this;
        me.loadStart();
    }
});

Ext.define('ExGods.view.battle_new.stuff.BattleReward', {
    extend: ExGods.stuff.stuff.Expa,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.stuff.decorator.BonusStick);
        return data;
    }
});

/**
 *    
 */
Ext.define('ExGods.view.battle_new.Avatar', {
    extend: Ext.Container,
    alias: 'widget.battle_avatar',
    /**
     * @cfg  
     */
    user: null,
    layout: 'fit',
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'panel',
                //plugins: ['paperdeco'],
                //padding: '10 18 20 18',
                tpl: [
                    '<div class="battle-avatar-bg">',
                    '<tpl if="display_title">',
                    //    
                    '<div class="info-btn-{[this.getSide()]}-container">',
                    '<div class="info-btn"></div>',
                    '</div>',
                    '<tpl if="this.isInfo()">',
                    '<div class="info-top-container">',
                    '<div class="paper paper-tl"></div>',
                    '<div class="paper paper-tm"></div>',
                    '<div class="paper paper-tr"></div>',
                    '<div class="paper paper-mr"></div>',
                    '<div class="paper paper-br"></div>',
                    '<div class="paper paper-bm"></div>',
                    '<div class="paper paper-bl"></div>',
                    '<div class="paper paper-ml"></div>',
                    '<div class="paper paper-bg"></div>',
                    '<div class="avatar-info-container">',
                    '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
                    '<div class="avatar-params stats-list">',
                    '{[ ExGods.util.User.printUserStats(this.getSummaryStats(values), {visibleValue: 1, align: "right"}) ]}',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    '{[ ExGods.util.User.printUserStats(this.getSummaryStats(values), {visibleValue: 2}) ]}',
                    '<tpl if="bot_visible_turns.length || bot_visible_instants.length || bot_visible_battle_actions.length">',
                    '<div class="stats-list like_table">',
                    '<div class="align_middle">',
                    '<tpl if="bot_visible_turns.length">',
                    '<tpl for="bot_visible_turns">',
                    '{[this.printAction("turn", xindex-1)]}',
                    '</tpl>',
                    '</tpl>',
                    '<tpl if="bot_visible_instants.length">',
                    '<tpl for="bot_visible_instants">',
                    '{[this.printAction("prep", xindex-1)]}',
                    '</tpl>',
                    '</tpl>',
                    '<tpl if="bot_visible_battle_actions.length">',
                    '<tpl for="bot_visible_battle_actions">',
                    '{[this.printAction("actions", xindex-1)]}',
                    '</tpl>',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    '<tpl if="bot_visible_turns.length + bot_visible_instants.length + bot_visible_battle_actions.length == 1">',
                    '<div class="paper-separator"></div>',
                    '</tpl>',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    '<tpl if="aura">',
                    '<div class="battle-aura-container">',
                    '{[this.printAuras(values.aura)]}',
                    '</div>',
                    '</tpl>',
                    '<tpl else>',
                    '<tpl if="battle.live">',
                    '<div class="avatar-frame"></div>',
                    '<div class="avatar-image {[this.getSideCls()]}" style="background-image:url({[this.getImage(values.shape)]})"></div>',
                    '<div class="avatar-stats">',
                    '{[ ExGods.util.User.printUserStats(values.stats.stats, {visibleValue: 2}) ]}',
                    '</div>',
                    '<tpl if="aura">',
                    '<div class="battle-aura-container">',
                    '{[this.printAuras(values.aura)]}',
                    '</div>',
                    '</tpl>',
                    '<tpl else>',
                    // 
                    '<div class="avatar-frame"></div>',
                    '<div class="avatar-image" style="background-image:url({[this.getImage(values.shape)]})"></div>',
                    '</tpl>',
                    '</tpl>',
                    '<tpl else>',
                    // 
                    '<div class="avatar-frame"></div>',
                    '<div class="avatar-image" style="background-image:url({[this.getImage(values.shape)]})"></div>',
                    '</tpl>',
                    '</div>',
                    {
                        printAuras: function(auras) {
                            var prepared = [],
                                html = '';
                            //aura[0] - aura name
                            //aura[1] - aura steps
                            Ext.Array.each(auras, function(aura) {
                                var i = prepared.length;
                                while (i--) {
                                    if (prepared[i].name == aura[0] && prepared[i].steps == aura[1]) {
                                        prepared[i].count++;
                                        return;
                                    }
                                }
                                prepared.push({
                                    name: aura[0],
                                    steps: aura[1],
                                    count: 1
                                });
                            });
                            Ext.Array.each(prepared, function(aura) {
                                var ref = ExGods.ref('battle_aura|' + aura.name),
                                    img = IMAGE_URL + (ref.params.images.small || ref.params.images.icon),
                                    steps = aura.steps != "0" ? '<div class="battle-aura-counter">' + aura.steps + '</div>' : "",
                                    count = aura.count > 1 ? '<div class="battle-aura-count exg-stuff-decorator-quantity-counter"><span>' + aura.count + '</span></div>' : "";
                                html += [
                                    '<div class="battle-aura" data-qtip="' + ref.label + '" data-aura="' + aura.name + '" style="background-image:url(' + img + ')">',
                                    steps,
                                    count,
                                    '</div>'
                                ].join('');
                            });
                            return html;
                        },
                        getImage: function(shape) {
                            var image;
                            if (!me.isEnemy) {
                                if (me.user.isLiveInBattle()) {
                                    image = me.user.getBattleAvatar();
                                } else {
                                    image = me.getShapeImage('battle_die_shape');
                                }
                            } else {
                                if (me.user) {
                                    if (me.user.isLiveInBattle()) {
                                        image = me.user.getBattleAvatar();
                                    } else {
                                        image = me.getShapeImage('battle_die_shape');
                                    }
                                } else {
                                    image = me.getShapeImage('no_enemy_shape');
                                }
                            }
                            return image;
                        },
                        getSide: function() {
                            return (me.isEnemy) ? 'right' : 'left';
                        },
                        isInfo: function() {
                            return me.isInfo;
                        },
                        getSideCls: function() {
                            return (me.isEnemy) ? 'flip-h' : '';
                        },
                        printAction: function(type, index) {
                            var name, ref_data,
                                turns = me.user.get('bot_visible_turns'),
                                preps = me.user.get('bot_visible_instants'),
                                actions = me.user.get('bot_visible_battle_actions');
                            switch (type) {
                                case 'turn':
                                    {
                                        if (index >= 2 || !turns[index]) {
                                            return;
                                        }
                                        name = turns[index].name;
                                        ref_data = ExGods.ref('battle_turn|' + name);
                                        break;
                                    };
                                case 'prep':
                                    {
                                        if ((turns.length + index) >= 2 || !preps[index]) {
                                            return;
                                        }
                                        name = preps[index].name;
                                        ref_data = ExGods.ref('battle_prep|' + name);
                                        break;
                                    };
                                case 'actions':
                                    {
                                        if ((turns.length + preps.length + index) >= 2 || !actions[index]) {
                                            return;
                                        }
                                        name = actions[index].id;
                                        ref_data = ExGods.ref('battle_actions|' + name);
                                        break;
                                    };
                            }
                            if (ref_data) {
                                return '<div class="paper-separator"></div>' + '<div class="action" id="' + type + '__' + name + '">' + '<img src="' + IMAGE_URL + (type == 'actions' ? ref_data.desc.img : ref_data.desc.images.active) + '">' + '<p>' + ref_data.label + '</p>' + '<div class="notify_i"></div>' + '</div>';
                            } else {
                                return '';
                            }
                        },
                        //   ,        timed
                        getSummaryStats: function(u) {
                            var stats = u.stats.stats,
                                timed = me.user.get('timed');
                            Ext.Object.each(stats, function(k, v) {
                                if (k == 'mp' || k == 'hp' || k == 'shield') {
                                    stats[k] = Math.floor(timed[k][0]);
                                }
                            });
                            if (me.isEnemy) {
                                stats['mp'] = "???";
                            }
                            //     
                            return stats;
                        }
                    }
                ],
                data: me.user ? me.user.data : {}
            }
        ];
        if (me.user) {
            me.setUser(me.user);
        }
        me.callParent(arguments);
        me.on('afterrender', function() {
            me.el.on('click', function() {
                if (me.isInfo) {
                    me.isInfo = false;
                } else {
                    me.isInfo = true;
                }
                me.onUserChange();
                me.fireEvent('viewmodechange', me, me.isInfo);
            }, //      
            me, {
                delegate: '.info-btn'
            });
            me.el.on('click', function(e, el) {
                var aura = ExGods.ref('battle_aura|' + el.dataset.aura);
                Ext.widget('commondetailswindow', {
                    itemElement: el.dom || el,
                    data: {
                        label: aura.label,
                        description: aura.params.description,
                        image: IMAGE_URL + aura.params.images.large
                    }
                });
            }, me, {
                delegate: '.battle-aura'
            });
            me.el.on('click', function(e, el) {
                var cfg = el.id.split('__'),
                    ref = ExGods.ref('battle_' + cfg[0]).get(cfg[1]);
                if (me.actionInfo)  {
                    me.actionInfo.close();
                }
                
                me.actionInfo = Ext.widget('commondetailswindow', {
                    itemElement: this,
                    data: {
                        label: ref.label,
                        image: IMAGE_URL + ((ref.desc.images) ? ref.desc.images.active : ref.desc.img),
                        rows: [
                            {
                                content: ref.prognoz
                            },
                            {
                                content: ref.desc.desc || ref.desc.msg || ''
                            }
                        ]
                    }
                });
                me.actionInfo.on('close', function() {
                    me.actionInfo.destroy();
                    me.actionInfo = false;
                });
                me.actionInfo.setY(Ext.get(el).getY());
                //     ,    .    -     isEnemy
                me.actionInfo.setX(parseInt(Ext.get(el).getX()) - 230);
            }, me, {
                delegate: '.action'
            });
        }, me);
    },
    /**
     *   
     */
    setUser: function(user) {
        var me = this;
        if (me.user) {
            me.mun(me.user, 'change', me.onUserChange);
        }
        me.user = user;
        if (me.user) {
            me.mon(me.user, 'change', me.onUserChange, me);
        }
        if (me.rendered) {
            me.items.items[0].update(me.user ? me.user.data : {});
        }
    },
    onUserChange: function() {
        var me = this,
            data = Ext.clone(me.user.data);
        if (me.rendered) {
            me.items.items[0].update(data);
        }
    },
    /**
     * @private
     *      
     * @return {String} Url  
     */
    getShapeImage: function(shapeKey) {
        var me = this,
            shape, image;
        shape = ExGods.references.get('constants').get(shapeKey);
        if (shape) {
            shape = ExGods.references.get('user_shape').getByKey(shape.value);
            if (shape) {
                image = shape.battle;
            }
        }
        return image;
    },
    // updateAura:function(aura){
    //  var me = this,
    //      data = me.user.data;
    //  if(me.trueAura){
    //      data.aura = aura;
    //      if(me.rendered){
    //          me.items.items[0].update(data);
    //      }
    //      me.trueAura = false;
    //  }else{
    //      me.trueAura = aura;
    //  }
    // }
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        battle_die_shape = me.getShapeImage('battle_die_shape');
        no_enemy_shape = me.getShapeImage('no_enemy_shape');
        return {
            images: [
                battle_die_shape,
                no_enemy_shape
            ].concat(arr_images)
        };
    }
});

/**  **/
Ext.define('ExGods.view.battle_new.Roller', {
    extend: Ext.Component,
    alias: 'widget.battle_roller',
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BattleRoller:'
    },
    /**
     *  
     * @cfg
     */
    state: {},
    animating: false,
    turnHeight: 105,
    //   
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="wrap">',
            '<tpl for="turns">',
            '<div class="slot slot-{[xindex]}">',
            '<div class="turn{[this.getCls(parent.state, values)]}" role="{name}">',
            //'<div class="label ellipsis">{label}</div>',
            '<div class="label ellipsis">{[this.getPrognoz(values,"top")]}</div>',
            '<div class="hidden-empty-border"></div>',
            '<div class="image" style="background-image: url({[this.getImage(values,parent.state)]})">',
            //'<div class="empty-border"></div>',
            '<div class="image-border"></div>',
            '</div>',
            '<div class="prognoz-right">{[this.getPrognoz(values,"right")]}</div>',
            //'<div class="cost ellipsis">{[this.getPrognoz(values,"bottom")]} {[this.getCost(values)]}</div>',
            '<div class="cost ellipsis">{[this.getPrognoz(values,"bottom")]}</div>',
            '<div class="upper-empty-border"></div>',
            '</div>',
            '</div>',
            '</tpl>',
            '<div class="wait-enemy-msg" style="background-image: url(' + ExGods.ref('images|battle_images').image['wait-enemy-msg'] + ')"></div>',
            '<div class="dead-msg" style="background-image: url(' + ExGods.ref('images|battle_images').image['dead-msg'] + ')"></div>',
            '</div>',
            '<div class="cf"></div>',
            '<div id="battle-roller-btn" class="disabled" style="background-image: url(' + ExGods.ref('images|battle_images').image['roller_btn_text'] + ')">',
            '<span>{[ this.printSpriteMoney(values.state.cost_reroll || [],{cls:"battle-roller-cost"}) ]}</span>',
            '</div>',
            {
                getCls: function(state, values) {
                    var cls = '';
                    if (!state.can_kick || !ExGods.app.getUser().checkStuff(values.cost, {
                        activeSlot: true
                    })) {
                        cls = ' disabled';
                    }
                    return cls;
                },
                getPrognoz: function(turn, place) {
                    if (!turn.name || !turn.prognoz)  {
                        return '';
                    }
                    
                    return me.getPrognoz(turn, place);
                },
                getCost: function(turn) {
                    if (!turn.cost)  {
                        return '';
                    }
                    
                    return me.getCost(turn);
                },
                getImage: function(values, state) {
                    if (state.can_kick && ExGods.app.getUser().checkStuff(values.cost, {
                        activeSlot: true
                    })) {
                        return values.images.active;
                    } else {
                        return values.images.passive;
                    }
                },
                printSpriteMoney: function(stuff, opts) {
                    return me.printSpriteMoney(stuff, opts);
                }
            }
        ];
        me.data = me.prepareData();
        me.callParent(arguments);
        me.on('destroy', function() {
            if (me.tooltip)  {
                me.tooltip.close();
            }
            
        });
    },
    afterRender: function() {
        var me = this,
            el = me.getEl();
        me.callParent(arguments);
        if (!me.state.user.battle.live) {
            me.setDead();
            return;
        }
        el.on('click', me.onTurnClick, me, {
            delegate: '.turn'
        });
        el.on('mouseover', me.onTurnMouseOver, me, {
            delegate: '.turn'
        });
        el.on('mouseout', me.onTurnMouseOut, me, {
            delegate: '.turn'
        });
        el.on('click', me.onRerollClick, me, {
            delegate: '#battle-roller-btn'
        });
        el.down('.dead-msg').fadeOut({
            duration: 200
        });
        Ext.Array.each(el.select('.turn').elements, function(turnDom) {
            var turnEl = Ext.get(turnDom),
                img = turnEl.down('.image');
            var interval = setInterval(function() {
                    if (turnEl.dom) {
                        if (me.animating || turnEl.hasCls('disabled'))  {
                            return;
                        }
                        
                        ExGods.helpme.shine(img, 'battle-roller-btn-shine', 19, 62, 25).on('click', function(e) {
                            me.onTurnClick(e, turnEl);
                        });
                    } else {
                        clearInterval(interval);
                    }
                }, 5000);
        });
        if (me.animateOnRender) {
            me.startAnimate(true);
        } else {
            el.select('.turn').show();
            me.disableBtn(false);
        }
        if (!me.state.can_kick || !me.state.av_kick || me.state.av_kick.length == 0) {
            me.waitEnemyTurn(true);
        }
    },
    getPrognoz: function(turn, pos) {
        var ref = ExGods.ref('battle_turn').get(turn.name),
            tpl = ref.desc.prognoz.battle[pos].prognoz_template,
            label = ref.desc.prognoz.battle[pos].prognoz_label,
            template = new Ext.XTemplate(label + ' ' + tpl),
            html = template.apply(turn || {});
        return html;
    },
    getCost: function(turn) {
        var c = turn.cost,
            res = '';
        if (c)  {
            res += ExGods.util.Stuff.printStuff(c);
        }
        
        return res;
    },
    animateSlot: function(slotEl) {
        var me = this,
            cellWidth = 125,
            cellHeight = 109,
            //   
            elemsConfig = [
                {
                    img: IMAGE_URL + '/battle/roller/start.png',
                    height: 218
                },
                {
                    img: IMAGE_URL + '/battle/roller/loop.png',
                    height: 654
                },
                {
                    img: IMAGE_URL + '/battle/roller/loop.png',
                    height: 654
                },
                {
                    img: IMAGE_URL + '/battle/roller/finish.png',
                    height: 218
                }
            ],
            elems = [],
            move1, move2,
            _posElems = function(elems) {
                for (var i = 1; i < elems.length; i++) {
                    elems[i].top = elems[i - 1].top - elems[i].height;
                }
            },
            _doMove = function(config) {
                var move = {
                        start: Date.parse(new Date()),
                        config: config,
                        distance: 0,
                        speed: config.speed,
                        boost: config.boost,
                        elapsedTime: 0,
                        finish: function() {
                            window.clearInterval(tickerId);
                            this.finished = true;
                        }
                    };
                var tickSize = 10,
                    ticks = 0,
                    tickTime = Date.now();
                var tickerId = window.setInterval(function() {
                        ticks = Math.round((Date.now() - tickTime) / tickSize);
                        for (var i = 0; i < ticks; i++) {
                            if (move.finished) {
                                break;
                            }
                            move.speed += move.boost;
                            move.distance += move.speed;
                            move.elapsedTime += tickSize;
                            Ext.Array.each(config.elems, function(el, index) {
                                el.top += move.speed;
                                el.el.dom.style.top = el.top + 'px';
                                if (config.onElemHide && el.top >= cellHeight) {
                                    config.onElemHide(el, index, config.elems, move);
                                }
                            });
                            if (config.onTick) {
                                config.onTick(move);
                            }
                        }
                        tickTime = Date.now();
                    }, tickSize);
                return move;
            };
        elems.push({
            el: slotEl.down('.turn'),
            top: 0,
            height: cellHeight
        });
        Ext.Array.each(elemsConfig, function(elCfg) {
            var el = slotEl.appendChild({
                    tag: 'div'
                });
            el.applyStyles({
                'background-image': 'url(' + elCfg.img + ')',
                'background-repeat': 'no-repeat',
                'height': elCfg.height + 'px',
                'width': cellWidth + 'px',
                'top': '-1000px',
                'left': '0px',
                'position': 'absolute'
            });
            elems.push({
                el: el,
                height: elCfg.height
            });
        });
        var startMove = function() {
                //  
                var params = {
                        to: {
                            opacity: 0
                        },
                        duration: 200
                    };
                // elems[0].el.down('.hidden-empty-border').animate(params);
                // elems[0].el.down('.upper-empty-border').animate(params);
                //elems[0].el.down('.image-border').animate(Ext.apply(params,{
                elems[0].el.down('.cost').animate(params);
                elems[0].el.down('.label').animate(params);
                elems[0].el.down('.prognoz-right').animate(Ext.apply(params, {
                    callback: function() {
                        //   
                        _posElems(elems);
                        if (!move2) {
                            move1 = _doMove({
                                elems: elems.slice(0, 4),
                                speed: 0,
                                boost: 0.1,
                                // px per tick
                                onTick: function(move) {
                                    if (move.boost && move.distance >= 100) {
                                        move.boost = 0.2;
                                    }
                                    if (move.boost && move.distance >= 300) {
                                        move.boost = 0.4;
                                    }
                                    if (move.boost && move.distance >= 500) {
                                        move.boost = 0;
                                    }
                                },
                                //                    
                                onElemHide: function(el, index, elems, move) {
                                    if (index == 2 || index == 3) {
                                        _posElems([
                                            elems[index == 2 ? 3 : 2],
                                            elems[index == 2 ? 2 : 3]
                                        ]);
                                    }
                                }
                            });
                        }
                    }
                }));
                setTimeout(function() {
                    elems[0].el.down('.image').setStyle('opacity', 1);
                }, 700);
            };
        //   
        var stopMove = function(callback) {
                if (move1) {
                    move1.finish();
                }
                var moveElems = [];
                elems[0].el.show();
                if (elems[2].top > elems[3].top) {
                    moveElems.push(elems[2]);
                    if (elems[3].top >= -elems[3].height) {
                        moveElems.push(elems[3]);
                    }
                } else if (elems[3].top > elems[2].top) {
                    moveElems.push(elems[3]);
                    if (elems[2].top >= -elems[2].height) {
                        moveElems.push(elems[2]);
                    }
                }
                moveElems.push(elems[4]);
                moveElems.push(elems[0]);
                _posElems(moveElems);
                move2 = _doMove({
                    elems: moveElems,
                    speed: move1.speed,
                    boost: -0.1,
                    onTick: function(move) {
                        if (move.speed <= 10) {
                            move.boost = -0.08;
                        }
                        if (move.speed <= 7) {
                            move.boost = -0.05;
                        }
                        if (move.speed <= 5) {
                            move.boost = 0;
                        }
                        var turnEl = move.config.elems[move.config.elems.length - 1],
                            finish = function() {
                                move.finish();
                                var cb = function() {
                                        var animateParams = {
                                                //from: {opacity: 0},
                                                to: {
                                                    opacity: 1
                                                },
                                                duration: 300
                                            };
                                        elems[0].el.down('.label').animate(animateParams);
                                        elems[0].el.down('.prognoz-right').animate(animateParams);
                                        elems[0].el.down('.hidden-empty-border').animate(animateParams);
                                        elems[0].el.down('.upper-empty-border').animate(animateParams);
                                        elems[0].el.down('.image-border').animate(animateParams);
                                        elems[0].el.down('.cost').animate(animateParams);
                                        elems[1].el.remove();
                                        elems[2].el.remove();
                                        elems[3].el.remove();
                                        elems[4].el.remove();
                                        callback();
                                    };
                                if ((Date.parse(new Date()) - move.start) <= 2000) {
                                    turnEl.el.animate({
                                        duration: 350,
                                        from: {
                                            top: turnEl.top
                                        },
                                        to: {
                                            top: 0
                                        },
                                        easing: 'bounceOut',
                                        callback: cb
                                    });
                                } else {
                                    turnEl.el.setTop(0);
                                    cb();
                                }
                            };
                        if (turnEl.top >= 40 || (Date.parse(new Date()) - move.start) > 1000) {
                            finish();
                        }
                    }
                });
            };
        //       
        var initMove = function(callback) {
                var moveElems = [];
                elems[0].el.show();
                elems[3].top = cellHeight;
                moveElems.push(elems[3]);
                moveElems.push(elems[4]);
                moveElems.push(elems[0]);
                _posElems(moveElems);
                move2 = _doMove({
                    elems: moveElems,
                    speed: 10,
                    boost: -0.09,
                    onTick: function(move) {
                        if (move.speed <= 8) {
                            move.boost = -0.08;
                        }
                        if (move.speed <= 5) {
                            move.boost = -0.05;
                        }
                        if (move.speed <= 3) {
                            move.boost = 0;
                        }
                        if (elems[0].top >= 40) {
                            move.finish();
                            elems[0].el.animate({
                                duration: 350,
                                from: {
                                    top: elems[0].top
                                },
                                to: {
                                    top: 0
                                },
                                easing: 'bounceOut',
                                callback: function() {
                                    var animateParams = {
                                            //from: {opacity: 0},
                                            to: {
                                                opacity: 1
                                            },
                                            duration: 300
                                        };
                                    elems[0].el.down('.label').animate(animateParams);
                                    elems[0].el.down('.prognoz-right').animate(animateParams);
                                    elems[0].el.down('.image-border').animate(Ext.apply(animateParams, {
                                        duration: 500,
                                        delay: 200
                                    }));
                                    elems[0].el.down('.cost').animate(animateParams);
                                    elems[1].el.remove();
                                    elems[2].el.remove();
                                    elems[3].el.remove();
                                    elems[4].el.remove();
                                    callback();
                                }
                            });
                        }
                    }
                });
            };
        return {
            startMove: function() {
                startMove();
            },
            stopMove: function(callback) {
                var minTime = 1000,
                    //     .               
                    _setTimer = function() {
                        if (!move1 || move1.elapsedTime < minTime) {
                            setTimeout(function() {
                                _setTimer();
                            }, move1 ? minTime - move1.elapsedTime : minTime);
                        } else {
                            stopMove(callback);
                        }
                    };
                _setTimer();
            },
            initMove: function(callback) {
                initMove(callback);
            }
        };
    },
    startAnimate: function(initial) {
        var me = this,
            slotEls = me.getEl().select('.slot');
        /***/
        me.log(' ');
        me.waitEnemyTurn(false);
        me.hidePointer();
        if (me.animating) {
            return;
        }
        me.animating = true;
        me.anims = [];
        Ext.Array.each(me.getEl().select('.slot').elements, function(el) {
            var a = me.animateSlot(Ext.get(el));
            me.anims.push(a);
            setTimeout(function() {
                if (initial) {
                    if (me.state.can_kick) {
                        a.initMove(function() {
                            me.animating = false;
                            if (ExGods.app.getUser().checkStuff(me.state.cost_reroll)) {
                                me.disableBtn(false);
                            }
                        });
                    } else {
                        me.animating = false;
                    }
                } else {
                    a.startMove();
                }
            }, 400 - 400 * Math.random());
        });
    },
    stopAnimate: function(callback) {
        var me = this,
            stopped = 0;
        if (me.stopping) {
            return;
        }
        if (me.animating) {
            me.stopping = true;
            Ext.Array.each(me.anims, function(a) {
                a.stopMove(function() {
                    if (++stopped == me.anims.length) {
                        me.animating = false;
                        me.stopping = false;
                        callback();
                    }
                });
            });
        }
    },
    prepareData: function() {
        var me = this,
            turns = [],
            reference = ExGods.ref('battle_turn');
        Ext.Array.each(me.state.av_kick || [
            {},
            {},
            {}
        ], function(item) {
            var refInfo = reference.get(item.name);
            if (!refInfo) {
                refInfo = {
                    label: '',
                    desc: {
                        desc: '',
                        images: {
                            active: '',
                            passive: ''
                        },
                        prognoz_text: '',
                        prognoz_template: ''
                    }
                };
            }
            turns.push({
                name: refInfo.name,
                label: refInfo.label,
                images: {
                    active: IMAGE_URL + refInfo.desc.images.active,
                    passive: IMAGE_URL + refInfo.desc.images.passive
                },
                prognoz: item.prognoz,
                text: refInfo.desc.prognoz_text,
                template: refInfo.desc.prognoz_template,
                cost: item.cost
            });
        });
        return {
            turns: turns,
            state: me.state
        };
    },
    onTurnClick: function(e, el) {
        var me = this,
            name;
        el = Ext.get(el);
        if (!me.animating && !el.hasCls('disabled')) {
            Ext.each(el.up('#battle-roller').select('.turn').elements, function(turnDom) {
                var animateParams = {
                        to: {
                            opacity: 0
                        },
                        duration: 200
                    };
                if (turnDom == el.dom) {
                    name = el.getAttribute('role');
                    el.down('.cost').animate(animateParams);
                    el.down('.prognoz-right').animate(animateParams);
                    el.down('.label').animate(animateParams);
                    el.down('.image-border').animate(Ext.apply(animateParams, {
                        callback: function() {
                            me.fireEvent('turnclick', name);
                        }
                    }));
                    el.addCls('disabled');
                } else {
                    var turnEl = Ext.get(turnDom);
                    turnEl.down('.image-border').animate(animateParams);
                    turnEl.addCls('disabled');
                }
            });
        }
    },
    onTurnMouseOver: function(e, el) {
        var me = this,
            name = el.getAttribute('role'),
            ref = ExGods.ref('battle_turn').get(name),
            turn = Ext.Array.findBy(me.state.av_kick, function(item) {
                return item.name == name;
            }),
            tpl_buffer = '',
            prognoz_valid = false;
        if (me.tooltip) {
            if (me.tooltip.name == name) {
                return;
            } else {
                me.tooltip.close();
                me.tooltip = false;
            }
        }
        if (me.mouseOverTimeOut) {
            clearTimeout(me.mouseOverTimeOut);
        }
        if (ref.desc.prognoz) {
            tpl_buffer = '<div class="stats-list"><ul class="battle-table-list">';
            for (var key in ref.desc.prognoz.room) {
                var p = ref.desc.prognoz.room[key];
                if (!p.prognoz_label)  {
                    
                    continue;
                }
                
                prognoz_valid = true;
                tpl_buffer += '<li><span class="label">' + p.prognoz_label + '</span>';
                tpl_buffer += '<span class="value">' + p.prognoz_template + '</span></li>';
            }
            tpl_buffer += '</ul></div>';
            tpl_buffer = new Ext.XTemplate(tpl_buffer);
            tpl_buffer = tpl_buffer.apply(turn || {});
        }
        me.mouseOverTimeOut = setTimeout(function() {
            if (Ext.get(el).isVisible(true)) {
                me.tooltip = Ext.widget('commondetailswindow', {
                    itemElement: el.dom || el,
                    name: name,
                    data: {
                        label: ref.label,
                        image: IMAGE_URL + ref.desc.images.active,
                        rows: [
                            {
                                content: prognoz_valid ? tpl_buffer : false
                            },
                            {
                                content: ref.desc.desc
                            }
                        ]
                    }
                });
            }
        }, ExGods.ref('constants|bat_tooltip_delay').value);
    },
    onTurnMouseOut: function(e, el) {
        var me = this,
            rt = Ext.get(e.relatedTarget),
            t = Ext.get(e.target);
        if (!rt || !t)  {
            return;
        }
        
        var oldName = rt.up('.turn') ? rt.up('.turn').getAttribute('role') : rt.getAttribute('role'),
            newName = t.up('.turn') ? t.up('.turn').getAttribute('role') : t.getAttribute('role');
        if (oldName && oldName == newName) {
            return;
        }
        if (me.mouseOverTimeOut) {
            clearTimeout(me.mouseOverTimeOut);
        }
        if (me.tooltip && me.tooltip.close) {
            me.tooltip.close();
            me.tooltip = false;
        }
    },
    onRerollClick: function() {
        var me = this;
        if (me.state.can_reroll && !me.getEl().down('#battle-roller-btn').hasCls('disabled')) {
            me.fireEvent('rerollclick');
        }
    },
    setState: function(state) {
        var me = this,
            slotEls, data, battleview, ekey, buser;
        if (state)  {
            me.state = state;
        }
        
        data = me.prepareData();
        if (me.rendered) {
            slotEls = me.getEl().select('.slot');
            ekey = ExGods.app.getUser().get('battle').ekey;
            battleview = ExGods.app.getBattleBattleViewController();
            buser = battleview.getBattleUser(ekey);
            Ext.Array.each(data.turns, function(turn, index) {
                var turnEl = slotEls.item(index).down('.turn'),
                    enoughStuff = ExGods.app.getUser().checkStuff(turn.cost, {
                        activeSlot: true
                    });
                // Ext.each(turn.cost,function(item){
                //  if(buser.get('timed')[item.params.id] && buser.get('timed')[item.params.id][0] < item.params.quantity) enoughStuff = false;
                // });
                if (turnEl) {
                    turnEl.set({
                        role: turn.name
                    });
                    if (!enoughStuff || battleview.f_wait_kick || battleview.f_start_round_complete) {
                        turnEl.addCls('disabled');
                    } else {
                        turnEl.removeCls('disabled');
                    }
                    turnEl.down('.image').applyStyles({
                        'background-image': 'url(' + (enoughStuff ? turn.images.active : turn.images.passive) + ')'
                    });
                    turnEl.down('.label').setHTML(me.getPrognoz(turn, 'top'));
                    turnEl.down('.prognoz-right').setHTML(me.getPrognoz(turn, 'right'));
                    //turnEl.down('.cost').setHTML(me.getPrognoz(turn,'bottom') + ' ' + me.getCost(turn));
                    turnEl.down('.cost').setHTML(me.getPrognoz(turn, 'bottom'));
                }
            });
            me.disableBtn(!me.state.can_reroll || me.animating || battleview.f_wait_kick || battleview.f_start_round_complete);
            //   
            me.getEl().down('#battle-roller-btn').setHTML(me.printSpriteMoney(me.state.cost_reroll || [], {
                cls: "battle-roller-cost"
            }));
        }
    },
    setDead: function() {
        var me = this;
        Ext.Array.each(me.el.select('.turn').elements, function(turnDom) {
            var turnEl = Ext.get(turnDom);
            turnEl.addCls('disabled');
            turnEl.fadeOut({
                duration: 200
            });
        });
        me.el.down('.dead-msg').fadeIn({
            duration: 200
        });
        me.disableBtn(true);
        me.f_death_blocked = true;
    },
    disableBtn: function(disabled) {
        var me = this;
        if (me.rendered) {
            if (disabled) {
                me.getEl().select('#battle-roller-btn').addCls('disabled');
            } else if (me.state.can_reroll && !me.animating && !me.f_death_blocked && ExGods.app.getUser().checkStuff(me.state.cost_reroll)) {
                me.getEl().select('#battle-roller-btn').removeCls('disabled');
            }
        }
    },
    /**
     *      
     */
    showPointer: function(turn) {
        var me = this,
            container = me.up('#battle-container'),
            isMark = false;
        if (this.is_shown_pointer)  {
            return;
        }
        
        if (!turn && this.is_shown_mark)  {
            return;
        }
        
        if (me.f_death_blocked)  {
            return;
        }
        
        if (!turn) {
            var turns = Ext.select('.turn').elements,
                priorityValue = 0,
                priorityTurns = [];
            Ext.Array.each(turns, function(node, index) {
                if (node.className.split(' ').indexOf('disabled') != -1)  {
                    return;
                }
                
                var priority = me.state.av_kick[index].priority;
                if (priority > priorityValue) {
                    priorityValue = priority;
                    priorityTurns = [
                        node
                    ];
                } else if (priority == priorityValue) {
                    priorityTurns.push(node);
                }
            });
            turn = Ext.get(priorityTurns[Math.floor(Math.random() * priorityTurns.length)]);
        } else {
            isMark = true;
        }
        container.el.select('.finger').remove();
        var style = [
                'left:' + (turn.getX() - container.getX() + 26) + 'px',
                'top:' + (turn.getY() - container.getY() + 20) + 'px'
            ].join(';'),
            html = [
                '<div class="finger" style="' + style + '">',
                '<div class="finger-image"></div>',
                '<div class="finger-text" style="background-image: url(' + ExGods.ref('images|battle_images').image['finger_text'] + ')"></div>',
                '</div>'
            ].join(''),
            animEl = container.el.insertHtml('beforeEnd', html, true),
            img = animEl.down('.finger-image').dom,
            text = animEl.down('.finger-text').dom,
            cycles = ExGods.ref('constants|bat_anim_pointer_cycles').value,
            time_text_shown = ExGods.ref('constants|bat_anim_pointer_text_hidden').value,
            time_text_hidden = ExGods.ref('constants|bat_anim_pointer_text_shown').value,
            time = ExGods.ref('constants|bat_anim_pointer_speed').value,
            deltaOpacity = (time / (time - time_text_hidden - time_text_shown)).toFixed(2),
            startOpacity = (deltaOpacity * (time - time_text_hidden) / time).toFixed(2),
            i = maxI = 51 * cycles,
            showing = true,
            deltaX = 10,
            deltaY = 5,
            timestamp;
        if (!isMark)  {
            me.is_shown_pointer = true;
        }
        
        animEl.on('click', function(e, el) {
            me.onTurnClick(e, turn);
        });
        animEl.on('mouseover', function(e, el) {
            me.onTurnMouseOver(e, turn);
        });
        animEl.on('mouseout', function(e, el) {
            me.onTurnMouseOut(e, turn);
        });
        (function() {
            // 
            text.style.opacity = startOpacity - Math.abs((i - maxI / (2)) / (maxI / (2))) * deltaOpacity;
            // 
            img.style.left = (24 + Math.abs(deltaX * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            img.style.top = (-18 - Math.abs(deltaY * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            // 
            if (i % (maxI / cycles) == maxI / (2 * cycles))  {
                ExGods.helpme.shine(animEl, 'finger-sprite', 34, -62, 25);
            }
            
            if (i > 0) {
                i--;
                var curTime = new Date().getTime();
                if (!me.is_shown_pointer && !timestamp) {
                    timestamp = curTime + time / maxI * i + 100;
                }
                if (timestamp && curTime > timestamp) {
                    animEl.remove();
                    return;
                }
                setTimeout(arguments.callee, time / maxI);
            } else {
                i = maxI;
                if (me.is_shown_pointer) {
                    setTimeout(arguments.callee, time / maxI);
                } else {
                    animEl.remove();
                }
            }
        })();
    },
    /**
     *      
     */
    hidePointer: function() {
        this.is_shown_pointer = false;
    },
    /**
     *      
     */
    waitEnemyTurn: function(wait) {
        var me = this,
            el = me.getEl();
        if (!el || me.f_wait_enemy === wait) {
            return;
        } else {
            me.f_wait_enemy = wait;
        }
        if (wait) {
            el.addCls('f-wait-enemy');
            el.down('.wait-enemy-msg').fadeIn({
                duration: 200
            });
            el.select('.turn').addCls('disabled');
            me.disableBtn(true);
        } else {
            el.removeCls('f-wait-enemy');
            el.down('.wait-enemy-msg').fadeOut({
                duration: 200
            });
        }
    },
    applyMarks: function(marks) {
        var me = this,
            time = parseInt(ExGods.ref('constants|bat_anim_pointer_speed').value) + 50,
            battleViewCtrl = ExGods.app.getBattleBattleViewController();
        if (me.marksInterval)  {
            clearInterval(me.marksInterval);
        }
        
        if (marks.length) {
            me.marksInterval = setInterval(function() {
                var nodes = me.getEl().select('.turn'),
                    markNodes = [];
                Ext.Array.each(nodes.elements, function(node) {
                    if (marks.indexOf(node.attributes.role.value) != -1) {
                        markNodes.push(Ext.get(node));
                    }
                });
                if (markNodes.length) {
                    Ext.each(markNodes, function(node) {
                        if (!node.hasCls('disabled') && !me.animating && !battleViewCtrl.f_start_round_complete && ExGods.app.getViewportController().getCenter().isVisible()) {
                            me.hidePointer();
                            me.showPointer(node);
                            me.is_shown_mark = true;
                        }
                    });
                } else {
                    me.is_shown_mark = false;
                }
            }, time);
        } else {
            me.is_shown_mark = false;
        }
    },
    printSpriteMoney: function(stuff, options) {
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        options = options || {};
        var me = this,
            res = [];
        Ext.Array.each(stuff, function(item) {
            res.push(ExGods.util.Sprite.printSprite(item.params.quantity, IMAGE_URL + 'num_combo.png', {
                width: 10,
                height: 16,
                cls: item.params.id + '-sprite' + (options.cls ? ' ' + options.cls : ''),
                tag: options.tag
            }));
        });
        return res.join(' ');
    }
});

/**
 *     
 */
Ext.define('ExGods.view.battle_new.PrepActions', {
    extend: Ext.Component,
    alias: 'widget.battle_preps',
    /**
     * @cfg {Object} state  
     */
    state: {},
    /**
     * @cfg {ExGods.controller.battle.BattleView} battleView  BattleView
     */
    battleView: null,
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="left-arrow disabled"></div>',
            '<div class="list-wrap">',
            '<ul class="prep-actions">',
            '<tpl for="values.av_prep">',
            '<li class="prep-action {[this.getPrepCls(values)]}" role="{[values.name]}">',
            //'<div class="label">{[ this.getPrepName(values.name) ]}</div>',
            '<div class="counter">{[ this.getPrepCounterValue() ]}</div>',
            '<div class="image" style="background-image: url({[ this.getPrepImage(values) ]})">',
            '<div class="image-frame"></div>',
            '<div class="svg-frame" id="svg-frame-{[xindex]}"></div>',
            '</div>',
            '<div class="cost">',
            '<tpl if="cost && cost.length">',
            '{[ ExGods.util.Stuff.printStuff(values.cost || []) ]}',
            '<tpl else>',
            ExGods.getMsgByKey('view_battle_prepactions_freeaction'),
            '</tpl>',
            '</div>',
            //'<div class="mask"></div>',
            '</li>',
            '</tpl>',
            '</ul>',
            '</div>',
            '<div class="right-arrow disabled"></div>',
            {
                getPrepCls: function(prepAction) {
                    var cls = '';
                    if (me.isActionDisabled(prepAction)) {
                        cls = 'disabled';
                    }
                    return cls;
                },
                getPrepName: function(name) {
                    var prep = ExGods.ref('battle_prep|' + name);
                    if (prep) {
                        return prep.label;
                    }
                },
                getPrepImage: function(prepAction) {
                    var prep = ExGods.ref('battle_prep|' + prepAction.name);
                    if (me.isActionDisabled(prepAction)) {
                        return IMAGE_URL + prep.desc.images.passive;
                    } else {
                        return IMAGE_URL + prep.desc.images.active;
                    }
                },
                getPrepCounterValue: function(state) {
                    return me.getPrepCounterValue();
                }
            }
        ];
        me.data = me.state;
        me.callParent();
        me.on('destroy', function() {
            if (me.tooltip)  {
                me.tooltip.close();
            }
            
        });
    },
    afterRender: function() {
        var me = this,
            el = me.getEl();
        me.callParent(arguments);
        if (!me.state.user.battle.live) {
            me.setDisabled(true);
            return;
        }
        el.on('click', me.onPrepActsLeftClick, me, {
            delegate: '.left-arrow'
        });
        el.on('click', me.onPrepActsRightClick, me, {
            delegate: '.right-arrow'
        });
        el.on('click', me.onPrepActClick, me, {
            delegate: '.prep-action'
        });
        el.on('mouseover', me.onPrepActMouseOver, me, {
            delegate: '.prep-action'
        });
        el.on('mouseout', me.onPrepActMouseOut, me, {
            delegate: '.prep-action'
        });
        Ext.Array.each(el.select('.prep-action').elements, function(actionDom, index) {
            var actionEl = Ext.get(actionDom),
                img = actionEl.down('.image'),
                data = me.state.av_prep[index];
            if (data.rest && data.cd && parseInt(data.cd) > 1 && data.rest != 0) {
                ExGods.helpme.createSquareTimer(0, parseInt(data.cd), parseInt(data.rest), false, false, 'svg-frame-' + (index + 1), 57);
            }
        });
        var interval = setInterval(function() {
                var els = el.select('.prep-action').elements;
                if (!els.length) {
                    clearInterval(interval);
                    return;
                }
                Ext.Array.each(els, function(actionDom, index) {
                    var actionEl = Ext.get(actionDom),
                        img = actionEl.down('.image');
                    if (actionEl.hasCls('disabled'))  {
                        return;
                    }
                    
                    ExGods.helpme.shine(img, 'battle-roller-btn-shine', 19, 62, 25).on('click', function(e) {
                        me.onPrepActClick(e, actionEl);
                    });
                });
            }, 5000);
        me.doPrepActsOffset(0);
    },
    // ,  /   
    onPrepActClick: function(e, el) {
        var me = this,
            name;
        el = Ext.get(el);
        name = el.getAttribute('role');
        if (!el.hasCls('disabled')) {
            el.addCls('disabled');
            me.fireEvent('prepclick', name);
        }
    },
    onPrepActMouseOver: function(e, el) {
        var me = this,
            name = el.getAttribute('role'),
            ref = ExGods.ref('battle_prep').get(name),
            prep = Ext.Array.findBy(me.state.av_prep, function(item) {
                return item.name == name;
            }),
            tpl_buffer = '';
        if (me.tooltip) {
            if (me.tooltip.name == name) {
                return;
            } else {
                me.tooltip.close();
                me.tooltip = false;
            }
        }
        if (me.mouseOverTimeOut) {
            clearTimeout(me.mouseOverTimeOut);
        }
        if (ref.desc.prognoz) {
            tpl_buffer = '<div class="stats-list"><ul class="table-list">';
            for (var i = 0; i < ref.desc.prognoz.length; i++) {
                tpl_buffer += '<li><span class="label">' + ref.desc.prognoz[i].prognoz_label + '</span>';
                tpl_buffer += '<span class="value">' + ref.desc.prognoz[i].prognoz_template + '</span></li>';
            }
            tpl_buffer += '</ul></div>';
            tpl_buffer = new Ext.Template(tpl_buffer);
            tpl_buffer = tpl_buffer.apply(prep.prognoz || {});
        }
        me.mouseOverTimeOut = setTimeout(function() {
            if (Ext.get(el).isVisible(true)) {
                me.tooltip = Ext.widget('commondetailswindow', {
                    itemElement: el.dom || el,
                    name: name,
                    data: {
                        label: ref.label,
                        image: IMAGE_URL + ref.desc.images.active,
                        rows: [
                            {
                                content: tpl_buffer
                            },
                            {
                                content: prep.cost && prep.cost.length ? '<div style="clear:both;overflow:hidden">' + ExGods.getMsgByKey('view_battle_prepactions_pricewordintt') + ' <span class="prep-action-stuff" style="float:right; font-weight: bold;">' + ExGods.util.Stuff.printStuff(prep.cost || []) + '</span></div>' : null
                            },
                            {
                                content: ref.desc.desc
                            }
                        ]
                    }
                });
            }
        }, ExGods.ref('constants|bat_tooltip_delay').value);
    },
    onPrepActMouseOut: function(e, el) {
        var me = this,
            newName = Ext.get(e.target).up('.prep-action') ? Ext.get(e.target).up('.prep-action').getAttribute('role') : Ext.get(e.target).getAttribute('role');
        var oldName = undefined;
        var relatedTarget = e.relatedTarget;
        if (relatedTarget) {
            oldName = Ext.get(relatedTarget).up('.prep-action') ? Ext.get(relatedTarget).up('.prep-action').getAttribute('role') : Ext.get(relatedTarget).getAttribute('role');
        }
        if (oldName == newName) {
            return;
        }
        if (me.mouseOverTimeOut) {
            clearTimeout(me.mouseOverTimeOut);
        }
        if (me.tooltip && me.tooltip.close) {
            me.tooltip.close();
            me.tooltip = false;
        }
    },
    onPrepActsLeftClick: function(e, el) {
        var me = this,
            offsetNum = (me.prepActsOffset || 0) - 1;
        me.doPrepActsOffset(offsetNum);
    },
    onPrepActsRightClick: function(e, el) {
        var me = this,
            offsetNum = (me.prepActsOffset || 0) + 1;
        me.doPrepActsOffset(offsetNum);
    },
    // @param offsetNum -  ,     
    doPrepActsOffset: function(offsetNum) {
        var me = this,
            offset, listEl, leftArrEl, rightArrEl;
        me.prepActsOffset = me.prepActsOffset || 0;
        listEl = Ext.select('#battle-prepacts ul').first();
        leftArrEl = Ext.select('#battle-prepacts .left-arrow').first();
        rightArrEl = Ext.select('#battle-prepacts .right-arrow').first();
        //     
        if (offsetNum >= 0 && me.state.av_prep.length - offsetNum >= 4) {
            // 4 -  
            offset = offsetNum * 91;
            // 91 -   
            listEl.setStyle('left', '-' + offset + 'px');
            me.prepActsOffset = offsetNum;
        }
        if (me.prepActsOffset == 0) {
            leftArrEl.addCls('disabled');
        } else {
            leftArrEl.removeCls('disabled');
        }
        if (me.state.av_prep.length - me.prepActsOffset <= 4) {
            rightArrEl.addCls('disabled');
        } else {
            rightArrEl.removeCls('disabled');
        }
    },
    /**
     *   .
     * update - ,    
     */
    updateCounters: function(update) {
        var me = this,
            prepCounterValue = me.getPrepCounterValue();
        if (me.rendered) {
            if (update) {
                me.update(me.state);
            }
            //  
            if (me.state.can_prep) {
                me.getEl().select('#battle-prepacts .counter').setHTML(prepCounterValue);
            }
            //   
            Ext.Array.each(me.state.av_prep, function(prepAction, index) {
                var el, prep,
                    enoughStuff = me.isEnoughCost(prepAction.cost),
                    el = me.getEl().select('#battle-prepacts li.prep-action').item(index);
                if (me.isActionDisabled(prepAction)) {
                    if (prepAction.cd && parseInt(prepAction.cd) > 1) {
                        ExGods.helpme.createSquareTimer(0, parseInt(prepAction.cd), parseInt(prepAction.rest), false, false, 'svg-frame-' + (index + 1), 57);
                        if (!el.down('.prepact-cd') && prepAction.rest > 0) {
                            var sprite = ExGods.util.Sprite.printSprite(parseInt(prepAction.rest), IMAGE_URL + '/num_combo.png', {
                                    width: 10,
                                    height: 16
                                });
                            el.down('.image').insertHtml('beforeEnd', '<div class="prepact-cd">' + sprite + '</div>');
                        }
                    }
                    if (el) {
                        el.addCls('disabled');
                        prep = ExGods.ref('battle_prep|' + prepAction.name);
                        el.down('.image').applyStyles({
                            'background-image': 'url(' + IMAGE_URL + prep.desc.images.passive + ')'
                        });
                    }
                } else {
                    if (el) {
                        el.removeCls('disabled');
                        prep = ExGods.ref('battle_prep|' + prepAction.name);
                        el.down('.image').applyStyles({
                            'background-image': 'url(' + IMAGE_URL + prep.desc.images.active + ')'
                        });
                    }
                }
            });
        }
    },
    /**
     *      
     */
    getPrepCounterValue: function() {
        var me = this,
            startDate, restToPrepare;
        startDate = new Date(me.state.start * 1000 + ExGods.util.Date.serverTimeOffset * 1000);
        restToPrepare = Math.max(me.state.to_prepare - parseInt((Date.now() - startDate) / 1000), 0);
        if (restToPrepare < 10 && restToPrepare > 0) {
            restToPrepare = '<span class="red">' + restToPrepare + '</span>';
        }
        return restToPrepare || 0;
    },
    /**
     *      
     */
    setState: function(state) {
        var me = this;
        me.state = state;
        if (me.rendered) {
            me.updateCounters(true);
            me.doPrepActsOffset(me.prepActsOffset || 0);
        }
    },
    /**
     * / 
     */
    setDisabled: function(disabled) {
        var me = this,
            rootEl;
        if (me.rendered) {
            rootEl = me.getEl();
            if (disabled) {
                rootEl.select('.prep-action').addCls('disabled');
                me.actions_disabled = true;
            } else {
                if (me.state.can_prep) {
                    //rootEl.select('.prep-action').removeCls('disabled');
                    me.actions_disabled = false;
                    me.updateCounters();
                }
            }
        }
    },
    applyMarks: function(marks) {
        var me = this,
            nodes = me.getEl().select('#battle-prepacts li.prep-action'),
            markNodes = [],
            time = parseInt(ExGods.ref('constants|bat_anim_pointer_speed').value) + 50;
        Ext.Array.each(nodes.elements, function(node) {
            if (marks.indexOf(node.attributes.role.value) != -1) {
                markNodes.push(Ext.get(node));
            }
        });
        if (me.marksInterval)  {
            clearInterval(me.marksInterval);
        }
        
        if (markNodes.length) {
            me.marksInterval = setInterval(function() {
                Ext.each(markNodes, function(node) {
                    if (node.hasCls('disabled') || !ExGods.app.getViewportController().getCenter().isVisible()) {
                        clearInterval(me.marksInterval);
                    } else {
                        me.showPointer(node);
                    }
                });
            }, time);
        }
    },
    /**
     *      
     */
    showPointer: function(prepact) {
        var me = this,
            container = me.up('#battle-container'),
            style = [
                'left:' + (prepact.getX() - container.getX() + 15) + 'px',
                'top:' + (prepact.getY() - container.getY() + 15) + 'px'
            ].join(';'),
            html = [
                '<div class="finger" style="' + style + '">',
                '<div class="finger-image"></div>',
                '<div class="finger-text"></div>',
                '</div>'
            ].join(''),
            animEl = container.el.insertHtml('beforeEnd', html, true),
            img = animEl.down('.finger-image').dom,
            text = animEl.down('.finger-text').dom,
            cycles = ExGods.ref('constants|bat_anim_pointer_cycles').value,
            time_text_shown = ExGods.ref('constants|bat_anim_pointer_text_hidden').value,
            time_text_hidden = ExGods.ref('constants|bat_anim_pointer_text_shown').value,
            time = ExGods.ref('constants|bat_anim_pointer_speed').value,
            deltaOpacity = (time / (time - time_text_hidden - time_text_shown)).toFixed(2),
            startOpacity = (deltaOpacity * (time - time_text_hidden) / time).toFixed(2),
            i = maxI = 50 * cycles,
            showing = true,
            deltaX = 10,
            deltaY = 5,
            timestamp;
        animEl.on('click', function(e, el) {
            me.onPrepActClick(e, prepact);
        });
        animEl.on('mouseover', function(e, el) {
            me.onPrepActMouseOver(e, prepact);
        });
        animEl.on('mouseout', function(e, el) {
            me.onPrepActMouseOut(e, prepact);
        });
        (function() {
            // 
            text.style.opacity = startOpacity - Math.abs((i - maxI / (2)) / (maxI / (2))) * deltaOpacity;
            // 
            img.style.left = (24 + Math.abs(deltaX * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            img.style.top = (-18 - Math.abs(deltaY * (i % (maxI / cycles) - maxI / (2 * cycles)) / (maxI / (2 * cycles)))) + 'px';
            // 
            if (i % (maxI / cycles) == maxI / (2 * cycles))  {
                ExGods.helpme.shine(animEl, 'finger-sprite', 34, -62, 25);
            }
            
            if (i > 0) {
                i--;
                var curTime = new Date().getTime();
                if (!timestamp) {
                    timestamp = curTime + time / maxI * i + 100;
                }
                if (timestamp && curTime > timestamp) {
                    animEl.remove();
                    return;
                }
                setTimeout(arguments.callee, time / maxI);
            } else {
                animEl.remove();
            }
        })();
    },
    isActionDisabled: function(prepAction) {
        var me = this;
        return !me.state.can_prep || prepAction.rest > 0 || me.getPrepCounterValue() == 0 || !me.isEnoughCost(prepAction.cost) || me.actions_disabled || (prepAction.max_used > 0 && prepAction.used >= prepAction.max_used) || prepAction.timeout > 0;
    },
    /**
     * ,        
     */
    isEnoughCost: function(cost) {
        var me = this;
        //       .
        //    -      ,      
        return me.battleView.getBattleUser().checkStuff(cost) || ExGods.app.getUser().checkStuff(cost);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.data.av_kick) {
            for (var i = 0; i < me.data.av_kick.length; i++) {
                if (me.data.av_kick[i].cost) {
                    stuff_arr.push(me.data.av_kick[i].cost);
                }
            }
        }
        if (me.data.av_prep) {
            for (var i = 0; i < me.data.av_prep.length; i++) {
                if (me.data.av_prep[i].cost) {
                    for (var j = 0; j < me.data.av_prep[i].cost.length; j++) {
                        stuff_arr.push(me.data.av_prep[i].cost[j]);
                    }
                }
            }
        }
        return {
            stuff: stuff_arr,
            images: [].concat(arr_images)
        };
    }
});

/**
 *      
 */
Ext.define('ExGods.view.battle_new.Choice', {
    extend: Ext.Component,
    alias: 'widget.battle_choice',
    /**
     * @cfg {Object} state  
     */
    state: {},
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<tpl if="kick">',
            '<div class="my-kick" style="background-image: url({[ this.getTurnImage(values.kick) ]});"></div>',
            '</tpl>',
            '<tpl if="enemy_kick">',
            '<div class="enemy-kick" style="background-image: url({[ this.getEnemyTurnImage(values.enemy_kick) ]}); left: 108px;"></div>',
            '</tpl>',
            {
                getTurnName: function(name) {
                    var turn = ExGods.ref('battle_turn|' + name);
                    if (turn) {
                        return turn.label;
                    }
                },
                getTurnImage: function(name) {
                    var turn = ExGods.ref('battle_turn|' + name);
                    if (turn) {
                        return IMAGE_URL + turn.desc.images['active'];
                    }
                },
                getEnemyTurnImage: function(name) {
                    var turn = ExGods.ref('battle_turn|' + name);
                    if (turn) {
                        return IMAGE_URL + turn.desc.images['flip'];
                    }
                }
            }
        ];
        me.data = me.state;
        me.callParent();
    },
    setMyChoice: function(kickName) {
        var me = this;
        me.state.kick = kickName;
        me.update(me.state);
    },
    setEnemyChoice: function(kickName, callback) {
        if (!this.state.user.battle.live) {
            callback();
            return;
        }
        var me = this,
            kickEl = me.getEl().down('.enemy-kick'),
            ref_data = ExGods.ref('battle_turn|' + kickName),
            img = ref_data ? IMAGE_URL + ref_data.desc.images['flip'] : '';
        if (!kickEl) {
            kickEl = me.getEl().insertHtml('beforeEnd', '<div class="enemy-kick" style="left: 108px;"></div>', true);
        }
        kickEl.applyStyles({
            'opacity': ExGods.ref('constants|bat_anim_e_choice_opacity').value,
            'background-image': 'url(' + img + ')'
        });
        kickEl.animate({
            to: {
                opacity: 1
            },
            duration: ExGods.ref('constants|bat_anim_e_choice_dur').value,
            callback: function() {
                callback();
            }
        });
    },
    clearChoice: function() {
        var me = this;
        me.state.kick = null;
        me.state.enemy_kick = null;
        me.update(me.state);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.state.kick) {
            var turn = ExGods.ref('battle_turn|' + me.state.kick);
            if (turn) {
                arr_images.push(IMAGE_URL + turn.desc.images['active']);
            }
        }
        if (me.state.enemy_kick) {
            var turn = ExGods.ref('battle_turn|' + me.state.enemy_kick);
            if (turn) {
                arr_images.push(IMAGE_URL + turn.desc.images['flip']);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.battle_new.UserList', {
    extend: Ext.panel.Panel,
    alias: 'widget.battle_userlist',
    /**
     * @cfg   (required)
     */
    store: null,
    /**
     * @cfg , ,     
     */
    isEnemies: false,
    padding: '4px 4px 8px 4px',
    //padding: 4,
    plugins: [
        'skindeco',
        {
            ptype: 'scroller',
            autoHide: true,
            autoRestorePosition: true,
            padding: '28px 5px 0 0'
        }
    ],
    initComponent: function() {
        var me = this;
        me.header = {
            cls: 'battle-group-header',
            style: {
                backgroundImage: 'url(' + ExGods.ref('images|battle_images').image[me.isEnemies ? 'header_opponent' : 'header_ally'] + '),url(' + IMAGE_URL + 'skin-bg.png);'
            }
        };
        me.items = [
            {
                xtype: 'dataview',
                store: me.store,
                autoEl: 'ul',
                cls: 'battle-group-list',
                itemSelector: 'li',
                tpl: [
                    '<tpl for=".">',
                    '<li class="{[this.getCls(values)]}">',
                    '<div class="battle-avatar-lvl-container">',
                    //  
                    '<div class="battle-group-avatar" style="background-image:url({[this.getAvatarImage(values.shape)]})" data-uname="{display_title}"></div>',
                    //
                    '<div class="battle-group-lvl">{[this.getLevel(values.hoard.level)]}</div>',
                    //lvl
                    '</div>',
                    '<div class="battle-nick-timed-container">',
                    //  
                    '<p data-qtip="{display_title}">{display_title}</p>',
                    //
                    '<div class="battle-group-timed">',
                    // 
                    '<div class="sp" data-qtip="' + ExGods.getMsgByKey('view_battle_userlist_sptt') + ' {[ExGods.printNumber(Math.floor(values.timed.shield[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.shield[1], 10000, "0")]}" style="width:{[this.calcBarWidth(values.timed.shield)]}px">',
                    '<span>{[ExGods.printNumber(Math.floor(values.timed.shield[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.shield[1], 10000, "0")]}</span>',
                    '</div>',
                    '<div class="hp" data-qtip="' + ExGods.getMsgByKey('view_battle_userlist_hptt') + ' {[ExGods.printNumber(Math.floor(values.timed.hp[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.hp[1], 10000, "0")]}" style="width:{[this.calcBarWidth(values.timed.hp)]}px">',
                    '<span>{[ExGods.printNumber(Math.floor(values.timed.hp[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.hp[1], 10000, "0")]}</span>',
                    '</div>',
                    '<tpl if="this.isEnemies()">',
                    '<div class="mp" data-qtip="" style="width:0px">',
                    '<span style="margin: -1px;">???</span>',
                    '</div>',
                    '<tpl else>',
                    '<div class="mp" data-qtip="' + ExGods.getMsgByKey('view_battle_userlist_mptt') + ' {[ExGods.printNumber(Math.floor(values.timed.mp[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.mp[1], 10000, "0")]}" style="width:{[this.calcBarWidth(values.timed.mp)]}px">',
                    '<span>{[ExGods.printNumber(Math.floor(values.timed.mp[0]), 10000, "0")]}/{[ExGods.printNumber(values.timed.mp[1], 10000, "0")]}</span>',
                    '</div>',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    //
                    '<tpl if="aura">',
                    '<div class="battle-aura-container">',
                    '{[this.printAuras(values.aura)]}',
                    '</div>',
                    '</tpl>',
                    '<tpl if="battle.live == 0">',
                    '<div class="battle-group-dead-mask"></div>',
                    '</tpl>',
                    '</li>',
                    '</tpl>',
                    {
                        getCls: function(data) {
                            var cls = [];
                            if (data.is_bot) {
                                cls.push('bot');
                            }
                            return cls.join(' ');
                        },
                        calcBarWidth: function(param) {
                            return Math.ceil(88 * param[0] / param[1]) || 0;
                        },
                        printAuras: function(auras) {
                            var prepared = [],
                                html = '';
                            //aura[0] - aura name
                            //aura[1] - aura steps
                            Ext.Array.each(auras, function(aura) {
                                var i = prepared.length;
                                while (i--) {
                                    if (prepared[i].name == aura[0] && prepared[i].steps == aura[1]) {
                                        prepared[i].count++;
                                        return;
                                    }
                                }
                                prepared.push({
                                    name: aura[0],
                                    steps: aura[1],
                                    count: 1
                                });
                            });
                            Ext.Array.each(prepared, function(aura) {
                                var ref = ExGods.ref('battle_aura|' + aura.name),
                                    img = IMAGE_URL + (ref.params.images.small || ref.params.images.icon),
                                    steps = aura.steps != "0" ? '<div class="battle-aura-counter">' + aura.steps + '</div>' : "",
                                    count = aura.count > 1 ? '<div class="battle-aura-count exg-stuff-decorator-quantity-counter"><span>' + aura.count + '</span></div>' : "";
                                html += [
                                    '<div class="battle-aura" data-qtip="' + ref.label + '" data-aura="' + aura.name + '" style="background-image:url(' + img + ')">',
                                    steps,
                                    count,
                                    '</div>'
                                ].join('');
                            });
                            return html;
                        },
                        getAvatarImage: function(shape) {
                            return ExGods.references.get('user_shape').getByKey(shape).thumb;
                        },
                        getLevel: function(level) {
                            var result = '';
                            level = level.toString();
                            for (var i = 0; i < level.length; i++) {
                                result += '<img alt="' + level[i] + '" class="number-' + level[i] + '" src="' + Ext.BLANK_IMAGE_URL + '">';
                            }
                            return result;
                        },
                        isEnemies: function() {
                            return me.isEnemies;
                        }
                    }
                ]
            }
        ];
        me.callParent();
        me.store.on('do_refresh', function() {
            if (me.items && me.items.items && me.items.items[0])  {
                me.items.items[0].refresh();
            }
            
        });
        me.on('afterrender', function() {
            // me.el.on('click',function(){
            //  if(me.isInfo){
            //      me.isInfo = false;
            //  }else{
            //      me.isInfo = true;
            //  }
            //  me.onUserChange();
            //  me.fireEvent('viewmodechange', me, me.isInfo); //      
            // },me,{delegate:'.info-btn'});
            me.el.on('click', function(e, el) {
                var aura = ExGods.ref('battle_aura|' + el.dataset.aura);
                var cmp = Ext.widget('commondetailswindow', {
                        autoShow: false,
                        itemElement: el.dom || el,
                        data: {
                            label: aura.label,
                            description: aura.params.description,
                            image: IMAGE_URL + aura.params.images.large
                        }
                    });
                ExGods.Resources.load(cmp, function() {
                    cmp.show();
                });
            }, me, {
                delegate: '.battle-aura'
            });
            me.el.on('click', function(e, el) {
                el = Ext.get(el);
                if (!el.up('li').hasCls('bot')) {
                    ExGods.app.fireEvent('nickinfoclick', el.getAttribute('data-uname'));
                }
            }, me, {
                delegate: '.battle-group-avatar'
            });
        }, me);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            var dt = me.store.data.items[i].data;
            arr_images.push(ExGods.references.get('user_shape').getByKey(dt.shape).thumb);
            if (dt.aura) {
                for (var j = 0; j < dt.aura.length; j++) {
                    var aura = dt.aura[j];
                    if (aura instanceof Array) {} else {
                        aura = [
                            aura
                        ];
                    }
                    for (var k = 0; k < aura.length; k++) {
                        var strct = ExGods.ref('battle_aura|' + aura[k]);
                        if (strct && strct.params) {
                            var imgs = strct.params.images;
                            for (var it in imgs) {
                                arr_images.push(imgs[it]);
                            }
                        }
                    }
                }
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.battle_new.Result', {
    extend: Ext.container.Container,
    alias: 'widget.battleresult',
    /**
     * @cfg {Object} data   
     */
    data: {},
    cls: 'battle-result',
    margin: '6px 7px',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    plugins: [
        'paperdeco'
    ],
    initComponent: function() {
        var me = this,
            data = me.config.data.battle_result,
            side = data.user_result.side,
            allies, enemies, akpi, ekpi,
            socialFriend = data.user_result.arena_special_rival;
        for (var i = 0; i < data.participant.length; i++) {
            if (data.participant[i][0].side == side) {
                allies = data.participant[i];
                akpi = data.result.total_kpi[i + 1];
            } else {
                enemies = data.participant[i];
                ekpi = data.result.total_kpi[i + 1];
            }
        }
        var single = (allies.length > 1 || enemies.length > 1) ? false : true,
            can_master = false;
        i = data.user_result.loot ? data.user_result.loot.length : 0;
        while (i--) {
            if (data.user_result.loot[i].is_store) {
                can_master = true;
                break;
            }
        }
        me.items = [
            {
                xtype: 'battleresultside',
                kpi: akpi,
                members: allies,
                enemies: false,
                single: single,
                lose: data.user_result.is_lose,
                margin: '7px 0 7px 11px'
            },
            {
                html: '<div class="v-separator" style="height:400px"></div>'
            },
            {
                xtype: 'battlerewards',
                data: data.user_result,
                flex: 1,
                dockedItems: [
                    {
                        dock: 'bottom',
                        xtype: 'toolbar',
                        layout: {
                            pack: 'center'
                        },
                        margin: '0 0 20',
                        items: [
                            {
                                xtype: 'textbutton',
                                dock: 'bottom',
                                cls: 'no_border',
                                width: 120,
                                margin: '0 5',
                                text: ExGods.getMsgByKey('view_battle_result_closebtn'),
                                handler: function() {
                                    me.fireEvent('close');
                                },
                                hidden: can_master
                            },
                            {
                                xtype: 'textbutton',
                                dock: 'bottom',
                                cls: 'no_border',
                                width: 120,
                                text: ExGods.getMsgByKey('view_battle_result_closebtn'),
                                margin: '0 5',
                                handler: function() {
                                    ExGods.app.getInventoryInventoryController().service.command('put_from_store_loot', {
                                        battle_id: data.battle_id
                                    }, function() {
                                        me.fireEvent('close');
                                    });
                                },
                                hidden: !can_master
                            },
                            {
                                xtype: 'textbutton',
                                dock: 'bottom',
                                itemId: 'loot_manager_btn',
                                cls: 'no_border',
                                width: 120,
                                text: ExGods.getMsgByKey('view_battle_result_masterbtn'),
                                margin: '0 5',
                                hidden: !can_master || !ExGods.app.getUser().getGuild()
                            }
                        ]
                    }
                ]
            },
            {
                html: '<div class="v-separator" style="height:400px"></div>'
            },
            {
                xtype: 'battleresultside',
                kpi: ekpi,
                members: enemies,
                enemies: true,
                single: single,
                lose: !data.user_result.is_lose,
                margin: '7px 11px 7px 0'
            }
        ];
        me.callParent();
        if (socialFriend && isSocialApp) {
            var ref = ExGods.ref('images|vk_battle_result');
            ExGods.app.getSocialController().wallPost({
                message: ref.description,
                image: ref.image.title,
                owner: socialFriend.id
            });
        }
    },
    //   VK
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.model.BattleResult', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'bot',
            type: 'int'
        },
        {
            name: 'side',
            type: 'string'
        },
        {
            name: 'live',
            type: 'string'
        },
        {
            name: 'user',
            type: 'auto'
        },
        {
            name: 'kpi',
            type: 'int'
        }
    ]
});

/**
 *  
 */
Ext.define('ExGods.store.BattleResult', {
    extend: Ext.data.Store,
    model: 'ExGods.model.BattleResult',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'kpi',
            direction: 'DESC'
        }
    ]
});

/**
 *      
 */
Ext.define('ExGods.view.battle_new.ResultSide', {
    extend: Ext.panel.Panel,
    alias: 'widget.battleresultside',
    width: 227,
    cls: 'battle-result-side',
    initComponent: function() {
        var me = this;
        me.store = Ext.create('ExGods.store.BattleResult', {
            data: me.members
        });
        var tpl = [
                '<div class="paper-title">{[this.getTitle()]}</div>',
                '<tpl if="this.isNotSingle()">',
                '<div class="column-titles">',
                '<p style="float:left">' + ExGods.getMsgByKey('view_battle_resultside_membertitle') + '</p>',
                '<p style="float:right">' + ExGods.getMsgByKey('view_battle_resultside_effecttitle') + '</p>',
                '</div>',
                '</tpl>',
                '<table>',
                '<tpl for=".">',
                '<tpl if="this.isNotSingle()">',
                '<tpl if="xindex &lt; 7">',
                '<tr class="{[ xindex % 2 ? "exg-share-bg-dark" : "exg-share-bg-light" ]}">',
                '<td class="base-info" style="background-image: url({[ this.getImage(values.user.shape) ]})">',
                '<span>{[ ExGods.printUser(values.user, {fields: "name,rank", maxNameWidth: 120})]}</span>',
                '<span>{[ ExGods.printUser(values.user, {fields: "level"})]}</span>',
                '<div class="image-frame"></div>',
                '</td>',
                '<td class="kpi">{[this.calcKpi(values)]}</td>',
                '</tr>',
                '</tpl>',
                '<tpl else>',
                '<div class="battle-result-frame"></div>',
                me.lose ? '<div class="battle-result-lose" style="background-image: url({[this.getLoseImage()]})"></div>' : '',
                '<div class="battle-result-avatar {[this.flip()]}" style="background-image: url({[this.getBigImage(values.user.shape)]})">',
                '</div>',
                '</tpl>',
                '</tpl>',
                '</table>',
                {
                    getImage: function(shape) {
                        if (typeof shape == 'object') {
                            return /^http/.test(shape.thumb) ? shape.thumb : IMAGE_URL + shape.thumb;
                        } else {
                            return ExGods.references.get('user_shape').getByKey(shape).thumb;
                        }
                    },
                    getBigImage: function(shape) {
                        if (typeof shape == 'object') {
                            return /^http/.test(shape.large) ? shape.large : IMAGE_URL + shape.large;
                        } else {
                            return ExGods.references.get('user_shape').getByKey(shape).full;
                        }
                    },
                    getLoseImage: function() {
                        return ExGods.references.get('images').get('avatar_ruin').image.avatar_ruin;
                    },
                    getTitle: function(values) {
                        if (me.single) {
                            return ExGods.printUser(me.store.getAt(0).data.user, {
                                fields: "name,rank,level"
                            });
                        } else {
                            return me.enemies ? '<h4>' + ExGods.getMsgByKey('view_battle_resultside_enemytitle') + '</h4>' : '<h4>' + ExGods.getMsgByKey('view_battle_resultside_allytitle') + '</h4>';
                        }
                    },
                    isNotSingle: function() {
                        return !me.single;
                    },
                    flip: function() {
                        return (me.enemies) ? 'flip-h' : '';
                    },
                    calcKpi: function(values) {
                        return Math.round((values.kpi && me.kpi) ? values.kpi * 100 / me.kpi : 0) + '%';
                    }
                }
            ];
        me.items = [
            {
                xtype: 'dataview',
                store: me.store,
                itemSelector: 'tr',
                tpl: tpl
            }
        ];
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            var dt = me.store.data.items[i].data;
            var shp = ExGods.references.get('user_shape').getByKey(dt.user.shape).thumb;
            arr_images.push(shp);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *     
 */
Ext.define('ExGods.view.battle_new.Rewards', {
    extend: Ext.panel.Panel,
    alias: 'widget.battlerewards',
    cls: 'battle-rewards',
    initComponent: function() {
        var me = this;
        me.data = me.config.data;
        me.loot = [];
        me.loot_group = [];
        me.item_loot = [];
        me.chain_loot = [];
        me.losses = [];
        //  loot         "store_source"
        Ext.Array.each(me.data.loot || [], function(item) {
            if (me.data.loot_group && item.store_source == 'loot')  {
                return;
            }
            
            if (item.store_source == 'chain') {
                me.chain_loot.push(item.stuff);
            } else {
                me.loot.push(item.stuff);
            }
        });
        //   
        Ext.Array.each(me.data.loot_group || [], function(item) {
            me.loot_group.push(item.stuff);
        });
        //  
        if (me.data.item_drop) {
            Ext.Array.each(me.data.item_drop, function(item) {
                me.losses.push({
                    params: {
                        itemModel: Ext.create('ExGods.model.Item', item.item),
                        id: item.proto
                    },
                    type: 'iteminstance'
                });
            });
        }
        //  
        if (me.data.item_loot) {
            Ext.Array.each(me.data.item_loot, function(item) {
                me.item_loot.push({
                    params: {
                        itemModel: Ext.create('ExGods.model.Item', item.item),
                        id: item.proto
                    },
                    type: 'iteminstance'
                });
            });
        }
        //     
        if (me.data.break_reward) {
            me.loot = me.loot.concat(ExGods.helpme.flatStuff(me.data.break_reward, {
                flatItems: true
            }));
        }
        // 
        if (me.data.get_exp) {
            var expa = {
                    params: {
                        quantity: me.data.get_exp
                    },
                    type: 'expa'
                };
            if (parseInt(me.data.get_exp) > 0) {
                me.loot.push(expa);
            } else {
                me.losses.push(expa);
            }
        }
        //  
        if (me.data.get_exp_add) {
            var expa_add = {
                    params: {
                        quantity: me.data.get_exp_add
                    },
                    type: 'expa_bonus'
                };
            if (parseInt(me.data.get_exp_add) > 0) {
                me.loot.push(expa_add);
            } else {
                me.losses.push(expa_add);
            }
        }
        // 
        if (me.data.get_trophy) {
            var trophy = {
                    params: {
                        quantity: me.data.get_trophy > 0 ? me.data.get_trophy : me.data.get_trophy * -1
                    },
                    type: 'trophy'
                };
            if (parseInt(me.data.get_trophy) > 0) {
                me.loot.push(trophy);
            } else {
                me.losses.push(trophy);
            }
        }
        //     (  battle_chain),     
        if (me.data.battle_chain) {
            if (me.data.battle_chain.win_stuff) {
                me.loot = me.loot.concat(ExGods.helpme.flatStuff(me.data.battle_chain.win_stuff));
            } else if (me.data.battle_chain.lose_stuff) {
                me.losses = me.losses.concat(ExGods.helpme.flatStuff(me.data.battle_chain.lose_stuff));
            }
            me.chain_loot = [];
        }
        //          /
        //      
        var flagSize = 'normal';
        if (me.losses.length > 4 || (me.loot.length + me.item_loot.length) > 4 || me.chain_loot.length > 4 || me.loot_group.length > 4 || ((me.loot.length + me.item_loot.length) && me.chain_loot.length && me.losses.length)) {
            flagSize = 'short';
        }
        var loot_tpl = [];
        if (me.loot.length || me.item_loot.length)  {
            loot_tpl.push('<div class="paper-title"><h4>' + ExGods.getMsgByKey('view_battle_rewards_rewardstitle') + '</h4></div><div class="item-rewards"></div>');
        }
        
        if (me.chain_loot.length)  {
            loot_tpl.push('<div class="paper-title"><h4>' + ExGods.getMsgByKey('battle_result_chain_loot_title') + '</h4></div><div class="chain-rewards"></div>');
        }
        
        if (me.loot_group.length)  {
            loot_tpl.push('<div class="paper-title"><h4>' + ExGods.getMsgByKey('view_battle_rewards_grouptitle') + '</h4></div><div class="loot-drop"></div>');
        }
        
        if (me.losses.length)  {
            loot_tpl.push('<div class="paper-title"><h4>' + ExGods.getMsgByKey('view_battle_rewards_losstitle') + '</h4></div><div class="item-drop"></div>');
        }
        
        loot_tpl = loot_tpl.join('<div class="battle-rewards-separator"></div>');
        me.tpl = [
            '<div class="battle-flag ' + (flagSize == 'short' ? 'short-flag' : '') + '" style="background-image: url({[this.getFlag(values)]})"></div>',
            '<div class="battle-rewards-separator"></div>',
            loot_tpl,
            {
                getFlag: function(values) {
                    var ret;
                    if (flagSize == 'short') {
                        if (values.is_draw) {
                            ret = ExGods.ref('images|battle_images').image['drawgame_flag_short'];
                        } else if (values.is_lose) {
                            ret = ExGods.ref('images|battle_images').image['defeat_flag_short'];
                        } else {
                            ret = ExGods.ref('images|battle_images').image['victory_flag_short'];
                        }
                    } else {
                        if (values.is_draw) {
                            ret = ExGods.ref('images|battle_images').image['draw_flag'];
                        } else if (values.is_lose) {
                            ret = ExGods.ref('images|battle_images').image['lose_flag'];
                        } else {
                            ret = ExGods.ref('images|battle_images').image['win_flag'];
                        }
                    }
                    return ret;
                },
                getTitle: function(values) {
                    return (drop || values.is_lose) ? ExGods.getMsgByKey('view_battle_rewards_losstitle') : ExGods.getMsgByKey('view_battle_rewards_rewardstitle');
                }
            }
        ];
        me.callParent();
        me.on('afterrender', function() {
            if (me.losses.length)  {
                me.printLootLose();
            }
            
            if (me.loot.length)  {
                me.printLoot();
            }
            
            if (me.loot_group.length)  {
                me.printGroupLoot();
            }
            
            if (me.item_loot.length) {
                me.printItemLoot();
            }
            if (me.chain_loot.length) {
                me.printChainLoot();
            }
        });
    },
    printLoot: function() {
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            i;
        ExGods.util.Helper.loadProtosFromStuff(me.loot, function() {
            me.el.down('.item-rewards').update(ExGods.stuff.StuffManager.image(me.loot));
        });
    },
    printGroupLoot: function() {
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            i;
        ExGods.util.Helper.loadProtosFromStuff(me.loot_group, function() {
            me.el.down('.loot-drop').update(ExGods.stuff.StuffManager.image(me.loot_group));
        });
    },
    printChainLoot: function() {
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            i;
        ExGods.util.Helper.loadProtosFromStuff(me.chain_loot, function() {
            me.el.down('.chain-rewards').update(ExGods.stuff.StuffManager.image(me.chain_loot));
        });
    },
    /**
     *   
     */
    printItemLoot: function() {
        var me = this,
            items = '',
            protos = ExGods.app.getItemPrototypesStore(),
            el = me.el.down('.item-rewards ul');
        if (!el) {
            me.el.down('.item-rewards').update('<ul>');
            el = me.el.down('.item-rewards ul');
        }
        ExGods.util.Helper.loadProtosFromStuff(me.item_loot, function() {
            el.insertHtml('beforeEnd', ExGods.stuff.StuffManager.image(me.item_loot));
        });
    },
    /**
     *    ( items)
     */
    printLootLose: function() {
        var me = this,
            items = '',
            protos = ExGods.app.getItemPrototypesStore(),
            rewards = [];
        ExGods.util.Helper.loadProtosFromStuff(me.losses, function() {
            me.el.down('.item-drop').update(ExGods.stuff.StuffManager.image(me.losses));
        });
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.losses && me.losses.length) {
            stuff_arr = stuff_arr.concat(me.losses);
        }
        if (me.loot && me.loot.length) {
            stuff_arr = stuff_arr.concat(me.loot);
        }
        if (me.loot_group && me.loot_group.length) {
            stuff_arr = stuff_arr.concat(me.loot_group);
        }
        if (me.item_loot && me.item_loot.length) {
            stuff_arr = stuff_arr.concat(me.item_loot);
        }
        if (me.chain_loot && me.chain_loot.length) {
            stuff_arr = stuff_arr.concat(me.chain_loot);
        }
        var images__ = ExGods.ref('images|battle_images').image;
        for (var it in images__) {
            arr_images.push(images__[it]);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   .
 */
Ext.define('ExGods.controller.battle.BattleView', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BattleView:'
    },
    views: [
        'battle_new.Avatar',
        'battle_new.UserList',
        'battle_new.Result',
        'battle_new.ResultSide',
        'battle_new.Rewards',
        'battle_new.Roller',
        'battle_new.PrepActions',
        'battle_new.Choice'
    ],
    refs: [
        {
            /**
         * @private
         * @method getBattleChatMessages
         *     
         * @return {ExGods.view.chat.MessageList}
         */
            ref: 'battleChatMessages',
            selector: '#battle-chat-messages'
        },
        {
            /**
         * @private
         * @method getChatContactList
         *      ""
         */
            ref: 'chatContactList',
            selector: '#chat-contact-list #contact-list'
        },
        {
            /**
         * @private
         * @method getBattleContainer
         *   
         * @return {Ext.container.Container}
         */
            ref: 'battleContainer',
            selector: 'battlecontainer'
        },
        {
            /**
         * @method getQuickSlots
         *    
         * @return {ExGods.view.QuickSlots}
         */
            ref: 'quickSlots',
            selector: '#quick-slots'
        }
    ],
    /**
     * @property {Number} cur_round   ,   
     */
    cur_round: undefined,
    aura: {},
    init: function() {
        var me = this;
        /*me.app.getChatConnection().on({
            command_battle_log: me.onBattleLogMessage,
            scope: me
        });*/
        // me.listen({
        //  controller: {
        //      '#battle.Battle': {
        //          'load_start': me.onBattleLoadStart,
        //          'start': me.onBattleStart,
        //          'not_active_battle': me.onNotActiveBattle,
        //          'u_change': me.onBattleUserChange,
        //          'u_add': me.onBattleUserAdd,
        //          'u_title': me.onBattleUserTitle,
        //          'load_finish': me.onBattleLoadFinish,
        //          'finish': me.onBattleFinish,
        //          'before_reroll': me.onBattleBeforeReroll,
        //          'reroll': me.onBattleReroll,
        //          'before_prep': me.onBattleBeforePrep,
        //          'prep': me.onBattlePrep,
        //          'before_kick': me.onBattleBeforeKick,
        //          'kick': me.onBattleKick,
        //          'user_kick': me.onBattleUserKick,
        //          'enemy_kick': me.onBattleEnemyKick,
        //          'load_round': me.onBattleLoadRound,
        //          'round': {
        //              fn: me.onBattleRound,
        //              delay: 400
        //          },
        //          'item': me.onBattleItem,
        //          'apply_marks':me.applyMarks,
        //          'exit': me.onBattleExit,
        //          'state_refresh': me.onBattleStateRefresh,
        //      },
        //      '#battle.Animation': {
        //          afteranim: me.onAfterAnimation,
        //      }
        //  },
        //  component: {
        //      '#battle-header' : {
        //          showbattle: me.onBattleHeaderShowBattle,
        //          showgroup: me.onBattleHeaderShowGroup
        //      },
        //      '#battle-prepacts': {
        //          prepclick: me.onPrepButtonClick,
        //      },
        //      '#battle-roller': {
        //          turnclick: me.onRollerTurnClick,
        //          rerollclick: me.onRerollButtonClick
        //      }
        //  }
        // });
        me.control({
            '#battle-header': {
                showbattle: me.onBattleHeaderShowBattle,
                showgroup: me.onBattleHeaderShowGroup
            },
            '#battle-prepacts': {
                prepclick: me.onPrepButtonClick
            },
            '#battle-roller': {
                turnclick: me.onRollerTurnClick,
                rerollclick: me.onRerollButtonClick
            }
        });
        //    
        me.allies = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.User',
            sorters: [
                {
                    sorterFn: function() {
                        return me.sortMembers.apply(me, arguments);
                    }
                }
            ]
        });
        //    
        me.enemies = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.User',
            sorters: [
                {
                    sorterFn: function() {
                        return me.sortMembers.apply(me, arguments);
                    }
                }
            ]
        });
        //     
        me.battle = me.app.getController('battle.Battle');
        //     
        me.animation = me.app.getController('battle.Animation');
        //     
        me.inventory = me.app.getController('inventory.Inventory');
        ExGods.stuff.StuffManager.register({
            'expa_bonus': ExGods.view.battle_new.stuff.BattleReward
        });
        me.callParent(arguments);
    },
    /**
     *  true,   
     */
    isRendered: function() {
        return this.getBattleContainer() ? true : false;
    },
    /**
    *     
    */
    onRender: function(listener) {
        var me = this;
        me.control({
            '#battle-container': {
                render: listener
            }
        });
    },
    /**
    *     
    */
    onDestroy: function(listener) {
        var me = this;
        me.control({
            '#battle-container': {
                destroy: listener
            }
        });
    },
    applyMarks: function(marks) {
        var me = this;
        me.marks = marks;
        if (me.getBattleContainer()) {
            var actions = [],
                prepacts = [],
                turns = [],
                items = [];
            Ext.each(marks, function(quest) {
                Ext.each(quest.aims, function(aim) {
                    Ext.each(aim.marks, function(mark) {
                        if (mark.battle_action)  {
                            actions.push(mark.battle_action);
                        }
                        
                        if (mark.instant)  {
                            prepacts.push(mark.instant);
                        }
                        
                        if (mark.main)  {
                            turns.push(mark.main);
                        }
                        
                        if (mark.item)  {
                            items.push(mark.item);
                        }
                        
                    });
                });
            });
            Ext.getCmp('battle-roller').applyMarks(turns);
            Ext.getCmp('battle-prepacts').applyMarks(prepacts);
            me.getQuickSlots().applyMarks(actions, items);
        }
    },
    //      
    onBattleLogMessage: function(chatcn, message) {
        var me = this,
            data = message.body.data,
            chatMessages = me.getBattleChatMessages(),
            tpl, battle_log;
        if (data.message) {
            message.tpl = data.message;
        } else {
            battle_log = ExGods.references.get('battle_log');
            tpl = battle_log.getByKey(data.type + '_' + (data.result || ''));
            if (tpl) {
                message.tpl = tpl.pattern;
            }
        }
        if (chatMessages && message) {
            chatMessages.addMessage(message);
        }
    },
    onBattleLoadStart: function() {
        var me = this;
        if (me.app.getController('Viewport').layout && me.app.getController('Viewport').layout != 'battle') {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView    ');
            me.canLayout = false;
            me.app.getController('Location').maskLocation(function() {
                if (me.canLayout) {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView  ,   -  ');
                    me.setLayoutAndShow();
                } else {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView  ,   - ');
                    me.canLayout = true;
                }
            });
        } else {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView   ,   ');
            me.canLayout = true;
        }
    },
    onBattleStart: function() {
        var me = this,
            side1 = [],
            side2 = [],
            myBattleSide = me.user.getBattleSide();
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView   ');
        //   
        me.battle.list.each(function(u) {
            var u_copy = Ext.clone(u);
            if (u.battle.side == "1") {
                side1.push(u_copy);
            } else {
                side2.push(u_copy);
            }
        });
        me.allies.removeAll();
        me.enemies.removeAll();
        me.allies.loadRawData(myBattleSide == 1 ? side1 : side2);
        me.enemies.loadRawData(myBattleSide == 1 ? side2 : side1);
        me.allies.sort();
        me.enemies.sort();
        me.cur_round = me.battle.state.round;
        me.changes = {};
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView   ,   - ' + me.cur_round);
        if (me.canLayout) {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView   -  ');
            me.setLayoutAndShow();
        } else {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView     - ');
            me.canLayout = true;
        }
    },
    setLayoutAndShow: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView    ');
        me.app.getController('Viewport').setLayout('battle', function() {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView  ,  ');
            me.resetFlags();
            me.showBattleView();
            me.applyMarks(me.marks);
            me.showHint('start');
            me.inventory.lockNewItemsUpdate();
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_start').log('@battleView  ');
        });
    },
    showBattleView: function() {
        var me = this,
            battleCt = me.getBattleContainer(),
            myBattleSide = me.user.getBattleSide(),
            enemyInfoCmp, enemy;
        /***/
        me.log(' ');
        if (battleCt) {
            battleCt.removeAll();
            enemy = me.getBattleEnemy();
            //   
            var cntrl_comp = Ext.create({
                    xtype: 'container',
                    layout: {
                        type: 'hbox',
                        align: 'stretch'
                    },
                    items: [
                        {
                            xtype: 'battle_avatar',
                            id: 'battle-avatar',
                            user: me.getBattleUser(me.user.getBattleEkey()),
                            isEnemy: false,
                            width: 218
                        },
                        {
                            xtype: 'container',
                            layout: 'absolute',
                            id: 'battle-central',
                            flex: 1,
                            plugins: [
                                'skindeco'
                            ],
                            items: [
                                {
                                    xtype: 'component',
                                    cls: 'bg',
                                    width: 476,
                                    height: 396,
                                    x: -27,
                                    y: 31,
                                    style: {
                                        'background-image': 'url(' + ExGods.ref('images|battle_images').image['battle_main'] + ')'
                                    }
                                },
                                {
                                    xtype: 'battle_roller',
                                    id: 'battle-roller',
                                    state: Ext.clone(me.battle.state),
                                    animateOnRender: true
                                },
                                {
                                    xtype: 'battle_preps',
                                    id: 'battle-prepacts',
                                    state: Ext.clone(me.battle.state),
                                    battleView: me
                                },
                                {
                                    xtype: 'battle_choice',
                                    id: 'battle-choice',
                                    state: Ext.clone(me.battle.state)
                                }
                            ]
                        },
                        {
                            xtype: 'battle_avatar',
                            id: 'battle-enemy-avatar',
                            user: enemy,
                            isEnemy: true,
                            width: 218
                        }
                    ]
                });
            battleCt.add(cntrl_comp);
            //   
            var enemy_lst = Ext.create({
                    xtype: 'container',
                    autoShow: false,
                    layout: {
                        type: 'hbox',
                        align: 'stretch'
                    },
                    padding: 2,
                    items: [
                        {
                            xtype: 'battle_userlist',
                            store: me.allies,
                            flex: 1
                        },
                        {
                            xtype: 'battle_userlist',
                            store: me.enemies,
                            isEnemies: true,
                            flex: 1
                        }
                    ]
                });
            ExGods.Resources.load(enemy_lst, function() {
                ExGods.Resources.load(cntrl_comp, function() {
                    battleCt.add(enemy_lst);
                });
            });
            //         
            if (enemy) {
                enemyInfoCmp = Ext.getCmp('battle-enemy-info');
                if (enemyInfoCmp) {
                    enemyInfoCmp.setUser(enemy);
                }
            }
            ExGods.util.Ticker.addListener(me.onTick, me);
            battleCt.on('destroy', function() {
                ExGods.util.Ticker.removeListener(me.onTick, me);
            });
            // 
            var userInfo = Ext.getCmp('tech-info'),
                enemyInfo = Ext.getCmp('header-right');
            userInfo.setUser(me.getBattleUser(me.user.getBattleEkey()));
            userInfo.fireEvent('battlestart');
            enemyInfo.addCls('in-battle');
            me.getQuickSlots().setDisabled((battleCt.down('battle_roller').f_wait_enemy) ? true : !me.battle.state.can_item);
            //     
            var user = me.getBattleUser(me.user.getBattleEkey());
            user.on('battlechanged', function() {
                var rollerCmp = Ext.getCmp('battle-roller'),
                    prepActsCmp = Ext.getCmp('battle-prepacts'),
                    headerCmp = Ext.getCmp('battle-header'),
                    choiceCmp = Ext.getCmp('battle-choice');
                if (!user.isLiveInBattle() && !me.battle.result) {
                    //    ( ),  
                    headerCmp.setDied(true);
                    rollerCmp.hidePointer();
                    rollerCmp.setDead();
                    prepActsCmp.setDisabled(true);
                    me.getQuickSlots().setDisabled(true);
                }
            });
        } else {
            /***/
            me.log('error', '   .');
        }
    },
    /**
     *       
     */
    finishAnimationAndShowResult: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView    ');
        me.animation.onAnimationFinish(function() {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  ');
            setTimeout(function() {
                me.showResultView();
            }, 2500);
        });
    },
    //     
    /**
     *   
     */
    showResultView: function() {
        var me = this,
            viewport = me.app.getController('Viewport'),
            wnd;
        /***/
        me.log('  ', me.battle.result);
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView    ');
        try {
            viewport.setLayout('main', function() {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView   ');
                // 
                var userInfo = Ext.getCmp('tech-info'),
                    enemyInfo = Ext.getCmp('header-right');
                userInfo.setUser(me.user);
                userInfo.fireEvent('battlefinish', {
                    battle_result: me.battle.result
                });
                enemyInfo.removeCls('in-battle');
                if (me.battle.result) {
                    wnd = Ext.widget('window2', {
                        id: 'battle-result',
                        autoShow: false,
                        items: [
                            {
                                xtype: 'battleresult',
                                data: {
                                    battle_result: me.battle.result
                                },
                                listeners: {
                                    close: function() {
                                        wnd.close();
                                    }
                                }
                            }
                        ]
                    });
                    ExGods.Resources.load(wnd, function() {
                        wnd.show();
                    });
                }
                me.getQuickSlots().setDisabled(false);
                me.inventory.unlockNewItemsUpdate();
                if (!viewport.gameShown) {
                    viewport.on('gameshown', function() {
                        if (wnd && wnd.rendered) {
                            wnd.doLayout();
                        }
                    }, this, {
                        single: true,
                        delay: 200
                    });
                }
            });
        } catch (e) {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView    ' + e);
            /***/
            me.log('error', e);
        }
    },
    getListBySide: function(side) {
        var me = this;
        if (me.user.getBattleSide() == side) {
            return me.allies;
        } else {
            return me.enemies;
        }
    },
    onTick: function() {
        var me = this,
            startDate = new Date(me.battle.state.start * 1000 + ExGods.util.Date.serverTimeOffset * 1000),
            restToRound,
            roller = Ext.getCmp('battle-roller'),
            viewport = ExGods.app.getViewportController();
        // startDate = ExGods.util.Date.normalizeServerDateTime(startDate);
        restToRound = Math.max(me.battle.state.to_round - parseInt((Date.now() - startDate) / 1000), 0);
        //   ""       z-      x-
        if (viewport.gameShown && restToRound <= (ExGods.ref('constants|bat_anim_pointer_time').value / 1000) && restToRound > 0 && (!me.rerollTime || (Date.now() - me.rerollTime) > parseInt(ExGods.ref('constants|bat_anim_pointer_speed').value) * 2) && ExGods.app.getViewportController().getCenter().isVisible() && !roller.is_shown_pointer && !me.f_wait_kick && !me.f_start_round_complete && !roller.animating && !Ext.getCmp('battle-prepacts').marksInterval && !me.getQuickSlots().marksInterval && Ext.select('.turn:not([class="turn disabled"])').elements.length) {
            roller.showPointer();
        } else {
            roller.hidePointer();
        }
        try {
            Ext.getCmp('battle-header').setTime(restToRound);
            Ext.getCmp('battle-prepacts').updateCounters();
        } catch (e) {
            /****/
            me.log('error', '   ');
        }
    },
    /**    **/
    onRollerTurnClick: function(name) {
        var me = this;
        me.battle.doKick(name);
    },
    onPrepButtonClick: function(prepName) {
        var me = this;
        me.battle.doPrep(prepName);
    },
    onRerollButtonClick: function(btn) {
        var me = this;
        me.battle.doReroll();
    },
    onBattleHeaderShowBattle: function() {
        var me = this,
            battleCt = me.getBattleContainer();
        if (battleCt) {
            battleCt.getLayout().setActiveItem(0);
            Ext.select('.finger').fadeIn();
        }
    },
    onBattleHeaderShowGroup: function() {
        var me = this,
            battleCt = me.getBattleContainer();
        if (battleCt) {
            battleCt.getLayout().setActiveItem(1);
            Ext.select('.finger').fadeOut();
        }
    },
    /**
     *       battle ekey.  ekey  ,   
     */
    getBattleUser: function(ekey) {
        var me = this,
            index;
        ekey = ekey || me.user.getBattleEkey();
        index = me.allies.findBy(function(u) {
            return u.data.battle.ekey == ekey;
        });
        if (index != -1) {
            return me.allies.getAt(index);
        } else {
            index = me.enemies.findBy(function(u) {
                return u.data.battle.ekey == ekey;
            });
            if (index != -1) {
                return me.enemies.getAt(index);
            } else {
                return null;
            }
        }
    },
    /**
     *    .
     *     , ..   ,       -    
     */
    getBattleEnemy: function() {
        var me = this,
            enemyAvatarCmp = Ext.getCmp('battle-enemy-avatar');
        if (enemyAvatarCmp) {
            return enemyAvatarCmp.user;
        } else {
            if (me.battle.state.live != "0" && me.battle.state.enemy) {
                return me.getBattleUser(me.battle.state.enemy);
            } else {
                return null;
            }
        }
    },
    /**
     *      
     */
    onBattleUserChange: function(data) {
        var me = this;
        data = Ext.clone(data);
        me.changes = me.changes || {};
        if (me.cur_round != me.battle.state.round) {
            me.changes.next = me.changes.next || {};
            me.changes.next[data.battle.ekey] = me.changes.next[data.battle.ekey] || [];
            me.changes.next[data.battle.ekey].push(data);
        } else {
            me.changes[data.battle.ekey] = me.changes[data.battle.ekey] || [];
            me.changes[data.battle.ekey].push(data);
            me.applyChanges(data.battle.ekey, data);
        }
    },
    /**
     * @private      
     */
    applyChanges: function(ekey, changes) {
        var me = this,
            user = me.getBattleUser(me.user.getBattleEkey()),
            enemy = me.getBattleEnemy(),
            u;
        changes = Ext.clone(changes);
        if (ekey == user.getBattleEkey()) {
            u = user;
        } else if (enemy && ekey == enemy.getBattleEkey()) {
            u = enemy;
        }
        if (u) {
            // Note: ,          
            //    
            delete changes.timed;
            delete changes.battle;
            delete changes.aura;
            delete changes.stats;
            u.set(changes);
        } else {
            u = me.getBattleUser(ekey);
            if (u) {
                u.set(changes);
                //   , ..        
                me.allies.fireEvent('do_refresh');
                me.enemies.fireEvent('do_refresh');
            }
        }
    },
    /**
     * @private    
     */
    applyChangesOnNewRound: function() {
        var me = this;
        if (me.changes && me.changes.next) {
            me.changes = me.changes.next;
            me.changes.next = {};
            Ext.Object.each(me.changes, function(k, v) {
                me.applyChanges(k, v[v.length - 1]);
            });
        } else {
            me.changes = {
                next: {}
            };
        }
    },
    /**
     * @private       
     */
    syncChanges: function() {
        var me = this,
            u_ekey = me.user.getBattleEkey(),
            user = me.getBattleUser(me.user.getBattleEkey()),
            enemy = me.getBattleEnemy(),
            e_ekey = enemy ? enemy.getBattleEkey() : null;
        if (me.changes) {
            if (me.changes[u_ekey]) {
                user.set(me.changes[u_ekey][me.changes[u_ekey].length - 1]);
            }
            if (enemy && me.changes[e_ekey]) {
                enemy.set(me.changes[e_ekey][me.changes[e_ekey].length - 1]);
            }
        }
    },
    /**
     *     
     */
    onBattleUserAdd: function(data) {
        var me = this;
        if (me.user.getBattleSide() == data.battle.side) {
            me.allies.loadRawData(Ext.clone(data), true);
        } else {
            me.enemies.loadRawData(Ext.clone(data), true);
        }
    },
    onBattleUserTitle: function(ekey, title) {
        var me = this,
            user = me.allies.getAt(me.allies.findBy(function(user) {
                return user.data.battle.ekey == ekey;
            }));
        if (!user) {
            user = me.enemies.getAt(me.enemies.findBy(function(user) {
                return user.data.battle.ekey == ekey;
            }));
        }
        if (user) {
            user.set('display_title', title);
        }
    },
    onBattleBeforeReroll: function() {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller');
        rollerCmp.disableBtn(true);
        rollerCmp.startAnimate();
        me.rerollTime = Date.now();
    },
    onBattleReroll: function() {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller');
        setTimeout(function() {
            rollerCmp.setState(me.battle.state);
            rollerCmp.stopAnimate(function() {
                rollerCmp.disableBtn(me.f_start_round_complete);
            });
        }, 1000 - (Date.now() - me.rerollTime));
        rollerCmp.disableBtn(me.f_start_round_complete);
    },
    onBattleBeforePrep: function() {
        var me = this,
            prepActsCmp = Ext.getCmp('battle-prepacts');
    },
    // 
    onBattlePrep: function() {
        var me = this,
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            rollerCmp = Ext.getCmp('battle-roller');
        prepActsCmp.setState(me.battle.state);
        rollerCmp.setState(me.battle.state);
    },
    onBattleBeforeKick: function() {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller'),
            prepActsCmp = Ext.getCmp('battle-prepacts');
        prepActsCmp.setDisabled(true);
        rollerCmp.hidePointer();
        rollerCmp.disableBtn(true);
        me.getQuickSlots().setDisabled(true);
        me.setFlag('f_wait_kick', true);
    },
    onBattleKick: function(kickName) {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller'),
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            choiceCmp = Ext.getCmp('battle-choice'),
            headerCmp = Ext.getCmp('battle-header');
        headerCmp.setBlocked(true);
        me.animateKickChoice(kickName, function() {
            setTimeout(function() {
                if (!me.f_enemy_kick && !me.f_start_round_complete) {
                    rollerCmp.waitEnemyTurn(true);
                }
            }, 500);
        });
    },
    //     ,      
    onBattleUserKick: function(kickName) {
        var me = this,
            choiceCmp = Ext.getCmp('battle-choice');
        if (me.f_user_kick) {
            return;
        }
        //     
        me.setFlag('f_user_kick', true);
        if (!me.f_wait_kick) {
            choiceCmp.setMyChoice(kickName);
        }
        me.completeRoundOnKick();
    },
    onBattleEnemyKick: function(kickName) {
        var me = this,
            choiceCmp = Ext.getCmp('battle-choice');
        if (me.f_enemy_kick) {
            return;
        }
        //     
        me.setFlag('f_enemy_kick', true);
        if (me.f_wait_kick && !me.f_kick_choice_animated) {
            me.on('kick_choice_animated', function() {
                choiceCmp.setEnemyChoice(kickName, function() {
                    me.setFlag('f_ekick_choice_animated', true);
                    me.fireEvent('ekick_choice_animated');
                });
            }, me, {
                single: true
            });
        } else {
            choiceCmp.setEnemyChoice(kickName, function() {
                me.setFlag('f_ekick_choice_animated', true);
                me.fireEvent('ekick_choice_animated');
            });
        }
        me.completeRoundOnKick();
    },
    onBattleLoadRound: function() {
        var me = this;
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  .. ');
        if (!me.f_start_round_complete) {
            if (me.f_wait_kick && !me.f_kick_choice_animated) {
                me.on('kick_choice_animated', function() {
                    me.completeRound();
                }, me, {
                    single: true
                });
            } else {
                me.completeRound();
            }
        }
    },
    onBattleRound: function() {
        var me = this;
        if (me.f_start_round_complete) /* && me.battle.state.live != "0"*/
        {
            //     
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  ..     -     ');
            me.setFlag('f_show_new_round', true);
        } else {
            me.showNewRound();
        }
    },
    showNewRound: function() {
        var me = this,
            user = me.getBattleUser(me.user.getBattleEkey()),
            rollerCmp = Ext.getCmp('battle-roller'),
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            headerCmp = Ext.getCmp('battle-header'),
            choiceCmp = Ext.getCmp('battle-choice');
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView   ');
        me.resetFlags();
        if (me.battle.state.live != "0") {
            //       
            rollerCmp.startAnimate();
            setTimeout(function() {
                rollerCmp.setState(me.battle.state);
                rollerCmp.stopAnimate(function() {
                    rollerCmp.disableBtn(false);
                    prepActsCmp.setDisabled(false);
                });
            }, 1000);
            //   
            prepActsCmp.setState(me.battle.state);
            prepActsCmp.actions_disabled = false;
            choiceCmp.clearChoice();
            //    
            headerCmp.setBlocked(false);
            //   ,    
            if (me.battle.state.can_item) {
                me.getQuickSlots().setDisabled(false);
            }
        } else {
            // 
            choiceCmp.clearChoice();
        }
        me.allies.sort();
        me.enemies.sort();
        me.updateEnemy();
        // 
        if (prepActsCmp.tooltip) {
            prepActsCmp.tooltip.close();
            prepActsCmp.tooltip = false;
        }
        if (rollerCmp.tooltip) {
            rollerCmp.tooltip.close();
            rollerCmp.tooltip = false;
        }
        me.applyMarks(me.marks);
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView     ' + me.battle.state.round);
        me.cur_round = me.battle.state.round;
        me.applyChangesOnNewRound();
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView   new_round');
        me.fireEvent('new_round', me, me.battle.state.round);
        me.animation.onBattleViewNewRound(me, me.battle.state.round);
        me.setFlag('f_show_new_round', undefined);
    },
    onBattleLoadFinish: function() {
        var me = this,
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            rollerCmp = Ext.getCmp('battle-roller'),
            quickSlots = me.getQuickSlots();
        if (rollerCmp) {
            if (rollerCmp.mouseOverTimeOut) {
                clearTimeout(rollerCmp.mouseOverTimeOut);
            }
            if (rollerCmp.marksInterval) {
                clearInterval(rollerCmp.marksInterval);
            }
            if (rollerCmp.tooltip) {
                rollerCmp.tooltip.close();
                rollerCmp.tooltip = false;
            }
        }
        if (prepActsCmp) {
            if (prepActsCmp.mouseOverTimeOut) {
                clearTimeout(me.mouseOverTimeOut);
            }
            if (prepActsCmp.marksInterval) {
                clearInterval(prepActsCmp.marksInterval);
            }
            if (prepActsCmp.actionInfo && prepActsCmp.actionInfo.close) {
                prepActsCmp.actionInfo.close();
            }
        }
        if (quickSlots.marksInterval) {
            clearInterval(quickSlots.marksInterval);
        }
    },
    onBattleFinish: function() {
        var me = this;
        if (me.cur_round != me.battle.state.round) {
            //    ,         
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView    .   .  - ' + me.cur_round + ',  - ' + me.battle.state.round);
            me.on('new_round', function() {
                me.finishAnimationAndShowResult();
            }, me, {
                single: true
            });
        } else if (me.f_start_round_complete) {
            //     
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView    .   -    ');
            me.setFlag('f_show_result', true);
        } else {
            me.finishAnimationAndShowResult();
        }
    },
    onNotActiveBattle: function() {
        var me = this,
            viewport = me.app.getController('Viewport');
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  .   ');
        if (viewport.layout != 'main') {
            viewport.setLayout('main', function() {
                // TODO -     ,      
                // 
                var userInfo = Ext.getCmp('tech-info'),
                    enemyInfo = Ext.getCmp('header-right');
                userInfo.setUser(me.user);
                enemyInfo.removeCls('in-battle');
                me.getQuickSlots().setDisabled(false);
                me.inventory.unlockNewItemsUpdate();
                me.app.getController('Location').unmaskLocation();
            });
        } else {
            me.app.getController('Location').unmaskLocation();
        }
    },
    onBattleItem: function() {
        var me = this;
        me.getQuickSlots().setDisabled(!me.battle.state.can_item);
    },
    onBattleExit: function() {
        var me = this,
            viewport = me.app.getController('Viewport'),
            location = me.app.getController('Location'),
            userInfo = Ext.getCmp('tech-info'),
            enemyInfo = Ext.getCmp('header-right'),
            headerCmp = Ext.getCmp('battle-header');
        headerCmp.setBlocked(true);
        location.maskLocation(function() {
            viewport.setLayout('main', function() {
                // 
                userInfo.setUser(me.user);
                userInfo.fireEvent('battlefinish', {
                    battle_result: me.battle.result
                });
                enemyInfo.removeCls('in-battle');
                me.getQuickSlots().setDisabled(false);
                me.inventory.unlockNewItemsUpdate();
            });
        }, {
            img: me.user.location.data.blob.image
        });
    },
    onBattleStateRefresh: function() {
        var me = this,
            prepActsCmp = Ext.getCmp('battle-prepacts');
        //  
        if (prepActsCmp && me.isRendered()) {
            prepActsCmp.setState(me.battle.state);
        }
    },
    completeRoundOnKick: function() {
        var me = this,
            enemy = me.getBattleEnemy();
        if (me.f_user_kick && (!enemy || me.f_enemy_kick)) {
            me.setFlag('f_start_round_complete', true);
            if (enemy && !me.f_ekick_choice_animated) {
                me.on('ekick_choice_animated', function() {
                    me.completeRound();
                }, me, {
                    single: true
                });
            } else if (me.f_wait_kick && !me.f_kick_choice_animated) {
                me.on('kick_choice_animated', function() {
                    me.completeRound();
                }, me, {
                    single: true
                });
            } else {
                me.completeRound();
            }
        }
    },
    completeRound: function() {
        var me = this,
            rollerCmp = Ext.getCmp('battle-roller'),
            prepActsCmp = Ext.getCmp('battle-prepacts'),
            headerCmp = Ext.getCmp('battle-header');
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView   ' + me.cur_round);
        rollerCmp.disableBtn(true);
        rollerCmp.waitEnemyTurn(false);
        rollerCmp.hidePointer();
        headerCmp.setBlocked(true);
        prepActsCmp.setDisabled(true);
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  ');
        try {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView    ');
            me.animation.refreshChoiceFromAnimation();
        } catch (e) {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView        ' + e);
        }
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView   ');
        me.waitBeforeAnimations(function() {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  kick1');
            me.animation.animateKick(1, function() {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  kick2');
                me.animation.animateKick(2, function() {
                    /*****/
                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  1');
                    me.animation.animateMyContinuing(function() {
                        /*****/
                        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  2');
                        me.animation.animateEnemyContinuing(function() {
                            /*****/
                            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  ');
                            me.animation.animateFinal(function() {
                                //   
                                try {
                                    /*****/
                                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView C ');
                                    me.syncChanges();
                                } catch (e) {
                                    /*****/
                                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView     ' + e);
                                }
                                /*****/
                                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView   ');
                                me.waitIfDied(function() {
                                    // ,   
                                    /*****/
                                    ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  ');
                                    if (me.f_show_result) {
                                        /*****/
                                        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  ');
                                        me.showResultView();
                                    } else if (me.f_show_new_round) {
                                        /*****/
                                        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView   ');
                                        me.showNewRound();
                                    } else {
                                        /*****/
                                        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  . ');
                                        me.resetFlags();
                                    }
                                });
                            });
                        });
                    });
                });
            });
        });
    },
    updateEnemy: function() {
        var me = this,
            enemyAvatarCmp = Ext.getCmp('battle-enemy-avatar'),
            enemyInfoCmp = Ext.getCmp('battle-enemy-info'),
            curEnemy = me.getBattleEnemy(),
            newEnemyEkey = me.battle.state.enemy,
            enemy;
        if (me.battle.state.live != "0") {
            if (!curEnemy || curEnemy.getBattleEkey() != newEnemyEkey) {
                enemy = me.getBattleUser(newEnemyEkey);
                enemyAvatarCmp.setUser(enemy);
                if (enemy) {
                    enemyInfoCmp.setUser(enemy);
                    enemyInfoCmp.show();
                    if (!curEnemy || curEnemy.getBattleEkey() != newEnemyEkey) {
                        me.showHint('enemy_changed');
                    }
                } else {
                    enemyInfoCmp.hide();
                }
            }
        } else {
            enemyAvatarCmp.setUser(null);
            enemyInfoCmp.hide();
        }
    },
    animateKickChoice: function(kickName, callback) {
        var me = this,
            choiceCmp = Ext.getCmp('battle-choice'),
            _finish = function() {
                choiceCmp.setMyChoice(kickName);
                delete me.kick_choice_animating;
                me.setFlag('f_kick_choice_animated', true);
                callback();
                me.fireEvent('kick_choice_animated');
            };
        if (!me.kick_choice_animating) {
            me.kick_choice_animating = true;
            var dom = undefined;
            try {
                dom = Ext.select('[role=' + kickName + ']').elements[0];
            } catch (e) {
                me.log('warn', 'kickName  ' + kickName + "   !");
                dom = undefined;
            }
            if (!dom) {
                _finish();
                return;
            }
            var el = Ext.get(dom),
                img = el.down('.image'),
                position = img.getXY(),
                container = me.getBattleContainer().down('#battle-central');
            position[0] -= container.getX();
            position[1] -= container.getY();
            var animEl = container.el.insertHtml('beforeEnd', '<div class="image-animate" style="' + 'top:' + position[1] + 'px;' + 'left:' + position[0] + 'px;' + 'background-image:' + Ext.String.htmlEncode(img.dom.style.backgroundImage) + '"></div>', true);
            el.down('.image').setStyle('opacity', 0);
            animEl.animate({
                to: {
                    top: 216,
                    left: 122,
                    opacity: ExGods.ref('constants|bat_anim_choice1_opacity').value
                },
                duration: ExGods.ref('constants|bat_anim_choice1_dur').value,
                callback: function() {
                    animEl.remove();
                    _finish();
                }
            });
        }
    },
    resetFlags: function() {
        var me = this;
        me.setFlag('f_start_round_complete', undefined);
        me.setFlag('f_wait_kick', undefined);
        me.setFlag('f_kick_choice_animated', undefined);
        me.setFlag('f_ekick_choice_animated', undefined);
        me.setFlag('f_user_kick', undefined);
        me.setFlag('f_enemy_kick', undefined);
        me.setFlag('f_show_new_round', undefined);
        me.setFlag('f_show_result', undefined);
    },
    setFlag: function(f, v) {
        this.log(f + ' = ' + v);
        this[f] = v;
    },
    waitBeforeAnimations: function(callback) {
        var me = this;
        setTimeout(function() {
            callback();
        }, ExGods.ref('constants|bat_anim_delay_before_start').value);
    },
    waitIfDied: function(callback) {
        var me = this,
            user = me.getBattleUser(me.user.getBattleEkey()),
            enemy = me.getBattleEnemy();
        //       - ,         
        if (!user.data.battle.live || (enemy && !enemy.data.battle.live)) {
            setTimeout(function() {
                callback();
            }, 1500);
        } else {
            callback();
        }
    },
    /**
     *     
     */
    onAfterAnimation: function(anim) {
        var me = this,
            effect, u,
            _applyEffect = function(u, data, effect) {
                var timed = Ext.clone(u.data.timed),
                    aura = Ext.clone(u.data.aura),
                    stats = Ext.clone(u.data.stats),
                    battle = Ext.clone(u.data.battle);
                Ext.Array.each(effect, function(e) {
                    if (e.stat) {
                        timed[e.stat][0] = e.rest;
                        timed[e.stat][1] = e.max;
                    }
                    if (e.aura) {
                        //      
                        var found, changes, auraInfo;
                        if (me.changes[u.data.battle.ekey]) {
                            changes = me.changes[u.data.battle.ekey][me.changes[u.data.battle.ekey].length - 1];
                            if (changes.aura) {
                                for (var j = 0; j < changes.aura.length && !found; j++) {
                                    if (changes.aura[j][0] == e.aura) {
                                        found = true;
                                        aura = changes.aura;
                                        //      .    -  
                                        auraInfo = ExGods.ref('battle_aura|' + e.aura);
                                        if (auraInfo && auraInfo.params.stats) {
                                            Ext.Array.each(auraInfo.params.stats, function(s) {
                                                stats.stats[s.stat] = changes.stats.stats[s.stat];
                                            });
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (e.die) {
                        battle.live = 0;
                    }
                });
                u.set({
                    timed: timed,
                    aura: aura,
                    stats: stats,
                    battle: battle
                });
                Ext.getCmp('battle-roller').setState();
            };
        //       
        if (anim.data.effect) {
            if (anim.data.effect.u || anim.data.effect.u1) {
                effect = anim.data.effect.u || anim.data.effect.u1;
                if (anim.source == 'me') {
                    u = me.getBattleUser(me.user.getBattleEkey());
                } else if (anim.source == 'enemy') {
                    u = me.getBattleEnemy();
                }
                if (u) {
                    _applyEffect(u, me.battle.list.getByKey(u.data.battle.ekey), effect);
                }
            }
            if (anim.data.effect.u2) {
                effect = anim.data.effect.u2;
                if (anim.dest == 'me') {
                    u = me.getBattleUser(me.user.getBattleEkey());
                } else if (anim.dest == 'enemy') {
                    u = me.getBattleEnemy();
                }
                if (u) {
                    _applyEffect(u, me.battle.list.getByKey(u.data.battle.ekey), effect);
                }
            }
        }
        if (anim.enemy_hint && anim.enemy_anim) {
            ExGods.app.getHintsController().showHints(anim.enemy_hint);
        }
        if (anim.self_hint && anim.self_anim) {
            ExGods.app.getHintsController().showHints(anim.self_hint);
        }
    },
    showHint: function(key) {
        var hint = this.battle.hints[key];
        if (hint)  {
            ExGods.app.getHintsController().showHints(hint);
        }
        
    },
    getResources: function() {
        var me = this,
            images,
            shapes = [
                'battle_die_shape',
                'no_enemy_shape'
            ];
        images = [
            '/battle/roller/start.png',
            '/battle/roller/loop.png',
            '/battle/roller/finish.png',
            '/battle/frm_flash.png'
        ];
        Ext.Array.each(shapes, function(key) {
            var shape = ExGods.references.get('constants').get(key);
            if (shape) {
                info = ExGods.references.get('user_shape').getByKey(shape.value);
                if (info) {
                    images.push(info.battle);
                }
            }
        });
        me.allies.each(function(user) {
            images.push(user.getBattleAvatar());
            images.push(user.getThumb());
            if (user.data.aura) {
                for (var i = 0; i < user.data.aura.length; i++) {
                    images.push((ExGods.ref('battle_aura|' + user.data.aura[i][0]).params.images.small || ExGods.ref('battle_aura|' + user.data.aura[i][0]).params.images.icon));
                }
            }
        });
        me.enemies.each(function(user) {
            images.push(user.getBattleAvatar());
            images.push(user.getThumb());
            if (user.data.aura) {
                for (var i = 0; i < user.data.aura.length; i++) {
                    images.push((ExGods.ref('battle_aura|' + user.data.aura[i][0]).params.images.small || ExGods.ref('battle_aura|' + user.data.aura[i][0]).params.images.icon));
                }
            }
        });
        Ext.Array.each(me.battle.state.av_kick || [], function(item) {
            var info = ExGods.ref('battle_turn|' + item.name);
            if (info && info.desc && info.desc.images) {
                Ext.Object.each(info.desc.images, function(k, v) {
                    images.push(v);
                });
            }
        });
        Ext.Array.each(me.battle.state.av_prep || [], function(item) {
            var info = ExGods.ref('battle_prep|' + item.name);
            if (info && info.desc && info.desc.images) {
                Ext.Object.each(info.desc.images, function(k, v) {
                    images.push(v);
                });
                
            }
        });
        return {
            images: images
        };
    },
    /**
     *   .   ,   
     */
    sortMembers: function(o1, o2) {
        var me = this,
            _pairIndex = function(obj) {
                var index = 0;
                for (var key in me.battle.pairs) {
                    if (me.battle.pairs[key]) {
                        if (key == obj.getBattleEkey() || me.battle.pairs[key] == obj.getBattleEkey()) {
                            return index;
                        }
                        index++;
                    }
                }
                if (!obj.isLiveInBattle()) {
                    return 1000;
                } else {
                    return index;
                }
            };
        return _pairIndex(o1) - _pairIndex(o2);
    }
});

/**
 *  
 */
Ext.define('ExGods.view.FramesAnim', {
    // cfg
    renderTo: null,
    images: [],
    frames: [],
    fps: 25,
    flipped: false,
    infinite: false,
    inProgress: false,
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        Ext.apply(me, config || {});
        me.init();
        me.onInit();
    },
    init: function() {
        var me = this,
            ct = Ext.get(me.renderTo);
        ct.insertHtml('beforeEnd', '<div class="frame ' + (me.flipped ? 'flip-h' : '') + '" style="background-repeat: no-repeat; position: absolute;"></div>');
        me.el = Ext.get(ct.down('.frame'));
        me.ctWidth = ct.getWidth();
        me.ctHeight = ct.getHeight();
    },
    start: function() {
        var me = this,
            intervalId;
        if (me.frames && me.frames.length && me.images && me.images.length) {
            me.inProgress = true;
            me.el.applyStyles({
                backgroundImage: 'url(' + (/^http/.test(me.images[0]) ? me.images[0] : IMAGE_URL + me.images[0]) + ')'
            });
            me.frameIndex = 0;
            me.showFrame(me.frameIndex);
            intervalId = setInterval(function() {
                if (me.frames[++me.frameIndex]) {
                    me.showFrame(me.frameIndex);
                } else if (me.infinite) {
                    me.frameIndex = 0;
                } else {
                    clearInterval(intervalId);
                    me.finish();
                }
            }, 1000 / me.fps);
            me.onStart();
        } else {
            me.onStart();
            me.finish();
        }
    },
    finish: function() {
        var me = this;
        me.inProgress = false;
        me.el.remove();
        delete me.el;
        me.onFinish();
    },
    showFrame: function(index) {
        var me = this,
            frameData = me.frames[index],
            prevData = me.frames[index - 1],
            styles = {};
        //     
        if (!prevData || frameData[2] != prevData[2] || frameData[3] != prevData[3]) {
            styles = {
                width: frameData[2] + 'px',
                height: frameData[3] + 'px'
            };
        }
        //    
        if (!prevData || frameData[5] != prevData[5] || frameData[6] != prevData[6]) {
            styles.top = (-frameData[6]) + 'px';
            if (me.flipped) {
                styles.right = (-frameData[5]) + 'px';
            } else {
                styles.left = (-frameData[5]) + 'px';
            }
        }
        me.onProgress(index);
        styles['background-position'] = (-frameData[0]) + 'px ' + (-frameData[1]) + 'px';
        if (me.el && me.el.dom) {
            me.el.applyStyles(styles);
        }
    },
    onInit: function() {},
    //
    onStart: function() {},
    //
    onFinish: function() {},
    //
    /**
     *     
     */
    onProgress: function(index) {}
});
//

/**
 *   
 */
Ext.define('ExGods.view.battle_new.AnimationPanel', {
    extend: Ext.Component,
    side: 'left',
    // 'left' or 'right'
    cls: 'battle-anim-panel',
    /**
     * @cfg {Array}  ,     . , ["mp", "hp"]
     */
    hiddenEffects: [],
    initComponent: function() {
        var me = this;
        me.style = {
            position: 'absolute',
            top: 0,
            height: '239px',
            width: '217px'
        };
        me.style[me.side] = '0';
        me.renderTpl = [
            '<div class="anim-panel" style="width:217px; height:239px; position: relative;"></div>',
            '<div class="text-img" style="top: ' + ExGods.ref('constants|bat_anim_text_y_from').value + 'px' + '"></div>'
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
    },
    /**
     *  
     */
    runAnim: function(anim, target, callback) {
        var me = this,
            el,
            started = 0,
            stopped = 0,
            _afterAnim = function() {
                if (++stopped == started) {
                    callback();
                }
            };
        if (anim.type != 'effect') {
            started++;
            me.runImageAnimation(anim, target, function() {
                _afterAnim();
            });
            if (anim.data.effect) {
                started++;
                me.runEffectAnimation(target == 'self' ? anim.data.effect.u || anim.data.effect.u1 : anim.data.effect.u2, anim.data.result, function() {
                    _afterAnim();
                });
            }
        } else {
            started++;
            me.runEffectAnimation(target == 'self' ? anim.data.effect.u || anim.data.effect.u1 : anim.data.effect.u2, anim.data.result, function() {
                _afterAnim();
            });
        }
        if (!started) {
            callback();
        }
    },
    /**
     * @private
     */
    runImageAnimation: function(anim, target, callback) {
        var me = this,
            ss, bm, animData, animName,
            animationOn = typeof ExGods.app.user.getSetting('animation_on') == 'undefined' || ExGods.app.user.getSetting('animation_on') == "1",
            _animateFrame = function(img) {
                var time1 = ExGods.ref('constants|bat_anim_frame_time1').value,
                    time2 = ExGods.ref('constants|bat_anim_frame_time2').value,
                    getEl = function() {
                        return me.side == 'left' ? Ext.select('#battle-avatar .avatar-frame') : Ext.select('#battle-enemy-avatar .avatar-frame');
                    },
                    el = getEl();
                if (!el)  {
                    return;
                }
                
                el.applyStyles({
                    'background-image': 'url(' + IMAGE_URL + anim.images.aframe + ')'
                });
                el.animate({
                    duration: time1,
                    to: {
                        opacity: 1
                    },
                    callback: function() {
                        setTimeout(function() {
                            el = getEl();
                            if (!el)  {
                                return;
                            }
                            
                            el.animate({
                                duration: time2,
                                to: {
                                    opacity: 0
                                }
                            });
                        }, 1500 - time1 - time2);
                    }
                });
            },
            _animateTextImg = function(img) {
                var getEl = function() {
                        try {
                            return Ext.get(me.getEl().select('.text-img').item(0));
                        } catch (err) {}
                    };
                var el = getEl();
                if (el) {
                    el.applyStyles({
                        'background-image': 'url(' + IMAGE_URL + img + ')',
                        'opacity': 0
                    });
                    el.animate({
                        duration: ExGods.ref('constants|bat_anim_text_time1').value,
                        from: {
                            opacity: 0,
                            top: ExGods.ref('constants|bat_anim_text_y_from').value + 'px'
                        },
                        to: {
                            opacity: 1,
                            top: ExGods.ref('constants|bat_anim_text_y_to').value + 'px'
                        },
                        callback: function() {
                            el = getEl();
                            if (!el)  {
                                return;
                            }
                            
                            el.animate({
                                duration: ExGods.ref('constants|bat_anim_text_time2').value,
                                from: {
                                    opacity: 1
                                },
                                to: {
                                    opacity: 0
                                }
                            });
                        }
                    });
                }
            };
        animName = target == 'self' ? anim.self_anim : anim.enemy_anim;
        animTextImg = target == 'self' ? anim.self_text_img : anim.enemy_text_img;
        animData = ExGods.ref('battle_animations|' + animName);
        if (animData) {
            var spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                    images: animData.images,
                    frames: animData.frames,
                    renderTo: me.getEl().down('.anim-panel'),
                    flipped: (me.side == 'left' && animData.mirror_left || me.side == 'right' && animData.mirror_right)
                });
            if (animationOn) {
                spriteSheet.start();
            }
            if (anim.images && anim.images.aframe) {
                _animateFrame(anim.images.aframe);
            }
            if (animTextImg) {
                _animateTextImg(animTextImg);
            }
            setTimeout(function() {
                callback();
            }, 1500);
        } else // ,     1.5 
        {
            callback();
        }
    },
    runEffectAnimation: function(effect, result, callback) {
        var me = this,
            started = 0,
            _plusOrMinusColor = function(effect) {
                var arithmetic, parametr,
                    indent = '0px';
                if (result == 'add' || effect.make < 0)  {
                    arithmetic = 'plus';
                }
                else {
                    arithmetic = 'minus';
                    indent = '-18px';
                }
                if (effect.stat == 'hp')  {
                    parametr = 'health';
                }
                else if (effect.stat == 'mp') {
                    parametr = 'mana';
                    indent = '-36px';
                } else  {
                    parametr = 'shield';
                }
                
                return {
                    arith: arithmetic,
                    param: parametr,
                    indent: indent
                };
            },
            _showEffect = function(e, callback) {
                var value = Math.abs(e.make || 0);
                var pomColor = _plusOrMinusColor(e);
                if (!value || Ext.Array.indexOf(me.hiddenEffects, e.stat) != -1) {
                    callback();
                    return;
                }
                var div_element = me.getEl().insertHtml('beforeEnd', ExGods.util.Sprite.printSprite(value, IMAGE_URL + '/battle/numbers/num.png', {
                        width: 15,
                        height: 24,
                        indent: pomColor.indent,
                        cls: 'battle_numbers ' + pomColor.arith + ' ' + pomColor.param
                    }));
                Ext.get(div_element).animate({
                    duration: 1800,
                    to: {
                        top: 40,
                        opacity: 1
                    }
                }).animate({
                    duration: 200,
                    to: {
                        opacity: 0
                    },
                    listeners: {
                        afteranimate: function() {
                            if (this.target && this.target.target) {
                                this.target.target.remove();
                            }
                        }
                    }
                });
                setTimeout(function() {
                    callback();
                }, 500);
            },
            _afterEffectShow = function() {
                if (--started == 0) {
                    callback();
                } else {
                    _showEffect(queue.shift(), _afterEffectShow);
                }
            },
            queue = [];
        Ext.Array.each(effect, function(e) {
            if (e.stat) {
                if (started++) {
                    queue.push(e);
                } else {
                    _showEffect(e, _afterEffectShow);
                }
            }
        });
        if (!started) {
            callback();
        }
    },
    /**
     *    
     */
    testSpriteSheet: function(images, frames) {
        var me = this,
            spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                images: images,
                frames: frames,
                renderTo: me.getEl().down('.anim-panel'),
                flipped: me.side != 'left'
            });
        spriteSheet.start();
    },
    /**
     *   
     *       .
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.controller.battle.Animation', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'BattleAnimation:'
    },
    refs: [
        {
            ref: 'battleContainer',
            selector: '#battle-container'
        }
    ],
    views: [
        'ExGods.view.battle_new.AnimationPanel'
    ],
    init: function() {
        var me = this;
        me.app.getChatConnection().on({
            command_battle_log: function(cn, message) {
                if (me.enabled) {
                    me.onBattleLogMessage(message.body.data);
                } else {
                    me.hasUnprocessLogMessages.push(message.body.data);
                }
            },
            scope: me
        });
        me.control({
            '#battle-container': {
                render: me.onContainerRender,
                destroy: me.onContainerDestroy
            },
            '#battle-header': {
                showbattle: me.onBattleView,
                showgroup: me.onGroupView
            },
            'battle_avatar': {
                viewmodechange: me.onBattleAvatarModeChange
            }
        });
        me.battle = me.app.getController('battle.Battle');
        me.battleView = me.app.getController('battle.BattleView');
        me.battleView.onRender(function() {
            me.onBattleViewRender();
        });
        me.battleView.onDestroy(function() {
            me.onBattleViewDestroy();
        });
        me.hasUnprocessLogMessages = [];
        me.resurections = [];
        me.callParent();
    },
    onBattleViewRender: function() {
        var me = this;
        me.startWork(true);
    },
    onBattleViewDestroy: function() {
        var me = this;
        me.startWork(false);
    },
    startWork: function(enabled) {
        var me = this;
        me.resurections = [];
        me.kick_animations = [];
        me.continuing_animations = [];
        me.final_animations = [];
        if (me.enabled !== enabled) {
            me.enabled = enabled;
            if (me.enabled) {
                if (me.hasUnprocessLogMessages.length) {
                    setTimeout(function() {
                        for (var i = 0; i < me.hasUnprocessLogMessages.length; i++) {
                            me.onBattleLogMessage(me.hasUnprocessLogMessages[i]);
                        }
                        me.hasUnprocessLogMessages = [];
                    }, ExGods.ref('constants|bat_anim_first_anim_delay').value);
                }
            }
        }
    },
    onBattleViewNewRound: function(view, round) {
        var me = this,
            user = me.app.getController('battle.BattleView').getBattleUser(me.user.getBattleEkey()),
            enemy = me.app.getController('battle.BattleView').getBattleEnemy();
        me.cur_round = round;
        me.kick_animations = [];
        me.continuing_animations = [];
        me.final_animations = [];
        //   
        if (me.resurections.length) {
            me.animateResurections();
        }
        //  ,     ,     
        if (me.next_round_animations.length) {
            Ext.Array.each(me.next_round_animations, function(anim) {
                me.setAnimationSourceDestInfo(anim);
                if (anim.source == 'me' || anim.source == 'enemy' || anim.dest == 'me' || anim.dest == 'enemy') {
                    me.addAnimation(anim);
                }
            });
            me.next_round_animations = [];
        }
        ExGods.Resources.load(me);
    },
    onBattleLogMessage: function(data) {
        var me = this,
            anim;
        anim = me.processLogMessage(data);
        if (anim) {
            me.loadAnimationResources(anim);
            if (anim.data.result == 'resurect') {
                me.resurections.push(anim);
            } else if (me.battle.state.round != me.cur_round) {
                me.next_round_animations.push(anim);
            } else {
                if (anim.source == 'me' || anim.source == 'enemy' || anim.dest == 'me' || anim.dest == 'enemy') {
                    if (anim.type == 'kick') {
                        me.kick_animations.push(anim);
                    } else if (anim.type == 'continuing') {
                        me.continuing_animations.push(anim);
                    } else {
                        if (me.kick_animations.length && !(anim.type == 'effect' && anim.data.type == 'cost')) {
                            me.final_animations.push(anim);
                        } else {
                            me.addAnimation(anim);
                        }
                    }
                }
            }
        }
    },
    /**
     *   /  
     */
    setAnimationSourceDestInfo: function(anim) {
        var me = this,
            user = me.app.getController('battle.BattleView').getBattleUser(me.user.getBattleEkey()),
            enemy = me.app.getController('battle.BattleView').getBattleEnemy();
        if (anim.data.u) {
            if (anim.data.u[2] == user.getBattleEkey()) {
                anim.source = 'me';
                anim.dest = 'enemy';
            } else if (enemy && anim.data.u[2] == enemy.getBattleEkey()) {
                anim.source = 'enemy';
                anim.dest = 'me';
            } else {}
        } else // ignore
        {
            if (anim.data.u1 && anim.data.u1[2] == user.getBattleEkey()) {
                anim.source = 'me';
                if (anim.data.u2[2] == user.getBattleEkey()) {
                    anim.dest = 'me';
                } else if (enemy && anim.data.u2[2] == enemy.getBattleEkey()) {
                    anim.dest = 'enemy';
                } else {
                    anim.dest = 'other';
                }
            } else if (anim.data.u1 && enemy && anim.data.u1[2] == enemy.getBattleEkey()) {
                anim.source = 'enemy';
                if (anim.data.u2[2] == enemy.getBattleEkey()) {
                    anim.dest = 'enemy';
                } else if (anim.data.u2[2] == user.getBattleEkey()) {
                    anim.dest = 'me';
                } else {
                    anim.dest = 'other';
                }
            } else {
                anim.source = 'other';
                if (anim.data.u2) {
                    if (anim.data.u2[2] == user.getBattleEkey()) {
                        anim.dest = 'me';
                    } else if (enemy && anim.data.u2[2] == enemy.getBattleEkey()) {
                        anim.dest = 'enemy';
                    } else {
                        anim.dest = 'other';
                    }
                } else {
                    anim.dest = 'other';
                }
            }
        }
    },
    processLogMessage: function(data) {
        var me = this,
            anim = {
                data: data,
                images: {}
            },
            ref_data;
        me.setAnimationSourceDestInfo(anim);
        if (data.turn_name) {
            anim.type = 'kick';
        } else if (data.prepare_name) {
            anim.type = 'instant';
        } else if (data.action_id) {
            anim.type = 'action';
        } else if (data.continuing_id) {
            anim.type = 'continuing';
        } else if (data.effect) {
            anim.type = 'effect';
        }
        if (anim.type == 'kick') {
            ref_data = ExGods.ref('battle_turn|' + anim.data.turn_name).desc || {};
            anim.images = ref_data.images;
        } else if (anim.type == 'instant') {
            ref_data = ExGods.ref('battle_prep|' + data.prepare_name) || {};
            anim.images = ref_data.desc ? ref_data.desc.images : {};
            ref_data = ref_data.animation || {};
        } else if (anim.type == 'action') {
            ref_data = ExGods.ref('battle_actions|' + data.action_id).desc || {};
            anim.images = {
                aframe: ref_data.aframe
            };
        } else if (anim.type == 'continuing') {
            ref_data = ExGods.ref('battle_continuing|' + data.continuing_id).desc || {};
            anim.images = {
                aframe: ref_data.animation_frame
            };
        }
        if (ref_data) {
            if (ref_data.a_self && ref_data.a_self[anim.data.result]) {
                anim.self_anim = ref_data.a_self[anim.data.result].name;
                anim.self_text_img = ref_data.a_self[anim.data.result].image;
                anim.self_hint = ref_data.a_self[anim.data.result].hint;
            }
            if (ref_data.a_enemy && ref_data.a_enemy[anim.data.result]) {
                anim.enemy_anim = ref_data.a_enemy[anim.data.result].name;
                anim.enemy_text_img = ref_data.a_enemy[anim.data.result].image;
                anim.enemy_hint = ref_data.a_enemy[anim.data.result].hint;
            }
        }
        //      (data.u1 == data.u2)  u2  
        if (anim.data.effect && anim.data.effect.u2 && anim.data.u1 && anim.data.u2 && anim.data.u1[2] == anim.data.u2[2]) {
            anim.data.effect.u1 = anim.data.effect.u2;
            anim.data.effect.u2 = undefined;
        }
        return anim;
    },
    /**
     * @private   
     */
    loadAnimationResources: function(anim, callback) {
        var me = this,
            images = [],
            data,
            animOn = ExGods.app.user.getSetting('animation_on'),
            callbackInner = function() {
                anim.resource_loaded = true;
                //  ,    
                if (callback) {
                    callback();
                }
            };
        if (typeof animOn == 'undefined' || animOn == "1") {
            //     
            if (anim.self_anim) {
                data = ExGods.ref('battle_animations|' + anim.self_anim);
                images = images.concat(data.images);
                images.push(anim.self_text_img);
            }
            if (anim.enemy_anim) {
                data = ExGods.ref('battle_animations|' + anim.enemy_anim);
                images = images.concat(data.images);
                images.push(anim.enemy_text_img);
            }
            ExGods.Resources.loadImages(images, callbackInner);
        } else {
            callbackInner();
        }
    },
    /**
     * @private ,     .
     *    callback  1 
     */
    checkAnimationResources: function(anim, callback) {
        var me = this,
            times = 0,
            maxTimes = 10,
            interval;
        callback = callback || Ext.emptyFn;
        if (anim.resource_loaded) {
            callback();
        } else {
            interval = setInterval(function() {
                if (anim.resource_loaded || ++times >= 10) {
                    callback();
                    clearInterval(interval);
                }
            }, 100);
        }
    },
    /**
     *       
     */
    addAnimation: function(anim) {
        var me = this;
        /***/
        me.log('     ' + anim.type, anim);
        me.queue = me.queue || [];
        if (Ext.isArray(anim)) {
            me.queue = me.queue.concat(anim);
        } else {
            me.queue.push(anim);
        }
        me.start();
    },
    /**
     *  
     */
    start: function() {
        var me = this,
            _runAnim = function() {
                if (me.queue.length) {
                    var anim = me.queue.shift();
                    me.checkAnimationResources(anim, function() {
                        me.runAnim(anim, function() {
                            try {
                                /***/
                                me.fireEvent('afteranim', anim);
                                me.battleView.onAfterAnimation(anim);
                            } catch (e) {
                                /***/
                                me.log('error', 'afteranim event error ', e);
                            }
                            if (anim.callback) {
                                try {
                                    anim.callback();
                                } catch (e) {
                                    /***/
                                    me.log('error', 'anim callback error ', e);
                                }
                            }
                            /****/
                            me.log('  ' + anim.type, anim);
                            _runAnim();
                        });
                    });
                } else {
                    /***/
                    me.log('  ');
                    delete me.started;
                    me.fireEvent('animation_finish');
                }
            };
        if (!me.started) {
            /***/
            me.log('  ');
            me.started = true;
            _runAnim();
        }
    },
    /**
     * @private
     */
    runAnim: function(anim, callback) {
        var me = this,
            ref_data,
            started = 0,
            _afterAnim = function() {
                if (--started > 0) {} else //
                {
                    callback();
                }
            };
        /***/
        me.log('  ' + anim.type, anim);
        callback = callback || Ext.emptyFn;
        if (anim.type == 'effect') {
            if ((anim.data.effect.u || anim.data.effect.u1) && me.canShowAnimation('self', anim)) {
                if (anim.source == 'me') {
                    me.leftPanel.runAnim(anim, 'self', _afterAnim);
                    started++;
                } else if (anim.source == 'enemy') {
                    me.rightPanel.runAnim(anim, 'self', _afterAnim);
                    started++;
                }
            }
            if (anim.data.effect.u2 && me.canShowAnimation('enemy', anim)) {
                if (anim.dest == 'me') {
                    me.leftPanel.runAnim(anim, 'enemy', _afterAnim);
                    started++;
                } else if (anim.dest == 'enemy') {
                    me.rightPanel.runAnim(anim, 'enemy', _afterAnim);
                    started++;
                }
            }
        } else {
            if (anim.self_anim && me.canShowAnimation('self', anim)) {
                if (anim.source == 'me') {
                    me.leftPanel.runAnim(anim, 'self', _afterAnim);
                    started++;
                } else if (anim.source == 'enemy') {
                    me.rightPanel.runAnim(anim, 'self', _afterAnim);
                    started++;
                }
            }
            if (anim.enemy_anim && me.canShowAnimation('enemy', anim)) {
                if (anim.dest == 'me') {
                    me.leftPanel.runAnim(anim, 'enemy', _afterAnim);
                    started++;
                } else if (anim.dest == 'enemy') {
                    me.rightPanel.runAnim(anim, 'enemy', _afterAnim);
                    started++;
                }
            }
        }
        if (!started) {
            callback();
        }
    },
    onContainerRender: function() {
        var me = this,
            container = me.getBattleContainer();
        /****/
        me.log('   -    ');
        me.leftPanel = Ext.create('ExGods.view.battle_new.AnimationPanel', {
            autoShow: false,
            renderTo: container.el
        });
        ExGods.Resources.load(me.leftPanel, function() {
            me.leftPanel.show();
        });
        me.rightPanel = Ext.create('ExGods.view.battle_new.AnimationPanel', {
            renderTo: container.el,
            side: 'right',
            autoShow: false,
            hiddenEffects: [
                'mp'
            ]
        });
        ExGods.Resources.load(me.rightPanel, function() {
            me.rightPanel.show();
        });
        me.next_round_animations = [];
        me.kick_animations = [];
        me.continuing_animations = [];
        me.cur_round = me.battle.state.round;
    },
    onContainerDestroy: function() {
        var me = this;
        /****/
        me.log('  .   ');
        me.leftPanel.destroy();
        me.rightPanel.destroy();
    },
    onBattleAvatarModeChange: function(avatar, isInfoMode) {
        var me = this,
            panel;
        /****/
        me.log('    - /  ');
        if (avatar.isEnemy) {
            panel = me.rightPanel;
        } else {
            panel = me.leftPanel;
        }
        if (isInfoMode) {
            panel.hide();
        } else {
            panel.show();
        }
    },
    onBattleView: function() {
        var me = this,
            uAva = Ext.getCmp('battle-avatar'),
            eAva = Ext.getCmp('battle-enemy-avatar');
        if (!uAva.isInfo) {
            me.leftPanel.show();
        }
        if (!eAva.isInfo) {
            me.rightPanel.show();
        }
    },
    onGroupView: function() {
        var me = this;
        me.leftPanel.hide();
        me.rightPanel.hide();
    },
    /**
     *  
     */
    animateResurections: function() {
        var me = this,
            enemy = me.battleView.getBattleEnemy(),
            u_ekey = me.user.getBattleEkey(),
            e_ekey = enemy ? enemy.getBattleEkey() : null,
            animated = [],
            anim;
        Ext.Array.each(me.resurections, function(anim) {
            me.setAnimationSourceDestInfo(anim);
            if (anim.source == 'me' || anim.source == 'enemy') {
                me.addAnimation(anim);
                animated.push(anim);
            }
        });
        me.resurections = Ext.Array.difference(me.resurections, animated);
    },
    /**
     *   
     * @param index - 1  2 
     */
    animateKick: function(index, callback) {
        var me = this,
            myKickHasNegativeMake = false;
        Ext.Array.each(me.kick_animations, function(a) {
            if (a.soruce == 'me' && a.data.effect && a.data.effect.u1) {
                Ext.Array.each(a.data.effect.u1, function(effect) {
                    if (effect.make < 0) {
                        myKickHasNegativeMake = true;
                    }
                });
            }
        });
        //   :
        //   ,     make  ,  " ",  " "
        if (index == 1 && !myKickHasNegativeMake || index == 2 && myKickHasNegativeMake) {
            me.animateMyKick(callback);
        } else {
            me.animateEnemyKick(callback);
        }
    },
    animateMyKick: function(callback) {
        var me = this,
            anims = [],
            started = 0;
        /***/
        me.log('  ');
        try {
            Ext.Array.each(me.kick_animations, function(a) {
                if (a.source == 'me') {
                    anims.push(a);
                }
            });
            if (anims.length) {
                me.animChoice(anims[0], function() {
                    Ext.Array.each(anims, function(anim) {
                        anim.callback = function() {
                            if (--started == 0) {
                                callback();
                            }
                        };
                        started++;
                        me.addAnimation(anim);
                    });
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', '    ', e);
            callback();
        }
    },
    animateEnemyKick: function(callback) {
        var me = this,
            anims = [],
            started = 0;
        /***/
        me.log('  ');
        try {
            Ext.Array.each(me.kick_animations, function(a) {
                if (a.source == 'enemy') {
                    anims.push(a);
                }
            });
            if (anims.length) {
                me.animChoice(anims[0], function() {
                    Ext.Array.each(anims, function(anim) {
                        anim.callback = function() {
                            if (--started == 0) {
                                callback();
                            }
                        };
                        started++;
                        me.addAnimation(anim);
                    });
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', '    ', e);
            callback();
        }
    },
    animateMyContinuing: function(callback) {
        var me = this,
            anims = [],
            started = 0;
        /***/
        me.log('  ');
        try {
            Ext.Array.each(me.continuing_animations, function(a) {
                if (a.dest == 'me') {
                    anims.push(a);
                }
            });
            if (anims.length) {
                Ext.Array.each(anims, function(anim) {
                    anim.callback = function() {
                        if (--started == 0) {
                            callback();
                        }
                    };
                    started++;
                    me.addAnimation(anim);
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', '    ', e);
            callback();
        }
    },
    animateEnemyContinuing: function(callback) {
        var me = this,
            anims = [],
            started = 0;
        /***/
        me.log('  ');
        try {
            Ext.Array.each(me.continuing_animations, function(a) {
                if (a.dest == 'enemy') {
                    anims.push(a);
                }
            });
            if (anims.length) {
                Ext.Array.each(anims, function(anim) {
                    anim.callback = function() {
                        if (--started == 0) {
                            callback();
                        }
                    };
                    started++;
                    me.addAnimation(anim);
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', '    ', e);
            callback();
        }
    },
    animateFinal: function(callback) {
        var me = this,
            started = 0;
        /***/
        me.log('   ');
        try {
            if (me.final_animations.length) {
                Ext.Array.each(me.final_animations, function(anim) {
                    anim.callback = function() {
                        if (--started == 0) {
                            callback();
                        }
                    };
                    started++;
                    me.addAnimation(anim);
                });
            } else {
                callback();
            }
        } catch (e) {
            /***/
            me.log('error', '    ', e);
            callback();
        }
    },
    //      
    refreshChoiceFromAnimation: function() {
        var me = this,
            choiceCmpEl = Ext.getCmp('battle-choice').getEl(),
            myKickAnimation, enemyKickAnimation, myKickEl, enemyKickEl, kickInfo;
        Ext.Array.each(me.kick_animations, function(a) {
            if (!myKickAnimation && a.source == 'me') {
                myKickAnimation = a;
            } else if (!enemyKickAnimation && a.source == "enemy") {
                enemyKickAnimation = a;
            }
        });
        if (choiceCmpEl) {
            if (myKickAnimation && myKickAnimation.data.turn_name) {
                myKickEl = choiceCmpEl.down('.my-kick');
                kickInfo = ExGods.ref('battle_turn|' + myKickAnimation.data.turn_name);
                if (kickInfo && myKickEl) {
                    myKickEl.setStyle('background-image', 'url(' + IMAGE_URL + kickInfo.desc.images['active'] + ')');
                }
            }
            if (enemyKickAnimation && enemyKickAnimation.data.turn_name) {
                enemyKickEl = choiceCmpEl.down('.enemy-kick');
                kickInfo = ExGods.ref('battle_turn|' + enemyKickAnimation.data.turn_name);
                if (kickInfo && enemyKickEl) {
                    enemyKickEl.setStyle('background-image', 'url(' + IMAGE_URL + kickInfo.desc.images['flip'] + ')');
                }
            }
        }
    },
    //        
    animChoice: function(anim, callback) {
        var me = this,
            choiceCmpEl = Ext.getCmp('battle-choice') ? Ext.getCmp('battle-choice').getEl() : null,
            started = 0,
            source = anim.source,
            _animChoice = function(target, anim, callback) {
                var kickEl,
                    dest = {
                        y: ExGods.ref('constants|bat_anim_choice2_top').value
                    },
                    animEl;
                if (source == 'me') {
                    kickEl = choiceCmpEl.down('.my-kick');
                } else {
                    kickEl = choiceCmpEl.down('.enemy-kick');
                }
                if ((target == 'self' && source == 'me') || (target == 'enemy' && source == 'enemy')) {
                    dest.x = -272;
                } else {
                    dest.x = 377;
                }
                if (!kickEl) {
                    callback();
                    return;
                }
                animEl = kickEl.parent().insertHtml('afterBegin', '<div style="z-index: 1000; background-image: ' + Ext.String.htmlEncode(kickEl.getStyle('background-image')) + '; left: ' + kickEl.getLocalX() + 'px; top: ' + kickEl.getLocalY() + 'px;"></div>', true);
                kickEl.setStyle('opacity', 0);
                animEl.animate({
                    duration: ExGods.ref('constants|bat_anim_choice2_dur').value,
                    to: {
                        left: dest.x + 'px',
                        top: dest.y + 'px',
                        opacity: ExGods.ref('constants|bat_anim_choice2_opacity').value,
                        width: ExGods.ref('constants|bat_anim_choice2_w').value,
                        height: ExGods.ref('constants|bat_anim_choice2_h').value
                    },
                    listeners: {
                        afteranimate: function() {
                            callback();
                        }
                    }
                });
            },
            _hideChoice = function(callback) {
                var kickEl;
                if (source == 'me') {
                    kickEl = choiceCmpEl.down('.my-kick');
                } else {
                    kickEl = choiceCmpEl.down('.enemy-kick');
                }
                kickEl.animate({
                    duration: 500,
                    from: {
                        opacity: 1
                    },
                    to: {
                        opacity: 0
                    },
                    callback: callback
                });
            },
            _afterAnim = function() {
                if (--started == 0) {
                    callback();
                }
            };
        /***/
        me.log(' ', anim);
        try {
            if (anim.self_anim && me.canShowAnimation('self', anim)) {
                started++;
                _animChoice('self', anim, _afterAnim);
            }
            if (anim.enemy_anim && me.canShowAnimation('enemy', anim)) {
                started++;
                _animChoice('enemy', anim, _afterAnim);
            }
            if (!started) {
                _hideChoice(callback);
            }
        } catch (e) {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView    ' + e);
            callback();
        }
    },
    /**
     *         
     */
    onAnimationFinish: function(callback) {
        var me = this;
        if (!me.queue || !me.queue.length) {
            callback();
        } else {
            me.on('animation_finish', callback, me, {
                single: true
            });
        }
    },
    /**
     * @private  "  "
     * @param target String   "self" or "enemy"
     * @param anim
     */
    canShowAnimation: function(target, anim) {
        var me = this,
            u;
        if (target == 'self' && anim.source == 'me' || target == 'enemy' && anim.dest == 'me') {
            u = me.battleView.getBattleUser(me.user.getBattleEkey());
        } else if (target == 'self' && anim.source == 'enemy' || target == 'enemy' && anim.dest == 'enemy') {
            u = me.battleView.getBattleEnemy();
        }
        return u && u.isLiveInBattle();
    },
    /**
     *    
     */
    _run_anim: function(side, img_url, data) {
        var me = this,
            panel = side == 'left' ? me.leftPanel : me.rightPanel;
        panel.testSpriteSheet([
            img_url
        ], data);
    },
    getResources: function() {
        var me = this,
            images = [],
            animRef = ExGods.ref('battle_animations'),
            collectTurnImages = function(turnData, arr) {
                if (turnData.desc) {
                    Ext.Object.each(turnData.desc.a_self || {}, function(k, v) {
                        if (v.image) {
                            arr.push(v.image);
                        }
                        if (v.name) {
                            var data = animRef.get(v.name);
                            if (data) {
                                arr.push(data.images[0]);
                            }
                        }
                    });
                    Ext.Object.each(turnData.desc.a_enemy || {}, function(k, v) {
                        if (v.image) {
                            arr.push(v.image);
                        }
                        if (v.name) {
                            var data = animRef.get(v.name);
                            if (data) {
                                arr.push(data.images[0]);
                            }
                        }
                    });
                }
            };
        Ext.Array.each(me.battle.state.av_kick || [], function(item) {
            var info = ExGods.ref('battle_turn|' + item.name);
            if (info) {
                collectTurnImages(info, images);
            }
        });
        Ext.Array.each(me.battle.state.av_prep || [], function(item) {
            var info = ExGods.ref('battle_prep|' + item.name);
            if (info) {
                collectTurnImages(info, images);
            }
        });
        images.push('battle/numbers/num.png');
        return {
            images: images
        };
    }
});

/**
 * ,      .
 *
 * @author Oleg M.
 */
Ext.define('ExGods.controller.battle.Stability', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'BattleStability:'
    },
    /**
     * @property {Number} roundDelay
     */
    roundDelay: 30 * 1000,
    init: function() {
        var me = this;
        me.listen({
            controller: {
                '#battle.Battle': {
                    'start': me.onBattleStart,
                    'finish': me.onBattleFinish,
                    'load_round': me.onBattleLoadRound
                }
            }
        });
        me.battle = me.app.getController('battle.Battle');
        me.battleView = me.app.getController('battle.BattleView');
        me.callParent();
    },
    onBattleStart: function() {
        var me = this;
        clearTimeout(me.onRoundTimeout);
        me.onRoundTimeout = null;
    },
    onBattleFinish: function() {
        var me = this;
        clearTimeout(me.onRoundTimeout);
        me.onRoundTimeout = null;
    },
    /**
     * @private   
     */
    onBattleLoadRound: function() {
        var me = this;
        if (me.onRoundTimeout) {
            clearTimeout(me.onRoundTimeout);
            me.onRoundTimeout = null;
        }
        //       BattleView.
        // ,   <this.roundDelay>  View        .     -     View
        me.onRoundTimeout = setTimeout(function() {
            if (me.battleView.cur_round != me.battle.state.round) {
                /***/
                me.log('  ,     ');
                me.battle.restartBattle();
            }
        }, me.roundDelay);
    }
});

/**
 *    
 */
Ext.define('ExGods.controller.ChatGroup', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    init: function(app) {
        var me = this;
        me.guild_service = ExGods.Services.get('guilds');
        me.control({
            '#guild-group-messages': {
                render: me.onGuildGroupRender,
                destroy: me.onGuildGroupDestroy
            }
        });
        app.getChatConnection().on({
            command_chat_update_group: me.onChatGroupUpdate,
            scope: me
        });
    },
    onGuildGroupRender: function() {
        var me = this;
        me.guild_service.command('guild_groups', {}, function(data) {
            if (data.group)  {
                me.app.getStore('GuildGroupOnlineList').loadRawData(data.group.users);
            }
            
        });
    },
    onGuildGroupDestroy: function() {
        this.app.getStore('GuildGroupOnlineList').removeAll();
    },
    onChatGroupUpdate: function(chatcn, data) {
        if (data.body.group_info) {
            this.app.getStore('GuildGroupOnlineList').loadRawData(data.body.group_info.users);
        }
    }
});

/**
 *  
 *
 *  <code>data</code>   :
 *
 *      {
 *          body: <_>
 *          from: <>
 *          to: <>
 *      }
 * 
 * <code>state</code>  :
 *
 * - 1 - 
 * - 2 - 
 *
 * <code>snet</code> -  1,       
 */
Ext.define('ExGods.model.Notice', {
    extend: Ext.data.Model,
    idProperty: 'letter_id',
    fields: [
        {
            name: 'data',
            type: 'auto',
            convert: function(v) {
                if (v && v.body) {
                    v.body = ExGods.app.applyTpl(v.body);
                }
                return v;
            }
        },
        {
            name: 'letter_id',
            type: 'int'
        },
        {
            name: 'received',
            type: 'date',
            dateFormat: serverDateTimeFormat
        },
        {
            name: 'snet',
            type: 'int',
            convert: function(v, rec) {
                var data = rec.get('data');
                return data ? data.snet : 0;
            }
        },
        {
            name: 'state',
            type: 'int'
        }
    ]
});

/**
 *  
 */
Ext.define('ExGods.store.Notices', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Notice'
});

/**
 *  
 */
Ext.define('ExGods.view.notice.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.noticetabpanel',
    tabUi: 'skintext',
    bodyPadding: '0 10 8 8',
    /**
     * @cfg {Object} messages  
     */
    messages: {},
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {};
        }
        Ext.applyIf(item.tabConfig, {
            xtype: 'noticetab',
            quantityLeft: item.quantityLeft || 0,
            item: item,
            messages: me.messages
        });
        me.callParent(arguments);
    }
});

/**
 *   
 */
Ext.define('ExGods.view.notice.Notice', {
    extend: Ext.panel.Panel,
    alias: 'widget.notice',
    id: 'notice',
    margin: '-3px -3px 0 -3px',
    count: 10,
    /**
     * @cfg {Ext.data.Model} group (required)
     *   
     */
    /**
     * @cfg {ExGods.store.Notices} notices (required)
     *   
     */
    /**
     * @cfg {Object} messages  
     */
    messages: {},
    bodyPadding: 0,
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            autoHide: true,
            autoRestorePosition: true,
            padding: '3px 3px 0 0'
        }
    ],
    /**
    *    ,   
     */
    loadings: 0,
    /**
     *    ,   
     */
    loaded: 0,
    /**
     * @cfg {String} social
     *   
     */
    /**
     *  "" ,      
     */
    rawMails: [],
    /**
     *  ,       rawMails
     */
    leftToLoad: 0,
    initComponent: function() {
        var me = this,
            notices = me.store,
            notice = me.store.first();
        me.tpl = [
            '<tpl if="empty">',
            '<p class="central-window-empty">{[this.getEmptyText()]}</div>',
            '<tpl else>',
            '<div class="notice-container">',
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="subject"><h4>{data.subject}</h4></div>',
            '<div class="quest-deco-body">',
            '<div class="narrow-column" style="margin:3px 0 15px 6px">',
            '<div class="quest-giver-border">',
            '<div class="quest-giver-image" style="background-image:url({[IMAGE_URL]}{data.image})"></div>',
            '</div>',
            '</div>',
            '<div class="wide-column">',
            '<tpl if="data.attaches && data.attaches.length">',
            '<div style="min-height: 120px">{[ ExGods.util.Helper.processTextWithSmiles( ExGods.app.applyTpl(values.data.body, values) ) ]}</div>',
            '<div class="info-box">',
            '<div class="info-box-bg"></div>',
            '<div class="info-box-tl"></div>',
            '<div class="info-box-t"></div>',
            '<div class="info-box-tr"></div>',
            '<div class="info-box-l"></div>',
            '<div class="info-box-r"></div>',
            '<div class="info-box-bl"></div>',
            '<div class="info-box-b"></div>',
            '<div class="info-box-br"></div>',
            '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_award'] + '"></div>',
            '<div class="info-box-content info-box-rewards">',
            '<ul>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '<li class="info-box-itembox"></li>',
            '</ul>',
            '</div>',
            '</div>',
            '<tpl else>',
            '<div style="min-height: 250px">{[ ExGods.util.Helper.processTextWithSmiles( ExGods.app.applyTpl(this.clearDirections(values.data.body), values) ) ]}</div>',
            '</tpl>',
            '<div id="checkbox-place"></div>',
            '<div id="button-place"></div>',
            '</div>',
            '</div>',
            '</div>',
            '</div>',
            '</tpl>',
            {
                getEmptyText: function() {
                    return ExGods.ref('message_client|emptynotices');
                },
                clearDirections: function(text) {
                    return text.replace(/\[#\s([\w\d-_]+)\s#\]/ig, '');
                }
            }
        ] , me.count = parseInt(ExGods.ref('constants').get('max_letter_count').value);
        me.callParent();
        me.on('afterrender', function() {
            if (me.notice) {
                me.getRewards();
            }
        });
        me.on('afterlayout', function() {
            me.scroller.onResize();
        });
    },
    /**
     *   ()   
     */
    showNext: function(callback) {
        var me = this,
            notice = me.store.first(),
            new_count = parseInt(me.messages.new_count),
            count = me.count;
        //    
        if (me.loaded != me.loadings) {
            me.loaded++;
            return;
        }
        if (me.getEl()) {
            me.getEl().unmask();
        }
        if (me.store.count()) {
            var attaches = notice.get('data').attaches;
            me.update(notice.getData());
            me.getRewards();
            // me.checkbox = Ext.widget('checkboxfield', {
            //  name: 'snet',
            //  renderTo:'checkbox-place',
            //  boxLabel: ' ',
            //  checked: true,
            //  width: 130
            // });
            Ext.widget({
                xtype: 'textbutton',
                renderTo: 'button-place',
                cls: 'no_border',
                text: (attaches && attaches.length) ? ExGods.getMsgByKey('view_notice_get_attach_text') : ExGods.getMsgByKey('view_notice_read_letter_text'),
                handler: function(button) {
                    me.fireEvent('take', button, me.checkbox);
                }
            });
            if (typeof callback == 'function')  {
                callback();
            }
            
        } else // if (notice.get('snet')) {
        //  me.checkbox.setVisible(true);
        //  me.checkbox.setValue(true);
        // } else {
        //  me.checkbox.setVisible(false);
        //  me.checkbox.setValue(false);
        // }
        {
            if (me.rawMails.length && me.leftToLoad == 0) {
                me.store.loadRawData(me.rawMails);
                me.rawMails = [];
                if (typeof callback == 'function')  {
                    callback();
                }
                
            } else {
                if (me.leftToLoad > 0) {
                    if (me.count < me.leftToLoad) {
                        me.leftToLoad -= me.count;
                    } else {
                        count = me.leftToLoad;
                        me.leftToLoad = 0;
                    }
                }
                me.store.load({
                    params: {
                        start: Math.max(0, new_count - me.count) + 1 + me.rawMails.length,
                        count: count
                    },
                    callback: function(notices) {
                        if (typeof callback == 'function')  {
                            callback();
                        }
                        
                        me.afterNoticeLoad(notices);
                    },
                    scope: me
                });
            }
            
        }
        if (me.rendered) {
            me.scroller.onResize();
        }
    },
    //       
    /**
     *         
     *    
     *
     * @param {ExGods.model.Notice[]}
     */
    afterNoticeLoad: function(notices) {
        var me = this,
            i, j,
            protosItem = ExGods.app.getItemPrototypesStore(),
            protosAbility = ExGods.app.getAbilityPrototypesStore(),
            protosFeature = ExGods.app.getFeaturePrototypesStore(),
            itemIds = [],
            abilityIds = [],
            featureIds = [];
        if (me.getEl()) {
            ExGods.util.Helper.maskElement(me.getEl());
        }
        for (i = 0; i < notices.length; i++) {
            var notice = notices[i],
                attaches = notice.get('data').attaches;
            if (attaches.length) {
                for (j = 0; j < attaches.length; j++) {
                    var attach = attaches[j];
                    if (attach.type == 'item' && !protosItem.data.getByKey(parseInt(attach.params.id))) {
                        itemIds.push(parseInt(attach.params.id));
                    }
                    if (attach.type == 'ability' && !protosAbility.data.getByKey(attach.params.id)) {
                        abilityIds.push(attach.params.id);
                    }
                    if (attach.type == 'feature' && !protosFeature.data.getByKey(attach.params.id)) {
                        featureIds.push(attach.params.id);
                    }
                }
            }
        }
        me.loadings = 0;
        if (itemIds.length || abilityIds.length || featureIds.length) {
            me.loaded = 1;
            //   
            if (itemIds.length)  {
                me.loadings++;
            }
            
            if (abilityIds.length)  {
                me.loadings++;
            }
            
            if (featureIds.length)  {
                me.loadings++;
            }
            
            protosItem.loadNew(itemIds, Ext.Function.bind(me.showNext, me));
            protosAbility.loadNew(abilityIds, Ext.Function.bind(me.showNext, me));
            protosFeature.loadNew(featureIds, Ext.Function.bind(me.showNext, me));
        } else {
            me.loaded = 0;
            //  
            if (notices.length) {
                me.showNext();
            } else {
                if (me.getEl()) {
                    me.getEl().unmask();
                }
                me.update({
                    empty: true
                });
                me.doLayout();
            }
        }
    },
    getRewards: function() {
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            rewards = me.store.first().get('data').attaches;
        if (rewards.length) {
            ExGods.app.block();
            ExGods.util.Helper.loadProtosFromStuff(rewards, function() {
                ExGods.app.unblock();
                var rewardsHtml = ExGods.stuff.StuffManager.image(rewards),
                    rewardsEl = document.createElement('div'),
                    ul = me.el && me.el.down('.info-box-rewards ul');
                rewardsEl.innerHTML = rewardsHtml;
                Ext.get(rewardsEl).select('li').addCls('info-box-itembox');
                if (ul) {
                    ul.update(rewardsEl.firstChild.innerHTML);
                    for (var i = rewards.length; i < 7; i++) {
                        ul.insertHtml('beforeEnd', '<li class="info-box-itembox"></li>');
                    }
                }
            });
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.List', {
    extend: Ext.panel.Panel,
    alias: 'widget.baselist',
    itemWidgetName: 'baselistitem',
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            scrollDeltaY: 50,
            autoHide: true,
            autoRestorePosition: true
        }
    ],
    /**
     * true     
     */
    noEmpty: false,
    emptyTpl: [
        '<div>{text}</div>'
    ],
    emptyData: {
        text: 'empty'
    },
    initComponent: function() {
        var me = this,
            store = me.store,
            items = me.getItems();
        if (!me.items) {
            me.items = [];
        }
        me.items.push({
            xtype: 'container',
            itemId: 'wrap',
            layout: {
                type: 'vbox',
                align: 'stretch'
            },
            items: items
        });
        me.callParent(arguments);
        me.rerender = Ext.Function.createBuffered(me.rerender, 100, me);
        store.on('datachanged', me.rerender, me);
        store.on('update', me.rerender, me);
        me.on('show', me.rerender, me);
    },
    /*
     *     .
     */
    scrollTo: function(record) {
        var me = this,
            slider = me.down('slider'),
            target = me.getComponent('wrap').getComponent(record.get('proto_id'));
        me.collapseAll();
        if (target) {
            target.expand();
            Ext.Function.createBuffered(function() {
                slider.setValue(slider.maxValue - target.y);
            }, 50)();
        }
    },
    //slider.setValue(slider.maxValue - target.el.getLocalY());
    /*
     *    
     */
    scrollToTop: function() {
        this.scroller.scrollToTop();
    },
    /*
     *       
     */
    showDefault: function() {
        var me = this;
        me.collapseAll();
        me.scrollToTop();
    },
    /*
     *   
     */
    collapseAll: function() {
        var me = this;
        Ext.each(me.getComponent('wrap').items.items, function(item) {
            if (item.isExpanded) {
                item.collapse();
            }
        });
    },
    /*
     *   
     */
    expandAll: function() {
        var me = this;
        Ext.each(me.getComponent('wrap').items.items, function(item) {
            if (!item.isExpanded) {
                item.expand();
            }
        });
    },
    /*
     *     
     */
    rerender: function() {
        var me = this;
        if (!me.rendered) {
            return;
        }
        me.suspendLayouts();
        me.getComponent('wrap').removeAll();
        me.getComponent('wrap').add(me.getItems());
        me.resumeLayouts(true);
    },
    /**
     * @private
     *    
     */
    getItems: function() {
        var me = this,
            store = me.store,
            items = [];
        if (store.getCount() > 0) {
            store.each(function(record) {
                var item = Ext.apply({
                        xtype: me.itemWidgetConfig.xtype,
                        record: record
                    }, me.itemWidgetConfig);
                items.push(item);
            });
        } else if (!me.noEmpty) {
            items.push({
                xtype: 'component',
                margin: '1px 0 0 0',
                height: 369,
                data: me.emptyData,
                tpl: Ext.create('ExGods.view.Template', me.emptyTpl)
            });
        }
        return items;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var stuff_arr = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            stuff_arr.concat(me.store.data.items[i].data.rewards);
        }
        return {
            stuff: stuff_arr || [],
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.notice.Archive', {
    extend: ExGods.view.List,
    alias: 'widget.noticearchive',
    id: 'notice-archive',
    margin: '-3px -3px 0 -3px',
    count: 5,
    finish: 1,
    start: 1,
    emptyTpl: [
        '<p class="central-window-empty">{text}</p>'
    ],
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            scrollDeltaY: 50,
            autoHide: true,
            autoRestorePosition: true,
            padding: '3px 3px 0 0'
        }
    ],
    /**
     * @cfg {Object}  
     */
    messages: {},
    initComponent: function() {
        var me = this;
        me.itemWidgetConfig = {
            xtype: 'noticelistitem',
            listeners: {
                expand: me.onItemExpand,
                collapse: me.onItemCollapse,
                scope: me
            }
        };
        me.emptyData = {
            text: ExGods.ref('message_client|emptyarchive')
        };
        me.callParent(arguments);
        me.on('render', function() {
            me.loadNotices();
        });
        me.mon(me.store, 'datachanged', function(store) {
            btnPanel = me.getDockedItems('[dock="bottom"]')[0];
            if (store.getCount() > 1 && !btnPanel) {
                me.addDocked({
                    dock: 'bottom',
                    xtype: 'panel',
                    margin: 8,
                    items: [
                        {
                            xtype: 'textbutton',
                            text: ExGods.getMsgByKey('view_notice_archive_deleteall'),
                            id: 'delete-all-notices',
                            cls: 'x-btn-txt-red'
                        }
                    ]
                });
            } else if (store.getCount() <= 1 && btnPanel) {
                me.removeDocked(btnPanel);
            }
        });
        me.on({
            scroll: me.onScroll,
            buffer: 50,
            scope: me
        });
    },
    onItemExpand: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onItemCollapse: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onScroll: function(scroller) {
        var me = this,
            rest_count = me.messages.rest_count;
        if (((scroller && scroller.isBottom()) || !scroller) && me.finish < rest_count) {
            var count = Math.min(me.count, rest_count - me.finish);
            me.loadNotices({
                start: me.finish + 1,
                count: count
            }, me.store.first());
            me.finish += count;
        }
    },
    /**
     *   
     *
     * @param {Object} params
     * @param {ExGods.model.Notice} notice
     */
    loadNotices: function(params, notice) {
        var me = this;
        if (!params)  {
            params = {};
        }
        
        Ext.applyIf(params, {
            start: 1,
            count: me.count
        });
        me.store.load({
            params: params,
            addRecords: true,
            scope: me
        });
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        var parent = me.callParent();
        return {
            stuff: [].concat(parent.stuff),
            images: [
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 *     -  
 */
Ext.define('ExGods.view.notice.Tab', {
    extend: ExGods.view.skin.Tab,
    alias: 'widget.noticetab',
    /**
     * @cfg {Object} messages  
     */
    messages: {},
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.counterEl = '';
        // me.btnEl.insertHtml('beforeEnd', '<div class="counter"></div>', true);
        me.item.store.on('datachanged', me.onCountChange, me);
        me.onCountChange();
    },
    onCountChange: function() {
        var me = this,
            numbers = '',
            store = me.item.store,
            param = (me.item.xtype == 'notice') ? 'new_count' : 'rest_count',
            qcont = me.btnEl.down('.quantity-container'),
            count = me.messages[param].toString();
        for (var i = 0; i < count.length; i++) {
            numbers += '<div class="tab-number" style="background-image:url(' + IMAGE_URL + 'quests/tasks_sprite_' + count.charAt(i) + '.png)"></div>';
        }
        if (qcont) {
            qcont.destroy();
        }
        me.btnEl.insertHtml('beforeEnd', '<div class="quantity-container" id="quantity-container" style="left:' + me.quantityLeft + 'px">' + numbers + '</div>');
    }
});

Ext.define('ExGods.view.ListItem', {
    extend: Ext.Component,
    alias: 'widget.baselistitem',
    /*
     * events: 'collapse', 'expand';
     */
    viewChangeSelector: '.view-change-selector',
    isExpanded: false,
    initComponent: function() {
        var me = this;
        me.callParent();
        me.record.listItem = me;
        me.on('afterrender', function() {
            me.el.on('click', function(elem) {
                if (this.getEl().down(me.viewChangeSelector).hasCls('disable'))  {
                    return;
                }
                
                if (me.isExpanded) {
                    me.collapse();
                } else {
                    me.expand();
                }
            }, me, {
                delegate: me.viewChangeSelector
            });
        });
    },
    // 
    setTpl: function(rawTpl) {
        return Ext.create('ExGods.view.Template', rawTpl);
    },
    //     
    collapse: function() {
        var me = this;
        me.isExpanded = false;
        me.fireEvent('collapse', me);
    },
    //     
    expand: function() {
        var me = this;
        me.isExpanded = true;
        me.fireEvent('expand', me);
    }
});

Ext.define('ExGods.view.notice.ListItem', {
    extend: ExGods.view.ListItem,
    alias: 'widget.noticelistitem',
    margin: '0 0 -3px 0',
    initComponent: function() {
        var me = this;
        var expanded = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{data.subject}</h4>',
                '<div class="view-change-selector expanded"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url({[IMAGE_URL]}{data.image})"></div>',
                '</div>',
                '</div>',
                '<div class="wide-column">',
                '<div class="all-text">{[ ExGods.util.Helper.processTextWithSmiles( ExGods.app.applyTpl(this.clearDirections(values.data.body), values) ) ]} </div>',
                '<div id="button-place-{letter_id}"></div>',
                '</div>',
                '</div>',
                {
                    clearDirections: function(text) {
                        return text.replace(/\[#\s([\w\d-_]+)\s#\]/ig, '');
                    }
                }
            ];
        var collapsed = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{data.subject}</h4>',
                '<div class="view-change-selector collapsed"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url({[IMAGE_URL]}{data.image})"></div>',
                '</div>',
                '</div>',
                '<div class="wide-column">',
                '<div class="short-text"><span id="' + me.id + 'text_container" style="display:block">{[ ExGods.util.Helper.processTextWithSmiles( ExGods.app.applyTpl(this.clearDirections(values.data.body), values) ) ]}</span></div>',
                '<div id="button-place-{letter_id}"></div>',
                '</div>',
                '</div>',
                {
                    clearDirections: function(text) {
                        return text.replace(/\[#\s([\w\d-_]+)\s#\]/ig, '');
                    }
                }
            ];
        me.expanded = me.setTpl(expanded);
        me.collapsed = me.setTpl(collapsed);
        me.callParent(arguments);
        me.on('render', function() {
            if (me.record.get('expanded') == true) {
                me.expand();
            } else {
                me.collapse();
            }
            me.el.on('click', function() {
                me.fireEvent('delete', me.record);
            }, me, {
                delegate: '.x-btn-txt'
            });
            //     .short-text,    EXPAND
            if (Ext.get(me.id + 'text_container') && Ext.get(me.id + 'text_container').dom.offsetHeight <= 83) {
                this.getEl().down('.view-change-selector').addCls('disable');
            }
        });
    },
    renderSubmitButton: function() {
        Ext.widget('textbutton', {
            text: ExGods.getMsgByKey('view_notice_listitem_delete'),
            cls: 'x-btn-txt-red no_border',
            margin: '0 0 15 -50',
            renderTo: 'button-place-' + this.record.get('letter_id')
        });
    },
    collapse: function() {
        var me = this;
        me.collapsed.overwrite(me.el, me.record.data);
        me.renderSubmitButton();
        me.record.set('expanded', false);
        me.callParent();
    },
    expand: function() {
        var me = this;
        me.expanded.overwrite(me.el, me.record.data);
        me.renderSubmitButton();
        me.record.set('expanded', true);
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images)
        };
    }
});

/**
 *     :
 * 
 */
Ext.define('ExGods.controller.Communication', {
    extend: ExGodsCore.controller.Base,
    views: [
        'CommonWindow',
        'notice.Archive',
        'notice.Notice',
        'notice.TabPanel',
        'notice.Tab',
        'notice.ListItem'
    ],
    refs: [
        {
            /**
         * @method getCommunicationButton
         *   ""
         * @return {ExGods.view.menu.MainMenuButton}
         */
            ref: 'communicationButton',
            selector: '#mainmenu-communication-button'
        },
        {
            /**
         * @method getNotice
         *    () 
         * @return {ExGods.view.notice.Notice}
         */
            ref: 'notice',
            selector: '#notice'
        },
        {
            /**
         * @method getNoticeArchive
         *    
         * @return {ExGods.view.notice.Archive}
         */
            ref: 'noticeArchive',
            selector: '#notice-archive'
        }
    ],
    init: function(app) {
        var me = this;
        me.service = ExGods.Services.get('messages');
        me.service.on('update', me.onServiceUpdate, me);
        me.control({
            'notice': {
                take: me.onTakeAttachClick
            },
            'noticelistitem': {
                'delete': me.deleteArchiveItem
            },
            '#delete-all-notices': {
                click: me.deleteAll
            }
        });
        // '#notice-archive button[action="clear"]': {
        //  click: me.clearNoticeArchive
        // }
        var icons = ExGods.references.get('images').get('communication_icons').image;
        //   
        me.newNotices = Ext.create('ExGods.store.Notices', {
            proxy: {
                type: 'ajax',
                url: HOST_URL + '/game.pl?cmd=messages_get_list_new',
                limitParam: false,
                pageParam: false,
                startParam: false,
                reader: {
                    type: 'json',
                    rootProperty: 'letters'
                }
            },
            sorters: [
                {
                    property: 'received',
                    direction: 'ASC'
                },
                {
                    property: 'letter_id',
                    direction: 'ASC'
                }
            ]
        });
        //   
        me.archiveNotices = Ext.create('ExGods.store.Notices', {
            proxy: {
                type: 'ajax',
                url: HOST_URL + '/game.pl?cmd=messages_get_list_rest',
                limitParam: false,
                pageParam: false,
                startParam: false,
                reader: {
                    type: 'json',
                    rootProperty: 'letters'
                }
            },
            sorters: [
                {
                    property: 'received',
                    direction: 'DESC'
                },
                {
                    property: 'letter_id',
                    direction: 'DESC'
                }
            ]
        });
        me.newNotices.getProxy().setExtraParam('service_id', me.service.id);
        me.archiveNotices.getProxy().setExtraParam('service_id', me.service.id);
        app.getChatConnection().on({
            command_post: me.onPostCommand,
            //command_contact: me.onContactCommand,
            scope: me
        });
        ExGods.Components.addComponentInitializer('notices', me.initNoticesComponent, me);
    },
    onServiceUpdate: function() {
        var me = this;
        if (me.service.data.messages.new_count != '0') {
            me.getCommunicationButton().reset();
            me.getCommunicationButton().addCount(me.service.data.messages.new_count);
        }
    },
    deleteAll: function(btn, e) {
        var me = this;
        Ext.widget('confirmdialog', {
            message: ExGods.ref('message_client|delete_all_confirm'),
            handler: function() {
                if (me.archiveNotices._doremove)  {
                    return;
                }
                
                me.archiveNotices._doremove = 1;
                me.service.command('messages_remove_list_rest', {}, function(result) {
                    if (result.success) {
                        me.service.data.messages.rest_count = 0;
                        me.archiveNotices.removeAll();
                    }
                    me.archiveNotices._doremove = null;
                });
            }
        });
    },
    deleteArchiveItem: function(message) {
        var me = this;
        if (me.archiveNotices._doremove)  {
            return;
        }
        
        me.archiveNotices._doremove = 1;
        me.service.command('messages_remove', {
            letter_id: message.get('letter_id')
        }, function(result) {
            if (result.success) {
                me.service.data.messages.rest_count--;
                me.archiveNotices.remove(message);
            }
            me.archiveNotices._doremove = null;
        });
    },
    /**
     *        
     *
     * @param {Object} data  :
     *
     *      {
     *          body: {
     *              chain: {},
     *              letter: {},
     *              type: 'post'
     *          },
     *          ...
     *      }
     */
    onPostCommand: function(chatcn, data) {
        var me = this,
            app = me.application,
            messageData = data.body.letter;
        if (data.body.remove) {
            var notices = messageData.state == 1 ? me.newNotices : me.archiveNotices,
                notice = notices.data.getByKey(Number(messageData.letter_id));
            if (notice) {
                notices.remove(notice);
                if (notices == me.newNotices) {
                    me.service.data.messages.new_count--;
                } else {
                    me.service.data.messages.rest_count--;
                }
            }
        } else {
            if (me.getNotice()) {
                var count = me.service.data.messages.new_count;
                me.service.data.messages.new_count++;
                if (me.newNotices.count() < count) {
                    me.getNotice().rawMails.push(data.body.letter);
                    me.newNotices.fireEvent('datachanged', me.newNotices);
                } else {
                    me.newNotices.loadRawData([
                        data.body.letter
                    ], true);
                }
                if (me.service.data.messages.new_count == 1) {
                    if (me.getNotice().isVisible()) {
                        me.getNotice().showNext();
                    } else {
                        me.getNotice().on('show', function() {
                            me.getNotice().showNext();
                        }, me, {
                            single: true
                        });
                    }
                }
            } else {
                me.service.data.messages.new_count++;
            }
            me.getCommunicationButton().reset();
            me.getCommunicationButton().addCount(me.service.data.messages.new_count);
        }
    },
    /**
     *     ""
     */
    onTakeAttachClick: function(button, checkbox) {
        var me = this,
            app = me.application,
            newNotices = me.newNotices,
            notice = newNotices.first(),
            user = me.getUser();
        // if (checkbox.checked) {
        //  var data = notice.get('data'),
        //      img = data.viral_image || data.image;
        //  if (isSocialApp) {
        //      button.disable();
        //      app.on({
        //          socialwallposted: Ext.Function.pass(me.takeNoticeAttach, [button, checkbox, notice], me),
        //          socialwallcanceled: function() {
        //              button.enable();
        //          },
        //          single: true
        //      })
        //      app.fireEvent('socialwallpost', {
        //          message: data.viral || data.subject,
        //          subject: data.subject,
        //          image_rel: data.image ? data.image : null,
        //          image: img ? IMAGE_URL + img : null
        //      });
        //  } else if (user.getSocialNet()) {
        //      app.fireEvent('socialshare', {
        //          type: user.get('social').social_net,
        //          url: 'http://' + location.host,
        //          image: IMAGE_URL + img || Ext.BLANK_IMAGE_URL,
        //          title: data.subject,
        //          description: data.viral || data.body
        //      });
        //      me.takeNoticeAttach(button, checkbox, notice);
        //  } else {
        //      //    
        //      Ext.widget('confirmdialog', {
        //          message: ExGods.ref('message_client|socialattachment'),
        //          handler: function() {
        //              app.fireEvent('socialnetassign');
        //          }
        //      });
        //  }
        // } else {
        me.takeNoticeAttach(button, checkbox, notice);
    },
    //}
    takeNoticeAttach: function(button, checkbox, notice) {
        var me = this,
            user = me.getUser(),
            newNotices = me.newNotices;
        button.disable();
        ExGods.app.block();
        me.service.command(notice.get('data').attaches.length ? 'messages_take_attach' : 'messages_update_state', {
            letter_id: notice.get('letter_id')
        }, function(result) {
            notice.set(result.letter);
            if (me.service.data.messages.new_count != 0)  {
                me.service.data.messages.new_count--;
            }
            
            me.service.data.messages.rest_count++;
            me.newNotices.remove(notice);
            me.archiveNotices.add(notice);
            me.getCommunicationButton().reset();
            me.getCommunicationButton().addCount(me.service.data.messages.new_count);
            me.getNotice().showNext(function() {
                //checkbox.setValue(true);
                button.enable();
                ExGods.app.unblock();
            });
        });
    },
    // clearNoticeArchive: function() {
    //  var me = this,
    //      archiveNotices = me.archiveNotices,
    //      service = me.getNotice().service;
    //  me.request({
    //      url: '/game.pl?cmd=messages_remove_list_rest',
    //      params:{
    //          service_id:service.get('id')
    //      },
    //      success: function(result) {
    //          if (result.success) {
    //              var data = service.get('data');
    //              archiveNotices.removeAll();
    //              data.messages.rest_count = 0;
    //              service.set('data',data);
    //          }
    //      }
    //  });
    // },
    /**
     *  
     */
    initNoticesComponent: function(config) {
        var me = this,
            wnd, cmp,
            fn = function() {
                var tabPanel = this.down('noticetabpanel');
                if (tabPanel && tabPanel.rendered) {
                    if (me.service.data.messages.new_count != 0) {
                        tabPanel.setActiveTab(0);
                    } else {
                        tabPanel.setActiveTab(1);
                    }
                }
            };
        cmp = Ext.widget('noticetabpanel', {
            messages: me.service.data.messages,
            items: [
                {
                    xtype: 'notice',
                    user: ExGods.app.user,
                    store: me.newNotices,
                    social: me.getUser().getSocialNet(),
                    icon: ExGods.ref('images|notice_images').image.new_tab_text,
                    quantityLeft: 105,
                    messages: me.service.data.messages
                },
                {
                    xtype: 'noticearchive',
                    user: ExGods.app.user,
                    store: me.archiveNotices,
                    icon: ExGods.ref('images|notice_images').image.archive_tab_text,
                    quantityLeft: 118,
                    messages: me.service.data.messages
                }
            ]
        });
        wnd = Ext.widget('window2', {
            id: 'NOTICES',
            items: [
                cmp
            ],
            autoShow: false,
            closeAction: 'hide',
            listeners: {
                show: function() {
                    var tabPanel = this.down('noticetabpanel');
                    if (tabPanel && tabPanel.rendered) {
                        tabPanel.items.each(function(item) {
                            item.tab.onCountChange();
                        });
                        fn.call(this);
                    }
                },
                afterrender: fn
            }
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
            cmp.down('notice').showNext(function() {
                cmp.down('notice').leftToLoad = me.service.data.messages.new_count - me.newNotices.count();
            });
        });
        return wnd;
    }
});

/**
 *    
 */
Ext.define('ExGods.controller.Resources', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Resources:'
    },
    /**
     * @property cache Array
     */
    cache: {
        images: []
    },
    init: function() {
        var me = this;
        me.queue = [];
        ExGods.Resources = me;
        //  
        me.callParent(arguments);
    },
    /**
     *   
     * @param src  .       ,   getResources  id component',    
     * @param callback 
     */
    load: function(src, callback) {
        var me = this,
            recources = {},
            started = 0,
            finished = 0,
            checkFinish = function(src) {
                var checkQueue = function() {
                        if (me.queue.length) {
                            var src = me.queue.shift();
                            me.load(src.src, src.callback);
                        }
                    };
                if (++finished >= started) {
                    me.loading = false;
                    var items = [];
                    if (src.items && src.items.items) {
                        items = items.concat(src.items.items);
                    }
                    if (src.dockedItems && src.dockedItems.items) {
                        items = items.concat(src.dockedItems.items);
                    }
                    if (src.plugins && src.plugins.length) {
                        items = items.concat(src.plugins);
                    }
                    me.loadMulti(items, function() {
                        /***/
                        me.log('finish', src);
                        callback();
                        checkQueue();
                    });
                }
            };
        callback = callback || Ext.emptyFn;
        if (me.loading) {
            me.queue.push({
                src: src,
                callback: callback
            });
            return;
        }
        /***/
        me.log(' ', src);
        if (typeof src == 'string') {
            src = Ext.getCmp(src);
            if (!src) {
                /***/
                me.log('warn', '\t  .', src);
                callback();
                return;
            }
        }
        if (typeof src.getResources == 'function') {
            recources = src.getResources();
            me.loading = true;
            //    
            if (recources && recources.images) {
                started++;
            }
            if (recources && recources.stuff) {
                started++;
            }
            if (recources && recources.images) {
                me.loadImages(recources.images, function() {
                    checkFinish(src);
                });
            }
            if (recources && recources.stuff) {
                me.loadStuff(recources.stuff, function() {
                    checkFinish(src);
                });
            }
        }
        if (!started) {
            checkFinish(src);
        }
    },
    /**
     *     
     * @param src Array
     */
    loadMulti: function(src, callback) {
        var me = this,
            loaded = 0,
            onLoad = function() {
                if (++loaded == src.length) {
                    callback();
                }
            };
        if (src.length) {
            for (var i = 0; i < src.length; i++) {
                me.load(src[i], onLoad);
            }
        } else {
            callback();
        }
    },
    /**
     *  
     */
    loadImages: function(images, callback) {
        var me = this,
            loaded = 0,
            incCounter = function() {
                if (++loaded == images.length) {
                    callback();
                }
            },
            img;
        if (images.length) {
            for (var i = 0; i < images.length; i++) {
                if (images[i] && images[i] != IMAGE_URL && Ext.Array.indexOf(me.cache.images, images[i]) == -1) {
                    if (images[i].substr && images[i].substr(0, 4) == 'img:') {
                        // ,    
                        images[i] = images[i].substr(4);
                    }
                    img = new Image();
                    img.onload = incCounter;
                    img.onerror = incCounter;
                    img.src = /^http/.test(images[i]) ? images[i] : IMAGE_URL + images[i];
                    me.cache.images.push(images[i]);
                } else {
                    incCounter();
                }
            }
        } else {
            me.imagesloaded = true;
            callback();
        }
    },
    /**
     *  
     */
    loadStuff: function(stuff, callback) {
        var me = this,
            itemProtos = me.app.getItemPrototypesStore(),
            featureProtos = me.app.getFeaturePrototypesStore(),
            proto,
            images = [];
        stuff = Ext.isArray(stuff) ? stuff : [
            stuff
        ];
        ExGods.util.Helper.loadProtosFromStuff(stuff, function() {
            Ext.Array.each(stuff, function(item) {
                //ExGods.ref('user_hoard|expa').image_big,
                if (item.type == 'expa') {
                    var obj = ExGods.ref('user_hoard|expa');
                    //images.push(obj.image);
                    images.push(obj.image_big);
                    images.push(obj.image_disabled);
                    return;
                }
                if (item.type == 'currency') {
                    var obj = ExGods.ref('user_money|' + item.params.id);
                    images.push(obj.image);
                    images.push(obj.image_big);
                    images.push(obj.image_disabled);
                    return;
                }
                if (item.type == 'item' || item.type == 'skull_item') {
                    proto = itemProtos.getById(parseInt(item.params.id));
                    if (proto) {
                        for (var key in proto.data.images) {
                            images.push(proto.data.images[key]);
                        }
                    }
                    return;
                }
                if (item.type == 'feature') {
                    proto = featureProtos.getById(item.params.id);
                    if (proto) {
                        for (var key in proto.data.images) {
                            images.push(proto.data.images[key]);
                        }
                    }
                    return;
                }
                if (item.type == 'action') {
                    proto = ExGods.ref('direct_actions|' + item.params.id);
                    if (proto) {
                        images.push(proto.images.simple);
                        images.push(proto.images.special);
                    }
                    return;
                }
                if (item.type == 'ingredients') {
                    proto = ExGods.ref('ingredients|' + item.params.id);
                    if (proto) {
                        images.push(proto.params.images.img_1);
                        images.push(proto.params.images.img_2);
                        images.push(proto.params.images.img_3);
                    }
                    return;
                }
                if (item.type == 'iteminstance') {
                    for (var i = 0; i < item.params.itemModel.data.features.length; i++) {
                        if (item.params.itemModel.data.features[i].images) {
                            var imgs = item.params.itemModel.data.features[i].images;
                            for (var it in imgs) {
                                if (imgs[it]) {
                                    images.push(imgs[it]);
                                }
                            }
                        }
                    }
                    //  
                    if (item.params.itemModel.data.proto_id) {
                        proto = itemProtos.getById(parseInt(item.params.itemModel.data.proto_id));
                        if (proto) {
                            for (var key in proto.data.images) {
                                images.push(proto.data.images[key]);
                            }
                            if (proto.data.action_full) {
                                for (var i = 0; i < proto.data.action_full.length; i++) {
                                    if (proto.data.action_full[i].images) {
                                        for (var it in proto.data.action_full[i].images) {
                                            images.push(proto.data.action_full[i].images[it]);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return;
                }
                if (item.type == 'timed') {
                    proto = ExGods.ref('user_timed|' + item.params.id);
                    if (proto) {
                        images.push(proto.img.img2);
                        images.push(proto.img.stuff);
                        if (proto.price) {
                            for (var i = 0; i < proto.price.length; i++) {
                                if (proto.price[i].type == 'timed') {
                                    me.log('warn', '  timed  price    timed! :) ');
                                }
                                me.loadStuff(proto.price[i], callback);
                            }
                        }
                    }
                    return;
                }
                me.log('warn', '      : ' + item.type);
            });
            //console.log(' : ' + item.type);
            me.loadImages(images, callback);
        });
    }
});

Ext.define('ExGods.view.dialog.stuff.DailyBonus', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.view.dialog.stuff.decorator.Day);
        if (me.stuff.selected) {
            data.decorators.push(ExGods.view.dialog.stuff.decorator.Selected);
        } else if (me.stuff.taken) {
            data.img = me.obj.getDisabledImage();
            data.decorators.push(ExGods.view.dialog.stuff.decorator.Taken);
        }
        return data;
    }
});

Ext.define('ExGods.view.dialog.stuff.Rewards', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.view.dialog.stuff.decorator.RewardFrame);
        return data;
    }
});

/**
 *     
 */
Ext.define('ExGods.view.dialog.stuff.decorator.Day', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateBefore: function(data) {
            var label;
            if (data.stuff.fin) {
                label = ExGods.getMsgByKey('daily_bonus_last_reward');
            } else {
                label = ExGods.app.applyTpl(ExGods.getMsgByKey('view_dialog_daily_day'), {
                    day: data.stuff.login_day_index
                });
            }
            return '<div class="label">' + label + '</div>';
        }
    }
});

/**
 *     
 */
Ext.define('ExGods.view.dialog.stuff.decorator.Selected', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var label;
            if (data.stuff.fin) {
                label = ExGods.getMsgByKey('daily_bonus_last_reward');
            } else {
                label = ExGods.app.applyTpl(ExGods.getMsgByKey('view_dialog_daily_day'), {
                    day: data.stuff.login_day_index
                });
            }
            return '<div class="selected-frame">' + label + '</div>';
        }
    }
});

/**
 *     
 */
Ext.define('ExGods.view.dialog.stuff.decorator.Taken', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="taken-mask" style="background-image:url(' + ExGods.ref('images|daily_bonus').image.achieved + ')"></div>';
        }
    }
});

/**
 *     
 */
Ext.define('ExGods.view.dialog.stuff.decorator.RewardFrame', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateBefore: function(data) {
            return '<div class="selected-frame"></div>';
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.dialog.RewardsDialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.dialog_rewards',
    defaultConfig: {
        btnText: 'OK',
        btnColor: '',
        backImg: ''
    },
    layout: 'fit',
    bodyPadding: '7 8 4 6',
    cls: 'dialog_rewards',
    /** @cfg */
    config: {},
    stuff: [],
    plugins: [],
    buttonClickHandler: Ext.emptyFn,
    initComponent: function() {
        var me = this;
        me.config = Ext.applyIf(me.config || {}, me.defaultConfig);
        me.items = [
            {
                xtype: 'container',
                layout: 'absolute',
                plugins: [
                    'paperdeco'
                ],
                items: [
                    {
                        xtype: 'component',
                        cls: 'image-wrap',
                        html: '<div class="frame"></div><div class="image" style="background-image: url(' + IMAGE_URL + me.config.backImg + ')"></div>'
                    },
                    {
                        xtype: 'component',
                        width: '100%',
                        y: 269,
                        style: {
                            'text-align': 'center'
                        },
                        html: '<div class="dialog-rewards-stuff"></div>',
                        listeners: {
                            render: me.printRewards,
                            scope: me
                        }
                    }
                ]
            }
        ];
        me.bbar = {
            items: [
                {
                    xtype: 'textbutton',
                    text: me.config.btnText,
                    cls: (me.config.btnColor) ? 'x-btn-txt-' + me.config.btnColor : '',
                    handler: me.buttonClickHandler
                }
            ],
            layout: {
                pack: 'center'
            },
            margin: '-5 0 12 0'
        };
        if (me.stuff.length > 6) {
            me.plugins.push({
                ptype: 'pager',
                marginLeft: -27,
                marginRight: -27,
                top: 286,
                total: Math.ceil(me.stuff.length / 6),
                tpl: []
            });
        }
        me.callParent(arguments);
    },
    printRewards: function() {
        var me = this,
            html = [],
            page = me.pager ? me.pager.current - 1 : 0,
            l = me.stuff.length;
        for (var i = page * 6; i < Math.min(l, (page + 1) * 6); i++) {
            html.push(ExGods.stuff.StuffManager.image(me.stuff[i]));
        }
        html = html.join('<div class="dialog-rewards-ribbon-middle"></div>');
        html = '<div class="dialog-rewards-ribbon-left"></div>' + html;
        html = html + '<div class="dialog-rewards-ribbon-right"></div>';
        me.el.down('.dialog-rewards-stuff').setHTML(html);
    },
    prevPage: function(pager) {
        this.printRewards();
        pager.refresh();
    },
    nextPage: function(pager) {
        this.printRewards();
        pager.refresh();
    }
});

/**
 *   .      :   
 */
Ext.define('ExGods.view.dialog.Dialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.dialog',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    bodyPadding: '10 9 13 10',
    plugins: [
        'skindeco'
    ],
    /**
     * @cfg {Object}
     *  : title  
     *  : image  
     *  : description  
     *
     */
    info: {},
    /**
     * @cfg {Object}    
     */
    data: '',
    /**
     * @cfg {String/Array}    data
     */
    tplForContent: '',
    /**
     * @cfg {Array} actions  -  (   )
     */
    actions: [],
    /**
     * @cfg {Object}     
     */
    actionsPanelConfig: {},
    // 
    initComponent: function() {
        var me = this;
        if (me.close_btn_text) {
            me.actions.push({
                anchor: "100%",
                text: me.close_btn_text,
                xtype: "textbutton",
                margin: '0 0 3 0',
                handler: function(button, event) {
                    me.up().closeComponent();
                }
            });
        }
        if (!me.actionsView) {
            me.actionsView = Ext.create('ExGods.view.dialog.DialogActions', {
                actions: me.actions
            });
        }
        me.items = [
            {
                itemId: 'info',
                cls: 'dialog-info',
                plugins: [
                    'parchmentdeco'
                ],
                width: 174,
                tpl: new Ext.Template('<div class="title">{title}</div>', '<div class="parchment-separator"></div>', '<div class="image" style="background-image: url({image})">', '<div class="frame"></div>', '</div>', '<div class="parchment-separator"></div>', '<div class="description">{description}</div>'),
                data: me.info
            },
            {
                itemId: 'content-container',
                bodyPadding: '4 0 4 4',
                flex: 1,
                layout: 'fit',
                margin: '0 0 0 2',
                plugins: [
                    'parchmentdeco'
                ],
                items: [
                    {
                        itemId: 'content',
                        autoScroll: true,
                        cls: 'dialog-content',
                        plugins: [
                            {
                                animate: false,
                                autoHide: false,
                                padding: '14 0 0 0',
                                ptype: 'scroller',
                                scrollDeltaY: 16
                            }
                        ],
                        html: Ext.create('ExGods.view.Template', me.tplForContent).apply(me.data)
                    }
                ],
                dockedItems: [
                    me.actionsView
                ]
            }
        ];
        me.on('afterrender', me.onAfterRender, me);
        me.callParent();
    },
    /**
     *  ,       - ,   .
     * @return {Ext.Panel}
     */
    getInfoPanel: function() {
        return this.getComponent('info');
    },
    /**
     *  ,     
     * @return {Ext.Panel}
     */
    getContentPanel: function() {
        var me = this,
            contentCt = me.getComponent('content-container');
        if (contentCt) {
            return contentCt.getComponent('content');
        } else {
            return null;
        }
    },
    /**
     *   
     * @param {Object} data
     */
    setInfo: function(data) {
        var me = this,
            infoPanel = me.getInfoPanel();
        if (infoPanel) {
            infoPanel.update(data);
        }
    },
    /**
     *   
     * @param {Object} data ,    tpl  html
     */
    setContent: function(data) {
        var me = this,
            contentPanel = me.getContentPanel(),
            text = Ext.create('ExGods.view.Template', me.tplForContent).apply(data);
        if (contentPanel) {
            contentPanel.body.setHTML(text);
            contentPanel.scroller.onResize();
        }
    },
    /**
     *   
     * @param {Html} text     
     *
     */
    addContent: function(text) {
        var me = this,
            contentPanel = me.getContentPanel();
        if (contentPanel) {
            contentPanel.body.setHTML(contentPanel.body.getHTML() + text);
            contentPanel.scroller.onResize();
            contentPanel.scroller.scrollToBottom();
        }
    },
    /**
     *  
     * @param {Object} newSettings     
     */
    updateData: function(newSettings) {
        if (newSettings.info)  {
            this.setInfo(newSettings.info);
        }
        
        if (newSettings.data)  {
            this.setContent(newSettings.data);
        }
        
        if (newSettings.actions)  {
            this.actionsView.setActions(newSettings.actions);
        }
        
    },
    /**
     * @private
     */
    onAfterRender: function() {
        var me = this;
    }
});
//       
//        -   
//      me.getEl().on('click', function(e, t) {
//          var el = Ext.get(t),
//              item;
//
//          if (item  = e.getTarget('.item')) {
//              ExGods.app.fireEvent('itemclick', {
//                  itemEl: item,
//                  proto_id: parseInt(item.getAttribute('data-proto_id')),
//                  maskCt: el.up('.x-container')
//              });
//          }
//
//      });

/**
 *      
 */
Ext.define('ExGods.view.dialog.BotInfoDialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.bot_info_dialog',
    layout: 'fit',
    closable: true,
    width: 620,
    height: 430,
    y: 95,
    x: 223,
    plugins: [
        'skindeco'
    ],
    cls: 'bot-dialog',
    bodyPadding: '7 8 4 6',
    initComponent: function() {
        var me = this,
            protos = ExGods.app.getItemPrototypesStore(),
            items = curency = '',
            missedProtos = [],
            stuff_length = me.config.data.description_stuff.length;
        //   
        //me.config.data.description_stuff = me.config.data.description_stuff.concat(me.config.prize );
        //me.config.data.description_stuff = me.config.data.description_stuff.concat(me.config.prize );
        me.right_width = 350;
        //    
        if (stuff_length > 5) {
            //   ,   
            me.right_width = stuff_length * 70;
            //   
            me.width = 270 + me.right_width;
            //   (  + )
            me.x = (1000 - me.width) / 2;
        }
        //  (  -       2)
        var me = this,
            descrHeight = 270,
            bigPrize;
        me.config.data.name_with_level = ExGods.printUser({
            hoard: {
                level: me.config.data.level
            },
            display_title: me.config.data.title
        }, {
            fields: 'level,name',
            maxNameWidth: '180'
        });
        me.config.data.image = ExGodsCore.app.references.get('user_shape').getByKey(me.config.data.shape).full;
        if (me.config.prize) {
            descrHeight = 158;
            bigPrize = [
                '<div class="paper-title">' + ExGods.getMsgByKey('view_dialog_botinfodialog_banish') + '</div>',
                '<div class="npc_stuff_2 npc_bigPrize"></div>'
            ].join('');
        }
        me.tplForContent = [
            '<div class="paper-title">' + ExGods.getMsgByKey('view_dialog_botinfodialog_title') + '</div>',
            '<div class="description" style="height: ' + descrHeight + 'px;">',
            me.config.description,
            '</div>',
            bigPrize,
            '<div class="paper-title">' + ExGods.getMsgByKey('view_dialog_botinfodialog_attack') + '</div>',
            '<div class="npc_stuff_2 npc_bigItems"></div>'
        ].join('');
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                layout: 'absolute',
                height: 418,
                items: [
                    {
                        itemId: 'info',
                        cls: 'dialog-info',
                        style: {
                            borderRight: '1px solid #7d4b2a'
                        },
                        width: 230,
                        height: 399,
                        y: 7,
                        x: 11,
                        tpl: new Ext.Template('<div class="paper-title">{name_with_level}</div>', '<div class="frame"></div>', '<div class="image" style="background-image: url({image})">', '</div>', '<div class="user_stats_image">', ExGods.util.User.printUserStats(me.config.data.stats, {
                            visibleValue: 2
                        }), '</div>'),
                        data: me.config.data
                    },
                    {
                        itemId: 'content-container',
                        width: me.right_width,
                        height: 399,
                        style: {
                            borderLeft: '1px solid #7d4b2a'
                        },
                        x: 245,
                        y: 7,
                        items: [
                            {
                                itemId: 'content',
                                autoScroll: true,
                                cls: 'dialog-content',
                                // plugins: [{
                                //  animate: false,
                                //  autoHide: false,
                                //  padding: '14 0 0 0',
                                //  ptype: 'scroller',
                                //  scrollDeltaY: 16
                                // }],
                                html: me.tplForContent
                            }
                        ]
                    },
                    {
                        itemId: 'v-separator',
                        width: 10,
                        height: 407,
                        html: '<div class="v-separator"></div>',
                        x: 240,
                        y: 0
                    },
                    {
                        itemId: 'separator',
                        width: me.right_width + 1,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 295
                    },
                    {
                        itemId: 'separator-2',
                        width: me.right_width + 1,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 184,
                        hidden: !bigPrize
                    }
                ]
            }
        ];
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.config.data.description_stuff) {
            stuff_arr = stuff_arr.concat(me.config.data.description_stuff);
        }
        if (me.config.data.prize) {
            stuff_arr = stuff_arr.concat(me.config.data.prize);
        }
        return {
            stuff: stuff_arr,
            images: [
                me.config.data.image
            ].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.dialog.BotDialog', {
    extend: Ext.panel.Panel,
    alias: 'widget.botdialog',
    cls: 'bot-dialog',
    bodyPadding: '7 8 0 6',
    id: 'BotDialogPanel',
    initComponent: function() {
        var me = this;
        me.tplForContent = [
            '<div class="paper-title">' + me.info.bot_power_text + '</div>',
            '<div class="description">' + me.info.description + '</div>',
            '<div class="separator"></div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('dialog_reward_can') + '</div>',
            '<div class="npc_stuff_2">{[this.methodGetStuff()]}</div>'
        ].join('');
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                layout: 'absolute',
                height: 370,
                items: [
                    {
                        itemId: 'info',
                        cls: 'dialog-info',
                        style: {
                            borderRight: '1px solid #7d4b2a'
                        },
                        width: 230,
                        height: 350,
                        y: 7,
                        x: 11,
                        tpl: new Ext.XTemplate('<div class="paper-title">{name_with_level}</div>', '<div class="frame"></div>', '<div class="image bot-info-stats-container" style="background-image: url({image})">', '<tpl if="this.isInfo()">', '<div class="paper paper-bg"></div>', '<div class="avatar-info-container">', '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>', '<div class="avatar-params stats-list">', '{[ ExGods.util.User.printUserStats(values.stats, {visibleValue: 1, align: "right"}) ]}', '</div>', '<div class="paper-separator"></div>', '<div class="avatar-statsstars">', '{[ ExGods.util.User.printUserStats(values.stats, {visibleValue: 2}) ]}', '</div>', '</div>', '</tpl>', '</div>', {
                            isInfo: function() {
                                return me.isInfo;
                            }
                        }),
                        data: me.info
                    },
                    {
                        itemId: 'content-container',
                        width: 510,
                        height: 350,
                        style: {
                            borderLeft: '1px solid #7d4b2a'
                        },
                        x: 245,
                        y: 7,
                        items: [
                            {
                                itemId: 'content',
                                autoScroll: true,
                                cls: 'dialog-content',
                                tpl: [
                                    me.tplForContent,
                                    {
                                        methodGetStuff: function() {
                                            if (!Ext.isArray(me.info.stuff)) {
                                                me.info.stuff = [
                                                    me.info.stuff
                                                ];
                                            }
                                            var img_stuff_html = Ext.Array.map(me.info.stuff, function(stuff) {
                                                    return ExGods.stuff.StuffManager.image(stuff);
                                                }).join('');
                                            return img_stuff_html;
                                        }
                                    }
                                ],
                                data: {}
                            }
                        ]
                    },
                    {
                        itemId: 'v-separator',
                        width: 10,
                        height: 358,
                        html: '<div class="v-separator"></div>',
                        x: 240,
                        y: 0
                    },
                    {
                        itemId: 'separator',
                        width: 511,
                        height: 10,
                        html: '<div class="separator"></div>',
                        x: 245,
                        y: 246
                    }
                ]
            },
            {
                xtype: 'container',
                style: {
                    padding: '0 0 0 385px',
                    height: '47px'
                },
                items: me.actionsView
            }
        ];
        me.callParent();
        me.on('afterrender', function(cmp) {
            var btn = cmp.down('#attack_button');
            if (btn) {
                btn.el.set({
                    'data-qh_otype': 'bot_button_attack',
                    'data-qh_oid': me.speaker.data.bot_type
                });
            }
            btn = cmp.down('#banish_button');
            if (btn) {
                btn.el.set({
                    'data-qh_otype': 'bot_button_banish',
                    'data-qh_oid': me.speaker.data.bot_type,
                    'data-qh_opts': "{&quot;cls&quot;:&quot;flip-h&quot;}"
                });
            }
            me.el.on('click', function() {
                me.isInfo = !me.isInfo;
                me.onInfoChange();
            }, me, {
                delegate: '.info-btn'
            });
        });
    },
    onInfoChange: function() {
        var me = this;
        if (me.rendered) {
            me.down('#info').update(me.info);
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var obj = ExGods.ref('images|bot_dialog_images').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        return {
            stuff: me.info.stuff,
            images: [
                me.info.image,
                IMAGE_URL + 'button-text-30.png',
                //  
                IMAGE_URL + 'btn_wide_red.png'
            ].concat(arr_images)
        };
    }
});

(function() {
    /**
     *   
     */
    Ext.define('ExGods.view.dialog.DailyBonusDialog', {
        extend: Ext.panel.Panel,
        alias: 'widget.dialog_daily_bonus',
        defaultConfig: {
            btnText: 'OK',
            btnColor: '',
            backImg: '',
            selectedIndex: 1
        },
        layout: 'fit',
        bodyPadding: '7 8 4 6',
        cls: 'dialog_daily_bonus',
        /** @cfg */
        config: {},
        rewards: [],
        buttonClickHandler: Ext.emptyFn,
        initComponent: function() {
            var me = this,
                rewardsPanel, currentPage;
            me.config = Ext.applyIf(me.config || {}, me.defaultConfig);
            me.config.selectedIndex = me.rewards.length < me.config.selectedIndex ? me.rewards.length : parseInt(me.config.selectedIndex);
            currentPage = Math.ceil(me.config.selectedIndex / 10);
            rewardsPanel = new RewardsPanel({
                selectedIndex: me.config.selectedIndex,
                totalCount: me.rewards.length,
                rewardsData: me.rewards.slice((currentPage - 1) * 10, (currentPage - 1) * 10 + 10)
            });
            me.items = [
                {
                    xtype: 'container',
                    layout: 'absolute',
                    plugins: [
                        'paperdeco'
                    ],
                    items: [
                        {
                            xtype: 'component',
                            cls: 'image-wrap',
                            html: '<div class="frame"></div><div class="image" style="background-image: url(' + IMAGE_URL + me.config.backImg + ')"></div>'
                        },
                        {
                            xtype: 'component',
                            width: '99%',
                            height: 4,
                            html: '<div class="separator"></div>',
                            x: 4,
                            y: 252
                        },
                        {
                            xtype: 'container',
                            itemId: 'rewardsPanelCt',
                            layout: 'fit',
                            width: '100%',
                            y: 265,
                            x: 15,
                            margin: '-5 0 0 0',
                            items: [
                                rewardsPanel
                            ]
                        },
                        {
                            xtype: 'component',
                            cls: 'title_1',
                            style: {
                                background: 'url(' + ExGods.ref('images|daily_bonus').image.title_1 + ') 50% 4px no-repeat, url(' + IMAGE_URL + 'dialog_daily_bonus/flag1.png) no-repeat 0 0, url(' + IMAGE_URL + 'dialog_daily_bonus/flag3.png) 100% 0 no-repeat'
                            },
                            x: 178,
                            y: 28
                        },
                        {
                            xtype: 'component',
                            cls: 'title_2',
                            style: {
                                backgroundImage: 'url(' + ExGods.ref('images|daily_bonus').image.title_2 + ')'
                            },
                            x: 190,
                            y: 203
                        }
                    ]
                }
            ];
            me.bbar = {
                items: [
                    {
                        xtype: 'textbutton',
                        text: me.config.btnText,
                        cls: (me.config.btnColor) ? 'x-btn-txt-' + me.config.btnColor : '',
                        handler: me.buttonClickHandler
                    }
                ],
                layout: {
                    pack: 'center'
                },
                margin: '-5 0 12 0'
            };
            me.plugins = me.plugins || [];
            me.plugins.push({
                ptype: 'pager',
                marginLeft: -27,
                marginRight: -27,
                top: 304,
                current: currentPage,
                total: Math.ceil(me.rewards.length / 10)
            });
            me.listeners = {
                prev: me.updateRewardsPanel,
                next: me.updateRewardsPanel,
                scope: me
            };
            me.callParent(arguments);
        },
        updateRewardsPanel: function(pager) {
            var me = this,
                rewardsPanel, ct;
            rewardsPanel = new RewardsPanel({
                selectedIndex: me.config.selectedIndex,
                totalCount: me.rewards.length,
                rewardsData: me.rewards.slice((pager.current - 1) * 10, (pager.current - 1) * 10 + 10)
            });
            ct = me.items.items[0].getComponent('rewardsPanelCt');
            ct.removeAll();
            ct.add(rewardsPanel);
            pager.refresh();
        },
        /**
     *   
     */
        getResources: function() {
            var me = this,
                stuff_arr = [],
                arr_images = [];
            stuff_arr = stuff_arr.concat(me.rewards);
            var imgs = ExGods.ref('images|daily_bonus').image;
            for (var it in imgs) {
                arr_images.push(imgs[it]);
            }
            return {
                stuff: stuff_arr,
                images: [].concat(arr_images)
            };
        }
    });
    /**
     *  Private class
     */
    var RewardsPanel = Ext.define(null, {
            extend: 'Ext.panel.Panel',
            selectedIndex: 1,
            totalCount: 1,
            initComponent: function() {
                var me = this;
                me.config = Ext.applyIf(me.config, {
                    selectedIndex: 1,
                    totalCount: 1
                });
                me.data = me.config.rewardsData;
                me.tpl = [
                    '<div class="daily-rewards">',
                    '<tpl for=".">',
                    '{[this.printReward(values)]}',
                    '</tpl>',
                    '</div>',
                    {
                        printReward: function(values) {
                            return ExGods.stuff.StuffManager.image({
                                type: 'daily_bonus',
                                selected: values.login_day_index == me.config.selectedIndex,
                                taken: values.login_day_index < me.config.selectedIndex,
                                params: {
                                    stuff: Ext.apply({
                                        fin: values.login_day_index == me.config.totalCount
                                    }, values)
                                }
                            });
                        }
                    }
                ];
                me.callParent(arguments);
            },
            afterRender: function() {
                var me = this;
                me.callParent();
                var onClick = function(e, el) {
                        var item = Ext.fly(el).parent().down('.item img');
                        if (item) {
                            item.el.dom.click();
                        }
                    };
                me.el.on('click', onClick, me, {
                    delegate: '.label'
                });
                me.el.on('click', onClick, me, {
                    delegate: '.taken-mask'
                });
                me.el.on('click', onClick, me, {
                    delegate: '.selected-frame'
                });
            }
        });
}());

/**
 *    
 */
Ext.define('ExGods.view.dialog.List', {
    extend: Ext.view.View,
    alias: 'widget.dialoglist',
    autoEl: {
        tag: 'ul',
        cls: 'quest-dialogs parchment-content parchment-content-nop'
    },
    cls: 'parchment-content parchment-content-nop',
    deferInitialRefresh: false,
    dock: 'bottom',
    itemSelector: 'li',
    /**
     * @cfg {ExGods.store.Quests} quests (required)
     *   
     */
    style: {
        border: '0 !important'
    },
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<tpl for=".">',
            '<li>',
            '<img src="{[this.getIcon(values.action.qid, values.action, values.image)]}" /> {name}',
            '</li>',
            '</tpl>',
            {
                icons: ExGods.references.get('images').get('dialogue_icons').image,
                quests: me.quests,
                getIcon: function(qid, action, image) {
                    var cmd = action.cmd,
                        src = image,
                        icons = this.icons;
                    if (src)  {
                        return IMAGE_URL + src;
                    }
                    
                    switch (cmd) {
                        case 'check_quest_aims':
                            //   
                            src = icons.point;
                            break;
                        case 'list':
                            //  
                            src = icons.dialogue_end;
                            break;
                        case 'point':
                            //   
                            src = icons.point;
                            break;
                        case 'prize':
                            //  
                            src = icons.give_prize;
                            break;
                        case 'quest':
                            var quests = this.quests.snapshot ? this.quests.snapshot : this.quests.data,
                                quest = quests.getByKey(qid);
                            //   
                            src = icons.add_quest;
                            if (quest) {
                                //status = 0 - 
                                //status = 2 - 
                                // -  
                                switch (quest.get('status')) {
                                    case 0:
                                        src = icons.add_quest;
                                        break;
                                    case 2:
                                        src = icons.complete_quest;
                                        break;
                                    default:
                                        src = icons.point;
                                        break;
                                }
                            };
                            break;
                        case 'random_point':
                            //    
                            src = icons.make;
                            break;
                        case 'shops':
                            //  
                            src = icons.trade;
                            break;
                        case 'user_handler':
                            //     
                            src = icons.user_actions;
                            break;
                        default:
                            //src = Ext.BLANK_IMAGE_URL;
                            src = icons.point;
                            break;
                    }
                    return src;
                }
            }
        ];
        me.callParent();
    }
});

/**
 *   actions .
 *
 *    actions  Dialog view
 *    NPC
 *
 * @author  
 *
 */
Ext.define('ExGods.view.dialog.NpcActions', {
    extend: Ext.panel.Panel,
    alias: 'widget.npc_actions',
    itemId: 'npc-actions-container',
    dock: 'bottom',
    margin: '4 0 0 0',
    height: 122,
    style: {
        border: '1px solid #907041 !important'
    },
    plugins: [
        {
            ptype: 'scroller',
            animate: true,
            autoHide: true,
            snap: 'li',
            scrollDeltaY: 24
        }
    ],
    defaults: {
        anchor: '100%'
    },
    layout: 'anchor',
    initComponent: function() {
        var me = this;
        me.callParent();
    },
    /**
     * ,      ,    
     * @private
     *
     * @param {Array} store    (   )
     *
     * @return {Boolean}
     */
    isBattlePoint: function(store) {
        var index = store.findBy(function(point) {
                if (point.get('action').cmd == 'battle')  {
                    return true;
                }
                
            });
        return index == -1 ? false : true;
    },
    /**
     *    
     * @param {Array} store    (   )
     */
    setActions: function(store) {
        var me = this;
        me.removeAll();
        if (me.isBattlePoint(store)) {
            var battlePoints = [];
            store.each(function(point) {
                if (point.get('action').cmd == 'battle')  {
                    battlePoints.push({
                        point: point,
                        text: point.get('name'),
                        name: 'action-button',
                        xtype: 'textbutton'
                    });
                }
                
            });
            me.add({
                xtype: 'container',
                defaults: {
                    anchor: '100%'
                },
                items: battlePoints,
                layout: 'anchor'
            });
        } else {
            me.add({
                xtype: 'dialoglist',
                quests: me.quests,
                store: store
            });
        }
    }
});

/**
 *  
 */
Ext.define('ExGods.model.Quest', {
    extend: Ext.data.Model,
    idProperty: 'proto_id',
    aimCounterInterval: {},
    statics: {
        /**
         * @property
         * @static
         *     ,    
         */
        VIRGIN: -1,
        /**
         * @property
         * @static
         *  
         */
        NOT_ACTIVE: 0,
        /**
         * @property
         * @static
         *   (  )
         */
        ACTIVE: 1,
        /**
         * @property
         * @static
         *  ( )
         */
        READY_TO_COMPLETE: 2,
        /**
         * @property
         * @static
         *  ()
         */
        COMPLETE: 3,
        /**
         * @property
         * @static
         * 
         */
        FAILED: 4,
        /**
         * @property
         * @static
         * 
         */
        ARCHIVE: 5
    },
    fields: [
        {
            name: 'aims',
            type: 'auto',
            convert: function(aims, record) {
                //       (stage)
                if (aims) {
                    Ext.Array.sort(aims, function(a, b) {
                        var stage1 = parseInt(a.stage);
                        var stage2 = parseInt(b.stage);
                        if (stage1 == stage2) {
                            return 0;
                        }
                        return stage1 > stage2 ? 1 : -1;
                    });
                    Ext.each(aims, function(aim, aim_index) {
                        if (aim.counter) {
                            Ext.each(aim.counter, function(counter, index) {
                                if (counter.type == 1) {
                                    counter.left = parseInt(counter.need) - parseInt(counter.curr);
                                    if (counter.left > 0) {
                                        if (record.aimCounterInterval['aimcounter_' + aim_index + '_' + index]) {
                                            clearInterval(record.aimCounterInterval['aimcounter_' + aim_index + '_' + index]);
                                        }
                                        record.aimCounterInterval['aimcounter_' + aim_index + '_' + index] = setInterval(function() {
                                            counter.left--;
                                            if (counter.left <= 0) {
                                                clearInterval(record.aimCounterInterval['aimcounter_' + aim_index + '_' + index]);
                                            }
                                            record.fireEvent('aimcounter_' + aim_index + '_' + index, counter.left, record);
                                        }, 1000);
                                    }
                                }
                            });
                        }
                    });
                }
                return aims;
            }
        },
        {
            name: 'desc',
            mapping: 'params.desc',
            type: 'string'
        },
        {
            //   
            name: 'droppable',
            mapping: 'params.droppable',
            convert: function(v, rec) {
                var status = rec.get('status');
                return v && (status == ExGods.model.Quest.ACTIVE || status == ExGods.model.Quest.READY_TO_COMPLETE);
            },
            type: 'int'
        },
        {
            name: 'energy',
            mapping: 'params.energy',
            type: 'int'
        },
        {
            name: 'expanded',
            type: 'auto'
        },
        {
            mapping: 'object.data',
            name: 'giver',
            type: 'auto'
        },
        {
            mapping: 'object.object_type',
            name: 'giver_type',
            type: 'auto'
        },
        {
            //     
            name: 'level',
            mapping: 'params.level',
            type: 'int'
        },
        {
            //  
            name: 'marks',
            type: 'auto',
            defaultValue: []
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            //   ,   
            name: 'object_id',
            type: 'int'
        },
        {
            name: 'proto_id',
            type: 'int'
        },
        {
            name: 'repeat',
            mapping: 'params.repeat',
            type: 'string'
        },
        {
            name: 'random_rewards',
            type: 'auto'
        },
        {
            name: 'reroll_stuff',
            type: 'auto'
        },
        {
            name: 'rewards',
            type: 'auto'
        },
        {
            //   
            name: 'stage',
            type: 'int'
        },
        {
            /*
         * -1 -     ,    
         *  0 - 
         *  1 -  (  )
         *  2 -  ( )
         *  3 -  ()
         *  4 - 
         *  5 - 
         */
            name: 'status',
            type: 'int'
        },
        {
            name: 'story',
            mapping: 'params.story',
            type: 'int'
        },
        {
            mapping: 'params.timeout',
            name: 'timeout',
            type: 'string'
        },
        {
            //      
            name: 'timedropfrom',
            type: 'int'
        },
        {
            /*
         * TIMESTAMP   
         */
            name: 'timeopen',
            type: 'int'
        },
        {
            //      
            name: 'timerest',
            type: 'int'
        },
        {
            // 0 -   , 1 - 
            name: 'traced',
            type: 'int',
            defaultValue: 0
        },
        {
            // 
            name: 'params',
            type: 'auto'
        },
        {
            name: 'give_confirm_text',
            type: 'string'
        },
        {
            name: 'take_confirm_text',
            type: 'string'
        }
    ],
    constructor: function(data, id, raw, convertedData) {
        var me = this;
        me.callParent(arguments);
        if (raw || data) {
            me.updateTimerestInterval((raw || data).timerest);
            me.updateDropInterval((raw || data).timedropfrom);
        }
    },
    /**
     *    
     * @private
     */
    afterEdit: function() {
        var me = this;
        var changes = me.getChanges();
        // TODO: ,     
        me.processChanges(changes);
    },
    processChanges: function(changes) {
        var me = this;
        if (changes.timerest) {
            me.updateTimerestInterval(changes.timerest);
        }
        if (changes.timedropfrom) {
            me.updateDropInterval(changes.timedropfrom);
        }
    },
    updateTimerestInterval: function(timerest) {
        var me = this;
        me.updateInterval = me.updateInterval || {};
        if (me.updateInterval['timerest']) {
            clearInterval(me.updateInterval['timerest']);
            me.updateInterval['timerest'] = 0;
        }
        if (timerest > 0) {
            me.updateInterval['timerest'] = setInterval(function() {
                me.data.timerest--;
                if (me.data.timerest <= 0) {
                    //me.loadRemote();
                    clearInterval(me.updateInterval['timerest']);
                }
            }, 1000);
        }
    },
    updateDropInterval: function(timedropfrom) {
        var me = this,
            i = 0;
        me.updateInterval = me.updateInterval || {};
        if (me.updateInterval['timedropfrom']) {
            clearInterval(me.updateInterval['timedropfrom']);
            me.updateInterval['timedropfrom'] = 0;
        }
        if (timedropfrom > 0) {
            me.updateInterval['timedropfrom'] = setInterval(function() {
                me.data.timedropfrom--;
                if (me.data.timedropfrom <= 0) {
                    for (; i < me.stores.length; i++) {
                        me.stores[i].remove(me);
                    }
                    clearInterval(me.updateInterval['timedropfrom']);
                }
                me.fireEvent('timedropchanged', me.data.timedropfrom, me);
            }, 1000);
        }
    },
    /**
     *        id
     */
    loadRemote: function() {
        var me = this;
        Ext.Ajax.request({
            url: HOST_URL + '/game.pl?cmd=quest',
            params: {
                qid: me.get('proto_id')
            },
            success: function(response) {
                var result = Ext.decode(response.responseText, true);
                if (result) {
                    me.set(result);
                }
            }
        });
    },
    /*
     *  true,      
     */
    isTraceable: function() {
        return this.get('params').traced && (this.get('status') == this.self.ACTIVE || this.get('status') == this.self.READY_TO_COMPLETE);
    },
    /**
     *  true,   
     */
    isTraced: function() {
        var me = this;
        return me.get('proto_id') == ExGods.app.user.get('trace_quest_proto');
    },
    /**
     *     
     */
    getGiveConfirmation: function() {
        var me = this,
            params = me.get('params');
        if (params.is_give_confirmed == 1) {
            return me.get('give_confirm_text');
        } else {
            return '';
        }
    },
    /**
     *     
     */
    getTakeConfirmation: function() {
        var me = this,
            params = me.get('params');
        if (params.is_take_confirmed == 1) {
            return me.get('take_confirm_text');
        } else {
            return '';
        }
    },
    /**
     *   -
     */
    getGiverThumb: function() {
        var me = this,
            shapes = ExGods.references.get('user_shape');
        if (me.data.giver && me.data.giver.shape) {
            return shapes.getByKey(me.data.giver.shape).thumb;
        } else if (me.data.giver && me.data.giver.image_thumb) {
            //  giver 
            return IMAGE_URL + me.data.giver.image_thumb;
        } else if (me.data.giver && me.data.giver.icon) {
            //  giver 
            return IMAGE_URL + me.data.giver.icon;
        } else if (me.data.params && me.data.params.image) {
            return IMAGE_URL + me.data.params.image;
        } else {
            return Ext.BLANK_IMAGE_URL;
        }
    }
});

/**
 *  
 */
Ext.define('ExGods.store.Quests', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Quest',
    id: 'quests',
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        /**
         *     3 (      )  0 ( )
         * datachanged      
         */
        me.on('datachanged', function() {
            var records = this.queryBy(function(record, id) {
                    return record.get('status') === 3 || record.get('status') === 0;
                });
            records.each(function(item) {
                me.remove(item);
            }, me);
        });
        /**
         * update     
         */
        me.on('update', function() {
            var records = this.queryBy(function(record, id) {
                    return record.get('status') === 3 || record.get('status') === 0;
                });
            records.each(function(item) {
                me.remove(item);
            }, me);
        });
    },
    sorters: [
        {
            sorterFn: function(a, b) {
                var ret = 0;
                if (a.get('story') == 3 && b.get('story') != 3)  {
                    ret = -1;
                }
                
                if (b.get('story') == 3 && a.get('story') != 3)  {
                    ret = 1;
                }
                
                if (!a.get('repeat') && !a.get('timeout') && a.get('story') == 1 && (b.get('repeat') || b.get('timeout') || b.get('story') != 1))  {
                    ret = -1;
                }
                
                if (!b.get('repeat') && !b.get('timeout') && b.get('story') == 1 && (a.get('repeat') || a.get('timeout') || a.get('story') != 1))  {
                    ret = 1;
                }
                
                if (a.get('status') == 2 && b.get('status') != 2)  {
                    ret = -1;
                }
                
                if (b.get('status') == 2 && a.get('status') != 2)  {
                    ret = 1;
                }
                
                return ret;
            }
        }
    ]
});
// proxy: {
//  type: 'ajax',
//  url: '/game.pl?cmd=quests.current',
//  limitParam: false,
//  pageParam: false,
//  startParam: false,
//  reader: {
//      type: 'json',
//      rootProperty: 'quests'
//  }
// }

/**
 *  
 *
 *       .
 */
Ext.define('ExGods.controller.Dialog', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        }
    },
    stores: [
        'Quests'
    ],
    views: [
        'dialog.Dialog',
        'dialog.List',
        'dialog.NpcActions',
        'dialog.BotInfoDialog',
        'dialog.BotDialog',
        'dialog.RewardsDialog',
        'dialog.DailyBonusDialog'
    ],
    refs: [
        {
            /**
         * @method getMain
         *   
         * @return {Ext.container.Container}
         */
            ref: 'main',
            selector: '#main'
        },
        {
            /**
         * @method getDialog
         */
            ref: 'dialog',
            selector: '#npc-dialog'
        },
        {
            /**
         * @method getBanish
         */
            ref: 'banish',
            selector: '#banish_button'
        }
    ],
    /**
     * @property {Object} speaker
     * 
     */
    popups_enabled: true,
    popups_queue: [],
    init: function() {
        var me = this;
        me.control({
            '#LOB_BOT_LIST': {
                itemclick: {
                    fn: me.onBotClick,
                    delay: 0
                }
            },
            'npc_actions button[name="action-button"]': {
                click: me.onNpcActionButtonClick
            },
            'dialoglist': {
                itemclick: {
                    fn: me.onPointClick,
                    delay: 0
                }
            },
            '#battle-result': {
                destroy: {
                    fn: me.showPopups,
                    delay: 100
                }
            }
        });
        ExGods.stuff.StuffManager.register({
            'daily_bonus': ExGods.view.dialog.stuff.DailyBonus,
            'dialog_rewards': ExGods.view.dialog.stuff.Rewards
        });
        ExGods.Components.addComponentInitializer('dialog', me.initDialogComponent, me);
        ExGods.Components.addComponentInitializer('dialog_rewards', me.initDialogRewardsComponent, me);
        ExGods.Components.addComponentInitializer('dialog_daily_bonus', me.initDialogDailyBonusComponent, me);
        ExGods.Components.addComponentInitializer('dialog_confirm', me.initDialogConfirmComponent, me);
        ExGods.Components.addComponentInitializer('dialog_bot_info', me.initBotInfoComponent, me);
        me.app.getChatConnection().on({
            command_popup: me.onPopupCommand,
            scope: me
        });
    },
    onPopupCommand: function(chatcn, data) {
        var me = this,
            component = ExGods.Components.factory(data.body.popup, {
                popup_params: data.body.params
            });
        if (component && !component.error) {
            if (!me.isBattle()) {
                component.show();
            } else {
                me.popups_queue.push(component);
            }
        }
    },
    isBattle: function() {
        var me = this;
        return me.user.isBattle() || me.app.getController('battle.BattleView').isRendered() || Ext.getCmp('battle-result');
    },
    showPopups: function() {
        var me = this,
            i = me.popups_queue.length;
        while (i--) {
            if (me.popups_queue[i])  {
                me.popups_queue[i].show();
            }
            
            me.popups_queue.splice(i, 1);
        }
    },
    /**
     * @private
     *    
     * 
     * @param {Ext.grid.View} view    
     * @param {ExGods.model.Monster} bot       
     */
    onBotClick: function(view, bot) {
        var me = this;
        if (!bot.data.chain) {
            //    (   . )
            me.showBotDialog({
                image: ExGodsCore.app.references.get('user_shape').getByKey(bot.get('shape')).full,
                description: bot.get('description') || ' ',
                stuff: bot.get('stuff') || ' ',
                stats: bot.get('bot_stats'),
                level: bot.get('level'),
                sec_to_banish: Math.ceil(((bot.data.last_banish + bot.data.cooldown_banish + 1 + ExGods.util.Date.serverTimeOffset) * 1000 - new Date())),
                name_with_level: ExGods.printUser({
                    hoard: {
                        level: bot.get('level')
                    },
                    display_title: bot.get('label')
                }, {
                    fields: 'level,name',
                    maxNameWidth: '180'
                })
            }, false, bot);
        }
    },
    showBotDialog: function(infoData, requestOptions, speaker) {
        var me = this,
            params = {
                ekey: speaker.get('entry')
            },
            source = speaker.get('source'),
            surging = me.app.getController('Surging'),
            location = me.app.getController('Location'),
            callback = function(json) {
                var botList = Ext.getCmp('LOB_BOT_LIST');
                me.dialog.close();
                if (botList && json && json.stuffs) {
                    botList.animatePrize(speaker.get('entry'), json.stuffs, function() {
                        location.unlockUpdate();
                    });
                } else {
                    location.unlockUpdate();
                }
            },
            attackHandlerFn = function() {
                surging.service.command('battle_bot_surging', params, callback);
            },
            surgingHandlerFn = function() {
                location.lockUpdate();
                ExGods.app.block();
                surging.service.command('banish_bot', params, function(json) {
                    ExGods.app.unblock();
                    callback(json);
                });
            },
            bot_power,
            printBotPower = function(stats, level) {
                var userStats = ExGods.app.getUser().get('stats').stats,
                    powers = [],
                    maxStatPower = parseInt(ExGods.ref('constants|max_stat_power').value),
                    minStatPower = parseInt(ExGods.ref('constants|min_stat_power').value),
                    maxLevelPower = parseInt(ExGods.ref('constants|max_level_power').value),
                    minLevelPower = parseInt(ExGods.ref('constants|min_level_power').value),
                    deltaA = stats.agility - userStats.accuracy,
                    deltaB = stats.stamina - userStats.strength,
                    deltaLvl = level - ExGods.app.getUser().get('hoard').level;
                /**
                 *      
                 *  >= X -  
                 * Y <=  < X -  
                 *  < Y -  
                 *      
                 *  >= X -  
                 * Y <=  < X -  
                 *  < Y -  
                 *     
                 *  >= M -  
                 * N <=  < M -  
                 *  < N -  
                 *        .
                 */
                if (deltaA >= maxStatPower) {
                    powers.push(2);
                } else if (deltaA >= minStatPower) {
                    powers.push(1);
                } else {
                    powers.push(0);
                }
                if (deltaB >= maxStatPower) {
                    powers.push(2);
                } else if (deltaB >= minStatPower) {
                    powers.push(1);
                } else {
                    powers.push(0);
                }
                if (deltaLvl >= maxLevelPower) {
                    powers.push(2);
                } else if (deltaLvl >= minLevelPower) {
                    powers.push(1);
                } else {
                    powers.push(0);
                }
                powers = powers.sort();
                var power = bot_power = powers[powers.length - 1];
                if (power == 2) {
                    return '<span style="color:#c6240d">' + ExGods.getMsgByKey('ctrl_dialog_hard_bot') + '</span>';
                } else if (power == 1) {
                    return '<span style="color:#000">' + ExGods.getMsgByKey('ctrl_dialog_normal_bot') + '</span>';
                } else {
                    return '<span style="color:green">' + ExGods.getMsgByKey('ctrl_dialog_easy_bot') + '</span>';
                }
            };
        // source = quest_... -    -    
        if (source.substr(0, 5) == 'quest') {
            attackHandlerFn = function() {
                ExGods.Services.get('location').command('attack_quest_bot', params, function(result) {
                    if (result.success) {
                        callback(result);
                    }
                });
            };
            surgingHandlerFn = function() {
                location.lockUpdate();
                ExGods.Services.get('location').command('banish_quest_bot', params, function(result) {
                    if (result.success) {
                        callback(result);
                    }
                });
            };
        }
        var reward_banish = '',
            userMoney = Ext.clone(me.user.get('money'));
        if (speaker.get('reward_banish').length)  {
            reward_banish = '(+ ' + ExGods.util.Stuff.printStuff(speaker.get('reward_banish')[0][0]) + ')';
        }
        
        if (infoData.stats)  {
            infoData.bot_power_text = printBotPower(infoData.stats, infoData.level);
        }
        
        var actionView = [
                {
                    xtype: 'textbutton',
                    cls: 'qh-object double_text_btn x-btn-txt-red',
                    itemId: 'attack_button',
                    margin: '0 0 0 -105',
                    text: speaker.get('battle_id') > 0 ? '<div class="text-btn-image" style="background-image:url(' + ExGods.ref('images|bot_dialog_images').image['text_interfere'] + ')"></div>' : '<div class="text-btn-image" style="background-image:url(' + ExGods.ref('images|bot_dialog_images').image['text_attack'] + ')"></div>',
                    disabled: speaker.get('battle_enable') == 1 ? false : true,
                    handler: bot_power == 2 ? function() {
                        Ext.widget('confirmdialog', {
                            title: '',
                            message: ExGods.ref('message_client|powerful_bot'),
                            handler: attackHandlerFn
                        });
                    } : attackHandlerFn
                },
                {
                    xtype: 'textbutton',
                    margin: '0 0 0 15',
                    text: '<div class="text-btn-image" style="background-image:url(' + ExGods.ref('images|bot_dialog_images').image['text_drive_away'] + ')"></div>',
                    cls: 'qh-object double_text_btn double_text',
                    itemId: 'banish_button',
                    disabled: (infoData.sec_to_banish > 0 || speaker.get('banish_enable') != 1) ? true : false,
                    handler: surgingHandlerFn
                }
            ];
        //      var qh_pointers_attack =
        //          {
        //              xtype: 'container',
        //              html: '<div class="qh-object" data-qh_otype="bot_button_attack" data-qh_oid="'+speaker.data.bot_type+'"></div>',
        //              cls: 'attack_button_pointer_container'
        //          };
        //
        //      var qh_pointers_banish =
        //          {
        //              xtype: 'container',
        //              html: '<div class="qh-object flip-h" data-qh_otype="bot_button_banish" data-qh_oid="'+speaker.data.bot_type+'"></div>',
        //              cls: 'banish_button_pointer_container'
        //          };
        //      var qh_pointers_attack_any =
        //      {
        //          xtype: 'container',
        //          html: '<div class="qh-object" data-qh_otype="bot_button_attack_any" data-qh_oid="1"></div>',
        //          cls: 'attack_button_pointer_container'
        //      };
        //
        //      var qh_pointers_banish_any =
        //      {
        //          xtype: 'container',
        //          html: '<div class="qh-object flip-h" data-qh_otype="bot_button_banish_any" data-qh_oid="1"></div>',
        //          cls: 'banish_button_pointer_container'
        //      };
        if (infoData.sec_to_banish > 0) {
            setTimeout(function() {
                if (me.getBanish())  {
                    me.getBanish().enable();
                }
                
            }, infoData.sec_to_banish);
        }
        var dialogSettings = {
                xtype: 'botdialog',
                info: infoData,
                tplForContent: infoData.greetings_template,
                data: {
                    user: me.getUser().data
                },
                actionsView: actionView,
                id: 'npc-dialog',
                speaker: speaker
            };
        //qh_pointers_attack: qh_pointers_attack,
        //  qh_pointers_banish: qh_pointers_banish,
        //          qh_pointers_attack_any: qh_pointers_attack_any,
        //          qh_pointers_banish_any: qh_pointers_banish_any
        var protos = ExGods.app.getItemPrototypesStore(),
            missedProtos = [];
        for (var i = 0; i < infoData.stuff.length; i++) {
            var type = infoData.stuff[i].type;
            switch (type) {
                case 'item':
                    var proto_id = parseInt(infoData.stuff[i].params.id);
                    item = protos.data.getByKey(proto_id);
                    if (!item) {
                        missedProtos.push(proto_id);
                    };
                    break;
            }
        }
        if (missedProtos.length) {
            ExGods.app.block();
            protos.loadNew(missedProtos, function() {
                ExGods.app.unblock();
                me.dialog = Ext.widget('window2', {
                    autoShow: false,
                    items: [
                        dialogSettings
                    ]
                });
                ExGods.Resources.load(me.dialog, function() {
                    me.dialog.show();
                });
            });
        } else {
            me.dialog = Ext.widget('window2', {
                autoShow: false,
                items: [
                    dialogSettings
                ]
            });
            ExGods.Resources.load(me.dialog, function() {
                me.dialog.show();
            });
        }
    },
    /**
     *        NPC
     */
    onNpcActionButtonClick: function(button) {
        var me = this;
        me.onPointClick(null, button.point);
    },
    initDialogComponent: function(config, componentId) {
        var me = this,
            actions = [];
        for (var i = 1; i < 5; i++) {
            var label = config['btn' + i];
            if (label) {
                var act = config['act' + i];
                var action = {
                        anchor: "100%",
                        text: label,
                        xtype: "textbutton",
                        margin: '0 0 3 0'
                    };
                if (Ext.isObject(act)) {
                    Ext.apply(action, {
                        action: act.id,
                        handler: function() {
                            ExGods.ClientActions.createAndInvoke({
                                actionId: this.action
                            }, null, function(err) {
                                /***/
                                me.log('error', err);
                            });
                        }
                    });
                }
                actions.push(action);
            }
        }
        return Ext.widget('window2', {
            id: componentId,
            items: [
                {
                    xtype: 'dialog',
                    icon: config.icon,
                    itemId: config.itemId,
                    info: {
                        title: config.bot_title,
                        image: config.bot_image,
                        description: config.bot_description
                    },
                    data: {
                        description: config.description
                    },
                    tplForContent: [
                        '<p>{description}</p>'
                    ],
                    actions: actions,
                    close_btn_text: config.close_btn_text
                }
            ]
        });
    },
    initDialogRewardsComponent: function(config, componentId) {
        var me = this,
            bigRewards, wnd,
            rewards = (config.reward || []).concat(config.popup_params || []);
        wnd = Ext.widget('window2', {
            id: componentId,
            layer: 'directions-layer',
            autoShow: false,
            x: 110,
            y: 93
        });
        ExGods.util.Helper.loadProtosFromStuff(rewards, function() {
            var dialog = Ext.widget('dialog_rewards', {
                    config: config,
                    stuff: Ext.Array.map(rewards, function(reward) {
                        return {
                            type: 'dialog_rewards',
                            params: {
                                stuff: reward
                            }
                        };
                    }),
                    buttonClickHandler: function() {
                        wnd.close();
                    }
                });
            wnd.add(dialog);
        });
        return wnd;
    },
    initDialogDailyBonusComponent: function(config, componentId) {
        var me = this,
            bigRewards, wnd,
            stuff = Ext.Array.sort(ExGods.ref('login_days_bonus').getRange(), function(a, b) {
                return a.login_day_index - b.login_day_index;
            });
        wnd = Ext.widget('window2', {
            id: componentId,
            layer: 'directions-layer',
            autoShow: false,
            x: 110,
            y: 93
        });
        ExGods.helpme.loadProtosFromStuff(stuff, function() {
            var dialog = {
                    xtype: 'dialog_daily_bonus',
                    config: config,
                    rewards: stuff,
                    buttonClickHandler: function() {
                        wnd.close();
                    }
                };
            wnd.add(dialog);
            ExGods.Resources.load(wnd, function() {
                wnd.show();
            });
        });
        return wnd;
    },
    initDialogConfirmComponent: function(config, componentId) {
        var me = this,
            wnd, wndConfig,
            getDialogButtons = function(config) {
                var buttons = [];
                if (config.btn1) {
                    buttons.push({
                        xtype: 'textbutton',
                        cls: 'no_border',
                        text: ExGods.app.applyTpl(config.btn1, {
                            u: me.app.user.data
                        }),
                        action: config.act1,
                        handler: doAction,
                        margin: '0 20 0 0'
                    });
                }
                if (config.btn2) {
                    buttons.push({
                        xtype: 'textbutton',
                        cls: 'no_border',
                        text: ExGods.app.applyTpl(config.btn2, {
                            u: me.app.user.data
                        }),
                        action: config.act2,
                        handler: doAction,
                        margin: '0 20 0 0'
                    });
                }
                //  
                buttons.push({
                    xtype: 'textbutton',
                    text: ExGods.app.applyTpl(config.close_btn_text, {
                        u: me.app.user.data
                    }) || ExGods.getMsgByKey('close_btn_text'),
                    cls: 'x-btn-txt-red no_border',
                    handler: doAction
                });
                return buttons;
            },
            doAction = function(btn) {
                if (btn.action) {
                    ExGods.ClientActions.createAndInvoke({
                        actionId: this.action.id
                    }, function() {
                        wnd.close();
                    }, function(err) {
                        /***/
                        me.log('error', err);
                    });
                } else {
                    wnd.close();
                }
            };
        wndConfig = {
            id: componentId,
            y: config.y || 260,
            width: parseInt(config.width || 320),
            height: parseInt(config.height || 155),
            items: [
                {
                    xtype: 'panel',
                    html: '<div style="padding: 10px 10px 10px 10px; text-align: center;">' + ExGods.app.applyTpl(config.text, {
                        u: me.app.user.data
                    }) + '</div>',
                    buttons: getDialogButtons(config),
                    buttonAlign: 'center'
                }
            ]
        };
        if (config.x) {
            wndConfig.x = config.x;
        }
        wnd = Ext.widget('floatwindow', wndConfig);
        return wnd;
    },
    initBotInfoComponent: function(config, componentId) {
        var dialog = {
                xtype: 'bot_info_dialog',
                config: config
            };
        var panel = Ext.create('Ext.panel.Panel', {
                id: componentId,
                autoShow: false,
                layer: 'directions-layer',
                layout: 'absolute',
                items: [
                    dialog
                ]
            });
        dialog = panel.down('bot_info_dialog');
        ExGods.util.Helper.loadProtosFromStuff(config.data.description_stuff.concat(config.prize || []), function() {
            var update = function() {
                    if (config.prize) {
                        dialog.el.down('.npc_bigPrize').update(ExGods.stuff.StuffManager.image(config.prize));
                    }
                    dialog.el.down('.npc_bigItems').update(ExGods.stuff.StuffManager.image(config.data.description_stuff));
                };
            dialog.on('afterrender', function() {
                update();
            });
            ExGods.Resources.load(panel, function() {
                panel.show();
            });
        });
        dialog.on('close', function() {
            panel.destroy();
        });
        return panel;
    }
});

/**
 * ,     .      .
 */
Ext.define('ExGods.view.shop.stuff.ShopStuff', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        if (data.decorators) {
            Ext.Array.remove(data.decorators, ExGods.stuff.decorator.Quantity);
        } else  {
            data.decorators = [];
        }
        
        if (me.stuff.locked) {
            data.decorators.push(ExGods.view.shop.stuff.decorator.Locked);
        }
        return data;
    }
});

/**
 *    
 */
Ext.define('ExGods.view.shop.stuff.decorator.Locked', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var image = ExGods.references.get('images').get('item_locked_status').image['img60'];
            return '<div class="shop-item-locked" style="background-image:url(' + image + ')"></div>';
        }
    }
});

/**
 * , ,  .
 */
Ext.define('ExGods.view.Room', {
    extend: Ext.panel.Panel,
    alias: 'widget.room',
    plugins: [
        'irondeco'
    ],
    layout: 'absolute',
    x: 5,
    y: 3,
    width: 850,
    height: 420,
    //margin: '0 10 10 0',
    /**
     * @cfg {string} closeCallback (required)
     * ,        
     */
    /**
     * @cfg {string} backgroundImage (required)
     *   ,  
     */
    /**
     * @cfg {string} emptySearchText (required)
     *   
     */
    /**
     * @cfg {string} closeText (required)
     *   
     */
    /**
     * @cfg {string} rightPanelX (required)
     *       " "  " "    .
     */
    initComponent: function() {
        var me = this;
        me.style = {
            backgroundImage: "url(" + IMAGE_URL + me.backgroundImage + ")",
            // backgroundSize: "100% auto",
            backgroundRepeat: "no-repeat",
            backgroundPosition: '5px'
        };
        me.items.push(me.initButtonsPanel(), {
            xtype: 'panel',
            layout: 'anchor',
            y: 195,
            x: me.rightPanelX,
            hidden: true,
            itemId: 'search_empty_message',
            style: {
                textAlign: 'center',
                color: '#ECDBC7',
                fontSize: 20
            },
            html: '<div>' + me.emptySearchText + '</div>'
        });
        me.callParent();
    },
    initButtonsPanel: function() {
        var me = this,
            buttons = [];
        if (me.closeText) {
            buttons.push({
                itemId: 'back_in_town',
                text: me.closeText,
                cls: ((me.closeColor) ? 'qh-object x-btn-txt-' + me.closeColor : 'qh-object') + (me.closeBtnUI && me.closeBtnUI == 'stone' ? ' stone_btn' : ''),
                handler: function(btn) {
                    me.closeCallback();
                }
            });
        }
        if (me.buttons) {
            buttons = buttons.concat(me.buttons);
        }
        delete me.buttons;
        return {
            xtype: 'panel',
            layout: 'anchor',
            y: 373,
            x: me.rightPanelX,
            maxWidth: 581,
            cls: 'body_overflow_visible',
            style: {
                textAlign: 'center',
                overflow: 'visible'
            },
            defaults: {
                xtype: 'textbutton',
                height: me.closeBtnUI == 'stone' ? 42 : 30,
                cls: me.closeBtnUI && me.closeBtnUI == 'stone' ? ' stone_btn' : ''
            },
            items: buttons
        };
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + me.backgroundImage,
                me.closeText
            ]
        };
    }
});

/**
 *  
 *
 *     .
 */
Ext.define('ExGods.view.shop.ShopTabs', {
    extend: Ext.container.Container,
    alias: 'widget.shoptabs',
    /**
     * @cfg {ExGods.model.User} user
     *  
     */
    /**
     * @cfg {} activeShopId ID ,      
     */
    /**
     * @property {Ext.data.Store} shops
     *  
     */
    initComponent: function() {
        var me = this;
        me.shops = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.Shop'
        });
        //   
        me.availabilityFilter = new Ext.util.Filter({
            filterFn: function(item) {
                var level = parseInt(me.user.getLevel()),
                    proto = item.data.item_proto;
                return level >= proto.data.data.strict.level;
            }
        });
        me.items = [
            {
                xtype: 'room',
                backgroundImage: me.backImg,
                emptySearchText: me.emptySearchText,
                closeText: me.closeText,
                closeColor: me.closeColor,
                closeCallback: function() {
                    me.fireEvent('close');
                },
                rightPanelX: 250,
                items: [
                    {
                        xtype: 'panel',
                        id: 'shop-window-container',
                        width: 230,
                        height: 380,
                        margin: '15 0 0 5'
                    },
                    {
                        xtype: 'skintabpanel',
                        activeTab: 0,
                        x: 242,
                        y: 10,
                        width: 580,
                        height: 363,
                        closable: true,
                        listeners: {
                            beforeclose: {
                                fn: function() {
                                    me.fireEvent('close');
                                    return false;
                                }
                            }
                        },
                        plugins: [
                            'skindeco',
                            {
                                ptype: 'pager',
                                marginLeft: -27,
                                marginRight: -27,
                                top: 164
                            }
                        ],
                        padding: '0 0 35 0'
                    },
                    {
                        xtype: 'form',
                        x: 530,
                        y: 20,
                        width: 270,
                        height: 30,
                        tbar: {
                            xtype: 'panel',
                            bodyCls: 'parchment-content-nop',
                            bodyPadding: 0,
                            defaults: {
                                margin: '0 1'
                            },
                            height: 30,
                            items: [
                                {
                                    xtype: 'checkboxfield',
                                    boxLabel: ExGods.getMsgByKey('view_shop_tabs_avail'),
                                    checked: true,
                                    itemId: 'availability',
                                    style: {
                                        color: '#e3ac69'
                                    },
                                    listeners: {
                                        change: function() {
                                            me.updateFilters('level');
                                        },
                                        scope: me
                                    },
                                    margin: '0 10 0 0'
                                },
                                {
                                    xtype: 'tbfill'
                                },
                                {
                                    xtype: 'textfield',
                                    emptyText: ExGods.getMsgByKey('view_shop_tabs_seachbyname'),
                                    itemId: 'title',
                                    cls: 'text-search-input',
                                    listeners: {
                                        change: {
                                            fn: function() {
                                                me.updateFilters('text');
                                            },
                                            buffer: 100
                                        },
                                        scope: me
                                    },
                                    padding: 1,
                                    value: ''
                                }
                            ],
                            layout: 'hbox',
                            margin: '0 16 5 0'
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
        Ext.Array.forEach(me.query('#shop-view'), function(cmp) {
            cmp.relayEvents(cmp.up(), [
                'show'
            ]);
        });
        me.mon(me.user, {
            levelchanged: me.onLevelChanged,
            scope: me
        });
    },
    /**
     *      
     * @param {Object} data  
     */
    setData: function(data) {
        var me = this,
            tabsPanel = me.down('skintabpanel'),
            tabs = [],
            activeTab = 0;
        me.shopsData = Ext.clone(data);
        me.shops.loadRawData(data);
        me.shops.each(function(shop, index) {
            if (me.activeShopId == shop.get('entry')) {
                activeTab = index;
            }
            tabs.push({
                padding: '0 0 0 10',
                shop: shop,
                tabConfig: {
                    xtype: 'skintab',
                    icon: IMAGE_URL + shop.getIcon('normal'),
                    tooltip: shop.get('name'),
                    cls: 'qh-object',
                    id: 'shop-tab-' + index
                },
                items: [
                    {
                        xtype: 'shop',
                        itemId: 'shop-view',
                        store: shop.items(),
                        filterByLevel: true,
                        emptyText: me.emptySearchText
                    }
                ]
            });
        });
        ExGods.Resources.load({
            items: {
                items: tabs
            },
            getResources: function() {
                var me = this;
                return {
                    images: []
                };
            }
        }, function() {
            tabsPanel.removeAll();
            tabsPanel.add(tabs);
            tabsPanel.setActiveTab(activeTab);
            Ext.apply(tabsPanel.pager, {
                current: 1,
                currentTab: 0,
                total: Math.ceil(me.shops.first().items().data.items.length / 6),
                //      
                totalTabs: tabsPanel.items.length
            });
            tabsPanel.on('beforetabchange', function(tabPanel, newShop, oldShop) {
                me.clearSearch();
            });
            tabsPanel.on('tabchange', function(tabPanel, newShop, oldShop) {
                me.updatePager();
            });
        });
    },
    /**
     *    
     * @private
     */
    clearSearch: function() {
        var me = this;
        if (me.down('#title').getValue()) {
            me.down('#title').setValue('');
            me.updateFilters("text");
        }
    },
    /**
     *    .   
     */
    onLevelChanged: function() {
        var me = this;
        Ext.Array.forEach(me.query('#shop-view'), function(cmp) {
            cmp.setFilters();
        });
    },
    /**
     *    
     */
    updateFilters: function(filterName) {
        var me = this,
            tab = me.down('skintabpanel').getActiveTab(),
            dataview = tab.down('dataview'),
            store = dataview.getStore(),
            searchText = Ext.String.trim(me.down('#title').getValue()),
            checked = me.down('#availability').getValue(),
            allItemsStore = Ext.create('ExGods.store.ShopItems'),
            allItems = [];
        if (filterName == 'level') {
            Ext.Array.forEach(me.query('#shop-view'), function(cmp) {
                cmp.setFilterByLevel(checked);
            });
        } else if (filterName == 'text') {
            //    ,          ,   .
            //  -      
            if (searchText) {
                if (!dataview.allItemsStore) {
                    me.shopsData.forEach(function(data) {
                        allItems = allItems.concat(data.items);
                    });
                    allItemsStore.loadRawData(allItems);
                    dataview.originStore = dataview.store;
                    dataview.allItemsStore = allItemsStore;
                    dataview.bindStore(allItemsStore);
                }
            } else {
                if (dataview.allItemsStore) {
                    dataview.allItemsStore = undefined;
                    dataview.bindStore(dataview.originStore);
                }
            }
            dataview.setTextFilter(searchText);
        }
        me.updatePager();
    },
    updatePager: function() {
        var me = this;
        //   (   6 ,    -   6)
        var length = me.down('skintabpanel').getActiveTab().down('dataview').getStore().data.items.length;
        if (length)  {
            var total = Math.ceil(length / 6);
        }
        else  {
            total = 1;
        }
        
        Ext.apply(me.down('skintabpanel').pager, {
            current: 1,
            currentTab: me.down('skintabpanel').items.findIndex('id', me.down('skintabpanel').getActiveTab().id),
            total: total
        });
        me.down('skintabpanel').pager.refresh();
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Shop', {
    extend: ExGodsCore.controller.Base,
    models: [
        'ShopItem'
    ],
    views: [
        'shop.ShopTabs'
    ],
    refs: [
        {
            /**
         * @method getShopTabs
         *   
         * @return {Ext.container.Container}
         */
            ref: 'shopTabs',
            selector: 'shoptabs'
        }
    ],
    init: function() {
        var me = this;
        me.control({
            'shop': {
                itemclick: {
                    fn: me.onShopItemClick,
                    delay: 0
                }
            },
            'shoptabs skintabpanel': {
                next: me.showNextPage,
                prev: me.showPrevPage
            }
        });
        me.app.getChatConnection().on({
            scope: me
        });
        ExGods.app.on({
            'quest_finish': me.updateShop,
            scope: me
        });
        ExGods.stuff.StuffManager.register({
            'shop_stuff': ExGods.view.shop.stuff.ShopStuff
        });
        ExGods.Components.addComponentInitializer('shop', me.initShopComponent, me);
    },
    showNextPage: function(pager) {
        if (pager.current > pager.total) {
            this.getShopTabs().clearSearch();
            pager.currentTab++;
            pager.cmp.setActiveTab(pager.currentTab);
            pager.current = 1;
            total = Math.ceil(this.getShopTabs().down('skintabpanel').getActiveTab().down('dataview').getStore().data.length / 6);
            if (!total)  {
                total = 1;
            }
            
            pager.total = total;
        } else {
            this.openPage(+1);
        }
        pager.refresh();
    },
    showPrevPage: function(pager) {
        var me = this;
        if (pager.current < 1) {
            this.getShopTabs().clearSearch();
            pager.currentTab--;
            pager.cmp.setActiveTab(pager.currentTab);
            total = Math.ceil(this.getShopTabs().down('skintabpanel').getActiveTab().down('dataview').getStore().data.length / 6);
            if (!total)  {
                total = 1;
            }
            
            pager.current = total;
            pager.total = total;
            setTimeout(function() {
                me.openLastPage(pager.total);
            }, 0);
        } else {
            this.openPage(-1);
        }
        pager.refresh();
    },
    openPage: function(direction) {
        var ul = this.getShopTabs().down('skintabpanel').getActiveTab().down('dataview').getEl().down('.shop-items'),
            margin_top = parseInt(ul.getStyle('margin-top').split('p')[0]),
            page_height = parseInt(this.getShopTabs().down('skintabpanel').getActiveTab().getEl().getStyle('height').split('p')[0]);
        //      _
        ul.setStyle('margin-top', margin_top + -1 * direction * (page_height - 1) + 'px');
    },
    openLastPage: function(total) {
        var ul = this.getShopTabs().down('skintabpanel').getActiveTab().down('dataview').getEl().down('.shop-items'),
            page_height = this.getShopTabs().down('skintabpanel').getActiveTab().getEl().getStyle('height').split('p')[0];
        //    _   _
        ul.setStyle('margin-top', -1 * (page_height - 1) * (total - 1) + 'px');
    },
    onShopItemClick: function(itemView, shopItem, itemEl, zero, event) {
        var me = this;
        if (event.getTarget('.x-btn')) {
            if (shopItem.get('params').variable_count) {
                me.showQuantityDialog(shopItem, function(quantity) {
                    me.buyItem(shopItem, quantity, itemView.ownerCt.shopService);
                });
            } else {
                me.buyItem(shopItem, 1, itemView.ownerCt.shopService);
            }
            event.stopPropagation();
        }
    },
    /**
     *    
     */
    buyItem: function(shopItem, quantity, service) {
        var me = this,
            ask_service = null,
            items = [],
            kits = [],
            proto,
            _buyItem = function() {
                if (shopItem.data.kit) {
                    kits.push({
                        count: quantity,
                        kit: shopItem.get('entry')
                    });
                } else {
                    items.push({
                        count: quantity,
                        item: shopItem.get('entry')
                    });
                }
                ExGods.app.block();
                service.command('shop_buy', {
                    basket: Ext.JSON.encode([
                        {
                            items: items,
                            kits: kits,
                            shop: shopItem.data.shop_id
                        }
                    ])
                }, function(json) {
                    ExGods.app.unblock();
                    if (shopItem.data.params.ask_service) {
                        service.update(null);
                    }
                });
            };
        service = service || me.service;
        quantity = quantity || 1;
        proto = shopItem.data.item_proto;
        if (parseInt(me.getUser().getLevel()) < parseInt(proto.data.data.strict.level)) {
            Ext.widget('confirmdialog', {
                message: ExGods.getMsgByKey("shop_buy_high_level_confirm"),
                handler: function() {
                    _buyItem(shopItem);
                }
            });
        } else {
            _buyItem(shopItem);
        }
    },
    updateShop: function(json) {
        var me = this,
            shopLocation = me.getShopTabs(),
            instances = json.instances;
        if (shopLocation && Ext.isArray(instances)) {
            Ext.Array.each(instances, function(instance) {
                if (instance.type == 'shop') {
                    me.updateShopsItems(instance.data);
                }
            });
        }
    },
    updateShopsItems: function(shopsData) {
        var me = this,
            shops = me.getShopTabs().shops;
        Ext.Array.forEach(shopsData, function(shopData) {
            var shop = shops.getById(parseInt(shopData.entry));
            shop.set('items', shopData.items);
        });
    },
    getMissedProtos: function() {
        var me = this,
            shops = me.service.data.shops,
            missedProtos = [];
        shops.forEach(function(shop) {
            missedProtos = missedProtos.concat(ExGods.model.Shop.getMissedProtos(shop));
        });
        return missedProtos;
    },
    initShopComponent: function(config, componentId) {
        var me = this,
            wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        me.service.on('update', me.onServiceUpdate, me);
        Ext.apply(config, {
            user: me.user,
            listeners: {
                close: {
                    fn: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            wnd.close();
                        }, {
                            img: config.backImg
                        });
                        return false;
                    },
                    single: true
                }
            }
        });
        if (config.clientAction && config.clientAction.options.shop) {
            config.activeShopId = config.clientAction.options.shop.shop_id;
        }
        Ext.Array.forEach(me.service.data.shops, function(shop) {
            Ext.Array.forEach(shop.items, function(item) {
                if (item.discount_ended)  {
                    me.startDiscountTimer(item.discount_ended);
                }
                
            });
        });
        cmp = Ext.apply({
            xtype: 'shoptabs'
        }, config);
        wnd = Ext.widget('window1', {
            id: componentId,
            items: [
                cmp
            ],
            autoShow: false
        });
        cmp = wnd.down('shoptabs');
        cmp.on('destroy', function() {
            clearInterval(me.discountwait);
            delete me.discountwait;
        });
        //     
        var protos = ExGods.app.getItemPrototypesStore(),
            missedProtos = me.getMissedProtos();
        ExGods.app.getController('Location').maskLocation(function() {
            protos.loadNew(missedProtos, function() {
                cmp.setData(me.service.data.shops);
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.backImg
        });
        return wnd;
    },
    onServiceUpdate: function() {
        var me = this,
            tabs = me.getShopTabs(),
            panel = tabs ? tabs.down('skintabpanel') : null;
        ExGods.app.getItemPrototypesStore().loadNew(me.getMissedProtos(), function() {
            var shops = me.getShopTabs().shops;
            if (shops && shops.totalCount) {
                Ext.Array.forEach(me.service.data.shops, function(shopData, index) {
                    //,   ,   ,  .
                    var shop = shops.getAt(index);
                    if (shop) {
                        shop.set('items', shopData.items);
                    }
                });
            }
        });
        if (panel) {
            panel.pager.current = 1;
            panel.pager.refresh();
        }
    },
    startDiscountTimer: function(end_time) {
        var me = this;
        me.discountwait = setInterval(function() {
            var currTime = new Date(ExGods.util.Date.normalizeServerDateTime(end_time)) / 1 - new Date() / 1;
            if (currTime < -1) {
                clearInterval(me.discountwait);
                delete me.discountwait;
                me.onRefreshDiscount();
            }
        }, 1000);
    },
    onRefreshDiscount: function() {
        var me = this;
        if (me.service) {
            me.service.update(null, function() {
                ExGods.app.getItemPrototypesStore().loadNew(me.getMissedProtos(), function() {
                    var shops = me.getShopTabs().shops;
                    if (shops && shops.totalCount) {
                        Ext.Array.forEach(me.service.data.shops, function(shopData, index) {
                            //,   ,   ,  .
                            var shop = shops.getAt(index);
                            if (shop)  {
                                shop.set('items', shopData.items);
                            }
                            
                        });
                    }
                });
            });
        }
    },
    /**
     *    -  
     */
    showQuantityDialog: function(shopItem, callback) {
        var me = this;
        var cmp = Ext.widget('progressdialog', {
                title: shopItem.getTitle(),
                image: shopItem.getImage(),
                label: ExGods.getMsgByKey('shop_quantity_dialog_input_text'),
                min: 1,
                max: ExGods.ref('constants|shop_max_quantity').value,
                value: 1,
                inputWidth: 75,
                autoShow: false,
                handler: callback,
                buttonsText: [
                    ExGods.getMsgByKey('shop_buy_btn_text'),
                    ExGods.getMsgByKey('shop_quantity_dialog_no_btn_text')
                ],
                value_dependent_text: [
                    Ext.String.format(ExGods.getMsgByKey('shop_quantity_dialog_price_text'), '{[this.printPrice(values)]}'),
                    {
                        printPrice: function(values) {
                            var price = shopItem.get('price');
                            if (Ext.isArray(price)) {
                                price = price[0];
                            }
                            return ExGods.util.Format.printMoney({
                                name: price.name,
                                value: price.value * values.value
                            });
                        }
                    }
                ]
            });
        ExGods.Resources.load(cmp, function() {
            cmp.show();
        });
    }
});

/**
 *      
 */
Ext.define('ExGods.view.grid.Grid', {
    extend: Ext.panel.Panel,
    alias: 'widget.exg_grid',
    requires: [],
    //
    /**
     * @cfg {Number} rowsCount -      
     */
    rowsCount: 4,
    /**
     * @cfg {Number} columnsCount -    
     */
    columnsCount: 4,
    /**
      * @cfg {Number}  
      */
    cellWidth: 64,
    /**
      * @cfg {Number}  
      */
    cellHeight: 64,
    /**
     * @cfg {Ext.data.Store} store   
     */
    store: null,
    /**
     * @cfg {String} itemTpl   
     */
    itemTpl: '',
    /**
     * @cfg {String} itemSelector   
     */
    itemSelector: '.exg-grid-item',
    /**
     * ,      
     */
    emptyText: null,
    /**
     *  
     */
    pager: null,
    /**
     * @property itemsView {Ext.view.View} DataView 
     */
    itemsView: null,
    layout: 'fit',
    initComponent: function() {
        var me = this,
            ct;
        me.cls = me.cls ? me.cls + ' slotsgrid' : 'slotsgrid';
        me.calcWidth();
        me.initItemTemplate();
        me.itemsView = Ext.widget('dataview', {
            collectData: Ext.Function.bind(me.collectData, me),
            itemSelector: me.itemSelector,
            store: me.store,
            emptyText: me.emptyText ? '<div class="exg-grid-empty-msg">' + me.emptyText + '</div>' : '',
            deferEmptyText: false,
            tpl: [
                '<div class="exg-grid-inner" style="width: {[ this.getInnerWidth() ]}px; height: {[ this.getInnerHeight() ]}px;">',
                '<ul class="exg-grid-items">',
                '<tpl for=".">',
                '<li class="exg-grid-item" style="width: ' + me.cellWidth + 'px; height: ' + me.cellHeight + 'px;">',
                '{[ this.printItem(values) ]}',
                '</li>',
                '</tpl>',
                '</ul>',
                '<div class="x-clear"></div>',
                '</div>',
                {
                    getInnerWidth: function() {
                        return me.cellWidth * me.columnsCount;
                    },
                    getInnerHeight: function() {
                        return me.cellHeight * me.rowsCount;
                    },
                    printItem: function(data) {
                        return me.itemTpl.apply(data);
                    }
                }
            ],
            listeners: {
                refresh: function() {
                    var pager = me.getPager();
                    if (pager) {
                        pager.total = me.getTotalPagesCount();
                        if (pager.current > pager.total) {
                            pager.current = pager.total;
                        }
                        pager.cmp.openPage(pager.current);
                        pager.refresh();
                    }
                }
            }
        });
        ct = {
            xtype: 'container',
            layout: 'fit',
            items: me.itemsView,
            plugins: []
        };
        if (me.pager) {
            me.initPager(ct);
        }
        me.items = [
            ct
        ];
        me.callParent();
        me.on({
            show: me.showPager,
            hide: me.hidePager,
            scope: me
        });
        me.relayEvents(me.itemsView, [
            'itemclick',
            'refresh',
            'resize',
            'viewready'
        ]);
    },
    /**
     *  
     */
    showPager: function() {
        var me = this,
            pager = me.getPager();
        if (pager && pager.isVisible()) {
            pager.showArrows();
        }
    },
    /**
     *  
     */
    hidePager: function() {
        var me = this,
            pager = me.getPager();
        if (pager) {
            pager.hideArrows();
        }
    },
    /********************** PROTECTED ********************/
    /**
     *     .     
     */
    calcWidth: function() {
        var me = this;
        me.width = me.cellWidth * me.columnsCount;
    },
    /**
     *     
     */
    initItemTemplate: function() {
        var me = this;
        me.itemTpl = new Ext.XTemplate(me.itemTpl);
    },
    /**
     *   
     */
    getPager: function() {
        return this.items.items[0].pager;
    },
    //  -  
    getTotalPagesCount: function() {
        var me = this;
        return Math.ceil(me.store.getCount() / (me.rowsCount * me.columnsCount)) || 1;
    },
    /**
     *   DataView.     
     */
    collectData: function(records) {
        var me = this,
            data = [];
        records.forEach(function(record) {
            data.push(record.data);
        });
        return data;
    },
    /**
     *  
     */
    configPager: function() {
        var me = this;
        me.pager = Ext.apply({
            ptype: 'pager',
            marginLeft: -36,
            marginRight: -36,
            top: (me.rowsCount * me.cellHeight) / 2 - 25,
            /** 25 -     */
            textLeft: me.width / 2 - 112 / 2,
            /* 112 -  */
            textTop: me.cellHeight * me.rowsCount + 8,
            /** 8 -     */
            total: me.getTotalPagesCount()
        }, me.pager);
        return me.pager;
    },
    /**
     *  
     */
    initPager: function(ct) {
        var me = this;
        ct.plugins.push(me.configPager());
        ct.prevPage = function(pager) {
            ct.openPage(pager.current);
            pager.refresh();
        };
        ct.nextPage = function(pager) {
            ct.openPage(pager.current);
            pager.refresh();
        };
        ct.openPage = function(pageIndex) {
            var ul = me.getEl().down('.exg-grid-items');
            ul.setStyle('margin-top', '-' + ((pageIndex - 1) * me.rowsCount * me.cellHeight) + 'px');
        };
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *     
 */
Ext.define('ExGods.view.grid.SlotsGrid', {
    extend: ExGods.view.grid.Grid,
    alias: 'widget.slotsgrid',
    cls: 'exg-grid-slots',
    cellWidth: 64,
    cellHeight: 64
});

/**
 *         
 */
Ext.define('ExGods.view.grid.FramedSlotsGrid', {
    extend: ExGods.view.grid.SlotsGrid,
    alias: 'widget.framedslotsgrid',
    /**
     * @cfg headerText {String} ,   
     */
    headerText: '',
    initComponent: function() {
        var me = this;
        if (me.plugins) {
            me.plugins.push('inventory_frame');
        } else {
            me.plugins = [
                'inventory_frame'
            ];
        }
        me.callParent(arguments);
    },
    /**
     * @override
     */
    calcWidth: function() {
        var me = this;
        me.callParent(arguments);
        me.width += 20;
    }
});
// 

/**
 *      
 */
Ext.define('ExGods.mixin.Highlightable', {
    /**
     *  
     */
    highlight: function(lightOn) {
        var me = this,
            target = me.getHighlitableTarget();
        if (target) {
            if (lightOn) {
                if (!target.hasCls('exg-highlighted')) {
                    target.addCls('exg-highlighted');
                    target.insertHtml('beforeEnd', '<div class="exg-highlighted-inner"></div>');
                }
            } else if (target.hasCls('exg-highlighted')) {
                target.removeCls('exg-highlighted');
                target.down('.exg-highlighted-inner').remove();
            }
        }
    },
    /**
     *  ,    .   -  
     */
    getHighlitableTarget: function() {
        var me = this;
        if (me.rendered) {
            return me.getEl();
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.item.InventorySlot', {
    extend: ExGods.view.grid.FramedSlotsGrid,
    alias: 'widget.iteminventoryslot',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.InventoryDragHighlight,
        ExGods.mixin.Highlightable
    ],
    /**
     * @cfg {ExGods.store.Slots} slots (required)
     *  , ,   
     */
    /**
     * @cfg {Object} sorter   
     */
    /**
     * @cfg canDragItems ,      drag-and-drop'
     */
    canDragItems: true,
    initComponent: function() {
        var me = this,
            view,
            i = 0;
        me.stuffs = [];
        me.cls += ' inventory-slot';
        me.sorter = me.sorter || new ExGods.view.inventory.InventorySorter({
            user: ExGods.app.user
        });
        me.sorter.on('refresh', function() {
            me.store.sort();
        }, me);
        me.store = Ext.create('Ext.data.Store', {
            model: 'ExGodsCore.model.Item',
            sorters: me.sorter.getSorters()
        });
        var bufferedRefreshSlotItems = Ext.Function.createBuffered(me.refreshSlotItems, 100);
        Ext.Array.each(me.slots, function(slot) {
            me.mon(slot, {
                highlight: me.highlight.bind(me, true),
                unhighlight: me.highlight.bind(me, false),
                scope: me
            });
            me.store.add(slot.get('items').data.items);
            me.mon(slot.items(), 'datachanged', bufferedRefreshSlotItems, me);
            me.mon(slot.items(), 'refresh', bufferedRefreshSlotItems, me);
            var itms = slot.get('items').data.items;
            for (var i = 0; i < itms.length; i++) {
                me.stuffs.push({
                    //       
                    params: {
                        id: itms[i].data.proto_id,
                        quantity: itms[i].data.count
                    },
                    type: 'item'
                });
            }
        });
        me.itemTpl = [
            '{[this.getStuff(values)]}',
            {
                getStuff: function(values) {
                    return ExGods.stuff.StuffManager.image(values);
                }
            }
        ];
        me.callParent();
        me.view = me.down('dataview');
        me.view.slot = me.slot;
        me.view.on('render', me.initDragAndDrop, me);
    },
    collectData: function(records) {
        return Ext.Array.map(records, function(record) {
            return {
                type: 'inventory_item',
                params: {
                    itemModel: record
                }
            };
        });
    },
    /**
     * @private
     * D&D 
     */
    initDragAndDrop: function(view) {
        var me = this,
            itemController = ExGods.app.getController('Item');
        if (me.canDragItems) {
            me.initDrag({
                view: view,
                cancelFn: function() {
                    ExGods.app.user.slots().each(function(slot) {
                        if (slot.getSlotType().active == 0)  {
                            slot.fireEvent('unhighlight', slot);
                        }
                        
                    });
                }
            });
        }
        me.initDrop({
            onDrop: function(target, dd, e, data) {
                if (Ext.getClassName(data.item) == 'ExGodsCore.model.Item' && !view.getNode(data.item)) {
                    itemController.takeOff(data.item, data.cancel);
                    return true;
                } else if (Ext.getClassName(data.item) == 'ExGods.model.WareHouseStuff') {
                    ExGods.app.getController('inventory.VirtualStore').doPutItems(data.item, false, data.cancel);
                    return true;
                } else  {
                    return false;
                }
                
            }
        });
        me.initDragHighlight();
    },
    refreshSlotItems: function() {
        var me = this,
            store = me.store;
        store.removeAll();
        Ext.Array.each(me.slots, function(slot) {
            store.add(slot.get('items').data.items);
        });
        store.filter();
        store.sort();
    },
    /**
     * mixin override
     */
    getHighlitableTarget: function() {
        var me = this,
            dataview = me.down('dataview');
        if (dataview.rendered) {
            return dataview.getEl();
        }
    },
    destroy: function() {
        var me = this;
        me.sorter.destroy();
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: me.stuffs || [],
            images: [
                IMAGE_URL + 'pager/btn_left.png',
                IMAGE_URL + 'pager/btn_right.png',
                IMAGE_URL + 'pager/btn_right_bg.png',
                IMAGE_URL + 'pager/btn_left_bg.png',
                IMAGE_URL + 'slots/slot_regular.jpg',
                // 
                IMAGE_URL + 'inventory/frm_top_left.jpg',
                IMAGE_URL + 'inventory/frm_top_center.jpg',
                IMAGE_URL + 'inventory/frm_top_right.jpg',
                IMAGE_URL + 'inventory/frm_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_center.jpg',
                IMAGE_URL + 'inventory/frm_bottom_left.jpg',
                IMAGE_URL + 'inventory/frm_left.jpg',
                IMAGE_URL + 'inventory/frm_top.png',
                IMAGE_URL + 'page_num.png',
                IMAGE_URL + 'button-text-30.png'
            ].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.item.Slot', {
    alias: 'widget.itemslot',
    extend: Ext.Component,
    mixins: [
        ExGods.mixin.Highlightable
    ],
    cls: 'x-btn itemslot',
    /**
     * @cfg {Object} slot (required)
     *   
     */
    initComponent: function() {
        var me = this;
        me.style = {
            backgroundImage: me.getBackgroundImage()
        };
        me.data = me.prepareData();
        me.tpl = [
            '<tpl if="item">',
            '{[this.getStuff(values.item)]}',
            '</tpl>',
            {
                getStuff: function(item) {
                    return ExGods.stuff.StuffManager.image(item);
                }
            }
        ];
        me.callParent();
        me.mon(me.slot.items(), {
            datachanged: me.updateItem,
            load: me.updateItem,
            scope: me
        });
        me.mon(me.slot, {
            protect: me.updateItem,
            highlight: me.highlight.bind(me, true),
            unhighlight: me.highlight.bind(me, false),
            scope: me
        });
    },
    updateItem: function() {
        var me = this;
        data = me.prepareData();
        me.update(data);
        me.initTooltips();
        me.el.setStyle({
            backgroundImage: me.getBackgroundImage()
        });
    },
    prepareData: function() {
        var me = this,
            item = me.slot.items().data.items[0],
            data = {};
        if (item) {
            me.stuff = {
                //       
                params: {
                    id: item.data.proto_id,
                    quantity: 1
                },
                //title
                type: 'item'
            };
            data.item = {
                type: 'item_slot',
                params: {
                    slot: me.slot,
                    itemModel: item
                }
            };
        }
        return data;
    },
    getRecord: function() {
        return this.slot.items().data.items[0];
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.initTooltips();
        //  click
        me.el.on('click', function(e) {
            me.fireEvent('click', me, me.slot, e);
        });
    },
    getBackgroundImage: function() {
        var me = this,
            background;
        if (me.slot.get('protect')) {
            background = 'url(' + IMAGE_URL + 'slots/new/frm.png), ' + 'url(' + ExGods.ref('slot_type|' + me.slot.get('type')).images.prot + ')';
        } else {
            background = 'url(' + ExGods.ref('slot_type|' + me.slot.get('type')).images.empty + ')';
        }
        return background;
    },
    initTooltips: function() {
        var me = this;
        if (me.slot.items().getCount()) {
            ExGods.Tooltips.removeTip(me.el);
        } else {
            ExGods.Tooltips.makeElementAsTip(me.el, 'slot', me.slot.data.ekey);
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.item.DollSlot', {
    extend: ExGods.view.item.Slot,
    alias: 'widget.dollslot',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.InventoryDragHighlight
    ],
    cls: 'qh-object active-slot',
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        if (me.user == ExGods.app.user) {
            me.initDrag();
            me.initDragHighlight();
        }
        me.el.set({
            'data-qh_otype': 'active_slot',
            'data-qh_oid': me.slot.get('type')
        });
        if (!me.x) {
            me.el.set({
                'data-qh_opts': '{&quot;cls&quot;:&quot;flip-h&quot;}'
            });
        }
    }
});

/**
 *  .     
 * "inventory_sort_by_name", "inventory_sort_by_dur".
 */
Ext.define('ExGods.view.inventory.InventorySorter', {
    extend: Ext.util.Observable,
    /**
     * @cfg {ExGods.model.User} user
     */
    constructor: function() {
        var me = this;
        me.callParent(arguments);
        me.sortByName = parseInt(me.user.getSetting('inventory_sort_by_name') || 0);
        me.sortByDur = parseInt(me.user.getSetting('inventory_sort_by_dur') || 0);
        me.sortFn = function(o1, o2) {
            var proto1 = o1.getProto(),
                proto2 = o2.getProto(),
                dur1 = o1.getDur(),
                dur2 = o2.getDur(),
                id1 = parseInt(o1.data.item_id),
                id2 = parseInt(o2.data.item_id);
            if (me.sortByName && proto1 && proto2) {
                if (proto1.data.title > proto2.data.title) {
                    return 1;
                } else if (proto1.data.title < proto2.data.title) {
                    return -1;
                } else if (!me.sortByDur) {
                    return 0;
                }
            }
            if (me.sortByDur && typeof dur1 != 'undefined' && typeof dur2 != 'undefined') {
                if (dur1 > dur2) {
                    return 1;
                } else if (dur1 < dur2) {
                    return -1;
                } else {
                    return 0;
                }
            }
            return id1 > id2 ? -1 : id1 < id2 ? 1 : 0;
        };
        me.mon(me.user, 'settingschanged', me.onSettingsChanged, me);
    },
    onSettingsChanged: function() {
        var me = this,
            newSortByName = parseInt(me.user.getSetting('inventory_sort_by_name')) || 0,
            newSortByDur = parseInt(me.user.getSetting('inventory_sort_by_dur')) || 0;
        if (me.sortByName != newSortByName || me.sortByDur != newSortByDur) {
            me.sortByName = newSortByName;
            me.sortByDur = newSortByDur;
            me.fireEvent('refresh');
        }
    },
    getSorters: function() {
        var me = this;
        return [
            {
                sorterFn: me.sortFn
            }
        ];
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.inventory.Inventory', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /**
         * @method getInventoryButton
         */
            ref: 'inventoryButton',
            selector: '#mainmenu-inventory-button'
        },
        {
            /**
         * @method getInventorySlots
         */
            ref: 'inventorySlots',
            selector: '#inventory_slots'
        },
        {
            /**
         * @method getUserStats
         */
            ref: 'userStats',
            selector: '#user_stats'
        },
        {
            /**
         * @method getVirtualStoreBtn
         */
            ref: 'virtualStoreBtn',
            selector: '#virtualStoreBtn'
        }
    ],
    views: [
        'item.InventorySlot',
        'item.DollSlot',
        'inventory.InventorySorter'
    ],
    tooltips: [
        'item',
        'slot'
    ],
    init: function(app) {
        var me = this,
            user = app.user;
        me.service = ExGods.Services.get('inventory');
        user.slots().each(function(slot) {
            if (!slot.getSlotTypeInfo().active) {
                slot.on('newitemsadded', function(slot, ids) {
                    me.incNewItemsCounter(ids.length);
                }, me);
            }
        });
        ExGods.app.getStore('VirtualStore').on({
            //'datachanged': me.onVirtualStoreChanged,
            'newitemsadded': me.onVirtualStoreNewItems,
            scope: me
        });
        me.control({
            'dollslot': {
                click: me.onDollSlotClick,
                scope: me
            }
        });
        ExGods.Components.addComponentInitializer('inventory', me.initInventoryComponent, me);
    },
    initInventoryComponent: function(config) {
        var me = this,
            cmp,
            form_config = [];
        ExGods.app.user.slots().each(function(slot) {
            if (!slot.getSlotTypeInfo().active) {
                form_config.push({
                    boxLabel: slot.data.name,
                    slotType: slot.data.type
                });
            }
        });
        cmp = Ext.widget('skintabpanel', {
            tabUi: 'skintext',
            cls: 'owerflow_visible_panel',
            bodyPadding: '0 11 11',
            items: [
                {
                    icon: ExGods.ref('images|inventory_tabs').image.inventory,
                    layout: 'absolute',
                    items: [
                        {
                            xtype: 'form',
                            x: 395,
                            y: -38,
                            width: 365,
                            height: 30,
                            tbar: {
                                xtype: 'panel',
                                bodyCls: 'parchment-content-nop',
                                defaults: {
                                    xtype: 'checkboxfield',
                                    checked: true,
                                    style: {
                                        color: '#e3ac69'
                                    },
                                    padding: '0 15 0 0',
                                    listeners: {
                                        change: me.onFilterChange,
                                        scope: me
                                    }
                                },
                                items: form_config,
                                layout: 'hbox'
                            }
                        },
                        {
                            xtype: 'button',
                            text: ExGods.getMsgByKey('inventory_params_btn_text'),
                            x: 132,
                            y: 8,
                            width: 104,
                            height: 18,
                            cls: 'inventory-params',
                            style: {
                                'z-index': '999'
                            },
                            handler: function() {
                                if (me.getUserStats().isVisible()) {
                                    me.getUserStats().hide();
                                    this.removeCls('opened');
                                } else {
                                    me.getUserStats().show();
                                    this.addClass('opened');
                                }
                            }
                        },
                        {
                            xtype: 'userstats',
                            user: ExGods.app.user,
                            itemId: 'user_stats',
                            hidden: true,
                            width: 225,
                            style: {
                                'z-index': '999'
                            },
                            x: 72,
                            y: 32
                        },
                        {
                            xtype: 'dollpanel',
                            user: ExGods.app.user
                        },
                        me.createInventorySlotsView(),
                        {
                            xtype: 'container',
                            layout: {
                                type: 'hbox',
                                pack: 'center'
                            },
                            width: 340,
                            height: 80,
                            x: 405,
                            y: 330,
                            items: [
                                {
                                    xtype: 'textbutton',
                                    text: ExGods.getMsgByKey('text_storage_img'),
                                    cls: 'inventory-virtual-store-btn',
                                    itemId: 'virtualStoreBtn',
                                    width: 120,
                                    margin: '0 5',
                                    handler: function(btn) {
                                        btn.disable();
                                        ExGods.Components.factory("VIRTUAL_STORE");
                                        var counterEl = btn.el.down('.newitems-counter');
                                        if (counterEl) {
                                            counterEl.remove();
                                        }
                                    },
                                    listeners: {
                                        afterrender: function(btn) {
                                            if (me.newItemsVirtualStoreCount) {
                                                me.incNewItemsVirtualStoreCounter(me.newItemsVirtualStoreCount);
                                            }
                                            if (me.newItemsLootCount) {
                                                me.incNewLootCounter(me.newItemsLootCount);
                                            }
                                        }
                                    }
                                }
                            ]
                        }
                    ]
                },
                {
                    icon: ExGods.ref('images|inventory_tabs').image.raids,
                    layout: 'absolute',
                    items: [
                        {
                            xtype: 'guildraids',
                            store: ExGods.app.getGuildRaidsStore(),
                            show_rewards: true
                        }
                    ]
                }
            ],
            listeners: {
                destroy: function(cmp) {
                    var items = Ext.ComponentQuery.query('parchmentwindow');
                    items.forEach(function(item) {
                        item.close();
                    });
                },
                beforetabchange: function(tabpanel, newTab) {
                    var guildraids = newTab.down('guildraids');
                    if (!guildraids)  {
                        return;
                    }
                    
                    if (me.achievements_requesting) {
                        return false;
                    } else if (me.achievements_requested) {
                        guildraids.show();
                        me.achievements_requested = false;
                    } else {
                        me.achievements_requesting = true;
                        me.request({
                            url: '/game.pl',
                            params: {
                                cmd: 'guild_raid_achievements'
                            },
                            success: function(data) {
                                if (data.achievements) {
                                    me.user.setRaidAchievements(data.achievements);
                                }
                                me.achievements_requesting = false;
                                me.achievements_requested = true;
                                tabpanel.setActiveTab(newTab);
                            }
                        });
                        return false;
                    }
                },
                tabchange: function(tabpanel, newTab) {
                    me.getInventorySlots().setVisible(Boolean(newTab.down('#inventory_slots')));
                }
            }
        });
        var wnd = Ext.widget('window2', {
                id: 'INVENTORY',
                items: [
                    cmp
                ],
                closeAction: 'hide',
                autoShow: false,
                listeners: {
                    render: function() {
                        me.getInventorySlots().show();
                        me.getInventoryButton().reset();
                    },
                    show: function() {
                        me.getInventorySlots().show();
                        this.down('skintabpanel').setActiveTab(0);
                        if (cmp.down('#loot_manager_btn'))  {
                            cmp.down('#loot_manager_btn').setDisabled(ExGods.app.getStore('Loot').getCount() === 0);
                        }
                        
                        me.getInventoryButton().reset();
                    },
                    hide: function() {
                        me.getInventorySlots().hide();
                        this.down('guildraids').hide();
                    }
                }
            });
        ExGods.app.block();
        ExGods.Resources.load(wnd, function() {
            wnd.show();
            ExGods.app.unblock();
        });
        return wnd;
    },
    createInventorySlotsView: function(config) {
        var me = this,
            cmp,
            notActiveSlots = [];
        ExGods.app.user.slots().each(function(slot) {
            if (!slot.getSlotTypeInfo().active) {
                notActiveSlots.push(slot);
            }
        });
        return Ext.widget('iteminventoryslot', Ext.apply({
            headerText: ExGods.getMsgByKey('inventory_title_text'),
            itemId: 'inventory_slots',
            slots: notActiveSlots,
            user: ExGods.app.user,
            rowsCount: 4,
            columnsCount: 5,
            x: 400,
            y: 22,
            pager: {
                marginLeft: -37,
                marginRight: -39,
                textTop: 270,
                textLeft: 104
            }
        }, config));
    },
    /**
     *      
     */
    lockNewItemsUpdate: function() {
        var me = this;
        me.f_locked_new_items_update = true;
    },
    unlockNewItemsUpdate: function() {
        var me = this,
            inventoryCmp = Ext.getCmp('INVENTORY');
        if (me.newItemsCount && (!inventoryCmp || !inventoryCmp.isVisible())) {
            me.getInventoryButton().addCount(me.newItemsCount);
        }
        me.newItemsCount = 0;
        me.f_locked_new_items_update = false;
    },
    onFilterChange: function(field) {
        var me = this,
            values = [],
            store = me.getInventorySlots().store,
            protos = ExGods.app.getItemPrototypesStore(),
            all_checked = true;
        Ext.Array.each(field.up().up().query('checkboxfield'), function(checkBox) {
            if (checkBox.getValue()) {
                values.push(checkBox.slotType);
            } else  {
                all_checked = false;
            }
            
        });
        store.removeFilter('user_filter');
        if (!all_checked) {
            store.addFilter(Ext.util.Filter({
                filterFn: function(rec) {
                    var proto = protos.getById(rec.get('proto_id')) || protos.data.getByKey(rec.data.stuff.params.id);
                    if (!proto)  {
                        return false;
                    }
                    
                    var slotType = proto.getTypeInfo().slot_off;
                    return values.indexOf(slotType) != -1;
                },
                id: 'user_filter'
            }));
        }
    },
    /**
     * @private     
     */
    onVirtualStoreChanged: function(virtualStore) {
        var me = this,
            cmp = Ext.getCmp('INVENTORY'),
            btn = me.getVirtualStoreBtn();
        if (cmp && btn) {
            //   ""  
            btn.setDisabled(virtualStore.getCount() == 0);
        }
    },
    /**
     * @private      
     */
    onVirtualStoreNewItems: function(virtualStore, newItems) {
        var me = this,
            newItemsCount = newItems.length,
            i = newItemsCount,
            el;
        me.incNewItemsCounter(newItemsCount);
        me.incNewItemsVirtualStoreCounter(newItemsCount);
        while (i--) {
            el = virtualStore.getById(newItems[i]);
            if (el) {
                newItemsCount--;
            }
        }
        me.incNewLootCounter(newItemsCount);
    },
    onDollSlotClick: function(cmp, slot, e) {
        var me = this;
        //   -      
        if (slot.items().getCount())  {
            return;
        }
        
        me.app.getItemController().showSlotWindow(slot, cmp.el);
    },
    /**
     *        ""
     */
    incNewItemsCounter: function(count) {
        var me = this,
            inventoryCmp = Ext.getCmp('INVENTORY'),
            virtualStoreCmp = Ext.getCmp('VIRTUAL_STORE'),
            fucinaCmp = Ext.getCmp('FUCINA');
        if (me.f_locked_new_items_update) {
            me.newItemsCount = (me.newItemsCount || 0) + count;
            return;
        }
        if ((!inventoryCmp || !inventoryCmp.isVisible()) && (!fucinaCmp || !fucinaCmp.isVisible()) && (!virtualStoreCmp || !virtualStoreCmp.isVisible())) {
            me.getInventoryButton().addCount(count);
        }
    },
    /**
     *       ""
     */
    incNewItemsVirtualStoreCounter: function(count) {
        var me = this,
            cmp = Ext.getCmp('INVENTORY'),
            cmp2 = Ext.getCmp('VIRTUAL_STORE'),
            virtualStoreBtn = me.getVirtualStoreBtn();
        if (cmp2) {
            return;
        }
        //   
        if (cmp && virtualStoreBtn) {
            counterEl = virtualStoreBtn.el.down('.newitems-counter');
            if (!counterEl) {
                counterEl = virtualStoreBtn.el.insertHtml('beforeEnd', '<div class="newitems-counter"></div>', true);
            }
            counterEl.setHTML((parseInt(counterEl.getHTML()) || 0) + count);
        } else {
            me.newItemsVirtualStoreCount = (me.newItemsVirtualStoreCount || 0) + count;
        }
    },
    /**
     *       
     */
    incNewLootCounter: function(count) {
        var me = this,
            cmp = Ext.getCmp('INVENTORY');
        if (cmp && cmp.down('#loot_manager_btn') && cmp.down('#loot_manager_btn').el) {
            var lootBtn = cmp.down('#loot_manager_btn');
            counterEl = lootBtn.el.down('.newitems-counter');
            if (!counterEl) {
                counterEl = lootBtn.el.insertHtml('beforeEnd', '<div class="newitems-counter"></div>', true);
            }
            counterEl.setHTML((parseInt(counterEl.getHTML()) || 0) + count);
            lootBtn.enable();
        } else {
            me.newItemsLootCount = (me.newItemsLootCount || 0) + count;
        }
    },
    /**
     *    
     */
    getTooltipData: function(type, value) {
        var me = this,
            data;
        value = value.split('|');
        if (type == 'item' && (value[1] == 'user_info' && !Ext.getCmp('user-info'))) {
            me.user.slots().each(function(slot) {
                slot.items().each(function(item) {
                    if (item.data.item_id == value[0]) {
                        data = {
                            item: item
                        };
                        data.tooltipText = me.user.isBattle() ? ExGods.getMsgByKey('tooltip_text_battle') : ExGods.getMsgByKey('tooltip_text');
                    }
                });
            });
        } else if (type == 'slot') {
            me.user.slots().each(function(slot) {
                if (slot.data.ekey == value[0]) {
                    data = {
                        slot: slot
                    };
                    data.tooltipText = !slot.data.protect ? ExGods.getMsgByKey('tooltip_text') : '';
                }
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.inventory.stuff.VirtualStoreStuff', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.sourceModel = me.stuff.sourceModel;
        data.decorators.push(ExGods.view.inventory.stuff.decorator.Timer);
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent(),
            destinations = me.stuff.sourceModel.get('destinations');
        data.buttons = [];
        if (destinations.indexOf('inventory') != -1) {
            data.buttons.push({
                text: ExGods.getMsgByKey('virtual_store_get_btn_text'),
                action: 'get_virtual_store_stuff'
            }, {
                text: ExGods.getMsgByKey('virtual_store_get_all_btn_text'),
                action: 'get_all_virtual_store_stuff',
                hidden: data.stuff.params.quantity <= 1
            }, {
                text: ExGods.getMsgByKey('virtual_store_drop_btn_text'),
                action: 'drop_virtual_store_stuff'
            }, {
                text: ExGods.getMsgByKey('virtual_store_drop_all_btn_text'),
                action: 'drop_all_virtual_store_stuff',
                hidden: data.stuff.params.quantity <= 1
            });
        }
        if (destinations.indexOf('guild_store') != -1) {
            data.buttons.push({
                text: ExGods.getMsgByKey('virtual_store_puton_guild_store_btn_text'),
                action: 'guild_virtual_store_stuff'
            }, {
                text: ExGods.getMsgByKey('virtual_store_puton_guild_store_all_btn_text'),
                action: 'guild_all_virtual_store_stuff',
                hidden: data.stuff.params.quantity <= 1
            });
        }
        if (destinations.indexOf('group') != -1) {
            data.buttons.push({
                text: ExGods.getMsgByKey('virtual_store_puton_group_btn_text'),
                action: 'group_virtual_store_stuff'
            });
        }
        if (ExGods.app.getController('Market').isCanSellStuff(data.stuff)) {
            data.buttons.push({
                text: ExGods.getMsgByKey('put_on_market_btn_text'),
                action: 'put_to_market'
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.inventory.stuff.WareHouseStuff', {
    extend: ExGods.stuff.stuff.ItemInstance,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        me.replaceQuantityDecorator(data.decorators);
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        return Ext.apply(data, {
            buttons: [
                {
                    text: ExGods.getMsgByKey('virtual_store_get_btn_text'),
                    action: 'get_warehouse_item'
                }
            ]
        });
    },
    /**
     *    -
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.inventory.stuff.decorator.WareHouseQuantity);
    }
});

Ext.define('ExGods.view.inventory.stuff.Ingredient', {
    extend: ExGods.stuff.stuff.Ingredient,
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        if (ExGods.app.getController('Market').isCanSellStuff({
            type: 'ingredients',
            params: data.stuff.params
        })) {
            data.buttons = [
                {
                    text: ExGods.getMsgByKey('put_on_market_btn_text'),
                    action: 'put_to_market'
                }
            ];
        }
        return data;
    }
});

/**
 *    
 */
Ext.define('ExGods.view.inventory.stuff.decorator.Timer', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var expire_date = data.sourceModel.get('expire_date');
            return expire_date ? ExGods.util.Timers.printTimer('rest', 'virtual-store-item', expire_date, {
                needNormalized: true
            }) : '';
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.inventory.stuff.decorator.WareHouseQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getQuantity: function(data) {
            var quantity = data.itemModel.getQuantity();
            return quantity > 1 ? quantity : false;
        }
    }
});

/**
 *    
 *
 * @author Max Dvortsov
 */
Ext.define('ExGods.view.ProgressDialog', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.progressdialog',
    autoShow: true,
    width: 350,
    bodyPadding: 5,
    y: 200,
    //     
    plugins: [
        'skindeco'
    ],
    cls: 'progress-dialog',
    /**
     * @cfg {Array} buttonsText   
     */
    buttonsText: null,
    /**
     * @cfg {String} title  
     */
    title: '',
    /**
     * @cfg {String} description  
     */
    description: '',
    /**
     * @cfg {String} label    
     */
    label: '',
    /**
     * @cfg {Number} value    
     */
    value: 1,
    /**
     * @cfg {Number} min  
     */
    min: 1,
    /**
     * @cfg {Number} max  
     */
    max: 2,
    /**
     * @cfg {Number} increment  
     */
    increment: 1,
    /**
     * @cfg {Number} inputWidth   
     */
    inputWidth: 100,
    /**
     * @cfg {String} image   
     */
    /**
     * @cfg {Number|Object} item   ,   item      
     */
    /**
     * @cfg {String} value_dependent_text -        
     */
    value_dependent_text: '',
    /**
     * @cfg {Function|Object} handler    -     {fn, scope}
     */
    handler: Ext.emptyFn,
    handler_negative: Ext.emptyFn,
    initComponent: function() {
        var me = this;
        if (me.value_dependent_text) {
            me.value_dependent_text = new Ext.XTemplate(me.value_dependent_text);
        }
        var innerPanelCfg = {
                plugins: [
                    'paperdeco'
                ],
                width: me.width - 10,
                padding: '0 0 20',
                tpl: [
                    '<tpl if="title">',
                    '<div class="paper-title"><h4>{title}</h4></div>',
                    '</tpl>',
                    '<tpl if="description">',
                    '<div class="progress-description">{description}</div>',
                    '</tpl>',
                    '<div class="progress-core">',
                    '<tpl if="this.isImage()">',
                    '<div class="progress-dialog-image"{[this.getImageStyle()]}></div>',
                    '</tpl>',
                    '<div class="progress-dialog-container">',
                    '<div class="progress-dialog-input">',
                    '<div class="progress-dialog-input-label">{label}</div>',
                    '<div class="progress-dialog-input-field"></div>',
                    '</div>',
                    '<div class="progress-dialog-bar"></div>',
                    '</div>',
                    '</div>',
                    '<tpl if="value_dependent_text">',
                    '<div class="progress-dialog-comission">',
                    '{[ this.getValueDependant() ]}',
                    '</div>',
                    '</tpl>',
                    {
                        isImage: function() {
                            return me.image || me.item;
                        },
                        getImageStyle: function() {
                            var image = me.getImage();
                            if (image && image != true) {
                                return ' style="background-image:url(' + image + ')"';
                            } else  {
                                return '';
                            }
                            
                        },
                        getValueDependant: function() {
                            return me.value_dependent_text.apply({
                                value: me.getValue()
                            });
                        }
                    }
                ],
                data: {
                    title: me.title,
                    description: me.description,
                    label: me.label,
                    value: me.value,
                    value_dependent_text: me.value_dependent_text
                }
            };
        //
        if (!me.buttonsText)  {
            me.buttonsText = ExGods.getMsgByKey('view_confirm_yesno').split(';');
        }
        
        Ext.apply(me, {
            buttonAlign: 'center',
            buttons: {
                margin: '-5 0 15 0',
                defaults: {
                    xtype: 'textbutton',
                    width: 130
                },
                items: [
                    {
                        text: me.buttonsText[0],
                        cls: 'qh-object',
                        handler: function() {
                            if (typeof me.handler == 'object') {
                                me.handler.fn.call(me.handler.scope ? me.handler.scope : me, me.getValue());
                            } else {
                                me.handler.call(me, me.getValue());
                            }
                            me.close();
                        },
                        listeners: {
                            render: function() {
                                if (me.quest_helper_id)  {
                                    //  
                                    this.el.set({
                                        'data-qh_otype': me.quest_helper_type,
                                        'data-qh_oid': me.quest_helper_id
                                    });
                                }
                                
                            }
                        }
                    },
                    {
                        text: me.buttonsText[1],
                        cls: 'x-btn-txt-red',
                        handler: function() {
                            if (typeof me.handler_negative == 'object') {
                                me.handler_negative.fn.call(me.handler_negative.scope ? me.handler_negative.scope : me, me.getValue());
                            } else {
                                me.handler_negative.call(me, me.getValue());
                            }
                            me.close();
                        }
                    }
                ]
            }
        });
        me.items = [
            innerPanelCfg
        ];
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.slider = Ext.widget('exg_slider', {
            width: 188,
            value: me.getValue(),
            increment: me.increment,
            minValue: me.min,
            maxValue: me.max,
            renderTo: me.el.down('.progress-dialog-bar'),
            listeners: {
                change: me.onSliderChange,
                scope: me
            }
        });
        me.input = Ext.widget('numberfield', {
            value: me.getValue(),
            width: me.inputWidth,
            padding: 2,
            renderTo: me.el.down('.progress-dialog-input-field'),
            hideTrigger: true,
            listeners: {
                change: me.onInputChange,
                scope: me
            }
        });
    },
    onDestroy: function() {
        var me = this;
        me.slider.destroy();
        me.input.destroy();
        me.callParent();
    },
    onSliderChange: function(slider, value) {
        this.setValue(value);
    },
    onInputChange: Ext.Function.createBuffered(function(slider, value) {
        if (value || value == 0) {
            this.setValue(value);
            this.slider.setValue(this.value);
        }
    }, 1000),
    /**
     *     ,     
     */
    getImage: function() {
        var me = this,
            image, missed, proto, id,
            protos = ExGods.app.getItemPrototypesStore();
        if (me.image) {
            image = me.image;
        } else if (me.item) {
            id = typeof me.item == 'object' ? me.item.params.id : me.item;
            proto = protos.data.getByKey(id);
            if (proto) {
                image = proto.get('images').info;
            } else {
                missed = id;
            }
        }
        if (image) {
            return image.substr(0, 4) == 'http' ? image : IMAGE_URL + image;
        } else if (missed) {
            protos.loadNew([
                missed
            ], function() {
                me.el.down('.progress-dialog-image').setStyle({
                    backgroundImage: 'url(' + protos.data.getByKey(missed).get('images').info + ')'
                });
            });
            return true;
        } else  {
            return false;
        }
        
    },
    getValue: function() {
        return this.value;
    },
    setValue: function(value) {
        var me = this;
        value = Math.max(me.min, Math.min(me.max, value));
        // 
        me.input.setValue(value);
        //  
        if (me.value_dependent_text && me.el) {
            me.el.down('.progress-dialog-comission').setHTML(me.value_dependent_text.apply({
                value: value
            }));
        }
        me.value = value;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var img = me.getImage();
        if (img === true || img == false) {
            img = undefined;
        } else {
            arr_images.push(img);
        }
        if (me.buttonsText) {
            arr_images = arr_images.concat(me.buttonsText);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.inventory.VirtualStoreView', {
    extend: ExGods.view.grid.FramedSlotsGrid,
    alias: 'widget.virtualstoreview',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.InventoryDragHighlight
    ],
    /**
     * @cfg store      
     **/
    /**
     * @cfg can_drag   true,  false -   
     */
    can_drag: true,
    initComponent: function() {
        var me = this;
        me.cls += ' virtual-store';
        me.itemTpl = [
            '{[ExGods.stuff.StuffManager.image(values)]}'
        ];
        me.callParent();
        me.view = me.down('dataview');
        me.view.on('render', function() {
            if (me.can_drag)  {
                me.initDragAndDrop();
            }
            
        });
        me.mon(me.store, {
            highlight: me.highlight,
            unhighlight: me.unhighlight,
            scope: me
        });
    },
    collectData: function(records) {
        var me = this,
            data = [],
            protos = ExGods.app.getItemPrototypesStore();
        Ext.Array.each(records, function(rec) {
            if (rec.data.entries && rec.data.entries[0]) {
                data.push({
                    type: 'warehouse_stuff',
                    params: {
                        itemModel: rec
                    }
                });
            } else {
                data.push({
                    type: 'virtual_store_stuff',
                    sourceModel: rec,
                    params: {
                        stuff: {
                            params: {
                                id: rec.data.stuff.params.id,
                                quantity: rec.data.stuff.params.quantity
                            },
                            type: rec.data.stuff.type
                        }
                    }
                });
            }
        });
        me.itemsTotalCount = data.length;
        return data;
    },
    /**
     * @override
     */
    getTotalPagesCount: function() {
        var me = this;
        return Math.ceil(me.itemsTotalCount / (me.rowsCount * me.columnsCount)) || 1;
    },
    highlight: function() {
        if (this.el && !this.el.down('.virtual-store-highlight')) {
            this.down('dataview').el.insertHtml('beforeEnd', '<div class="virtual-store-highlight"></div>');
        }
    },
    unhighlight: function() {
        if (this.el && this.el.down('.virtual-store-highlight')) {
            this.el.down('.virtual-store-highlight').remove();
        }
    },
    /**
     * @private
     * D&D 
     */
    initDragAndDrop: function() {
        var me = this;
        me.initDrag({
            view: me.view,
            cancelFn: function() {
                ExGods.app.user.slots().each(function(slot) {
                    if (slot.getSlotType().active == 0)  {
                        slot.fireEvent('unhighlight', slot);
                    }
                    
                });
            }
        });
        me.initDrop({
            onDrop: function(target, dd, e, data) {
                if (Ext.getClassName(data.item) == 'ExGodsCore.model.Item' && ExGods.app.getItemPrototypesStore().data.getByKey(data.item.get('proto_id')).canPutInWareHouse()) {
                    me.fireEvent('put_to_warehouse', data.item, data.cancel);
                } else  {
                    return false;
                }
                
            }
        });
        me.initDragHighlight();
    }
});

/**
 *    
 */
Ext.define('ExGods.view.inventory.Ingredients', {
    extend: ExGods.view.grid.FramedSlotsGrid,
    alias: 'widget.ingredientsview',
    /**
     * @cfg place - proto.place 
     **/
    initComponent: function() {
        var me = this;
        me.store = Ext.create('Ext.data.Store', {
            fields: [
                {
                    name: 'type',
                    type: 'string'
                },
                {
                    name: 'group',
                    type: 'string'
                },
                {
                    name: 'params',
                    type: 'auto'
                }
            ],
            sorters: [
                {
                    property: 'group',
                    direction: 'DESC'
                }
            ]
        });
        me.loadData();
        me.itemTpl = [
            '{[ExGods.stuff.StuffManager.image(values)]}'
        ];
        me.callParent();
        me.mon(ExGods.app.user, 'ingredientschanged', me.loadData, me);
        me.mon(me.store, {
            highlight: me.highlight,
            unhighlight: me.unhighlight,
            scope: me
        });
    },
    loadData: function() {
        var me = this,
            data = [];
        Ext.Array.each(ExGods.app.user.data.ingredients, function(ingredient) {
            var proto = ExGods.ref('ingredients|' + ingredient.name);
            if (proto.place == me.place) {
                data.push({
                    type: 'user_ingredient',
                    group: proto.group,
                    params: {
                        id: ingredient.name,
                        quantity: ingredient.value
                    }
                });
            }
        });
        me.store.loadRawData(data);
    },
    highlight: function() {
        if (!this.el.down('.slotsgrid-highlight')) {
            this.down('dataview').el.insertHtml('beforeEnd', '<div class="slotsgrid-highlight"></div>');
        }
    },
    unhighlight: function() {
        if (this.el.down('.slotsgrid-highlight')) {
            this.el.down('.slotsgrid-highlight').remove();
        }
    }
});

/**
 *  
 */
Ext.define('ExGods.view.Slider', {
    extend: Ext.panel.Panel,
    alias: 'widget.exg_slider',
    useTips: false,
    width: 188,
    height: 22,
    /**
     * @cfg {Number} value  
     */
    value: 1,
    /**
     * @cfg {Number} minValue  
     */
    minValue: 1,
    /**
     * @cfg {Number} maxValue  
     */
    maxValue: 2,
    /**
     * @cfg {Number} increment  
     */
    increment: 1,
    /**
     * @cfg {Number} upperScale   .  0 -  
     */
    upperScale: 0,
    /**
     * @cfg {String} title  
     */
    title: 0,
    /**
     * @cfg {Boolean} disabled
     */
    disabled: false,
    initComponent: function() {
        var me = this;
        me.cls = me.cls ? me.cls + ' exg-slider-bar' : 'exg-slider-bar';
        me.html = [
            '<div class="exg-slider-arrow left-arrow"></div>',
            '<div class="exg-slider-arrow right-arrow"></div>',
            '<div class="exg-slider-bar-slider"></div>'
        ];
        if (me.title || me.upperScale) {
            var html = [];
            if (me.title) {
                html.push('<div class="exg-slider-title">' + me.title + '</div>');
                delete me.title;
            }
            if (me.upperScale) {
                me.upperScale = Math.ceil(me.upperScale);
                var i = me.minValue,
                    left;
                html.push('<div class="exg-slider-scale">');
                while (i < me.maxValue) {
                    left = Math.floor((me.width - 42 - /* */
                    28) * /* */
                    (i - me.minValue) / (me.maxValue - me.minValue));
                    html.push('<p style="left:' + left + 'px">' + Math.floor(i) + '</p>');
                    i += me.upperScale;
                }
                html.push('<p style="left:' + (me.maxValue == 1 ? 0 : me.width - 42 - 28) + 'px">' + me.maxValue + '</p>');
                html.push('</div>');
            }
            me.dockedItems = [
                {
                    dock: 'top',
                    xtype: 'component',
                    height: 20,
                    html: html.join('')
                }
            ];
            me.height += 21;
        }
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.slider = Ext.widget('slider', {
            useTips: me.useTips,
            width: me.width - 54,
            ui: 'default',
            value: me.value,
            increment: me.increment,
            minValue: me.minValue,
            maxValue: me.maxValue,
            disabled: me.disabled,
            renderTo: me.el.down('.exg-slider-bar-slider')
        });
        me.relayEvents(me.slider, [
            'change'
        ]);
        //    
        me.el.on('click', function() {
            me.setValue(me.getValue() - me.increment);
        }, me, {
            delegate: '.left-arrow'
        });
        //    
        me.el.on('click', function() {
            me.setValue(me.getValue() + me.increment);
        }, me, {
            delegate: '.right-arrow'
        });
        me.callParent();
    },
    setValue: function(value, animate) {
        this.value = value;
        return this.slider.setValue(value, animate);
    },
    getValue: function() {
        return this.slider.getValue();
    },
    /**
     * override
     */
    disable: function() {
        this.addCls('disabled');
        if (this.slider) {
            this.slider.disable();
        }
    },
    /**
     * override
     */
    enable: function() {
        this.removeCls('disabled');
        if (this.slider) {
            this.slider.enable();
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'scrollbar/hor_arrow_bottom.png',
                IMAGE_URL + 'scrollbar/hor_arrow_top.png',
                IMAGE_URL + 'scrollbar/hor_bg_bottom.png',
                IMAGE_URL + 'scrollbar/hor_bg_top.png',
                IMAGE_URL + 'scrollbar/hor_bg_midle.png',
                IMAGE_URL + 'scrollbar/hor_thumb_new.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.model.Item', {
    extend: ExGodsCore.model.Item
});

/**
 *     
 */
Ext.define('ExGods.model.VirtualStoreStuff', {
    extend: ExGods.model.Item,
    idProperty: 'entry',
    fields: [
        {
            //    ,     ( , ..       stuffs)
            name: 'entry',
            type: 'auto'
        },
        {
            //     
            name: 'add_time',
            type: 'string'
        },
        {
            //       .   add_time.  
            name: 'expire_date',
            type: 'auto',
            mapping: 'add_time',
            convert: function(v, r) {
                if (!v)  {
                    return v;
                }
                
                var dt = ExGods.util.Date.parseString(v);
                dt = Ext.Date.add(dt, Ext.Date.MINUTE, ExGods.ref('constants|user_store_live').value);
                ExGods.util.Ticker.addListener(r.onTick, r);
                return dt;
            }
        },
        {
            name: 'source_id',
            type: 'string'
        },
        {
            name: 'source_name',
            type: 'string'
        },
        {
            //     
            name: 'destinations',
            type: 'auto'
        },
        {
            // 
            name: 'params',
            type: 'auto'
        },
        {
            //     ,     
            name: 'index',
            type: 'auto'
        },
        {
            // 
            name: 'stuff',
            type: 'auto',
            convert: function(v, r) {
                r.set('proto_id', v.params.id);
                return v;
            }
        },
        {
            //    - entry ,  
            name: 'entries',
            type: 'auto'
        }
    ],
    onTick: function() {
        if (this.isExpired()) {
            ExGods.util.Ticker.removeListener(this.onTick, this);
            var i = this.stores.length;
            while (i--) {
                this.stores[i].remove(this);
            }
        }
    },
    isExpired: function() {
        if (!this.data.expire_date)  {
            return false;
        }
        
        var expireDate = ExGods.util.Date.normalizeServerDateTime(this.data.expire_date);
        var now = new Date();
        if (expireDate <= now) {
            return true;
        } else {
            return false;
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.store.VirtualStore', {
    extend: Ext.data.Store,
    model: 'ExGods.model.VirtualStoreStuff',
    proxy: 'memory',
    id: 'VirtualStore',
    entries: [],
    filters: [
        function(item) {
            return !item.isExpired() && [
                'item',
                'currency'
            ].indexOf(item.data.stuff.type) != -1;
        }
    ],
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        me.on('datachanged', me.onDataChanged, me);
    },
    onDataChanged: function() {
        var me = this,
            oldEntries = me.entries,
            newItems;
        me.entries = [];
        //   entries        . 
        me.each(function(item) {
            //            
            //   1   5,    5,   1.
            var cnt = item.data.stuff.params.quantity;
            for (var j = 0; j < cnt; j++) {
                me.entries.push(item.data.entry);
            }
        });
        newItems = Ext.Array.difference(me.entries, oldEntries);
        if (!me.new_items_block && newItems.length) {
            me.fireEvent('newitemsadded', me, newItems);
        }
    },
    checkExpired: function() {
        var me = this,
            expired = [];
        me.each(function(item) {
            if (item.isExpired()) {
                expired.push(item);
            }
        });
        if (expired.length) {
            me.filter();
        }
    },
    blockNewItemsEvent: function() {
        var me = this;
        me.new_items_block = true;
        setTimeout(function() {
            me.new_items_block = false;
        }, 0);
    }
});

/**
 *     
 */
Ext.define('ExGods.model.WareHouseStuff', {
    extend: ExGods.model.VirtualStoreStuff,
    fields: [
        {
            //    - entry ,  
            name: 'entries',
            type: 'auto'
        },
        {
            name: 'items',
            type: 'auto'
        }
    ],
    isWareHouse: function() {
        return this.get('entries') && this.get('entries').length;
    },
    getQuantity: function() {
        var count = 0;
        Ext.Array.each(this.get('items'), function(el) {
            var quantity = el.param ? Number(el.param.count) : 1;
            count += quantity || 1;
        });
        return count;
    },
    isExpired: function() {
        var me = this,
            expire_str = me.data.param ? me.data.param.expire_str : undefined,
            proto = me.getProto(),
            validto = proto ? proto.data.data.validto : undefined,
            expire_date,
            now = new Date();
        if (expire_str) {
            expire_str = ExGods.util.Date.parseString(expire_str) || Infinity;
        } else  {
            expire_str = Infinity;
        }
        
        if (validto) {
            validto = ExGods.util.Date.parseString(validto) || Infinity;
        } else  {
            validto = Infinity;
        }
        
        if (expire_str !== Infinity || validto !== Infinity) {
            expire_date = ExGods.util.Date.normalizeServerDateTime(new Date(Math.min(expire_str, validto)));
        }
        return expire_date && expire_date <= now;
    }
});

/**
 *   
 */
Ext.define('ExGods.store.WareHouse', {
    extend: Ext.data.Store,
    model: 'ExGods.model.WareHouseStuff',
    proxy: 'memory',
    id: 'WareHouse',
    sorters: [
        {
            sorterFn: function(m1, m2) {
                if (m1.get('expire_date') && m2.get('expire_date')) {
                    return m1.get('expire_date') > m2.get('expire_date') ? -1 : 1;
                } else if (m1.get('expire_date')) {
                    return -1;
                } else if (m2.get('expire_date')) {
                    return 1;
                } else  {
                    return 0;
                }
                
            }
        }
    ],
    constructor: function(config) {
        var me = this;
        me.callParent(arguments);
        ExGods.app.getStore('VirtualStore').on('datachanged', me.updateVirtualStoreRecords, me);
    },
    updateVirtualStoreRecords: function() {
        var me = this,
            toRemove = [],
            data = [];
        me.each(function(rec) {
            if (!rec.isWareHouse()) {
                toRemove.push(rec);
            }
        });
        me.remove(toRemove);
        ExGods.app.getStore('VirtualStore').each(function(rec) {
            data.push(Ext.clone(rec.raw));
        });
        me.superclass.loadRawData.call(me, data, true);
    },
    /**
     *        
     *    
     */
    loadRawData: function(data, append, cb) {
        var me = this;
        var stuff = Ext.Array.map(data, function(el) {
                return {
                    params: {
                        id: el.proto_id,
                        quantity: 1
                    },
                    type: 'item'
                };
            });
        ExGods.helpme.loadProtosFromStuff(stuff, function() {
            data = me.prepareWareHouseItems(data);
            if (!append) {
                me.removeAll();
                ExGods.app.getStore('VirtualStore').each(function(rec) {
                    data.push(rec.raw);
                });
            }
            me.superclass.loadRawData.call(me, data, true);
            if (cb)  {
                cb();
            }
            
        });
    },
    /**
     * @private        
     */
    prepareWareHouseItems: function(data) {
        var me = this,
            preparedData = [],
            stackData = {},
            protos = ExGods.app.getItemPrototypesStore().data;
        Ext.Array.each(data, function(el) {
            var proto = protos.getByKey(el.proto_id),
                stuffEl = {
                    params: {
                        id: el.proto_id,
                        quantity: 1
                    },
                    type: 'item'
                },
                cfg = {
                    stuff: stuffEl,
                    entries: [
                        el.entry
                    ],
                    items: [
                        el
                    ],
                    param: el.param,
                    proto_id: el.proto_id,
                    features: el.features
                };
            if (proto.get('data') && proto.get('data').stack) {
                if (stackData[el.proto_id]) {
                    stackData[el.proto_id].entries.push(el.entry);
                    stackData[el.proto_id].items.push(el);
                } else {
                    stackData[el.proto_id] = cfg;
                }
            } else {
                preparedData.push(cfg);
            }
        });
        Ext.Object.each(stackData, function(proto_id, el) {
            preparedData.push(el);
        });
        return preparedData;
    },
    checkExpired: function() {
        var me = this,
            expired = [];
        me.each(function(item) {
            if (item.isExpired()) {
                expired.push(item);
            }
        });
        if (expired.length) {
            me.remove(expired);
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.controller.inventory.VirtualStore', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /** getInventoryItemsView */
            ref: 'inventoryItemsView',
            selector: '#inventory_slots'
        },
        {
            /** getVirtualStoreView */
            ref: 'virtualStoreView',
            selector: '#virtual_store_view'
        },
        {
            /** getEssenceView */
            ref: 'essenceView',
            selector: '#essence_view'
        },
        {
            /** getIngredientsView */
            ref: 'ingredientsView',
            selector: '#ingredients_view'
        }
    ],
    views: [
        'item.InventorySlot',
        'inventory.VirtualStoreView',
        'inventory.Ingredients',
        'ProgressDialog',
        'ExGods.view.Slider'
    ],
    stores: [
        'VirtualStore',
        'WareHouse'
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'VirtualStore:'
    },
    tooltips: [
        'item'
    ],
    init: function(app) {
        var me = this;
        me.virtualStore = ExGods.app.getStore('VirtualStore');
        me.wareHouseStore = ExGods.app.getStore('WareHouse');
        me.listen({
            component: {
                '#virtual_store_view dataview': {
                    itemdblclick: me.onItemDblClick
                },
                'virtualstoreview': {
                    put_to_warehouse: me.putToWareHouse
                }
            }
        });
        ExGods.util.Timers.on('virtual-store-item-expire', me.onTimerExpired, me);
        me.startExpireMonitor();
        me.inventory = me.app.getController('inventory.Inventory');
        ExGods.stuff.StuffManager.register({
            'warehouse_stuff': {
                classObj: ExGods.view.inventory.stuff.WareHouseStuff,
                listeners: {
                    get_warehouse_item: me.onGetWareHouseItemClick,
                    scope: me
                }
            },
            'virtual_store_stuff': {
                classObj: ExGods.view.inventory.stuff.VirtualStoreStuff,
                listeners: {
                    get_virtual_store_stuff: me.onGetVirtualStoreStuffClick,
                    drop_virtual_store_stuff: me.onDropVirtualStoreStuffClick,
                    get_all_virtual_store_stuff: me.onGetAllVirtualStoreStuffClick,
                    drop_all_virtual_store_stuff: me.onDropAllVirtualStoreStuffClick,
                    guild_virtual_store_stuff: me.onGuildVirtualStoreStuffClick,
                    guild_all_virtual_store_stuff: me.onGuildAllVirtualStoreStuffClick,
                    group_virtual_store_stuff: me.onGroupVirtualStoreStuffClick,
                    put_to_market: me.onPutToMarketClick,
                    scope: me
                }
            },
            'user_ingredient': {
                classObj: ExGods.view.inventory.stuff.Ingredient,
                listeners: {
                    put_to_market: me.onIngredientPutToMarketClick,
                    scope: me
                }
            }
        });
        ExGods.Components.addComponentInitializer('virtual_store', me.initVirtualStoreComponent, me);
    },
    initVirtualStoreComponent: function(config) {
        var me = this,
            notActiveSlots = [],
            filterItems = [],
            fucinaFilterItems = [],
            homeFilterItems = [],
            win, cmp,
            stuff = [],
            defaults = {
                xtype: 'checkboxfield',
                checked: true,
                style: {
                    color: '#e3ac69'
                },
                padding: '0 15 0 0'
            },
            showInventory = function() {
                if (Ext.getCmp('INVENTORY')) {
                    Ext.getCmp('INVENTORY').show();
                } else {
                    ExGods.Components.factory("INVENTORY");
                }
            };
        ExGods.references.get('ingredients').each(function(k, v) {
            if (v.place == 'fucina' && fucinaFilterItems.indexOf(v.group) == -1) {
                fucinaFilterItems.push(v.group);
            } else if (v.place == 'home' && homeFilterItems.indexOf(v.group) == -1) {
                homeFilterItems.push(v.group);
            }
        });
        fucinaFilterItems = Ext.Array.map(fucinaFilterItems, function(v) {
            return Ext.apply({
                boxLabel: v,
                slotType: v
            }, defaults, {
                listeners: {
                    change: me.onFucinaFilterChange,
                    scope: me
                }
            });
        });
        homeFilterItems = Ext.Array.map(homeFilterItems, function(v) {
            return Ext.apply({
                boxLabel: v,
                slotType: v
            }, defaults, {
                listeners: {
                    change: me.onHomeFilterChange,
                    scope: me
                }
            });
        });
        ExGods.app.user.slots().each(function(slot) {
            if (!slot.getSlotTypeInfo().active) {
                notActiveSlots.push(slot);
                filterItems.push({
                    boxLabel: slot.data.name,
                    slotType: slot.data.type
                });
            }
        });
        var dubl = Ext.getCmp('VIRTUAL_STORE');
        if (dubl) {
            dubl.close();
        }
        
        win = Ext.widget('window2', {
            id: 'VIRTUAL_STORE',
            autoShow: false,
            items: [],
            closeAction: 'destroy'
        });
        me.inventoryItemsView = me.inventory.createInventorySlotsView();
        cmp = Ext.widget('skintabpanel', {
            cls: 'owerflow_visible_panel',
            bodyPadding: '0 11 11',
            items: [
                {
                    icon: ExGods.ref('images|virtual_store_images').image.vstore_tab,
                    layout: 'absolute',
                    items: [
                        {
                            xtype: 'form',
                            x: 395,
                            y: -38,
                            width: 365,
                            height: 30,
                            tbar: {
                                xtype: 'panel',
                                bodyCls: 'parchment-content-nop',
                                defaults: {
                                    xtype: 'checkboxfield',
                                    checked: true,
                                    style: {
                                        color: '#e3ac69'
                                    },
                                    padding: '0 15 0 0',
                                    listeners: {
                                        change: me.onFilterChange,
                                        scope: me
                                    }
                                },
                                items: filterItems,
                                layout: 'hbox'
                            }
                        },
                        me.inventoryItemsView,
                        {
                            xtype: 'virtualstoreview',
                            itemId: 'virtual_store_view',
                            rowsCount: 4,
                            columnsCount: 5,
                            x: 16,
                            y: 22,
                            store: me.wareHouseStore,
                            pager: {
                                marginLeft: -39,
                                marginRight: -37,
                                textTop: 270,
                                textLeft: 104
                            },
                            headerText: ExGods.getMsgByKey('virtual_store_title_text'),
                            listeners: {
                                destroy: function() {
                                    me.wareHouseStore.clearFilter();
                                }
                            }
                        },
                        {
                            xtype: 'container',
                            layout: {
                                type: 'hbox',
                                pack: 'center'
                            },
                            width: 340,
                            height: 80,
                            x: 405,
                            y: 330,
                            items: [
                                {
                                    xtype: 'textbutton',
                                    text: config.rucksack_btn_text,
                                    width: 120,
                                    handler: showInventory
                                }
                            ]
                        }
                    ],
                    listeners: {
                        show: function() {
                            this.down('iteminventoryslot').show();
                            this.down('virtualstoreview').show();
                        },
                        hide: function() {
                            this.down('iteminventoryslot').hide();
                            this.down('virtualstoreview').hide();
                        }
                    }
                },
                {
                    icon: ExGods.ref('images|virtual_store_images').image.fucina_tab,
                    items: [
                        {
                            xtype: 'form',
                            x: 210,
                            y: -38,
                            width: 392,
                            height: 30,
                            items: fucinaFilterItems,
                            style: {
                                zIndex: 10
                            },
                            layout: {
                                type: 'hbox',
                                pack: 'end'
                            }
                        },
                        {
                            xtype: 'form',
                            x: 600,
                            y: -68,
                            width: 132,
                            height: 21,
                            tbar: {
                                xtype: 'textfield',
                                cls: 'text-search-input',
                                emptyText: ExGods.getMsgByKey('ingredients_input_empty'),
                                listeners: {
                                    change: me.onFucinaFilterChange,
                                    scope: me
                                },
                                value: ''
                            }
                        },
                        {
                            xtype: 'ingredientsview',
                            itemId: 'ingredients_view',
                            rowsCount: 4,
                            columnsCount: 11,
                            x: 16,
                            y: -29,
                            place: 'fucina',
                            headerText: ExGods.getMsgByKey('ingredients_title_text'),
                            pager: {
                                marginLeft: -39,
                                marginRight: -39,
                                textTop: 272,
                                textLeft: 295
                            }
                        }
                    ],
                    buttons: {
                        padding: '0 0 10',
                        defaults: {
                            xtype: 'textbutton',
                            width: 120
                        },
                        items: [
                            {
                                text: config.rucksack_btn_text,
                                margin: '0 123 0 0',
                                handler: showInventory
                            }
                        ]
                    },
                    listeners: {
                        show: function() {
                            this.down('ingredientsview').show();
                        },
                        hide: function() {
                            this.down('ingredientsview').hide();
                        }
                    }
                },
                {
                    icon: ExGods.ref('images|virtual_store_images').image.essence_tab,
                    items: [
                        {
                            xtype: 'form',
                            x: 210,
                            y: -38,
                            width: 392,
                            height: 30,
                            items: homeFilterItems,
                            style: {
                                zIndex: 10
                            },
                            layout: {
                                type: 'hbox',
                                pack: 'end'
                            }
                        },
                        {
                            xtype: 'form',
                            x: 600,
                            y: -68,
                            width: 132,
                            height: 21,
                            tbar: {
                                xtype: 'textfield',
                                cls: 'text-search-input',
                                emptyText: ExGods.getMsgByKey('home_input_empty'),
                                listeners: {
                                    change: me.onHomeFilterChange,
                                    scope: me
                                },
                                value: ''
                            }
                        },
                        {
                            xtype: 'ingredientsview',
                            itemId: 'essence_view',
                            rowsCount: 4,
                            columnsCount: 11,
                            x: 16,
                            y: -29,
                            place: 'home',
                            headerText: ExGods.getMsgByKey('home_title_text'),
                            pager: {
                                marginLeft: -39,
                                marginRight: -39,
                                textTop: 272,
                                textLeft: 295
                            }
                        }
                    ],
                    buttons: {
                        padding: '0 0 10',
                        defaults: {
                            xtype: 'textbutton',
                            width: 120
                        },
                        items: [
                            {
                                text: config.rucksack_btn_text,
                                margin: '0 123 0 0',
                                handler: showInventory
                            }
                        ]
                    },
                    listeners: {
                        show: function() {
                            this.down('ingredientsview').show();
                        },
                        hide: function() {
                            this.down('ingredientsview').hide();
                        }
                    }
                }
            ]
        });
        if (ExGods.app.getStore('Loot').getCount()) {
            cmp.add({
                icon: ExGods.ref('images|virtual_store_images').image.lm_tab,
                layout: 'fit',
                itemId: 'lm_container',
                items: [
                    {
                        xtype: 'lmcontainer'
                    }
                ],
                buttonAlign: 'center',
                buttons: {
                    padding: '0 0 10',
                    defaults: {
                        xtype: 'textbutton',
                        width: 120
                    },
                    items: [
                        {
                            text: config.take_all_btn_text,
                            itemId: 'self_loot_btn',
                            margin: '0 136 0 0'
                        },
                        {
                            text: config.rucksack_btn_text,
                            margin: '0 0 0 136',
                            handler: showInventory
                        }
                    ]
                },
                listeners: {
                    show: function() {
                        this.down('lootslots').show();
                    },
                    hide: function() {
                        this.down('lootslots').hide();
                    }
                }
            });
            ExGods.app.getStore('Loot').each(function(rec) {
                stuff.push(rec.get('stuff'));
            });
            var cmp_ = cmp.down('lmcontainer');
            ExGods.Resources.load(cmp_, function() {
                cmp.setActiveTab('lm_container');
            });
        }
        win.add(cmp);
        me.inventory.service.command('get_warehouse', {}, function(data) {
            if (data.success) {
                ExGods.helpme.loadProtosFromStuff(stuff, function() {
                    me.wareHouseStore.loadRawData(data.warehouse, false, function() {
                        ExGods.Resources.load(me, function() {
                            Ext.getCmp('INVENTORY').down('#virtualStoreBtn').enable();
                            win.show();
                        });
                    });
                });
            } else {
                win.close();
                Ext.getCmp('INVENTORY').down('#virtualStoreBtn').enable();
            }
        });
        return win;
    },
    onGetWareHouseItemClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.params.itemModel);
        win.close();
    },
    onGetVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.sourceModel, 1, function() {
            win.close();
        });
    },
    onDropVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doRemoveItems(data.stuff.sourceModel, 1, function() {
            win.close();
        });
    },
    onGetAllVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.sourceModel, null, function() {
            win.close();
        });
    },
    onDropAllVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doRemoveItems(data.stuff.sourceModel, null, function() {
            win.close();
        });
    },
    onGuildVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.sourceModel, 1, function() {
            win.close();
        }, {
            destination: 'guild_store'
        });
    },
    onGuildAllVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutItems(data.stuff.sourceModel, null, function() {
            win.close();
        }, {
            destination: 'guild_store'
        });
    },
    onGroupVirtualStoreStuffClick: function(data, btn, win) {
        var me = this;
        me.doPutOnGroup(data.stuff.sourceModel, 1, function() {
            win.close();
        });
    },
    onPutToMarketClick: function(data, btn, win) {
        var me = this,
            marketController = me.app.getController('Market'),
            market_item = marketController.getMarketItemInfo(data.stuff);
        me.app.getController('Market').putStoreStuffToMarket(Ext.apply({
            entry: market_item.entry
        }, data.stuff));
    },
    onIngredientPutToMarketClick: function(data, btn, win) {
        var me = this,
            marketController = me.app.getController('Market'),
            stuff = {
                type: 'ingredients',
                params: data.stuff.params
            },
            market_item = marketController.getMarketItemInfo(stuff);
        me.app.getController('Market').putInventoryStuffToMarket(Ext.apply({
            entry: market_item.entry
        }, stuff));
    },
    /**
     * @private     dataview
     */
    onItemDblClick: function(view, item, itemEl) {
        var me = this;
        me.preventClick = true;
        me.doPutItems(item);
    },
    onFilterChange: function(field) {
        this.filterVirtualStore(this.getInventoryItemsView().store, field);
        this.filterVirtualStore(this.getVirtualStoreView().store, field);
    },
    onFucinaFilterChange: function(field) {
        this.filterStore(this.getIngredientsView().store, field);
    },
    onHomeFilterChange: function(field) {
        this.filterStore(this.getEssenceView().store, field);
    },
    filterStore: function(store, field) {
        var me = this,
            values = [],
            text = '';
        Ext.Array.each(field.up().up().query('checkboxfield'), function(checkBox) {
            if (checkBox.getValue()) {
                values.push(checkBox.slotType);
            }
        });
        var textfield = field.up('form').up().down('textfield');
        if (textfield)  {
            text = textfield.getValue().toLowerCase();
        }
        
        store.removeFilter('user_filter');
        store.addFilter(Ext.util.Filter({
            filterFn: function(rec) {
                var title = rec.get('title');
                if (!title) {
                    var ingredient = ExGods.ref('ingredients|' + rec.get('params').id);
                    if (ingredient)  {
                        title = ingredient.label;
                    }
                    
                }
                return values.indexOf(rec.get('group')) != -1 && (!title || !text || title.toLowerCase().indexOf(text) != -1);
            },
            id: 'user_filter'
        }));
    },
    filterVirtualStore: function(store, field) {
        var me = this,
            values = [],
            protos = ExGods.app.getItemPrototypesStore(),
            all_checked = true;
        Ext.Array.each(field.up().up().query('checkboxfield'), function(checkBox) {
            if (checkBox.getValue()) {
                values.push(checkBox.slotType);
            } else  {
                all_checked = false;
            }
            
        });
        if (store.id == 'VirtualStore') {
            store.blockNewItemsEvent();
        }
        store.removeFilter('user_filter');
        if (!all_checked) {
            store.addFilter(Ext.util.Filter({
                filterFn: function(rec) {
                    var proto = protos.getById(rec.get('proto_id')) || protos.data.getByKey(rec.data.stuff.params.id);
                    if (!proto)  {
                        return false;
                    }
                    
                    var slotType = proto.getTypeInfo().slot_off;
                    return values.indexOf(slotType) != -1;
                },
                id: 'user_filter'
            }));
        }
    },
    /**
     *      
     * @param record      
     * @param quantity - .    =  
     * @param callback 
     * @param opts 
     *      destination -   
     *      title -  display_title,  destination == "group"
     */
    doPutItems: function(record, quantity, callback, opts) {
        var me = this;
        opts = opts || {};
        //    -  
        if (Ext.getClassName(record) == 'ExGods.model.WareHouseStuff' && record.isWareHouse()) {
            me.putFromWareHouse(record, callback);
        } else {
            if (!quantity) {
                quantity = record.data.stuff.params.quantity;
            }
            me.app.block();
            me.inventory.service.command('put_from_store', {
                entry: record.data.entry,
                destination: opts.destination || 'inventory',
                title: opts.title || undefined,
                index: record.data.index + 1,
                // required 1 based
                quantity: quantity
            }, function(json) {
                me.app.unblock();
                if (callback) {
                    callback();
                }
            });
        }
    },
    /**
     *      
     */
    doPutAllItems: function() {
        var me = this,
            entries = [],
            finished = 0,
            onRequest = function(json) {
                if (++finished == entries.length || json.success != 1) {
                    ExGods.app.unblock();
                    me.virtualStore.resumeEvents(true);
                } else {
                    putOnItem(entries[finished]);
                }
            },
            putOnItem = function(entry) {
                me.inventory.service.command('put_from_store', {
                    entry: entry,
                    destination: 'inventory'
                }, function(json) {
                    onRequest(json);
                });
            };
        me.virtualStore.suspendEvents(true);
        me.virtualStore.each(function(item) {
            entries.push(item.data.entry);
        });
        entries = Ext.Array.unique(entries);
        if (entries.length) {
            ExGods.app.block();
            putOnItem(entries[0]);
        }
    },
    /**
     *     
     * @param virtualStoreStuff    
     * @param quantity - .    =  
     */
    doPutOnGroup: function(virtualStoreStuff, quantity, callback) {
        var me = this,
            store;
        if (virtualStoreStuff.data.params && virtualStoreStuff.data.params.users) {
            ExGods.Components.factory('USER_TARGET_PANEL', {
                users: virtualStoreStuff.data.params.users,
                listeners: {
                    select: function(panel, record) {
                        me.doPutItems(virtualStoreStuff, quantity, callback, {
                            destination: 'group',
                            title: record.data.display_title
                        });
                        win.close();
                    }
                }
            });
        }
    },
    /**
     *      
     * @param virtualStoreStuff    
     * @param quantity - .    =  
     */
    doRemoveItems: function(virtualStoreStuff, quantity, callback) {
        var me = this;
        if (!quantity) {
            quantity = virtualStoreStuff.data.stuff.params.quantity;
        }
        me.app.block();
        me.inventory.service.command('remove_from_store', {
            entry: virtualStoreStuff.data.entry,
            index: virtualStoreStuff.data.index + 1,
            // required 1 based
            quantity: quantity
        }, function(json) {
            me.app.unblock();
            if (callback) {
                callback();
            }
        });
    },
    /**
     *    
     */
    putToWareHouse: function(item, negative_cb) {
        var me = this,
            ids = item.get('stack_ids'),
            l = item.get('count') || 1,
            proto = ExGods.app.getItemPrototypesStore().data.getByKey(item.get('proto_id')),
            cost = proto.getWareHouseCost(),
            msgCfg = {
                cost: {
                    name: cost.currency,
                    value: cost.value
                },
                item: {
                    id: item.get('proto_id'),
                    title: proto.get('title')
                }
            },
            callback = function(data) {
                if (data.success) {
                    me.wareHouseStore.loadRawData(data.warehouse, false, function() {
                        me.app.unblock();
                    });
                } else  {
                    me.app.unblock();
                }
                
            };
        negative_cb = negative_cb || Ext.emptyFn;
        if (l > 1) {
            var cmp = Ext.widget('progressdialog', {
                    title: proto.get('title'),
                    item: item.get('proto_id'),
                    description: ExGods.app.applyTpl(ExGods.getMsgByKey('ctrl_virtstore_progressdesc'), msgCfg),
                    label: ExGods.getMsgByKey('ctrl_virtstore_progresslabel'),
                    value: l,
                    min: 1,
                    max: l,
                    inputWidth: 38,
                    handler: function(value) {
                        if (item.isExpired())  {
                            return;
                        }
                        
                        me.app.block();
                        me.inventory.service.command('put_to_warehouse_some', {
                            item_proto: item.get('proto_id'),
                            slot: item.get('slot_id'),
                            count: value
                        }, callback);
                    },
                    handler_negative: negative_cb,
                    value_dependent_text: [
                        Ext.String.format(ExGods.getMsgByKey('ctrl_virtstore_progresstpl'), '{[ExGods.printMoney({name:"' + cost.currency + '",value:this.calcValue(values)})]}'),
                        {
                            calcValue: function(values) {
                                return Math.ceil(values.value * cost.value);
                            }
                        }
                    ],
                    buttonsText: [
                        ExGods.getMsgByKey('warehouse_confirm_yes'),
                        ExGods.getMsgByKey('warehouse_confirm_no')
                    ],
                    listeners: {
                        close: negative_cb
                    }
                });
            ExGods.Resources.load(cmp, function() {
                cmp.show();
            });
        } else {
            Ext.widget('confirmdialog', {
                message: ExGods.app.applyTpl(ExGods.getMsgByKey('ctrl_virtstore_warehouseconfirm'), msgCfg),
                handler: function() {
                    if (item.isExpired())  {
                        return;
                    }
                    
                    me.app.block();
                    if (proto.isStack()) {
                        me.inventory.service.command('put_to_warehouse_some', {
                            item_proto: item.get('proto_id'),
                            slot: item.get('slot_id'),
                            count: 1
                        }, callback);
                    } else {
                        me.inventory.service.command('put_to_warehouse', {
                            item: item.get('item_id'),
                            slot: item.get('slot_id')
                        }, callback);
                    }
                },
                handler_negative: negative_cb,
                listeners: {
                    close: negative_cb
                }
            });
        }
    },
    /**
     *    
     */
    putFromWareHouse: function(item, negative_cb) {
        var me = this,
            ids = item.get('entries'),
            l = item.getQuantity(),
            proto_id = item.get('stuff').params.id,
            proto = ExGods.app.getItemPrototypesStore().data.getByKey(proto_id),
            msgCfg = {
                item: {
                    id: proto_id,
                    title: proto.get('title')
                }
            },
            callback = function(data) {
                if (data.success) {
                    me.wareHouseStore.loadRawData(data.warehouse, false, function() {
                        me.app.unblock();
                    });
                } else  {
                    me.app.unblock();
                }
                
            };
        negative_cb = negative_cb || Ext.emptyFn;
        if (l > 1) {
            var cmp = Ext.widget('progressdialog', {
                    title: proto.get('title'),
                    item: proto_id,
                    description: ExGods.app.applyTpl(ExGods.getMsgByKey('ctrl_virtstore_out_progressdesc'), msgCfg),
                    label: ExGods.getMsgByKey('ctrl_virtstore_progresslabel'),
                    value: l,
                    min: 1,
                    max: l,
                    autoShow: false,
                    inputWidth: 38,
                    handler: function(value) {
                        me.app.block();
                        me.inventory.service.command('put_from_warehouse_some', {
                            item_proto: proto_id,
                            count: value
                        }, callback);
                    },
                    handler_negative: negative_cb,
                    buttonsText: [
                        ExGods.getMsgByKey('warehouse_confirm_yes'),
                        ExGods.getMsgByKey('warehouse_confirm_no')
                    ],
                    listeners: {
                        close: negative_cb
                    }
                });
            ExGods.Resources.load(cmp, function() {
                cmp.show();
            });
        } else {
            Ext.widget('confirmdialog', {
                message: ExGods.app.applyTpl(ExGods.getMsgByKey('ctrl_virtstore_out_warehouseconfirm'), msgCfg),
                handler: function() {
                    me.app.block();
                    if (proto.isStack()) {
                        me.inventory.service.command('put_from_warehouse_some', {
                            item_proto: proto_id,
                            count: 1
                        }, callback);
                    } else {
                        me.inventory.service.command('put_from_warehouse', {
                            entry: item.get('entries')
                        }, callback);
                    }
                },
                handler_negative: negative_cb,
                listeners: {
                    close: negative_cb
                }
            });
        }
    },
    /**
     * @private    
     */
    onTimerExpired: function() {
        var me = this;
        me.virtualStore.filter();
    },
    /**
     * @private     
     */
    startExpireMonitor: function() {
        var me = this;
        setInterval(function() {
            me.virtualStore.checkExpired();
            me.wareHouseStore.checkExpired();
        }, 1000);
    },
    /**
     *  
     */
    getResources: function() {
        var me = this,
            stuff = [];
        me.virtualStore.each(function(record) {
            stuff = stuff.concat(record.data.stuff);
        });
        return {
            stuff: stuff
        };
    },
    /**
     *    
     */
    getTooltipData: function(type, value) {
        var me = this,
            data;
        if (type == 'item') {
            me.wareHouseStore.each(function(rec) {
                if (rec.get('entries').indexOf(value) != -1) {
                    data = {
                        item: rec,
                        tooltipText: ExGods.getMsgByKey('tooltip_text')
                    };
                }
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.inventory.stuff.InventoryItem', {
    extend: ExGods.stuff.stuff.ItemInstance,
    /**
     * override
     */
    getDblClickAction: function() {
        var inventoryCmp = Ext.getCmp('INVENTORY');
        if (inventoryCmp && inventoryCmp.isVisible()) {
            return 'put_on';
        } else {
            return 'put_to_warehouse';
        }
    },
    getImageData: function() {
        var me = this,
            data = me.callParent();
        me.replaceQuantityDecorator(data.decorators);
        data.decorators.push(ExGods.view.inventory.stuff.decorator.QuestHelper, ExGods.view.item.stuff.decorator.CriticalDurability);
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent(),
            user = ExGods.app.getUser(),
            slot_on = references.get('item_type').getByKey(data.protoModel.get('type')).slot_on,
            actions = data.protoModel.get('action_full'),
            param = data.itemModel.get('param'),
            inventoryCmp = Ext.getCmp('INVENTORY');
        data.buttons = [];
        if (inventoryCmp && inventoryCmp.isVisible()) {
            if (user.slots().findExact('type', slot_on) != -1) {
                data.buttons.push({
                    action: 'put_on',
                    cls: 'qh-object no_border',
                    text: ExGods.getMsgByKey('put_on_item'),
                    qh: {
                        'data-qh_otype': 'inventory_item_button_puton',
                        'data-qh_oid': data.protoModel.get('entry')
                    }
                });
            }
        } else if (data.protoModel.canPutInWareHouse()) {
            data.buttons.push({
                action: 'put_to_warehouse',
                text: ExGods.getMsgByKey('put_to_warehouse_btn')
            });
        }
        if (!user.isChain()) {
            Ext.Array.each(data.protoModel.get('condition_actions'), function(action) {
                if (action.type != 'battle') {
                    data.buttons.push({
                        action_data: action,
                        actionType: 'condition_actions',
                        action: 'item_action',
                        text: action.label
                    });
                }
            });
            Ext.Array.each(actions, function(action) {
                switch (action.type) {
                    case 'dialog':
                        data.buttons.push({
                            action_data: action,
                            actionType: action.type,
                            action: 'item_action',
                            text: action.label,
                            value: action.entry
                        });
                        break;
                    case 'map':
                        data.buttons.push({
                            action_data: action,
                            action: 'item_action',
                            actionType: action.type,
                            text: ExGods.app.applyTpl(action.label, param) + (action.costs && action.costs.length ? ' (' + ExGods.util.Stuff.printStuff(action.costs, {
                                delimiter: ',&nbsp;'
                            }) + ')' : ''),
                            value: action.entry,
                            cls: 'qh-object no_border do-map-action',
                            id: 'map-action_' + action.entry,
                            qh: {
                                'data-qh_otype': 'map_action',
                                'data-qh_oid': action.entry
                            }
                        });
                        break;
                    case 'sale':
                        if (!parseInt(data.itemModel.getProto().get('param').nonsale)) {
                            var currency = ExGods.references.get('user_money').getByKey('gold'),
                                price = data.itemModel.calcPrice(action.cost, false, true),
                                priceAll = data.itemModel.calcPrice(action.cost, true, true),
                                text, textAll;
                            if (price === "0") {
                                text = ExGods.getMsgByKey('drop_item_single');
                            } else {
                                text = ExGods.getMsgByKey('sell_item_for') + ' ' + '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + price + '';
                            }
                            if (priceAll === "0") {
                                textAll = ExGods.getMsgByKey('drop_item_all');
                            } else {
                                textAll = ExGods.getMsgByKey('sell_items_for') + ' ' + '<img class="stuff-icon" src="' + currency.image + '" title="' + currency.label + '" />' + priceAll + '';
                            }
                            data.buttons.push({
                                action_data: action,
                                actionType: 'sell',
                                action: 'item_action',
                                text: text
                            });
                            if (data.itemModel.get('count') > 1) {
                                data.buttons.push({
                                    action_data: action,
                                    actionType: 'sellAll',
                                    action: 'item_action',
                                    text: textAll
                                });
                            }
                        };
                        break;
                    default:
                        break;
                }
            });
        }
        return data;
    },
    /**
     *    -
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.inventory.stuff.decorator.InventoryItemQuantity);
    },
    /**
     * override
     */
    details: function(config) {
        var me = this,
            data = me.getDetailsData(),
            condition_action = data.protoModel.raw.condition_action,
            user = ExGods.app.getUser(),
            method = ExGods.stuff.stuff.ItemInstance.prototype.details.bind(me, config);
        if (config.tooltip) {
            //    
            return method();
        } else {
            ExGods.app.getFeaturePrototypesStore().loadNew(data.itemModel.data.param.features, function() {
                //      -  .   ,    
                if (!user.isChain() && condition_action && condition_action.length && user.userVersion != data.protoModel.get('condition_actions_version')) {
                    ExGods.Services.get('inventory').command('get_item_action', {
                        proto_id: data.protoModel.get('entry')
                    }, function(json) {
                        data.protoModel.set({
                            'condition_actions': json.result,
                            'condition_actions_version': user.userVersion
                        });
                        method();
                    });
                } else {
                    method();
                }
            });
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.inventory.stuff.decorator.InventoryItemQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getQuantity: function(data) {
            var quantity = data.itemModel.get('count');
            return quantity > 1 ? quantity : false;
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.inventory.stuff.decorator.QuestHelper', {
    extend: ExGods.stuff.Decorator,
    statics: {
        getCls: function(data) {
            return 'qh-object';
        },
        getAttributes: function(data) {
            var str = 'data-qh_oid="' + data.itemModel.get('proto_id') + '" data-qh_otype="inventory_item"',
                inventoryCmp = Ext.getCmp('INVENTORY');
            if (inventoryCmp) {
                var store = inventoryCmp.down('iteminventoryslot').store,
                    index = store.indexOf(data.itemModel);
                if (!index % 5) {
                    str += ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"';
                }
            }
            return str;
        }
    }
});

Ext.define('ExGods.view.item.stuff.ItemSlot', {
    extend: ExGods.stuff.stuff.ItemInstance,
    /**
     * override
     */
    getDblClickAction: function() {
        if (!ExGods.app.getUser().isBattle()) {
            return 'take_off';
        } else {
            return false;
        }
    },
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.unshift(ExGods.view.item.stuff.decorator.Protect);
        data.decorators.push(ExGods.view.inventory.stuff.decorator.QuestHelper, ExGods.view.item.stuff.decorator.CriticalDurability);
        me.replaceQuantityDecorator(data.decorators);
        return data;
    },
    /**
     *    -
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.inventory.stuff.decorator.InventoryItemQuantity);
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent(),
            user = ExGods.app.getUser(),
            protect_price = ExGods.Services.get('inventory').data.next_price_protect,
            slot = data.stuff.params.slot;
        Ext.Array.insert(data.blocks, 3, [
            ExGods.stuff.block.item.Description
        ]);
        //    -   
        if (!user.slots().getById(Number(slot.data.ekey)) || user.isBattle()) {
            return data;
        }
        data.buttons = [];
        if (slot.get('protect') != '1' && protect_price) {
            data.buttons.push({
                action: 'item_action',
                actionType: 'protect_actions',
                text: ExGods.getMsgByKey('protect_slot_for') + ' ' + ExGods.util.Stuff.printStuff(protect_price),
                slot: slot,
                cls: 'qh-object no_border',
                qh: {
                    'data-qh_otype': 'protect_slot_button',
                    'data-qh_oid': slot.get('type')
                }
            });
        }
        if (!user.isBattle()) {
            data.buttons.push({
                action: 'take_off',
                text: ExGods.getMsgByKey('take_off_item')
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.item.stuff.RepairItem', {
    extend: ExGods.stuff.stuff.ItemInstance,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.view.item.stuff.decorator.CriticalDurability);
        return data;
    }
});

Ext.define('ExGods.view.item.stuff.QuickSlot', {
    extend: ExGods.view.item.stuff.ItemSlot,
    /**
     * override
     */
    details: function(config) {
        var me = this,
            user = ExGods.app.getUser(),
            itemModel = me.stuff.params.itemModel,
            protoModel = itemModel.getProto(),
            condition_action = protoModel.raw.condition_action,
            actions = protoModel.get('action_full');
        doAction = function() {
            var done = false;
            Ext.Array.each(protoModel.get('condition_actions'), function(action) {
                if (action.type == 'battle') {
                    ExGods.app.getItemController().doAction(me, {
                        action_data: action
                    });
                    done = true;
                }
            });
            if (!done && actions[0]) {
                ExGods.app.getItemController().doAction(me, {
                    action_data: actions[0]
                });
            }
        };
        if (user.isBattle() && !config.tooltip) {
            if (Ext.getCmp('quick-slots').isDisabled())  {
                return false;
            }
            
            if (condition_action && condition_action.length && user.userVersion != protoModel.get('condition_actions_version')) {
                ExGods.Services.get('inventory').command('get_item_action', {
                    proto_id: protoModel.get('entry')
                }, function(json) {
                    protoModel.set({
                        'condition_actions': json.result,
                        'condition_actions_version': user.userVersion
                    });
                    doAction();
                });
            } else {
                doAction();
            }
            return false;
        } else {
            return me.callParent(arguments);
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.item.stuff.decorator.Protect', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var protect = data.stuff.params.slot.get('protect');
            return protect ? '<div class="slot-protect"></div>' : '';
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.item.stuff.decorator.CriticalDurability', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            var critical = data.itemModel.hasCriticalDurability(),
                img = ExGods.references.get('images').get('item_critical_status').image['img60'];
            return critical ? '<div class="item-critical" style="background-image: url(' + img + ')"></div>' : '';
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.item.stuff.decorator.QuestHelper', {
    extend: ExGods.stuff.Decorator,
    statics: {
        getCls: function(data) {
            return 'qh-object';
        },
        getAttributes: function(data) {
            var slotType = data.stuff.params.slot.get('type'),
                str = 'data-qh_oid="' + slotType + '" data-qh_otype="active_slot"';
            if ([
                1,
                2,
                5,
                8
            ].indexOf(slotType) != -1) {
                str += ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"';
            }
            return str;
        }
    }
});

/**
 * Created by dvetlugin on 25.03.14.
 */
/**
  *
 * ExGods.view.plugin.ExtraParchmentDeco
 */
Ext.define('ExGods.view.plugin.ExtraParchmentDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.extraparchmentdeco',
    init: function(cmp) {
        cmp.addClsWithUI('extraparchment');
        if (cmp.isPanel) {
            if (!cmp.title)  {
                cmp.title = ' ';
            }
            
            Ext.override(cmp, {
                addTool: function(tools) {
                    var i = 0;
                    tools = [].concat(tools);
                    for (; i < tools.length; i++) {
                        tools[i].height = 31;
                        tools[i].width = 32;
                    }
                    this.callParent(arguments);
                }
            });
        }
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header)  {
            cmp.header.setHeight(0);
        }
        
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'shop/detail_bottom.png',
                IMAGE_URL + 'shop/detail_middle.png',
                IMAGE_URL + 'shop/detail_separator.png'
            ]
        };
    }
});

/**
 *     ()   
 */
Ext.define('ExGods.view.TargetWindow', {
    extend: Ext.panel.Panel,
    alias: 'widget.targetwindow',
    /**
     * @cfg {String} windowTitle  
     */
    windowTitle: '',
    /**
     * @cfg {Ext.data.Store} store    (required)
     */
    store: null,
    cls: 'target-window',
    /**
     * @cfg {String} itemTpl    (required)
     *     Ext.XTemplate  /
     */
    itemTpl: null,
    /**
     * @cfg {String} searchField   ,     .
     */
    searchField: '',
    /**
     * @cfg {Boolean} singleBtn     ,       
     */
    singleBtn: true,
    buttonAlign: 'center',
    constrain: true,
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    height: 370,
    width: 260,
    initComponent: function() {
        var me = this;
        /**
         * @cfg {String} emptyText     
         */
        me.emptyText = me.emptyText || ExGods.getMsgByKey('view_target_empty');
        /**
         * @cfg {String} searchEmptyText    
         */
        me.searchEmptyText = me.searchEmptyText || ExGods.getMsgByKey('view_target_searchempty');
        /**
         * @cfg {String} buttonText    
         */
        me.buttonText = me.buttonText || ExGods.getMsgByKey('target_window_button_text');
        // me.addEvents(
        //  *
        //   * @event select
        //   *   ,    .    
        //   * @param {ExGods.view.TargetWindow} this
        //   * @param {Ext.data.Model} selectedRecord  
        //  'select'
        // );
        if (!(me.itemTpl instanceof Ext.XTemplate)) {
            me.itemTpl = Ext.create('Ext.XTemplate', me.itemTpl);
        }
        Ext.apply(this, {
            items: [
                {
                    xtype: 'container',
                    plugins: [
                        'paperdeco'
                    ],
                    layout: 'anchor',
                    items: [
                        {
                            xtype: 'component',
                            height: 24,
                            cls: 'paper-title',
                            html: me.windowTitle,
                            hidden: !me.windowTitle,
                            style: {
                                'text-align': 'center',
                                'position': 'relative',
                                'margin': '7px 11px -5px 11px',
                                'font-weight': 'bold'
                            }
                        },
                        {
                            xtype: 'textfield',
                            padding: '10 20 14 16',
                            itemId: 'search',
                            anchor: '100%',
                            emptyText: me.searchEmptyText,
                            height: 22,
                            fieldStyle: {
                                position: 'relative',
                                height: '22px'
                            },
                            hidden: me.searchField ? false : true,
                            listeners: {
                                change: me.onSearchFieldChange,
                                scope: me
                            }
                        }
                    ]
                },
                {
                    xtype: 'viewpanel',
                    itemId: 'listPanel',
                    flex: 1,
                    plugins: [
                        {
                            ptype: 'scroller',
                            animate: true,
                            autoHide: true,
                            scrollDeltaY: 26,
                            snap: 'li.item'
                        }
                    ],
                    store: me.store,
                    viewConfig: {
                        itemSelector: 'li.item',
                        tpl: [
                            '<tpl if="this.isEmpty()">',
                            '<div style="text-align: center; color: rgb(236, 219, 199); padding-top: 10%;">' + me.emptyText + '</div>',
                            '<tpl else>',
                            '<ul class="items">',
                            '<tpl for=".">',
                            '<li class="item">',
                            '{[this.getItemHtml(values)]}',
                            '</li>',
                            '</tpl>',
                            '</ul>',
                            '</tpl>',
                            {
                                isEmpty: function() {
                                    return me.store.getCount() === 0;
                                },
                                getItemHtml: function(data) {
                                    return me.itemTpl.apply(data);
                                }
                            }
                        ],
                        listeners: {
                            itemclick: {
                                fn: me.onTargetClick,
                                delay: 0,
                                scope: me
                            },
                            selectionchange: me.onSelectionChange,
                            refresh: me.onViewRefresh,
                            scope: me
                        }
                    }
                }
            ]
        });
        if (me.clientActions) {
            for (var i = 0; i < me.clientActions.length; i++) {
                me.items.push(me.clientActions[i]);
            }
        }
        me.callParent();
    },
    onViewRefresh: function(view) {
        var me = this;
        if (me.singleBtn && !me.getComponent('applyButton')) {
            me.add({
                xtype: 'textbutton',
                itemId: 'applyButton',
                text: me.buttonText,
                handler: Ext.Function.bind(me.onButtonClick, me),
                margin: '10 5 0 5',
                disabled: true,
                cls: me.buttonCls || 'no_border'
            });
        } else {
            me.store.each(function(record) {
                var node = view.getNode(record);
                if (node) {
                    Ext.widget('textbutton', {
                        renderTo: node,
                        text: me.buttonText,
                        handler: function() {
                            me.onTargetSelect(record);
                        },
                        cls: me.buttonCls || 'no_border'
                    });
                }
            });
        }
    },
    /**
     * @private
     */
    onSearchFieldChange: function(field, newValue) {
        var me = this;
        me.store.clearFilter();
        if (newValue) {
            me.store.filter({
                anyMatch: true,
                property: me.searchField,
                value: newValue
            });
            if (me.store.count() == 1) {
                me.getComponent('listPanel').getView().select(0);
            } else {
                me.getComponent('listPanel').getView().getSelectionModel().deselectAll();
            }
            field.focus();
        } else {
            me.getComponent('listPanel').getView().getSelectionModel().deselectAll();
        }
    },
    /**
     * @private
     */
    onTargetClick: function(view, record, node, index, event) {
        var me = this;
        me.down('#search').setRawValue(record.get(me.searchField));
    },
    /**
     * @private
     */
    onSelectionChange: function(view, selected) {
        var me = this,
            btns = me.query('textbutton');
        Ext.each(btns, function(btn) {
            btn.setDisabled(selected.length == 0);
        });
    },
    /**
     * @private
     */
    onButtonClick: function(button, event) {
        var me = this,
            selection = me.getComponent('listPanel').getView().getSelectionModel().getSelection();
        if (selection.length) {
            me.onTargetSelect(selection[0]);
        }
    },
    /**
     * @private
     */
    onTargetSelect: function(target) {
        this.fireEvent('select', this, target);
    }
});

/**
 *    -
 */
Ext.define('ExGods.view.user.TargetWindow', {
    extend: ExGods.view.TargetWindow,
    alias: 'widget.usertargetwindow',
    /**
     * @cfg {Array} users   ExGods.model.BasicUser    ,     
     */
    users: null,
    cls: 'target-window user-target-window',
    padding: '10 10 15 10',
    buttonCls: ' ',
    //   -  .
    width: 350,
    initComponent: function() {
        var me = this;
        Ext.apply(this, {
            store: me.store || me.initStore(),
            itemTpl: me.getItemTpl(),
            searchField: 'display_title'
        });
        me.callParent();
    },
    /**
     * @private
     *   -
     */
    initStore: function() {
        var me = this,
            store;
        store = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.BasicUser'
        });
        if (me.users && me.users.length) {
            if (me.users[0].display_title) {
                //    
                store.loadRawData(me.users);
            } else {
                store.loadRecords(me.users);
            }
        }
        return store;
    },
    getItemTpl: function() {
        return [
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="target-user">',
            '<div class="exg-share-base-info exg-share-bg-light gender-{gender}" style="background-image: url({[ this.getUserImage(values) ]})">',
            '<span>{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank", maxNameWidth: 228})]}</span>',
            '<span>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {hoard.level}</span>',
            '<div class="image-frame"></div>',
            '</div>',
            '</div>',
            {
                getUserImage: function(values) {
                    var model = Ext.create('ExGods.model.User', values);
                    return model.getShape().thumb;
                }
            }
        ];
    },
    /**
     * @private
     */
    onTargetClick: function(view, record, node, index, event) {
        var me = this;
        me.callParent(arguments);
        view.getSelectionModel().preventFocus = true;
        //  Ext  body
        if (event.target.className.indexOf(' info-icon ') != -1 && view.up('window'))  {
            view.up('window').close();
        }
        
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        /* 
         user_target_panel      
           

        var wnd = ExGods.Components.factory('USER_TARGET_PANEL'....

    

        debugger
        var str = me.store || me.initStore();

        var model = Ext.create('ExGods.model.User', str);
        var shape = model.getShape().thumb;
        */
        return {
            images: [].//IMAGE_URL + 'icons/stats/ico_injury16.png',
            concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.store.Items', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Item',
    proxy: 'memory',
    /**
     *        
     */
    insert: function(index, records) {
        var me = this,
            sync = false,
            i, record, len;
        var newRecords = [];
        records = [].concat(records);
        for (i = 0 , len = records.length; i < len; i++) {
            record = me.createModel(records[i]);
            record.set(me.modelDefaults);
            // reassign the model in the array in case it wasn't created yet
            records[i] = record;
            //   
            var proto_id = record.get('proto_id');
            var proto = ExGods.app.getItemPrototypesStore().data.getByKey(proto_id);
            if (proto.isStack()) {
                var searchIndex = me.data.findIndexBy(function(dataRecord) {
                        if (dataRecord.get('proto_id') == proto_id)  {
                            return true;
                        }
                        
                    });
                var item_id = record.get('item_id');
                if (searchIndex != -1) {
                    var cur_rec = me.data.getAt(searchIndex);
                    cur_rec.get('stack_ids').push(item_id);
                    cur_rec.data.count += record.get('param').count || 1;
                    records = Ext.Array.erase(records, i, 1);
                    i--;
                    len -= 1;
                } else {
                    record.set('stack_ids', [
                        item_id
                    ]);
                    record.set('count', record.get('param').count || 1);
                    me.data.insert(index + i, record);
                    record.join(me);
                    newRecords.push(record);
                }
            } else {
                me.data.insert(index + i, record);
                record.set('count', record.get('param').count || 1);
                record.join(me);
                newRecords.push(record);
            }
            // END:   
            sync = sync || record.phantom === true;
        }
        if (me.snapshot) {
            me.snapshot.addAll(newRecords);
        }
        me.fireEvent('add', me, newRecords, index);
        me.fireEvent('datachanged', me);
        if (me.autoSync && sync) {
            me.sync();
        }
    }
});

/**
 *  .          (, ,   .)
 */
Ext.define('ExGods.controller.Item', {
    extend: ExGods.controller.Base,
    stores: [
        'Items',
        'Quests'
    ],
    views: [
        'user.TargetWindow'
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Item:'
    },
    /**
     * @property {Boolean} afterDrop
     * @private
     * , ,     ,    ,       
     */
    afterDrop: false,
    /**
     * @property {Number}
     *  -   ,       ( )
     */
    MAX_STACK_OPERATION_SIZE: 100,
    init: function(app) {
        var me = this;
        me.InventoryService = ExGods.Services.get('inventory');
        me.control({
            'shop': {
                itemclick: me.onShopItemClick
            },
            '#do-protect-slot': {
                click: me.onProtectSlotBtnClick
            }
        });
        app.on({
            itemclick: me.showItemWindow,
            scope: me
        });
        ExGods.stuff.StuffManager.register({
            'inventory_item': {
                classObj: ExGods.view.inventory.stuff.InventoryItem,
                listeners: {
                    item_action: me.onItemActionClick,
                    put_on: me.doPutOn,
                    put_to_warehouse: function(data) {
                        var item = data.stuff.params.itemModel;
                        me.app.getInventoryVirtualStoreController().putToWareHouse(item);
                    },
                    scope: me
                }
            },
            'item_slot': {
                classObj: ExGods.view.item.stuff.ItemSlot,
                listeners: {
                    item_action: me.onItemActionClick,
                    take_off: me.doTakeOff,
                    scope: me
                }
            },
            'quick_slot': {
                classObj: ExGods.view.item.stuff.QuickSlot,
                listeners: {
                    item_action: me.onItemActionClick,
                    take_off: me.doTakeOff,
                    scope: me
                }
            },
            'repair_item': ExGods.view.item.stuff.RepairItem
        });
        ExGods.Components.addComponentInitializer('item_target_panel', me.initItemTargetPanelComponent, me);
        //    
        setInterval(function() {
            me.getUser().slots().each(function(slot) {
                slot.checkExpired(function(items) {});
            });
        }, //
        1000);
    },
    onItemActionClick: function(data, btn, win) {
        var me = this;
        switch (btn.actionType) {
            case 'puton':
                me.doPutOn.apply(me, arguments);
                break;
            case 'takeoff':
                me.doTakeOff.apply(me, arguments);
                break;
            case 'battle':
            case 'map':
            case 'condition_actions':
                me.doAction.apply(me, arguments);
                break;
            case 'dialog':
                me.showDialog.apply(me, arguments);
                break;
            case 'sell':
                me.doSell.apply(me, arguments);
                break;
            case 'sellAll':
                me.doSellAll.apply(me, arguments);
                break;
            case 'protect_actions':
                me.doProtectActions.apply(me, arguments);
                break;
            default:
                break;
        }
    },
    onProtectSlotBtnClick: function(btn) {
        var me = this;
        me.doProtectActions(null, btn, btn.up('window'));
    },
    doPutOn: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            user = me.getUser();
        if (!item)  {
            return;
        }
        
        me.putOn(item, function() {
            if (win)  {
                win.close();
            }
            
        });
    },
    /**
     *    
     *
     * @param {ExGods.view.TextButton/Object} button
     */
    putOn: function(item, callback, targetSlot) {
        var me = this,
            user = me.getUser(),
            params = {
                item: item.get('item_id'),
                slot: item.get('slot_id')
            };
        if (targetSlot) {
            params.slot_to = targetSlot.get('ekey');
        }
        me.app.block();
        me.InventoryService.command('item_on', params, function(json) {
            if (!json.user) {
                var items = user.slots().data.getByKey(item.get('slot_id')).get('items');
                items.fireEvent('refresh', items);
            }
            me.app.unblock();
            if (callback)  {
                callback();
            }
            
            me.user.fireEvent('item_on');
        });
    },
    doTakeOff: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            user = me.getUser();
        if (!item)  {
            return;
        }
        
        me.takeOff(item, function() {
            if (win)  {
                win.close();
            }
            
        });
    },
    /**
     *    
     *
     * @param {ExGods.view.TextButton/Object} button
     */
    takeOff: function(item, callback) {
        var me = this,
            user = me.getUser();
        if (!item)  {
            return;
        }
        
        me.app.block();
        me.InventoryService.command('item_off', {
            slot: item.get('slot_id')
        }, function(json) {
            if (!json.user) {
                var items = user.slots().data.getByKey(item.get('slot_id')).get('items');
                items.fireEvent('refresh', items);
            }
            me.app.unblock();
            if (callback)  {
                callback();
            }
            
            me.user.fireEvent('item_off');
        });
    },
    /**
     *  
     *
     */
    doSell: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            action = btn.action_data,
            price = item.calcPrice(action.cost, false, false),
            text;
        if (price == 0) {
            text = ExGods.getMsgByKey('inventory_confirm_drop_item');
        } else {
            text = Ext.String.format(ExGods.getMsgByKey('inventory_confirm_sell_item'), ExGods.util.Stuff.printStuff({
                type: 'currency',
                params: {
                    quantity: price,
                    id: 'gold'
                }
            }));
        }
        me.showActionConfirmation(text, {
            handler: function() {
                me.app.block();
                me.InventoryService.command('item_del', {
                    item: item.get('item_id'),
                    slot: item.get('slot_id')
                }, function() {
                    me.app.unblock();
                    win.close();
                });
            }
        });
    },
    /**
     *     
     *
     */
    doSellAll: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            action = btn.action_data,
            itemsInStack = item.get('stack_ids'),
            priceAll = item.calcPrice(action.cost, true, false, me.MAX_STACK_OPERATION_SIZE),
            operateItems = [];
        if (!itemsInStack) {
            me.log('warn', ' itemsInStack,             1!');
            return;
        }
        if (itemsInStack.length > me.MAX_STACK_OPERATION_SIZE) {
            operateItems = itemsInStack.slice(0, me.MAX_STACK_OPERATION_SIZE);
        } else if (item.get('count') > 1 && !itemsInStack) {
            operateItems = [
                item.get('item_id')
            ];
        } else {
            operateItems = itemsInStack;
        }
        if (priceAll == 0) {
            text = ExGods.getMsgByKey('inventory_confirm_drop_all_items');
        } else {
            text = Ext.String.format(ExGods.getMsgByKey('inventory_confirm_sell_all_items'), ExGods.util.Stuff.printStuff({
                type: 'currency',
                params: {
                    quantity: priceAll,
                    id: 'gold'
                }
            }));
        }
        me.showActionConfirmation(text, {
            handler: function() {
                me.app.block();
                me.InventoryService.command('item_del', {
                    items: operateItems,
                    slot: item.get('slot_id')
                }, function() {
                    me.app.unblock();
                    win.close();
                });
            }
        });
    },
    /**
     *   
     *
     * @param {ExGods.view.TextButton} button    ,   
     */
    doAction: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            action = Ext.create('ExGods.model.Action', Ext.clone(btn.action_data));
        action.set({
            'source': item,
            'service_id': me.InventoryService.id
        });
        if (action.get('type') == 'map' || !action.get('type')) {
            action.set('type', 'map.inventory');
        }
        //   ,    
        me.application.getController('Action').doAction(action, function(json) {
            if (win)  {
                win.close();
            }
            
            if (Ext.getCmp('itemtargetpanel')) {
                Ext.getCmp('itemtargetpanel').closeComponent();
            }
        }, me);
    },
    /**
     *     
     *
     * @param {ExGods.view.TextButton} button    ,   
     */
    doProtectActions: function(data, btn, win) {
        var me = this;
        me.showActionConfirmation(new Ext.XTemplate(ExGods.ref('message_client|confirm_buy_slot')).apply({
            cost: ExGods.util.Stuff.printStuff(me.InventoryService.data.next_price_protect)
        }), {
            handler: function() {
                me.app.block();
                me.InventoryService.command('protect_slot', {
                    slot: btn.slot.get('ekey')
                }, function() {
                    me.app.unblock();
                    win.close();
                });
            }
        });
    },
    showSlotWindow: function(slot, el) {
        var me = this,
            description, buttons,
            user = me.getUser(),
            protect_price = ExGods.Services.get('inventory').data.next_price_protect;
        if (slot.get('protect')) {
            description = [
                '<div style="background: url(' + IMAGE_URL + '/icons/done.png) 0 0 no-repeat; padding-left: 20px;" >',
                ExGods.ref('message_client|slot_protected'),
                '</div>'
            ].join('');
        } else {
            description = ExGods.ref('message_client|slot_not_protected');
            if (user.slots().getById(Number(slot.data.ekey)) && !user.isBattle()) {
                buttons = [
                    {
                        text: ExGods.getMsgByKey('protect_slot_for') + ' ' + ExGods.util.Stuff.printStuff(protect_price),
                        cls: 'qh-object no_border',
                        id: 'do-protect-slot',
                        slot: slot,
                        qh: {
                            'data-qh_otype': 'protect_slot_button',
                            'data-qh_oid': slot.get('type')
                        }
                    }
                ];
            }
        }
        if (me.slotWindow)  {
            me.slotWindow.close();
        }
        
        me.slotWindow = Ext.widget('commondetailswindow', {
            data: {
                label: slot.get('name'),
                image: ExGods.ref('slot_type|' + slot.get('type')).images.empty,
                description: description
            },
            buttons: buttons,
            itemElement: el
        });
    },
    /**
     *     
     *
     * @param {ExGods.view.TextButton} button    ,   
     */
    showDialog: function(data, btn, win) {
        var me = this,
            item = data.stuff.params.itemModel,
            proto = item.getProto(),
            slot = me.user.slots().data.getByKey(item.get('slot_id'));
        win.close();
        // TODO:     ,     <code>app.fireEvent()</code>
        var controller = me.application.getController('Dialog');
        controller.init();
        var dialog = controller.show({
                title: proto.get('title'),
                image: proto.get('images').info || Ext.BLANK_IMAGE_URL,
                description: proto.get('data').description
            }, {
                url: '/dialogs.pl?cmd=list',
                params: {
                    item: item.get('item_id'),
                    slot: item.get('slot_id')
                }
            }, item);
    },
    /**
     *      
     *
     * @param {Ext.view.View} itemView
     * @param {ExGods.model.ShopItem} shopItem
     * @param {Ext.Element} itemEl
     */
    onShopItemClick: function(itemView, shopItem, itemEl, zero, event) {
        var me = this;
        if (!event.getTarget('.x-btn')) {
            Ext.get(itemEl).down('.exg-stuff-imaged').dom.click();
        }
    },
    /**
     *     , ,    .
     *     .
     *
     * @param {Object} options
     *
     * - **item** : ExGods.model.Item
     *
     *  ,   
     *
     * - **proto_id** : Number
     *
     *  ,   
     *
     * - **quantity** : Number
     *
     *  (   )
     *
     * - **itemEl** : Number
     *
     * DOM ,    
     *
     * @private
     */
    showItemWindow: function(options) {
        var me = this,
            protos = me.application.getItemPrototypesStore(),
            stuffMgr = ExGods.stuff.StuffManager,
            fn = function() {
                var cfg = {
                        params: {
                            id: options.proto_id,
                            quantity: options.quantity || 1
                        },
                        type: options.type
                    };
                if (options.item) {
                    cfg.params.itemModel = options.item;
                }
                var obj = stuffMgr.factory(cfg);
                if (obj) {
                    return obj.details({
                        clickedEl: options.itemEl,
                        tooltip: options.tooltip
                    });
                }
            };
        if (!options.item) {
            protos.loadNew([
                options.proto_id
            ], fn);
        } else {
            return fn();
        }
    },
    /**
     * @private
     *      ""/""
     *
     * @param {String} message   (required)
     * @param {Object} options :
     *
     *     handler {Function} - ,   
     *     buttonsText {Array} -  
     *
     * @author  
     */
    showActionConfirmation: function(message, options) {
        var me = this,
            config = options || {};
        config.message = message;
        config.handler = {
            fn: options.handler,
            scope: me
        };
        Ext.widget('confirmdialog', config);
    },
    initItemTargetPanelComponent: function(config, componentId) {
        var me = this,
            items = [],
            actions = [],
            cmp, wnd,
            checkFilterSlot = function(slot) {
                var map_action = (config.action.params && typeof config.action.params.map_action == 'object') ? config.action.params.map_action[0] : undefined,
                    filter_slots = (map_action && map_action.target_params && map_action.target_params.filter_slots) ? map_action.target_params.filter_slots : undefined,
                    type = slot.get('type'),
                    valid = false;
                if (filter_slots) {
                    Ext.each(filter_slots, function(fslot) {
                        if (fslot.slot == type)  {
                            valid = true;
                        }
                        
                    });
                } else {
                    valid = true;
                }
                return valid;
            };
        switch (config.source) {
            case 'damaged':
                //  ,  
                me.getUser().slots().each(function(slot) {
                    slot.items().each(function(item) {
                        if (item.isDamaged() && checkFilterSlot(slot)) {
                            items.push(item);
                        }
                    });
                });
                break;
            case 'upgraded':
                //   
                me.getUser().slots().each(function(slot) {
                    slot.items().each(function(item) {
                        if (item.isUpgraded() && checkFilterSlot(slot)) {
                            items.push(item);
                        }
                    });
                });
                break;
            case 'filtered':
                var filters = {},
                    item_proto = ExGods.app.getItemPrototypesStore(),
                    tp = config.targetParams;
                Ext.Array.each(tp.filter_list, function(f) {
                    switch (f.filter_type) {
                        case 'ilist':
                            if (!filters.items)  {
                                filters.items = [];
                            }
                            ;
                            filters.items = filters.items.concat(Ext.Array.map(f.filter_data.items, function(item) {
                                return Number(item.item);
                            }));
                            break;
                        case 'itype':
                            if (!filters.types)  {
                                filters.types = [];
                            }
                            ;
                            filters.types = filters.types.concat(Ext.Array.map(f.filter_data.types, function(type) {
                                return Number(type.type);
                            }));
                            break;
                        case 'igrade':
                            filters.grade = parseInt(f.filter_data.item_grade) || 1;
                            break;
                        case 'ibreak':
                            filters.broken = parseInt(f.filter_data.item_break) || 0;
                            break;
                        case 'irepair':
                            filters.repair = parseInt(f.filter_data.item_repair) || 0;
                            break;
                        case 'itemp':
                            filters.temp = parseInt(f.filter_data.item_temp) || 0;
                            break;
                        case 'iupgrade':
                            filters.upgrade = parseInt(f.filter_data.item_upgrade) || 0;
                            break;
                    }
                });
                //    
                me.getUser().slots().each(function(slot) {
                    slot.items().each(function(item) {
                        var pid = item.get("proto_id"),
                            proto = item_proto.getById(pid);
                        if ((filters.items == undefined || filters.items.indexOf(pid) != -1) && (filters.types == undefined || filters.types.indexOf(proto.get("type")) != -1) && (filters.grade == undefined || (proto.get('data').item_grade || 1) == filters.grade) && (filters.broken == undefined || item.isDamaged() == !!filters.broken) && (filters.repair == undefined || !parseInt(item.get('param').nonrep) == !!filters.repair) && (filters.temp == undefined || Boolean(item.get('param').expire_str) == Boolean(filters.temp)) && (filters.upgrade == undefined || !!item.get('param').upgrades == !!filters.upgrade)) {
                            items.push(item);
                        }
                    });
                });
                //     (  )
                items = Ext.Array.sort(items, function(a, b) {
                    return a.getDur() - b.getDur();
                });
                break;
            default:
                break;
        }
        for (var i = 1; i < 5; i++) {
            var label = config['btn' + i];
            if (label) {
                var act = config['act' + i];
                var clientAction = {
                        text: label,
                        xtype: "textbutton",
                        margin: '3 5 0 5',
                        disabled: true
                    };
                if (Ext.isObject(act)) {
                    Ext.apply(clientAction, {
                        clientAction: act.id,
                        handler: function() {
                            var selection = button.up().down('viewpanel').getView().getSelectionModel().getSelection();
                            if (selection.length) {
                                ExGods.ClientActions.createAndInvoke({
                                    actionId: this.clientAction,
                                    selected_target: selection[0]
                                }, function() {
                                    wnd.close();
                                }, function(err) {
                                    /***/
                                    me.log('error', err);
                                });
                            }
                        }
                    });
                }
                actions.push(clientAction);
            }
        }
        cmp = Ext.widget('itemtargetwindow', {
            windowTitle: config.windowTitle,
            items: items,
            action: config.action,
            singleBtn: false,
            buttonCls: 'item-button no_border',
            clientActions: actions,
            listeners: config.listeners || [],
            emptyText: config.emptyText
        });
        cmp.on('destroy', function() {
            wnd.close();
        });
        wnd = Ext.widget('floatwindow', {
            id: componentId,
            autoShow: true,
            plugins: [
                'skindeco'
            ],
            width: 360,
            height: 360,
            y: 100,
            items: [
                cmp
            ]
        });
        return wnd;
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Hints', {
    extend: ExGods.controller.Base,
    /**
     * @private
     */
    init: function(app) {
        var me = this;
        app.on({
            notshowhint: me.onNotShowHint,
            scope: me
        });
    },
    onLaunch: function(app) {},
    /**
     *     
     *
     * @param {Ext.Component} cmp
     * @param {Object} options
     */
    prepareHints: function(cmp, options) {
        var me = this,
            app = me.application,
            blocks = options.blocks;
        if (blocks.length) {
            var block = blocks.shift();
            if (app.gameStarted) {
                me.showHints(block, blocks);
            } else {
                app.on('gamestarted', function() {
                    me.showHints(block, blocks);
                }, me, {
                    single: true
                });
            }
        } else {
            app.fireEvent('hintsshowed');
        }
    },
    /**
     *   
     * name -  
     * startIndex -  ,    
     */
    showHints: function(name, startIndex) {
        var me = this,
            refData = ExGods.references.get('user_hint').get(name),
            i = startIndex || 0;
        if (refData && refData.length && refData[i]) {
            var tips = [],
                user = me.getUser(),
                read_hints = user.get('read_hints'),
                new_read_hints = [],
                block = refData[i],
                tip;
            i++;
            Ext.Array.each(block.data, function(hint) {
                if (!Ext.Array.contains(read_hints, hint.id)) {
                    if (hint.is_main != 0) {
                        var main_tip = Ext.widget('direction', {
                                is_main: true,
                                layer: 'directions-layer',
                                config: {
                                    x: hint.coords.x,
                                    y: hint.coords.y,
                                    label: hint.label,
                                    text: hint.text,
                                    close_btn: 1,
                                    btn: {
                                        text: ExGods.getMsgByKey('close_btn_text'),
                                        handler: function() {
                                            main_tip.close();
                                        }
                                    }
                                },
                                listeners: {
                                    close: function() {
                                        Ext.Array.forEach(tips, function(tip) {
                                            if (tip != main_tip) {
                                                tip.close();
                                            }
                                        });
                                        Ext.getBody().unmask();
                                        me.request({
                                            url: '/game.pl?cmd=read_hints',
                                            params: {
                                                hints: new_read_hints
                                            },
                                            success: function(json) {
                                                if (json.success) {
                                                    ExGods.app.getUser().set('read_hints', json.read_hints);
                                                }
                                            }
                                        });
                                        me.showHints(name, i);
                                    }
                                }
                            });
                        tips.push(main_tip);
                        main_tip.show();
                    } else {
                        tips.push(Ext.create('Ext.window.Window', {
                            autoShow: true,
                            draggable: false,
                            header: false,
                            html: hint.text,
                            plugins: [
                                'hintdeco'
                            ],
                            resizable: false,
                            shadow: 'frame',
                            renderTo: 'viewport',
                            minHeight: 0,
                            width: hint.coords.width,
                            height: hint.coords.height,
                            x: hint.coords.x,
                            y: hint.coords.y
                        }));
                    }
                    new_read_hints.push(hint.id);
                }
            });
            if (tips.length)  {
                Ext.getBody().mask().setStyle('opacity', 0.15);
            }
            
        }
    },
    // var closer = Ext.create('Ext.window.Window', {
    //  autoShow: true,
    //  draggable: false,
    //  header: false,
    //  html: block.description,
    //  plugins: ['hintdeco'],
    //  resizable: false,
    //  renderTo: 'viewport',
    //  shadow: 'frame',
    //  minWidth: 120,
    //  minHeight: 0,
    //  width: block.coords.width,
    //  height: block.coords.height,
    //  x: block.coords.x,
    //  y: block.coords.y,
    //  buttonAlign: 'center',
    //  buttons: [{
    //      xtype: 'textbutton',
    //      text: '',
    //      handler: function() {
    //          Ext.Array.forEach(tips, function(tip) {
    //              tip.close();
    //          });
    //          Ext.getBody().unmask();
    //          me.request({
    //              url: '/game.pl?cmd=read_hints',
    //              params: {
    //                  hints: new_read_hints
    //              },
    //              success:function(json){
    //                  if(json.success){
    //                      ExGods.app.getUser().set('read_hints',json.read_hints);
    //                  }
    //              }
    //          });
    //          me.showHints(name,i);
    //      }
    //  }]
    // });
    // tips.push(closer);
    /**
     *    ID
     */
    showHintById: function(hintId) {
        var me = this,
            name, index;
        ExGods.references.get('user_hint').each(function(blockName, items) {
            Ext.Array.each(items, function(item) {
                Ext.Array.each(item.data, function(hint, i) {
                    if (hintId == hint.id) {
                        name = blockName;
                        index = i;
                    }
                });
            });
        });
        if (name) {
            me.showHints(name, index);
        }
    },
    /**
     *            
     */
    resetHints: function() {
        this.request({
            url: '/game.pl?cmd=reset_all_hints',
            success: function(json) {
                if (json.success) {
                    ExGods.app.getUser().set('read_hints', json.read_hints);
                }
            }
        });
    },
    onNotShowHint: function(hint_id) {
        ExGods.app.getController('Base').request({
            url: '/game.pl?cmd=read_interface',
            params: {
                id: hint_id
            },
            success: function(json) {
                ExGods.app.user.set('read_hints', json.read_hints);
            }
        });
    },
    /**
     *  ,    " "
     * @param allHints   
     * @returns {Array}    " "
     */
    getConfirmationHintsFromArray: function(allHints) {
        var result_array = [];
        if (allHints) {
            Ext.Array.forEach(allHints, function(hints_data_element) {
                var hint = ExGods.references.get('user_hint').getById(parseInt(hints_data_element.entry));
                if (hint) {
                    Ext.Array.forEach(hint.data.data, function(hint_data_element) {
                        if (hint_data_element.type && hint_data_element.type == 'confirm' && !Ext.Array.contains(ExGods.app.user.get('read_hints'), hint_data_element.id)) {
                            result_array.push({
                                hint_text: hint_data_element.text,
                                entry: hints_data_element.entry
                            });
                        }
                    });
                }
            });
        }
        return result_array;
    },
    showConfirmations: function(hints_array, callback) {
        var agree_count = 0;
        Ext.widget('confirmdialog', {
            title: '',
            message: hints_array[0].hint_text,
            entry: hints_array[0].entry,
            handler: function() {
                //      ,   
                if (agree_count == hints_array.length - 1) {
                    callback();
                }
            }
        });
        for (var i = 1; i < hints_array.length; i++) {
            Ext.widget('confirmdialog', {
                title: '',
                message: hints_array[i].hint_text,
                entry: hints_array[i].entry,
                handler: function() {
                    agree_count++;
                }
            });
        }
    }
});

/**
 * Mixin, 
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGods.util.Flags', {
    set_f: function(f, v) {
        var me = this;
        me['f_' + f] = v;
        if (me.log) {
            me.log('f_' + f, v);
        }
    },
    get_f: function(f) {
        var me = this;
        return me['f_' + f];
    },
    if_f: function(f, fn, else_fn) {
        var me = this;
        if (me['f_' + f]) {
            fn();
        } else if (else_fn) {
            else_fn();
        }
    },
    if_not_f: function(f, fn) {
        var me = this;
        if (!me['f_' + f]) {
            fn();
        }
    }
});

/**
 *   Ext.view.View .
 *    , ,    .
 */
Ext.define('ExGods.view.ViewPanel', {
    extend: Ext.panel.Panel,
    alias: 'widget.viewpanel',
    hasView: false,
    initComponent: function() {
        var me = this,
            view;
        me.store = Ext.data.StoreManager.lookup(me.store || 'ext-empty-store');
        me.bodyCls = me.bodyCls || '';
        me.bodyCls += (' ' + me.extraBodyCls);
        me.cls = me.cls || '';
        me.cls += (' ' + me.extraBaseCls);
        if (!me.hasView) {
            me.viewConfig = me.viewConfig || {};
            view = me.getView();
            me.items = [
                view
            ];
            me.hasView = true;
            me.relayEvents(view, [
                'itemclick',
                'refresh',
                'resize',
                'viewready'
            ]);
        }
        delete me.autoScroll;
        me.callParent();
    },
    getStore: function() {
        return this.store;
    },
    getView: function() {
        var me = this;
        if (!me.view) {
            me.view = Ext.ComponentManager.create(Ext.apply({}, me.viewConfig, {
                store: me.store,
                panel: me,
                autoShow: false,
                xtype: 'dataview'
            }));
        }
        return me.view;
    },
    isViewReady: function() {
        var me = this;
        return me.getView().viewReady;
    },
    bindStore: function(store) {
        var me = this;
        me.store = store;
        me.getView().bindStore(store);
    },
    onDestroy: function() {
        var me = this;
        me.callParent();
        me.bindStore(null);
    }
});

/**
 *  NPC  
 */
Ext.define('ExGods.view.location.lob.BotsList', {
    extend: ExGods.view.ViewPanel,
    alias: 'widget.locationbots',
    cls: 'location-bot-list',
    /**
     * @cfg clientObject {Object}     -
     */
    clientObject: {},
    /**
     * @cfg locationObject {Object}     
     */
    locationObject: {},
    closeAction: 'hide',
    flex: 1,
    header: false,
    cooldowns: {},
    cooldowns_delays: {},
    //    
    width: 90,
    height: 358,
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    initComponent: function() {
        var me = this;
        me.viewConfig = {
            itemSelector: 'li.bot',
            prepareData: Ext.Function.bind(me.prepareData, me),
            tpl: [
                '<div class="location-header" style="margin:0 auto; margin-bottom: -2px;"><div class="location-header-title creatures" style="background-image:url(' + ExGods.ref('images|location_images').image['monsters_title'] + ');"></div></div>',
                '<ul class="bot-list">',
                '<tpl for=".">',
                '<tpl if="values.wait">' + '<div id="surging_image"></div>' + '<div id="surging_wait">{[this.createSurgingWaitTimer(values)]}</div>' + '<tpl else>' + '<li class="bot <tpl if="values.hostile">bot-hostile</tpl> qh-object"',
                'data-qh_otype="bot" data-qh_oid="{bot_type}" data-qtip="{display_title}">',
                '<div class="image qh-object" data-qh_otype="bot_any" data-qh_oid="1" style="background-image: url({images.thumb}), url({toughness.image})"></div>',
                '<div id="bot_{entry}" class="timer{[this.checkVisible(values)]}">{[this.createTimer(values)]}</div>',
                '<span class="level" style="color: #feefb4; bottom: 4px">{level}</span>',
                '<tpl if="chain_next_time">',
                '{[ ExGods.util.Timers.printTimer("rest", "", values.chain_next_time, {needNormalized: true}) ]}',
                '</tpl>',
                '</li>',
                '</tpl>' + '</tpl>',
                '</ul>',
                {
                    createTimer: function(data) {
                        var timeLeft = me.calcLeftTime(data);
                        if (timeLeft) {
                            var arr = [],
                                s = 52,
                                //    ;
                                tickTime = Math.round((data.cooldown_banish * 1000 - (me.cooldowns_delays[data.entry] || 0)) / 360),
                                curTime = new Date(),
                                intervalFn = me.cooldowns[data.entry],
                                //timeLeft = me.calcLeftTime(data),
                                i = Math.ceil(361 - timeLeft * 360 / data.cooldown_banish / 1000),
                                x, y, i, poly, time, ticks;
                            if (intervalFn) {
                                clearInterval(intervalFn);
                            }
                            for (; i < 361; i++) {
                                if (i <= 45) {
                                    x = Math.round(s / 2 + s * i / 90);
                                    y = 0;
                                } else if (i > 45 && i <= 135) {
                                    x = s;
                                    y = Math.round(s * (i - 45) / 90);
                                } else if (i > 135 && i <= 225) {
                                    x = Math.round(s * (90 - (i - 135)) / 90);
                                    y = s;
                                } else if (i > 225 && i <= 315) {
                                    x = 0;
                                    y = Math.round(s * (90 - (i - 225)) / 90);
                                } else if (i > 315) {
                                    x = Math.round(s * (i - 315) / 90);
                                    y = 0;
                                }
                                arr.push([
                                    x,
                                    y
                                ]);
                            }
                            if (arr.length) {
                                arr.push([
                                    s / 2,
                                    s / 2
                                ]);
                            } else  {
                                return;
                            }
                            
                            me.cooldowns[data.entry] = setInterval(function() {
                                var el = Ext.get('bot_' + data.entry);
                                if (arr.length) {
                                    if (el) {
                                        if (el.down('svg')) {
                                            poly.plot(arr);
                                        } else {
                                            var svg = SVG('bot_' + data.entry).size(s, s);
                                            poly = svg.polygon(arr).fill('black').opacity(0.5);
                                        }
                                    }
                                    time = new Date();
                                    ticks = Math.round((time - curTime) / tickTime);
                                    curTime = time;
                                    arr.splice(0, ticks);
                                } else {
                                    clearInterval(me.cooldowns[data.entry]);
                                    delete me.cooldowns[data.entry];
                                    delete me.cooldowns_delays[data.entry];
                                    if (el)  {
                                        el.remove();
                                    }
                                    
                                }
                            }, tickTime);
                        }
                    },
                    checkVisible: function(data) {
                        return (me.calcLeftTime(data)) ? ' ' : ' hidden';
                    },
                    createSurgingWaitTimer: function(data) {
                        if (me.surgingwait) {
                            clearInterval(me.surgingwait);
                            delete me.surgingwait;
                        }
                        
                        var time = data.wait;
                        me.surgingwait = setInterval(function() {
                            var el = Ext.get('surging_wait');
                            var el_img = Ext.get('surging_image');
                            var currTime = time - new Date() / 1000;
                            if (currTime > 1) {
                                if (el)  {
                                    el.setHTML(ExGods.app.applyTpl(ExGods.getMsgByKey('view_location_bots_morein'), {
                                        time: ExGods.util.Time.printTime(currTime, {
                                            format: 'short'
                                        })
                                    }));
                                }
                                
                            } else {
                                ExGods.app.getChatConnection().ping();
                                clearInterval(me.surgingwait);
                                delete me.surgingwait;
                                ExGods.app.getSurgingController().surging_wait = 0;
                                if (el)  {
                                    el.remove();
                                }
                                
                                if (el_img)  {
                                    el_img.remove();
                                }
                                
                            }
                        }, 1000);
                        return ExGods.app.applyTpl(ExGods.getMsgByKey('view_location_bots_morein'), {
                            time: ExGods.util.Time.printTime(time - new Date() / 1000, {
                                format: 'short'
                            })
                        });
                    }
                }
            ],
            getResources: function() {
                me;
                var arr_images = [],
                    shapeRef = ExGods.ref('user_shape');
                if (me.store.removed) {
                    for (var i = 0; i < me.store.removed.length; i++) {
                        var item = me.store.removed[i].data;
                        if (item.shape) {
                            var shape = shapeRef.getByKey(item.shape);
                            arr_images.push(shape.thumb);
                        }
                    }
                }
                return {
                    images: [].concat(arr_images),
                    stuff: []
                };
            }
        };
        me.callParent();
        //me.store.on('stateschanged', me.onStatesChanged, me);
        me.on('removed', function() {
            if (me.surgingwait) {
                clearInterval(me.surgingwait);
                delete me.surgingwait;
            }
            
        }, me);
    },
    //me.store.on('datachanged',me.showHideCmp,me);
    //me.on('afterrender',me.showHideCmp,me);
    showHideCmp: function() {
        var me = this;
        if (!me.rendered)  {
            return;
        }
        
        if (me.store.data.length && !me.isVisible()) {
            me.show();
        }
        if (!me.store.data.length && me.isVisible()) {
            me.hide();
        }
    },
    /**
     * @private
     *     .
     *
     *    (   ):
     *
     * - 1 -  
     * - 2 -     
     */
    prepareData: function(data, recordIndex, record) {
        var me = this,
            toughnessImages = ExGods.ref('images|bot_toughness_images').image,
            toughnessColor = {
                green: '6eff42',
                yellow: 'ffef42',
                red: 'ff3c3c'
            };
        if (data.wait) {
            return {
                wait: data.wait
            };
        }
        return {
            images: ExGodsCore.app.references.get('user_shape').getByKey(data.shape),
            display_title: data.label,
            level: data.count,
            last_banish: record.data.last_banish,
            cooldown_banish: record.data.cooldown_banish,
            bot_type: data.bot_type,
            entry: data.entry,
            hostile: true,
            toughness: {
                image: toughnessImages[data.toughness],
                color: toughnessColor[data.toughness]
            },
            chain: data.chain,
            chain_next_time: data.chain_next_time
        };
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        //     
        me.getEl().setStyle({
            overflow: 'visible'
        });
        me.body.el.setStyle({
            overflow: 'visible'
        });
    },
    calcLeftTime: function(record, useDelay) {
        var me = this,
            end_sec_time, ret;
        end_sec_time = record.last_banish + record.cooldown_banish + ExGods.util.Date.serverTimeOffset;
        ret = end_sec_time * 1000 - new Date().getTime();
        if (!me.cooldowns_delays[record.entry] && ret > 0) {
            me.cooldowns_delays[record.entry] = record.cooldown_banish * 1000 - ret;
        }
        ret += (me.cooldowns_delays[record.entry] || 0);
        return ret > 0 ? ret : 0;
    },
    /**
     *      
     */
    animatePrize: function(botEntry, stuff, callback) {
        var me = this,
            record = me.store.getById(botEntry),
            recordEl, index, currency, ct;
        if (record) {
            recordEl = me.view.getNode(record);
        }
        if (recordEl) {
            index = me.view.indexOf(recordEl);
            ct = this.getEl().insertHtml('beforeEnd', '<div style="position: absolute; width: 82px; height: 82px; top: ' + (42 + index * 82) + 'px;"></div>', true);
            ct.on('click', function() {
                recordEl.click();
            });
            el = ExGods.helpme.animateCurrency(ct, stuff, function() {
                if (callback) {
                    ct.remove();
                    callback();
                }
            }, 'prize-anim');
            if (el) {
                el.applyStyles({
                    left: Math.max(41 - el.getWidth() / 2, 0) + 'px'
                });
            } else // , 41 -   
            {
                if (callback) {
                    ct.remove();
                    callback();
                }
            }
        } else {
            if (callback) {
                callback();
            }
        }
    },
    /**
     *      ,    
     */
    locationObjectClickHandler: function() {
        return false;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            imgs;
        imgs = ExGods.ref('images|bot_toughness_images').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   -   .       
 */
Ext.define('ExGods.view.location.lob.ServiceEnter', {
    extend: Ext.Component,
    alias: 'widget.serviceenter',
    /**
     * @cfg clientObject {Object}     -
     */
    clientObject: {},
    /**
     * @cfg locationObject {Object}     
     */
    locationObject: {},
    cls: 'location-service-enter-view',
    initComponent: function() {
        var me = this;
        me.height = me.locationObject.interactive.h;
        me.width = me.locationObject.interactive.w;
        me.tpl = [
            '<div class="light-img" style="background-image: url(' + IMAGE_URL + '{lightImg});"></div>',
            '<div class="image" style="{[ values.image ? "background-image: url("+ values.image +")" : "" ]};"></div>',
            '<tpl if="masked">',
            '<tpl if="Ext.isChrome">',
            '<div class="image-mask" style="{[ values.image ? "-webkit-mask-image: url("+ values.image +")" : "" ]};"></div>',
            '</tpl>',
            '</tpl>'
        ];
        me.data = {
            lightImg: me.clientObject.lightImg,
            masked: me.clientObject.masked
        };
        me.callParent(arguments);
    },
    /**
     *    (text, image)
     */
    setServiceData: function(data) {
        var me = this;
        me.serviceData = data;
        if (!me.rendered) {
            me.update({
                lightImg: me.clientObject.lightImg,
                image: me.serviceData.image ? IMAGE_URL + me.serviceData.image : Ext.BLANK_IMAGE_URL,
                masked: me.clientObject.masked
            });
        } else {
            me.getEl().down('.image').setStyle('background-image', 'url(' + (me.serviceData.image ? IMAGE_URL + me.serviceData.image : Ext.BLANK_IMAGE_URL) + ')');
            if (me.clientObject.masked) {
                if (Ext.isChrome) {
                    me.getEl().down('.image-mask').setStyle('-webkit-mask-image', 'url(' + (me.serviceData.image ? IMAGE_URL + me.serviceData.image : Ext.BLANK_IMAGE_URL) + ')');
                }
            }
        }
        if (me.ownerCt) {
            me.ownerCt.titleComponent.show();
        }
        ExGods.Resources.load(me, function() {
            me.show();
        });
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        //         
        if (!me.isVisible()) {
            me.ownerCt.titleComponent.hide();
        }
    },
    overListener: function() {
        var me = this,
            maskEl = me.el.down('.image-mask'),
            lightImg = me.el.down('.light-img');
        if (lightImg) {
            lightImg.setStyle('opacity', 1);
        }
        if (maskEl && me.clientObject.masked) {
            maskEl.setStyle('opacity', 0);
        }
    },
    leaveListener: function() {
        var me = this,
            maskEl = me.el.down('.image-mask'),
            lightImg = me.el.down('.light-img');
        if (lightImg) {
            lightImg.setStyle('opacity', 0);
        }
        if (maskEl && me.clientObject.masked) {
            maskEl.setStyle('opacity', 0.3);
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        var img = me.data.lightImg;
        if (me.data.image) {
            arr_images.push(me.data.image);
        }
        return {
            stuff: [],
            images: [
                IMAGE_URL + img
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.model.Location', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    proxy: 'memory',
    fields: [
        {
            name: 'action',
            type: 'auto'
        },
        {
            //  
            name: 'blob',
            convert: function(v) {
                if (v) {
                    //        -        
                    v.objects = (function() {
                        var objects = [];
                        Ext.Array.each(v.objects || [], function(item) {
                            var interactive = item.interactive;
                            Ext.Array.each(interactive, function(interactiveItem) {
                                var itemClone = Ext.clone(item);
                                itemClone.interactive = interactiveItem;
                                objects.push(itemClone);
                            });
                        });
                        return objects;
                    }());
                }
                return v;
            }
        },
        {
            //    
            name: 'chat_room_name',
            type: 'string'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            //  
            name: 'name',
            type: 'string'
        },
        {
            name: 'prototype',
            type: 'auto'
        },
        {
            // id  
            name: 'world',
            type: 'int'
        },
        {
            //  
            name: 'quest_bots',
            type: 'auto'
        },
        {
            //    
            name: 'battle_chain',
            type: 'auto'
        }
    ],
    /**
     *    
     * @return {String}  
     */
    getThumb: function() {
        return this.get('blob').thumb ? IMAGE_URL + this.get('blob').thumb : Ext.BLANK_IMAGE_URL;
    },
    /**
     *   
     * @return {String}  
     */
    getName: function() {
        return this.get('name');
    },
    /**
     *    
     * @return {String}  
     */
    getImage: function() {
        return IMAGE_URL + this.get('blob').image || Ext.BLANK_IMAGE_URL;
    },
    getType: function() {
        return this.get('prototype').type;
    },
    /**
     *     
     * @return {Array}   :
     *      {
     *          type -  ,
     *          params_type -   
     *          interactive -   
     *          description -   
     *      }
     */
    getObjects: function() {
        return this.get('blob').objects || [];
    },
    /**
     *   
     * @return {Object}
     */
    getProto: function() {
        var me = this,
            proto = me.get('prototype');
        if (typeof proto == "object") {
            return proto;
        } else {
            return ExGods.references.get('prototypes_rooms').get(parseInt(proto, 10));
        }
    },
    /**
     *  true,   
     */
    isDanger: function() {
        var me = this;
        return this.getProto().blob.danger === "1";
    },
    /**
     *  ,    
     */
    getWorld: function() {
        var me = this,
            worlds = ExGods.app.getWorldsStore();
        return worlds.getById(me.get('world'));
    },
    afterEdit: function(modifiedFields) {
        var me = this;
        /**
         * @event locationchanged   -  
         */
        me.fireEvent('locationchanged');
        Ext.Array.each(modifiedFields, function(key) {
            /**
             *       
             */
            me.fireEvent(key + 'changed', me, me.get(key));
        });
    }
});

/**
 *   -  " "
 */
Ext.define('ExGods.view.location.lob.CloseButton', {
    extend: Ext.Component,
    alias: 'widget.closelocationbtn',
    /**
     * @cfg clientObject {Object}     -
     */
    clientObject: {},
    /**
     * @cfg locationObject {Object}     
     */
    locationObject: {},
    cls: 'location-close-button',
    initComponent: function() {
        var me = this;
        me.width = me.clientObject.width || 114;
        me.height = me.clientObject.height || 40;
        me.style = {
            backgroundImage: 'url(' + IMAGE_URL + me.clientObject.backImg + ')'
        };
        me.tpl = '<div class="button"></div>';
        me.data = {};
        me.callParent(arguments);
    },
    /**
     *      ,    
     */
    locationObjectClickHandler: function(e) {
        var me = this;
        if (e.getTarget('.button')) {
            return true;
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + me.clientObject.backImg
            ]
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.location.LocationObject', {
    extend: Ext.container.Container,
    alias: 'widget.locationobject',
    /**
     * @cfg {Object}   
     */
    objData: {},
    cls: 'location-object',
    overCls: 'location-object-over',
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: {
            info: false,
            wrap: true,
            error: true
        },
        prefix: 'LocationObject:'
    },
    initComponent: function() {
        var me = this;
        me.innerComponent = me.initInnerComponent();
        me.innerComponent.on('afterrender', me.onAfterRender, me);
        me.titleComponent = me.initTitleComponent();
        Ext.apply(me, {
            x: me.objData.interactive.x,
            y: me.objData.interactive.y,
            width: me.objData.interactive.w,
            height: me.objData.interactive.h,
            style: {
                'z-index': me.objData.interactive.z || 0
            },
            items: [
                me.titleComponent,
                me.innerComponent
            ]
        });
        me.callParent(arguments);
    },
    /**
     * @template
     *    .
     * @return {Ext.Component}
     */
    initInnerComponent: function() {},
    //
    /**
     *    ,         
     */
    getTitleText: function() {
        var me = this;
        if (typeof me.innerComponent.getTitleText == 'function') {
            return me.innerComponent.getTitleText();
        } else {
            return me.objData.interactive.params_display.label;
        }
    },
    /**
     *    
     * @return {Object}   {title: <String>, text: <String>}
     */
    getTooltipText: function() {
        var me = this;
        if (typeof me.innerComponent.getTooltipText == 'function') {
            return me.innerComponent.getTooltipText();
        } else if (me.objData.interactive.description) {
            return {
                title: me.objData.description,
                text: me.objData.interactive.description
            };
        }
    },
    /**
     * @template
     *  dom-      
     * @return {Ext.dom.Element} DOM-,     null,    
     */
    getAnimationTarget: function() {},
    //
    /**
     *      
     */
    locationObjectClickHandler: function() {
        var me = this;
        if (me.objData.client_action && me.objData.client_action.id) {
            ExGods.ClientActions.createAndInvoke({
                actionId: me.objData.client_action.id,
                src: 'location-object',
                options: {
                    locationObject: me.objData
                }
            }, null, function(err) {
                /****/
                me.log('error', err);
            });
        }
    },
    /**
     *   
     */
    initTitleComponent: function() {
        var me = this,
            title = me.getTitleText(),
            titleWidth = 105,
            topOffset = me.objData.interactive.params_display.d ? me.objData.interactive.params_display.d : me.objData.interactive.h / 2 - 28,
            scrollingTime = parseFloat(ExGods.ref('constants|animate_scrolling_time').value),
            scrollingDistance = parseFloat(ExGods.ref('constants|animate_scrolling_distance').value),
            onOver = function() {
                var el = me.titleComponent.getEl();
                el.stopAnimation();
                el.animate({
                    duration: scrollingTime,
                    to: {
                        'top': topOffset - scrollingDistance
                    }
                });
            },
            onLeave = function() {
                var el = me.titleComponent.getEl();
                el.stopAnimation();
                el.animate({
                    duration: scrollingTime,
                    to: {
                        'top': topOffset
                    }
                });
            };
        if (title) {
            me.addOnOverListener(onOver);
            me.addOnLeaveListener(onLeave);
            return Ext.widget('component', {
                autoEl: 'span',
                cls: 'location-object-title',
                tpl: [
                    '<span class="location-object-title-inner">{title}</span>'
                ],
                data: {
                    title: title
                },
                style: {
                    'left': ((me.objData.interactive.w - titleWidth) / 2 - 30) + 'px',
                    'top': topOffset + 'px'
                }
            });
        }
    },
    onAfterRender: function() {
        var me = this;
        me.tuneQuestHelperOptions(me.getEl());
        if (me.getTooltipText()) {
            me.createTooltip();
        }
        if (me.getAnimationTarget()) {
            me.startAnimation();
        }
        me.getEl().on('click', function(e) {
            me.onClick(e);
        });
    },
    /**
     * @private    
     */
    startAnimation: function() {
        var me = this,
            animTarget = me.getAnimationTarget(),
            tickSize = 100,
            time_to_show = parseFloat(ExGods.ref('constants|animate_to_show').value),
            time_on_peak = parseFloat(ExGods.ref('constants|animate_on_peak').value),
            time_to_hide = parseFloat(ExGods.ref('constants|animate_to_hide').value),
            time_pause = parseFloat(ExGods.ref('constants|animate_pause').value),
            max_intensity = parseFloat(ExGods.ref('constants|animate_intensity').value),
            phases = [
                {
                    dur: time_to_show,
                    opacity: 0,
                    tick: function() {
                        setOpacity(this, this.opacity + (max_intensity / (time_to_show / tickSize)));
                    },
                    finish: function() {
                        setOpacity(this, max_intensity);
                    }
                },
                {
                    dur: time_on_peak,
                    tick: Ext.emptyFn,
                    finish: Ext.emptyFn
                },
                {
                    dur: time_to_hide,
                    tick: function() {
                        setOpacity(this, this.opacity - (max_intensity / (time_to_hide / tickSize)));
                    },
                    finish: function() {
                        setOpacity(this, 0);
                    }
                },
                {
                    dur: time_pause,
                    tick: Ext.emptyFn,
                    finish: function() {
                        stopAnim = overed ? true : false;
                        setOpacity(this, 0);
                    }
                }
            ],
            setOpacity = function(phase, opacity) {
                if (!stopAnim) {
                    phase.opacity = opacity;
                    animTarget.dom.style.opacity = opacity;
                }
            },
            currentPhase = 0,
            spentTime = 0,
            stopAnim = false,
            overed = false,
            rootEl = me.getEl(),
            onOver = function() {
                overed = true;
                stopAnim = true;
                animTarget.stopAnimation();
                animTarget.setStyle('background-position', '0px 100%');
                animTarget.animate({
                    duration: 400,
                    to: {
                        'opacity': 1
                    }
                });
            },
            onLeave = function() {
                overed = true;
                stopAnim = true;
                animTarget.animate({
                    duration: 400,
                    to: {
                        'opacity': 0
                    },
                    callback: function() {
                        overed = false;
                    }
                });
                animTarget.setStyle('background-position', '0px 0px');
            };
        if (animTarget) {
            me.animationInterval = setInterval(function() {
                try {
                    phases[currentPhase].tick();
                    spentTime += tickSize;
                    if (spentTime >= phases[currentPhase].dur) {
                        phases[currentPhase].finish();
                        var opacity = phases[currentPhase].opacity;
                        spentTime = 0;
                        currentPhase = phases.length - 1 == currentPhase ? 0 : currentPhase + 1;
                        phases[currentPhase].opacity = opacity;
                    }
                } catch (e) {}
            }, //
            tickSize);
            me.addOnOverListener(onOver);
            me.addOnLeaveListener(onLeave);
        }
    },
    /**
     * @private
     */
    stopAnimation: function() {
        var me = this;
        if (me.animationInterval) {
            clearInterval(me.animationInterval);
            me.animationInterval = null;
        }
    },
    /**
     * @private  dom-,    -
     */
    tuneQuestHelperOptions: function(el) {
        var me = this,
            pointerHeight = 46,
            locationViewWidth = 860,
            _getOptions = function(data) {
                var options = {
                        style: '',
                        cls: ''
                    };
                options.style += 'top:' + (data.interactive.h / 2 - pointerHeight / 2) + 'px;';
                if (data.interactive.x < locationViewWidth / 2) {
                    options.cls = 'flip-h';
                    options.style += 'left:' + (data.interactive.w - 10) + 'px;';
                } else {
                    options.style += 'left:-60px;';
                }
                return Ext.String.htmlEncode(Ext.encode(options));
            };
        el.set({
            'data-qh_otype': 'iobject',
            'data-qh_oid': me.objData.id || me.objData.description,
            'data-qh_opts': _getOptions(me.objData)
        });
        el.addCls('qh-object');
    },
    /**
     * @private
     */
    createTooltip: function() {
        var me = this,
            title = me.getTooltipText().title,
            text = me.getTooltipText().text;
        me.tooltip = Ext.create('Ext.tip.ToolTip', {
            target: me.getEl(),
            maxWidth: parseInt(ExGods.ref('constants|tooltip_max_width').value),
            cls: 'paperdeco-tooltip',
            plugins: [
                'paperdeco'
            ],
            html: '<div class="paper-title ellipsis">' + title + '</div>' + '<div class="tooltip-paper-body">' + text + '</div>'
        });
    },
    /**
     * @private
     */
    addOnOverListener: function(listener) {
        var me = this,
            rootEl = me.getEl();
        if (!rootEl) {
            me.on('afterrender', function() {
                me.addOnOverListener(listener);
            }, me, {
                single: true
            });
            return;
        }
        if (!me.overListeners) {
            me.overListeners = [];
            rootEl.on('mouseenter', function() {
                me.overListeners.forEach(function(listener) {
                    listener.call(me);
                });
                if (!me.leaveDetectInterval) {
                    me.leaveDetectInterval = setInterval(function() {
                        if (!rootEl.hasCls('location-object-over')) {
                            if (me.leaveListeners) {
                                me.leaveListeners.forEach(function(listener) {
                                    listener.call(me);
                                });
                            }
                            clearInterval(me.leaveDetectInterval);
                            me.leaveDetectInterval = null;
                        }
                    }, 100);
                }
            });
        }
        me.overListeners.push(listener);
    },
    /**
     * @private
     */
    addOnLeaveListener: function(listener) {
        var me = this;
        if (!me.leaveListeners) {
            me.leaveListeners = [];
        }
        me.leaveListeners.push(listener);
    },
    /**
     * @private
     */
    onClick: function(e) {
        var me = this,
            win;
        if (me.objData.view_message) {
            win = Ext.widget('commonwindow', {
                autoShow: true,
                closeAction: 'destroy',
                buttonAlign: 'center',
                minWidth: 250,
                y: 260,
                buttons: {
                    defaultType: 'textbutton',
                    items: [
                        {
                            handler: function() {
                                win.destroy();
                            },
                            text: ExGods.getMsgByKey('close_btn_text')
                        }
                    ]
                }
            });
            win.update(me.objData.view_message);
        } else {
            me.locationObjectClickHandler(e);
        }
    },
    /**
     * @private
     */
    onDestroy: function() {
        var me = this;
        if (me.leaveDetectInterval) {
            clearInterval(me.leaveDetectInterval);
        }
        if (me.tooltip) {
            me.tooltip.destroy();
            me.tooltip = null;
        }
        me.stopAnimation();
    }
});

/**
 *   ""
 */
Ext.define('ExGods.view.location.LocationObjectImage', {
    extend: ExGods.view.location.LocationObject,
    alias: 'widget.locationobjectimage',
    cls: 'location-object location-object-image',
    /**
     * @override
     *    .
     * @return {Ext.Component}
     */
    initInnerComponent: function() {
        var me = this;
        return Ext.widget('component', {
            cls: 'location-object-inner',
            autoEl: 'a',
            layout: 'absolute',
            width: me.objData.interactive.w,
            height: me.objData.interactive.h,
            style: {
                backgroundImage: 'url(' + IMAGE_URL + me.objData.interactive.params_display.image + ')'
            }
        });
    },
    /**
     * @override
     *  dom-      
     * @return {Ext.dom.Element} DOM-,     null,    
     */
    getAnimationTarget: function() {
        var me = this;
        return me.innerComponent.getEl();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        var image = IMAGE_URL + me.objData.interactive.params_display.image;
        return {
            images: [
                image
            ].concat(arr_images)
        };
    }
});

/**
 *   ""
 */
Ext.define('ExGods.view.location.LocationObjectButton', {
    extend: ExGods.view.location.LocationObject,
    alias: 'widget.locationobjectbutton',
    cls: 'location-object location-object-button',
    /**
     * @override
     *    .
     * @return {Ext.Component}
     */
    initInnerComponent: function() {
        var me = this,
            config = {},
            cls = 'location-object-inner ',
            text = me.objData.interactive.params_display.label;
        config.text = text;
        if (me.objData.interactive.params_display.style == "double") {
            cls += 'double_text_btn double_text ';
            config.minWidth = 88;
        }
        if (me.objData.interactive.params_display.color) {
            cls += 'x-btn-txt-' + me.objData.interactive.params_display.color;
        }
        if (me.objData.interactive.w) {
            config.minWidth = me.objData.interactive.w;
        }
        if (cls) {
            config.cls = cls;
        }
        return Ext.widget('textbutton', config);
    },
    /**
     * @override
     */
    getTitleText: function() {},
    //  
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   ""
 */
Ext.define('ExGods.view.location.LocationObjectComponent', {
    extend: ExGods.view.location.LocationObject,
    alias: 'widget.locationobjectcomponent',
    cls: 'location-object location-object-component',
    /**
     * @override
     *    .
     * @return {Ext.Component}
     */
    initInnerComponent: function() {
        var me = this,
            config = {
                locationObject: me.objData
            },
            info, cmp;
        ExGods.ref('client_objects').each(function(item) {
            if (item.id == me.objData.interactive.params_display.component_params.id) {
                info = item;
            }
        });
        if (info && info.name) {
            cmp = ExGods.Components.factory(info.name, config);
        }
        if (!cmp.error) {
            if (cmp.overListener) {
                me.addOnOverListener(function() {
                    cmp.overListener();
                });
            }
            if (cmp.leaveListener) {
                me.addOnLeaveListener(function() {
                    cmp.leaveListener();
                });
            }
            return cmp;
        } else {
            me.log('error', '@initInnerComponent    : ' + cmp.error);
        }
    },
    /**
     * @override
     *     
     */
    locationObjectClickHandler: function() {
        var me = this;
        if (typeof me.innerComponent.locationObjectClickHandler == 'function') {
            if (me.innerComponent.locationObjectClickHandler.apply(me.innerComponent, arguments) === true) {
                me.callParent(arguments);
            }
        } else {
            me.callParent(arguments);
        }
    },
    /**
     * @override
     *  dom-      
     * @return {Ext.dom.Element} DOM-,     null,    
     */
    getAnimationTarget: function() {
        var me = this;
        if (typeof me.innerComponent.getAnimationTarget == 'function') {
            return me.innerComponent.getAnimationTarget();
        }
    }
});
/**
     *     
     */

/**
 *  
 */
Ext.define('ExGods.view.location.Location', {
    extend: Ext.panel.Panel,
    alias: 'widget.locationview',
    mixins: [
        ExGodsCore.util.Loggable
    ],
    logConfig: {
        enabled: {
            info: true,
            wrap: false,
            error: false
        },
        prefix: 'LocationView:'
    },
    /**
     * @cfg location {ExGodsCore.model.Location}
     *  
     */
    bodyPadding: 0,
    header: false,
    layout: 'absolute',
    margin: '3 5 7 5',
    plugins: [
        'irondeco'
    ],
    height: 412,
    itemsToDraw: [],
    initComponent: function() {
        var me = this;
        me.location = me.user.location;
        me.mon(me.location, 'locationchanged', me.drawLocation, me);
        me.callParent();
        me.drawLocation();
    },
    drawLocation: function() {
        var me = this,
            items;
        items = [
            {
                xtype: 'image',
                anchor: '100% 100%',
                src: me.location.getImage()
            }
        ];
        Ext.Array.each(me.location.getObjects(), function(item) {
            if (item.interactive.view == 'image') {
                items.push(Ext.widget({
                    xtype: 'locationobjectimage',
                    autoShow: false,
                    objData: item
                }));
            } else if (item.interactive.view == 'button') {
                items.push(Ext.widget({
                    xtype: 'locationobjectbutton',
                    autoShow: false,
                    objData: item
                }));
            } else if (item.interactive.view == 'component') {
                items.push({
                    //  locationobjectcomponent     
                    xtype: 'locationobjectcomponent',
                    autoShow: false,
                    objData: item
                });
            } else {}
        });
        //
        me.itemsToDraw = items;
        if (!me.loaderCt || !me.loaderCt.animating) {
            ExGods.Resources.load({
                items: {
                    items: me.itemsToDraw
                },
                getResources: function() {
                    var image_fon = me.location.getImage();
                    return {
                        images: [
                            image_fon
                        ]
                    };
                }
            }, function() {
                me.redrawItems();
            });
        }
    },
    /**
     * @private
     */
    redrawItems: Ext.Function.createBuffered(function() {
        var me = this;
        if (!me.itemsToDraw.length)  {
            return;
        }
        
        me.removeAll();
        if (me.el && ExGods.loaderCt.isVisible()) {
            ExGods.loaderCt.addLoadRemover();
        }
        me.add(me.itemsToDraw);
        me.itemsToDraw = [];
    }, 200),
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            imgs;
        imgs = ExGods.ref('images|location_images').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        return {
            images: [
                //   
                IMAGE_URL + 'locations/header_on_location.png',
                IMAGE_URL + 'locations/header_on_location.png',
                IMAGE_URL + 'locations/header_on_location.png',
                IMAGE_URL + 'locations/header_on_location.png',
                IMAGE_URL + 'locations/text_1.png',
                IMAGE_URL + 'locations/text_3.png',
                IMAGE_URL + 'locations/text_2.png',
                IMAGE_URL + 'locations/text_1_hover.png',
                IMAGE_URL + 'locations/text_3_hover.png',
                IMAGE_URL + 'locations/text_2_hover.png',
                IMAGE_URL + 'interface/quest_helper/item.png'
            ].concat(arr_images)
        };
    }
});

/**
 *    
 *
 */
Ext.define('ExGods.model.Monster', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'banish_enable',
            type: 'string'
        },
        {
            name: 'battle_enable',
            type: 'string'
        },
        {
            name: 'bot_stats',
            type: 'auto'
        },
        {
            name: 'bot_type',
            type: 'auto'
        },
        {
            name: 'cooldown_banish',
            type: 'auto'
        },
        {
            name: 'count',
            type: 'auto'
        },
        {
            name: 'gender',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'auto'
        },
        {
            name: 'last_banish',
            type: 'auto'
        },
        {
            name: 'shape',
            type: 'auto'
        },
        {
            name: 'description',
            type: 'auto'
        },
        {
            name: 'greetings_template',
            type: 'auto'
        },
        {
            name: 'battle_id',
            type: 'int'
        },
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'stuff',
            type: 'auto'
        },
        {
            name: 'source',
            type: 'string'
        },
        {
            name: 'toughness',
            type: 'string'
        },
        {
            name: 'reward_banish',
            type: 'auto'
        },
        {
            name: 'level',
            type: 'auto'
        },
        {
            name: 'wait',
            type: 'int'
        },
        {
            //  
            name: 'chain',
            type: 'auto'
        },
        {
            //     
            name: 'chain_next_time',
            type: 'auto'
        }
    ]
});

/**
 *   
 */
Ext.define('ExGods.store.Monster', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Monster',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'entry',
            direction: 'DESC'
        }
    ],
    constructor: function() {
        var me = this;
        me.callParent(arguments);
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Location', {
    extend: ExGodsCore.controller.Base,
    mixins: [
        ExGods.util.Flags
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Location:'
    },
    models: [
        'BasicUser',
        'Location',
        'World'
    ],
    stores: [
        'Monster'
    ],
    views: [
        'location.Location',
        'location.lob.BotsList',
        'location.lob.CloseButton',
        'location.lob.ServiceEnter'
    ],
    refs: [
        {
            /**
         * @method getLocationHeader
         *     
         * @return {Ext.container.Container}
         */
            ref: 'locationHeader',
            selector: '#location-header'
        },
        {
            /**
         * @method getLocationInfo
         *      
         * @return {Ext.panel.Panel}
         */
            ref: 'locationInfo',
            selector: '#location-info'
        },
        {
            /**
         * @method getHeaderRightInfo
         *      ,  
         *      
         * @return {Ext.container.Container}
         */
            ref: 'headerRightInfo',
            selector: '#header-right'
        },
        {
            /**
         * @method getLocationContainer
         *    
         * @return {ExGods.view.location.Container}
         */
            ref: 'locationContainer',
            selector: '#location-container'
        },
        {
            ref: 'questButton',
            selector: '#mainmenu-quests-button'
        }
    ],
    //  
    locationServices: [],
    init: function(app) {
        var me = this,
            user = me.getUser(),
            worlds = app.getWorldsStore();
        me.service = ExGods.Services.get('location');
        me.service.on('update', me.onServiceUpdate, me);
        //        "location"
        me.addAjaxRequestKeyHandler('location', function(data) {
            me.service.update(data);
        }, me);
        //   
        worlds.loadRawData(config.references.worlds);
        me.user.location = Ext.create('ExGods.model.Location', Ext.clone(me.service.data.location));
        me.user.location.on('locationchanged', me.onLocationChange, me);
        me.control({
            '#location-container locationbots': {
                afterrender: me.locationBotsRefresh
            }
        });
        user.location.on({
            'entrychanged': me.onLocationEntryChange,
            scope: me
        });
        me.app.chatcn.on('command_location', me.onLocationCommand, me);
        ExGods.Components.addComponentInitializer('bot_list', me.initBotsListComponent, me);
        ExGods.Components.addComponentInitializer('close_location_button', me.initCloseLocationButtonComponent, me);
        ExGods.Components.addComponentInitializer('location_service_enter', me.initLocationServiceEnterComponent, me);
        me.callParent(arguments);
    },
    /**
     *    command_location  
     */
    onLocationCommand: function(chatcn, data) {
        this.updateLocation();
    },
    /**
     * @private
     */
    onLocationChange: function() {
        var me = this,
            headerCt = me.getLocationHeader(),
            viewport = me.app.getController('Viewport'),
            chatCt = me.app.getController('Chat'),
            cb = function() {
                //   
                if (headerCt) {
                    headerCt.items.items[0].update({
                        location: me.user.location.get('name'),
                        world: me.user.location.getWorld().get('title')
                    });
                }
                //    (   =  )
                if (chatCt)  {
                    chatCt.getChannelByType('location').setTitle(me.user.location.get('name'));
                }
                
            };
        if (viewport.layout == 'main') {
            cb();
        }
    },
    /**
     *       
     */
    updateLocation: function() {
        var me = this;
        /***/
        me.log('   ..');
        me.service.update(null, function() {});
    },
    //          
    onServiceUpdate: function(service, newData, oldData) {
        var me = this;
        if (!ExGods.helpme.isEqual(newData.location, oldData.location)) {
            me.user.location.setRawData(Ext.clone(newData.location));
        }
    },
    /**
     * @private
     * ,      (user->binding->room)
     */
    onLocationEntryChange: function() {
        var me = this,
            viewport = me.app.getController('Viewport'),
            container = me.getLocationContainer(),
            view = (container) ? container.down('locationview') : null,
            cb = function() {
                viewport.closeAllWindows();
                //  
                me.locationBotsRefresh();
            };
        ExGods.Resources.load('location-container', function() {
            if (viewport.layout == 'main') {
                var loader = (view) ? view.loaderCt : null;
                if (loader) {
                    if (loader.animating) {
                        loader.on('animation_complete', function() {
                            cb();
                        }, {
                            single: true
                        });
                    } else {
                        cb();
                    }
                } else {
                    cb();
                }
            }
        });
    },
    /**
     *   
     */
    locationBotsRefresh: function() {
        //     .        .
        var me = this,
            surging = me.app.getSurgingController();
        if (surging) {
            surging.updateStore();
        }
    },
    /**
     *   
     */
    lockUpdate: function() {
        var me = this;
        me.set_f('lock_update', true);
        me.user.location.suspendEvents(true);
    },
    /**
     *       
     */
    unlockUpdate: function() {
        var me = this;
        if (me.isLocked()) {
            me.set_f('lock_update');
            me.user.location.resumeEvents(true);
            me.app.getSurgingController().updateStore();
        }
    },
    isLocked: function() {
        var me = this;
        return me.get_f('lock_update');
    },
    /**
     *     
     */
    maskLocation: function(callback, options) {
        var me = this,
            locationCt = Ext.getCmp('location-container');
        callback = callback || Ext.emptyFn;
        options = options || {};
        ExGods.loaderCt.addLoader(callback, options);
    },
    unmaskLocation: function(callback, options) {
        var me = this,
            locationCt = Ext.getCmp('location-container');
        callback = callback || Ext.emptyFn;
        options = options || {};
        ExGods.loaderCt.addLoadRemover(callback, options);
    },
    /**
     *  ,      .
     */
    getBindableServices: function(protoName) {
        var me = this,
            objects = me.service.data.location.blob.objects || [],
            services = [],
            service;
        for (var i = 0; i < objects.length; i++) {
            if (objects[i].client_action && objects[i].client_action.id) {
                service = ExGods.Services.factory(objects[i].client_action.id);
                if (!service.error && service.info.proto['package'] == protoName) {
                    services.push(service);
                } else if (service.error) {
                    /***/
                    me.log('error', '     ', service.error);
                }
            }
        }
        return services;
    },
    /**
     *   "bot_list"
     */
    initBotsListComponent: function(config) {
        var me = this,
            cmp;
        cmp = Ext.widget('locationbots', {
            id: 'LOB_BOT_LIST',
            user: me.user,
            store: ExGods.app.getMonsterStore(),
            clientObject: config,
            locationObject: config.locationObject,
            autoShow: false
        });
        ExGods.Resources.load(cmp, function() {
            cmp.show();
        });
        return cmp;
    },
    /**
     *   "close_location_button"
     */
    initCloseLocationButtonComponent: function(config) {
        var me = this,
            btn = Ext.widget('closelocationbtn', {
                clientObject: config,
                autoShow: false,
                locationObject: config.locationObject
            });
        ExGods.Resources.load(btn, function() {
            btn.show();
        });
        return btn;
    },
    /**
     *   "location_service_enter"
     */
    initLocationServiceEnterComponent: function(config) {
        var me = this,
            service = ExGods.Services.factory(config.locationObject.client_action.id),
            cmp,
            loadServiceData = function(callback) {
                if (service && !service.error) {
                    service.command('get_service_show', {}, function(resp) {
                        if (resp && resp.service) {
                            callback(resp.service);
                        }
                    }, {
                        url: 'game.pl'
                    });
                } else {
                    /****/
                    me.log('error', '@initLocationServiceEnterComponent    ', service.error);
                }
            };
        cmp = Ext.widget('serviceenter', {
            clientObject: config,
            locationObject: config.locationObject,
            hidden: true,
            autoShow: false
        });
        //     -    
        cmp.mon(me.service, 'update', function() {
            if (cmp.rendered) {
                loadServiceData(function(data) {
                    cmp.setServiceData(data);
                });
            }
        }, me, {
            delay: 300
        });
        // ,  ,        
        loadServiceData(function(data) {
            cmp.setServiceData(data);
        });
        return cmp;
    }
});

/**
 *    ,     
 *     
 */
Ext.define('ExGods.controller.Log', {
    extend: ExGods.controller.Base,
    init: function() {
        Ext.Ajax.on('requestcomplete', this.onRequestComplete, this);
    },
    onRequestComplete: function(conn, response, options) {
        var me = this,
            result = Ext.decode(response.responseText, true);
        if (result && result.msg && typeof result.msg == 'string') {
            //    -    
            var text = me.application.getController('Direction').processText(result.msg);
            me.application.fireEvent('logmessage', text);
        }
    }
});

/**
 *     
 */
Ext.define('ExGods.model.MarketItem', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            //  .   -   ,   -  1
            //  ,   
            name: 'level',
            type: 'int'
        },
        {
            //  .   - fucina  home.   - item1, item2, item3, item4 (  )
            //  ,   
            name: 'type',
            type: 'string'
        },
        {
            //   .   -  1
            name: 'grade',
            type: 'int'
        },
        {
            //  
            name: 'image',
            type: 'string'
        },
        {
            //     (name, value)
            name: 'price',
            type: 'auto'
        },
        {
            // -  .
            name: 'quantity',
            type: 'int'
        },
        {
            name: 'max_price',
            type: 'int'
        },
        {
            name: 'min_price',
            type: 'int'
        },
        {
            //     
            name: 'stuff',
            type: 'auto'
        },
        {
            //     
            name: 'create_date',
            type: 'string'
        }
    ]
});

/**
 *       
 */
Ext.define('ExGods.view.parchment.Combo', {
    extend: Ext.form.field.ComboBox,
    alias: 'widget.parchmentcombo',
    cls: 'parchment-combo',
    initComponent: function() {
        var me = this;
        me.listConfig = Ext.applyIf(me.listConfig || {}, {
            cls: 'parchment-combo-bound-list',
            minWidth: 140,
            afterRender: function() {
                var me = this;
                me.superclass.afterRender.apply(me, arguments);
                me.el.insertHtml('afterBegin', '<div class="paper paper-tl"></div>' + '<div class="paper paper-tm"></div>' + '<div class="paper paper-tr"></div>' + '<div class="paper paper-mr"></div>' + '<div class="paper paper-br"></div>' + '<div class="paper paper-bm"></div>' + '<div class="paper paper-bl"></div>' + '<div class="paper paper-ml"></div>' + '<div class="paper paper-bg"></div>');
            },
            setXY: function(pos) {
                var me = this;
                pos[0] = pos[0] - 5;
                //    5 px 
                me.superclass.setXY.call(me, pos);
            }
        });
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'deco/paper/paper_top_left.png',
                IMAGE_URL + 'deco/paper/paper_top_middle.png',
                IMAGE_URL + 'deco/paper/paper_top_right.png',
                IMAGE_URL + 'deco/paper/paper_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_right.png',
                IMAGE_URL + 'deco/paper/paper_bottom_middle.png',
                IMAGE_URL + 'deco/paper/paper_bottom_left.png',
                IMAGE_URL + 'deco/paper/paper_left.png',
                IMAGE_URL + 'deco/paper/paper_center_tile.png',
                IMAGE_URL + 'deco/paper/paper_top_left.png',
                IMAGE_URL + 'btn_close.png',
                IMAGE_URL + 'close.png',
                IMAGE_URL + 'deco/paper/paper_separator_top.png',
                IMAGE_URL + 'deco/paper/paper_separator_vertical.png',
                IMAGE_URL + 'deco/paper/paper_separator_left.png',
                IMAGE_URL + 'deco/paper/paper_separator_right.png',
                IMAGE_URL + 'deco/paper/paper_separator_horisontal.png',
                IMAGE_URL + 'deco/paper/header_left.png',
                IMAGE_URL + 'deco/paper/header_right.png',
                IMAGE_URL + 'deco/paper/header_middle.png'
            ].concat(arr_images)
        };
    }
});

/**
 * C    
 */
Ext.define('ExGods.view.grid.ParchmentGrid', {
    extend: ExGods.view.grid.Grid,
    alias: 'widget.exg_parchment_grid',
    cls: 'exg-grid-parchment',
    cellWidth: 186,
    cellHeight: 140,
    /**
     *     
     * @override
     */
    initItemTemplate: function() {
        var me = this;
        //     
        if (Ext.isArray(me.itemTpl)) {
            me.itemTpl.unshift('<div class="exg-grid-parchment-item-wrap"><div class="exg-grid-parchment-info-icon"></div>');
            if (typeof me.itemTpl[me.itemTpl.length - 1] == 'object') {
                Ext.Array.insert(me.itemTpl, me.itemTpl.length - 1, [
                    '</div>'
                ]);
            } else {
                me.itemTpl.push('</div>');
            }
        } else {
            me.itemTpl = '<div class="exg-grid-parchment-item-wrap"><div class="exg-grid-parchment-info-icon"></div>' + me.itemTpl + '</div>';
        }
        me.callParent(arguments);
    }
});

/**
 *   
 */
Ext.define('ExGods.view.market.Items', {
    extend: ExGods.view.grid.ParchmentGrid,
    alias: 'widget.marketitems',
    /**
     * @cfg service {ExGods.service.Market} service
     */
    service: null,
    /**
     * @cfg clientObject {Object}     -
     */
    clientObject: {},
    cls: 'market-items',
    initComponent: function() {
        var me = this;
        //  
        me.rowsCount = 2;
        me.columnsCount = 3;
        me.itemTpl = [
            '<div class="{[this.getCls(values)]}">',
            '<div class="title ellipsis">{[ this.printTitle(values) ]}</div>',
            '<div class="quantity">{[ this.printQuantity(values) ]}</div>',
            '<div class="image">{[ this.printImage(values) ]}</div>',
            '<div class="level">{[ this.printLevel(values) ]}</div>',
            '<div class="price">{[ this.printPrice(values) ]}</div>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border</span>',
            '<span role="action">market-buy</span>',
            '<span role="width:int">90</span>',
            '<span role="minWidth:int">90</span>',
            '<span role="margin">8 0 0 8</span>',
            '<span role="entry">{entry}</span>',
            '<span role="price">{price.value}</span>',
            '<span role="confirm">{[ this.getConfirmText(values) ]}</span>',
            '<span role="confirm2_tpl">{[ this.getConfirm2Tpl() ]}</span>',
            '<span role="disabled:bool">{[ values.quantity > 0 ? false : true ]}</span>',
            '<span role="text">' + me.clientObject.buy_btn_text + '</span>',
            '</div>',
            '</div>',
            {
                getCls: function(values) {
                    var cls = '';
                    if (values.quantity == 0) {
                        cls = 'disabled';
                    }
                    return cls;
                },
                printTitle: function(values) {
                    return '<span class="item-grade-color-' + values.grade + '">' + values.title + '</span>';
                },
                printQuantity: function(values) {
                    if (values.quantity > 0) {
                        return Ext.String.format(me.clientObject.items_count_text, values.quantity);
                    } else {
                        return me.clientObject.no_item_count_text;
                    }
                },
                printImage: function(values) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'shop_stuff',
                        params: {
                            stuff: values.stuff
                        }
                    });
                },
                printLevel: function(values) {
                    return Ext.String.format(me.clientObject.item_level_text, values.level);
                },
                printPrice: function(values) {
                    if (values.quantity > 0) {
                        return ExGods.util.Format.printMoney(values.price);
                    } else {
                        //   
                        // var avr = Math.round((values.max_price - values.min_price)/2);
                        // return ExGods.util.Format.printMoney({name: values.price.name, value: avr});
                        return '&nbsp;';
                    }
                },
                getConfirmText: function(values) {
                    if (values.price) {
                        return Ext.String.format(me.clientObject.buy_confirm, ExGods.util.Stuff.printStuff({
                            type: 'currency',
                            params: {
                                id: values.price.name,
                                quantity: values.price.value
                            }
                        }));
                    } else {
                        return '';
                    }
                },
                getConfirm2Tpl: function(values) {
                    return me.clientObject.buy_confirm2;
                }
            }
        ];
        me.emptyText = me.clientObject.empty_items_text;
        me.pager = {
            marginRight: -27,
            marginLeft: -36,
            textTop: -32,
            textLeft: 237
        };
        me.initStore();
        me.initFilters();
        me.callParent(arguments);
        //   
        me.itemsView.on('refresh', function(view) {
            ExGods.helpme.renderComponents(view.getEl(), me);
        });
        me.itemsView.on('beforedestroy', function(view) {
            ExGods.helpme.destroyComponents(view.getEl());
        });
        me.mon(me.service, 'update', me.onServiceUpdate, me);
    },
    /**
     *      
     */
    setFilter: function(type, value) {
        var me = this;
        if (type == 'text') {
            me.setTextFilter(value);
        } else if (type == 'avail') {
            me.setAvailFilter(value);
        } else if (type == 'level') {
            me.setLevelFilter(value);
        } else if (type == 'type') {
            me.setTypeFilter(value);
        }
    },
    /**
     *  
     */
    applyFilters: function() {
        var me = this,
            filters = [];
        for (var filterName in me.filters) {
            if (me.filters.hasOwnProperty(filterName)) {
                filters.push(me.filters[filterName]);
            }
        }
        me.store.clearFilter();
        me.store.filter(filters);
    },
    /**
     *  
     */
    clearFilters: function() {
        var me = this;
        me.store.clearFilter();
    },
    /****************** PRIVATES ******************/
    //   
    initStore: function() {
        var me = this,
            data = [],
            getMinPrice = function(prices) {
                var result = {
                        value: undefined,
                        type: ''
                    };
                prices.forEach(function(price) {
                    if (result.value == undefined) {
                        result = price;
                    } else if (parseInt(price.value) < parseInt(result.value)) {
                        result = price;
                    }
                });
                return result;
            };
        ExGods.ref('market').each(function(entry, item) {
            var proto, marketItem;
            marketItem = {
                entry: entry,
                min_price: item.min_price,
                max_price: item.max_price,
                stuff: item.stuff,
                price: item.price
            };
            if (me.service.data.market && me.service.data.market[entry]) {
                marketItem.quantity = me.service.data.market[entry].price.length;
                marketItem.price = getMinPrice(me.service.data.market[entry].price);
            } else {
                marketItem.quantity = 0;
            }
            if (marketItem.stuff.type == 'item') {
                proto = ExGods.app.getItemPrototypesStore().data.getByKey(parseInt(marketItem.stuff.params.id));
                if (proto) {
                    marketItem.type = 'item';
                    marketItem.title = proto.data.title;
                    marketItem.level = proto.data.data.strict.level;
                    marketItem.grade = parseInt(proto.data.data.item_grade || 0) || 1;
                    marketItem.image = proto.data.images.info;
                }
                data.push(marketItem);
            } else if (marketItem.stuff.type == 'ingredients') {
                proto = ExGods.ref('ingredients|' + marketItem.stuff.params.id);
                if (proto) {
                    marketItem.type = proto.place;
                    marketItem.title = proto.label;
                    marketItem.level = 1;
                    marketItem.grade = 1;
                    marketItem.image = IMAGE_URL + proto.params.images.img_1;
                }
                data.push(marketItem);
            } else {}
        });
        //
        if (!me.store) {
            me.store = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.MarketItem',
                data: data,
                sorters: [
                    {
                        //    (  )
                        sorterFn: function(o1, o2) {
                            if (o1.data.quantity == 0) {
                                return 1;
                            } else if (o2.data.quantity == 0) {
                                return -1;
                            } else {
                                return 0;
                            }
                        }
                    }
                ]
            });
        } else {
            me.store.loadRawData(data);
        }
    },
    initFilters: function() {
        var me = this;
        me.filters = {};
        me.setAvailFilter(true);
        me.applyFilters();
    },
    //       
    onServiceUpdate: function() {
        var me = this;
        me.initStore();
    },
    setTextFilter: function(value) {
        var me = this;
        value = Ext.String.trim(value);
        if (value) {
            me.filters['text'] = new Ext.util.Filter({
                filterFn: function(item) {
                    var itemTitle = item.data.title;
                    return itemTitle.toLowerCase().indexOf(value.toLowerCase()) == -1 ? false : true;
                }
            });
        } else {
            delete me.filters['text'];
        }
    },
    setLevelFilter: function(value) {
        var me = this;
        if (value && value != 0) {
            me.filters['level'] = new Ext.util.Filter({
                filterFn: function(item) {
                    return item.data.level == value;
                }
            });
        } else {
            delete me.filters['level'];
        }
    },
    setTypeFilter: function(value) {
        var me = this;
        if (value && value != 'all') {
            me.filters['type'] = new Ext.util.Filter({
                filterFn: function(item) {
                    if (/^item/.test(value)) {
                        var parts = value.split('_');
                        // item_1 or item_2 or ..   -  
                        return item.data.type == 'item' && item.data.grade == parts[1];
                    } else {
                        return item.data.type == value;
                    }
                }
            });
        } else {
            delete me.filters['type'];
        }
    },
    setAvailFilter: function(value) {
        var me = this;
        if (value) {
            if (!me.filters['avail']) {
                me.filters['avail'] = new Ext.util.Filter({
                    filterFn: function(item) {
                        return item.data.quantity > 0;
                    }
                });
            }
        } else {
            delete me.filters['avail'];
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.market.MyItems', {
    extend: ExGods.view.grid.ParchmentGrid,
    alias: 'widget.marketmyitems',
    /**
     * @cfg service {ExGods.service.Market} service
     */
    service: null,
    /**
     * @cfg clientObject {Object}     -
     */
    clientObject: {},
    cls: 'market-items market-my-items',
    initComponent: function() {
        var me = this;
        //  
        me.rowsCount = 2;
        me.columnsCount = 3;
        me.itemTpl = [
            '<div>',
            '<div class="title ellipsis">{[ this.printTitle(values) ]}</div>',
            '<div class="timer">{[ this.printTimer(values) ]}</div>',
            '<div class="image">{[ this.printImage(values) ]}</div>',
            '<div class="level">{[ this.printLevel(values) ]}</div>',
            '<div class="price">{[ this.printPrice(values) ]}</div>',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border</span>',
            '<span role="action">market-cancel</span>',
            '<span role="entry">{entry}</span>',
            '<span role="confirm">' + me.clientObject.cancel_confirm + '</span>',
            '<span role="text">' + me.clientObject.cancel_btn_text + '</span>',
            '<span role="width:int">90</span>',
            '<span role="minWidth:int">90</span>',
            '<span role="margin">8 0 0 8</span>',
            '</div>',
            '</div>',
            {
                printTitle: function(values) {
                    return '<span class="item-grade-color-' + values.grade + '">' + values.title + '</span>';
                },
                printImage: function(values) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'shop_stuff',
                        params: {
                            stuff: values.stuff
                        }
                    });
                },
                printLevel: function(values) {
                    return Ext.String.format(me.clientObject.item_level_text, values.level);
                },
                printPrice: function(values) {
                    return ExGods.util.Format.printMoney(values.price);
                },
                printTimer: function(values) {
                    var dt = ExGods.util.Date.normalizeServerDateTime(values.create_date);
                    return Ext.String.format(me.clientObject.drop_cooldown_text, ExGods.util.Timers.printRestTimer('market-my-items-timer', Ext.Date.add(dt, Ext.Date.HOUR, me.service.data.ttl)));
                }
            }
        ];
        me.emptyText = me.clientObject.empty_my_items_text;
        me.pager = {
            marginRight: -27,
            marginLeft: -36,
            textTop: -32,
            textLeft: 237
        };
        me.initStore();
        me.initFilters();
        me.callParent(arguments);
        //   
        me.itemsView.on('refresh', function(view) {
            ExGods.helpme.renderComponents(view.getEl(), me);
        });
        me.itemsView.on('beforedestroy', function(view) {
            if (view.getEl()) {
                ExGods.helpme.destroyComponents(view.getEl());
            }
        });
        me.mon(me.service, 'update', me.onServiceUpdate, me);
    },
    /**
     *      
     */
    setFilter: function(type, value) {
        var me = this;
        if (type == 'text') {
            me.setTextFilter(value);
        } else if (type == 'level') {
            me.setLevelFilter(value);
        } else if (type == 'type') {
            me.setTypeFilter(value);
        }
    },
    /**
     *  
     */
    applyFilters: function() {
        var me = this,
            filters = [];
        for (var filterName in me.filters) {
            if (me.filters.hasOwnProperty(filterName)) {
                filters.push(me.filters[filterName]);
            }
        }
        me.store.clearFilter();
        me.store.filter(filters);
    },
    /****************** PRIVATES ******************/
    getMarketItem: function(me) {
        var data = [];
        me.service.data.user_product.forEach(function(item) {
            var refData = ExGods.ref('market|' + item.ref_entry),
                marketItem;
            if (refData) {
                marketItem = {
                    entry: item.entry,
                    min_price: refData.min_price,
                    max_price: refData.max_price,
                    stuff: refData.stuff,
                    price: {
                        name: item.currency,
                        value: item.price
                    },
                    create_date: item.create_date
                };
                if (marketItem.stuff.type == 'item') {
                    proto = ExGods.app.getItemPrototypesStore().data.getByKey(parseInt(marketItem.stuff.params.id));
                    if (proto) {
                        marketItem.type = 'item';
                        marketItem.title = proto.data.title;
                        marketItem.level = proto.data.data.strict.level;
                        marketItem.grade = (parseInt(proto.data.data.item_grade || 0)) + 1;
                        marketItem.image = proto.data.images.info;
                    }
                    data.push(marketItem);
                } else if (marketItem.stuff.type == 'ingredients') {
                    proto = ExGods.ref('ingredients|' + marketItem.stuff.params.id);
                    if (proto) {
                        marketItem.type = proto.place;
                        marketItem.title = proto.label;
                        marketItem.level = 1;
                        marketItem.grade = 1;
                        marketItem.image = IMAGE_URL + proto.params.images.img_1;
                    }
                    data.push(marketItem);
                } else {}
            }
        });
        //
        return data;
    },
    //    
    initStore: function() {
        var me = this,
            data = [];
        var me = this,
            data = [],
            getMinPrice = function(prices) {
                var result = {
                        value: 0,
                        type: ''
                    };
                prices.forEach(function(price) {
                    if (price.value >= result.value) {
                        result = price;
                    }
                });
                return result;
            };
        data = me.getMarketItem(me);
        if (!me.store) {
            me.store = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.MarketItem',
                data: data,
                sorters: [
                    {
                        //     
                        sorterFn: function(o1, o2) {
                            if (o1.data.create_date < o2.data.create_date) {
                                return -1;
                            } else if (o1.data.create_date > o2.data.create_date) {
                                return 1;
                            } else {
                                return 0;
                            }
                        }
                    }
                ]
            });
        } else {
            me.store.loadRawData(data);
        }
    },
    //       
    onServiceUpdate: function() {
        var me = this;
        me.initStore();
    },
    initFilters: function() {
        var me = this;
        me.filters = {
            //   
            'expired': function(item) {
                var dt = ExGods.util.Date.normalizeServerDateTime(item.data.create_date);
                return Ext.Date.add(dt, Ext.Date.HOUR, me.service.data.ttl) > new Date();
            }
        };
    },
    // me.applyFilters();
    //       
    onServiceUpdate: function() {
        var me = this;
        me.initStore();
    },
    setTextFilter: function(value) {
        var me = this;
        value = Ext.String.trim(value);
        if (value) {
            me.filters['text'] = new Ext.util.Filter({
                filterFn: function(item) {
                    var itemTitle = item.data.title;
                    return itemTitle.toLowerCase().indexOf(value.toLowerCase()) == -1 ? false : true;
                }
            });
        } else {
            delete me.filters['text'];
        }
    },
    setLevelFilter: function(value) {
        var me = this;
        if (value && value != 0) {
            me.filters['level'] = new Ext.util.Filter({
                filterFn: function(item) {
                    return item.data.level == value;
                }
            });
        } else {
            delete me.filters['level'];
        }
    },
    setTypeFilter: function(value) {
        var me = this;
        if (value && value != 'all') {
            me.filters['type'] = new Ext.util.Filter({
                filterFn: function(item) {
                    if (/^item/.test(value)) {
                        var parts = value.split('_');
                        // item_1 or item_2 or ..   -  
                        return item.data.type == 'item' && item.data.grade == parts[1];
                    } else {
                        return item.data.type == value;
                    }
                }
            });
        } else {
            delete me.filters['type'];
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            data;
        data = me.getMarketItem(me);
        for (var i = 0; i < data.length; i++) {
            itm = data[i];
            if (itm.image) {
                arr_images.push(itm.image);
            }
            if (itm.stuff) {
                stuff_arr.push(itm.stuff);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 * 
 */
Ext.define('ExGods.view.market.Market', {
    extend: Ext.container.Container,
    alias: 'widget.market',
    /**
     * @cfg clientObject {Object}     -
     */
    clientObject: {},
    /**
     * @cfg service {ExGods.service.Market}  
     */
    service: null,
    initComponent: function() {
        var me = this;
        me.itemsView = Ext.widget('marketitems', {
            tabConfig: {
                icon: IMAGE_URL + me.clientObject.items_tab_img,
                tooltip: me.clientObject.items_tab_tip
            },
            service: me.service,
            clientObject: me.clientObject,
            listeners: {
                activate: me.onViewActivate,
                scope: me
            }
        });
        me.myItemsView = Ext.widget('marketmyitems', {
            tabConfig: {
                icon: IMAGE_URL + me.clientObject.my_items_tab_img,
                tooltip: me.clientObject.my_items_tab_tip
            },
            service: me.service,
            clientObject: me.clientObject,
            listeners: {
                activate: me.onViewActivate,
                scope: me
            }
        });
        me.items = [
            {
                xtype: 'room',
                backgroundImage: me.clientObject.back_img,
                emptySearchText: me.clientObject.search_placeholder_text,
                closeText: me.clientObject.close_btn_text,
                closeColor: me.clientObject.close_btn_color,
                closeCallback: function() {
                    me.fireEvent('close');
                },
                rightPanelX: 250,
                items: [
                    {
                        xtype: 'skintabpanel',
                        activeTab: 0,
                        x: 242,
                        y: 10,
                        width: 580,
                        height: 363,
                        closable: true,
                        plugins: [
                            'skindeco'
                        ],
                        padding: '0 0 0 0',
                        defaults: {
                            padding: '0 0 0 10'
                        },
                        items: [
                            me.itemsView,
                            me.myItemsView
                        ],
                        listeners: {
                            beforeclose: {
                                fn: function() {
                                    me.fireEvent('close');
                                    return false;
                                }
                            }
                        }
                    },
                    {
                        xtype: 'panel',
                        x: 357,
                        y: 20,
                        width: 433,
                        height: 30,
                        itemId: 'filters',
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        style: {
                            'z-index': 1
                        },
                        items: [
                            me.initAvailCheckbox(),
                            me.initLevelFilter(),
                            me.initTypeFilter(),
                            me.initSearchField()
                        ]
                    }
                ],
                buttons: [
                    {
                        text: me.clientObject.refresh_btn_text,
                        handler: function() {
                            me.fireEvent('reload', me);
                        },
                        hidden: true
                    }
                ]
            }
        ] , me.callParent(arguments);
    },
    /************** PRIVATES *****************/
    initAvailCheckbox: function() {
        var me = this;
        me.availCheckbox = Ext.widget('checkbox', {
            boxLabel: me.clientObject.avail_checkbox_text,
            checked: true,
            style: {
                color: '#e3ac69'
            },
            listeners: {
                change: function() {
                    me.updateFilters('avail', me.availCheckbox.getValue());
                }
            },
            margin: '0 8 0 0'
        });
        return me.availCheckbox;
    },
    initLevelFilter: function() {
        var me = this,
            data = [];
        //    " "
        data.push([
            0,
            me.clientObject.level_filter_all_text
        ]);
        //     
        ExGods.ref('user_level').each(function(item) {
            data.push([
                item.level,
                Ext.String.format(me.clientObject.level_filter_level_text, item.level)
            ]);
        });
        me.levelFilter = Ext.widget('parchmentcombo', {
            store: Ext.create('Ext.data.ArrayStore', {
                fields: [
                    {
                        name: 'value',
                        mapping: 0,
                        type: 'int'
                    },
                    {
                        name: 'label',
                        mapping: 1
                    }
                ],
                data: data
            }),
            displayField: 'label',
            valueField: 'value',
            queryMode: 'local',
            triggerAction: 'all',
            editable: false,
            value: 0,
            width: 110,
            margin: '3 8 0 0',
            listeners: {
                change: function() {
                    me.updateFilters('level', me.levelFilter.getValue());
                }
            }
        });
        return me.levelFilter;
    },
    initTypeFilter: function() {
        var me = this,
            data = [];
        //    " "
        data.push([
            'all',
            me.clientObject.types_filter_all_text
        ]);
        //       
        data.push([
            'fucina',
            me.clientObject.types_filter_fucina_text
        ]);
        data.push([
            'home',
            me.clientObject.types_filter_home_text
        ]);
        //     
        data.push([
            'item_1',
            me.clientObject.types_filter_grade1_text
        ]);
        data.push([
            'item_2',
            me.clientObject.types_filter_grade2_text
        ]);
        data.push([
            'item_3',
            me.clientObject.types_filter_grade3_text
        ]);
        data.push([
            'item_4',
            me.clientObject.types_filter_grade4_text
        ]);
        me.typeFilter = Ext.widget('parchmentcombo', {
            autoShow: false,
            xtype: 'combobox',
            store: Ext.create('Ext.data.ArrayStore', {
                fields: [
                    {
                        name: 'value',
                        mapping: 0
                    },
                    {
                        name: 'label',
                        mapping: 1
                    }
                ],
                data: data
            }),
            displayField: 'label',
            valueField: 'value',
            queryMode: 'local',
            triggerAction: 'all',
            editable: false,
            value: 'all',
            width: 110,
            margin: '3 0 0 0',
            listeners: {
                change: function() {
                    me.updateFilters('type', me.typeFilter.getValue());
                    setTimeout(function() {
                        me.searchField.focus();
                    }, 0);
                }
            }
        });
        //     ,    text-overflow
        ExGods.Resources.load(me.typeFilter, function() {
            me.typeFilter.show();
        });
        return me.typeFilter;
    },
    initSearchField: function() {
        var me = this;
        me.searchField = Ext.widget('textfield', {
            emptyText: me.clientObject.search_placeholder_text,
            itemId: 'title',
            width: 100,
            cls: 'text-search-input',
            listeners: {
                change: {
                    fn: function() {
                        me.updateFilters('text', me.searchField.getValue());
                    },
                    buffer: 100
                },
                scope: me
            },
            padding: 1,
            value: ''
        });
        return me.searchField;
    },
    updateFilters: function(type, value) {
        var me = this,
            view = me.itemsView.isVisible() ? me.itemsView : me.myItemsView;
        view.setFilter(type, value);
        if (type == 'text') {
            //      ,  
            //          ,    
            if (Ext.String.trim(value)) {
                view.setFilter('avail', false);
                view.setFilter('level', 0);
                view.setFilter('type', 'all');
            } else {
                view.setFilter('avail', me.availCheckbox.getValue());
                view.setFilter('level', me.levelFilter.getValue());
                view.setFilter('type', me.typeFilter.getValue());
            }
        }
        view.applyFilters();
    },
    /**
     *   
     */
    onViewActivate: function(view) {
        var me = this;
        // /  
        if (view == me.itemsView) {
            me.availCheckbox.show();
        } else {
            me.availCheckbox.hide();
        }
        //       
        me.suspendEvents();
        me.availCheckbox.setValue(true);
        me.levelFilter.setValue(0);
        me.typeFilter.setValue('all');
        me.searchField.setValue('');
        me.resumeEvents();
        //   
        view.setFilter('avail', true);
        view.setFilter('level', 0);
        view.setFilter('type', 'all');
        view.setFilter('text', '');
        view.applyFilters();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + me.clientObject.my_items_tab_img,
                IMAGE_URL + me.clientObject.back_img,
                IMAGE_URL + me.clientObject.items_tab_img,
                me.clientObject.close_btn_text
            ]
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Market', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Market:'
    },
    views: [
        'market.Market'
    ],
    models: [
        'MarketItem'
    ],
    init: function() {
        var me = this;
        me.listen({
            component: {
                'textbutton[action="market-buy"]': {
                    click: me.onBuyBtnClick
                },
                'textbutton[action="market-cancel"]': {
                    click: me.onCancelBtnClick
                },
                'marketitems dataview': {
                    itemclick: me.onMarketItemClick
                },
                'marketmyitems dataview': {
                    itemclick: me.onMarketItemClick
                }
            }
        });
        ExGods.Components.addComponentInitializer('market', me.initMarketComponent, me);
        ExGods.util.Timers.on('market-my-items-timer-expire', me.onMyItemsTimerExpire, me);
    },
    /**
     * ,     
     * @param stuff {Mixed}  .    -      
     */
    isCanSellStuff: function(stuff) {
        var me = this;
        return this.getMarketItemInfo(stuff) ? true : false;
    },
    /**
     * ,     
     * @param item {Object}  
     */
    isCanSellItem: function(item) {
        var me = this;
        return this.isCanSellStuff({
            type: 'item',
            params: {
                id: item.proto_id
            }
        });
    },
    /**
     *       .
     * @param stuff {Mixed}  .    -      
     */
    getMarketItemInfo: function(stuff) {
        var me = this,
            result;
        stuff = Ext.isArray(stuff) ? stuff[0] : stuff;
        ExGods.ref('market').each(function(entry, item) {
            if (stuff.type == item.stuff.type && stuff.params.id == item.stuff.params.id) {
                result = item;
            }
        });
        return result;
    },
    /**
     *      
     * @param stuff {Mixed} 
     * @param source {String}  ("inventory"  "source")
     */
    putStuffToMarket: function(stuff, source) {
        var me = this,
            marketItemInfo = me.getMarketItemInfo(stuff),
            getPriceInfo = function(entry, callback) {
                me.request({
                    url: 'map.pl?cmd=market_get_info&entry=' + marketItemInfo.entry,
                    success: function(resp) {
                        if (resp.success) {
                            callback(resp.info);
                        }
                    }
                });
            },
            showPutOnDialog = function(stuff, priceInfo, callback) {
                //     (, , etc)
                var image, title, proto;
                if (stuff.type == 'item') {
                    proto = ExGods.app.getItemPrototypesStore().data.getByKey(stuff.params.id);
                    if (proto) {
                        image = proto.data.images.on;
                        title = proto.data.title;
                    }
                } else if (stuff.type == 'ingredients') {
                    proto = ExGods.ref('ingredients|' + stuff.params.id);
                    if (proto) {
                        image = IMAGE_URL + proto.params.images.img_1;
                        title = proto.label;
                    }
                }
                var cmp = Ext.widget('progressdialog', {
                        title: title,
                        image: image,
                        autoShow: false,
                        label: Ext.String.format(ExGods.getMsgByKey('put_on_market_input_label'), '<img src="' + ExGods.ref('user_money|' + marketItemInfo.price.name).image + '">'),
                        min: priceInfo.min_price,
                        max: priceInfo.max_price,
                        value: Math.ceil(priceInfo.min_price + (priceInfo.max_price - priceInfo.min_price) / 2),
                        inputWidth: 75,
                        handler: callback,
                        buttonsText: [
                            ExGods.getMsgByKey('put_on_market_confirm_yes'),
                            ExGods.getMsgByKey('put_on_market_confirm_no')
                        ],
                        value_dependent_text: [
                            Ext.String.format(ExGods.getMsgByKey('put_on_market_comission_text'), '{[this.printComission(values)]}'),
                            {
                                printComission: function(values) {
                                    return ExGods.util.Format.printMoney({
                                        name: marketItemInfo.price.name,
                                        value: Math.round(values.value * priceInfo.comission / 100)
                                    });
                                }
                            }
                        ]
                    });
                ExGods.Resources.load(cmp, function() {
                    cmp.show();
                });
            };
        if (marketItemInfo) {
            me.app.block();
            getPriceInfo(marketItemInfo.entry, function(priceInfo) {
                me.app.unblock();
                showPutOnDialog(stuff, priceInfo, function(price) {
                    me.app.block();
                    if (source == 'inventory') {
                        ExGods.Services.get('inventory').command('put_from_inventory_market', {
                            entry: marketItemInfo.entry,
                            price: price
                        }, function(resp) {
                            me.app.unblock();
                            if (Ext.getCmp('MARKET')) {
                                me.service.update();
                            }
                        });
                    }
                    //   ,    
                    else if (source == 'store') {
                        ExGods.Services.get('inventory').command('put_from_store_market', {
                            entry: stuff.entry,
                            price: price,
                            index: 1
                        }, function(resp) {
                            me.app.unblock();
                            if (Ext.getCmp('MARKET')) {
                                me.service.update();
                            }
                        });
                    }
                });
            });
        }
    },
    //   ,      
    /**
     *      
     * @param stuff {Mixed} 
     */
    putInventoryStuffToMarket: function(stuff) {
        return this.putStuffToMarket(stuff, 'inventory');
    },
    /**
     *       
     * @param stuff {Mixed} 
     */
    putStoreStuffToMarket: function(stuff) {
        return this.putStuffToMarket(stuff, 'store');
    },
    /**
     *   "market"
     */
    initMarketComponent: function(config) {
        var me = this,
            wnd,
            loadProtosInner = function(callback) {
                var stuff = [];
                ExGods.ref('market').each(function(entry, item) {
                    stuff.push(item.stuff);
                });
                ExGods.helpme.loadProtosFromStuff(stuff, callback);
            };
        if (Ext.getCmp('MARKET')) {
            return;
        }
        me.service = config.service;
        wnd = Ext.widget('window1', {
            id: 'MARKET',
            autoShow: false,
            items: []
        });
        me.getController('Location').maskLocation(function() {
            //   ,   
            loadProtosInner(function() {
                //       
                wnd.add({
                    xtype: 'market',
                    service: config.service,
                    clientObject: config,
                    listeners: {
                        reload: function() {
                            me.onMarketReloadClick();
                        },
                        close: {
                            fn: function() {
                                ExGods.loaderCt.loadAndRemove(function() {
                                    wnd.close();
                                }, {
                                    img: config.back_img
                                });
                                return false;
                            },
                            single: true
                        }
                    }
                });
                //  
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    me.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.back_img
        });
        return wnd;
    },
    /**
     *     ""
     */
    onBuyBtnClick: function(btn) {
        var me = this,
            afterBuyInner = function(resp) {
                if (resp.success == 1) {
                    //   
                    me.service.update(null, function() {
                        me.app.unblock();
                    });
                } else if (resp.not_min_price) {
                    //         -           ,   
                    me.service.update(null, function() {
                        me.app.unblock();
                        if (me.service.data.market && me.service.data.market[btn.entry] && me.service.data.market[btn.entry].price.length) {
                            var minPrice = {
                                    value: undefined,
                                    type: ''
                                };
                            me.service.data.market[btn.entry].price.forEach(function(price) {
                                if (minPrice.value == undefined) {
                                    minPrice = price;
                                } else if (parseInt(price.value) < parseInt(minPrice.value)) {
                                    minPrice = price;
                                }
                            });
                            Ext.widget('confirmdialog', {
                                title: '',
                                message: Ext.String.format(btn.confirm2_tpl, ExGods.util.Format.printMoney(minPrice)),
                                handler: function() {
                                    me.doBuyItem(btn.entry, minPrice.value, afterBuyInner);
                                }
                            });
                        }
                    });
                } else {
                    me.app.unblock();
                }
            };
        if (btn.confirm) {
            Ext.widget('confirmdialog', {
                title: '',
                message: btn.confirm,
                handler: function() {
                    me.doBuyItem(btn.entry, btn.price, afterBuyInner);
                }
            });
        } else {
            me.doBuyItem(btn.entry, btn.price, afterBuyInner);
        }
    },
    /**
     *     ""
     */
    onCancelBtnClick: function(btn) {
        var me = this;
        if (btn.confirm) {
            Ext.widget('confirmdialog', {
                title: '',
                message: btn.confirm,
                handler: function() {
                    me.doCancelItem(btn.entry);
                }
            });
        } else {
            me.doCancelItem(btn.entry);
        }
    },
    /**
     *  
     */
    doBuyItem: function(entry, price, callback) {
        var me = this;
        me.app.block();
        me.service.command('market_buy_product', {
            entry: entry,
            price: price
        }, function(resp) {
            if (callback) {
                callback(resp);
            }
        });
    },
    /**
     *     
     */
    doCancelItem: function(entry) {
        var me = this;
        me.app.block();
        me.service.command('product_from_market', {
            entry: entry
        }, function(resp) {
            if (resp.success) {
                me.service.update(null, function() {
                    me.app.unblock();
                });
            } else //   
            {
                me.app.unblock();
            }
        });
    },
    /**
     *      
     */
    onMarketItemClick: function(view, item, itemEl, f, e) {
        var me = this;
        if (e.getTarget('.x-btn') || e.getTarget('.exg-stuff-imaged')) {
            return true;
        }
        Ext.get(itemEl).down('.exg-stuff-imaged').dom.click();
    },
    /**
     *   .
     *        .
     */
    onMarketReloadClick: function() {
        var me = this;
        if (me.reloadTime) {
            if (new Date() - me.reloadTime <= me.service.data.ttl_refresh_button * 1000) {
                return;
            }
        }
        //       
        me.reloadTime = new Date();
        me.service.update();
    },
    /**
     *      " "
     */
    onMyItemsTimerExpire: function(el) {
        var me = this;
        Ext.get(el).setHTML('...');
        //   
        me.service.update(null);
    }
});

/**
 *      .        
 */
Ext.define('ExGods.view.mask.stuff.UpgradeStuff', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        me.replaceQuantityDecorator(data.decorators);
        return data;
    },
    /**
     *    -
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.mask.stuff.decorator.UpgradeQuantity);
    }
});

/**
 *    
 */
Ext.define('ExGods.view.mask.stuff.decorator.UpgradeQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getCls: function(data) {
            var userQuantity = this.getUserQuantityOfStuff(data),
                requiredQuantity = data.stuff.params.quantity || 0;
            if (!data.resultInfo && requiredQuantity > userQuantity) {
                return 'upgrade-stuff-decorator-quantity-red';
            } else {
                return 'upgrade-stuff-decorator-quantity-green';
            }
        },
        /**
         * @override
         */
        getQuantity: function(data) {
            var userQuantity, requiredQuantity;
            userQuantity = this.getUserQuantityOfStuff(data);
            requiredQuantity = data.stuff.params.quantity || 0;
            if (data.stuff.type == 'currency') {
                return requiredQuantity;
            } else {
                return userQuantity + '/' + requiredQuantity;
            }
        },
        /**
         *   -           
         */
        getUserQuantityOfStuff: function(data) {
            var userQuantity = 0;
            if (data.stuff.type == 'currency') {
                userQuantity = ExGods.app.user.get('money')[data.stuff.params.id];
            } else if (data.stuff.type == 'item') {
                userQuantity = ExGods.app.user.slots().getItemCount(data.stuff.params.id);
            } else if (data.stuff.type == 'ingredients') {
                userQuantity = ExGods.app.user.getIngredientCountByName(data.stuff.params.id);
            }
            return userQuantity;
        }
    }
});

/**
 *     
 */
Ext.define('ExGods.model.Mask', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'enabled',
            type: 'int'
        },
        {
            name: 'g_order',
            type: 'int'
        },
        {
            name: 'group',
            type: 'auto'
        },
        {
            name: 'groupDur',
            type: 'int'
        },
        {
            name: 'has',
            type: 'auto'
        },
        {
            name: 'id',
            type: 'auto'
        },
        {
            name: 'slot_on',
            type: 'auto'
        },
        {
            name: 'message',
            type: 'string'
        },
        {
            name: 'item',
            type: 'auto',
            convert: function(v, r) {
                r.calcGroupDur(v);
                return ExGods.app.getItemPrototypesStore().data.getByKey(v).data;
            }
        },
        {
            name: 'item_price',
            type: 'auto'
        },
        {
            name: 'next_upgrade_price',
            type: 'auto'
        },
        {
            name: 'discount_ended',
            type: 'auto'
        },
        {
            name: 'params',
            type: 'auto'
        },
        {
            name: 'l_order',
            type: 'auto'
        },
        {
            name: 'battle_turns',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'auto'
        },
        {
            name: 'achievements',
            type: 'auto'
        },
        {
            name: 'next_enabled',
            type: 'int'
        },
        {
            name: 'next_message',
            type: 'string'
        },
        {
            name: 'current_upgrade',
            type: 'auto'
        },
        {
            name: 'next_battle_turns',
            type: 'auto'
        },
        {
            name: 'next_upgrade',
            type: 'auto'
        },
        {
            name: 'type',
            type: 'string'
        }
    ],
    calcGroupDur: function(item_id) {
        var me = this,
            durability = 0;
        item_id = item_id || me.get('item').entry;
        ExGods.app.user.slots().each(function(slot) {
            slot.get('items').each(function(item) {
                if (item.get('proto_id') == item_id && item.get('groupdur')) {
                    durability += item.get('groupdur');
                }
            });
        });
        me.set('groupDur', durability);
    }
});

/**
 *   
 */
Ext.define('ExGods.view.mask.UpgradeWindow', {
    extend: Ext.panel.Panel,
    alias: 'widget.upgrademask',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    margin: '10 14 0',
    initComponent: function() {
        var me = this,
            maskGrade;
        if (me.currentFitMask.item) {
            maskGrade = me.currentFitMask.item.data.item_grade;
        }
        me.items = [
            {
                xtype: 'upgradeavatar',
                mask: me.currentFitMask.current_upgrade || Ext.apply({
                    label: me.currentFitMask.label
                }, me.currentFitMask.params),
                maskGrade: maskGrade || 0,
                localUserData: me.localUser.data
            },
            {
                xtype: 'upgradeprogress',
                mask: me.currentFitMask
            },
            {
                xtype: 'upgradeavatar',
                mask: me.currentFitMask.next_upgrade,
                maskGrade: (maskGrade || 0) + 1,
                compareMask: me.currentFitMask,
                localUserData: me.upgradeFitData,
                compareUserData: me.localUser.data
            }
        ];
        me.callParent();
    }
});

/**
 *     
 */
Ext.define('ExGods.view.mask.MaskStats', {
    extend: Ext.panel.Panel,
    alias: 'widget.maskstats',
    id: 'user-mask-stats',
    cls: 'user-mask-stats',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    width: 218,
    height: 370,
    plugins: [
        'extraparchmentdeco'
    ],
    mass_data: {},
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    /**
     * @cfg {ExGods.model.Mask} mask (required)
     * 
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            mask = me.mask;
        me.items = [
            {
                xtype: 'component',
                data: me.prepareData(user.data.stats, mask),
                flex: 1,
                tpl: [
                    '<tpl if="values.name_black">' + '<h6 class="mask_title ellipsis" style="color: black; background: none;">{name_black}</h6>',
                    '<div class="ellipsis" style="text-align: center; font-weight: bold; margin: 0 8px; padding-bottom: 2px;">{groupName}</div>',
                    '<tpl else>' + '<h6 class="mask_title ellipsis">{name}</h6>',
                    '<div class="ellipsis" style="text-align: center; font-weight: bold; margin: 0 8px; padding-bottom: 2px; background: rgba(113, 172, 25, 0.33);">{groupName}</div>',
                    '</tpl>' + '<tpl if="this.checkWindow()">',
                    '<div class="user_stats_image">' + '{user_stats_image}' + '</div>' + '</tpl>',
                    '<div class="parchment-separator"></div>',
                    '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
                    '<div class="stats-list">' + '{user_stat}' + '</div>' + '<div class="parchment-separator"></div>' + '<div class="paper-title">' + ExGods.getMsgByKey('view_mask_stats_battleactions') + '</div>',
                    '<div class="stats-list like_table even">' + '<div class="align_middle">' + '<tpl if="actions.length">',
                    '<tpl for="actions">',
                    '<tpl if="xindex < 4">',
                    '<div class="action {[ parent.actions.length == 1 ? "single" : ""]}" data-id="{id}" data-type="{type}" data-qtip="{title}">',
                    '<div class="notify_i"></div>',
                    '<img height="52" width="52" src="{img}">',
                    '<strong>{title}</strong>',
                    '</div>',
                    '</tpl>',
                    '</tpl>',
                    '<tpl else>',
                    '{description}',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    '<div class="parchment-separator"></div>',
                    '<div class="paper-title">' + ExGods.getMsgByKey('view_mask_stats_conds') + '</div>',
                    '<div class="stats-list description2 like_table ">' + '<div class="align_middle">{description2}</div>' + '</div>',
                    {
                        hasDur: function(dur) {
                            return dur > 0;
                        },
                        checkWindow: function() {
                            return me.id == 'user-mask-stats-window';
                        }
                    }
                ]
            }
        ];
        this.dockedItems = [
            {
                xtype: 'panel',
                dock: 'bottom',
                margin: '0 0 30 0',
                style: {
                    textAlign: 'center',
                    overflow: 'visible'
                },
                items: [
                    {
                        xtype: 'panel',
                        html: '',
                        height: 15,
                        style: {
                            'margin-bottom': '3px'
                        }
                    },
                    {
                        xtype: 'textbutton',
                        text: mask && mask.item_price['new'] ? mask.item_price.discount ? ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_salebtntext'), {
                            price: ExGods.util.Format.printMoney(mask.item_price['old']),
                            discount_price: ExGods.util.Format.printMoney(mask.item_price['new'])
                        }) : ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_nosalebtntext'), {
                            price: ExGods.util.Format.printMoney(mask.item_price['new'])
                        }) : '',
                        action: 'buy-mask',
                        cls: 'qh-object no_border_double double_text ' + (mask.item_price.discount ? 'x-btn-txt-green' : ''),
                        //disabled: true,
                        width: 160,
                        margin: '0'
                    }
                ]
            }
        ];
        //id: 'put-mask'
        me.callParent();
        me.on('afterrender', function() {
            me.controlDetailedWindow();
            var button = this.dockedItems.last().items.items[1];
            var text = this.dockedItems.last().items.items[0];
            if (!mask.params.is_buyable || !mask.item_price['new'] || !mask.item_price['new'][0].value || mask.has) {
                button.hide();
                text.hide();
            } else {
                if (mask.item_price.discount == 0) {
                    text.hide();
                } else {
                    me.startDiscountTimer(mask);
                    text.show();
                    if (me.id == 'user-mask-stats')  {
                        me.dockedItems.last().el.setStyle('top', '293px');
                    }
                    else  {
                        me.dockedItems.last().el.setStyle('top', '340px');
                    }
                    
                }
            }
        });
        me.on('afterlayout', function() {
            var text = this.dockedItems.last().items.items[0];
            if (text.isVisible()) {
                if (me.id == 'user-mask-stats')  {
                    me.dockedItems.last().el.setStyle('top', '293px');
                }
                else  {
                    me.dockedItems.last().el.setStyle('top', '340px');
                }
                
            }
        });
        me.on('destroy', function() {
            clearInterval(me.discountwait);
            delete me.discountwait;
        });
    },
    controlDetailedWindow: function() {
        var me = this;
        this.getEl().on('click', function(e, el) {
            var id = el.getAttribute('data-id'),
                type = el.getAttribute('data-type'),
                info = ExGods.ref(type + '|' + id),
                maskData = me.mask.data ? me.mask.data : me.mask;
            if (info) {
                if (type == 'battle_turn' && maskData.battle_turns) {
                    //        
                    Ext.Array.each(maskData.battle_turns, function(item) {
                        if (item.name == id) {
                            info.cost = ExGods.util.Stuff.printStuff(item.cost);
                        }
                    });
                }
                if (type == 'battle_turn') {
                    info.turn_type = ExGods.getMsgByKey('masks_turn_type_name');
                } else if (type == 'battle_prep') {
                    info.turn_type = ExGods.getMsgByKey('masks_prep_type_name');
                } else if (type == 'battle_actions') {
                    info.turn_type = ExGods.getMsgByKey('masks_action_type_name');
                }
                Ext.widget('commondetailswindow', {
                    itemElement: el,
                    data: {
                        label: info.label,
                        image: IMAGE_URL + (info.desc.images ? info.desc.images['active'] : info.desc.img),
                        rows: [
                            {
                                content: info.turn_type
                            },
                            {
                                content: info.cost ? '<div style="clear:both">' + ExGods.getMsgByKey('view_battle_prepactions_pricewordintt') + ' <span style="float:right; font-weight: bold;">' + info.cost + '</span></div>' : ''
                            },
                            {
                                content: info.desc.desc || info.desc.description
                            }
                        ]
                    }
                });
            }
        }, me, {
            delegate: '.action'
        });
    },
    startDiscountTimer: function(mask) {
        var me = this;
        var text = me.dockedItems.last().items.items[0];
        var restTime = (ExGods.util.Date.normalizeServerDateTime(mask.discount_ended) - new Date()) / 1000 + 1;
        if (text.getEl())  {
            text.getEl().setHTML(ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_saletpl'), {
                discount: mask.item_price.discount,
                time: ExGods.util.Time.printTime(restTime, {
                    format: 'twonums'
                })
            }));
        }
        
        clearInterval(me.discountwait);
        delete me.discountwait;
        me.discountwait = setInterval(function() {
            var currTime = (ExGods.util.Date.normalizeServerDateTime(mask.discount_ended) - new Date()) / 1000 + 1;
            if (currTime < 1) {
                clearInterval(me.discountwait);
                delete me.discountwait;
                if (me.id == 'user-mask-stats')  {
                    // 1 .         
                    ExGods.app.getController('Masks').reloadMaskService();
                }
                
                var button = me.dockedItems.last().items.items[1];
                button.removeCls('x-btn-txt-green');
                button.setText(Ext.String.format(ExGods.getMsgByKey('view_masks_buy_btn_text'), ExGods.util.Format.printMoney(mask.item_price['old'])));
                text.getEl().setHTML(ExGods.getMsgByKey('view_masks_stats_nosale'));
                if (me.id == 'user-mask-stats')  {
                    me.dockedItems.last().el.setStyle('top', '293px');
                }
                else  {
                    me.dockedItems.last().el.setStyle('top', '340px');
                }
                
            } else {
                text.getEl().setHTML(ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_saletpl'), {
                    discount: mask.item_price.discount,
                    time: ExGods.util.Time.printTime(currTime, {
                        format: 'twonums'
                    })
                }));
            }
        }, 1000);
    },
    updateUserStats: function(user, mask) {
        var me = this;
        me.mask = mask;
        this.show();
        //    /     
        var button = this.dockedItems.last().items.items[1];
        var text = this.dockedItems.last().items.items[0];
        this.dockedItems.last().el.setStyle('top', '306px');
        if (mask.data.has) {
            button.hide();
            text.hide();
        } else {
            if (mask.data.params.is_buyable && mask.data.item_price['new'] && mask.data.item_price['new'][0].value) {
                button.action = "buy-mask";
                button.removeCls('x-btn-txt-green');
                button.show();
                if (mask.data.item_price.discount) {
                    button.addCls('x-btn-txt-green');
                    button.setText(ExGods.app.applyTpl(ExGods.getMsgByKey('view_mask_stats_salebtntext'), {
                        price: ExGods.util.Format.printMoney(mask.data.item_price['old']),
                        discount_price: ExGods.util.Format.printMoney(mask.data.item_price['new'])
                    }));
                    this.startDiscountTimer(mask.data);
                    text.show();
                    if (this.id == 'user-mask-stats')  {
                        this.dockedItems.last().el.setStyle('top', '293px');
                    }
                    else  {
                        this.dockedItems.last().el.setStyle('top', '340px');
                    }
                    
                } else {
                    button.setText(Ext.String.format(ExGods.getMsgByKey('view_masks_buy_btn_text'), ExGods.util.Format.printMoney(mask.data.item_price['new'])));
                    text.hide();
                }
            } else {
                button.hide();
                text.hide();
            }
        }
        var data = this.prepareData(user, mask.data);
        this.items.first().update(data);
    },
    /**
     *         
     *
     * @param {Object} data   {ExGods.model.User}
     * @return {Object}
     */
    prepareData: function(user, mask) {
        if (!mask) {
            this.hide();
            return;
        }
        var me = this,
            preparedData = {
                name: [],
                user_stat: [],
                description: [],
                user_stats_image: [],
                groupDur: [],
                dur: [],
                description2: [],
                actions: []
            },
            params = mask.current_upgrade || mask.params;
        if (mask.item.data) {
            var label = mask.current_upgrade ? mask.current_upgrade.label : (mask.label || mask.item.title);
            preparedData[mask.has ? 'name' : 'name_black'] = label;
            preparedData.description = params.description1;
            preparedData.groupDur = mask.groupDur;
            preparedData.dur = mask.item.param.dur * mask.has;
            preparedData.nonbr = mask.item.param.nonbr;
            preparedData.groupName = mask.group;
            preparedData.mask_id = mask.id;
            if (params.battle_instants && params.battle_instants.length) {
                Ext.Array.each(params.battle_instants, function(item) {
                    var id = item.name,
                        info = ExGods.ref('battle_prep|' + id);
                    preparedData.actions.push({
                        id: id,
                        type: 'battle_prep',
                        title: info.label,
                        img: IMAGE_URL + info.desc.images['active'],
                        desc: info.desc.desc
                    });
                });
            }
            if (params.battle_turns && params.battle_turns.length) {
                Ext.Array.each(params.battle_turns, function(item) {
                    var id = item.name,
                        info = ExGods.ref('battle_turn|' + id);
                    preparedData.actions.push({
                        id: id,
                        type: 'battle_turn',
                        title: info.label,
                        img: IMAGE_URL + info.desc.images['active'],
                        desc: info.desc.desc
                    });
                });
            }
            if (params.battle_actions && params.battle_actions.length) {
                Ext.Array.each(params.battle_actions, function(item) {
                    var id = item.id,
                        info = ExGods.ref('battle_actions|' + id);
                    preparedData.actions.push({
                        id: id,
                        type: 'battle_actions',
                        title: info.label,
                        img: IMAGE_URL + info.desc.img,
                        desc: info.desc.description
                    });
                });
            }
            //    : ", , "
            preparedData.actions = Ext.Array.sort(preparedData.actions, function(a, b) {
                if (a.type == b.type) {
                    return 0;
                } else if (a.type == 'battle_turn') {
                    return -1;
                } else if (a.type == 'battle_actions') {
                    return 1;
                } else if (b.type == 'battle_turn') {
                    return 1;
                } else {
                    return -1;
                }
            });
            if (params.is_buyable && mask.item_price['new'] && mask.item_price['new'][0].value && !mask.has)  {
                preparedData.description2 = '';
            }
            else {
                if (mask.achievements.length) {
                    Ext.Array.each(mask.achievements, function(ach1) {
                        if (ach1) {
                            if (ach1.value && !ach1.datefinish) {
                                var stage_max;
                                Ext.Array.each(ach1.stages, function(stage) {
                                    if (ach1.value < stage.value && !stage_max)  {
                                        stage_max = stage.value;
                                    }
                                    
                                });
                            }
                            preparedData.description2 += '<img style="margin: 2px 4px -4px -4px;" src="' + IMAGE_URL + 'icons/' + ((ach1.datefinish || (ach1.value && !stage_max)) ? '' : 'un') + 'done.png" />';
                            preparedData.description2 += ach1.description;
                            if (stage_max)  {
                                preparedData.description2 += ' (' + ach1.value + '/' + stage_max + ')';
                            }
                            
                            preparedData.description2 += '<br/>';
                        }
                    });
                } else {
                    preparedData.description2 = '<img style="margin: 2px 4px -4px -4px;" src="' + IMAGE_URL + 'icons/' + (mask.has ? 'done.png' : 'undone.png') + '" />' + params.description2;
                }
            }
            me.show();
        } else {
            me.hide();
        }
        var preparedChanges = {};
        Ext.each(config.references.user_stat, function(item) {
            if (item.visible == 1 && !item.param.fill) {
                var curStat = user.stats[item.name],
                    wasStat = ExGods.app.user.data.stats.stats[item.name],
                    changes = parseInt(curStat) - parseInt(wasStat),
                    className = '';
                preparedChanges[item.name] = changes;
            }
        });
        preparedData.user_stat = ExGods.util.User.printUserStats(user.stats, {
            visibleValue: 1,
            changes: preparedChanges,
            align: 'right'
        });
        preparedData.user_stats_image = ExGods.util.User.printUserStats(user.stats, {
            visibleValue: 2
        });
        return preparedData;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            maskData, params;
        mask_data = me.mask.data ? me.mask.data : me.mask;
        params = mask_data.current_upgrade || mask_data.params;
        Ext.Array.each(params.battle_instants, function(item) {
            var id = item.name,
                info = ExGods.ref('battle_prep|' + id);
            for (var it in info.desc.images) {
                arr_images.push(info.desc.images[it]);
            }
        });
        Ext.Array.each(params.battle_turns, function(item) {
            var id = item.name,
                info = ExGods.ref('battle_turn|' + id);
            for (var it in info.desc.images) {
                arr_images.push(info.desc.images[it]);
            }
        });
        Ext.Array.each(params.battle_actions, function(item) {
            var id = item.id,
                info = ExGods.ref('battle_actions|' + id);
            arr_images.push(info.desc.img);
        });
        Ext.Array.each(mask_data.battle_turns, function(item) {
            if (item.cost) {
                stuff_arr.push(item.cost);
            }
        });
        return {
            stuff: stuff_arr,
            images: [].concat(arr_images)
        };
    }
});

/**
 *     
 */
Ext.define('ExGods.view.mask.MaskStatsStars', {
    extend: Ext.panel.Panel,
    alias: 'widget.maskstats_onlystars',
    id: 'user-mask-stats-stars',
    cls: 'user-mask-stats-stars',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    width: 235,
    height: 65,
    style: {
        'z-index': 5
    },
    mass_data: {},
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    /**
     * @cfg {ExGods.model.Mask} mask (required)
     * 
     */
    initComponent: function() {
        var me = this,
            user = me.user,
            mask = me.mask;
        me.items = [
            {
                xtype: 'component',
                data: me.prepareData(user.data.stats, mask),
                flex: 1,
                tpl: [
                    '<div class="user_stats_image">' + '{user_stats_image}' + '</div>'
                ]
            }
        ];
        me.callParent();
    },
    updateUserStats: function(user, mask) {
        this.show();
        var data = this.prepareData(user, mask.data);
        this.items.first().update(data);
    },
    /**
     *         
     *
     * @param {Object} data   {ExGods.model.User}
     * @return {Object}
     */
    prepareData: function(user, mask) {
        if (!mask) {
            this.hide();
            return;
        }
        var me = this,
            preparedData = {
                name: [],
                user_stat: [],
                description: [],
                user_stats_image: [],
                groupDur: [],
                dur: [],
                description2: []
            };
        preparedData.user_stats_image = ExGods.util.User.printUserStats(user.stats, {
            visibleValue: 2
        });
        return preparedData;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        arr_images = arr_images.concat(ExGods.util.User.getUserStatImages());
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.mask.MaskAvatar', {
    extend: Ext.panel.Panel,
    alias: 'widget.maskavatar',
    layout: 'absolute',
    x: 5,
    y: 22,
    style: {
        'float': 'left'
    },
    /**
     * @cfg {ExGods.model.User} user (required)
     */
    nextAnimated: false,
    initComponent: function() {
        var me = this,
            user = me.user;
        if (me.cls != 'avatar') {
            me.plugins = [
                'inventory_frame'
            ];
        }
        me.callParent();
        me.avatar = me.initAvatar();
        me.add(me.avatar);
        me.mon(user, 'shapechanged', me.setAvatar, me);
    },
    initAvatar: function(invisible) {
        return Ext.widget('component', {
            style: this.getAvatarStyle(invisible),
            height: 410,
            width: 440,
            x: 0,
            y: 0
        });
    },
    /**
     *   
     */
    setAvatar: function() {
        var me = this;
        if (me.nextAnimated) {
            var avatar = me.initAvatar(true);
            me.add(avatar);
            me.avatar.el.animate({
                to: {
                    opacity: 0
                },
                duration: 1500
            });
            avatar.el.animate({
                to: {
                    opacity: 1
                },
                duration: 1500,
                callback: function() {
                    me.avatar.el.setStyle(me.getAvatarStyle());
                    avatar.destroy();
                    me.nextAnimated = false;
                }
            });
        } else {
            var speed = parseInt(ExGods.ref('constants|mask_house_change_speed').value),
                wait = parseInt(ExGods.ref('constants|mask_house_change_wait_time').value);
            me.avatar.el.animate({
                duration: speed,
                to: {
                    opacity: 0
                },
                listeners: {
                    afteranimate: function() {
                        me.avatar.el.setStyle(me.getAvatarStyle(true));
                    }
                }
            }).animate({
                delay: wait,
                duration: speed,
                to: {
                    opacity: 1
                }
            });
        }
    },
    /**
     * @private
     *     
     */
    getAvatarStyle: function(invisible) {
        return {
            background: 'url(' + this.user.getAvatar() + ') no-repeat 50% 50%',
            position: 'absolute',
            opacity: invisible ? 0 : 1
        };
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                me.user.getAvatar()
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.Tape', {
    extend: ExGods.view.ViewPanel,
    alias: 'widget.exg_tape',
    /**
     * itemTpl
     */
    itemTpl: [],
    /**
     * cellWidth
     */
    cellWidth: 64,
    /**
     * cellHeight
     */
    cellHeight: 64,
    /**
     * viewConfig
     */
    viewConfig: null,
    /**
     * startRecord {Number|Record}    
     */
    startRecord: 0,
    /**
     * scrollDuration
     */
    scrollDuration: 300,
    initComponent: function() {
        var me = this;
        me.initTemplates();
        me.viewConfig = Ext.apply({
            collectData: Ext.Function.bind(me.collectData, me),
            itemSelector: 'exg-tape-item',
            store: me.store,
            tpl: [
                '<div class="exg-tape-inner" style="width: {[ this.getInnerWidth() ]}px; height: {[ this.getInnerHeight() ]}px;">',
                '<ul class="exg-tape-items">',
                '<tpl for=".">',
                '<li class="exg-tape-item" style="width: ' + me.cellWidth + 'px; height: ' + me.cellHeight + 'px;">',
                '{[ this.printItem(values) ]}',
                '</li>',
                '</tpl>',
                '</ul>',
                '<div class="x-clear"></div>',
                '</div>',
                {
                    getInnerWidth: function() {
                        return me.cellWidth;
                    },
                    getInnerHeight: function() {
                        return me.cellHeight * me.store.getCount();
                    },
                    printItem: function(data) {
                        return me.itemTpl.apply(data);
                    }
                }
            ]
        }, me.viewConfig);
        me.callParent();
        me.on('viewready', function() {
            me.setActiveEl(me.startRecord, {
                silent: true
            });
        }, me, {
            single: true
        });
        me.mon(me.store, 'update', Ext.Function.createBuffered(function() {
            me.store.sort();
            me.getView().refresh();
            me.setActiveEl(null, {
                animate: true,
                silent: true,
                forced: true
            });
        }, 100));
    },
    onRender: function() {
        var me = this;
        me.el.insertHtml('beforeEnd', '<div class="exg-tape-top"></div>');
        me.el.insertHtml('beforeEnd', '<div class="exg-tape-bottom"></div>');
        me.callParent();
        //click
        me.el.on('click', function() {
            me.scrollTop(null, function() {
                me.hoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) - 1));
            });
        }, me, {
            delegate: '.exg-tape-top'
        });
        me.el.on('click', function() {
            me.scrollBottom(null, function() {
                me.hoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) + 1));
            });
        }, me, {
            delegate: '.exg-tape-bottom'
        });
        //hover
        me.el.on('mouseover', function() {
            me.hoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) - 1));
        }, me, {
            delegate: '.exg-tape-top'
        });
        me.el.on('mouseout', function() {
            me.unhoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) - 1));
        }, me, {
            delegate: '.exg-tape-top'
        });
        me.el.on('mouseover', function() {
            me.hoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) + 1));
        }, me, {
            delegate: '.exg-tape-bottom'
        });
        me.el.on('mouseout', function() {
            me.unhoverRecord(me.getRecord(me.getIndex(me.getActiveEl()) + 1));
        }, me, {
            delegate: '.exg-tape-bottom'
        });
        //scroll
        var wheelScroller = function(e) {
                e.preventDefault();
                if (e.detail > 0 || e.wheelDelta < 0) {
                    // 
                    me.scrollBottom();
                } else {
                    //  
                    me.scrollTop();
                }
            };
        me.getEl().dom.addEventListener('mousewheel', wheelScroller, false);
        me.getEl().dom.addEventListener('DOMMouseScroll', wheelScroller, false);
    },
    hoverRecord: function(record) {
        if (record) {
            this.getNodeByRecord(record).addCls('hover');
        }
    },
    unhoverRecord: function(record) {
        if (record) {
            this.getNodeByRecord(record).removeCls('hover');
        }
    },
    getNodeByRecord: function(record) {
        return this.getView().getNodeByRecord(record);
    },
    onSelect: function(view, model, index) {
        var me = this;
        me.fireEvent('select', me, view, model, index);
    },
    scrollTop: function(el, callback) {
        var me = this,
            model = me.getRecord(el),
            index = me.getIndex(model);
        if (index == -1) {
            return;
        }
        me.setActiveEl(--index, {
            animate: true,
            callback: callback || Ext.emptyFn
        });
    },
    scrollBottom: function(el, callback) {
        var me = this,
            model = me.getRecord(el),
            index = me.getIndex(model);
        if (index == -1) {
            return;
        }
        me.setActiveEl(++index, {
            animate: true,
            callback: callback || Ext.emptyFn
        });
    },
    /**
     *   
     * el {Number|Record|HTML|Ext.dom.Element}  , , dom  Ext.dom.Element
     * opts
     *  - animate {Boolean}   
     *  - callback {Function}
     *  - silent {Boolean}  true -    "select"
     *  - forced {Boolean}  true -       .      
     */
    setActiveEl: function(el, opts) {
        var me = this,
            model = me.getRecord(el),
            index = me.getIndex(model),
            view = me.getView(),
            cb = function() {
                if (!opts.silent) {
                    me.onSelect(view, model, index);
                }
                if (opts.callback)  {
                    opts.callback();
                }
                
            };
        opts = opts || {};
        if (!model)  {
            return false;
        }
        
        if (me.activeEl == model && !opts.forced)  {
            return false;
        }
        
        me.activeEl = model;
        var margin = Math.floor(me.getHeight() / 2 - me.cellHeight / 2) - index * me.cellHeight;
        view.el.stopAnimation();
        if (opts.animate) {
            view.el.animate({
                duration: me.scrollDuration,
                to: {
                    marginTop: margin + 'px'
                },
                callback: cb
            });
        } else {
            view.el.setStyle({
                marginTop: margin + 'px'
            });
            cb();
        }
    },
    /**
     *    /  
     * el {Number|Record|HTML|Ext.dom.Element}  , , dom  Ext.dom.Element
     */
    getRecord: function(el) {
        var me = this,
            index, model,
            view = me.getView();
        if (!el && el !== 0)  {
            return me.activeEl;
        }
        
        if (typeof el == 'number') {
            index = el;
            model = me.store.getAt(el);
        } else if (el.isModel) {
            model = el;
            index = me.store.indexOf(model);
        } else {
            el = Ext.get(el);
            model = view.getRecord(el);
            index = me.store.indexOf(model);
        }
        if (!model || index == -1) {
            return;
        }
        return model;
    },
    getActiveEl: function() {
        var me = this;
        return me.activeEl;
    },
    /**
     *     
     *     -    
     */
    getIndex: function(model) {
        var me = this,
            index = me.store.indexOf(model || me.getActiveEl());
        return index == -1 ? false : index;
    },
    /**
     *       
     */
    initTemplates: function() {
        var me = this;
        me.itemTpl = new Ext.XTemplate(me.itemTpl);
        me.selectorTpl = new Ext.XTemplate(me.selectorTpl);
    },
    /**
     *   DataView.     
     */
    collectData: function(records) {
        var me = this,
            data = [];
        records.forEach(function(record) {
            data.push(record.data);
        });
        return data;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            parent, items,
            arr_images = [];
        if (me.store) {
            items = me.store.data.items;
            for (var i = 0; i < items.length; i++) {
                if (items[i].data.item && items[i].data.item.images) {
                    for (var it in items[i].data.item.images) {
                        var img = items[i].data.item.images[it];
                        arr_images.push(img);
                    }
                }
            }
        }
        return {
            stuff: [],
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.mask.Tape', {
    extend: ExGods.view.Tape,
    alias: 'widget.masktape',
    cls: 'mask-items',
    bodyStyle: {
        overflow: 'visible'
    },
    cellWidth: 86,
    cellHeight: 82,
    initComponent: function() {
        var me = this;
        me.itemTpl = [
            '<div class="qh-object item {[this.getClass(values)]}" data-qh_otype="maskobject" data-qh_oid="{id}" id="maskid-{id}" data-qtip="{[this.getEscapedTitle(values)]}" >',
            '<div class="mask_frm"></div>',
            '<img class="image" src="{[this.getImage(values)]}" width="50" height="50">',
            '<div class="sticker"{[ this.getStickerStyle(values) ]}></div>',
            '<tpl if="values.has && this.checkDur(values)">',
            '<div class="dur">{groupDur}</div>',
            '</tpl>',
            '</div>',
            {
                getClass: function(values) {
                    return values.has ? ' has' : '';
                },
                checkDur: function(values) {
                    return values.item.param.nonbr == 0;
                },
                getEscapedTitle: function(values) {
                    return Ext.String.htmlEncode(values.item.title);
                },
                getImage: function(values) {
                    return values.has ? values.item.images.on : values.item.images.off;
                },
                getStickerStyle: function(values) {
                    var style = '';
                    if (values.params.toughness == 'red') {
                        var images = ExGods.ref('images|masks_images').image,
                            image = values.has ? images.trophies_rare : images.trophies_rare_bw;
                        style = ' style="background-image: url(' + image + ')"';
                    }
                    return style;
                }
            }
        ];
        me.scrollDuration = ExGods.ref('constants|mask_scroll_time').value * 1000;
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.printSelector();
    },
    printSelector: function() {
        var me = this;
        me.el.insertHtml('beforeEnd', '<div class="mask_selected_frame"></div>');
    },
    /**
     * override
     */
    getNodeByRecord: function(record) {
        return this.el.down('#maskid-' + record.get('id'));
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var parent = me.callParent();
        var images_trophies = ExGods.ref('images|masks_images').image;
        for (var it in images_trophies) {
            arr_images.push(images_trophies[it]);
        }
        return {
            stuff: [].concat(parent.stuff),
            images: [
                IMAGE_URL + 'mask/mask_select.png'
            ].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 *      
 */
Ext.define('ExGods.view.mask.CentralWindowMasks', {
    extend: Ext.panel.Panel,
    alias: 'widget.centralwindowmasks',
    bodyPadding: '7 8 0 6',
    config: {
        plugins: []
    },
    blocksPerPage: 3,
    masksInBlock: 5,
    initComponent: function() {
        var me = this;
        me.store = ExGods.app.getStore('Masks');
        me.maskGroups = me.store.getGroups();
        me.currentMask = me.store.getCurrent() || me.store.getAt(0);
        me.mon(me.store, {
            datachanged: me.updateMasks,
            update: me.updateMasks,
            scope: me
        });
        me.items = [
            {
                xtype: 'panel',
                layout: 'absolute',
                height: 415,
                items: [
                    {
                        xtype: 'maskstats',
                        itemId: 'user-mask-stats-window',
                        id: 'user-mask-stats-window',
                        user: me.user,
                        mask: me.currentMask.data,
                        closable: false,
                        x: 6,
                        y: 0,
                        height: 415
                    },
                    {
                        xtype: 'container',
                        itemId: 'masksWindow',
                        itemSelector: 'li',
                        x: 222,
                        y: 4,
                        width: 529,
                        height: 383,
                        html: me.prepareMasksHtml(me.maskGroups),
                        style: {
                            'overflow': 'hidden'
                        },
                        padding: '0 0 32 0'
                    },
                    {
                        xtype: 'form',
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        bodyPadding: '0 15 0 0',
                        margin: '-3 0 0 0',
                        defaults: {
                            xtype: 'checkboxfield',
                            checked: true,
                            style: {
                                color: '#e3ac69'
                            },
                            padding: '0 15 0 0',
                            listeners: {
                                change: me.onFilterChange,
                                scope: me
                            }
                        },
                        items: me.getTypeFilters()
                    }
                ]
            }
        ];
        me.initPager();
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.openPage(1);
        me.el.on('click', function(e, dom) {
            var id = dom.id.split('_')[1],
                rec = me.store.findRecord('id', id);
            me.fireEvent('itemclick', me, rec, dom);
        }, me, {
            delegate: '.mask-item'
        });
    },
    setMask: function(mask) {
        var me = this;
        me.el.down('#maskid_' + me.currentMask.get('id')).removeCls('mask_fit');
        me.el.down('#maskid_' + mask.get('id')).addCls('mask_fit');
        me.currentMask = mask;
        me.down('maskstats').updateUserStats(Ext.apply({
            shape: me.user.get('shape')
        }, me.user.get('stats')), mask);
    },
    onFilterChange: function() {
        var me = this;
        me.updateMasks();
        me.openPage(1);
        me.pager.refresh();
    },
    updateMasks: function() {
        var me = this,
            form = me.down('form'),
            view = me.down('#masksWindow'),
            types = [],
            filtered = [];
        //  
        form.items.each(function(item) {
            if (item.checked) {
                types.push(item.boxLabel);
            }
        });
        Ext.Array.each(me.maskGroups, function(group) {
            if (types.indexOf(group.type) != -1) {
                filtered.push(group);
            }
        });
        view.el.setHTML(me.prepareMasksHtml(filtered));
        me.pager.total = Math.ceil(filtered.length / me.blocksPerPage) || 1;
        me.openPage(me.pager.current);
        me.pager.refresh();
    },
    /**
     * @private
     */
    getTypeFilters: function() {
        var me = this,
            types = [],
            filters = [];
        Ext.Array.each(me.maskGroups, function(group) {
            Ext.Array.each(group.records, function(record) {
                var type = record.get('type');
                if (type && Ext.Array.indexOf(types, type) == -1) {
                    types.push(type);
                    filters.push({
                        boxLabel: type
                    });
                }
            });
        });
        return filters;
    },
    /**
     * @private
     */
    prepareMasksHtml: function(groups) {
        var me = this,
            masks_html = '<ul class="mask-items window_mask" style="padding: 0 0 0 8px">',
            getStickerStyle = function(values) {
                var style = '';
                if (values.params.toughness == 'red') {
                    var images = ExGods.ref('images|masks_images').image,
                        image = values.has ? images.trophies_rare : images.trophies_rare_bw;
                    style = ' style="background-image: url(' + image + ')"';
                }
                return style;
            };
        Ext.Array.each(groups, function(group) {
            masks_html += '<div class="mask_window_container"><div class="mask_window-header">' + group.name + '<div class="mask_group_text">' + group.name + '</div></div>';
            Ext.Array.each(group.records, function(mask, i) {
                var has = mask.get('has'),
                    item = mask.get('item'),
                    id = mask.get('id'),
                    cls = '';
                if (has)  {
                    cls += ' has';
                }
                
                if (me.currentMask == mask)  {
                    cls += ' mask_fit';
                }
                
                if (i >= me.masksInBlock)  {
                    return;
                }
                
                if (i > 0 && i < me.masksInBlock) {
                    masks_html += '<div class="mask-arrow' + (has ? '' : ' disabled') + '"></div>';
                }
                masks_html += '<li class="qh-object mask-item item ' + mask.get('params').toughness + cls + '" id="maskid_' + id + '" data-qh_otype="maskobject" data-qh_oid="' + id + '" ' + (i < 1 ? 'data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : '') + '>' + '<div class="mask_frm"></div>' + '<img class="image" src="' + item.images[has ? 'on' : 'off'] + '" width="50" height="50">' + (has && !item.param.nonbr ? '<div class="dur">' + mask.get('groupDur') + '</div>' : '') + '<div class="sticker"' + getStickerStyle(mask.data) + '></div>' + '<div class="notify_i"></div>' + '<div class="x-clear"></div>' + '</li>';
                if (i == group.records.length - 1 && group.records.length < me.masksInBlock) {
                    for (var i = 0; i < me.masksInBlock - group.records.length; i++) {
                        masks_html += '<div class="mask-arrow disabled"></div>';
                        masks_html += '<li>' + '<div class="mask_frm"></div>' + '<img class="image" src="' + IMAGE_URL + 'locations/monster_absent.jpg" width="50" height="50">' + '<div class="x-clear"></div>' + '</li>';
                    }
                }
            });
            masks_html += '</div>';
        });
        masks_html += '</ul>';
        return masks_html;
    },
    /**
     *  
     */
    initPager: function() {
        var me = this;
        me.config.plugins.push({
            ptype: 'pager',
            marginLeft: -29,
            marginRight: -29,
            top: 185,
            current: 1,
            currentTab: 0,
            total: Math.ceil(me.maskGroups.length / me.blocksPerPage),
            totalTabs: 1,
            textLeft: 435,
            textTop: -36
        });
        me.prevPage = function(pager) {
            me.openPage(pager.current);
            pager.refresh();
        };
        me.nextPage = function(pager) {
            me.openPage(pager.current);
            pager.refresh();
        };
        me.openPage = function(pageIndex) {
            var me = this;
            me.pager.current = pageIndex;
            pageIndex--;
            //  , ..    1,    0
            els = me.getEl().select('.mask_window_container');
            els.setStyle('display', 'none');
            var i = els.elements.length;
            while (i--) {
                els.elements[i].style.display = Math.floor(i / me.blocksPerPage) == pageIndex ? 'block' : 'none';
            }
        };
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        Ext.Array.each(me.maskGroups, function(group) {
            Ext.Array.each(group.records, function(mask, i) {
                var item = mask.get('item');
                for (var it in item.images) {
                    arr_images.push(item.images[it]);
                }
            });
        });
        var images_trophies = ExGods.ref('images|masks_images').image;
        for (var it in images_trophies) {
            arr_images.push(images_trophies[it]);
        }
        return {
            images: [
                IMAGE_URL + 'locations/monster_absent.jpg',
                IMAGE_URL + 'locations/monster_frame_green.png',
                IMAGE_URL + 'mask/header_class.png'
            ].concat(arr_images)
        };
    }
});

/**
 * 
 */
Ext.define('ExGods.view.mask.UpgradeAvatar', {
    extend: Ext.Component,
    alias: 'widget.upgradeavatar',
    width: 234,
    height: 404,
    cls: 'upgrade-avatar',
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="avatar" style="background-image:url({[this.getImage(values.user)]})"></div>',
            '<h1>{mask.label}</h1>',
            '<div class="avatar-bg"></div>',
            '<div id="upgrade-mask-preps">',
            '<tpl for="mask.battle_instants">',
            '<div class="ability-img prep-link" data-prep_name="{name}" style="background:url({[this.getPrepImage(values.name)]})">',
            '<div class="notify_i"></div>',
            '</div>',
            '</tpl>',
            '</div>',
            '<div class="info-top-container">',
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="avatar-info-container">',
            '{[ ExGods.util.User.printUserStats(values.user.stats.stats, {visibleValue: 2}) ]}',
            '<div class="paper-separator"></div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</div>',
            '<div class="avatar-params stats-list">',
            '<tpl if="compareUser">',
            '{[ ExGods.util.User.printUserStats(values.user.stats.stats, {visibleValue: 1, changes:this.prepareChanges(values), align: "right"}) ]}',
            '<tpl else>',
            '{[ ExGods.util.User.printUserStats(values.user.stats.stats, {visibleValue: 1, align: "right"}) ]}',
            '</tpl>',
            '</div>',
            '<div class="paper-separator"></div>',
            '<div class="paper-title">' + ExGods.getMsgByKey('view_mask_stats_battleactions') + '</div>',
            '<tpl if="mask.battle_turns">',
            '<div class="stats-list like_table">',
            '<div class="align_middle">',
            '<tpl for="mask.battle_turns">',
            '<div class="action turn-link" id="turn__{name}" data-turn_name="{name}">',
            '<img src="{[this.getTurnImage(values.name)]}">',
            '<p>{[this.getTurnLabel(values.name)]}</p>',
            '<div class="notify_i"></div>',
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            '</tpl>',
            '</div>',
            '</div>',
            '<div class="upgrade-mask-params-btn inventory-params noselect">' + ExGods.getMsgByKey('inventory_params_btn_text') + '</div>',
            {
                prepareChanges: function(values) {
                    var changes = {};
                    Ext.Object.each(values.user.stats.stats, function(k, v) {
                        changes[k] = parseInt(v) - parseInt(values.compareUser.stats.stats[k]);
                    });
                    return changes;
                },
                getImage: function(user) {
                    return ExGods.ref('user_shape|' + user.shape).full;
                },
                getPrepImage: function(name) {
                    return IMAGE_URL + ExGods.ref('battle_prep').get(name).desc.images.active;
                },
                getTurnImage: function(name) {
                    return IMAGE_URL + ExGods.ref('battle_turn').get(name).desc.images.active;
                },
                getTurnLabel: function(name) {
                    return ExGods.ref('battle_turn').get(name).label;
                }
            }
        ];
        me.data = {
            user: me.localUserData,
            mask: me.mask,
            compareUser: me.compareUserData
        };
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.maskGradeLine = Ext.widget('maskgradeline', {
            renderTo: me.getEl(),
            maskGrade: me.maskGrade
        });
        me.el.on('click', function() {
            var el = me.el.down('.info-top-container'),
                btn = me.el.down('.upgrade-mask-params-btn');
            if (el.isVisible()) {
                el.hide();
                btn.removeCls('opened');
            } else {
                el.show();
                btn.addCls('opened');
            }
        }, me, {
            delegate: '.upgrade-mask-params-btn'
        });
    },
    onDestroy: function() {
        var me = this;
        me.maskGradeLine.destroy();
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        arr_images.push(ExGods.ref('user_shape|' + me.data.user.shape).full);
        for (var it in me.data.mask.battle_instants) {
            var name = me.data.mask.battle_instants[it].name;
            var btl = ExGods.ref('battle_prep').get(name).desc.images;
            for (var it in btl) {
                arr_images.push(btl[it]);
            }
        }
        for (var it in me.data.mask.battle_turns) {
            var name = me.data.mask.battle_turns[it].name;
            var btl = ExGods.ref('battle_turn').get(name).desc.images;
            for (var it in btl) {
                arr_images.push(btl[it]);
            }
        }
        return {
            images: [
                IMAGE_URL + 'mask/trophy_mask_frm.png',
                IMAGE_URL + 'battle/peril-ico.png',
                IMAGE_URL + 'battle/peril-trafaret.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.mask.UpgradeProgress', {
    extend: Ext.Component,
    alias: 'widget.upgradeprogress',
    width: 294,
    height: 404,
    margin: '0 -7',
    y: 12,
    style: {
        zIndex: 1,
        overflow: 'hidden'
    },
    cls: 'upgrade-progress',
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="progress-bg"></div>',
            '<div id="anim-progress"></div>',
            '<div class="upper-progress-bg"></div>',
            '<div class="ingredients">',
            '<tpl for="next_upgrade_price">',
            '{[ this.printStuff(values) ]}',
            '</tpl>',
            '</div>',
            '<div id="upgrade-button-place"></div>',
            {
                printStuff: function(data) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'upgrade_stuff',
                        params: {
                            stuff: data
                        }
                    });
                }
            }
        ];
        me.data = me.mask;
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.btn = Ext.widget('textbutton', {
            text: ExGods.getMsgByKey('view_masks_improve_btn_text'),
            cls: 'double_text_btn',
            disabled: !me.mask.next_enabled || !me.mask.has || !me.isEnoughtResources(),
            width: 116,
            handler: function() {
                if (me.mask.next_message) {
                    ExGods.app.getViewportController().onLogMessage(me.currentFitMask.next_message);
                } else {
                    me.fireEvent('upgrade', {
                        id: me.mask.id,
                        item: me.mask.next_upgrade.item.id,
                        from_item: me.mask.item.entry,
                        btn: me.btn
                    }, me.startAnimate.bind(me));
                }
            },
            renderTo: 'upgrade-button-place'
        });
    },
    startAnimate: function() {
        var spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                images: [
                    'mask/upgarade_mask.png'
                ],
                frames: [
                    [
                        0,
                        0,
                        42,
                        37,
                        0,
                        66.45,
                        57.45
                    ],
                    [
                        42,
                        0,
                        42,
                        37,
                        0,
                        66.45,
                        57.45
                    ],
                    [
                        84,
                        0,
                        145,
                        42,
                        0,
                        66.45,
                        61.45
                    ],
                    [
                        229,
                        0,
                        145,
                        42,
                        0,
                        66.45,
                        61.45
                    ],
                    [
                        374,
                        0,
                        213,
                        49,
                        0,
                        66.45,
                        64.45
                    ],
                    [
                        587,
                        0,
                        283,
                        293,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        0,
                        293,
                        283,
                        293,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        283,
                        293,
                        283,
                        293,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        566,
                        293,
                        283,
                        293,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        0,
                        586,
                        283,
                        296,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        283,
                        586,
                        283,
                        296,
                        0,
                        66.45,
                        67.45
                    ],
                    [
                        566,
                        586,
                        283,
                        296,
                        0,
                        66.45,
                        67.45
                    ]
                ],
                renderTo: this.getEl().down('#anim-progress'),
                finish: function() {
                    this.inProgress = false;
                }
            });
        //fps:1
        spriteSheet.start();
        return spriteSheet;
    },
    getResources: function() {
        return [
            IMAGE_URL + 'mask/upgarade_mask.png'
        ];
    },
    /**
     *    -   
     */
    isEnoughtResources: function() {
        var me = this;
        return ExGods.app.getUser().checkStuff(me.mask.next_upgrade_price);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        for (var i = 0; i < me.data.next_upgrade_price.length; i++) {
            var stuff_ = me.data.next_upgrade_price[i];
            stuff_arr.push(stuff_);
        }
        return {
            stuff: stuff_arr,
            images: [
                IMAGE_URL + 'mask/trophy_improvemask_bg.png',
                IMAGE_URL + 'mask/trophy_improvemask_top.png'
            ].concat(arr_images)
        };
    }
});

/**
 * ,    ()
 */
Ext.define('ExGods.view.mask.MaskGradeLine', {
    extend: Ext.Component,
    alias: 'widget.maskgradeline',
    cls: 'mask-grade-line',
    /**
     * @cfg {Object} maskProto   
     */
    /**
      * @cfg {Number} maskGrade   
      */
    width: 86,
    initComponent: function() {
        var me = this,
            user = me.user;
        if (me.maskProto) {
            me.data = me.maskProto;
        } else {
            me.data = {
                data: {
                    item_grade: me.maskGrade
                }
            };
        }
        me.tpl = [
            '<tpl if="data.item_grade">',
            '{[ this.getCherepoks(values) ]}',
            '</tpl>',
            {
                getCherepoks: function(values) {
                    var html = '';
                    for (var i = 0; i < values.data.item_grade; i++) {
                        html += '<div></div>';
                    }
                    return html;
                }
            }
        ];
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Masks', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /**
         * @method getMasksWindow
         *   ""
         * @return {ExGods.view.menu.MainMenuButton}
         */
            ref: 'masksWindow',
            selector: '#masksWindow'
        },
        {
            /**
         * @method getTape
         *   
         * @return {Ext.panel}
         */
            ref: 'tape',
            selector: '#maskTape'
        },
        {
            /**
         * @method getAvailability
         *   ""
         * @return {Ext.form.field.Checkbox}
         */
            ref: 'availability',
            selector: '#availability'
        },
        {
            /**
         * @method getSearchEmptyMessage
         *  ,   
         * @return {Ext.panel}
         */
            ref: 'searchEmptyMessage',
            selector: '#search_empty_message'
        },
        {
            /**
         * @method getUserMaskStats
         *     
         * @return {Ext.panel}
         */
            ref: 'userMaskStats',
            selector: '#user-mask-stats'
        },
        {
            /**
         * @method getUserMaskStatsWindow
         *        " "
         * @return {Ext.panel}
         */
            ref: 'userMaskStatsWindow',
            selector: '#user-mask-stats-window'
        },
        {
            /**
         * @method getMaskContainer
         *      
         * @return {ExGods.view.ViewPanel}
         */
            ref: 'maskContainer',
            selector: '#mask-container'
        },
        {
            /**
         * @method getUserMaskStatsStars
         *   " "   
         * @return {ExGods.view.mask.MaskStatsStars}
         */
            ref: 'userMaskStatsStars',
            selector: '#user-mask-stats-stars'
        },
        {
            /**
         * @method getBackInTown
         *   " "
         */
            ref: 'backInTown',
            selector: '#back_in_town'
        },
        {
            /**
         * @method getUpgradeMaskWnd
         *   ""
         */
            ref: 'upgradeMaskWnd',
            selector: 'upgrademask'
        },
        {
            /**
         * @method getCentralWindowMasks
         *     
         */
            ref: 'centralWindowMasks',
            selector: 'centralwindowmasks'
        },
        {
            /**
         * @method getUpgradeBtn
         *   ""
         */
            ref: 'upgradeBtn',
            selector: '#upgrade-mask-btn'
        }
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Masks:'
    },
    models: [
        'Mask'
    ],
    views: [
        'mask.MaskStats',
        'mask.MaskAvatar',
        'mask.MaskStatsStars',
        'mask.CentralWindowMasks',
        'mask.UpgradeWindow',
        'mask.UpgradeAvatar',
        'mask.UpgradeProgress',
        'mask.MaskGradeLine',
        'mask.Tape'
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Masks:'
    },
    init: function(app) {
        var me = this,
            user = app.user;
        me.store = me.app.getMasksStore();
        me.control({
            'button[action="buy-mask"]': {
                click: me.buyMask
            },
            'upgradeprogress': {
                upgrade: me.onUpgrade
            },
            'masktape': {
                select: me.onMaskSelect
            },
            'centralwindowmasks': {
                itemclick: me.onCentralWindowItemClick
            }
        });
        ExGods.stuff.StuffManager.register({
            'upgrade_stuff': ExGods.view.mask.stuff.UpgradeStuff
        });
        me.fitMask = Ext.Function.createBuffered(me.fitMask, ExGods.ref('constants|mask_fit_time').value * 1000);
        ExGods.Components.addComponentInitializer('masks', me.initMasksComponent, me);
    },
    reloadMaskService: function(data) {
        var me = this;
        if (me.service) {
            me.service.update(data || null, function() {
                ExGods.helpme.loadProtos(me.service.data.masks, 'item', function() {
                    me.store.loadRawData(me.service.data.masks);
                    //      
                    me.currentFitMask = me.store.findRecord('id', me.currentFitMask.get('id'));
                    me.updateViews();
                });
            });
        }
    },
    initMasksComponent: function(config) {
        var me = this;
        if (Ext.getCmp('MASKS')) {
            return;
        }
        me.service = config.service;
        me.localUser = Ext.create('ExGods.model.User', Ext.clone(ExGods.app.user.raw));
        me.cmp = Ext.create('ExGods.view.Room', {
            cls: 'masks',
            backgroundImage: config.backImg,
            emptySearchText: config.emptySearchText,
            closeText: config.closeText,
            fitText: config.fitText,
            closeColor: config.closeColor,
            parent: me,
            closeCallback: Ext.Function.bind(me.checkFitOnClose, me, []),
            rightPanelX: 715,
            margin: '0 10 10 0',
            closable: true,
            items: [
                {
                    xtype: 'component',
                    margin: '0 0 0 722',
                    html: '<div class="mask_header" style="background: url(' + ExGods.ref('images|masks_images').image['header_trophy_text'] + ');"></div>'
                }
            ],
            listeners: {
                beforeclose: {
                    fn: function() {
                        me.checkFitOnClose(true);
                        return false;
                    }
                }
            }
        });
        wnd = Ext.widget('window1', {
            id: 'MASKS',
            autoShow: false,
            items: [
                me.cmp
            ]
        });
        me.maskImage = config.backImg;
        ExGods.app.getController('Location').maskLocation(function() {
            //  
            ExGods.helpme.loadProtos(me.service.data.masks, 'item', function() {
                me.store.loadRawData(me.service.data.masks);
                me.currentFitMask = me.store.getCurrent();
                var currentFitMask = me.currentFitMask || me.store.getAt(0);
                me.cmp.add({
                    xtype: 'maskstats',
                    itemId: 'user-mask-stats',
                    closeAction: 'hide',
                    user: me.localUser,
                    mask: currentFitMask.data,
                    closable: false,
                    x: 10,
                    y: 6
                }, {
                    xtype: 'maskstats_onlystars',
                    itemId: 'user-mask-stats-stars',
                    closeAction: 'hide',
                    user: me.localUser,
                    mask: currentFitMask.data,
                    closable: false,
                    x: 321,
                    y: 347
                }, {
                    xtype: 'maskavatar',
                    user: me.localUser,
                    cls: 'avatar',
                    x: 205,
                    y: 0,
                    width: 440
                }, {
                    xtype: 'masktape',
                    itemId: 'maskTape',
                    x: 615,
                    y: 40,
                    width: 225,
                    height: 325,
                    store: me.store,
                    startRecord: currentFitMask
                }, {
                    height: 30,
                    x: 60,
                    y: 375,
                    width: 110,
                    xtype: 'textbutton',
                    text: config.text_trophy_all,
                    cls: 'get_all_masks_btn',
                    handler: function(btn) {
                        var wnd = Ext.widget('window2', {
                                autoShow: false,
                                items: [
                                    {
                                        xtype: 'centralwindowmasks',
                                        user: me.localUser
                                    }
                                ]
                            });
                        ExGods.Resources.load(wnd, function() {
                            wnd.show();
                        });
                    }
                }, {
                    height: 30,
                    x: 615,
                    y: 373,
                    width: 110,
                    xtype: 'textbutton',
                    text: config.text_improve,
                    id: 'upgrade-mask-btn',
                    cls: 'qh-object',
                    hidden: !currentFitMask.data.next_upgrade,
                    handler: function() {
                        if (me.sendingFitRequest) {
                            var interval = setInterval(function() {
                                    if (me.sendingFitRequest)  {
                                        return;
                                    }
                                    
                                    me.showMaskUpgradeWnd();
                                    clearInterval(interval);
                                }, 100);
                        } else  {
                            me.showMaskUpgradeWnd();
                        }
                        
                    }
                });
                ExGods.Resources.load(wnd, function() {
                    var fn = function() {
                            ExGods.app.getController('Location').unmaskLocation();
                        },
                        mask;
                    wnd.show();
                    me.setUpgradeMaskQH();
                    if (config.clientAction && config.clientAction.options.mask_id) {
                        var ids = Ext.isArray(config.clientAction.options.mask_id) ? config.clientAction.options.mask_id : [
                                config.clientAction.options.mask_id
                            ],
                            i = ids.length;
                        while (i--) {
                            mask = me.store.findRecord('id', ids[i]);
                            if (mask)  {
                                break;
                            }
                            
                        }
                    }
                    if (!mask && !me.store.getCurrent()) {
                        mask = me.store.getAt(0);
                    }
                    if (mask) {
                        setTimeout(function() {
                            me.getTape().setActiveEl(mask, {
                                silent: true
                            });
                            me.fitMask(mask, fn);
                        }, 0);
                    } else  {
                        fn();
                    }
                    
                });
            });
        }, {
            img: me.maskImage
        });
        return wnd;
    },
    onMaskSelect: function(tape, dataview, record, index) {
        var me = this;
        me.fitMask(record);
    },
    onCentralWindowItemClick: function(centralwindow, record, dom) {
        var me = this;
        me.getTape().setActiveEl(record);
        me.fitMask(record);
    },
    /**
     * Xclicked - ,    
     */
    checkFitOnClose: function(Xclicked) {
        var me = this,
            prevent_close = false,
            closeWindow = function() {
                if (prevent_close)  {
                    return;
                }
                
                me.getTape().setActiveEl(me.store.getCurrent(), {
                    animate: true,
                    silent: true,
                    forced: true,
                    callback: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            Ext.getCmp('MASKS').close();
                        }, {
                            img: me.maskImage
                        });
                    }
                });
            };
        if (me.store.canFitAndUse(me.currentFitMask)) {
            //  quest helpera   
            me.setBackInTownQH(false);
            if (Xclicked) {
                Ext.widget('confirmdialog', {
                    quest_helper_id: me.currentFitMask.get('id'),
                    quest_helper_type: 'room_mask',
                    message: ExGods.ref('message_client|check_on_fit_message'),
                    handler: function(btn) {
                        prevent_close = true;
                        me.putMask(function() {
                            prevent_close = false;
                            closeWindow();
                        });
                    },
                    listeners: {
                        close: closeWindow
                    }
                });
            } else {
                Ext.widget('confirmdialog', {
                    quest_helper_id: me.currentFitMask.get('id'),
                    quest_helper_type: 'room_mask',
                    message: ExGods.ref('message_client|check_on_fit_message_no_close'),
                    handler: function(btn) {
                        me.putMask();
                    }
                });
            }
        } else  {
            closeWindow();
        }
        
    },
    setBackInTownQH: function(enable) {
        var me = this,
            protectBtn = me.getBackInTown(),
            canFitAndUse = me.store.canFitAndUse(me.currentFitMask),
            closeText = me.cmp.closeText,
            fitText = me.cmp.fitText;
        if (protectBtn) {
            if (enable) {
                protectBtn.el.set({
                    'data-qh_otype': 'room_mask',
                    'data-qh_oid': me.currentFitMask.get('id')
                });
                protectBtn.setText(canFitAndUse ? fitText : closeText);
                protectBtn.fitEnabled = canFitAndUse;
            } else {
                protectBtn.el.set({
                    'data-qh_otype': 'empty'
                });
            }
        }
    },
    setUpgradeMaskQH: function() {
        var me = this,
            upgradeBtn = me.getUpgradeBtn();
        if (upgradeBtn && upgradeBtn.isVisible() && me.currentFitMask) {
            upgradeBtn.el.set({
                'data-qh_otype': 'room_mask_button_uluchshit',
                'data-qh_oid': me.currentFitMask.get('id')
            });
        }
    },
    fitMask: function(record, callback) {
        var me = this,
            tape = me.getTape();
        if (me.currentFitMask == record)  {
            return;
        }
        
        me.sendingFitRequest = true;
        me.service.command('fit_mask', {
            id: record.get('id'),
            item: record.get('item').entry
        }, function(resp) {
            //    
            if (record != tape.getActiveEl())  {
                return;
            }
            
            var avtImg = ExGods.references.get('user_shape').getByKey(resp.fit.shape);
            ExGods.Resources.load({
                getResources: function() {
                    return {
                        images: [
                            avtImg.avatar
                        ]
                    };
                }
            }, function() {
                me.localUser.set({
                    stats: resp.fit,
                    shape: resp.fit.shape
                });
                me.currentFitMask = record;
                me.updateViews();
                me.sendingFitRequest = false;
                if (callback)  {
                    callback(resp);
                }
                
            });
        });
    },
    updateViews: function() {
        var me = this,
            record = me.currentFitMask,
            user = me.localUser,
            stats = user.get('stats'),
            centralwindow = me.getCentralWindowMasks(),
            userMaskStats = me.getUserMaskStats(),
            index;
        if (!userMaskStats) {
            return;
        }
        me.store.each(function(rec, i) {
            if (rec == record) {
                index = i;
            }
        });
        me.setQuestHelperVisibility(index);
        userMaskStats.updateUserStats(stats, record);
        me.getUserMaskStatsStars().updateUserStats(stats, record);
        if (centralwindow) {
            centralwindow.updateMasks();
            centralwindow.setMask(record);
        }
        me.setBackInTownQH(true);
        var upgradeBtn = me.getUpgradeBtn();
        if (upgradeBtn) {
            if (record.get('next_upgrade')) {
                if (record.get('next_enabled')) {
                    upgradeBtn.enable();
                } else {
                    upgradeBtn.disable();
                }
                upgradeBtn.show();
            } else {
                upgradeBtn.hide();
                upgradeBtn.disable();
            }
        }
        me.setUpgradeMaskQH();
    },
    showMaskUpgradeWnd: function() {
        var me = this,
            wnd;
        if (!me.currentFitMask.get('next_upgrade'))  {
            return;
        }
        
        //       , 
        //  ,     ""
        //  
        var itemId = me.currentFitMask.get('next_upgrade').item.id;
        me.sendingFitRequest = true;
        me.service.command('fit_mask', {
            id: me.currentFitMask.get('id'),
            item: itemId
        }, function(resp) {
            me.sendingFitRequest = false;
            wnd = Ext.widget('window2', {
                autoShow: false,
                items: [
                    {
                        xtype: 'upgrademask',
                        localUser: me.localUser,
                        currentMask: me.store.getCurrent(),
                        currentFitMask: me.currentFitMask.data,
                        upgradeFitData: {
                            stats: resp.fit,
                            shape: resp.fit.shape
                        },
                        service: me.service
                    }
                ]
            });
            ExGods.Resources.load(wnd, function() {
                wnd.show();
            });
        });
    },
    setQuestHelperVisibility: function(index) {
        if (!ExGods.app.getQuestHelperController().room_mask)  {
            return;
        }
        
        var me = this,
            btn = Ext.get(Ext.select('.get_all_masks_btn').elements[0]),
            el, pointer_el;
        me.store.each(function(record) {
            el = Ext.get('maskid-' + record.get('id'));
            //         
            if (el && Ext.Array.indexOf(ExGods.app.getQuestHelperController().room_mask, record.get('id')) != -1) {
                if ([
                    index - 1,
                    index,
                    index + 1
                ].indexOf(record.index) != -1) {
                    el.removeCls('qh-off');
                    //     
                    btn.removeCls('qh-object');
                    if (btn.el.down('.qh-pointer')) {
                        btn.el.down('.qh-pointer').hide();
                    }
                    if (el.down('.qh-pointer')) {
                        el.down('.qh-pointer').setVisible(record.index != index);
                    }
                } else {
                    el.addCls('qh-off');
                    //    
                    btn.addCls('qh-object');
                    btn.set({
                        'data-qh_otype': 'maskobject',
                        'data-qh_oid': record.get('id'),
                        'data-qh_opts': '{&quot;cls&quot;:&quot;flip-h&quot;}'
                    });
                    if (btn.el.down('.qh-pointer')) {
                        btn.el.down('.qh-pointer').show();
                    }
                }
            }
        });
    },
    putMask: function(cb) {
        var me = this,
            tapeCmp = me.getTape();
        me.service.command('put_on_mask', {
            id: me.currentFitMask.get('id'),
            item: me.currentFitMask.get('item').entry
        }, function(resp) {
            if (resp.success) {
                me.store.loadRawData(resp.masks);
                //      
                //        
                tapeCmp.activeEl = tapeCmp.store.getCurrent();
                me.localUser.set({
                    stats: ExGods.app.user.data.stats,
                    shape: ExGods.app.user.data.shape
                });
                me.updateViews();
            }
            if (cb)  {
                cb(resp);
            }
            
        });
    },
    buyMask: function() {
        var me = this;
        Ext.widget('confirmdialog', {
            message: new Ext.Template(ExGods.ref('message_client|buy_mask')).apply({
                cost: ExGods.util.Format.printMoney(me.currentFitMask.data.item_price['new'])
            }),
            handler: function() {
                me.service.command('buy_mask', {
                    id: me.currentFitMask.get('id')
                }, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.currentFitMask.set('has', 1);
                    me.currentFitMask.calcGroupDur();
                    me.updateViews();
                });
            }
        });
    },
    onUpgrade: function(params, startCallback) {
        var me = this,
            curMask = me.currentFitMask.data;
        Ext.widget('confirmdialog', {
            message: ExGods.app.applyTpl(ExGods.ref('message_client|upgrade_mask')),
            handler: function() {
                var upgraded_mask,
                    wnd = me.getUpgradeMaskWnd(),
                    data = wnd.upgradeFitData,
                    avatar = Ext.getCmp('MASKS').down('maskavatar'),
                    spriteSheet = startCallback();
                params.btn.disable();
                delete params.btn;
                me.service.command('upgrade_mask', params, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    ExGods.helpme.loadProtos(resp.masks, 'item', function() {
                        me.store.loadRawData(resp.masks);
                        upgraded_mask = me.store.findRecord('id', me.currentFitMask.get('id'));
                        var callback = function() {
                                setTimeout(function() {
                                    me.currentFitMask = upgraded_mask;
                                    avatar.nextAnimated = true;
                                    me.localUser.set(data);
                                    if (me.store.getCurrent() == me.currentFitMask) {
                                        me.user.set(data);
                                    }
                                    me.updateViews();
                                    if (wnd.up())  {
                                        wnd.up().close();
                                    }
                                    
                                }, ExGods.ref('constants|upgrade_mask_animation_delay').value);
                            };
                        if (spriteSheet.inProgress) {
                            spriteSheet.finish = callback;
                        } else  {
                            callback();
                        }
                        
                    });
                });
            }
        });
    }
});

/**
 *  ,  ,        .
 */
Ext.define('ExGods.controller.OnlineList', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'OnlineList:'
    },
    models: [
        'BasicUser'
    ],
    refs: [
        {
            /**
             * @method getChatList
             *      
             * @return {Ext.view.View}
             */
            ref: 'chatList',
            selector: '#chat-contact-list'
        }
    ],
    /**
     * @property {ExGodsCore.model.Location} location
     *  
     */
    /**
     * @property {ExGods.store.Locations} locations
     *  
     */
    /**
     * @property {Ext.container.Container} locationContainer
     * ,     ,     
     */
    /**
     * @property {ExGods.model.World} world
     *  
     */
    /**
     * @property {ExGods.store.Users} worldOnlineStore
     *      
     */
    init: function(app) {
        var me = this,
            user = me.getUser();
        me.chatContacts = app.getChatContactsStore();
        me.control({
            '#chat-tab-panel': {
                tabchange: me.onChatTabChange
            }
        });
        //   
        //      user.on({
        //          worldchanged: me.onWorldChanged,
        //          scope: me
        //      });
        user.location.on({
            idchanged: me.onLocationIdChanged,
            scope: me
        });
        //  15    
        me.onlineListTask = {
            interval: 15 * 1000,
            run: me.getOnlineList,
            stopped: true,
            scope: me
        };
        Ext.TaskManager.start(me.onlineListTask);
    },
    //      me.worldOnlineStore = Ext.create('ExGodsCore.store.ChatContacts', {
    //          proxy: {
    //              type: 'ajax',
    //              url: '/online_list/w/' + me.getWorld().get('entry') + '/',
    //
    //              reader: {
    //                  type: 'json',
    //                  root: 'user_list'
    //              },
    //
    //              limitParam: false,
    //              pageParam: false,
    //              startParam: false,
    //              sortParam: false
    //          }
    //      });
    //  15      
    //      me.worldOnlineTask = Ext.TaskManager.newTask({
    //          interval: 15 * 1000,
    //          fireOnStart: true,
    //          run: function(store, user) {
    //
    //              me.scroller.catchPosition();
    //              debugger
    //
    //              store.load({
    //                  url: '/online_list/w/' + user.getWorld() + '/'
    //              });
    //
    //              setTimeout(function(){
    //                  me.updateLayout();
    //                  me.scroller.restorePosition();
    //              },0);
    //
    //          },
    //          args: [me.worldOnlineStore, user]
    //      });
    /**
     * @private
     *    . /   
     *  
     */
    onChatTabChange: function(tabPanel, newCard) {
        var me = this,
            chatList = me.getChatList();
        if (newCard.channelType.world) {}
        //chatList.bindStore(me.worldOnlineStore);
        else if (newCard.channelType.battle) {
            chatList.bindStore(ExGods.app.getController('battle.BattleView').allies);
        } else if (newCard.channelType.location || newCard.channelType.group) {
            chatList.bindStore(me.chatContacts);
        }
    },
    //      if (newCard.channelType.world) {
    //          //me.worldOnlineTask.start();
    //      } else {
    //          me.worldOnlineTask.stop();
    //      }
    /**
     * @private   ID 
     */
    onLocationIdChanged: function() {
        var me = this;
        if (me.onlineListTask.stopped) {
            /***/
            me.log('  -');
            Ext.TaskManager.start(me.onlineListTask);
        } else {
            /***/
            me.log('ID   -  -');
            me.getOnlineList();
        }
    },
    onWorldChanged: function() {
        var me = this;
    },
    //      if (!me.worldOnlineTask.stopped) {
    //          me.worldOnlineTask.restart();
    //      }
    /**
     *   //NPC  
     *         next
     *            
     *        -<next>
     * 
     *     /online_list/6/  
     * {
     * success => 1,
     * user_list => [..],
     * next => 1,
     * }
     *       /online_list/6-1/
     *       next,   ,    
     */
    getOnlineList: function(cnt, next_part) {
        var me = this,
            user = me.getUser(),
            chat_room_name = user.location.get('chat_room_name');
        if (next_part) {
            chat_room_name += '-' + next_part;
        }
        me.request({
            url: '/online_list/' + chat_room_name + '/',
            method: 'GET',
            queue: false,
            success: function(result) {
                var userList = result.user_list,
                    users = me.getBasicUserModel().proxy.reader.read(userList).records,
                    chatContacts = [],
                    type, user, i;
                for (i = 0; i < users.length; i++) {
                    user = users[i];
                    type = user.getType();
                    if (type == 'user') {
                        chatContacts.push(user);
                    }
                }
                me.getChatList().scroller.catchPosition();
                //me.chatContacts.removeAll();
                me.chatContacts.loadData(chatContacts, Boolean(next_part));
                me.getChatList().scroller.restorePosition();
                if (result.next_part) {
                    me.getOnlineList(0, result.next_part);
                }
            }
        });
    }
});

/**
 *     
 */
Ext.define('ExGods.controller.Preloader', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'PreloaderCtrl:'
    },
    /**
     *   .    ,     null
     */
    getLoaderObject: function() {
        return exGodsLoader;
    },
    init: function() {
        var me = this;
        me.app.on({
            gamestarted: function() {
                this.setProgress([
                    82,
                    99
                ], ' ', 400);
            },
            scope: me
        });
        me.app.getChatConnection().on({
            beforeconnect: me.setProgress.bind(me, [
                40,
                53
            ], '   ', 400),
            connect: me.setProgress.bind(me, [
                53,
                71
            ], '  ', 400),
            presenceinit: me.setProgress.bind(me, [
                71,
                82
            ], '   ', 400),
            scope: me
        });
    },
    /**
     * @private    
     * @param {Array} percents   -
     * @param {String} msg   
     * @param {Number} animationSpeed   
     */
    setProgress: function(percents, msg, animationSpeed) {
        var me = this,
            loader = me.getLoaderObject();
        if (loader) {
            if (msg) {
                /***/
                me.log('info', msg + ' - ' + percents.join(' - ') + '%');
            }
            if (animationSpeed) {
                loader.animationSpeed = animationSpeed;
            }
            loader.setPercentage(percents[0], percents[1]);
        }
    }
});

/**
 *    
 */
Ext.define('ExGods.view.ratings.TitlePanel', {
    extend: Ext.panel.Panel,
    alias: 'widget.ratings_title',
    plugins: [
        'paperdeco'
    ],
    height: 100,
    cls: 'title',
    /**
     * @cfg  
     */
    rating: {},
    initComponent: function() {
        var me = this,
            btnText = me.rating.action;
        me.user = ExGods.app.user;
        me.items = [
            {
                layout: {
                    type: 'hbox'
                },
                items: [
                    {
                        xtype: 'panel',
                        flex: 1,
                        tpl: [
                            '<div class="exg-share-base-info" style="background-image: url({[ this.getUserImage(values.user) ]})">',
                            '<span>{[ ExGods.printUser(values.user, {fields: "name,level"})]}</span>',
                            '<span>',
                            '<tpl if="rating.rank">',
                            '<strong>{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('rating_place') + '",{place:values.rating.rank})]} </strong>',
                            '{[this.printValue(values.rating)]}',
                            '<tpl else>',
                            '<strong>' + ExGods.ref('message_client|ratings_no_rank') + '</strong>',
                            '</tpl>',
                            '</span>',
                            '<span>{rating.description}</span>',
                            '<div class="image-frame"></div>',
                            '</div>',
                            {
                                getUserImage: function(user) {
                                    return ExGods.ref('user_shape|' + user.shape).thumb;
                                },
                                printValue: function(rating) {
                                    if (rating.value || rating.value === 0) {
                                        return '(<span class="rating-value" style="background-image: url(' + IMAGE_URL + rating.value_image + ')">' + rating.value + '</span>)';
                                    } else  {
                                        return '';
                                    }
                                    
                                }
                            }
                        ],
                        data: {
                            user: me.user.data,
                            rating: me.rating
                        }
                    },
                    {
                        xtype: 'textbutton',
                        cls: 'no_border_double x-btn-txt-green',
                        text: btnText.length <= 18 ? btnText : '<span style="white-space: normal; line-height: 11px; display: block;">' + btnText + '</span>',
                        width: 150,
                        margin: '30 30 0 0',
                        handler: function() {
                            me.fireEvent('do_action');
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                ExGods.ref('user_shape|' + me.user.data.shape).thumb,
                IMAGE_URL + me.rating.value_image,
                IMAGE_URL + 'btn_green_high.png',
                IMAGE_URL + 'icons/level.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.ratings.List', {
    extend: Ext.panel.Panel,
    alias: 'widget.ratings_list',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'ratings-list',
    itemsPerPage: 7,
    textFilter: '',
    /**
     * @cfg {Array} rating 
     */
    rating: {},
    height: 266,
    initComponent: function() {
        var me = this;
        //   
        me.list = Ext.Array.sort(me.rating.top_list ? me.rating.top_list.data.ranks : [], function(a, b) {
            return a.rank - b.rank;
        });
        me.items = [
            {
                xtype: 'container',
                plugins: [
                    'paperdeco'
                ],
                height: 240,
                padding: '0 0 10 0',
                items: [
                    {
                        itemId: 'list',
                        tpl: [
                            '<tpl if="list.length">',
                            '<table class="list">',
                            '<tpl for="list">',
                            '<tr class="{[ xindex % 2 ? "exg-share-bg-light" : "exg-share-bg-dark" ]}">',
                            '<td class="place-cell">',
                            '<tpl if="rank &gt;= 1 && rank &lt;= 3">',
                            '<div class="place-{rank}"><img width="76" height="24" src="{[ this.getPlaceImage(values.rank) ]}"></div>',
                            '<tpl else>',
                            '<span>{[this.printPlace(values.rank)]}</span>',
                            '</tpl>',
                            '</td>',
                            '<td class="username-cell">',
                            '{[ ExGods.printUser(values.info, {fields: "name,rank,level,infoicon,guild"}) ]}',
                            '</td>',
                            '<td class="count-cell">',
                            '{[this.printValue(values.value)]}',
                            '</td>',
                            '</tr>',
                            '</tpl>',
                            '</table>',
                            '<tpl else>',
                            '<div class="empty-msg">' + ExGods.ref('message_client|ratings_empty_list') + '</div>',
                            '</tpl>',
                            {
                                printValue: function(value) {
                                    if (value || value === 0) {
                                        return '<span class="rating-value" style="background-image: url(' + IMAGE_URL + me.rating.value_image + ')">' + value + '</span>';
                                    } else  {
                                        return '';
                                    }
                                    
                                },
                                getPlaceImage: function(rank) {
                                    return ExGods.ref('images|rating_place_icons').image['place' + rank];
                                },
                                printPlace: function(place) {
                                    return ExGods.util.Sprite.printSprite(place, 'arena/place_numbers.png', {
                                        width: 10,
                                        height: 24,
                                        indent: '-5px',
                                        cls: 'inlineblock'
                                    }) + '<div class="place-img" style="background-image:url(' + IMAGE_URL + ExGods.getMsgByKey('place_img') + ')"></div>';
                                }
                            }
                        ],
                        data: {
                            list: me.list.slice(0, me.itemsPerPage)
                        }
                    }
                ]
            }
        ];
        me.plugins = me.plugins || [];
        me.plugins.push({
            ptype: 'pager',
            marginLeft: -27,
            marginRight: -27,
            top: 84,
            textTop: -24,
            textLeft: 326,
            total: Math.ceil(me.list.length / me.itemsPerPage)
        });
        me.listeners = {
            prev: me.updateList,
            next: me.updateList,
            scope: me
        };
        me.callParent();
    },
    updateList: function() {
        var me = this,
            items = me.filtered || me.list;
        items = items.slice((me.pager.current - 1) * me.itemsPerPage, me.pager.current * me.itemsPerPage);
        me.items.items[0].getComponent('list').update({
            arena: me.arena,
            list: items
        });
        me.pager.refresh();
    },
    setTextFilter: function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        if (me.textFilter) {
            me.filtered = Ext.Array.filter(me.list, function(item) {
                return (item.info.display_title).toLowerCase().indexOf(me.textFilter) != -1;
            });
            me.pager.total = Math.ceil(me.filtered.length / me.itemsPerPage);
        } else {
            delete me.filtered;
            me.pager.total = Math.ceil(me.list.length / me.itemsPerPage);
        }
        me.pager.current = 1;
        me.updateList();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        arr_images.concat(ExGods.ref('images|rating_place_icons').image);
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *  
 *
 * @author  
 *
 */
Ext.define('ExGods.controller.Ratings', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: true,
            error: true
        },
        prefix: 'Ratings:'
    },
    views: [
        'ExGods.view.ratings.TitlePanel',
        'ExGods.view.ratings.List'
    ],
    init: function() {
        var me = this;
        me.control({});
        //
        ExGods.Components.addComponentInitializer('ratings', me.initRatingsComponent, me);
    },
    initRatingsComponent: function(config) {
        var me = this,
            win = Ext.getCmp('RATINGS'),
            tabs = [];
        me.service = config.service;
        ExGods.app.block();
        Ext.Array.each(me.service.data.ratings, function(data) {
            tabs.push({
                tabConfig: {
                    xtype: 'skintab',
                    icon: IMAGE_URL + data.tab_image,
                    tooltip: data.description
                },
                items: [
                    {
                        xtype: 'ratings_title',
                        rating: data,
                        listeners: {
                            do_action: function() {
                                me.doRatingAction(data);
                                win.close();
                            }
                        }
                    },
                    {
                        xtype: 'ratings_list',
                        rating: data
                    }
                ]
            });
        });
        if (win)  {
            win.close();
        }
        
        win = Ext.widget('window2', {
            id: "RATINGS",
            autoShow: false,
            items: [
                {
                    layout: 'absolute',
                    items: [
                        {
                            xtype: 'skintabpanel',
                            tabUi: 'skintext',
                            items: tabs,
                            bodyPadding: '1 11 0 9',
                            cls: 'ratings',
                            listeners: {
                                tabchange: me.onTabChange
                            }
                        },
                        {
                            xtype: 'textfield',
                            x: 606,
                            y: 11,
                            width: 132,
                            height: 21,
                            style: {
                                'z-index': 1
                            },
                            emptyText: ExGods.ref('message_client|ratings_search_placeholder'),
                            itemId: 'text-search',
                            cls: 'text-search-input',
                            listeners: {
                                change: me.filterBySearch,
                                scope: me
                            },
                            value: ''
                        }
                    ]
                }
            ],
            /**
             *   
             */
            getResources: function() {
                var arr_images = [];
                Ext.Array.each(me.service.data.ratings, function(data) {
                    arr_images.push(data.tab_image);
                });
                return {
                    images: [].concat(arr_images)
                };
            }
        });
        ExGods.Resources.load(win, function() {
            win.show();
            ExGods.app.unblock();
        });
        return win;
    },
    filterBySearch: function(searchField) {
        var me = this,
            str = searchField.getValue(),
            list = Ext.getCmp('RATINGS').down('skintabpanel').getLayout().getActiveItem().down('ratings_list');
        if (list.setTextFilter) {
            list.setTextFilter(str);
        }
    },
    onTabChange: function(tabPanel, newCard, oldCard) {
        var me = this,
            searchField = tabPanel.up().down('#text-search'),
            listNew = newCard.down('ratings_list'),
            listOld = oldCard.down('ratings_list');
        searchField.setValue('');
        listNew.setTextFilter('');
        listNew.pager.hidden = 0;
        listNew.pager.refresh();
        listOld.pager.hidden = 1;
        listOld.pager.refresh();
    },
    doRatingAction: function(ratingData) {
        var me = this;
        me.service.command('ratings_map_action', {
            id: ratingData.id,
            tag: ratingData.tag,
            period: ratingData.period
        });
    }
});

/**
 *   
 */
Ext.define('ExGods.model.Robbery', {
    extend: Ext.data.Model,
    requesting: false,
    fields: [
        {
            //     .   .
            name: 'can_request',
            type: 'int'
        },
        {
            //    .   .
            name: 'can_start',
            type: 'int'
        },
        {
            //   
            name: 'can_reject',
            type: 'int'
        },
        {
            //   
            name: 'to_request',
            type: 'int'
        },
        {
            //    
            name: 'time_request',
            type: 'auto',
            convert: function(v, rec) {
                if (v) {
                    v = ExGods.util.Date.normalizeUnixTime(v);
                }
                return v;
            }
        },
        {
            //    
            name: 'to_assign',
            type: 'int'
        },
        {
            //      
            name: 'time_assign',
            type: 'auto',
            convert: function(v, rec) {
                if (v) {
                    v = ExGods.util.Date.normalizeUnixTime(v);
                }
                return v;
            }
        },
        {
            //    
            name: 'foe_list',
            type: 'auto',
            convert: function(v, rec) {
                /*** test ***/
                // for(var i = 0; i < 21; i++){
                //  var q = Ext.clone(v[0]);
                //  q.display_title += i;
                //  v.push(q);
                // }
                /*** end test ***/
                ExGods.app.getStore('RobberyFoe').loadRawData(v);
                return v;
            }
        },
        {
            //   
            name: 'list',
            type: 'auto',
            convert: function(v, rec) {
                //    1  -       
                return v ? v[0] : v;
            }
        },
        {
            //    , 
            name: 'count',
            type: 'int'
        },
        {
            //    
            name: 'request_stuff',
            type: 'auto',
            defaultValue: ''
        },
        {
            //   
            name: 'reward',
            type: 'auto',
            defaultValue: ''
        },
        {
            //   
            name: 'next_stuff',
            type: 'auto',
            defaultValue: ''
        },
        {
            //   
            name: 'desc',
            type: 'auto',
            defaultValue: ''
        }
    ]
});

/**
 *     
 */
Ext.define('ExGods.view.robbery.Foe', {
    extend: Ext.panel.Panel,
    alias: 'widget.robbery_foe',
    cls: 'enemy-info',
    plugins: [
        'paperdeco'
    ],
    height: 284,
    width: 188,
    padding: '0 10',
    initComponent: function() {
        var me = this;
        me.data = me.record.data;
        if (me.data.reward)  {
            me.data.reward.splice(2, me.data.reward.length - 1);
        }
        
        me.tpl = [
            '<div class="paper-title title">',
            '<h4>{[ExGods.ref("message_client|robbery_foe_title")]}</h4>',
            '</div>',
            '<div class="exg-share-base-info exg-share-bg-light gender-{gender}" style="background-image: url({shape})">',
            '<span>{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank", maxNameWidth: 84})]}</span>',
            '<span>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {hoard.level}</span>',
            '<tpl if="reward_extra">',
            '<span class="top_sto">{[ExGods.ref("message_client|robbery_topsto")]}</span>',
            '<div class="topsto_icon"></div>',
            '</tpl>',
            '<div class="image-frame"></div>',
            '</div>',
            '<div class="paper-separator"></div>',
            '<h5 class="exg-share-bg-dark">' + ExGods.getMsgByKey('view_battle_rewards_rewardstitle') + '</h5>',
            '<div class="foe-reward">',
            '<tpl if="reward">',
            '{[ExGods.stuff.StuffManager.image(values.reward_extra ? values.reward.concat(values.reward_extra) : values.reward)]}',
            '<tpl elseif="reward_extra">',
            '{[ExGods.stuff.StuffManager.image(values.reward_extra)]}',
            '<tpl else>',
            '{[ExGods.ref("message_client|robbery_empty_foe_reward")]}',
            '</tpl>',
            '</div>'
        ];
        me.dockedItems = [
            {
                dock: 'bottom',
                xtype: 'textbutton',
                text: ExGods.getMsgByKey('view_robbery_revenge'),
                cls: 'x-btn-txt-red no_border_double',
                margin: '0 25 35 25',
                action: 'robbery_revenge',
                itemId: 'revenge',
                can_revenge: !!me.data.online,
                disabled: !me.data.online,
                user_title: me.data.display_title
            }
        ];
        me.callParent(arguments);
    },
    getResources: function() {
        return {
            images: [
                this.record.get('shape')
            ]
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.robbery.EnemyList', {
    extend: Ext.container.Container,
    alias: 'widget.robbery_enemylist',
    layout: 'hbox',
    cls: 'robbery enemy-list',
    padding: '0 8 0 8',
    itemsPerPage: 3,
    textFilter: '',
    initComponent: function() {
        var me = this;
        me.store = ExGods.app.getStore('RobberyFoe');
        me.store.on('filterchange', me.renderFoes, me);
        me.plugins = [
            {
                ptype: 'pager',
                marginLeft: -31,
                marginRight: -31,
                top: 127,
                textTop: -32,
                textLeft: 235,
                hidden: me.store.getCount() > me.itemsPerPage ? 0 : 1,
                total: Math.ceil(me.store.getCount() / me.itemsPerPage)
            }
        ];
        me.listeners = {
            prev: me.setPagerFilter,
            next: me.setPagerFilter,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.setPagerFilter();
    },
    setPagerFilter: function() {
        var me = this,
            curPage = me.pager.current;
        me.store.removeFilter('pager');
        me.store.addFilter(Ext.util.Filter({
            filterFn: function(item) {
                var i = me.store.indexOf(item);
                //item.index  , ..    index -  
                return i >= (curPage - 1) * me.itemsPerPage && i < curPage * me.itemsPerPage;
            },
            id: 'pager'
        }));
    },
    onDestroy: function() {
        var me = this;
        me.store.removeFilter('pager');
        me.callParent(arguments);
    },
    renderFoes: Ext.Function.createBuffered(function() {
        var me = this;
        me.removeAll();
        me.store.each(function(el) {
            me.add(Ext.widget('robbery_foe', {
                record: el
            }));
        });
        if (!me.store.getTotalCount()) {
            me.add(Ext.widget('panel', {
                width: '100%',
                height: '100%',
                html: '<div class="robbery-foe-empty">' + ExGods.ref('message_client|robbery_foe_empty_text') + '</div>'
            }));
        }
        me.pager.hidden = me.pager.total > 1 ? 0 : 1;
        me.pager.refresh();
    }, 200),
    setTextFilter: Ext.Function.createBuffered(function(str) {
        var me = this;
        me.textFilter = (Ext.String.trim(str)).toLowerCase();
        me.store.removeFilter('pager');
        if (me.textFilter) {
            me.store.removeFilter('pager');
            me.store.addFilter(Ext.util.Filter({
                filterFn: function(item) {
                    return item.get('display_title').toLowerCase().indexOf(me.textFilter) != -1;
                },
                id: 'text'
            }));
        } else {
            me.store.removeFilter('text');
        }
        me.pager.total = Math.ceil(me.store.getCount() / me.itemsPerPage);
        me.pager.current = 1;
    }, 500),
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *       
 */
Ext.define('ExGods.model.RobberyFoe', {
    extend: Ext.data.Model,
    fields: [
        {
            //    
            name: 'add_time',
            type: 'string'
        },
        {
            //  
            name: 'binding',
            type: 'auto'
        },
        {
            // 
            name: 'display_title',
            type: 'string'
        },
        {
            // 
            name: 'gender',
            type: 'string'
        },
        {
            // 
            name: 'hoard',
            type: 'auto'
        },
        {
            //  
            name: 'online',
            type: 'int'
        },
        {
            // 
            name: 'race',
            type: 'string'
        },
        {
            //    
            name: 'reward',
            type: 'auto'
        },
        {
            //    
            name: 'reward_extra',
            type: 'auto'
        },
        {
            // 
            name: 'shape',
            type: 'string',
            convert: function(v, rec) {
                var shape = ExGods.ref('user_shape|' + v);
                return shape ? shape.thumb : v;
            }
        }
    ]
});

/**
 *  -        
 */
Ext.define('ExGods.view.robbery.EnemyInfo', {
    extend: Ext.panel.Panel,
    alias: 'widget.robbery_enemy',
    initComponent: function() {
        var me = this;
        me.data = me.config.data;
        me.groupLoot();
        me.data.list.loot = me.loot;
        ExGods.helpme.loadProtos(me.loot, 'params.id', function() {
            me.protosLoaded = true;
            me.addLoot();
        });
        me.tpl = [
            // ,   float:right,          
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="robbery-enemy">',
            '<div class="loot-info">',
            '<div class="paper-title title">',
            '<h4>{[ExGods.ref("message_client|robbery_rewards_title")]}</h4>',
            '</div>',
            '<p class="description exg-share-bg-light">{[ExGods.ref("message_client|robbery_enemy_desc")]}</p>',
            '<div class="loot exg-share-bg-dark">{[ExGods.stuff.StuffManager.image(values.reward || [])]}</div>',
            '<div class="exg-share-bg-dark" id="robbery-text-buttons"></div>',
            '</div>',
            '<div class="v-separator"></div>',
            '<div class="enemy">',
            '<div class="paper-title title">',
            '<h4>{[ExGods.ref("message_client|robbery_enemy_title")]}</h4>',
            '</div>',
            '<div class="exg-share-base-info exg-share-bg-light" style="background-image: url({[ this.getUserImage(values.list) ]})">',
            '<span>{[ ExGods.printUser(values.list, {fields: "name,rank", maxNameWidth: 112})]}</span>',
            '<span>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {list.hoard.level}</span>',
            '<div class="image-frame"></div>',
            '</div>',
            '<div class="paper-separator"></div>',
            '<h5 class="exg-share-bg-dark">' + ExGods.getMsgByKey('view_arena_arena_enemy_params') + '</h5>',
            '<div class="stats1 exg-share-bg-light">',
            '{[ ExGods.util.User.printUserStats(values.list.stats.stats, {visibleValue: 1, align: "right", changes: this.getStatsChanges(values.list.stats.stats)}) ]}',
            '</div>',
            '<div class="paper-separator"></div>',
            '<h5 class="exg-share-bg-dark">{[this.getMask(values.list.mask_proto_id)]}</h5>',
            '<div class="stats2 exg-share-bg-light">',
            '{[ ExGods.util.User.printUserStats(values.list.stats.stats, {visibleValue: 2, changes: this.getStatsChanges(values.list.stats.stats)}) ]}',
            '</div>',
            '</div>',
            '</div>',
            {
                getMask: function(proto_id) {
                    var proto = ExGods.app.getItemPrototypesStore().findRecord('entry', proto_id);
                    if (proto)  {
                        return proto.get('title');
                    }
                    
                },
                getUserImage: function(data) {
                    return ExGods.ref('user_shape|' + data.shape).thumb;
                },
                getStatsChanges: function(stats) {
                    //    
                    var changes = {},
                        myStats = ExGods.app.user.get('stats').stats;
                    Ext.Object.each(stats, function(k, v) {
                        if (typeof myStats[k] != 'undefined') {
                            changes[k] = v - myStats[k];
                        }
                    });
                    return changes;
                }
            }
        ];
        me.callParent();
    },
    groupLoot: function(data) {
        var me = this,
            loot = {};
        data = data || me.data;
        me.loot = [];
        me.protosLoaded = false;
        Ext.Array.each(data.list.loot, function(item) {
            if (loot[item.proto_id]) {
                loot[item.proto_id].params.quantity++;
            } else {
                loot[item.proto_id] = {
                    params: {
                        id: item.proto_id,
                        quantity: 1
                    },
                    item: item,
                    type: 'item'
                };
            }
        });
        Ext.Object.each(loot, function(k, v) {
            me.loot.push(v);
        });
    },
    afterRender: function() {
        var me = this;
        me.renderButtons();
        me.addLoot();
        me.callParent(arguments);
    },
    //ExGods.util.Ticker.addListener(me.updateAssignTime, me);
    addLoot: function() {
        var me = this;
        if (!me.protosLoaded || !me.rendered)  {
            return;
        }
        
        var loot = (me.loot.length || me.robbery.get('reward').length) ? ExGods.stuff.StuffManager.image((me.robbery.get('reward') || []).concat(me.loot)) : '<div class="robbery-enemy-empty">' + ExGods.ref('message_client|robbery_enemy_empty_reward') + '</div>';
        me.el.down('.loot').dom.innerHTML = loot;
    },
    renderButtons: function() {
        var me = this,
            time_assign = me.robbery.get('time_assign'),
            to_assign = me.robbery.get('to_assign'),
            time = Math.max(0, to_assign * 1000 - (Date.now() - time_assign)),
            stuff = me.robbery.get('next_stuff').stuff,
            fn = function() {
                me.accept_task.disable();
                me.decline_task.disable();
            };
        var cfg = [
                {
                    text: ExGods.getMsgByKey('view_robbery_startbattle'),
                    //  <span id="robbery-assign-time">'+ExGods.util.Time.printTime(time/1000, {format: 'detailed', emptyText: '..'})+'</span>',
                    cls: 'qh-object x-btn-txt-red no_border_double',
                    itemId: 'accept_task',
                    width: 160,
                    renderTo: 'robbery-text-buttons',
                    listeners: {
                        click: fn
                    }
                },
                {
                    text: ExGods.getMsgByKey('view_robbery_newsearch') + ' ' + ExGods.util.Stuff.printStuff(stuff),
                    disabled: !ExGods.app.getUser().checkStuff(stuff),
                    cls: 'no_border_double',
                    itemId: 'decline_task',
                    width: 160,
                    style: {
                        'float': 'right'
                    },
                    renderTo: 'robbery-text-buttons',
                    listeners: {
                        click: fn
                    }
                }
            ];
        Ext.Array.each(cfg, function(params) {
            me[params.itemId] = Ext.widget('textbutton', params);
            me[params.itemId].el.set({
                'data-qh_otype': 'robbery_button_battle',
                'data-qh_oid': '1'
            });
        });
    },
    updateAssignTime: function() {
        var me = this,
            time_assign = me.robbery.get('time_assign'),
            to_assign = me.robbery.get('to_assign'),
            time = Math.max(0, to_assign * 1000 - (Date.now() - time_assign));
        try {
            me.el.down('#robbery-assign-time').setHTML(ExGods.util.Time.printTime(time / 1000, {
                format: 'detailed',
                emptyText: '..'
            }));
        } catch (e) {}
        
    },
    onDestroy: function() {
        var me = this;
        //ExGods.util.Ticker.removeListener(me.updateAssignTime);
        me.callParent(arguments);
    },
    updateData: function(data) {
        var me = this;
        me.groupLoot(data);
        data.list.loot = me.loot;
        me.update(data);
        me.renderButtons();
        ExGods.helpme.loadProtos(me.loot, 'params.id', function() {
            me.protosLoaded = true;
            me.addLoot();
        });
    }
});

/**
 *  -        
 */
Ext.define('ExGods.view.robbery.Search', {
    extend: Ext.panel.Panel,
    alias: 'widget.robbery_search',
    cls: 'robbery-search',
    loading: false,
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser();
        var masksTpl = [
                '<div class="masks-tpl">',
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title title">',
                '<h4>{desc.title}</h4>',
                '</div>',
                '<p class="description">{desc.desc}</p>',
                '<div class="masks-container exg-share-bg-dark">',
                '<div class="masks">{[this.printMasks(values.desc.masks)]}</div>',
                '</div>',
                '</div>'
            ];
        var searchTpl = [
                '<div class="search-tpl">',
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<tpl if="time_request">',
                '<div class="robbery-nums"><div class="nums">{[this.printQueueNums(values)]}</div></div>',
                '<div class="robbery-queue">',
                '<div class="robbery-timer" style="width:{[this.printQueueTime(values)]}px"></div>',
                '</div>',
                '<tpl else>',
                '<div class="first-page-text">{[ExGods.ref("message_client|robbery_first_page")]}</div>',
                '</tpl>',
                '</div>',
                '<div class="timed-place" id="timed-place"></div>'
            ];
        var tplFunctions = [
                {
                    printQueueNums: function(data) {
                        var to_request = parseInt(data.to_request, 10),
                            time = Math.max(0, to_request * 1000 - (Date.now() - data.time_request)) / 1000;
                        return ExGods.util.Time.printTime(time, {
                            format: 'bignums'
                        });
                    },
                    printQueueTime: function(data) {
                        var to_request = parseInt(data.to_request, 10),
                            time = Math.max(0, to_request * 1000 - (Date.now() - data.time_request)) / 1000,
                            percent = time / to_request;
                        return data.time_request ? Math.round((1 - percent) * 232) : 0;
                    },
                    //return ExGods.util.Time.printTime(time, {format: 'detailed', emptyText: '..'})
                    printMasks: function(masks) {
                        var masksHtmls = [],
                            store = ExGods.app.getItemPrototypesStore();
                        Ext.Array.each(masks, function(mask) {
                            var proto = store.findRecord('entry', mask.params.id);
                            masksHtmls.push('<div class="info-box-itembox item exgtip" data-proto_id="' + mask.params.id + '" data-exgtip_type="proto_item" data-exgtip_value="' + mask.params.id + '" id="maskid_' + mask.params.id + '">' + '<div class="mask_frm"></div>' + '<img class="image on" src="' + proto.get('images').on + '" width="50" height="50">' + '<div class="notify_i"></div>' + '<div class="x-clear"></div>' + '</div>');
                        });
                        return masksHtmls.join('<div class="arrow"></div>');
                    },
                    printTimed: function(request_stuff) {
                        var type;
                        Ext.Array.each(request_stuff, function(item) {
                            if (item.type == 'timed')  {
                                type = item.params.id;
                            }
                            
                        });
                        var timed = ExGods.app.user.get('timed')[type],
                            time = timed ? timed[3] : undefined;
                        if (!time)  {
                            return '';
                        }
                        
                        time = new Date(time) - new Date();
                        return ExGods.util.Time.printTime(time / 1000, {
                            format: 'threenums'
                        });
                    },
                    checkOpacity: function(request_stuff) {
                        var type;
                        Ext.Array.each(request_stuff, function(item) {
                            if (item.type == 'timed')  {
                                type = item.params.id;
                            }
                            
                        });
                        var timed = ExGods.app.user.get('timed')[type],
                            time = timed ? timed[3] : undefined;
                        return (type && time) ? '' : ' style="opacity:0"';
                    }
                }
            ];
        me.tpl = masksTpl.concat(searchTpl).concat(tplFunctions);
        me.data = me.config.data;
        me.callParent();
        me.mon(me.robbery, 'update', function(data) {
            me.timedtimer.setEnable();
            me.cancelbtn.disable();
            me.timedtimer[data.time_request ? 'hide' : 'show']();
            me.cancelbtn[data.time_request ? 'show' : 'hide']();
        });
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.renderBtns();
        ExGods.util.Ticker.addListener(me.updateQueueTime, me);
    },
    renderBtns: function() {
        var me = this,
            timed,
            quantity = 1;
        try {
            timed = me.robbery.get('request_stuff')[0].params.id;
            quantity = me.robbery.get('request_stuff')[0].params.quantity;
        } catch (e) {}
        
        me.timedtimer = Ext.widget('timedtimer', {
            renderTo: 'timed-place',
            textbutton: {
                itemId: 'get_task',
                listeners: {
                    click: function() {
                        me.timedtimer.setDisable();
                    }
                }
            },
            qh: {
                'data-qh_otype': 'robbery_button_battle',
                'data-qh_oid': '1'
            },
            timed: timed,
            quantity: quantity,
            hidden: !!me.robbery.get('time_request')
        });
        me.cancelbtn = Ext.widget('textbutton', {
            renderTo: 'timed-place',
            text: ExGods.getMsgByKey('view_robbery_search_cancelbtntext'),
            cls: 'double_text_btn',
            itemId: 'cancel_search',
            hidden: !me.robbery.get('time_request'),
            disabled: true,
            listeners: {
                click: function() {
                    this.disable();
                }
            }
        });
    },
    updateQueueTime: function() {
        var me = this,
            viewEl = me.getEl(),
            time_request = me.robbery.get('time_request'),
            to_request = me.robbery.get('to_request'),
            can_reject = me.robbery.get('can_reject'),
            type, timed,
            time = 0,
            el, nums, percent;
        if (time_request && viewEl) {
            el = viewEl.down('.robbery-timer');
            nums = viewEl.down('.nums');
            time = Math.max(0, to_request * 1000 - (Date.now() - time_request)) / 1000;
            width = Math.round((1 - time / to_request) * 232);
            if (time === 0)  {
                me.robbery.set('time_request', 0);
            }
            
            if (el)  {
                el.animate({
                    width: width
                });
            }
            
            if (nums)  {
                nums.setHTML(ExGods.util.Time.printTime(time, {
                    format: 'bignums'
                }));
            }
            
            // ,    
            if (can_reject && time < to_request - can_reject && !me.robbery.requesting) {
                me.cancelbtn.enable();
            }
        }
    },
    updateData: function(data) {
        var me = this;
        me.update(data);
        ExGods.Resources.load(me, function() {
            me.renderBtns();
        });
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateReadyTime);
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [],
            store = ExGods.app.getItemPrototypesStore();
        var stdRbr = me.robbery.get('request_stuff');
        stuff_arr = stuff_arr.concat(stdRbr);
        stuff_arr = stuff_arr.concat(me.data.reward);
        if (me.data.desc.img) {
            arr_images.push(me.data.desc.img);
        }
        Ext.Array.each(me.data.desc.masks, function(mask) {
            var proto = store.findRecord('entry', mask.params.id);
            var imgs = proto.get('images');
            for (var it in imgs) {
                arr_images.push(imgs[it]);
            }
        });
        return {
            images: [
                stdRbr
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.store.RobberyFoe', {
    extend: Ext.data.Store,
    model: 'ExGods.model.RobberyFoe',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            sorterFn: function(a, b) {
                return a.add_time > b.add_time;
            }
        }
    ]
});

/**
 *  
 *
 * @author  
 *
 */
Ext.define('ExGods.controller.Robbery', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: false,
            error: false
        },
        prefix: 'Robbery:'
    },
    models: [
        'Robbery',
        'RobberyFoe'
    ],
    stores: [
        'RobberyFoe'
    ],
    views: [
        'robbery.EnemyList',
        'robbery.EnemyInfo',
        'robbery.Search',
        'robbery.Foe',
        'TimedTimer'
    ],
    refs: [
        {
            /**
         * @method getRobberySearch
         */
            ref: 'robberySearch',
            selector: 'robbery_search'
        },
        {
            /**
         * @method getRobberyContainer
         */
            ref: 'robberyContainer',
            selector: '#robbery'
        }
    ],
    loadingMasks: false,
    isRobberyBattle: false,
    init: function() {
        var me = this;
        me.control({
            '#accept_task': {
                click: me.onAcceptButtonClick
            },
            '#decline_task': {
                click: me.onDeclineTaskClick
            },
            '#get_task': {
                click: me.onGetTaskClick
            },
            '#cancel_search': {
                click: me.onCancelSearchClick
            },
            'textbutton[action="robbery_revenge"]': {
                click: me.onRevengeButtonClick
            },
            'battleresult': {
                close: me.showRobbery
            }
        });
        me.app.chatcn.on('command_robbery', me.onRobberyChatCommand, me);
        me.app.chatcn.on('robbery', me.onRobberyChatCommand, me);
        ExGods.Components.addComponentInitializer('robbery', me.initRobberyComponent, me);
    },
    /**
     *    
     */
    initRobberyComponent: function(config, componentId) {
        var me = this,
            cmp,
            icons = ExGods.ref('images|robbery_icons').image,
            data = config.service.data.robbery,
            wnd;
        /*** test user data***/
        // var json = '{"battle_id":"1000181900","time_assign":1425639565,"count":1,"to_assign":45,"message":"   ","list":[{"loot":[{"features":[],"action":null,"slot_id":"3063","param":{"features":[],"dur":1,"item_value":null,"nonrep":"1","nonbr":"1","nonsale":"1"},"proto_id":"1343","item_id":"13129"},{"features":[],"action":null,"slot_id":"3064","param":{"features":[],"dur":17,"item_value":null,"taxable":null,"nonrep":"1","nonbr":"0","nonsale":"0"},"proto_id":"1398","item_id":"13184"}],"mask_proto_id":"1343","stats":{"stats":{"damage":15,"hp":34,"agility":0,"shield":43,"mp":100,"strength":0,"stamina":0,"fury":9,"accuracy":0}},"is_bot":0,"mask_id":"9","race":"2","shape":"as_m","hoard":{"level":"2","rank":null},"gender":"1","display_title":"exorel"}]}'
        // data = Ext.apply(data,JSON.parse(json));
        // data.time_assign = parseInt(Date.now()/1000) + 360;
        /*** end test ***/
        me.service = config.service;
        me.service.on('update', me.onServiceUpdate, me);
        me.robbery = Ext.create('ExGods.model.Robbery', data);
        /***/
        me.log('  ""', data);
        Ext.apply(config, {
            rightPanelX: 177,
            closeCallback: function() {
                ExGods.loaderCt.loadAndRemove(function() {
                    wnd.close();
                }, {
                    img: config.backgroundImage
                });
            },
            margin: '0 10 10 0',
            items: [
                {
                    xtype: 'skintabpanel',
                    items: [
                        {
                            xtype: 'container',
                            itemId: 'robbery',
                            layout: 'fit',
                            margin: '0 8 8 8',
                            style: {
                                position: 'relative'
                            },
                            tabConfig: {
                                //tooltip: arena.data.label,
                                tooltip: ExGods.getMsgByKey('robbery_search_tooltip'),
                                icon: icons.search_tab
                            }
                        },
                        {
                            xtype: 'robbery_enemylist',
                            robbery: me.robbery.data,
                            tabConfig: {
                                tooltip: ExGods.getMsgByKey('robbery_enemy_list_tooltip'),
                                icon: icons.foes_tab
                            }
                        }
                    ],
                    width: 580,
                    height: 363,
                    y: 10,
                    x: 250,
                    plugins: [
                        'skindeco'
                    ],
                    closable: true,
                    listeners: {
                        beforeclose: {
                            fn: function() {
                                ExGods.loaderCt.loadAndRemove(function() {
                                    wnd.close();
                                }, {
                                    img: config.backgroundImage
                                });
                                return false;
                            }
                        },
                        tabchange: me.onTabChange,
                        scope: me
                    }
                },
                {
                    xtype: 'form',
                    x: 645,
                    y: 20,
                    width: 152,
                    height: 30,
                    tbar: {
                        xtype: 'panel',
                        bodyCls: 'parchment-content-nop',
                        bodyPadding: 0,
                        defaults: {
                            margin: '0 1'
                        },
                        height: 30,
                        items: [
                            {
                                xtype: 'textfield',
                                emptyText: ExGods.getMsgByKey('robbery_search_empty_text'),
                                itemId: 'text-search',
                                hidden: true,
                                cls: 'text-search-input',
                                listeners: {
                                    change: me.filterBySearch,
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            }
                        ],
                        layout: 'hbox',
                        margin: '0 0 5 0'
                    }
                }
            ]
        });
        me.cmp = Ext.apply({
            xtype: 'room'
        }, config);
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            items: [
                me.cmp
            ],
            getResources: function() {
                return {
                    images: [
                        config.backgroundImage
                    ]
                };
            }
        });
        me.cmp = wnd.down('room');
        me.cmp.on('render', function() {
            if (me.loadingMasks) {
                me.on('masks_loaded', me.setState, me, {
                    single: true
                });
            } else  {
                me.setState();
            }
            
        }, me);
        me.loadingMasks = true;
        ExGods.app.getController('Location').maskLocation(function() {
            ExGods.helpme.loadProtos(data.desc.masks.concat(data.request_stuff || []).concat(data.reward || []).concat(data.reward_extra || []), 'params.id', function() {
                me.loadingMasks = false;
                me.fireEvent('masks_loaded');
                //  
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.backgroundImage
        });
        return wnd;
    },
    setState: function() {
        var me = this,
            data = me.robbery.data,
            container = me.getRobberyContainer();
        if (!container)  {
            return;
        }
        
        if (data.list) {
            ExGods.app.getItemPrototypesStore().loadNew([
                data.list.mask_proto_id
            ], function() {
                if (me.robbery_search)  {
                    container.remove(me.robbery_search);
                }
                
                if (me.robbery_enemyinfo) {
                    me.robbery_enemyinfo.updateData(data);
                } else {
                    me.robbery_enemyinfo = container.add(Ext.widget('robbery_enemy', {
                        data: data,
                        robbery: me.robbery,
                        listeners: {
                            destroy: function() {
                                me.robbery_enemyinfo = undefined;
                            }
                        }
                    }));
                }
            });
        } else {
            if (me.robbery_enemyinfo)  {
                container.remove(me.robbery_enemyinfo);
            }
            
            if (me.robbery_search) {
                me.robbery_search.updateData(data);
            } else {
                var srch = Ext.widget('robbery_search', {
                        data: data,
                        autoShow: false,
                        robbery: me.robbery,
                        listeners: {
                            destroy: function() {
                                me.robbery_search = undefined;
                            }
                        }
                    });
                ExGods.Resources.load(srch, function() {
                    me.robbery_search = container.add(srch);
                });
            }
        }
    },
    onGetTaskClick: function() {
        var me = this;
        me.robbery.requesting = true;
        me.service.command('robbery_request', {}, function(json) {
            me.robbery.requesting = false;
            if (json.next_stuff) {
                me.robbery.set('next_stuff', json.next_stuff);
            }
        });
    },
    onCancelSearchClick: function() {
        var me = this;
        me.robbery.requesting = true;
        if (me.robbery.get('can_reject')) {
            me.service.command('robbery_reject', {}, function() {});
        }
    },
    //me.robbery.requesting = false;
    onDeclineTaskClick: function() {
        this.robbery.set('list', undefined);
        this.onGetTaskClick();
    },
    onAcceptButtonClick: function(btn) {
        var me = this;
        me.service.command('robbery_start', {}, function(json) {
            if (json.success) {
                me.isRobberyBattle = me.service.id;
            }
        });
    },
    onRevengeButtonClick: function(btn) {
        var me = this;
        /***/
        me.log('  ');
        me.robbery.requesting = true;
        me.setButtonsDisable([
            'revenge'
        ], true);
        me.service.command('robbery_foe', {
            title: btn.user_title
        }, function(json) {
            if (json.success) {} else //   
            {
                me.setButtonsDisable([
                    'revenge'
                ], false);
            }
            me.robbery.requesting = false;
        });
    },
    onRobberyChatCommand: Ext.Function.createBuffered(function(chatcn, data) {
        var me = this,
            search = me.getRobberySearch();
        data = data.body.data;
        /***/
        me.log('   ""  ', data);
        var keys = Ext.Object.getKeys(data);
        // robbery ,     ,     
        if (me.robbery) {
            if (keys.length == 1 && keys[0] == 'message') {
                me.robbery.requesting = true;
                me.service.update();
            } else {
                me.onServiceUpdate(me.service, data);
            }
        }
        if (data.message) {
            me.app.getViewportController().onLogMessage(data.message);
        }
    }, 300),
    onServiceUpdate: function(service, data) {
        var me = this;
        data = data.robbery ? data.robbery : data;
        if (!data.time_request)  {
            data.time_request = 0;
        }
        
        if (!data.list)  {
            data.list = undefined;
        }
        
        if (!data.time_assign)  {
            data.time_assign = 0;
        }
        
        if (me.robbery) {
            me.robbery.set(data);
            me.robbery.requesting = false;
            me.robbery.fireEvent('update', data);
        }
        me.setState();
    },
    onTabChange: function(panel, tab) {
        var me = this,
            searchField = me.cmp.down('#text-search');
        if (tab.xtype == 'robbery_enemylist') {
            searchField.el.select('input').elements[0].value = tab.textFilter || '';
            //      
            searchField.show();
        } else {
            searchField.hide();
        }
    },
    showRobbery: function() {
        var me = this;
        if (me.isRobberyBattle && ExGods.app.user.getSetting('reopen_interface') == 1) {
            ExGods.ClientActions.createAndInvoke({
                actionId: me.isRobberyBattle
            }, null, function(err) {
                /***/
                me.log('error', err);
            });
            me.isRobberyBattle = false;
        }
    },
    filterBySearch: function(searchField) {
        var me = this,
            str = searchField.getValue(),
            tabs = me.cmp.query('tabpanel')[0],
            tab = tabs.getActiveTab();
        if (tab.setTextFilter) {
            tab.setTextFilter(str);
        }
    },
    setButtonsDisable: function(btnNames, disabled) {
        var me = this,
            query;
        if (me.cmp) {
            Ext.Array.each(btnNames, function(btn) {
                Ext.Array.each(Ext.ComponentQuery.query('#' + btn), function(btn) {
                    if (!btn.can_revenge)  {
                        return;
                    }
                    
                    btn[disabled ? 'disable' : 'enable']();
                });
            });
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.Settings', {
    extend: Ext.panel.Panel,
    alias: 'widget.usersettings',
    padding: '0 10 13 5',
    plugins: [
        'scroller'
    ],
    cls: 'user_settings',
    initComponent: function() {
        var me = this,
            ourUserModel = ExGods.app.user,
            arrayOfCat = me.arrayOfCat,
            formForTabPanel = [],
            checkboxCount = 0;
        for (var j = 0; j < arrayOfCat.groups.length; j++) {
            checkboxCount = 0;
            var arrayOfGroups = {
                    xtype: 'form',
                    defaults: {
                        labelAlign: 'right',
                        labelWidth: 180,
                        width: 550,
                        msgTarget: 'under'
                    },
                    costs: [],
                    buttonAlign: 'center',
                    items: []
                };
            if (j != 0)  {
                arrayOfGroups.items.push({
                    xtype: 'label',
                    isFormField: false,
                    html: [
                        '<div class="parchment-separator"></div>',
                        '<div class="paper-title"><b>' + arrayOfCat.groups[j].nameGroup + '</b></div>'
                    ]
                });
            }
            else  {
                arrayOfGroups.items.push({
                    xtype: 'label',
                    isFormField: false,
                    html: [
                        '<div class="paper-title"><b>' + arrayOfCat.groups[j].nameGroup + '</b></div>'
                    ]
                });
            }
            
            var next_change, setting;
            //      
            for (var k = 0; k < arrayOfCat.groups[j].data.length; k++) {
                next_change = undefined;
                setting = ourUserModel.get('settings')[arrayOfCat.groups[j].data[k].name];
                if (setting && setting.next_change) {
                    next_change = ExGods.util.Date.normalizeServerDateTime(setting.next_change);
                    if (next_change <= new Date()) {
                        next_change = undefined;
                    }
                }
                switch (arrayOfCat.groups[j].data[k].type) {
                    case 'list':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 20 10 200',
                                xtype: 'radiogroup',
                                fieldLabel: arrayOfCat.groups[j].data[k].label,
                                allowBlank: false,
                                columns: 1,
                                layout: 'vbox',
                                labelAlign: 'top',
                                vertical: true,
                                name: arrayOfCat.groups[j].data[k].name,
                                items: (function(variants) {
                                    var items = [];
                                    Ext.Array.each(variants, function(variant, index) {
                                        items.push({
                                            boxLabel: variant.label,
                                            inputValue: variant.value,
                                            name: arrayOfCat.groups[j].data[k].name,
                                            checked: (ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name) == variant.value ? true : false)
                                        });
                                    });
                                    return items;
                                }(arrayOfCat.groups[j].data[k].defaultItem.list))
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                    case 'combo':
                        var store = Ext.create('Ext.data.Store', {
                                fields: [
                                    'label',
                                    'value'
                                ],
                                data: arrayOfCat.groups[j].data[k].defaultItem.combo
                            });
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 20 10 110',
                                width: 500,
                                labelWidth: 250,
                                xtype: 'combo',
                                ui: 'guild',
                                fieldLabel: arrayOfCat.groups[j].data[k].label,
                                store: store,
                                queryMode: 'local',
                                valueField: 'value',
                                displayField: 'label',
                                name: arrayOfCat.groups[j].data[k].name,
                                value: ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name)
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                    case 'flag':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 15 12 204',
                                xtype: 'checkboxfield',
                                inputValue: '1',
                                uncheckedValue: '0',
                                boxLabel: arrayOfCat.groups[j].data[k].label,
                                name: arrayOfCat.groups[j].data[k].name,
                                checked: +ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name, arrayOfCat.groups[j].data[k].name)
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        checkboxCount++;
                        break;
                    case 'volume':
                    case 'number':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 20',
                                xtype: 'numberfield',
                                hideTrigger: true,
                                fieldLabel: arrayOfCat.groups[j].data[k].label,
                                name: arrayOfCat.groups[j].data[k].name,
                                value: +ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name, arrayOfCat.groups[j].data[k].name)
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                    case 'string':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 20',
                                xtype: 'textfield',
                                fieldLabel: arrayOfCat.groups[j].data[k].label,
                                name: arrayOfCat.groups[j].data[k].name,
                                value: ourUserModel.getSetting(arrayOfCat.groups[j].data[k].name, arrayOfCat.groups[j].data[k].name)
                            };
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                    case 'passwd':
                        var item = {
                                disabled: Boolean(next_change),
                                margin: '10 10 0 75',
                                xtype: 'fieldcontainer',
                                name: arrayOfCat.groups[j].data[k].name,
                                defaults: {
                                    labelAlign: 'right',
                                    labelWidth: 180,
                                    width: 475
                                },
                                items: [
                                    {
                                        xtype: 'textfield',
                                        margin: '10',
                                        fieldLabel: ExGods.getMsgByKey('view_user_settings_oldpass'),
                                        name: 'current',
                                        isFormField: false,
                                        inputType: 'password'
                                    },
                                    {
                                        xtype: 'textfield',
                                        margin: '10',
                                        fieldLabel: ExGods.getMsgByKey('view_user_settings_newpass'),
                                        name: 'new',
                                        isFormField: false,
                                        inputType: 'password'
                                    },
                                    {
                                        xtype: 'textfield',
                                        margin: '10',
                                        fieldLabel: ExGods.getMsgByKey('view_user_settings_newpassconfirm'),
                                        name: 'new2',
                                        isFormField: false,
                                        inputType: 'password',
                                        msgTarget: 'under',
                                        fieldStyle: 'margin-bottom: 10px'
                                    },
                                    //       (. markInvalid  fielfcontainer)
                                    {
                                        xtype: 'hidden',
                                        name: arrayOfCat.groups[j].data[k].name,
                                        getSubmitValue: function() {
                                            var me = this,
                                                fieldCt = me.up('fieldcontainer'),
                                                value = [];
                                            fieldCt.items.each(function(item) {
                                                if (item != me && item.getValue) {
                                                    value.push(item.getValue());
                                                }
                                            });
                                            return value;
                                        }
                                    }
                                ],
                                markInvalid: function(msg) {
                                    var lastField = this.query('[name="new2"]')[0];
                                    lastField.markInvalid(msg);
                                    //        .
                                    lastField.inputEl.removeCls('x-form-invalid-field');
                                }
                            };
                        //      , .     
                        me.addToCotst(arrayOfCat.groups[j].data[k].costs, arrayOfGroups.costs);
                        arrayOfGroups.items.push(item);
                        break;
                }
                if (next_change) {
                    arrayOfGroups.items.push({
                        xtype: 'displayfield',
                        fieldLabel: '',
                        value: ExGods.app.applyTpl(ExGods.getMsgByKey('setting_comment'), {
                            time: ExGods.util.Timers.printRestTimer('setting-next-change-' + arrayOfCat.groups[j].data[k].name, next_change)
                        }),
                        name: 'comment',
                        margin: '10 20 10 110',
                        width: 500,
                        labelWidth: 0,
                        fieldStyle: {
                            textAlign: 'center'
                        }
                    });
                }
            }
            arrayOfGroups.buttons = [
                {
                    xtype: 'textbutton',
                    cls: 'no_border',
                    action: 'save',
                    text: arrayOfGroups.costs.length ? ExGods.app.applyTpl(ExGods.getMsgByKey('settings_cost_btn_msg'), {
                        costs: arrayOfGroups.costs
                    }) : ExGods.getMsgByKey('settings_free_btn_msg'),
                    margin: '0 0 20 0',
                    costs: arrayOfGroups.costs
                }
            ];
            if (arrayOfCat.groups[j].data.length == checkboxCount) {
                //        
                var items = arrayOfGroups.items;
                arrayOfGroups.items = [
                    items[0]
                ];
                // label
                for (var i = 0; i < checkboxCount; i += 2) {
                    if (items[i + 2]) {
                        items[i + 1].width = items[i + 2].width = 335;
                        items[i + 1].style = {
                            'text-align': 'right'
                        };
                        items[i + 2].style = {
                            'text-align': 'left'
                        };
                        items[i + 1].margin = '10 30 12 0';
                        items[i + 2].margin = '10 0 12 30';
                        arrayOfGroups.items.push({
                            xtype: 'panel',
                            layout: 'hbox',
                            width: 700,
                            items: [
                                items[i + 1],
                                items[i + 2]
                            ]
                        });
                    } else {
                        items[i + 1].width = 700;
                        items[i + 1].style = {
                            'text-align': 'center'
                        };
                        items[i + 1].margin = '10 0 12 0';
                        arrayOfGroups.items.push({
                            xtype: 'panel',
                            layout: 'hbox',
                            width: 700,
                            items: [
                                items[i + 1]
                            ]
                        });
                    }
                }
            }
            var formWihtParchmentdeco = {
                    xtype: 'form',
                    margin: '0',
                    items: arrayOfGroups
                };
            //                  plugins: [
            //                      {
            //                          //ptype: 'parchmentdeco',
            //                      }
            //                  ]
            formForTabPanel.push(formWihtParchmentdeco);
        }
        // panel   scroller    panel
        me.items = {
            xtype: 'panel',
            header: false,
            autoScroll: true,
            items: formForTabPanel,
            bodyPadding: '7 10 13 10',
            plugins: [
                'paperdeco'
            ]
        };
        arrayOfGroups.costs = undefined;
        me.callParent(arguments);
        ourUserModel.on('setting_change', function(name, value) {
            var el = me.down('[name="' + name + '"]');
            if (el && el.setValue)  {
                el.setValue(value);
            }
            
        });
    },
    //  "" ,  id    
    //   ,    
    addToCotst: function(costs, arrayOfCosts) {
        //   
        for (var i = 0; i < costs.length; i++) {
            for (var x = 0; x < arrayOfCosts.length; x++) {
                if (costs[i].name === arrayOfCosts[x].name) {
                    arrayOfCosts[x].value = arrayOfCosts[x].value + costs[i].value;
                    break;
                }
            }
            //   .
            if (x === arrayOfCosts.length) {
                arrayOfCosts.push(Ext.clone(costs[i]));
            }
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [
                IMAGE_URL + 'shop/btn_buy.png'
            ].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.controller.Settings', {
    extend: ExGodsCore.controller.Base,
    views: [
        'user.Settings'
    ],
    init: function(app) {
        var me = this;
        me.control({
            'usersettings button[action="save"]': {
                click: me.isCostSetting
            }
        });
        me.service = ExGods.Services.get('settings');
        ExGods.Components.addComponentInitializer('settings', me.initSettingsComponent, me);
    },
    /**
     * @private
     */
    createSettingsTabPanel: function(arrayOfCat) {
        //items     items  tabPanel
        var items = [];
        // usersettings - form      
        for (var i = 0; i < arrayOfCat.length; i++) {
            var panel = {
                    xtype: 'usersettings',
                    arrayOfCat: arrayOfCat[i],
                    tabConfig: {
                        icon: ExGods.ref('images|settings_images').image.tab,
                        tooltip: arrayOfCat[i].cat
                    },
                    getResources: function() {
                        var me = this,
                            arr_images = [];
                        var images_ = ExGods.ref('images|settings_images').image;
                        for (var i in images_) {
                            arr_images.push(images_[i]);
                        }
                        return {
                            stuff: [],
                            images: [
                                IMAGE_URL + 'shop/btn_buy.png'
                            ].concat(arr_images)
                        };
                    }
                };
            items.push(panel);
        }
        var tabPanel = {
                xtype: 'skintabpanel',
                tabUi: 'skintext',
                id: 'settings-tabs',
                items: items
            };
        return tabPanel;
    },
    isCostSetting: function(button) {
        var me = this;
        if (button.costs.length) {
            //    -   
            Ext.widget('confirmdialog', {
                message: ExGods.app.applyTpl(ExGods.getMsgByKey('settings_cost_confirmation'), button),
                handler: function() {
                    me.saveSettingsFromForm(button);
                }
            });
        } else {
            //    ,    
            me.saveSettingsFromForm(button);
        }
    },
    saveSettingsFromForm: function(button) {
        var me = this,
            settings = button.up('form').getValues(),
            form = button.up('form'),
            panel = button.up('usersettings'),
            user = this.getUser();
        ExGods.util.Helper.maskElement(panel.getEl());
        me.saveSettings(settings, function(json) {
            var errors = [];
            Ext.iterate(json.result || {}, function(key, value) {
                errors.push(value);
            });
            if (errors.length) {
                me.application.fireEvent('logmessage', errors.join(', '));
            } else {
                me.application.fireEvent('logmessage', ExGods.app.applyTpl(ExGods.getMsgByKey('settings_are_applied')));
            }
            me.fireEvent('settings_saved', json.result);
            panel.getEl().unmask();
        });
    },
    saveSettings: function(settings, cb) {
        var user = this.getUser(),
            me = this;
        me.service.command('save_setting', {
            setting: Ext.encode(settings)
        }, function(result) {
            if (result.success) {
                if (cb) {
                    cb(result);
                }
            }
        });
    },
    initSettingsComponent: function(config, componentId) {
        var me = this,
            wnd;
        //     
        var me = this,
            settings = me.service.data.settings;
        arrayOfCat = [] , user = me.getUser() , panel = Ext.getCmp('settings') , //       
        //     form
        splitIntoCat = function(array, item) {
            // .
            var user = ExGods.app.user,
                data = {
                    label: item.label,
                    defaultItem: item['default'],
                    type: item.type,
                    name: item.name,
                    entry: item.entry,
                    costs: item.params.costs
                },
                group = {
                    nameGroup: item.group,
                    data: [
                        data
                    ]
                },
                obj = {
                    cat: item.cat,
                    groups: [
                        group
                    ]
                };
            //        
            //,       
            for (var i = 0; i < array.length; i++) {
                if (item.cat === array[i].cat) {
                    //    ,  ,    ,
                    // ,    
                    for (var j = 0; j < array[i].groups.length; j++) {
                        if (item.group === array[i].groups[j].nameGroup) {
                            array[i].groups[j].data.push(data);
                            return true;
                        }
                    }
                    array[i].groups.push(group);
                    return true;
                }
            }
            array.push(obj);
        };
        if (panel) {
            panel.hide();
        }
        //    ""
        settingsAsArray = settings.sort(function(a, b) {
            return (a.order - b.order);
        });
        //   
        Ext.Array.each(settingsAsArray, function(item) {
            //      
            if (user.data.settings[item.name]) {
                splitIntoCat(arrayOfCat, item);
            }
        });
        panel = me.createSettingsTabPanel(arrayOfCat);
        wnd = Ext.widget('window2', {
            id: componentId,
            closeAction: 'hide',
            items: [
                panel
            ],
            autoShow: false
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
        });
        return wnd;
    }
});

/**
 *   . 
 *
 * @author Oleg Mikhailov
 */
Ext.define('ExGods.mixin.Sociable', {
    /**
     * @property initialized {Boolean}  
     */
    initialized: false,
    /**
     *  SDK .
     */
    initSDK: function() {
        var me = this;
        me.initialized = true;
        me.callParent(arguments);
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          url: <  >,
     *          image: <url  >,
     *          title: <>,
     *          description: <>
     *      }
     */
    share: function(obj) {},
    // 
    /**
     *     
     *
     * @param {Number}  
     */
    buy: function(preset) {},
    // 
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          image: <url  >,
     *          message: <>
     *          owner: <id      .  ,      >
     *      }
     */
    wallPost: function(obj) {},
    //
    /**
     *       
     */
    simpleWallPost: function(obj) {},
    //
    /**
     *    
     */
    invite: function(callback) {},
    //
    /**
     *  
     */
    gift: function(preset) {},
    //
    /**
     * ,       
     */
    isCanUsePromo: function(callback) {
        callback(false);
    },
    /**
     *    -
     * @param presetEntry {Number}
     * @param callback {Function} . 
     */
    usePromo: function(presetEntry, callback) {},
    //
    /**
     * ,        . (  )
     */
    isCanSendUserToUserMessage: function() {
        return false;
    },
    /**
     *       (  )
     * @param to {Array}  ids 
     * @param message {String}
     * @param callback {Function} 
     */
    sendUserToUserMessage: function(to, message, callback) {},
    //
    /**
     *   
     */
    setSize: function(width, height) {}
});
//

/**
 *   .  VK
 */
Ext.define('ExGods.controller.social.VK', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'VK:'
    },
    /**
     *  .     SDK .
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: '//vk.com/js/api/xd_connection.js?2',
            onLoad: function() {
                VK.init(function() {
                    me.initialized = true;
                });
            }
        });
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          url: <  >,
     *          image: <url  >,
     *          title: <>,
     *          description: <>
     *      }
     */
    share: function(obj) {
        var url = 'http://vkontakte.ru/share.php?' + Ext.Object.toQueryString(obj);
        window.open(url, 'share', 'width=600,height=400');
    },
    /**
     *     
     *
     * @param {Number}  
     */
    buy: function(preset) {
        var me = this,
            app = me.application,
            user = app.user;
        function onOrderSuccess() {
            VK.removeCallback('onOrderSuccess', onOrderSuccess);
            me.request({
                url: '/game.pl?cmd=money&item=1',
                method: 'POST'
            });
        }
        VK.addCallback('onOrderSuccess', onOrderSuccess);
        function onOrderCancel() {
            VK.removeCallback('onOrderCancel', onOrderCancel);
        }
        VK.addCallback('onOrderCancel', onOrderCancel);
        //    votes
        VK.callMethod('showOrderBox', {
            type: 'item',
            item: preset.entry
        });
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          image: <url  >,
     *          message: <>
     *          owner: <id      .  ,      >
     *      }
     */
    wallPost: function(obj, callback) {
        var me = this,
            user = me.user;
        VK.api('photos.getWallUploadServer', function(result) {
            me.request({
                url: '/vka.pl',
                params: {
                    cmd: 'wallupload',
                    url: result.response.upload_url,
                    image: obj.image
                },
                success: function(result) {
                    VK.api('photos.saveWallPhoto', result.response, function(result) {
                        var photo = result.response[0].id;
                        var params = {
                                message: obj.message + ' http://vk.com/app' + config.user.payment_app + '_' + user.get('social').social_net_id + '#msg_id' + getUID(),
                                attachments: photo
                            };
                        if (obj.owner)  {
                            params.owner_id = obj.owner;
                        }
                        
                        VK.api('wall.post', params, function(result) {
                            if (result.response && result.response.post_id) {
                                if (callback) {
                                    callback();
                                }
                            } else {}
                        });
                    });
                }
            });
        });
    },
    // me.application.fireEvent('socialwallcanceled');
    /**
     *       
     */
    simpleWallPost: function(obj, callback) {
        var me = this,
            user = me.user;
        var params = {
                message: obj.message + ' http://vk.com/app' + config.user.payment_app + '_' + user.get('social').social_net_id + '#msg_id' + getUID()
            };
        if (obj.owner)  {
            params.owner_id = obj.owner;
        }
        
        VK.api('wall.post', params, function(result) {
            if (result.response && result.response.post_id) {
                if (callback) {
                    callback();
                }
            } else {}
        });
    },
    // me.application.fireEvent('socialwallcanceled');
    /**
     *    
     */
    invite: function(callback) {
        var me = this,
            allFriends, appFriends, noAppFriends,
            userList = [],
            onListLoad = function() {
                if (allFriends && appFriends) {
                    cleanList();
                    prepareUsersFromFriends();
                    showDialog();
                }
            },
            cleanList = function() {
                for (var i = 0; i < allFriends.length; i++) {
                    if (appFriends.indexOf(allFriends[i].uid) != -1) {
                        allFriends[i] = null;
                    }
                }
                noAppFriends = Ext.Array.clean(allFriends);
            },
            prepareUsersFromFriends = function() {
                var defaults = {
                        hoard: me.user.data.hoard
                    };
                noAppFriends.forEach(function(friend) {
                    userList.push(Ext.apply({}, {
                        display_title: friend.first_name + ' ' + friend.last_name,
                        shape: {
                            small: friend.photo_50
                        },
                        gender: friend.sex == 1 ? 2 : 1,
                        social: friend.uid
                    }, defaults));
                });
            },
            showDialog = function() {
                ExGods.Components.factory('USER_TARGET_PANEL', {
                    windowTitle: ExGods.getMsgByKey('invite_friends_window_title'),
                    users: userList,
                    listeners: {
                        select: function(wnd, rec) {
                            //    
                            me.wallPost({
                                image: IMAGE_URL + ExGods.getMsgByKey('invite_friends_image_url'),
                                message: ExGods.getMsgByKey('invite_friends_message'),
                                owner: rec.data.social
                            }, function() {
                                if (callback) {
                                    callback();
                                }
                            });
                            wnd.up().close();
                        }
                    }
                });
            };
        //   
        VK.api('friends.get', {
            fields: 'nickname, domain, sex, photo_50'
        }, function(result) {
            if (result.response && Ext.isArray(result.response)) {
                allFriends = result.response;
                onListLoad();
            }
        });
        //   ,    
        VK.api('friends.getAppUsers', {}, function(result) {
            if (result.response && Ext.isArray(result.response)) {
                appFriends = result.response;
                onListLoad();
            }
        });
    },
    /**
     *  
     */
    gift: function(preset) {},
    //
    /**
     *   
     */
    setSize: function(width, height) {
        VK.callMethod("resizeWindow", width, height);
    }
});

/**
 *   .  OK
 */
Ext.define('ExGods.controller.social.OK', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'OK:'
    },
    /**
     *  SDK .
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: config.user.apiserver + 'js/fapi5.js',
            onLoad: function() {
                FAPI.init(config.user.apiserver, config.user.apiconnection, function() {
                    FAPI.Client.initialize();
                    FAPI.PrepareStreamPublish = function(message) {
                        var rm = message.message;
                        if (rm.length > 99) {
                            rm = rm.substr(0, 96) + " ...";
                        }
                        var params = {
                                "application_key": config.user.payment_app,
                                "session_key": config.user.payment_key,
                                "format": 'JSON',
                                "method": "stream.publish",
                                "message": message.subject,
                                attachment: Ext.encode({
                                    "caption": rm,
                                    "media": [
                                        {
                                            //"href": "link",
                                            "src": "/" + message.image_rel,
                                            "type": "image"
                                        }
                                    ]
                                })
                            };
                        var sig = FAPI.Util.calcSignature(params, config.user.secret_key);
                        FAPI.PrepareStreamPublish.params4send = params;
                        return sig;
                    };
                    FAPI.PrepareStreamPublish.params4send = {};
                    self.API_callback = function(method, result, data) {
                        if (method == 'showConfirmation' && result == 'ok') {
                            //FAPI.PrepareStreamPublish.params["resig"] = data;
                            FAPI.Client.call(FAPI.PrepareStreamPublish.params4send, function(status, data, error) {
                                if (status == 'ok') {
                                    me.application.fireEvent('socialwallposted');
                                } else {
                                    console.log("status: ", status);
                                    console.log("data: ", data);
                                    console.log("error: ", error);
                                }
                            }, //   (  )
                            data);
                        }
                    };
                    me.initialized = true;
                }, function(error) {
                    alert("API initialization failed");
                });
            }
        });
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          url: <  >,
     *          image: <url  >,
     *          title: <>,
     *          description: <>
     *      }
     */
    share: function(obj) {
        var url = 'http://www.odnoklassniki.ru/dk?st.cmd=addShare&st.s=1000&st._surl=' + encodeURIComponent('http://' + location.host + '/ok.pl?title=' + obj.title + '&description=' + obj.description + '&image=' + obj.image + '&url=' + obj.url);
        window.open(url, 'share', 'width=600,height=400');
    },
    /**
     *     
     *
     * @param {Number}  
     */
    buy: function(preset) {
        var me = this,
            app = me.application,
            user = app.user,
            plurals = preset.game_currency == 'gold' ? ExGods.getMsgByKey('gold_name').split(',') : ExGods.getMsgByKey('crystal_name').split(',');
        FAPI.UI.showPayment(Ext.util.Format.number(preset.count, '0,0') + ' ' + Ext.util.Format.plural(preset.count, plurals), '', preset.entry, preset.price, null, null, 'ok', 'true');
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          image: <url  >,
     *          message: <>
     *      }
     */
    wallPost: function(obj) {
        var me = this,
            user = me.user;
        if (obj.owner) {
            FAPI.UI.showInvite(obj.message, '', obj.owner);
        } else {
            var sig = FAPI.PrepareStreamPublish(obj);
            FAPI.UI.showConfirmation('stream.publish', Ext.String.format(ExGods.getMsgByKey("social_ok_confirm_text"), obj.subject), sig);
        }
    },
    /**
     *       
     */
    simpleWallPost: function(obj) {
        var me = this,
            user = me.user;
        if (obj.owner) {
            FAPI.UI.showInvite(obj.message, false, obj.owner);
        } else {
            var sig = FAPI.PrepareStreamPublish(obj);
            FAPI.UI.showConfirmation('stream.publish', Ext.String.format(ExGods.getMsgByKey("social_ok_confirm_text"), obj.subject), sig);
        }
    },
    /**
     *    
     */
    invite: function(callback) {},
    //
    /**
     *  
     */
    gift: function(preset) {},
    //
    /**
     *   
     */
    setSize: function(width, height) {
        FAPI.UI.setWindowSize(width, height);
    }
});

/**
 *   .  MM
 */
Ext.define('ExGods.controller.social.MM', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'MM:'
    },
    /**
     *  SDK .
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: 'https://connect.mail.ru/js/loader.js',
            onLoad: function() {
                mailru.loader.require('api', function() {
                    mailru.app.init(config.user.payment_key);
                    me.initialized = true;
                });
            }
        });
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          url: <  >,
     *          image: <url  >,
     *          title: <>,
     *          description: <>
     *      }
     */
    share: function(obj) {
        var url = 'http://connect.mail.ru/share?' + Ext.Object.toQueryString(obj);
        window.open(url, 'share', 'width=600,height=400');
    },
    /**
     *     
     *
     * @param {Number}  
     */
    buy: function(preset) {
        var me = this,
            app = me.application,
            user = app.user;
        mailru.events.listen(mailru.app.events.incomingPayment, function(event) {
            //       
            me.request({
                url: '/game.pl?cmd=money&item=1',
                method: 'POST'
            });
        });
        mailru.app.payments.showDialog({
            service_id: preset.entry,
            service_name: Ext.util.Format.money(preset.count, 'crystal'),
            mailiki_price: preset.price
        });
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          image: <url  >,
     *          message: <>
     *      }
     */
    wallPost: function(obj) {
        var me = this,
            user = me.user;
        mailru.events.remove(mailru.common.events.streamPublish);
        mailru.events.listen(mailru.common.events.streamPublish, function(event) {
            switch (event.status) {
                case 'publishSuccess':
                    // me.application.fireEvent('socialwallposted'); //    -  callback
                    break;
                case 'publishFail':
                    // me.application.fireEvent('socialwallcanceled');
                    break;
                case 'closed':
                    // me.application.fireEvent('socialwallcanceled');
                    break;
                default:
                    break;
            }
            
        });
        mailru.common.stream.post({
            title: obj.subject,
            text: obj.message,
            img_url: obj.image,
            action_links: [
                {
                    text: ExGods.getMsgByKey('social_link_title'),
                    href: '1'
                }
            ]
        });
    },
    /**
     *       
     */
    simpleWallPost: function(obj) {
        var me = this,
            user = me.user;
        mailru.events.remove(mailru.common.events.streamPublish);
        mailru.events.listen(mailru.common.events.streamPublish, function(event) {
            switch (event.status) {
                case 'publishSuccess':
                    // me.application.fireEvent('socialwallposted'); //    -  callback
                    break;
                case 'publishFail':
                    // me.application.fireEvent('socialwallcanceled');
                    break;
                case 'closed':
                    // me.application.fireEvent('socialwallcanceled');
                    break;
                default:
                    break;
            }
            
        });
        if (obj.owner) {
            mailru.common.guestbook.post({
                uid: obj.owner,
                title: obj.subject,
                text: obj.message,
                action_links: [
                    {
                        text: ExGods.getMsgByKey('social_link_title'),
                        href: '1'
                    }
                ]
            });
        } else {
            mailru.common.stream.post({
                title: obj.subject,
                text: obj.message,
                action_links: [
                    {
                        text: ExGods.getMsgByKey('social_link_title'),
                        href: '1'
                    }
                ]
            });
        }
    },
    /**
     *    
     */
    invite: function(callback) {},
    //
    /**
     *  
     */
    gift: function(preset) {},
    //
    /**
     *   
     */
    setSize: function(width, height) {
        mailru.app.utils.setHeight(height);
    }
});

/**
 *         
 */
Ext.define('ExGods.view.social.socialVoting.stuff.RewardsVote', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.view.dialog.stuff.decorator.RewardFrame);
        return data;
    }
});

/**
 *   
 *
 * @author  
 */
Ext.define('ExGods.view.social.socialVoting.Vote', {
    extend: Ext.panel.Panel,
    alias: 'widget.socialvotingpanel',
    id: 'VotePanelFB',
    /** @cfg */
    clientConfig: {},
    stuff: [],
    plugins: [],
    initComponent: function() {
        var me = this;
        me.clientConfig.you_get_reward;
        if (me.myParams.hasVoted) {
            me.hasVoted = me.myParams.hasVoted;
        }
        if (me.myParams.curVote) {
            me.curVote = me.myParams.curVote;
        }
        me.config = Ext.applyIf(me.clientConfig || {}, me.defaultConfig);
        me.items = [
            {
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                plugins: [
                    'paperdeco'
                ],
                padding: "0 0 0 0",
                margin: '7 8 4 6 ',
                items: [
                    {
                        width: '100%',
                        height: 130,
                        style: {
                            'text-align': 'center'
                        },
                        data: {},
                        tpl: [
                            '<div class="socialVoteBlock">',
                            '<div class="socialVoteBlock-content">',
                            '<div class="dialog-rewards-stuff">',
                            '<div class="paper-title"><h4>' + me.clientConfig.vote_text + '</h4></div>',
                            '<div class="stuff">' + '<div class="quest-giver-border">',
                            '<div class="quest-giver-image" style="background-image:url(' + IMAGE_URL + me.clientConfig.img_in_descr + '); "></div>',
                            '</div>',
                            '<p class="vote-game-text">' + me.clientConfig.description + '</p>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>'
                        ]
                    },
                    {
                        width: '100%',
                        height: 210,
                        id: 'socialVoteRewardBlock',
                        style: {
                            'text-align': 'center'
                        },
                        listeners: {
                            render: function() {
                                ///      
                                //    
                                function setCurSelectedRatingVote(data_id, force) {
                                    if (force != true) {
                                        if (me.hasVoted && me.hasVoted === true) {
                                            return;
                                        }
                                    }
                                    for (var i = 0; i <= 4; i++) {
                                        if (i <= data_id) {
                                            Ext.get('social-vote-star' + i).addCls('social-vote-star-on');
                                        } else {
                                            Ext.get('social-vote-star' + i).removeCls('social-vote-star-on');
                                        }
                                    }
                                    if (data_id == 0) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_terrible);
                                    }
                                    if (data_id == 1) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_bad);
                                    }
                                    if (data_id == 2) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_normal);
                                    }
                                    if (data_id == 3) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_good);
                                    }
                                    if (data_id == 4) {
                                        Ext.get("social-vote-status-text").setHTML(me.clientConfig.status_great);
                                    }
                                }
                                
                                Ext.query('.social-vote-star').forEach(function(dom) {
                                    setCurSelectedRatingVote(me.curVote, true);
                                    el = Ext.get(dom);
                                    el.on('mouseenter', function(e, target) {
                                        if (me.hasVoted && me.hasVoted === true) {
                                            return;
                                        }
                                        setCurSelectedRatingVote(target.getAttribute("data-id"));
                                    });
                                    el.on('click', function(e, target) {
                                        if (me.hasVoted && me.hasVoted === true) {
                                            return;
                                        }
                                        me.curVote = target.getAttribute("data-id");
                                    });
                                });
                                //       , 
                                //    
                                Ext.get('social-vote-star-wrpr').on('mouseleave', function(e, target) {
                                    if (me.hasVoted && me.hasVoted === true) {
                                        return;
                                    }
                                    setCurSelectedRatingVote(me.curVote);
                                });
                            },
                            afterrender: function() {
                                var me_xtype = this,
                                    socialVoteBtn = 0,
                                    socialVoteTakeRewardBtn = 0;
                                ExGods.util.Helper.renderComponents(me_xtype.el, me_xtype);
                                socialVoteBtn = Ext.getCmp('socialVoteBtn');
                                socialVoteTakeRewardBtn = Ext.getCmp('socialVoteTakeRewardBtn');
                                if (me.hasVoted == true) {
                                    socialVoteBtn.setDisabled(1);
                                    socialVoteTakeRewardBtn.setDisabled(0);
                                    Ext.get('voteHaveVotedImg').addCls('voteHaveVotedImgOk');
                                }
                                //  
                                socialVoteBtn.on('click', function() {
                                    if (this.isDisabled() || (me.hasVoted && me.hasVoted === true)) {
                                        return;
                                    }
                                    if (me.curVote >= 3) {
                                        var cmpFB = Ext.widget('socialvotingpanelFBWindow', {
                                                clientConfig: me.clientConfig,
                                                myParams: {
                                                    hasVoted: true,
                                                    curVote: me.curVote,
                                                    clientConfig: me.clientConfig,
                                                    componentId: me.componentId
                                                }
                                            });
                                        var wnd = Ext.widget('window2', {
                                                id: 'socialvotingpanelFBWindowId',
                                                cls: 'votingWindowFB',
                                                width: 828,
                                                height: 416,
                                                autoShow: false,
                                                items: [
                                                    cmpFB
                                                ]
                                            });
                                        var VotePanelFBImage = Ext.getCmp('VotePanelFBImage');
                                        ExGods.Resources.load(VotePanelFBImage, function() {
                                            wnd.show();
                                            Ext.get('floaterBlockFBAnim').show();
                                        });
                                    } else //      
                                    {
                                        me.hasVoted = true;
                                        Ext.getCmp('socialVoteBtn').setDisabled(1);
                                        Ext.get('voteHaveVotedImg').addCls('voteHaveVotedImgOk');
                                        Ext.getCmp('socialVoteTakeRewardBtn').setDisabled(0);
                                    }
                                });
                                //         
                                if (socialVoteTakeRewardBtn) {
                                    socialVoteTakeRewardBtn.on('click', function() {
                                        var args = Array.prototype.concat.apply([
                                                'onTakeRewardButton',
                                                me_xtype,
                                                me
                                            ], arguments);
                                        me_xtype.fireEvent.apply(me_xtype, args);
                                    });
                                }
                            },
                            beforedestroy: function() {
                                var me = this;
                                ExGods.util.Helper.destroyComponents(me.el);
                            }
                        },
                        data: {},
                        tpl: [
                            '<div class="paper-separator paper-separator-voting"></div>',
                            '<div class="socialVoteBlock">',
                            '<div class="socialVoteBlock-content">',
                            '<div class="dialog-rewards-stuff">',
                            '<div class="paper-title">',
                            '<h4>' + '{[this.methodGetImgRewardText()]}',
                            '</h4>',
                            '</div>',
                            '<div class="stuff">',
                            '<div class="social-vote-block-wrapper social-vote-block-wrapper1">',
                            '<div class="social-vote-block-bottom-top">',
                            '<div id="social-vote-star-wrpr" class="social-vote-star-wrpr">',
                            '<span id="social-vote-star0" class="social-vote-star " data-id="0"></span>',
                            '<span id="social-vote-star1" class="social-vote-star " data-id="1"></span>',
                            '<span id="social-vote-star2" class="social-vote-star " data-id="2"></span>',
                            '<span id="social-vote-star3" class="social-vote-star " data-id="3"></span>',
                            '<span id="social-vote-star4" class="social-vote-star" data-id="4"></span>',
                            '</div>',
                            '<span id="social-vote-status-text" class="social-vote-status-text">' + me.clientConfig.status_great + '</span>',
                            '</div>',
                            '<div class="social-vote-block-bottom-bottom">',
                            '<div class="component">',
                            '<span role="xtype">textbutton</span>',
                            '<span role="id">socialVoteBtn</span>',
                            '<span role="text">',
                            me.clientConfig.you_vote,
                            '</span>',
                            '<span role="cls">double_text_btn social-vote-btn</span>',
                            '<span role="flex:int">1</span>',
                            '<span role="margin">3 5 0 0</span>',
                            '</div>',
                            '<div id="voteHaveVotedImg" class="vote-have-voted-img"></div>',
                            '</div>',
                            '</div>',
                            '<div class="social-vote-block-wrapper social-vote-block-wrapper2">',
                            '<div class="social-voting-arror-right"></div>',
                            '</div>',
                            '<div class="social-vote-block-wrapper social-vote-block-wrapper3">',
                            '<div class="social-vote-block-bottom-top social-vote-block-bottom-top-right">',
                            '<div class="social-vote-block-right-img">',
                            '{[this.methodGetImgReward()]}',
                            '</div>',
                            '</div>',
                            '<div class="social-vote-block-bottom-bottom">',
                            '<div class="component">',
                            '<span role="xtype">textbutton</span>',
                            '<span role="id">socialVoteTakeRewardBtn</span>',
                            '<span role="text">',
                            me.clientConfig.you_get_reward,
                            '</span>',
                            '<span role="cls">double_text_btn social-vote-btn</span>',
                            '<span role="flex:int">1</span>',
                            '<span role="margin">3 5 0 0</span>',
                            '<span role="disabled:bool">1</span>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>',
                            '</div>',
                            {
                                methodGetImgReward: function() {
                                    if (!Ext.isArray(me.clientConfig.reward)) {
                                        me.clientConfig.reward = [
                                            me.clientConfig.reward
                                        ];
                                    }
                                    var img_stuff_html = Ext.Array.map(me.clientConfig.reward, function(stuff) {
                                            return ExGods.stuff.StuffManager.image({
                                                type: 'dialog_social_vote',
                                                params: {
                                                    stuff: stuff
                                                }
                                            });
                                        }).join('');
                                    return img_stuff_html;
                                },
                                methodGetImgRewardText: function() {
                                    var img_stuff_html = ExGods.app.applyTpl(me.clientConfig.vote_and_get_rewards, {
                                            reward: ExGods.stuff.StuffManager.print(me.clientConfig.reward)
                                        });
                                    return img_stuff_html;
                                }
                            }
                        ]
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            stuff: me.clientConfig.reward,
            images: [
                IMAGE_URL + 'dialog_vote/star_big_empty.png',
                IMAGE_URL + 'dialog_vote/star_big.png',
                IMAGE_URL + 'mask/arrow.png',
                IMAGE_URL + 'icons/undone.png',
                IMAGE_URL + 'icons/done.png',
                IMAGE_URL + 'dialog/item_slot.png',
                //   
                IMAGE_URL + me.clientConfig.img_in_descr,
                me.clientConfig.you_vote,
                me.clientConfig.you_get_reward
            ]
        };
    }
});

/**
 *   ,   
 *
 * @author  
 */
Ext.define('ExGods.view.social.socialVoting.VoteFBLink', {
    extend: Ext.panel.Panel,
    alias: 'widget.socialvotingpanelFBWindow',
    id: 'VotePanelFBImage',
    /** @cfg */
    clientConfig: {},
    stuff: [],
    plugins: [],
    initComponent: function() {
        var me = this;
        hasVoted = false;
        me.config = Ext.applyIf(me.clientConfig || {}, me.defaultConfig);
        //  ,      
        me.floaterBlock = Ext.create('Ext.Component', {
            x: 715,
            y: 400,
            autoShow: false,
            id: 'floaterBlockFBAnim',
            renderTo: Ext.getBody(),
            html: '<div class="socialVoteFacebook"></div>',
            style: 'position:absolute; z-index: 3333 ; display: none',
            listeners: {
                render: function() {
                    var me_xtype = this;
                    me_xtype.el.on('click', function() {
                        var args = Array.prototype.concat.apply([
                                'click',
                                me_xtype,
                                me
                            ], arguments);
                        me_xtype.fireEvent.apply(me_xtype, args);
                    });
                }
            }
        });
        me.items = [
            {
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                padding: "0 0 0 0",
                margin: '7 8 4 6 ',
                items: [
                    {
                        xtype: 'component',
                        height: 500,
                        html: '<div id="votingWindowFBGrandImageId" class="votingWindowFBGrandImage"></div>',
                        id: 'votingWindowFBGrandImageIdClc',
                        listeners: {
                            render: function() {
                                var me_xtype = this;
                                me_xtype.el.on('click', function() {
                                    var args = Array.prototype.concat.apply([
                                            'click',
                                            me_xtype,
                                            me
                                        ], arguments);
                                    me_xtype.fireEvent.apply(me_xtype, args);
                                });
                            },
                            destroy: function() {
                                var me_xtype = this;
                                var args = Array.prototype.concat.apply([
                                        'onDestroyWnd',
                                        me_xtype,
                                        me
                                    ], arguments);
                                me_xtype.fireEvent.apply(me_xtype, args);
                            }
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'dialog_vote/fb_bg.png',
                IMAGE_URL + 'dialog_vote/fb_rate_popup.png'
            ]
        };
    }
});

/**
 *   .  FB
 */
Ext.define('ExGods.controller.social.FB', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'FB:'
    },
    views: [
        'ExGods.view.social.socialVoting.Vote',
        'social.socialVoting.VoteFBLink'
    ],
    init: function() {
        var me = this;
        ExGods.stuff.StuffManager.register({
            'dialog_social_vote': ExGods.view.social.socialVoting.stuff.RewardsVote
        });
        me.control({
            '#votingWindowFBGrandImageIdClc': {
                click: me.onimageFBClick,
                onDestroyWnd: me.onDestroyWndFB
            },
            '#floaterBlockFBAnim': {
                click: me.onimageFBClick
            },
            '#socialVoteRewardBlock': {
                onTakeRewardButton: me.onTakeRewardButtonFB
            }
        });
        ExGods.Components.addComponentInitializer('social_voting', me.initSocialVoteComponent, me);
    },
    /**
     *      
     */
    initSocialVoteComponent: function(config, componentId) {
        var me = this;
        var myParams = {
                hasVoted: false,
                curVote: 4
            };
        //config.reward = config.reward[0]; // 1  
        //config.reward.pop();              // 2  
        me.FBVoteParams = myParams;
        var wnd = me.createVoteWindow(config, componentId, myParams);
        //   
        //ExGods.util.Helper.loadProtosFromStuff(config.reward, function() {    
        //wnd.show();
        //});
        var pnlRes = Ext.getCmp('VotePanelFB');
        //   
        //  
        ExGods.Resources.load(pnlRes, function() {
            wnd.show();
        });
        return wnd;
    },
    /**
     *  SDK .
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: 'https://connect.facebook.net/en_EN/sdk.js',
            onLoad: function() {
                FB.init({
                    appId: config.social.fba,
                    version: config.social.fba_version,
                    status: true,
                    cookie: true
                });
                FB.Event.subscribe('auth.authResponseChange', function() {
                    //   
                    FB.api('/me/?fields=currency', function(data) {
                        if (!data || data.error) {} else //
                        {
                            FB.userCurrency = data.currency;
                        }
                    });
                });
                //   app events  
                Ext.Loader.loadScript({
                    url: 'https://api.mkt.2rll.net/static/fb_log_event.js',
                    onLoad: function() {
                        InitAppLogEvent(config.social.fba);
                    }
                });
                me.initialized = true;
            }
        });
    },
    /**
     *    
     *     
     *
     * @param {Object} thisCls  this  xtype 
     * @param {Object} meView  this  
     */
    onimageFBClick: function(thisCls, meView) {
        var me = this;
        //        facebook
        // ...
        //
        window.open(meView.myParams.clientConfig.linkFB, '_blank');
        this.onDestroyWndFB(thisCls, meView);
        var wndSc = Ext.getCmp('socialvotingpanelFBWindowId');
        wndSc.close();
        var myParams = {
                hasVoted: true,
                curVote: meView.myParams.curVote
            };
        var wnd = me.createVoteWindow(meView.myParams.clientConfig, meView.myParams.componentId, myParams);
        wnd.show();
    },
    /**
     *   ,  .
     *   100 
     *
     * @param {Object} thisCls  this  xtype 
     * @param {Object} meView  this  
     */
    onTakeRewardButtonFB: function(thisCls, meView) {
        var me = this;
        //   
        Ext.getCmp('socialVoteTakeRewardBtn').setDisabled(1);
        ExGods.Services.get('special_deal').command('use_special_deal', {
            specialdeal: meView.clientConfig.special_deal_name,
            action: meView.clientConfig.special_deal_action
        }, function(data) {
            if (data.success) {
                //      
                var wnd_ = Ext.getCmp('SOCIAL_VOTE');
                wnd_.close();
            } else {
                //   ,  
                Ext.getCmp('socialVoteTakeRewardBtn').setDisabled(0);
            }
        });
    },
    /**
     *    
     *
     * @param {Object} thisCls  this  xtype 
     * @param {Object} meView  this  
     *
     */
    onDestroyWndFB: function(thisCls, meView) {
        if (meView.floaterBlock) {
            meView.floaterBlock.destroy();
        }
    },
    /**
     *     
     *
     * @param {Object} config    
     * @param {string} componentId   
     * @param {Object} myParams    
     *
     */
    createVoteWindow: function(config, componentId_, myParams_) {
        var cmp = Ext.widget('socialvotingpanel', {
                clientConfig: config,
                componentId: componentId_,
                myParams: myParams_
            });
        var wnd = Ext.widget('window2', {
                id: componentId_,
                cls: 'votingWindow',
                width: 566,
                height: 356,
                autoShow: false,
                items: [
                    cmp
                ]
            });
        return wnd;
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          url: <  >,
     *          image: <url  >,
     *          title: <>,
     *          description: <>
     *      }
     */
    share: function(obj) {
        FB.ui(obj);
    },
    /*, callback*/
    /**
     *     
     *
     * @param {Number}  
     */
    buy: function(preset) {
        var me = this;
        FB.ui({
            method: 'pay',
            action: 'purchaseitem',
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&preset_id=' + preset.entry + '&r=' + Math.random(),
            quantity: 1
        }, function(data) {});
    },
    //
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          image: <url  >,
     *          message: <>
     *          owner: <id      .  ,      >
     *      }
     */
    wallPost: function(obj) {
        var me = this,
            feedData = {
                method: 'feed',
                link: 'https://apps.facebook.com/' + config.social.fba + '/',
                picture: obj.image,
                caption: obj.subject,
                description: obj.message
            };
        if (obj.owner) {
            feedData.to = obj.owner;
        }
        FB.ui(feedData, function(response) {});
    },
    //
    /**
     *       
     */
    simpleWallPost: function(obj) {
        var me = this,
            user = me.user;
        FB.ui({
            method: 'feed',
            link: location.href,
            caption: obj.subject,
            description: obj.message
        }, function(response) {});
    },
    //
    /**
     *    
     */
    invite: function(callback) {
        var me = this;
        //   
        FB.api("/me/invitable_friends", function(response) {
            if (response && !response.error) {
                //     
                var users = [],
                    defaults = {
                        hoard: me.user.data.hoard
                    };
                response.data.forEach(function(friendData) {
                    users.push(Ext.apply({}, {
                        display_title: friendData.name,
                        shape: {
                            small: friendData.picture.data.url
                        },
                        social: friendData.id
                    }, defaults));
                });
                //       
                ExGods.Components.factory('USER_TARGET_PANEL', {
                    componentCls: 'fb-invite-list',
                    windowTitle: ExGods.getMsgByKey('invite_friends_window_title'),
                    users: users,
                    listeners: {
                        select: function(wnd, rec) {
                            //  
                            FB.ui({
                                method: 'apprequests',
                                message: ExGods.getMsgByKey('invite_friends_message'),
                                to: rec.data.social
                            }, function(response) {
                                if (response && response.error_code) {} else //
                                {
                                    callback();
                                }
                            });
                            wnd.up().close();
                        }
                    }
                });
            } else {
                /***/
                me.log('error', '      ', response);
            }
        });
    },
    /**
     *  
     */
    gift: function(preset) {
        var me = this;
        FB.ui({
            method: 'gift',
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&gift=1&preset_id=' + preset.entry + '&r=' + Math.random()
        }, function(data) {});
    },
    //
    /**
     * ,       
     */
    isCanUsePromo: function(callback) {
        var me = this;
        //  user access token 
        FB.getLoginStatus(function(response) {
            if (response.status === 'connected') {
                //   is_eligible_promo
                me.request({
                    url: 'https://graph.facebook.com/me?fields=is_eligible_promo&access_token=' + response.authResponse.accessToken,
                    success: function(response) {
                        if (response && response.is_eligible_promo) {
                            callback(true);
                        } else {
                            callback(false);
                        }
                    },
                    failure: function() {
                        callback(false);
                    }
                });
            } else {
                /***/
                me.log('error', '   access token ', response);
                callback(false);
            }
        });
    },
    /**
     *    -
     * @param presetEntry {Number}
     * @param callback {Function} . 
     */
    usePromo: function(presetEntry, callback) {
        var me = this;
        FB.ui({
            action: 'payer_promotion',
            method: 'payer_promotion',
            quantity: 1,
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&preset_id=' + presetEntry + '&r=' + Math.random()
        }, function() {
            if (callback) {
                callback();
            }
        });
    },
    /**
     * ,        . (  )
     */
    isCanSendUserToUserMessage: function() {
        return true;
    },
    /**
     *       (  )
     * @param to {Array}  ids 
     * @param message {String}
     * @param callback {Function} 
     */
    sendUserToUserMessage: function(to, message, callback) {
        FB.ui({
            method: 'apprequests',
            message: message,
            to: to.join(',')
        }, function(response) {
            if (response && !response.error) {
                callback();
            } else {
                /***/
                me.log('error', '  ', response);
            }
        });
    },
    /**
     *   
     */
    setSize: function(width, height) {
        FB.Canvas.setSize({
            width: width,
            height: height
        });
    }
});

/**
 *   .  KG
 */
Ext.define('ExGods.controller.social.KG', {
    extend: ExGods.controller.Base,
    mixins: [
        ExGods.mixin.Sociable
    ],
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'KG:'
    },
    /**
     *  .     SDK .
     */
    initSDK: function() {
        var me = this;
        Ext.Loader.loadScript({
            url: 'https://cdn1.kongregate.com/javascripts/kongregate_api.js?2',
            onLoad: function() {
                console.log('load before');
                kongregateAPI.loadAPI(function() {
                    console.log('load after');
                    me.KG = kongregateAPI.getAPI();
                });
            }
        });
    },
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          url: <  >,
     *          image: <url  >,
     *          title: <>,
     *          description: <>
     *      }
     */
    share: function(obj) {
        FB.ui(obj);
    },
    /*, callback*/
    /**
     *     
     *
     * @param {Number}  
     */
    buy: function(preset) {},
    // var me = this;
    // FB.ui({
    //  method: 'pay',
    //  action: 'purchaseitem',
    //  product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&preset_id=' + preset.entry + '&r=' + Math.random(),
    //  quantity: 1
    // },
    // function(data) {
    //  //
    // });
    //debugger
    /**
     *     
     *
     * @param {Object} obj     
     *
     *      {
     *          image: <url  >,
     *          message: <>
     *          owner: <id      .  ,      >
     *      }
     */
    wallPost: function(obj) {
        var me = this,
            feedData = {
                method: 'feed',
                link: 'https://apps.facebook.com/' + config.social.fba + '/',
                picture: obj.image,
                caption: obj.subject,
                description: obj.message
            };
        if (obj.owner) {
            feedData.to = obj.owner;
        }
        FB.ui(feedData, function(response) {});
    },
    //
    /**
     *       
     */
    simpleWallPost: function(obj) {
        var me = this,
            user = me.user;
        FB.ui({
            method: 'feed',
            link: location.href,
            caption: obj.subject,
            description: obj.message
        }, function(response) {});
    },
    //
    /**
     *    
     */
    invite: function(callback) {
        var me = this;
        //   
        FB.api("/me/invitable_friends", function(response) {
            if (response && !response.error) {
                //     
                var users = [],
                    defaults = {
                        hoard: me.user.data.hoard
                    };
                response.data.forEach(function(friendData) {
                    users.push(Ext.apply({}, {
                        display_title: friendData.name,
                        shape: {
                            small: friendData.picture.data.url
                        },
                        social: friendData.id
                    }, defaults));
                });
                //       
                ExGods.Components.factory('USER_TARGET_PANEL', {
                    componentCls: 'fb-invite-list',
                    windowTitle: ExGods.getMsgByKey('invite_friends_window_title'),
                    users: users,
                    listeners: {
                        select: function(wnd, rec) {
                            //  
                            FB.ui({
                                method: 'apprequests',
                                message: ExGods.getMsgByKey('invite_friends_message'),
                                to: rec.data.social
                            }, function(response) {
                                if (response && response.error_code) {} else //
                                {
                                    callback();
                                }
                            });
                            wnd.up().close();
                        }
                    }
                });
            } else {
                /***/
                me.log('error', '      ', response);
            }
        });
    },
    /**
     *  
     */
    gift: function(preset) {
        var me = this;
        FB.ui({
            method: 'gift',
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&gift=1&preset_id=' + preset.entry + '&r=' + Math.random()
        }, function(data) {});
    },
    //
    /**
     * ,       
     */
    isCanUsePromo: function(callback) {
        var me = this;
        //  user access token 
        FB.getLoginStatus(function(response) {
            if (response.status === 'connected') {
                //   is_eligible_promo
                me.request({
                    url: 'https://graph.facebook.com/me?fields=is_eligible_promo&access_token=' + response.authResponse.accessToken,
                    success: function(response) {
                        if (response && response.is_eligible_promo) {
                            callback(true);
                        } else {
                            callback(false);
                        }
                    },
                    failure: function() {
                        callback(false);
                    }
                });
            } else {
                /***/
                me.log('error', '   access token ', response);
                callback(false);
            }
        });
    },
    /**
     *    -
     * @param presetEntry {Number}
     * @param callback {Function} . 
     */
    usePromo: function(presetEntry, callback) {
        var me = this;
        FB.ui({
            action: 'payer_promotion',
            method: 'payer_promotion',
            quantity: 1,
            product: location.protocol + '//' + location.host + '/fba-pay.pl?cmd=get_info_preset&preset_id=' + presetEntry + '&r=' + Math.random()
        }, function() {
            if (callback) {
                callback();
            }
        });
    },
    /**
     * ,        . (  )
     */
    isCanSendUserToUserMessage: function() {
        return true;
    },
    /**
     *       (  )
     * @param to {Array}  ids 
     * @param message {String}
     * @param callback {Function} 
     */
    sendUserToUserMessage: function(to, message, callback) {
        FB.ui({
            method: 'apprequests',
            message: message,
            to: to.join(',')
        }, function(response) {
            if (response && !response.error) {
                callback();
            } else {
                /***/
                me.log('error', '  ', response);
            }
        });
    },
    /**
     *   
     */
    setSize: function(width, height) {
        FB.Canvas.setSize({
            width: width,
            height: height
        });
    }
});

/**
 *  .
 */
Ext.define('ExGods.controller.Sound', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Sound:'
    },
    music: true,
    sound: true,
    fadeTime: 2000,
    playing: {},
    init: function(app) {
        var me = this;
        me.music = !!parseInt(me.user.getSetting('music'));
        me.sound = !!parseInt(me.user.getSetting('sound'));
        me.fadeTime = parseInt(ExGods.ref('constants|fade_music_time').value);
        me.user.location.on('entrychanged', me.setMusic, me);
        me.app.on('gamestarted', me.setMusic, me);
        me.app.getBattleBattleController().on('start', function() {
            try {
                me.setMusic();
            } catch (e) {
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_start').log('@battle    ' + e);
                /*****/
                ExGods.util.RemoteDebug.get('battle_no_finish').log('@battle    ' + e);
            }
        }, me);
        me.app.getSettingsController().on('settings_saved', function() {
            var music = !!parseInt(me.user.getSetting('music')),
                sound = !!parseInt(me.user.getSetting('sound'));
            me.volume();
            if (music != me.music)  {
                me.toggleMusic();
            }
            
            if (sound != me.sound)  {
                me.toggleSound();
            }
            
        }, me);
        setTimeout(function() {
            Ext.getCmp('tech-info').on('battlefinish', me.setMusic, me);
        }, 0);
        if (/*@cc_on!@*/
        false) {
            // check for Internet Explorer
            document.onfocusin = me.setMusic.bind(me);
            document.onfocusout = me.forseClearMusic.bind(me);
        } else {
            window.onfocus = me.setMusic.bind(me);
            window.onblur = me.forseClearMusic.bind(me);
        }
    },
    /**
     *  
     */
    setMusic: function() {
        var me = this,
            battle_type = me.app.getBattleBattleController().battle_type,
            soundName = battle_type ? ExGods.references.get('battle_types').get(battle_type).params.images.sound : me.user.location.get('blob').sound,
            sound = ExGods.references.get('sounds').get(soundName),
            repeatFn = function() {
                if (sound.pause) {
                    /***/
                    me.log('    ');
                    me.playing.timeout = setTimeout(function() {
                        /***/
                        me.log('   ');
                        if (sound.fading)  {
                            me.play(sound.audio, 0, true, true);
                        }
                        else  {
                            me.play(sound.audio);
                        }
                        
                    }, sound.pause * 1000);
                } else {
                    /***/
                    me.log(' ');
                    if (sound.fading)  {
                        me.play(sound.audio, 0, true, true);
                    }
                    else  {
                        me.play(sound.audio);
                    }
                    
                }
            };
        try {
            me.clearMusic(function() {
                if (sound && me.music) {
                    me.play(sound.audio, 0, false, true);
                    me.fadeIn(sound.audio);
                    if (sound.fading) {
                        me.setTimeoutOnFading(sound.audio);
                    }
                    /***/
                    me.log('  ');
                    me.playing.music = sound.audio;
                    sound.audio.onended = repeatFn;
                }
            });
        } catch (e) {
            /***/
            me.log('error', '   ', e);
        }
    },
    /**
     *    
     */
    clearMusic: function(cb) {
        var me = this,
            audio = me.playing.music;
        if (audio) {
            audio.onended = null;
            if (!audio.paused) {
                me.fadeOut(audio, function() {
                    audio.pause();
                    /***/
                    me.log(' ,  ');
                    if (cb)  {
                        cb();
                    }
                    
                });
            } else if (cb)  {
                cb();
            }
            
            clearTimeout(me.playing.timeout);
        } else if (cb)  {
            cb();
        }
        
    },
    /**
     *     
     */
    forseClearMusic: function() {
        var me = this,
            audio = me.playing.music;
        if (audio) {
            audio.onended = null;
            if (!audio.paused) {
                audio.pause();
                /***/
                me.log('  ');
            }
            clearTimeout(me.playing.timeout);
        }
    },
    /**
     *    
     * audio - tag audio
     * volume -  0-100
     * fading -        
     * isMusic - ,      
     */
    play: function(audio, volume, fading, isMusic) {
        var me = this;
        if (!me.sound && !isMusic)  {
            return;
        }
        
        if (!me.music && isMusic)  {
            return;
        }
        
        audio.currentTime = 0;
        clearTimeout(audio.fadingTimeout);
        me.volume(typeof volume == 'number' ? volume : me.user.getSetting('volume'), audio);
        try {
            audio.play();
        } catch (e) {}
        
        if (fading) {
            me.fadeIn(audio);
            me.setTimeoutOnFading(audio);
        }
    },
    /**
     *  
     */
    volume: function(value, audio) {
        audio = audio || this.playing.music;
        value = typeof value == 'number' ? value : this.user.getSetting('volume');
        if (audio) {
            audio.volume = parseInt(value) / 100;
        }
    },
    /**
     * /  
     */
    toggleSound: function(state) {
        var me = this;
        me.sound = state || !me.sound;
        var value = parseInt(new Number(me.sound));
        me.user.setSetting('sound', value);
        ExGods.app.getSettingsController().saveSettings({
            sound: value
        });
    },
    // if(me.sound){
    //  me.setMusic();
    // }else{
    //  me.clearMusic();
    // }
    /**
     * /  
     */
    toggleMusic: function(state) {
        var me = this;
        me.music = state || !me.music;
        var value = parseInt(new Number(me.music));
        me.user.setSetting('music', value);
        ExGods.app.getSettingsController().saveSettings({
            music: value
        });
        if (me.music) {
            me.setMusic();
        } else {
            me.clearMusic();
        }
    },
    isSoundOff: function() {
        return !this.sound;
    },
    isMusicOff: function() {
        return !this.music;
    },
    fadeIn: function(audio, cb) {
        /***/
        this.log('fading in');
        this.fade(audio, true, cb);
    },
    fadeOut: function(audio, cb) {
        /***/
        this.log('fading out');
        this.fade(audio, false, cb);
    },
    fade: function(audio, increase, cb) {
        var me = this,
            settingVolume = parseInt(me.user.getSetting('volume'));
        clearInterval(audio.fadingInterval);
        audio.fadingInterval = setInterval(function() {
            if (increase) {
                if (audio.volume < settingVolume / 100) {
                    audio.volume = Math.min(audio.volume + 0.01, settingVolume / 100);
                } else {
                    clearInterval(audio.fadingInterval);
                    if (cb)  {
                        cb();
                    }
                    
                }
            } else {
                if (audio.volume != 0) {
                    audio.volume = Math.max(audio.volume - 0.01, 0);
                } else {
                    clearInterval(audio.fadingInterval);
                    if (cb)  {
                        cb();
                    }
                    
                }
            }
        }, me.fadeTime / settingVolume);
    },
    setTimeoutOnFading: function(audio) {
        var me = this;
        audio.fadingTimeout = setTimeout(me.fadeOut.bind(me, audio), audio.duration * 1000 - me.fadeTime - 50);
        /* */
        audio.onpause = function() {
            clearTimeout(audio.fadingTimeout);
        };
    }
});

Ext.define('ExGods.model.SpecialDeal', {
    extend: Ext.data.Model,
    idProperty: 'label',
    fields: [
        {
            name: 'actions',
            type: 'auto'
        },
        {
            name: 'time',
            type: 'number'
        },
        {
            name: 'ended',
            type: 'date',
            convert: function(v, rec) {
                if (v) {
                    v = Ext.Date.parse(v, 'YmdHis') || Ext.Date.parse(v, 'Y-m-d H:i:s');
                    var calcTime = function() {
                            return Math.floor(Math.max((ExGods.util.Date.normalizeServerDateTime(v).getTime() - new Date().getTime()) / 1000 + 2, 0));
                        },
                        time = calcTime();
                    rec.set('time', time);
                    if (time > 0) {
                        var _onTick = function() {
                                var time = calcTime();
                                if (time > 1) {
                                    rec.set('time', --time);
                                    rec.fireEvent('timechanged', time, rec);
                                } else {
                                    ExGods.util.Ticker.removeListener(rec.timer);
                                    rec.fireEvent('removed');
                                    var i = rec.stores.length;
                                    while (i > 0) {
                                        i--;
                                        rec.stores[i].remove(rec);
                                    }
                                }
                            };
                        setTimeout(function() {
                            rec.timer = ExGods.util.Ticker.addListener(_onTick, rec);
                            _onTick();
                        }, 0);
                    }
                }
                return v;
            }
        },
        {
            name: 'params',
            type: 'auto'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'value',
            type: 'number'
        },
        {
            name: 'expanded',
            type: 'boolean'
        }
    ]
});

Ext.define('ExGods.view.special_deal.Item', {
    extend: Ext.Component,
    alias: 'widget.specialdealitem',
    height: 302,
    margin: '5px 4px -3px',
    style: {
        position: 'relative',
        overflow: 'hidden'
    },
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<tpl if="title">',
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="paper-title">',
            '<h4>{title}</h4>',
            '</div>',
            '<div class="deal-big-image" style="background-image:url({[IMAGE_URL + values.params.image2]})">',
            '<div class="deal-big-image-border"></div>',
            '</div>',
            '<div class="deal-info">',
            '<p>{[new Ext.XTemplate(values.params.description).apply()]}</p>',
            '<div id="button-place">',
            '<tpl if="time">',
            '<p class="deal-info-timer">' + ExGods.getMsgByKey('view_specialdeal_item_rest') + ' <span class="dropdown">{[Ext.util.Format.countdown(values.time,{format:"threenums"})]}</span></p>',
            '</tpl>',
            '<tpl for="actions">',
            '<div id="button-place-{[xindex]}"></div>',
            '</tpl>',
            '</div>',
            '</div>',
            '<tpl else>',
            '<p class="central-window-empty deal-empty">{emptyText}</p>',
            '</tpl>'
        ];
        me.callParent(arguments);
    },
    setRecord: function(record, currentRecord) {
        var me = this;
        //    -     
        if (currentRecord) {
            currentRecord.un('timechanged', me.formatTime, me);
        }
        if (record) {
            me.update(record.data);
            if (me.rendered) {
                me.renderSubmitButton(record);
            } else {
                me.on('afterrender', me.renderSubmitButton.bind(me, record), me, {
                    single: true
                });
            }
            record.on('timechanged', me.formatTime, me);
            me.mon(record.store, 'remove', function(store, removedRecord) {
                if (removedRecord.id == record.id) {
                    record.un('timechanged', me.formatTime, me);
                }
            });
        } else {
            me.update({
                emptyText: me.emptyText
            });
        }
    },
    formatTime: function(time, record) {
        var me = this;
        if (me.el) {
            var dropdown = me.el.down('.dropdown');
            if (dropdown) {
                if (time > 0) {
                    dropdown.update(Ext.util.Format.countdown(time, {
                        format: 'threenums'
                    }));
                }
            }
        }
    },
    renderSubmitButton: Ext.Function.createBuffered(function(record) {
        var me = this,
            params = {},
            renderInner = function(text) {
                Ext.each(record.get('actions'), function(action, i) {
                    if (action.hidden != 1) {
                        Ext.widget('textbutton', {
                            cls: 'no_border_double x-btn-text-green',
                            style: {
                                margin: '0 -50px',
                                left: '50%'
                            },
                            text: text ? text : action.label_button,
                            action: action,
                            data: record.data,
                            renderTo: 'button-place-' + (i + 1)
                        }).on('click', function(cmp) {
                            me.fireEvent('btnclick', cmp);
                        });
                    }
                });
            };
        if (!me.isVisible())  {
            return;
        }
        
        if (record.data.params.promo && isSocialApp) {
            ExGods.app.getSocialController().isCanUsePromo(function(canUse) {
                renderInner(canUse ? ExGods.getMsgByKey('view_specialdeal_use_promo_btn_text') : null);
            });
        } else {
            renderInner();
        }
    }, // if(action.desc_button){
    //  var tpl = new Ext.XTemplate('<p class="deal-btn-desc">'+action.desc_button+'</p>');
    //  tpl.append(me.el.down('#button-place-'+(i+1)),{});
    // }
    // .el.set({
    //  'data-qh_otype':'tutorial_quests',
    //  'data-qh_oid':'1',
    //  'data-qh_opts': "{&quot;cls&quot;:&quot;flip-h&quot;}"
    // });
    300),
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        //             
        if (me.data.params) {
            if (me.data.params.image) {
                arr_images.push(me.data.params.image);
            }
            if (me.data.params.image2) {
                arr_images.push(me.data.params.image2);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.special_deal.List', {
    extend: Ext.view.View,
    alias: 'widget.specialdeallist',
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<ul class="deal-items">',
            '<tpl for=".">',
            '<li class="deal-item">',
            '<div class="item_info deal-info-btn"></div>',
            '<div class="deal-image" style="background-image:url({[IMAGE_URL + values.params.image]})"></div>',
            '<tpl if="time">',
            '<div class="deal-timer">',
            '<span class="dropdown">{[Ext.util.Format.countdown(values.time,{format:"short"})]}</span>',
            '</div>',
            '</tpl>',
            '</li>',
            '</tpl>',
            '</ul>'
        ];
        me.itemSelector = 'li';
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var i = 0; i < me.dataSource.data.items.length; i++) {
            arr_images.push(me.dataSource.data.items[i].data.params.image);
            arr_images.push(me.dataSource.data.items[i].data.params.image2);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.controller.SpecialDeal', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: false,
        prefix: 'SpecialDealController:'
    },
    models: [
        'SpecialDeal'
    ],
    views: [
        'special_deal.List',
        'special_deal.Item',
        'TextButton'
    ],
    refs: [
        {
            ref: 'mainMenu',
            selector: '#mainmenu'
        },
        {
            /**
         * @method getDealContainer
         */
            ref: 'dealContainer',
            selector: '#specialdealcontainer'
        }
    ],
    //  
    shownRecord: false,
    init: function() {
        var me = this;
        me.service = ExGods.Services.get('special_deal');
        me.service.on('update', me.onServiceUpdate, me);
        me.app.getSpecialDealsStore().loadRawData(me.service.data.special_deal);
        me.control({
            'specialdealitem': {
                btnclick: me.onActionClick
            },
            '#specialdealcontainer': {
                prev: me.setPager.bind(me, -1),
                next: me.setPager.bind(me, 1)
            },
            'specialdeallist': {
                itemclick: me.setRecord
            }
        });
        me.app.chatcn.on('command_refresh_special_deal', me.requestDeals, me);
        ExGods.Components.addComponentInitializer('special_deal', me.initSpecialDealComponent, me);
    },
    onLaunch: function() {
        this.resetDealTimer();
    },
    onServiceUpdate: function() {
        var me = this,
            deals = me.service.data.special_deal;
        //q = [];
        //if(deals.length)
        //q = deals.concat([deals[0],Ext.apply(Ext.clone(deals[0]),{title:'qq',name:'qq',ended:'2014-10-15 13:39:29'}),deals[0],deals[0],deals[0],deals[0]])
        me.app.getSpecialDealsStore().loadRawData(deals);
        me.resetDealTimer();
    },
    onActionClick: function(cmp) {
        var me = this,
            conf = cmp.action.confirm,
            store = me.app.getSpecialDealsStore(),
            useSpecialDeal = function() {
                me.service.command('use_special_deal', {
                    specialdeal: cmp.config.data.name,
                    action: cmp.action.action
                }, function(data) {
                    if (data.specialdeal) {
                        store.loadRawData(data.special_deal);
                        me.resetViews();
                    }
                });
            },
            okHandler = function() {
                if (cmp.config.data.params.promo && isSocialApp) {
                    me.app.getSocialController().isCanUsePromo(function(canUse) {
                        if (canUse) {
                            me.app.getSocialController().usePromo(cmp.config.data.params.promo, function() {
                                me.service.update(null, function() {
                                    me.resetViews(true);
                                });
                            });
                        } else {
                            useSpecialDeal();
                        }
                    });
                } else {
                    useSpecialDeal();
                }
            };
        if (conf && conf.confirmated) {
            Ext.widget('confirmdialog', {
                message: new Ext.XTemplate(conf.confirmated).apply(),
                buttonsText: [
                    conf.btn_yes || ExGods.getMsgByKey('yes_btn_text'),
                    conf.btn_no || ExGods.getMsgByKey('no_btn_text')
                ],
                handler: okHandler
            });
        } else {
            okHandler();
        }
    },
    requestDeals: function() {
        var me = this;
        me.service.update(null, function() {
            me.resetViews();
        });
    },
    resetViews: function(opening) {
        var me = this,
            cmp = me.getDealContainer(),
            store = me.app.getSpecialDealsStore(),
            record;
        if (cmp) {
            me.currentStartIndex = 0;
            me.setPager();
            record = store.getAt(0);
            if (opening || !me.checkExisitingActiveRecord()) {
                cmp.down('specialdealitem').setRecord(record, me.shownRecord);
            }
            me.shownRecord = record || false;
        }
        me.resetDealTimer();
    },
    setRecord: function(dataview, record, dom, index, e) {
        var me = this,
            cmp = me.getDealContainer();
        if (!me.shownRecord || !record || me.shownRecord.get('name') != record.get('name')) {
            cmp.down('specialdealitem').setRecord(record, me.shownRecord);
        }
        me.shownRecord = record;
    },
    checkExisitingActiveRecord: function() {
        var me = this,
            cmp = me.getDealContainer(),
            valid = false,
            store = me.app.getSpecialDealsStore();
        if (!me.shownRecord)  {
            return valid;
        }
        
        store.each(function(rec) {
            if (rec.get('name') == me.shownRecord.get('name'))  {
                valid = true;
            }
            
        });
        return valid;
    },
    setPager: function(sign) {
        var me = this,
            cmp = me.getDealContainer(),
            store = me.app.getSpecialDealsStore();
        if (cmp) {
            sign = sign || 0;
            me.currentStartIndex += sign;
            cmp.pager.refresh();
            store.clearFilter();
            store.addFilter(me._filter);
        }
    },
    /**
     * @private
     *        (   " "  )
     */
    setDealTimer: function() {
        var me = this,
            store = ExGods.app.getSpecialDealsStore(),
            time = Infinity,
            rec;
        store.each(function(item) {
            var left = item.get('time');
            if (left > 0 && left < time) {
                time = left;
                rec = item;
            }
        });
        if (rec) {
            ExGods.util.Helper.startMenuTimer('mainmenu-special_deal-button', 'deal-timer', rec.get('ended'));
        }
        setTimeout(function() {
            var btn = Ext.getCmp('mainmenu-special_deal-button');
            if (store.getCount()) {
                btn.disabledByController = false;
                btn.enable();
            } else {
                btn.disabledByController = true;
                btn.disable();
            }
            if (ExGods.app.user.isBattle()) {
                me.getMainMenu().disableMenu();
            }
        }, 0);
    },
    unsetDealTimer: function() {
        ExGods.util.Helper.stopMenuTimer('deal-timer');
    },
    resetDealTimer: function() {
        this.unsetDealTimer();
        this.setDealTimer();
    },
    initSpecialDealComponent: function(config) {
        var me = this,
            store = me.app.getSpecialDealsStore(),
            cmp,
            wnd = Ext.getCmp('SPECIAL_DEAL');
        ExGods.app.block();
        me.currentStartIndex = 0;
        me._filter = Ext.util.Filter({
            filterFn: function(rec) {
                return store.indexOf(rec) >= me.currentStartIndex && store.indexOf(rec) < me.currentStartIndex + 4;
            },
            id: '_filter'
        });
        store.addFilter(me._filter);
        cmp = {
            xtype: 'container',
            id: 'specialdealcontainer',
            plugins: [
                {
                    ptype: 'pager',
                    marginLeft: -27,
                    marginRight: -27,
                    hidden: 1,
                    top: 335
                }
            ],
            service: me.service,
            items: [
                {
                    xtype: 'specialdealitem',
                    emptyText: config.emptyText,
                    service: me.service
                },
                {
                    xtype: 'specialdeallist',
                    store: store,
                    service: me.service
                }
            ],
            onDestroy: function() {
                this.mun(store, 'datachanged');
                this.callParent(arguments);
            }
        };
        if (wnd)  {
            wnd.close();
        }
        
        wnd = Ext.widget('window2', {
            id: 'SPECIAL_DEAL',
            items: [
                cmp
            ],
            autoShow: false
        });
        cmp = wnd.down('container');
        cmp.mon(store, 'datachanged', function() {
            cmp.pager.total = store.totalCount - 3;
            cmp.pager.hidden = store.totalCount > 4 ? 0 : 1;
            if (!cmp.pager.hidden)  {
                cmp.pager.showArrows();
            }
            else  {
                cmp.pager.hideArrows();
            }
            
            me.resetDealTimer();
        });
        cmp.mon(store, 'remove', function(store, record) {
            if (me.shownRecord.id == record.id) {
                me.resetViews();
            } else {
                me.resetDealTimer();
            }
        });
        me.service.update(null, function() {
            me.resetViews(true);
            ExGods.Resources.load(wnd, function() {
                wnd.show();
                ExGods.app.unblock();
            });
        });
        return wnd;
    }
});

/**
 *   
 */
Ext.define('ExGods.controller.Surging', {
    extend: ExGodsCore.controller.Base,
    mixins: [
        ExGods.util.Flags
    ],
    views: [],
    //
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Surging'
    },
    stores: [
        'Monster'
    ],
    init: function() {
        var me = this;
        me.app.getChatConnection().on({
            command_surging_update: me.onSurgingUpdate,
            command_update_surging_service: me.onUpdateSurgingService,
            command_surging_update_wait: me.onSurginWait,
            scope: me
        });
        ExGods.app.user.location.on({
            'locationchanged': me.onLocationChange,
            //'entrychanged' : me.onLocationEntryChange,
            scope: me
        });
        ExGods.app.getBattleBattleController().on('finish', function() {
            ExGods.app.getChatConnection().ping();
        });
        me.initService();
        me.callParent(arguments);
    },
    initService: function() {
        var me = this,
            service,
            _bindEvents = function(service) {
                service.on('init', me.onServiceInit, me);
                service.on('update', me.onServiceUpdate, me);
            };
        _unbindEvents = function(service) {
            service.un('init', me.onServiceInit, me);
            service.un('update', me.onServiceUpdate, me);
        };
        service = me.app.getController('Location').getBindableServices('surging');
        if (service && service.length) {
            service = service[0];
            if (!me.service || me.service.id != service.id) {
                if (me.service) {
                    _unbindEvents(me.service);
                }
                _bindEvents(service);
                me.service = service;
                me.service.init();
            }
        } else {
            if (me.service) {
                _unbindEvents(me.service);
                me.service = null;
            }
        }
    },
    onServiceInit: function() {
        var me = this;
        me.updateStore();
    },
    onServiceUpdate: function() {
        var me = this;
        me.updateStore();
    },
    onLocationChange: function() {
        var me = this,
            waitEl = document.getElementById('surging_wait'),
            imageEl = document.getElementById('surging_image');
        me.initService();
        if (!me.service) {
            me.getMonsterStore().removeAll();
        }
        delete me.surging_wait;
        if (waitEl)  {
            waitEl.remove();
        }
        
        if (imageEl)  {
            imageEl.remove();
        }
        
        ExGods.app.getChatConnection().ping();
    },
    updateStore: function() {
        var me = this,
            store = me.getMonsterStore(),
            quest_bots = me.user.location.get('quest_bots'),
            battle_chain = me.app.getController('BattleChain').getSurgingChainEntry();
        if (!me.app.getController('Location').isLocked()) {
            store.removeAll();
            ExGods.Resources.load(me, function() {
                store.removeAll();
                if (quest_bots && quest_bots.length) {
                    store.add(quest_bots);
                }
                if (battle_chain) {
                    store.add(Ext.clone(battle_chain));
                }
                if (me.service && me.service.data && me.service.data.surging) {
                    store.add(me.service.data.surging);
                }
                if (me.surging_wait && !store.data.length) {
                    store.add({
                        'wait': me.surging_wait
                    });
                }
            });
        }
    },
    // if (store.getCount() && !Ext.getCmp('LOB_BOT_LIST')) {                   
    //  ExGods.Components.factory('LOB_BOT_LIST', {
    //      x: 757,
    //  });
    // }
    onSurgingUpdate: function(chatcn, data) {
        var me = this;
        /***/
        me.log('  "   "', data);
        if (me.service) {
            me.service.update({
                surging: data.body.surging
            });
        }
    },
    onUpdateSurgingService: function() {
        var me = this;
        /***/
        me.log('  "   "');
        if (me.service) {
            me.service.update();
        }
    },
    onSurginWait: function(chatObj, data) {
        var me = this;
        if (data.body.wait)  {
            me.surging_wait = data.body.wait + new Date() / 1000 + 1;
        }
        else if (data.body.wait == 0)  {
            ExGods.app.getChatConnection().ping();
        }
        
        if (!me.app.getController('Location').isLocked()) {
            me.updateStore();
        }
    },
    getResources: function() {
        var me = this,
            images = [],
            stuff = [],
            shapeRef = ExGods.ref('user_shape');
        if (me.service && me.service.data && me.service.data.surging && me.service.data.surging.length) {
            Ext.Array.each(me.service.data.surging, function(item) {
                var shape = shapeRef.getByKey(item.shape);
                if (shape) {
                    images.push(shape.thumb);
                    images.push(shape.full);
                }
                if (item.reward_banish && item.reward_banish.length) {
                    for (var i = 0; i < item.reward_banish.length; i++) {
                        stuff = stuff.concat(item.reward_banish[i]);
                    }
                }
                if (item.stuff && item.stuff.length) {
                    stuff = stuff.concat(item.stuff);
                }
            });
        }
        return {
            images: images,
            stuff: stuff
        };
    }
});

/**
 * 
 */
Ext.define('ExGods.view.teleport.Teleport', {
    extend: Ext.panel.Panel,
    alias: 'widget.teleport',
    header: false,
    ui: 'teleport',
    /**
     * @property {Object} positions
     *     
     */
    positions: {
        world_cradle: {
            x: 28,
            y: 153
        },
        world_eagle: {
            x: 104,
            y: 19
        },
        world_lion: {
            x: 176,
            y: 197
        },
        world_volcano: {
            x: 239,
            y: 68
        },
        world_dust: {
            x: 0,
            y: 0
        }
    },
    layout: 'absolute',
    margin: '0 10 10 0',
    x: 5,
    y: 3,
    plugins: [
        'irondeco'
    ],
    /**
     * @cfg {ExGods.store.Locations} locations
     * 
     */
    /**
     * @cfg {ExGods.model.User} user
     * 
     */
    /**
     * @cfg {ExGods.store.Worlds} worlds
     * 
     */
    /**
     * @cfg {ExGods.store.Worlds} backImg
     * 
     */
    initComponent: function() {
        var me = this;
        me.store = Ext.create('Ext.data.Store', {
            fields: [
                {
                    name: 'conditions',
                    type: 'auto'
                },
                {
                    name: 'entry',
                    type: 'int'
                },
                {
                    name: 'name',
                    type: 'string'
                },
                {
                    name: 'price',
                    type: 'auto'
                },
                {
                    name: 'rid',
                    type: 'int'
                },
                {
                    name: 'wid',
                    type: 'int'
                }
            ],
            groupField: 'wid'
        });
        me.style = {
            overflow: 'visible',
            backgroundImage: "url(" + IMAGE_URL + me.backImg + ")",
            backgroundRepeat: "no-repeat",
            backgroundPosition: '5px 5px'
        };
        me.callParent();
        me.on('afterrender', function(cmp) {
            var mapActionBtns = cmp.el.query('.world');
            if (mapActionBtns) {
                mapActionBtns.forEach(function(bnt) {
                    cmp.el.down('#' + bnt.id).set({
                        'data-qh_otype': 'world',
                        'data-qh_oid': bnt.id.split('_')[1]
                    });
                });
            }
        });
    },
    /**
     *      
     * @param {Object} data  
     */
    setData: function(data) {
        var me = this,
            items = [];
        me.store.loadRawData(data.blob);
        items.push({
            width: 575,
            height: 354,
            margin: '0 0 0 0',
            x: 4,
            y: -1,
            style: {
                backgroundImage: "url(" + ExGods.ref('images|teleport_images').image.bg + ")",
                backgroundRepeat: "no-repeat"
            }
        });
        me.worlds.each(function(world) {
            if (!world.isVisible())  {
                return;
            }
            
            var blob = world.get('blob'),
                position = me.positions[world.get('name')],
                menu = [],
                worldItems;
            worldItems = me.store.queryBy(function(item) {
                return item.data.wid == world.get('entry');
            });
            if (worldItems.length) {
                worldItems.each(function(room) {
                    menu.push({
                        action: 'teleport',
                        locationEntry: room.get('entry'),
                        teleportEntry: parseInt(data.entry),
                        text: '<span class="teleport-destination"><span class="label">' + room.get('name') + '</span></span>'
                    });
                });
            }
            items.push({
                xtype: 'button',
                cls: 'qh-object world',
                icon: world.getImage(),
                pressed: world.get('entry') == me.world.get('entry') ? true : false,
                text: ' ',
                //     iPad. TODO:   
                tooltip: !isMobile ? world.get('title') : undefined,
                world: world,
                id: 'world_' + world.get('entry'),
                width: 160,
                height: 150,
                x: position ? position.x : 0,
                y: position ? position.y : 0,
                menu: menu.length ? {
                    bodyPadding: '0 17 0 18',
                    closable: true,
                    closeAction: 'hide',
                    cls: 'teleport-menu',
                    defaults: {
                        border: 0
                    },
                    items: menu,
                    padding: 0,
                    plugins: [
                        'windeco'
                    ],
                    showSeparator: false,
                    width: 200,
                    height: 172,
                    showBy: function(cmp, pos, off) {
                        var me = this,
                            teleport = this.up('teleport');
                        if (me.floating && cmp) {
                            me.show();
                            // Align to Component or Element using setPagePosition because normal show
                            // methods are container-relative, and we must align to the requested element
                            // or Component:
                            // me.setPagePosition(me.el.getAlignToXY(cmp.el || cmp, pos || me.defaultAlign, off));
                            // me.setVerticalPosition();
                            var position = me.el.getAlignToXY(teleport.el || teleport, pos || me.defaultAlign, off);
                            position[0] += 240;
                            position[1] -= 270;
                            me.setPagePosition(position);
                        }
                        return me;
                    }
                } : undefined,
                listeners: {
                    menushow: function(button) {
                        ExGods.util.Helper.maskElement(button.up().el);
                    },
                    menuhide: function(button) {
                        button.up().el.unmask();
                    }
                }
            });
        });
        me.removeAll();
        me.add({
            xtype: 'panel',
            plugins: [
                'skindeco'
            ],
            itemId: 'teleports-container',
            cls: 'panel_with_teleports',
            closable: true,
            width: 580,
            height: 355,
            margin: '0 0 0 0',
            x: 245,
            y: 15,
            items: items,
            listeners: {
                beforeclose: {
                    fn: function() {
                        me.close();
                        return false;
                    }
                }
            }
        }, {
            xtype: 'panel',
            layout: 'anchor',
            y: 372,
            style: {
                textAlign: 'center'
            },
            margin: '0 0 0 250',
            items: [
                {
                    height: 30,
                    xtype: 'textbutton',
                    text: me.closeText,
                    cls: (me.closeColor) ? 'x-btn-txt-' + me.closeColor : '',
                    handler: function(btn) {
                        me.close();
                    }
                }
            ]
        });
    },
    getResources: function() {
        var me = this,
            images = [];
        images.push(IMAGE_URL + '/teleport_map.png');
        images.push(me.backImg);
        var imgs_ = ExGods.ref('images|teleport_images').image;
        for (var it in imgs_) {
            images.push(imgs_[it]);
        }
        me.worlds.each(function(world) {
            images.push(world.getImage());
        });
        return {
            images: images
        };
    }
});

/**
 * 
 */
Ext.define('ExGods.view.teleport.TeleportWithTimed', {
    extend: Ext.panel.Panel,
    alias: 'widget.teleport_with_timed',
    /**
     * @cfg service   
     */
    cls: 'teleport-with-timed',
    /**
      * @property {Object} selectedItem   
      */
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'component',
                autoEl: 'ul',
                cls: 'teleports-list',
                tpl: [
                    '<tpl for=".">',
                    '<li style="background-image: url(' + IMAGE_URL + '{image})" class="{[ values.message ? "disabled" : "" ]}" data-index="{[ xindex ]}">',
                    '<div class="title">',
                    '<div>&nbsp;</div>',
                    '<span>{[ values.name.toUpperCase() ]}</span>',
                    '</div>',
                    '</li>',
                    '</tpl>'
                ],
                data: me.service.teleports.blob,
                height: 226,
                listeners: {
                    afterrender: me.onListRendered,
                    scope: me
                }
            },
            {
                xtype: 'container',
                layout: {
                    type: 'hbox',
                    align: 'stretch'
                },
                flex: 1,
                margin: '0 0 4 0',
                items: [
                    {
                        xtype: 'panel',
                        plugins: [
                            'paperdeco'
                        ],
                        width: 451,
                        margin: '0 0 0 13',
                        layout: 'fit',
                        items: [
                            {
                                xtype: 'component',
                                cls: 'description',
                                itemId: 'teleportDescription',
                                tpl: [
                                    '<tpl if="item">',
                                    '<div class="paper-title">' + ExGods.getMsgByKey('teleport_with_timed_title') + '<div>',
                                    '<div class="stuff-list">',
                                    '{[ ExGods.stuff.StuffManager.image(values.item.description_stuff) ]}',
                                    '</div>',
                                    '<tpl else>',
                                    '<p>' + (me.clientConfig.teleport_select_desc || ExGods.getMsgByKey("teleport_with_timed_description")) + '</p>',
                                    '</tpl>'
                                ],
                                data: {}
                            }
                        ]
                    },
                    {
                        xtype: 'timedtimer',
                        itemId: 'timedTimer',
                        timed: me.service.teleports.blob[0].price[0].params.id,
                        quantity: me.service.teleports.blob[0].price[0].params.quantity,
                        is_disabled: true,
                        width: 100,
                        textbutton: {
                            cls: 'x-btn-txt double_text_btn',
                            text: me.clientConfig.teleportBtnText,
                            handler: function() {
                                me.fireEvent('teleport-gogo', me, me.selectedItem);
                            }
                        },
                        buybutton: {
                            cls: 'x-btn-txt double_text_btn',
                            text: me.clientConfig.teleportBtnText
                        },
                        margin: '5 0 0 4'
                    }
                ]
            }
        ];
        me.callParent();
    },
    /**
     * @private
     */
    onListRendered: function(listView) {
        var me = this;
        listView.el.on('click', function(e, el) {
            var descr = me.down('#teleportDescription'),
                timedTimer = me.down('#timedTimer'),
                item;
            el = Ext.get(el);
            if (!el.hasCls('disabled') && !el.hasCls('selected')) {
                item = me.service.teleports.blob[el.dom.getAttribute('data-index') - 1];
                listView.el.select('li').removeCls('selected');
                el.addCls('selected');
                descr.update({
                    item: item
                });
                timedTimer.setEnable();
                me.selectedItem = item;
            }
        }, me, {
            delegate: 'li'
        });
    },
    /**
     *  
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            images = [];
        Ext.Array.each(me.service.teleports.blob, function(item) {
            images.push(item.image);
            if (item.description_stuff) {
                stuff_arr = stuff_arr.concat(item.description_stuff);
            }
            if (item.price) {
                stuff_arr = stuff_arr.concat(item.price);
            }
        });
        return {
            stuff: stuff_arr,
            images: images
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Teleport', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Teleport:'
    },
    views: [
        'ConfirmationDialog',
        'teleport.Teleport',
        'teleport.TeleportWithTimed'
    ],
    stores: [
        'Quests'
    ],
    refs: [
        {
            /**
         * @private
         * @method getLocationView
         *   
         * @return {ExGods.view.location.Location}
         */
            ref: 'locationView',
            selector: 'locationview'
        }
    ],
    init: function() {
        var me = this;
        me.listen({
            component: {
                'teleport #teleports-container button': {
                    click: me.checkTeleport
                },
                'teleport menuitem[action="teleport"]': {
                    click: me.teleport
                }
            }
        });
        ExGods.Components.addComponentInitializer('teleport', me.initTeleportComponent, me);
        ExGods.Components.addComponentInitializer('teleport_with_timed', me.initTeleportWithTimedComponent, me);
    },
    /**
     *   
     */
    checkTeleport: function(button) {
        var me = this;
        if (button.pressed)  {
            return false;
        }
        
        if (!button.menu) {
            me.application.fireEvent('logmessage', ' ' + button.world.get('title') + '      ');
            return false;
        } else {
            //  ,       
            button.menu.hide();
            Ext.widget('confirmdialog', {
                message: Ext.String.format(ExGods.getMsgByKey('teleport_confirm_tp'), button.world.get('title')),
                handler: function() {
                    var menuItem = button.menu.items.first();
                    me.teleport(menuItem.locationEntry);
                }
            });
        }
    },
    /**
     *  
     * 
     * @param {String} locationEntry
     */
    teleport: function(locationEntry) {
        var me = this;
        /***/
        me.log('   ');
        ExGods.app.getController('Location').maskLocation(function() {
            //ExGods.app.block();
            me.service.command('teleport', {
                teleport_id: me.service.data.teleports.entry,
                entry: locationEntry
            }, {
                beforeKeyHandlers: function(json) {
                    //ExGods.app.unblock();
                    if (json.success) {
                        /***/
                        me.log(' .');
                        me.fireEvent('teleport', me);
                    }
                    //   
                    if (!json.success || json.msg) {
                        //        .      
                        ExGods.app.getController('Location').unmaskLocation();
                    }
                }
            });
        }, {
            img: me.maskImage
        });
    },
    /**
     *   "teleport"
     */
    initTeleportComponent: function(config, componentId) {
        var me = this,
            cmp, wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        Ext.apply(config, {
            user: me.getUser(),
            world: me.getWorld(),
            worlds: me.app.getWorldsStore(),
            listeners: {
                beforeclose: function() {
                    ExGods.loaderCt.loadAndRemove(function() {
                        wnd.close();
                    }, {
                        img: me.maskImage
                    });
                    return false;
                }
            }
        });
        cmp = Ext.apply({
            xtype: 'teleport'
        }, config);
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ]
        });
        cmp = wnd.down('teleport');
        cmp.setData(me.service.data.teleports);
        cmp.mon(me, 'teleport', function() {
            wnd.destroy();
        });
        me.maskImage = config.backImg;
        ExGods.app.getController('Location').maskLocation(function() {
            //  
            ExGods.Resources.load(wnd, function() {
                wnd.show();
                ExGods.app.getController('Location').unmaskLocation();
            });
        }, {
            img: me.maskImage
        });
        return wnd;
    },
    /**
     *   "teleport_with_timed" -   
     */
    initTeleportWithTimedComponent: function(config, componentId) {
        var me = this,
            cmp, wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        me.service = config.service;
        me.clientConfig = config;
        cmp = {
            xtype: 'room',
            rightPanelX: 245,
            margin: '0 10 10 0',
            backgroundImage: config.backImg,
            closeText: config.closeText,
            closeColor: config.closeColor,
            closeCallback: function() {
                wnd.close();
            },
            items: [
                {
                    xtype: 'teleport_with_timed',
                    width: 579,
                    height: 353,
                    y: 15,
                    x: 245,
                    plugins: [
                        'skindeco'
                    ],
                    closable: true,
                    teleportBtnText: config.teleportBtnText,
                    clientConfig: me.clientConfig,
                    service: me.service.data,
                    listeners: {
                        beforeclose: {
                            fn: function() {
                                wnd.close();
                                return false;
                            },
                            single: true
                        },
                        'teleport-gogo': function(view, data) {
                            me.teleport(data.entry);
                        },
                        scope: me
                    }
                }
            ]
        };
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ],
            listeners: {
                beforeclose: {
                    fn: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            wnd.close();
                        }, {
                            img: me.maskImage
                        });
                        return false;
                    },
                    single: true
                }
            }
        });
        cmp = wnd.down('room');
        cmp.mon(me, 'teleport', function() {
            wnd.destroy();
        });
        me.maskImage = config.backImg;
        ExGods.app.getController('Location').maskLocation(function() {
            //   
            var stuff = [];
            Ext.Array.each(me.service.data.teleports.blob, function(item) {
                stuff = stuff.concat(item.description_stuff);
            });
            ExGods.helpme.loadProtosFromStuff(stuff, function() {
                //  
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: me.maskImage
        });
        return wnd;
    }
});

/**
 *   tools
 *
 * @author  
 *
 */
Ext.define('ExGods.controller.ToolsMenu', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: true,
            error: true
        },
        prefix: 'ToolsMenu:'
    },
    refs: [
        {
            ref: 'toolsMenu',
            selector: '#tools-menu'
        }
    ],
    init: function() {
        var me = this;
        me.listen({
            controller: {
                '#Settings': {
                    settings_saved: me.refreshView
                }
            },
            component: {
                '#tools-menu': {
                    afterrender: me.refreshView
                },
                '#tools-menu button': {
                    click: me.onMenuButtonClick,
                    langselect: me.onLangSelect
                }
            }
        });
        me.viewportController = me.app.getViewportController();
        me.soundController = me.app.getSoundController();
        me.callParent(arguments);
    },
    onMenuButtonClick: function(button) {
        var me = this;
        switch (button.action) {
            case 'fullscreen':
                //   ,       
                //   
                if (!Ext.browser.is.IE11 && !Ext.browser.is.Safari) {
                    me.viewportController.doFullscreen();
                };
                break;
            case 'music_off':
                me.soundController.toggleMusic();
                break;
            case 'sound_off':
                me.soundController.toggleSound();
                break;
        }
        me.refreshView();
    },
    /**
     *   
     */
    onLangSelect: function(lang) {
        var me = this;
        ExGods.app.getSettingsController().saveSettings({
            language: lang
        });
    },
    refreshView: function() {
        var me = this,
            toolsMenu = me.getToolsMenu();
        if (toolsMenu) {
            toolsMenu.items.each(function(btn) {
                if (btn.action == 'music_off') {
                    if (me.soundController.isMusicOff()) {
                        btn.addCls('state2');
                    } else {
                        btn.removeCls('state2');
                    }
                } else if (btn.action == 'sound_off') {
                    if (me.soundController.isSoundOff()) {
                        btn.addCls('state2');
                    } else {
                        btn.removeCls('state2');
                    }
                } else if (btn.action == 'lang_select') {
                    btn.setLang(ExGods.app.user.getSetting('language'));
                }
            });
        }
    }
});

/**
 *    (tooltips)
 *
 * @author  
 *
 */
Ext.define('ExGods.controller.TooltipManager', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'TooltipManager:'
    },
    sources: {},
    init: function() {
        var me = this;
        ExGods.Tooltips = me;
        // alias
        me.callParent(arguments);
    },
    onLaunch: function() {
        var me = this;
        new Ext.tip.ToolTip({
            cls: 'exgtip-dummy',
            target: Ext.getBody(),
            delegate: '.exgtip',
            renderTo: Ext.getBody(),
            listeners: {
                beforeshow: function(tip) {
                    me.showTooltip(tip.triggerElement);
                    return true;
                },
                hide: function() {
                    if (me.tipWindow) {
                        me.tipWindow.close();
                        me.tipWindow = null;
                    }
                }
            }
        });
        //        
        me.app.controllers.each(function(item) {
            if (item.tooltips && item.tooltips.length) {
                item.tooltips.forEach(function(type) {
                    me.register(item, type);
                });
            }
        });
    },
    /**
     *    .
     *     getTooltipData(type, value)    
     */
    register: function(src, type) {
        var me = this;
        if (!me.sources[type]) {
            me.sources[type] = [
                src
            ];
        } else if (me.sources[type].indexOf(src) == -1) {
            me.sources[type].push(src);
        }
    },
    /**
     *     
     * @param {Object} config :
     *   {String} type  ,    
     *   {String} value  ,   
     *   {String} tag     
     *   {String} html  
     *   {String} cls   
     * return {String} 
     */
    createTip: function(config) {
        var me = this,
            tpl = [
                '<{tag} class="exgtip {cls}" data-exgtip_type="{type}" data-exgtip_value="{value}" >',
                '{html}',
                '</{tag}>'
            ];
        config.tag = config.tag || 'div';
        config.cls = config.cls || '';
        config.html = config.html || '';
        return ExGods.app.applyTpl(tpl.join(''), config);
    },
    /**
     *  - 
     * @param {Ext.dom.Element/HTMLElement} target Dom 
     * @param {String} type  ,    
     * @param {Mixed} value  ,   
     * return {String|Ext.dom.Element} 
     */
    makeElementAsTip: function(target, type, value) {
        var me = this;
        target = Ext.get(target);
        if (target && target.dom) {
            target.addCls('exgtip');
            target.dom.setAttribute('data-exgtip_type', type);
            target.dom.setAttribute('data-exgtip_value', value);
            return target;
        }
    },
    /**
     *     
     */
    removeTip: function(el) {
        var me = this;
        el = Ext.get(el);
        if (el) {
            el.removeCls('exgtip');
            el.dom.removeAttribute('data-exgtip_type');
            el.dom.removeAttribute('data-exgtip_value');
        }
    },
    /**
     * @private
     */
    showTooltip: function(triggerElement) {
        var me = this,
            data, type, value, tooltip;
        type = triggerElement.getAttribute('data-exgtip_type');
        value = triggerElement.getAttribute('data-exgtip_value');
        if (!me.canTooltipShow(type, value)) {
            return;
        }
        if (!(data = me.getData(type, value))) {
            /***/
            me.log('warn', '   ', type, value);
            return;
        }
        if (me.tipWindow) {
            me.tipWindow.close();
            me.tipWindow = null;
        }
        if (type == 'text') {
            tooltip = me.createTextTooltip(triggerElement, data);
        } else if (type == 'item') {
            tooltip = me.createItemTooltip(triggerElement, data);
        } else if (type == 'proto_item') {
            tooltip = me.createProtoItemTooltip(triggerElement, data);
        } else if (type == 'ingredient' || type == 'currency' || type == 'timed') {
            tooltip = me.createCommonTooltip(triggerElement, data);
        } else if (type == 'slot') {
            tooltip = me.createSlotTooltip(triggerElement, data);
        } else if (type == 'quest') {
            tooltip = me.createQuestTooltip(triggerElement, data);
        } else if (type == 'monster') {
            tooltip = me.createMonsterTooltip(triggerElement, data);
        } else if (type == 'stuff') {
            tooltip = me.createStuffTooltip(triggerElement, data);
        } else {
            /***/
            me.log('warn', '   ', type);
            return;
        }
        me.tipWindow = tooltip;
    },
    /**
     * @private       
     */
    getData: function(type, value) {
        var me = this,
            data;
        if (me.sources[type] && me.sources[type].length) {
            for (var i = 0; i < me.sources[type].length && !data; i++) {
                if (typeof me.sources[type][i].getTooltipData == 'function') {
                    data = me.sources[type][i].getTooltipData(type, value);
                } else {
                    /***/
                    me.log('warn', '    ' + type + '    getTooltipData', me.sources[type][i]);
                }
            }
        }
        return data;
    },
    /**
     * @private
     */
    createTextTooltip: function(triggerElement, data) {
        var me = this;
        return Ext.widget('parchmentwindow', {
            closable: false,
            itemElement: triggerElement,
            html: data,
            bodyPadding: 15
        });
    },
    /**
     * @private
     */
    createItemTooltip: function(triggerElement, data) {
        var me = this;
        return me.app.getItemController().showItemWindow({
            item: data.item,
            proto_id: data.proto.data.id,
            itemEl: triggerElement,
            tooltip: true
        });
    },
    /**
     * @private
     */
    createProtoItemTooltip: function(triggerElement, data) {
        var me = this;
        me.app.getItemController().showItemWindow({
            proto_id: data.proto.data.id,
            itemEl: triggerElement,
            tooltip: true
        });
    },
    /**
     * @private
     */
    createCommonTooltip: function(triggerElement, data) {
        var me = this;
        return Ext.widget('commondetailswindow', {
            closable: false,
            imageSize: 64,
            data: data,
            itemElement: triggerElement
        });
    },
    /**
     * @private
     */
    createSlotTooltip: function(triggerElement, data) {
        var description,
            rows = [];
        if (data.slot.get('protect')) {
            description = [
                '<div style="background: url(' + IMAGE_URL + '/icons/done.png) 0 0 no-repeat; padding-left: 20px;" >',
                ExGods.ref('message_client|slot_protected'),
                '</div>'
            ].join('');
        } else {
            description = ExGods.ref('message_client|slot_not_protected');
        }
        if (data.tooltipText) {
            rows.push({
                content: [
                    '<div class="description-block parchment-content">',
                    '<ul class="table-list">',
                    '<li style="text-align: center;">' + data.tooltipText + '</li>',
                    '</ul>',
                    '</div>'
                ].join('')
            });
        }
        return Ext.widget('commondetailswindow', {
            closable: false,
            data: {
                label: data.slot.get('name'),
                image: ExGods.ref('slot_type|' + data.slot.get('type')).images.empty,
                description: description,
                rows: rows
            },
            itemElement: triggerElement
        });
    },
    /**
     * @private
     */
    createQuestTooltip: function(triggerElement, quest) {
        var me = this,
            printQuestAims = function(quest) {
                var tpl = [
                        '<ul style="padding-bottom: 5px;">',
                        '<tpl for="aims">',
                        '<tpl if="this.getImage(values)">',
                        '<li style="background-image: url({[this.getImage(values)]});background-repeat: no-repeat; padding: 0 0 2px 20px;">{name} {[this.getCounters(values)]}</li>',
                        '<tpl else>',
                        '<li style="padding: 0 0 2px 0;">{name} {[this.getCounters(values)]}</li>',
                        '</tpl>',
                        '</tpl>',
                        '</ul>',
                        {
                            getImage: function(aim) {
                                var images = ExGods.ref('images|quest_icons').image,
                                    src,
                                    title = '';
                                switch (quest.data.status) {
                                    case 1:
                                    case 4:
                                        src = images['aim_' + (aim.done ? 'done' : 'undone')];
                                        break;
                                    case 2:
                                    case 3:
                                    case 5:
                                        src = images['aim_done'];
                                        break;
                                    default:
                                        break;
                                }
                                
                                return src;
                            },
                            getCounters: function(aim) {
                                var html = '';
                                if (aim.counter && aim.counter.length && (quest.data.status == 1 || quest.data.status == 2 || quest.data.status == 4)) {
                                    Ext.Array.forEach(aim.counter, function(counter, index) {
                                        if (counter.type != 1) {
                                            html = '(' + counter.curr + '/' + counter.need + ')';
                                        }
                                    });
                                }
                                return html;
                            }
                        }
                    ];
                tpl = new Ext.XTemplate(tpl);
                return tpl.applyTemplate(quest.data);
            };
        return Ext.widget('commondetailswindow', {
            closable: false,
            data: {
                label: quest.data.name,
                image: quest.getGiverThumb(),
                rows: [
                    {
                        content: printQuestAims(quest)
                    }
                ]
            },
            itemElement: triggerElement
        });
    },
    /**
     * @private
     */
    createStuffTooltip: function(triggerElement, stuffObj) {
        return stuffObj.details({
            clickedEl: triggerElement,
            tooltip: true
        });
    },
    /**
     * @private
     */
    canTooltipShow: function(type, value) {
        var me = this,
            cmp;
        if (!type || !value) {
            return false;
        }
        if ([
            'item',
            'slot',
            'proto_item',
            'ingredient',
            'currency',
            'timed',
            'stuff'
        ].indexOf(type) != -1) {
            cmp = Ext.ComponentQuery.query('parchmentwindow');
            if (cmp.length > 1 || (cmp.length == 1 && cmp[0] != me.tipWindow)) {
                return false;
            }
        }
        return true;
    }
});

/**
 *  
 */
Ext.define('ExGods.view.quest.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.questtabpanel',
    tabUi: 'skintext',
    bodyPadding: '0 10 8 8',
    initComponent: function() {
        var me = this;
        me.callParent();
        var style = {
                color: '#cd9c64',
                margin: '9px'
            };
        me.down('tabbar').add([
            {
                dock: 'top',
                xtype: 'checkbox',
                boxLabel: ExGods.getMsgByKey('view_quest_tabpanel_story'),
                name: 'story',
                style: style,
                checked: true
            },
            {
                dock: 'top',
                xtype: 'checkbox',
                boxLabel: ExGods.getMsgByKey('view_quest_tabpanel_daily'),
                name: 'daily',
                style: style,
                checked: true
            }
        ]);
        me.on('afterrender', function() {
            var count = ExGods.app.getUser().availableQuestsStore.getCount();
            if (count > 0) {
                me.setActiveTab('available_quests');
            } else {
                me.setActiveTab('active_quests');
            }
        });
    },
    //      me.on('show',function(){
    //          ExGods.app.getQuestController().getQuestButton().reset();
    //      });
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {};
        }
        Ext.applyIf(item.tabConfig, {
            quantityLeft: item.quantityLeft || 0,
            countLabel: true,
            item: item
        });
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.quest.NewList', {
    extend: ExGods.view.List,
    alias: 'widget.questnewlist',
    margin: '-3px -3px 0 -3px',
    cls: 'questnewlist',
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            scrollDeltaY: 50,
            autoHide: true,
            autoRestorePosition: true,
            padding: '3px 3px 0 0'
        }
    ],
    emptyTpl: [
        '<p class="central-window-empty">{text}</p>'
    ],
    initComponent: function() {
        var me = this;
        me.itemWidgetConfig = {
            xtype: 'questlistitem',
            autoShow: false,
            listeners: {
                expand: me.onItemExpand,
                collapse: me.onItemCollapse,
                scope: me
            }
        };
        me.emptyData = {
            text: ExGods.getMsgByKey('view_quest_newlist_emptytext')
        };
        me.noQuestsChecked = ExGods.ref('message_client|noquestschecked');
        me.callParent(arguments);
    },
    onItemExpand: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onItemCollapse: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onRender: function() {
        var me = this;
        me.checkboxes = me.up().query('checkbox');
        if (!me.skipFilter) {
            Ext.each(me.checkboxes, function(item) {
                me.onCheckBoxChange(item, item.checked);
                item.on('change', me.onCheckBoxChange, me);
            });
        } else {
            Ext.each(me.checkboxes, function(item) {
                item.hide();
            });
        }
        me.callParent(arguments);
    },
    onShow: function() {
        var me = this;
        Ext.each(me.checkboxes, function(item) {
            if (me.skipFilter) {
                item.hide();
            } else {
                item.show();
            }
        });
        me.callParent(arguments);
    },
    onCheckBoxChange: function(checkbox, checked) {
        var me = this;
        if (!checked) {
            if (me.store.filters.length == 1) {
                me.emptyData.text = me.noQuestsChecked;
            } else {
                me.emptyData.text = me.emptyText;
            }
            switch (checkbox.name) {
                case 'story':
                    me.store.addFilter(Ext.util.Filter({
                        filterFn: function(item) {
                            return item.data.repeat;
                        },
                        //   - ,    
                        id: checkbox.name
                    }));
                    break;
                case 'daily':
                    me.store.addFilter(Ext.util.Filter({
                        filterFn: function(item) {
                            return !item.data.repeat;
                        },
                        //   -  
                        id: checkbox.name
                    }));
                    break;
            }
        } else {
            me.emptyData.text = me.emptyText;
            me.store.removeFilter(checkbox.name);
        }
        if (me.items) {
            me.collapseAll();
        }
        if (me.scroller && me.scroller.scrollEl) {
            me.scrollToTop();
            me.scroller.onResize();
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var obj = ExGods.references.get('images').get('quest_icons').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        obj = ExGods.ref('images|common_text_images').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        var parent = me.callParent();
        return {
            stuff: [].concat(parent.stuff),
            images: [
                IMAGE_URL + 'quests/bg.png',
                IMAGE_URL + 'quests/top_1.png',
                IMAGE_URL + 'quests/top_2.png',
                IMAGE_URL + 'quests/top_3.png',
                IMAGE_URL + 'quests/side_left.png',
                IMAGE_URL + 'quests/side_right.png',
                IMAGE_URL + 'quests/bottom_1.png',
                IMAGE_URL + 'quests/bottom_2.png',
                IMAGE_URL + 'quests/bottom_3.png',
                IMAGE_URL + 'quests/item_box.jpg',
                IMAGE_URL + 'quests/button_task_close.png',
                IMAGE_URL + 'scrollbar/thumb.png',
                IMAGE_URL + 'scrollbar/bg_midle.png',
                IMAGE_URL + 'scrollbar/bg_top.png',
                IMAGE_URL + 'scrollbar/bg_bottom.png',
                IMAGE_URL + 'shop/btn_buy.png',
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 * C 
 */
Ext.define('ExGods.view.quest.Column', {
    extend: Ext.panel.Panel,
    alias: 'widget.questcolumn',
    flex: 1,
    layout: 'card',
    header: false,
    cls: 'location-quest-column',
    // plugins: ['skinparchmentdeco'],
    /**
     * @cfg {Ext.data.Store} store (required)
     *  
     */
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    initComponent: function() {
        var me = this;
        var questsTpl = new Ext.XTemplate('<div class="location-header" style="margin:0 0 -4px 1px"><div class="location-header-title quests" style="background-image:url(' + ExGods.ref('images|location_images').image.quests_title + ');"></div></div>', '<ul class="quests">', '<tpl for=".">', '<tpl if="xindex &lt; 5">', '<li class="quest {[values.params.is_tutorial ? "tutorial" : ""]} {[values.status ==2 ? "finish" : values.status ==  1 ? "active" : ""]} exgtip" style="cursor: pointer;margin-left:0px" data-exgtip_type="quest" data-exgtip_value="{proto_id}">', '<div class="quest-giver-border">', '<div class="quest-giver-image" style="background-image:url({[this.getThumb(values)]})">', '<div class="quest-giver-sign" {[this.getStatusIcon(values)]}"></div>', '</div>', '</div>', '</li>', '</tpl>', '</tpl>', '</ul>', {
                shapes: ExGods.references.get('user_shape'),
                getThumb: function(values) {
                    var quest = me.store.getById(parseInt(values.proto_id));
                    return quest.getGiverThumb();
                },
                getStatusIcon: function(values) {
                    var icon = '';
                    switch (values.status) {
                        case 0:
                        case 3:
                            if (values.params.story == 3) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_green.png';
                            } else if (values.params.repeat) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_blue.png';
                            } else {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_yellow.png';
                            };
                            break;
                        case 2:
                            if (values.params.story == 3) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_green.png';
                            } else if (values.params.repeat) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_blue.png';
                            } else {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_yellow.png';
                            };
                            break;
                    }
                    if (icon) {
                        return 'style="background-image:url(' + icon + ')"';
                    }
                }
            });
        me.initStore();
        me.quests = Ext.widget('viewpanel', {
            layout: 'absolute',
            store: me.store,
            bodyStyle: {
                overflow: 'visible'
            },
            viewConfig: {
                itemSelector: 'li.quest',
                tpl: questsTpl,
                listeners: {
                    refresh: me.onViewRefresh,
                    scope: me
                }
            }
        });
        // me.quests.relayEvents(me, ['show']);
        me.items = [
            me.quests
        ];
        me.energyCounter = Ext.widget('component', {
            margin: '0 0 0 4',
            position: 'absolute',
            width: 80
        });
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent();
        //       
        me.getEl().setStyle({
            overflow: 'visible'
        });
        me.body.el.setStyle({
            overflow: 'visible'
        });
        me.ownerCt.getEl().setStyle({
            overflow: 'visible'
        });
    },
    /**
     *       ,    
     */
    initStore: function() {
        var me = this,
            available = me.user.availableQuestsStore,
            questsStore = ExGods.app.getStore('Quests');
        me.store = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.Quest'
        });
        var loadStore = function(store) {
                var me = this,
                    add = false;
                if (questsStore.totalCount) {
                    var collection = questsStore.queryBy(function(record, id) {
                            var status = record.get('status');
                            return status == 0 || status == 2;
                        });
                    me.store.loadRecords(collection.items);
                    add = true;
                }
                if (available.totalCount) {
                    me.store.loadRecords(available.data.items, {
                        addRecords: add
                    });
                    add = true;
                }
                if (questsStore.totalCount) {
                    var collection = questsStore.queryBy(function(record, id) {
                            var status = record.get('status');
                            return status != 0 && status != 2;
                        });
                    me.store.loadRecords(collection.items, {
                        addRecords: add
                    });
                }
            };
        loadStore.call(me);
        me.mon(available, 'datachanged', loadStore, me);
        me.mon(available, 'update', loadStore, me);
        me.mon(questsStore, 'datachanged', loadStore, me);
        me.mon(questsStore, 'update', loadStore, me);
    },
    bindStore: function(store) {
        this.quests.bindStore(store);
    },
    /**
     * @private
     */
    onViewRefresh: function(view, opts) {
        var me = this;
        view.getStore().each(function(record) {
            if (record.get('status') == ExGods.model.Quest.COMPLETE && record.get('timerest') > 0) {
                me.updateQuestTimer(record);
            }
        });
    },
    /**
     * @private
     *    
     *
     * @param {ExGods.model.Quest} quest
     */
    updateQuestTimer: function(quest) {
        var me = this,
            qid = quest.getId(),
            timerest = quest.get('timerest'),
            timers = me._timers || {},
            node = me.quests.getView().getNode(quest);
        if (timers[qid]) {
            window.clearInterval(timers[qid]);
            timers[qid] = 0;
        }
        timers[qid] = window.setInterval(function() {
            if (timerest-- >= 0) {
                if (node) {
                    Ext.fly(node).select('.countdown').setHTML(Ext.util.Format.countdown(timerest));
                }
            } else {
                window.clearInterval(timers[qid]);
                timers[qid] = 0;
            }
        }, 1000);
        me._timers = timers;
    },
    onDestroy: function() {
        var me = this;
        me.store.clearFilter();
        me.callParent(arguments);
    },
    /**
     *      ,    
     */
    locationObjectClickHandler: function(e) {
        return false;
    }
});

/**
 *     ()
 *
 *  ExGods.view.plugin.ParchmentDeco
 */
Ext.define('ExGods.view.plugin.SimpleParchmentDeco', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.simpleparchmentdeco',
    init: function(cmp) {
        cmp.addClsWithUI('parchment');
        if (typeof cmp.padding == 'undefined') {
            cmp.padding = 8;
        }
        if (cmp.isPanel) {
            if (!cmp.title)  {
                cmp.title = ' ';
            }
            
            Ext.override(cmp, {
                addTool: function(tools) {
                    var i = 0;
                    tools = [].concat(tools);
                    for (; i < tools.length; i++) {
                        //    ""   3231
                        tools[i].height = 31;
                        tools[i].width = 32;
                    }
                    this.callParent(arguments);
                }
            });
        }
        cmp.on('render', this.addDeco, this);
    },
    addDeco: function() {
        var me = this,
            cmp = me.cmp;
        if (cmp.header)  {
            cmp.header.setHeight(0);
        }
        
        if (cmp.bodyBorder !== false)  {
            cmp.el.insertHtml('afterBegin', '<div class="parchment-border"></div>');
        }
        
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', this.addDeco, this);
        me.cmp = null;
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'close.png',
                IMAGE_URL + 'parchment-tl.jpg',
                IMAGE_URL + 'parchment-tm.jpg',
                IMAGE_URL + 'parchment-tr.jpg',
                IMAGE_URL + 'parchment-mr.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'parchment-br.jpg',
                IMAGE_URL + 'parchment-bm.jpg',
                IMAGE_URL + 'parchment-bl.jpg',
                IMAGE_URL + 'parchment-ml.jpg',
                IMAGE_URL + 'parchment-bg.jpg',
                IMAGE_URL + 'separator-horizontal.jpg'
            ]
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.view.parchment.Window', {
    extend: Ext.window.Window,
    alias: 'widget.parchmentwindow',
    autoShow: true,
    bodyBorder: false,
    bodyPadding: 0,
    closable: true,
    cascade: true,
    draggable: false,
    header: {
        margin: 0
    },
    style: {
        overflow: 'visible'
    },
    /**
     * @cfg {Boolean} hideOnOuterClick 
     *        
     */
    hideOnOuterClick: true,
    layout: 'absolute',
    /**
     * @cfg {Ext.Element} maskCt
     *    
     */
    padding: '0 4 4',
    plugins: [
        'paperdeco'
    ],
    renderTo: Ext.getBody(),
    resizable: false,
    shadow: false,
    width: 230,
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
        me.on('hide', me.onWndHide, me);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        setTimeout(function() {
            me.doLayout();
        }, //     
        0);
    },
    onShowComplete: function() {
        var me = this,
            windowPosition, parentWindow;
        me.callParent(arguments);
        if (me.itemElement) {
            if (Ext.get(me.itemElement) && Ext.get(me.itemElement).up('.x-window') && me.cascade) {
                //     
                var coords = Ext.get(me.itemElement).up('.x-window').getXY();
                if (coords[0] + me.getSize().width + 20 <= Ext.getBody().getSize().width + Ext.getBody().getScroll().left) {
                    coords[0] += 20;
                } else {
                    coords[0] = Ext.getBody().getSize().width + Ext.getBody().getScroll().left - me.getSize().width - 21;
                }
                if (coords[1] + me.getSize().height + 20 <= Ext.getBody().getSize().height + Ext.getBody().getScroll().top) {
                    coords[1] += 20;
                } else {
                    coords[1] = Ext.getBody().getSize().height + Ext.getBody().getScroll().top - me.getSize().height - 21;
                }
                windowPosition = {
                    left: coords[0],
                    top: coords[1]
                };
                //  ,      
                var parentWindow = Ext.getCmp(Ext.get(me.itemElement).up('.x-window').id);
                if (parentWindow) {
                    me.mon(parentWindow, 'close', function() {
                        setTimeout(function() {
                            me.close();
                        }, 0);
                    });
                    me.mon(parentWindow, 'activate', function() {
                        setTimeout(function() {
                            me.close();
                        }, 0);
                    });
                }
            } else {
                windowPosition = me.getItemWindowPosition(me.itemElement, me.maskCt);
            }
        }
        if (windowPosition) {
            if (windowPosition.left == 0 && windowPosition.top == 0) {
                me.close();
                return;
            } else {
                me.setPosition(windowPosition.left, windowPosition.top);
            }
        }
        if (me.hideOnOuterClick) {
            setTimeout(function() {
                Ext.getBody().on('click', me.processOuterClick, me);
            }, 10);
        }
    },
    onWndHide: function() {
        var me = this;
        if (me.hideOnOuterClick) {
            Ext.getBody().un('click', me.processOuterClick, me);
        }
    },
    processOuterClick: function(e, el) {
        var me = this;
        if (me.isVisible() && !Ext.fly(el).up('.' + me.cls) && !Ext.fly(el).up('.x-window') && me.plugins) //   
        {
            me.close();
        }
    },
    /**
     *   - 
     * @private
     *
     * @param {ExGods.view.item.Item/HTMLElement} item  
     * @return {Object}  -
     *
     *  {
     *      left: <left offset>,
     *      top: <top offset>
     *  }
     */
    getItemWindowPosition: function(item, container) {
        var me = this,
            itemPosition;
        if (Ext.isElement(item)) {
            item = Ext.get(item);
            itemPosition = item.getXY();
        } else {
            itemPosition = item.el.getXY();
        }
        // Ext JS 4.1rc1
        var windowPosition = {
                left: itemPosition[0],
                top: itemPosition[1]
            },
            itemSize = item.getSize(),
            itemWidth = item.getWidth(),
            windowSize = me.getSize(),
            containerSize = null,
            isBodyContainer = false;
        if (item.up('.pergament')) {
            container = item.up('.pergament');
            containerSize = container.getSize();
        } else if (container) {
            containerSize = container.getSize();
        } else if (container = item.up('#right-container')) {
            containerSize = container.getSize();
        } else if (container = item.up('#doll-panel')) {
            containerSize = container.getSize();
        } else {
            container = Ext.getBody();
            isBodyContainer = true;
            containerSize = container.getSize();
        }
        if (isBodyContainer) {
            var containerScroll = container.getScroll();
            if (windowPosition.left + itemSize.width + windowSize.width <= containerSize.width + containerScroll.left) {
                windowPosition.left += itemSize.width;
            } else {
                windowPosition.left -= windowSize.width;
            }
            if (windowPosition.top + windowSize.height + 4 > containerSize.height + containerScroll.top) {
                windowPosition.top -= (windowPosition.top + windowSize.height + 4) - (containerSize.height + containerScroll.top);
            }
        } else {
            var containerPosition;
            if (!container.el) {
                containerPosition = container.getOffsetsTo(Ext.getBody());
            } else {
                containerPosition = container.el.getOffsetsTo(Ext.getBody());
            }
            if (windowPosition.left + itemSize.width + windowSize.width <= containerSize.width + containerPosition[0] || windowPosition.left - windowSize.width < 0) {
                windowPosition.left += itemSize.width;
            } else {
                windowPosition.left -= windowSize.width;
            }
            if (windowPosition.top + windowSize.height > containerSize.height + containerPosition[1]) {
                windowPosition.top -= (windowPosition.top + windowSize.height) - (containerSize.height + containerPosition[1]);
            }
        }
        return windowPosition;
    }
});

/**
 *   .  , ,  .
 */
Ext.define('ExGods.view.CommonDetailsWindow', {
    extend: ExGods.view.parchment.Window,
    alias: 'widget.commondetailswindow',
    /**
     * @cfg {Object} data (required)
     *   label {String}  
     *   description {String}  
     *   image {String} URL , 
     *   rows {Array}   .      :
     *      cls {String} CSS    
     *      title {String}  
     *      content {String}  
     *      separator {Boolean}       , 
     */
    data: {},
    /**
      * @cfg {Number} imageSize (52  64)
      */
    imageSize: 52,
    /**
      * @cfg {Template} headerTpl
      */
    headerTpl: [
        '<div class="parchment-content cf header">',
        '<span style="display: table;">',
        '<div class="image image{imageSize}" style="background-image: url({image});"></div>',
        '<span class="label">{label}</span>',
        '</span>',
        '</div>'
    ],
    cls: 'common-details-window',
    padding: '4 4 10 4',
    initComponent: function() {
        var me = this;
        me.html = '';
        me.data = me.config.data;
        me.data.imageSize = me.imageSize;
        me.headerTpl = new Ext.XTemplate(me.headerTpl).apply(me.data);
        me.tpl = [
            //   
            me.headerTpl,
            // 
            '<tpl if="description">',
            '<div class="separator"></div>',
            '<div class="description parchment-content">',
            '{[ExGods.app.applyTpl(values.description)]}',
            '</div>',
            '</tpl>',
            // 
            '<tpl for="rows">',
            '<tpl if="content">',
            '<div class="separator" style="{[ values.separator === false ? "display: none;" : "" ]}"></div>',
            '<div class="row parchment-content {[ values.cls ? values.cls : ""]}">',
            '<tpl if="title">',
            '<div class="paper-title title">{title}</div>',
            '</tpl>',
            '{content}',
            '</div>',
            '</tpl>',
            '</tpl>',
            '<tpl if="this.hasButtons">',
            '<div class="separator"></div>',
            '</tpl>',
            {
                hasButtons: me.buttons ? me.buttons.length : false
            }
        ];
        if (me.buttons && me.buttons.length) {
            me.dockedItems = [
                {
                    xtype: 'toolbar',
                    layout: 'anchor',
                    dock: 'bottom',
                    itemId: 'actions',
                    margin: '4 0 14 0',
                    padding: '0 16 0 16',
                    defaults: {
                        anchor: '100%',
                        margin: '2 0',
                        cls: 'no_border'
                    },
                    defaultType: 'textbutton',
                    items: me.buttons
                }
            ];
            delete me.buttons;
        }
        
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                me.data.image
            ]
        };
    }
});

Ext.define('ExGods.view.quest.ListItem', {
    extend: ExGods.view.ListItem,
    alias: 'widget.questlistitem',
    margin: '0 0 -3px 0',
    initComponent: function() {
        var me = this;
        //if(me.record.get('timedropfrom')) debugger
        var templateHelpers = {
                getDesc: function(desc) {
                    return ExGods.app.applyTpl(desc, {
                        u: ExGods.app.getUser().data
                    });
                },
                images: ExGods.references.get('images').get('quest_icons').image,
                shapes: ExGods.references.get('user_shape'),
                getThumb: function(values) {
                    if (values.giver && values.giver.shape) {
                        return this.shapes.getByKey(values.giver.shape).thumb;
                    } else if (values.giver && values.giver.image_thumb) {
                        //  giver 
                        return IMAGE_URL + values.giver.image_thumb;
                    } else if (values.giver && values.giver.icon) {
                        //  giver 
                        return IMAGE_URL + values.giver.icon;
                    } else if (values.params && values.params.image) {
                        return IMAGE_URL + values.params.image;
                    } else {
                        return Ext.BLANK_IMAGE_URL;
                    }
                },
                /**
             * status:
             * 0: 
             * 1:   
             * 2: 
             * 3:   
             * 4: 
             * 5: 
             */
                getStatusIcon: function(values) {
                    var icon = '';
                    switch (values.status) {
                        case 0:
                        case 3:
                            if (values.params.story == 3) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_green.png';
                            } else if (values.params.repeat) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_blue.png';
                            } else {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_exclamation_yellow.png';
                            };
                            break;
                        case 2:
                            if (values.params.story == 3) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_green.png';
                            } else if (values.params.repeat) {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_blue.png';
                            } else {
                                icon = '' + IMAGE_URL + 'quests/icon_quest_question_yellow.png';
                            };
                            break;
                    }
                    if (icon) {
                        return 'style="background-image:url(' + icon + ')"';
                    }
                },
                checkDaily: function(repeat) {
                    return repeat ? ' (' + ExGods.getMsgByKey('view_quest_listitem_daily') + ')' : '';
                },
                getAimStatus: function(status, done, count) {
                    var images = ExGods.references.get('images').get('quest_icons').image,
                        src = Ext.BLANK_IMAGE_URL,
                        title = '';
                    switch (status) {
                        case 1:
                        case 4:
                            src = images['aim_' + (done ? 'done' : 'undone')];
                            break;
                        case 2:
                        case 3:
                        case 5:
                            src = images.aim_done;
                            break;
                        default:
                            break;
                    }
                    return (src) ? 'style="background-image:url(' + src + ');text-indent:10px;' + ((count == 1) ? 'margin:5px 0' : '') + '"' : '';
                },
                getAimText: function(text) {
                    return text.replace(/["']/g, "&quot;");
                },
                getCounters: function(values, status, xindex, qtip) {
                    var out = '',
                        counters = values.counter,
                        arr = [];
                    xindex = xindex - 1;
                    if (counters && counters.length && (status == 1 || status == 2 || status == 4)) {
                        Ext.Array.forEach(counters, function(counter, index) {
                            if (counter.type == 1) {
                                if (qtip) {
                                    arr.push('(' + Ext.util.Format.countdown(counter.left, {
                                        format: 'short'
                                    }) + ')');
                                } else {
                                    index = xindex + '_' + index;
                                    var text = '';
                                    if (counter.left)  {
                                        text = '(' + Ext.util.Format.countdown(counter.left, {
                                            format: 'short'
                                        }) + ')';
                                    }
                                    
                                    arr.push('<span class="aim-ticker-' + index + '">' + text + '</span>');
                                    me.mon(me.record, 'aimcounter_' + index, function(left, record) {
                                        var span = me.el.down('.aim-ticker-' + index);
                                        if (me.el && span) {
                                            if (left < 1) {
                                                span.update('');
                                                span.up('li').setStyle('background-image', 'url(' + ExGods.references.get('images').get('quest_icons').image.aim_done + ')');
                                            } else {
                                                span.update('(' + Ext.util.Format.countdown(left, {
                                                    format: 'short'
                                                }) + ')');
                                            }
                                        }
                                    });
                                }
                            } else {
                                arr.push('(' + counter.curr + '/' + counter.need + ')');
                            }
                        });
                        if (arr.length) {
                            out = arr.join(', ');
                        }
                    }
                    return out;
                },
                showTimeToPerform: function(data) {
                    return data.timedropfrom && data.timedropfrom > 0 && (data.status == ExGods.model.Quest.ACTIVE || data.status == ExGods.model.Quest.READY_TO_COMPLETE);
                },
                /**
             * True,     
             * @return {Boolean}
             */
                isTraceable: function(qid) {
                    var quest = me.up('questnewlist').store.getById(qid);
                    return quest ? quest.isTraceable() : false;
                },
                /**
             * True,   
             * @return {Boolean}
             */
                isTraced: function(qid) {
                    var quest = me.up('questnewlist').store.getById(qid);
                    return quest ? quest.isTraced() : false;
                }
            };
        var expanded = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{name}{[this.templateHelpers.checkDaily(values.params.repeat)]}</h4>',
                '<div class="view-change-selector expanded"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url({[this.templateHelpers.getThumb(values)]})">',
                '<div class="quest-giver-sign" {[this.templateHelpers.getStatusIcon(values)]}"></div>',
                '</div>',
                '</div>',
                '<tpl if="this.templateHelpers.showTimeToPerform(values)">',
                '<div class="quest-timer">',
                '<span class="dropdown">{timedropfrom:countdown}</span>',
                '</div>',
                '</tpl>',
                '</div>',
                '<div class="wide-column">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image.title_aim + ')"></div>',
                '<div class="info-box-content">',
                '<tpl if="aims.length">',
                '<ul>',
                '<tpl for="aims">',
                '<tpl if="parent.status == 0 || parent.status == -1">',
                '<tpl if="stage == 1">',
                //       
                '<li class="aim" {[this.templateHelpers.getAimStatus(parent.status, values.done, parent.aims.length)]}>',
                '<span class="aim-text" data-qtip="{[this.templateHelpers.getAimText(values.name)]}{[this.templateHelpers.getCounters(values, parent.status, xindex, 1)]}">{name}' + ' {[this.templateHelpers.getCounters(values, parent.status, xindex)]}' + '</span>',
                '</li>',
                '</tpl>',
                '<tpl else>',
                '<li class="aim" {[this.templateHelpers.getAimStatus(parent.status, values.done, parent.aims.length)]}>',
                '<span class="aim-text" data-qtip="{[this.templateHelpers.getAimText(values.name)]}{[this.templateHelpers.getCounters(values, parent.status, xindex, 1)]}">{name}' + ' {[this.templateHelpers.getCounters(values, parent.status, xindex)]}' + '</span>',
                '</li>',
                '</tpl>',
                '</tpl>',
                '</ul>',
                '</tpl>',
                '</div>',
                '</div>',
                '<tpl if="random_rewards && random_rewards.length  || rewards && rewards.length">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image.title_award + ')"></div>',
                '<div class="info-box-content info-box-rewards">',
                '<ul>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '</ul>',
                '</div>',
                '</div>',
                '</tpl>',
                '<div class="button-place expanded" id="button-place-{proto_id}"></div>',
                '</div>',
                '<div class="quest-description">{[this.templateHelpers.getDesc(values.desc)]}</div>',
                '</div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        var collapsed = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{name}{[this.templateHelpers.checkDaily(values.params.repeat)]}</h4>',
                '<div class="view-change-selector collapsed"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url({[this.templateHelpers.getThumb(values)]})">',
                '<div class="quest-giver-sign" {[this.templateHelpers.getStatusIcon(values)]}"></div>',
                '</div>',
                '</div>',
                '<tpl if="this.templateHelpers.showTimeToPerform(values)">',
                '<div class="quest-timer">',
                '<span class="dropdown">{timedropfrom:countdown}</span>',
                '</div>',
                '</tpl>',
                '</div>',
                '<div class="wide-column">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_aim'] + ')"></div>',
                '<div class="info-box-content">',
                '<tpl if="aims.length">',
                '<ul>',
                '<tpl for="aims">',
                '<tpl if="parent.status == 0 || parent.status == -1">',
                '<tpl if="stage == 1">',
                //       
                '<li class="aim" {[this.templateHelpers.getAimStatus(parent.status, values.done, parent.aims.length)]}>',
                '<span class="aim-text" data-qtip="{[this.templateHelpers.getAimText(values.name)]}{[this.templateHelpers.getCounters(values, parent.status, xindex, 1)]}">{name}' + ' {[this.templateHelpers.getCounters(values, parent.status, xindex)]}' + '</span>',
                '</li>',
                '</tpl>',
                '<tpl else>',
                '<li class="aim" {[this.templateHelpers.getAimStatus(parent.status, values.done, parent.aims.length)]}>',
                '<span class="aim-text" data-qtip="{[this.templateHelpers.getAimText(values.name)]}{[this.templateHelpers.getCounters(values, parent.status, xindex, 1)]}">{name}' + ' {[this.templateHelpers.getCounters(values, parent.status, xindex)]}' + '</span>',
                '</li>',
                '</tpl>',
                '</tpl>',
                '</ul>',
                '</tpl>',
                '</div>',
                '</div>',
                '<div class="button-place expanded" id="button-place-{proto_id}"></div>',
                '</div>',
                '</div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        me.itemId = me.record.get('proto_id');
        me.expanded = me.setTpl(expanded);
        me.collapsed = me.setTpl(collapsed);
        me.callParent(arguments);
        me.on('render', function() {
            if (me.record.get('expanded') === true) {
                me.expand();
            } else {
                me.collapse();
            }
            me.el.on('click', function() {
                me.fireEvent('questaction', me.record);
            }, me, {
                delegate: '.world-quest-action'
            });
            me.el.on('click', function() {
                me.fireEvent('questcancel', me.record);
            }, me, {
                delegate: '.world-quest-cancel'
            });
            me.el.on('click', function() {
                me.fireEvent('questreroll', me.record);
            }, me, {
                delegate: '.world-quest-reroll'
            });
        });
        if (me.record.get('timedropfrom')) {
            me.mon(me.record, 'timedropchanged', function(time) {
                me.formatTime(time);
            }, me);
        }
    },
    formatTime: function(time) {
        var me = this;
        if (me.el) {
            var dropdown = me.el.down('.dropdown');
            if (dropdown) {
                if (time > 0) {
                    dropdown.update(Ext.util.Format.countdown(time, {
                        format: 'short'
                    }));
                } else {
                    me.destroy();
                }
            }
        }
    },
    getRewards: function() {
        var me = this,
            rewards = me.record.get('rewards') || [],
            random_rewards = me.record.get('random_rewards');
        if (random_rewards) {
            if (typeof random_rewards == 'object') {
                rewards = rewards.concat(random_rewards);
            } else {
                rewards = rewards.concat({
                    type: 'item',
                    params: {
                        id: ExGods.ref('constants|random_reward').value
                    }
                });
            }
        }
        if (rewards.length) {
            ExGods.util.Helper.loadProtosFromStuff(rewards, function() {
                var rewardsHtml = ExGods.stuff.StuffManager.image(rewards),
                    rewardsEl = document.createElement('div'),
                    ul = me.el && me.el.down('.info-box-rewards ul');
                rewardsEl.innerHTML = rewardsHtml;
                Ext.get(rewardsEl).select('li').addCls('info-box-itembox');
                if (ul) {
                    ul.update(rewardsEl.firstChild.innerHTML);
                    for (var i = rewards.length; i < 7; i++) {
                        ul.insertHtml('beforeEnd', '<li class="info-box-itembox"></li>');
                    }
                }
            });
        }
    },
    renderSubmitButton: function() {
        var me = this,
            status = me.record.get('status'),
            droppable = me.record.get('droppable'),
            id = me.record.get('proto_id'),
            reroll_stuff = me.record.get('reroll_stuff'),
            params = {};
        switch (status) {
            case 0:
                params.text = ExGods.getMsgByKey('view_quest_listitem_takebtn');
                params.cls = 'qh-object world-quest-action no_border';
                break;
            case 2:
                params.text = ExGods.getMsgByKey('view_quest_listitem_rewardbtn');
                params.cls = 'qh-object world-quest-action no_border';
                break;
        }
        if (droppable && !params.text) {
            params.text = ExGods.getMsgByKey('view_quest_listitem_cancelbtn');
            params.cls = 'qh-object x-btn-txt-red world-quest-cancel no_border';
        }
        params.width = 163;
        params.renderTo = 'button-place-' + id;
        if (params.text) {
            var btn = Ext.widget('textbutton', params);
            if (me.record.data.params.is_tutorial && (me.record.data.status == 0 || me.record.data.status == 2))  {
                btn.el.set({
                    'data-qh_otype': 'tutorial_quests',
                    'data-qh_oid': '1',
                    'data-qh_opts': "{&quot;cls&quot;:&quot;flip-h&quot;}"
                });
            }
            
        }
        //  ,     
        if (reroll_stuff && status == 0) {
            var rerollBtn = Ext.widget('textbutton', {
                    text: ExGods.getMsgByKey('quest_reroll_btn_text') + ExGods.util.Stuff.printStuff(reroll_stuff),
                    cls: 'x-btn-txt-red world-quest-reroll no_border',
                    width: params.width,
                    renderTo: params.renderTo,
                    style: {
                        marginLeft: '15px'
                    }
                });
            me.el.down('#' + params.renderTo).setStyle('margin-left', '-170px');
        }
    },
    collapse: function() {
        var me = this;
        me.collapsed.overwrite(me.el, me.record.data);
        me.formatTime(me.record.get('timedropfrom'));
        me.renderSubmitButton();
        me.record.set('expanded', false);
        me.callParent();
    },
    expand: function() {
        var me = this;
        me.expanded.overwrite(me.el, me.record.data);
        me.formatTime(me.record.get('timedropfrom'));
        me.getRewards();
        me.renderSubmitButton();
        me.record.set('expanded', true);
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var rewards = [];
        var obj = ExGods.references.get('images').get('quest_icons').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        obj = ExGods.ref('images|common_text_images').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        rewards = me.record.get('rewards') || [] , random_rewards = me.record.get('random_rewards');
        if (random_rewards) {
            if (typeof random_rewards == 'object') {
                rewards = rewards.concat(random_rewards);
            } else {
                rewards = rewards.concat({
                    type: 'item',
                    params: {
                        id: ExGods.ref('constants|random_reward').value
                    }
                });
            }
        }
        return {
            stuff: rewards || [],
            images: [
                IMAGE_URL + 'quests/bg.png',
                IMAGE_URL + 'quests/top_1.png',
                IMAGE_URL + 'quests/top_2.png',
                IMAGE_URL + 'quests/top_3.png',
                IMAGE_URL + 'quests/side_left.png',
                IMAGE_URL + 'quests/side_right.png',
                IMAGE_URL + 'quests/bottom_1.png',
                IMAGE_URL + 'quests/bottom_2.png',
                IMAGE_URL + 'quests/bottom_3.png',
                IMAGE_URL + 'quests/item_box.jpg',
                IMAGE_URL + 'quests/button_task_close.png',
                IMAGE_URL + 'scrollbar/thumb.png',
                IMAGE_URL + 'scrollbar/bg_midle.png',
                IMAGE_URL + 'scrollbar/bg_top.png',
                IMAGE_URL + 'scrollbar/bg_bottom.png',
                IMAGE_URL + 'shop/btn_buy.png',
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images)
        };
    }
});

/**
 *   actions .
 *
 *    Dialog view   actions
 *
 * @author  
 *
 */
Ext.define('ExGods.view.dialog.DialogActions', {
    extend: Ext.container.Container,
    alias: 'widget.dialog_actions',
    dock: 'bottom',
    layout: 'anchor',
    id: 'actions-container',
    margin: '4 0 0 0',
    /**** @cfg {array}  
     *  :text  
     *  :action   
     */
    actions: [],
    /**** @cfg {object}    
     * 
     *   
     */
    defaults: {
        xtype: 'textbutton',
        anchor: '100%'
    },
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
        me.setActions(me.actions);
    },
    /**
     *    
     * param {Array}    (   )
     */
    setActions: function(actions) {
        var me = this;
        me.removeAll();
        me.add(actions);
        actions.length ? me.show() : me.hide();
    }
});

/**
 *   
 */
Ext.define('ExGods.store.AvailableQuests', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Quest',
    id: 'available_quests'
});
// proxy: {
//  type: 'ajax',
//  url: '/game.pl?cmd=quests.current',
//  limitParam: false,
//  pageParam: false,
//  startParam: false,
//  reader: {
//      type: 'json',
//      rootProperty: 'quests'
//  }
// }

/**
 *  
 */
Ext.define('ExGods.controller.Quest', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: false,
        prefix: 'QuestController:'
    },
    stores: [
        'AvailableQuests',
        'Quests'
    ],
    models: [
        'Quest',
        'User'
    ],
    views: [
        'CommonDetailsWindow',
        'quest.TabPanel',
        'quest.Column',
        'List',
        'quest.NewList',
        'ListItem',
        'quest.ListItem',
        'TextButton',
        'dialog.DialogActions'
    ],
    tooltips: [
        'quest'
    ],
    refs: [
        {
            /**
             * @private
             * @method getQuestWnd
             *     
             */
            ref: 'questWnd',
            selector: '#QUESTS'
        },
        {
            /**
             * @private
             * @method getQuestDescriptionPanel
             *    
             * @return {Ext.container.Container}
             */
            ref: 'questDescriptionPanel',
            selector: '#quest-description'
        },
        {
            ref: 'questButton',
            selector: '#mainmenu-quests-button'
        },
        {
            /**
             * @method getQuestList
             */
            ref: 'questList',
            selector: 'questnewlist'
        },
        {
            /**
             * @method getQuestTabs
             */
            ref: 'questTabs',
            selector: 'questtabpanel'
        },
        {
            /**
             * @method getDialog
             * @return {ExGods.view.Dialog}
             */
            ref: 'dialog',
            selector: '#quest-dialog'
        },
        {
            /**
             * NEW
             * @method getLocationView
             * @return {ExGods.view.Dialog}
             */
            ref: 'locationView',
            selector: 'locationmain'
        }
    ],
    /**
     * @property {Ext.XTemplate} questTpl
     *   
     */
    init: function() {
        var me = this;
        me.service = ExGods.Services.get('quests');
        me.control({
            '#QUESTS questtabpanel': {
                afterrender: {
                    fn: me.onQuestsShow,
                    delay: 200
                }
            },
            '#QUESTS': {
                show: {
                    fn: function(wnd) {
                        if (wnd && wnd.down)  {
                            me.onQuestsShow(wnd.down('questtabpanel'));
                        }
                        
                    },
                    buffer: 100
                }
            },
            //      +    show 
            'questlist dataview': {
                itemclick: {
                    fn: me.onQuestClick,
                    delay: 0
                }
            },
            //NEW
            'questcolumn dataview': {
                itemclick: me.showQuestsWnd
            },
            'questcolumn button[dock="bottom"]': {
                click: me.showQuestsWnd
            },
            'questlistitem': {
                questaction: me.onWorldQuestAction,
                questcancel: me.onWorldQuestCancel,
                questreroll: me.onWorldQuestReroll,
                togglequesttracing: me.toggleQuestTracing
            }
        });
        //        "trace_quest"
        me.addAjaxRequestKeyHandler('trace_quest', function(data) {
            var quest = me.getQuestsStore().getById(parseInt(data.trace_quest.proto_id));
            if (quest) {
                quest.set(data.trace_quest);
            }
        }, me);
        //        "quests"
        me.addAjaxRequestKeyHandler('quests', function(data) {
            Ext.each(data.quests, function(quest) {
                var q = me.getQuestsStore().findRecord('proto_id', quest.proto_id);
                if (q && q.get('expanded')) {
                    quest.expanded = q.get('expanded');
                }
            });
            this.getQuestsStore().loadRawData(data.quests);
        }, me);
        me.application.getChatConnection().on({
            command_quests: me.onQuestsCommand,
            scope: me
        });
        ExGods.Components.addComponentInitializer('quests', me.initQuestsComponent, me);
        ExGods.Components.addComponentInitializer('quest_giver_list', me.initQuestGiverListComponent, me);
        ExGods.Components.addComponentInitializer('quest_button', me.initQuestButtonComponent, me);
        me.getQuestsStore().on('datachanged', function() {
            ExGods.Resources.load(me);
        });
    },
    /**
     *    command_quests  
     */
    onQuestsCommand: Ext.Function.createBuffered(function(chatcn, data) {
        ExGods.Services.updateGroupOfServices('quests');
    }, 250),
    /*
     * @param {ExGods.view.TextButton[]} actions   
     * @param {Boolean} [closable=false]    ""
     */
    showQuest: function(quest, giverData, actions, closable) {
        var me = this,
            app = me.application,
            protos = me.application.getItemPrototypesStore(),
            missedProtos = [],
            container = me.getDialog();
        //    (, ..           )   
        if (container) {
            container.destroy();
        }
        container = Ext.widget('quest_dialog', {
            info: giverData,
            data: quest.data,
            actions: actions,
            id: 'quest-dialog',
            closable: closable
        });
        //   ,     
        container.quest = quest;
        // 
        me.application.getController('OverlayPanel').setLeftComponent(container, true, false);
        // 
        var rewards = quest.get('rewards');
        if (rewards && rewards.length) {
            Ext.Array.forEach(rewards, function(reward) {
                if (reward.type == 'item') {
                    var proto_id = parseInt(reward.params.id);
                    if (!protos.data.getByKey(proto_id) && !Ext.Array.contains(missedProtos, proto_id)) {
                        missedProtos.push(proto_id);
                    }
                }
            });
        }
        if (missedProtos.length) {
            ExGods.util.Helper.maskElement(container.body);
            protos.loadNew(missedProtos, function() {
                container.body.unmask();
            });
        }
        //    
        if (quest.get('timedropfrom')) {
            container.mon(quest, 'timedropchanged', function(time) {
                if (container.el) {
                    var dropdown = container.el.down('.dropdown');
                    if (dropdown)  {
                        if (time > 0) {
                            dropdown.update(Ext.util.Format.countdown(time));
                        } else {
                            container.destroy();
                        };
                    }
                    
                }
            }, me);
        }
        return container;
    },
    /**
     * @private
     *   
     * 
     * @param {Ext.view.View} view   
     * @param {ExGods.model.Quest} quest  
     * @param {HTMLElement} item 
     * @param {Number} index
     * @param {Ext.EventObject} e
     */
    onQuestClick: function(view, quest, item, index, e) {
        var me = this,
            giver = quest.get('giver'),
            giverData = {
                image: Ext.BLANK_IMAGE_URL
            };
        //           
        if (Ext.fly(e.target).hasCls('tracequest-btn')) {
            me.toggleQuestTracing(quest);
            return;
        }
        if (giver.bot_data) {
            var bot = Ext.create('ExGods.model.User', quest.get('giver'));
            giverData = {
                title: bot.get('display_title'),
                image: bot.getAvatar(),
                description: bot.get('bot_data').description,
                greetings_template: bot.get('bot_data').greetings_template || ''
            };
        } else {
            giverData = {
                title: giver.title,
                image: (giver.image_info || giver.image) ? (IMAGE_URL + (giver.image_info || giver.image)) : Ext.BLANK_IMAGE_URL,
                description: giver.description
            };
        }
        var actions = [];
        //  "  "
        if (quest.get('droppable')) {
            actions.push({
                xtype: 'textbutton',
                handler: function() {
                    me.request({
                        url: '/map.pl?cmd=del_quest',
                        method: 'GET',
                        params: {
                            qid: quest.get('proto_id')
                        },
                        success: function(json) {
                            var questView = Ext.getCmp('quest-dialog');
                            if (questView && questView.quest == quest) {
                                questView.destroy();
                            }
                        }
                    });
                },
                text: ExGods.getMsgByKey('quests_del_quest_btn')
            });
        }
        me.showQuest(quest, giverData, actions);
    },
    /**
     * @private
     *   .     -  
     */
    toggleQuestTracing: function(quest, item) {
        var me = this,
            list = item.ownerCt.el;
        ExGods.util.Helper.maskElement(list);
        me.request({
            url: '/game.pl?cmd=trace_quest',
            params: {
                qid: quest.isTraced() ? 0 : quest.get('proto_id')
            },
            success: function(json) {
                list.unmask();
                if (me.getQuestList()) {
                    me.getQuestList().rerender();
                }
            },
            scope: me
        });
    },
    onQuestsShow: function(cmp) {
        var me = this,
            tabs = {
                available: cmp.getComponent('available_quests')
            },
            count = this.getUser().availableQuestsStore.getCount(),
            currentTab;
        if (me.selected_quest) {
            if (me.selected_quest.data.status == 2 || me.selected_quest.data.status == 1) {
                tabs.active = cmp.getComponent('active_quests');
                currentTab = 'active';
            } else {
                currentTab = 'available';
            }
            if (count > 0) {
                cmp.setActiveTab(currentTab + '_quests');
            } else {
                cmp.setActiveTab('active_quests');
            }
            if (me.selected_quest.data) {
                tabs[currentTab].scrollTo(me.selected_quest);
            } else {
                tabs[currentTab].showDefault();
            }
            me.selected_quest = null;
        } else {
            if (count > 0) {
                currentTab = cmp.setActiveTab('available_quests');
            } else {
                currentTab = cmp.setActiveTab('active_quests');
            }
            var record = currentTab.store.getAt(0);
            if (record) {
                record.set('expanded', true);
                currentTab.scrollTo(record);
            }
        }
        setTimeout(function() {
            cmp.up().el.setStyle('opacity', 1);
        }, 100);
    },
    /*
     * NEW functions
     *   
     */
    showQuestsWnd: function(view, quest, item, index, e) {
        var me = this,
            cmp = Ext.getCmp('QUESTS');
        me.selected_quest = quest;
        if (cmp) {
            ExGods.app.block();
            ExGods.Resources.load(cmp, function() {
                ExGods.app.unblock();
                cmp.show();
            });
        } else {
            ExGods.Components.factory('QUESTS');
        }
    },
    /*
     * NEW
     *  questaction,      ""  ""
     */
    onWorldQuestAction: function(record) {
        var me = this,
            status = record.get('status').toString(),
            fn, message;
        switch (status) {
            case '0':
                fn = record.getGiveConfirmation;
                break;
            case '2':
                fn = record.getTakeConfirmation;
                break;
        }
        message = fn.call(record);
        if (message) {
            //     
            Ext.widget('confirmdialog', {
                message: message,
                handler: Ext.bind(me.doWorldQuestAction, me, [
                    record
                ])
            });
        } else {
            me.doWorldQuestAction(record);
        }
    },
    /*
     * NEW
     *  questaction,      ""  ""
     */
    doWorldQuestAction: function(record) {
        var me = this,
            qid = record.get('proto_id'),
            status = record.get('status').toString(),
            cmd, index;
        switch (status) {
            case '0':
                cmd = 'quests_get';
                index = me.user.availableQuestsStore.indexOf(record);
                break;
            case '2':
                cmd = 'quests_finish';
                index = me.getQuestsStore().indexOf(record);
                break;
        }
        me.service.command(cmd, {
            qid: qid
        }, function(json) {
            var oQuest = me.getQuestsStore().getById(parseInt(record.raw.proto_id));
            if (json.quest) {
                if (json.quest.status == 5) {
                    if (oQuest)  {
                        me.getQuestsStore().remove(oQuest);
                    }
                    
                } else {
                    if (oQuest) {
                        oQuest.set(json.quest);
                    } else {
                        me.getQuestsStore().loadRawData([
                            json.quest
                        ], true);
                        me.getUser().availableQuestsStore.remove(record);
                    }
                }
            }
            if (json.list) {
                ExGods.app.getStore('Adventures').loadRawData(json.list);
            }
            me.onAfterAction(index);
        });
    },
    /*
     *  questcancel,      "  "
     */
    onWorldQuestCancel: function(record) {
        var me = this,
            index = me.getQuestsStore().indexOf(record);
        me.service.command('quests_delete', {
            qid: record.get('proto_id')
        }, function() {
            me.onAfterAction(index);
        });
    },
    /*
     *  questreroll,      " "
     */
    onWorldQuestReroll: function(record) {
        var me = this,
            index = me.getQuestsStore().indexOf(record),
            tpl = new Ext.XTemplate(ExGods.ref('message_client|quest_reroll_confirm')).apply({
                cost: ExGods.util.Stuff.printStuff(record.get('reroll_stuff'))
            });
        Ext.widget('confirmdialog', {
            message: tpl,
            handler: function() {
                me.service.command('quests_reroll', {
                    qid: record.get('proto_id')
                }, function() {
                    me.onAfterAction(index);
                });
            }
        });
    },
    /**
     *    . ,     -      
     * index -      ,   
     */
    onAfterAction: function(index) {
        var me = this,
            activeQuests = me.getQuestsStore(),
            availQuests = me.user.availableQuestsStore,
            wnd = me.getQuestWnd(),
            cmp, activeItem;
        cmp = wnd.down('questtabpanel');
        activeItem = cmp.getLayout().getActiveItem();
        if (activeItem && activeItem.itemId == 'available_quests') {
            if (!availQuests.getCount()) {
                wnd.close();
            }
        } else if (activeItem && activeItem.itemId == 'active_quests' && !activeQuests.getCount()) {
            if (availQuests.getCount()) {
                cmp.getLayout().setActiveItem(1);
                //    "available_quests"
                index = 0;
            } else {
                wnd.close();
            }
        }
        if (cmp.isVisible() && typeof index == 'number') {
            setTimeout(function() {
                var store = cmp.getLayout().getActiveItem().store,
                    record = store.getAt(index);
                if (record) {
                    var listitem = cmp.getLayout().getActiveItem().getComponent('wrap').getComponent(record.get('proto_id'));
                    if (listitem) {
                        listitem.expand();
                    } else {
                        record.set('expanded', true);
                    }
                }
            }, 0);
        }
    },
    initQuestGiverListComponent: function(config, componentId) {
        var me = this,
            cmp = Ext.getCmp('LOB_QUEST_GIVER_LIST');
        if (cmp)  {
            cmp.close();
        }
        
        cmp = Ext.widget('questcolumn', {
            id: 'LOB_QUEST_GIVER_LIST',
            user: me.getUser(),
            width: 85,
            height: 365
        });
        return cmp;
    },
    initQuestButtonComponent: function(config) {
        var me = this,
            btn = Ext.getCmp('LOB_QUEST_BUTTON');
        if (btn)  {
            btn.destroy();
        }
        
        return Ext.widget('textbutton', {
            id: 'LOB_QUEST_BUTTON',
            cls: 'double_text_btn double_text x-btn-txt',
            height: 42,
            width: 92,
            minWidth: 10,
            handler: function() {
                me.showQuestsWnd();
            },
            text: config.btn_text,
            listeners: {
                afterrender: function() {
                    if (me.getQuestButton())  {
                        me.getQuestButton().drawLocationCount(true);
                    }
                    
                }
            }
        });
    },
    initQuestsComponent: function(config) {
        var me = this,
            activeQuestsStore = me.getQuestsStore(),
            availQuestsStore = me.user.availableQuestsStore,
            wnd, quest,
            _setSelectedQuestFromAction = function(clientAction) {
                if (clientAction.options.active_quests) {
                    quest = activeQuestsStore.getById(clientAction.options.active_quests.qid);
                    if (quest)  {
                        me.selected_quest = quest;
                    }
                    
                } else if (clientAction.options.available_quests) {
                    quest = availQuestsStore.getById(clientAction.options.available_quests.qid);
                    if (quest)  {
                        me.selected_quest = quest;
                    }
                    
                }
                if (wnd)  {
                    wnd.show();
                }
                
            };
        if (config.clientAction) {
            _setSelectedQuestFromAction(config.clientAction);
        }
        wnd = Ext.widget('window2', {
            id: 'QUESTS',
            closeAction: 'hide',
            onClientAction: _setSelectedQuestFromAction,
            autoShow: false,
            style: {
                opacity: 0
            },
            items: [
                {
                    xtype: 'questtabpanel',
                    items: [
                        {
                            xtype: 'questnewlist',
                            icon: ExGods.ref('images|quest_images').image.active_quests,
                            store: activeQuestsStore,
                            itemId: 'active_quests',
                            description: '',
                            tabtitle: '',
                            quantityLeft: 145,
                            emptyText: ''
                        },
                        {
                            xtype: 'questnewlist',
                            icon: ExGods.ref('images|quest_images').image.available_quests,
                            store: availQuestsStore,
                            itemId: 'available_quests',
                            description: '',
                            tabtitle: '',
                            quantityLeft: 133,
                            skipFilter: true,
                            emptyText: ''
                        }
                    ]
                }
            ],
            isVisible: function() {
                var me = this,
                    hidden;
                if (me.hidden || !me.rendered || me.isDestroyed || me.el.getStyle('opacity') == 0) {
                    hidden = true;
                }
                return !hidden;
            },
            listeners: {
                hide: function() {
                    this.el.setStyle({
                        opacity: 0
                    });
                }
            }
        });
        ExGods.app.block();
        ExGods.Resources.load(wnd, function() {
            ExGods.app.unblock();
            wnd.show();
        });
        return wnd;
    },
    getResources: function() {
        var me = this,
            images = [],
            stuff = [];
        me.getQuestsStore().each(function(item) {
            if (item.data.params && item.data.params.image) {
                images.push(item.data.params.image);
            }
            if (item.rewards && item.rewards.length) {
                stuff = stuff.concat(item.rewards);
            }
        });
        return {
            images: images,
            stuff: stuff
        };
    },
    /**
     *    
     */
    getTooltipData: function(type, value) {
        var me = this,
            data;
        if (type == 'quest') {
            data = me.getQuestsStore().getById(parseInt(value));
            if (!data) {
                data = me.user.availableQuestsStore.getById(parseInt(value));
            }
            return data;
        }
    }
});

/**
 *     (v.2)
 *
 *   ,       -:
 *
 *      <div class="qh-object" data-qh_otype="bot" data-qh_oid="123"></div>
 *
 *
 * @author Oleg Mikhailov
 *
 */
Ext.define('ExGods.controller.QuestHelper', {
    extend: ExGods.controller.Base,
    logConfig: {
        enabled: false,
        prefix: 'QuestHelper:'
    },
    stores: [
        'Quests'
    ],
    models: [
        'User'
    ],
    refs: [
        {
            /**
         * @method getLayerOver2
         */
            ref: 'layerOver2',
            selector: '#layer-over2'
        }
    ],
    /**
     * @property {Boolean} traced    (readonly)
     */
    traced: false,
    /**
     * @property {Boolean} disabled    (readonly)
     */
    disabled: false,
    shopItems: [],
    shopItemKits: [],
    init: function() {
        var me = this;
        me.listen({
            component: {
                '#LOB_BOT_LIST > dataview': {
                    refresh: {
                        fn: me.onBotsListRefresh,
                        delay: 1
                    }
                }
            }
        });
        me.lairCtrl = me.app.getController('Lair');
        me.fucinaCtrl = me.app.getController('Fucina');
        me.app.getController('Viewport').on('layoutchanged', function(viewport, layout) {
            if (layout == 'battle') {
                me.setDisabled(true);
            } else {
                me.setDisabled(false);
            }
        });
    },
    onLaunch: function() {
        this.startTracing();
    },
    /**
     * @private
     *  
     */
    startTracing: function() {
        var me = this;
        /**/
        me.log(' ..');
        if (!me.traceInterval) {
            me.traceInterval = window.setInterval(Ext.bind(me.showAllPointers, me), 1000);
        }
        me.showAllPointers();
        me.startAnim();
        me.traced = true;
        return me.traceInterval;
    },
    /**
     * @private
     *  
     */
    stopTracing: function() {
        var me = this;
        if (me.traceInterval) {
            window.clearInterval(me.traceInterval);
            me.traceInterval = null;
        }
        me.removeAllPointers();
        me.stopAnim();
        me.traced = false;
        /***/
        me.log(' .');
    },
    /**
     * @private
     *   -
     */
    setDisabled: function(disabled) {
        var me = this;
        me.disabled = disabled;
        if (me.traced) {
            if (me.disabled) {
                me.removeAllPointers();
            } else {
                me.showAllPointers();
            }
        }
    },
    isDisabled: function() {
        return this.disabled;
    },
    /**
     * ,    
     */
    onChangeTraceQuest: function() {
        var me = this;
        /**/
        me.log('  ');
        if (me.getTracedQuest()) {
            if (!me.traced) {
                me.startTracing();
            }
        } else {
            if (me.traced) {
                me.stopTracing();
            }
        }
    },
    /**
     *         
     */
    onQuestsStoreUpdate: function() {
        var me = this;
        /**/
        me.log('   .   ');
        if (me.getTracedQuest()) {
            if (!me.traced) {
                me.startTracing();
            }
        } else {
            if (me.traced) {
                me.stopTracing();
            }
        }
    },
    /**
     * @private
     */
    onBotsListRefresh: function() {
        var me = this;
        if (me.traced) {
            me.showAllPointers();
        }
    },
    /** 
     * @private
     *   
     */
    removeAllPointers: function() {
        var me = this;
        Ext.select('.qh-on').each(function(el) {
            me.hidePointer(el);
        });
    },
    /**
     * @private
     *   
     */
    showAllPointers: function() {
        var me = this;
        if (me.isDisabled()) {
            /***/
            me.log('  ..');
            return;
        }
        me.shopItems = [];
        me.shopItemKits = [];
        var tracedObjects = {
                quest: [],
                location: [],
                iobject: [],
                bot: [],
                item: [],
                menu: [],
                maskobject: [],
                shop_item_kit: [],
                shop_item: [],
                skill_interface: [],
                lair: [],
                arena_button_battle: [],
                bot_button_attack: [],
                bot_button_banish: [],
                room_mask: [],
                room_mask_button_uluchshit: [],
                skill_interface_boost: [],
                skill_interface_boost_complete: [],
                inventory_item: [],
                inventory_item_button_puton: [],
                lair_button_start: [],
                tutorial_quests: [
                    '1'
                ],
                bot_any: [],
                bot_button_attack_any: [],
                bot_button_banish_any: [],
                active_slot: [],
                protect_slot_button: [],
                lair_mode: [],
                map_action: [],
                world: [],
                payment_buy_button: [],
                payment_exchange: [],
                exchange_gold_button: [],
                exchange_crystal_button: [],
                forge_entry: [],
                forge_type: [],
                forge_type_ready_button: [],
                forge_item: [],
                forge_item_action_btn: [],
                tools_menu_fullscreen_button: [],
                robbery_button_battle: [],
                room_pet_button_puton: [],
                room_pet: []
            };
        me.getQuestsStore().each(function(quest) {
            var answer = me.getTracedObjects(quest, tracedObjects);
        });
        /***/
        me.log(' ', tracedObjects);
        Ext.select('.qh-object').each(function(el) {
            var objectType = el.dom.getAttribute('data-qh_otype');
            var objectId = el.dom.getAttribute('data-qh_oid');
            var options = el.dom.getAttribute('data-qh_opts');
            if (options) {
                options = Ext.decode(Ext.String.htmlDecode(options));
            } else {
                options = {};
            }
            if (Ext.isArray(tracedObjects[objectType]) && Ext.Array.indexOf(tracedObjects[objectType], objectId) != -1) {
                me.showPointer(el, options);
            } else {
                me.hidePointer(el);
            }
            if ((objectType == 'bot_button_attack' && tracedObjects.bot_button_attack_any.length) || (objectType == 'bot_button_banish' && tracedObjects.bot_button_banish_any.length)) {
                me.showPointer(el, options);
            }
            if ((objectType == 'lair_mode' && el.hasCls('selected'))) {
                me.hidePointer(el);
            }
            //  
            if (el.dom.id.substr(0, 9) == 'shop-tab-') {
                var shopView = ExGods.app.getShopController().getShopTabs(),
                    tabPanel = shopView.down('skintabpanel'),
                    activeTab = tabPanel.getActiveTab().id,
                    index = el.dom.id.substr(9),
                    shop = tabPanel.items.items[index],
                    store = shop.shop.itemsStore,
                    hasItems = false;
                Ext.Array.each(me.shopItems, function(id) {
                    if (store.findBy(function(item) {
                        var proto = item.get('item_proto');
                        return proto.get ? proto.get('entry') == id : false;
                    }) != -1) {
                        hasItems = true;
                    }
                });
                Ext.Array.each(me.shopItemKits, function(id) {
                    if (store.findBy(function(item) {
                        var proto = item.get('item_proto');
                        return proto.entry ? proto.entry == id : false;
                    }) != -1) {
                        hasItems = true;
                    }
                });
                if (hasItems && shop.id != activeTab) {
                    me.showPointer(el.up('.x-tab-bar'), {
                        style: 'left:' + (53 * index - 45) + 'px'
                    });
                } else if (hasItems) {
                    me.hidePointer(el.up('.x-tab-bar'));
                }
            }
        });
        Ext.select('.quest.tutorial').each(function(el) {
            if (!el.hasCls('active')) {
                me.showPointer(el);
            }
        });
    },
    /**
     * @private
     *   ,         
     * @return {Array}
     */
    getTracedObjects: function(quest, objects) {
        var me = this,
            //          quest = me.getTracedQuest(),
            aims = quest ? quest.get('aims') : [],
            marks = [],
            path, i,
            layerOver2 = me.getLayerOver2();
        //   
        if (quest) {
            marks = quest.get('marks');
        }
        //   
        if (aims.length) {
            for (i = 0; i < aims.length; i++) {
                if (aims[i].marks && aims[i].marks.length) {
                    marks = Ext.Array.merge(marks, aims[i].marks);
                    break;
                }
            }
        }
        //      
        me.room_mask = [];
        //          .
        //   ,          (  "location"),
        //        ,  ,   .
        for (i = 0; i < marks.length; i++) {
            path = marks[i].path && marks[i].path.length ? marks[i].path[0] : [];
            if (path.length == 0 || path.length == 1) {
                //    = 0 -    
                //     = 1 -     
                if (marks[i].object) {
                    if (marks[i].object.object_type == 1) {
                        objects.bot.push(marks[i].object.object_id);
                    } else if (marks[i].object.object_type == 2) {
                        objects.item.push(marks[i].object.object_id);
                    }
                }
                if (marks[i].menu) {
                    if (!layerOver2 || !layerOver2.isVisible()) {
                        objects.menu.push(marks[i].menu);
                    }
                }
                if (marks[i].iobject) {
                    objects.iobject.push(marks[i].iobject);
                }
                if (marks[i].room_mask) {
                    if (ExGods.app.getController('Masks').currentFitMask && ExGods.app.getController('Masks').currentFitMask.get('id') != marks[i].room_mask.toString()) {
                        objects.maskobject.push(marks[i].room_mask);
                        me.room_mask.push(marks[i].room_mask);
                    }
                }
                if (marks[i].room_mask_button_uluchshit) {
                    if (ExGods.app.getController('Masks').currentFitMask && ExGods.app.getController('Masks').currentFitMask.get('id') != marks[i].room_mask_button_uluchshit.toString()) {
                        objects.maskobject.push(marks[i].room_mask_button_uluchshit);
                    }
                    if (ExGods.app.getController('Masks').currentFitMask && ExGods.app.getController('Masks').currentFitMask.get('id') == marks[i].room_mask_button_uluchshit.toString()) {
                        objects.room_mask_button_uluchshit.push(marks[i].room_mask_button_uluchshit);
                    }
                }
                if (marks[i].room_pet) {
                    var currentPet = ExGods.app.getController('Pets').currentPet;
                    if (!currentPet || (currentPet && currentPet.get('item_proto').entry != marks[i].room_pet.toString())) {
                        objects.room_pet.push(marks[i].room_pet);
                    } else {
                        objects.room_pet_button_puton.push('1');
                    }
                }
                if (marks[i].shop_item_kit) {
                    me.shopItemKits.push(marks[i].shop_item_kit);
                    objects.shop_item_kit.push(marks[i].shop_item_kit);
                }
                if (marks[i].shop_item) {
                    me.shopItems.push(marks[i].shop_item);
                    objects.shop_item.push(marks[i].shop_item);
                }
                if (marks[i].skill_interface) {
                    var skillTabsData = ExGods.app.getSkillsStore().data.items,
                        show_marker = false;
                    for (var j = 0; j < skillTabsData.length; j++) {
                        skillTabsData[j].data.skills.each(function(skill) {
                            if (skill.data.name == marks[i].skill_interface) {
                                if (skill.data.can_master || skill.data.progress.is_ready)  {
                                    show_marker = true;
                                }
                                
                            }
                        });
                    }
                    if (show_marker)  {
                        objects.skill_interface.push(marks[i].skill_interface);
                    }
                    
                }
                if (marks[i].lair_id && marks[i].lair_mode && marks[i].lair_stage) {
                    if (me.lairCtrl.selectedStage != marks[i].lair_stage || me.lairCtrl.activeMode != marks[i].lair_mode) {
                        //     
                        objects.lair.push(marks[i].lair_id + '_' + marks[i].lair_mode + '_' + marks[i].lair_stage);
                    } else {
                        objects.lair_button_start.push('1');
                    }
                    objects.lair_mode.push(marks[i].lair_id + '_' + marks[i].lair_mode.toString());
                }
                if (marks[i].arena_button_battle) {
                    objects.arena_button_battle.push(marks[i].arena_button_battle.toString());
                }
                if (marks[i].bot_button_attack) {
                    objects.bot_button_attack.push(marks[i].bot_button_attack.toString());
                }
                if (marks[i].room_mask) {
                    objects.room_mask.push(marks[i].room_mask.toString());
                }
                if (marks[i].bot_button_banish) {
                    objects.bot_button_banish.push(marks[i].bot_button_banish.toString());
                }
                if (marks[i].skill_interface_boost) {
                    objects.skill_interface_boost.push(marks[i].skill_interface_boost.toString());
                }
                if (marks[i].skill_interface_boost_complete) {
                    objects.skill_interface_boost_complete.push(marks[i].skill_interface_boost_complete.toString());
                }
                if (marks[i].inventory_item) {
                    var open_window = false;
                    Ext.WindowMgr.each(function(win) {
                        if (win.initialCls == "item-window" && win.item && win.item.data && win.item.data.proto_id == marks[i].inventory_item)  {
                            open_window = true;
                        }
                        
                    });
                    if (!open_window)  {
                        objects.inventory_item.push(marks[i].inventory_item.toString());
                    }
                    
                }
                if (marks[i].inventory_item_button_puton) {
                    objects.inventory_item_button_puton.push(marks[i].inventory_item_button_puton.toString());
                }
                if (marks[i].bot_any) {
                    objects.bot_any.push(marks[i].bot_any.toString());
                }
                if (marks[i].bot_button_attack_any) {
                    objects.bot_button_attack_any.push(marks[i].bot_button_attack_any.toString());
                }
                if (marks[i].bot_button_banish_any) {
                    objects.bot_button_banish_any.push(marks[i].bot_button_banish_any.toString());
                }
                if (marks[i].active_slot) {
                    objects.active_slot.push(marks[i].active_slot.toString());
                }
                if (marks[i].protect_slot_button) {
                    objects.protect_slot_button.push(marks[i].protect_slot_button.toString());
                }
                if (marks[i].map_action) {
                    objects.map_action.push(marks[i].map_action.toString());
                }
                if (marks[i].world) {
                    objects.world.push(marks[i].world.toString());
                }
                if (marks[i].payment_buy_button) {
                    objects.payment_buy_button.push(marks[i].payment_buy_button.toString());
                }
                if (marks[i].payment_exchange) {
                    if (Ext.ComponentQuery.query('banktable')[0] && Ext.ComponentQuery.query('banktable')[0].selected && Ext.ComponentQuery.query('banktable')[0].selected.record.data.entry == marks[i].payment_exchange.toString()) {
                        objects.exchange_crystal_button.push('1');
                    } else if (Ext.ComponentQuery.query('banktable')[1] && Ext.ComponentQuery.query('banktable')[1].selected && Ext.ComponentQuery.query('banktable')[1].selected.record.data.entry == marks[i].payment_exchange.toString()) {
                        objects.exchange_gold_button.push('1');
                    } else  {
                        objects.payment_exchange.push(marks[i].payment_exchange.toString());
                    }
                    
                }
                if (Ext.getCmp('FUCINA')) {
                    // if (marks[i].forge_entry && me.fucinaCtrl.service && me.fucinaCtrl.service.data.fucina.current != marks[i].forge_entry) {
                    //  objects.forge_entry.push(marks[i].forge_entry);
                    // }
                    if (marks[i].forge_type && me.fucinaCtrl.service && me.fucinaCtrl.service.data.fucina.fucina_type != marks[i].forge_type) {
                        objects.forge_type.push(marks[i].forge_type);
                    }
                    if (marks[i].forge_type_ready_button && me.fucinaCtrl.service && me.fucinaCtrl.service.data.fucina.fucina_type == marks[i].forge_type_ready_button) {
                        objects.forge_type_ready_button.push(marks[i].forge_type_ready_button);
                    }
                    if (marks[i].forge_item) {
                        objects.forge_item.push(marks[i].forge_item);
                    }
                    if (marks[i].forge_item) {
                        objects.forge_item_action_btn.push(marks[i].forge_item);
                    }
                }
                if (marks[i].full_screen_button) {
                    objects.tools_menu_fullscreen_button.push("1");
                }
                if (marks[i].robbery_button_battle) {
                    objects.robbery_button_battle.push("1");
                }
            } else {
                objects.location = Ext.Array.merge(objects.location, path);
            }
        }
        if (objects.item.length) {
            //      -      ""
            objects.menu.push('inventory');
        }
        return objects;
    },
    //  ///
    //   * @priva//
    //   *      null,   //
    //   * @return {ExGods.model.Ques//
    //   //
    //  getTracedQuest: function()//
    //      var me = thi//
    //      return me.getQuestsStore().getById( me.getUser().get('trace_quest_proto') //
    //  },
    /**
     * @private
     *    
     * @param {Ext.dom.Element} el
     * @param {Object} options  
     */
    showPointer: function(el, options) {
        var me = this;
        options = Ext.applyIf(options || {}, {
            cls: '',
            style: ''
        });
        if (!el.hasCls('qh-on')) {
            el.insertHtml('beforeEnd', '<div class="qh-pointer ' + options.cls + '" style="' + options.style + '"></div>');
            el.addCls('qh-on');
        }
    },
    /**
     * @private
     *    
     * @param {Ext.dom.Element} el
     */
    hidePointer: function(el) {
        var me = this;
        if (el.hasCls('qh-on')) {
            el.removeCls('qh-on');
            el.select('.qh-pointer').remove();
        }
    },
    /**
     * @private
     *    
     */
    startAnim: function() {
        var me = this;
        if (me._anim_timer_id)  {
            return;
        }
        
        var duration = 600,
            distance = 5,
            speed = 1,
            direction = -1,
            counter = 0;
        me._anim_timer_id = window.setInterval(function() {
            if (++counter % distance == 0) {
                direction *= -1;
            }
            Ext.select('.qh-pointer').each(function(el) {
                if (el.dom.offsetParent)  {
                    el.setStyle('left', (el.getLocalX() + speed * direction) + 'px');
                }
                
            });
        }, duration / distance);
    },
    /**
     * @private
     *  
     */
    stopAnim: function() {
        var me = this;
        if (me._anim_timer_id) {
            window.clearInterval(me._anim_timer_id);
            delete me._anim_timer_id;
        }
    },
    /**
     * @private
     *  true,     -  
     */
    isBattleLayout: function() {
        return Ext.getCmp('battle-container') ? true : false;
    }
});

/**
 *    -
 */
Ext.define('ExGods.view.item.TargetWindow', {
    extend: ExGods.view.TargetWindow,
    alias: 'widget.itemtargetwindow',
    /**
     * @cfg {Array} items   ExGods.model.Item,     
     */
    items: null,
    cls: 'target-window item-target-window',
    padding: '10 10 15 10',
    buttonCls: ' ',
    //   -  .
    width: 350,
    initComponent: function() {
        var me = this;
        Ext.apply(this, {
            store: me.initStore(),
            itemTpl: me.getItemTpl(),
            searchField: 'title'
        });
        me.callParent();
    },
    /**
     * @private
     *   -
     */
    initStore: function() {
        var me = this,
            store, missedProtos;
        store = Ext.create('Ext.data.Store', {
            fields: [
                'title',
                'level',
                'price',
                'dur',
                'dur_max',
                'dur_is_critical',
                'image',
                'upgrades',
                'item'
            ]
        });
        Ext.Array.each(me.items, function(item) {
            var proto = item.getProto();
            store.add({
                title: proto.get('title'),
                level: proto.getLevel(),
                dur: item.getDur(),
                dur_max: item.getMaxDur(),
                dur_is_critical: item.hasCriticalDurability(),
                price: proto.get('data').price,
                item: item
            });
        });
        return store;
    },
    getItemTpl: function() {
        return [
            '<div class="paper paper-tl"></div>',
            '<div class="paper paper-tm"></div>',
            '<div class="paper paper-tr"></div>',
            '<div class="paper paper-mr"></div>',
            '<div class="paper paper-br"></div>',
            '<div class="paper paper-bm"></div>',
            '<div class="paper paper-bl"></div>',
            '<div class="paper paper-ml"></div>',
            '<div class="paper paper-bg"></div>',
            '<div class="target-item">',
            '{[this.printImage(values)]}',
            '<div class="title">{title}</div>',
            '<div>' + ExGods.getMsgByKey('view_arena_enemylist_level') + ' {level}</div>',
            '<div>' + ExGods.getMsgByKey('price_text') + ' {[this.getPrice(values)]}</div>',
            '<div <tpl if="dur_is_critical">class="critical-durability"</tpl>>' + ExGods.getMsgByKey('durability') + ' {dur}/{dur_max}</div>',
            '<div class="x-clear"></div>',
            '</div>',
            {
                getPrice: function(data) {
                    return ExGods.util.Stuff.printStuff({
                        type: "currency",
                        params: {
                            id: 'gold',
                            quantity: data.price
                        }
                    });
                },
                printImage: function(values) {
                    return ExGods.stuff.StuffManager.image({
                        type: 'repair_item',
                        params: {
                            itemModel: values.item
                        }
                    });
                }
            }
        ];
    },
    /**
     * @private
     * Override
     */
    onTargetSelect: function(target) {
        this.callParent([
            target.get('item')
        ]);
    }
});

/**
 *  "" 
 */
Ext.define('ExGods.controller.QuickSlot', {
    extend: ExGods.controller.Base,
    models: [
        'Slot@ExGodsCore.model'
    ],
    views: [
        'user.TargetWindow'
    ],
    refs: [
        {
            /**
         * @method getQuickSlots
         *    
         * @return {ExGods.view.QuickSlots}
         */
            ref: 'quickSlots',
            selector: '#quick-slots'
        }
    ],
    /**
     * @property {ExGods.model.User} user
     * @inheritdoc ExGods.app#user
     */
    init: function(app) {
        var me = this;
        me.user.slots().on('datachanged', me.setSlots, me);
        me.setSlots();
        me.control({
            '#quick-slots': {
                itemclick: {
                    fn: me.onQuickItemClick,
                    buffer: 200
                }
            }
        });
    },
    onLaunch: function(app) {
        var me = this,
            user = me.user;
        //     
        var bufferedRefresh = Ext.Function.createBuffered(me.refreshSlots, 1, me);
        me.quickSlotsStore.each(function(slot) {
            slot.items().on('datachanged', bufferedRefresh, me);
        });
    },
    refreshSlots: function() {
        this.getQuickSlots().refresh();
    },
    setSlots: function() {
        var me = this,
            records = me.user.slots().queryBy(function(slot) {
                return slot.get('type') == 14;
            });
        if (!me.quickSlotsStore) {
            me.quickSlotsStore = Ext.create('Ext.data.Store', {
                id: 'quick-slots',
                model: 'ExGodsCore.model.Slot'
            });
        }
        me.quickSlotsStore.loadData(records.getRange());
        if (me.getQuickSlots()) {
            me.getQuickSlots().refresh();
        }
    },
    /**
     *     
     */
    onQuickItemClick: function(view, slot, itemEl) {
        var me = this;
        if (view.isDisabled())  {
            return;
        }
        
        //   -      
        if (slot.items().getCount())  {
            return;
        }
        
        me.app.getItemController().showSlotWindow(slot, itemEl);
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.TrophyTable', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.usertrophytable',
    id: 'user-trophy-table',
    autoShow: true,
    bodyPadding: 0,
    /**
     * @cfg {Ext.data.Store} store (required)
     * 
     */
    /**
     * @cfg {ExGods.model.User} [user]
     * 
     */
    y: 142,
    initComponent: function() {
        var me = this,
            grid;
        grid = Ext.widget({
            xtype: 'dataview',
            itemSelector: 'tbody tr',
            store: me.store,
            tpl: [
                '<div class="paper-title" style="margin:2px 1px 0">',
                '<h4>' + ExGods.getMsgByKey('stuff_tooltip_trophy') + '</h4>',
                '</div>',
                '<table>',
                '<thead>',
                '<tr>',
                '<th>' + ExGods.getMsgByKey('stuff_tooltip_league') + '</th>',
                '<th class="trophy">' + ExGods.getMsgByKey('stuff_tooltip_trophy') + '</th>',
                '</tr>',
                '</thead>',
                '<tbody>',
                '<tpl for=".">',
                '<tr {[this.getCls(xindex)]}>',
                '<td>{description.label}</td>',
                '<td class="trophy">{trophy:number("0,0")}</td>',
                '</tr>',
                '</tpl>',
                '</tbody>',
                '</table>',
                {
                    getCls: function(i) {
                        return i % 2 ? 'class="even"' : '';
                    }
                }
            ],
            width: 200
        });
        me.items = [
            grid
        ];
        me.callParent();
        if (me.user) {
            grid.on('viewready', me.onViewReady, me);
        }
    },
    onViewReady: function(grid) {
        var me = this,
            selModel = grid.getSelectionModel();
        selModel.select(me.user.get('hoard').trophy_level - 1);
        selModel.setLocked(true);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.ExperienceBar', {
    extend: Ext.ProgressBar,
    alias: 'widget.experiencebar',
    itemId: 'experience-bar',
    border: 0,
    cls: 'experience-bar',
    height: 14,
    text: '???',
    /**
     * @cfg {ExGods.model.User} user (required)
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    width: 151,
    onRender: function() {
        var me = this,
            user = me.user;
        me.callParent(arguments);
        if (user) {
            me.tooltip = Ext.widget('tooltip', {
                target: me.el,
                maxWidth: parseInt(ExGods.ref('constants|tooltip_max_width').value),
                cls: 'paperdeco-tooltip',
                plugins: [
                    'paperdeco'
                ],
                tpl: new Ext.Template('<div class="paper-title ellipsis">' + ExGods.getMsgByKey('stuff_tooltip_experience') + '</div>' + '<div class="tooltip-paper-body">' + ExGods.ref('message_client|expa_tooltip') + '</div>'),
                listeners: {
                    beforeshow: function(tooltip) {
                        var expa = me.user.get('hoard').expa,
                            relative = me.getRelativeExpa(expa);
                        tooltip.update({
                            expa: expa,
                            to_level: relative.total - relative.current
                        });
                    }
                }
            });
            me.setData(user.get('hoard').expa);
            me.mon(user, {
                expachanged: me.setData,
                levelchanged: me.setData,
                scope: me
            });
            me.mon(user.get('feature'), 'datachanged', me.animateProgress, me);
            me.el.on('click', function() {
                /**
                 * @event click
                 *     
                 * @param {ExGods.view.user.ExperienceBar} this
                 */
                this.fireEvent('click', this);
            }, me);
        }
    },
    onShow: function() {
        this.setExpBuffLength();
        this.callParent(arguments);
    },
    /**
     *   
     * 
     * @param {Number} expa 
     */
    setData: function(expa) {
        var me = this,
            relative = me.getRelativeExpa(expa),
            percent = relative.current >= 0 ? relative.current / relative.total : 0;
        me.updateProgress(percent, Math.floor(percent * 100) + '%');
        me.setExpBuffLength();
        me.tooltip.update(relative);
    },
    /**
     *          
     * 
     * @param {Number} expa   
     * @return {Object}   
     * 
     *  {
     *      current: <_>,
     *      total: <_>
     *  }
     */
    getRelativeExpa: function(expa) {
        var me = this,
            levels = ExGods.references.get('user_level'),
            level = me.user.getLevel(),
            min = level ? levels.getByKey(level).expa : 0,
            max = levels.getByKey(level + 1).expa;
        return {
            current: expa - min,
            total: max - min
        };
    },
    /**
     *     
     * 
     * @param {ExGods.model.User} user  
     */
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            me.mun(me.user, {
                expachanged: me.setData,
                levelchanged: me.setData,
                scope: me
            });
            me.user = user;
            me.setData(user.get('hoard').expa);
            me.mon(user, {
                expachanged: me.setData,
                levelchanged: me.setData,
                scope: me
            });
        }
    },
    setExpBuffLength: function() {
        var me = this;
        if (me.processEl) {
            setTimeout(function() {
                me.processEl.style.width = Math.max((me.el.down('.x-progress-bar').getWidth() - 4), 0) + 'px';
            }, 0);
        }
    },
    animateProgress: function(store) {
        var me = this,
            user = me.user,
            feats = store.getExpFeatures();
        if (feats.length) {
            var feat = feats[0],
                el = me.el.down('.x-progress-bar'),
                left = 0,
                calcTime = function() {
                    return Math.floor(Math.max((ExGods.util.Date.normalizeServerDateTime(new Date(feat.get('ended').split('-').join('/'))).getTime() - new Date().getTime()) / 1000, 0));
                },
                timeStr = Ext.util.Format.countdown(calcTime(), {
                    format: "short"
                });
            if (!me.processEl) {
                me.processEl = document.createElement('div');
                me.processEl.className = 'x-progress-bar-process';
                me.setExpBuffLength();
                me.expFeatInterval = setInterval(function() {
                    left = left >= 19 ? 0 : left + 1;
                    me.processEl.style.backgroundPosition = left + 'px 0';
                }, 30);
                el.dom.insertBefore(me.processEl, el.dom.firstChild);
            }
            if (!me.timerEl) {
                me.timerEl = document.createElement('span');
                me.timerEl.className = 'x-progress-exgods-timer';
                me.el.dom.appendChild(me.timerEl);
            }
            me.timerEl.innerText = timeStr;
            var _onTick = function() {
                    var time = calcTime();
                    if (time > 0) {
                        me.timerEl.innerHTML = Ext.util.Format.countdown(time, {
                            format: "short"
                        });
                    } else {
                        ExGods.util.Ticker.removeListener(me.timer);
                        store.remove(feat);
                    }
                };
            setTimeout(function() {
                me.timer = ExGods.util.Ticker.addListener(_onTick, me);
                _onTick();
            }, 0);
        } else {
            if (me.expFeatInterval)  {
                clearInterval(me.expFeatInterval);
            }
            
            if (me.processEl && me.processEl.parentNode)  {
                me.processEl.parentNode.removeChild(me.processEl);
            }
            
            if (me.timerEl && me.timerEl.parentNode)  {
                me.timerEl.parentNode.removeChild(me.timerEl);
            }
            
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.HealthBar', {
    extend: Ext.ProgressBar,
    alias: 'widget.healthbar',
    border: 0,
    cls: 'health-bar',
    height: 14,
    width: 68,
    /**
     * @cfg {ExGods.model.User} user
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.tooltip = Ext.widget('tooltip', {
            target: me.el,
            tpl: new Ext.Template(ExGods.getMsgByKey('view_battle_userlist_hptt') + ' {current}/{total}'),
            listeners: {
                beforeshow: function(tooltip) {
                    var hp;
                    if (me.user) {
                        hp = me.user.get('timed').hp;
                        tooltip.update({
                            current: Math.floor(hp[0]),
                            total: hp[1]
                        });
                    }
                }
            }
        });
        if (me.user) {
            me.setData(me.user.get('timed').hp);
            me.mon(me.user, {
                hpchanged: me.setData,
                scope: me
            });
        }
    },
    /**
     *   
     * @param {Number[]} hp    
     */
    setData: function(hp) {
        var me = this;
        me.updateProgress(hp[0] / hp[1], ExGods.printNumber(Math.floor(hp[0]), 1000, '0', '0.0') + ' / ' + ExGods.printNumber(hp[1], 1000, '0', '0.0'));
        me.tooltip.update({
            current: Math.floor(hp[0]),
            total: hp[1]
        });
    },
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            if (me.user) {
                me.mun(me.user, {
                    hpchanged: me.setData,
                    scope: me
                });
            }
            if (me.rendered) {
                me.setData(user.get('timed').hp);
            }
            me.mon(user, {
                hpchanged: me.setData,
                scope: me
            });
            me.user = user;
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.ManaBar', {
    alias: 'widget.manabar',
    extend: Ext.ProgressBar,
    border: 0,
    cls: 'mana-bar',
    height: 14,
    /**
     * @cfg {ExGods.model.User} user
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    /**
      * @cfg {Boolean} empty  "  (???)  "
      */
    /**
     * @cfg {String} 
     */
    emptyText: '???',
    width: 152,
    initComponent: function() {
        var me = this;
        if (me.empty) {
            me.text = me.emptyText;
        }
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        if (!me.empty) {
            me.tooltip = Ext.widget('tooltip', {
                target: me.el,
                tpl: new Ext.Template(ExGods.getMsgByKey('view_battle_userlist_mptt') + ' {current}/{total}'),
                listeners: {
                    beforeshow: function(tooltip) {
                        var mp;
                        if (me.user) {
                            mp = me.user.get('timed').mp;
                            tooltip.update({
                                current: Math.floor(mp[0]),
                                total: mp[1]
                            });
                        }
                    }
                }
            });
            if (me.user) {
                me.setData(me.user.get('timed').mp);
                me.mon(me.user, {
                    mpchanged: me.setData,
                    scope: me
                });
            }
        }
    },
    /**
     *   
     * @param {Number[]} mp    
     */
    setData: function(mp) {
        var me = this;
        if (me.empty) {
            return;
        }
        me.updateProgress(mp[0] / mp[1], ExGods.printNumber(Math.floor(mp[0]), 10000, '0', '0.0') + ' / ' + ExGods.printNumber(mp[1], 10000, '0', '0.0'));
        me.tooltip.update({
            current: Math.floor(mp[0]),
            total: mp[1]
        });
    },
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            if (me.user) {
                me.mun(me.user, {
                    mpchanged: me.setData,
                    scope: me
                });
            }
            if (me.rendered) {
                me.setData(user.get('timed').mp);
            }
            me.mon(user, {
                mpchanged: me.setData,
                scope: me
            });
            me.user = user;
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.ShieldBar', {
    alias: 'widget.shieldbar',
    extend: Ext.ProgressBar,
    border: 0,
    cls: 'shield-bar',
    height: 14,
    /**
     * @cfg {ExGods.model.User} user
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    width: 68,
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.tooltip = Ext.widget('tooltip', {
            target: me.el,
            tpl: new Ext.Template(ExGods.getMsgByKey('view_battle_userlist_sptt') + ' {current}/{total}'),
            listeners: {
                beforeshow: function(tooltip) {
                    var shield;
                    if (me.user) {
                        shield = me.user.get('timed').shield;
                        tooltip.update({
                            current: Math.floor(shield[0]),
                            total: shield[1]
                        });
                    }
                }
            }
        });
        if (me.user) {
            me.setData(me.user.get('timed').shield);
            me.mon(me.user, {
                shieldchanged: me.setData,
                scope: me
            });
        }
    },
    /**
     *   
     * @param {Number[]} shield    
     */
    setData: function(shield) {
        var me = this;
        me.updateProgress(shield[0] / shield[1], ExGods.printNumber(Math.floor(shield[0]), 1000, '0', '0.0') + ' / ' + ExGods.printNumber(shield[1], 1000, '0', '0.0'));
        me.tooltip.update({
            current: Math.floor(shield[0]),
            total: shield[1]
        });
    },
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            if (me.user) {
                me.mun(me.user, {
                    shieldchanged: me.setData,
                    scope: me
                });
            }
            if (me.rendered) {
                me.setData(user.get('timed').shield);
            }
            me.mon(user, {
                shieldchanged: me.setData,
                scope: me
            });
            me.user = user;
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.TrophyBar', {
    extend: Ext.ProgressBar,
    alias: 'widget.trophybar',
    itemId: 'trophy-bar',
    border: 0,
    cls: 'trophy-bar',
    height: 14,
    text: '???',
    /**
     * @cfg {ExGods.model.User} user (required)
     * @inheritdoc ExGods.view.user.TechInfo#cfg-user
     */
    width: 151,
    onRender: function() {
        var me = this,
            user = me.user;
        me.callParent(arguments);
        if (user) {
            me.tooltip = Ext.widget('tooltip', {
                target: me.el,
                cls: 'paperdeco-tooltip',
                plugins: [
                    'paperdeco'
                ],
                maxWidth: parseInt(ExGods.ref('constants|tooltip_max_width').value),
                tpl: new Ext.Template('<div class="paper-title ellipsis">' + ExGods.getMsgByKey('stuff_tooltip_trophy') + '</div>' + '<div class="tooltip-paper-body">' + ExGods.ref('message_client|trophy_tooltip') + '</div>'),
                listeners: {
                    beforeshow: function(tooltip) {
                        var trophy = me.user.get('hoard').trophy,
                            relative = me.getRelativeTrophy(trophy);
                        tooltip.update({
                            trophy: trophy,
                            to_level: relative.total - relative.current
                        });
                    }
                }
            });
            me.setData(user.get('hoard').trophy);
            me.mon(user, {
                trophychanged: me.setData,
                //trophy_levelchanged: me.setData,
                scope: me
            });
            me.el.on('click', function() {
                /**
                 * @event click
                 *     
                 * @param {ExGods.view.user.TrophyBar} this
                 */
                this.fireEvent('click', this);
            }, me);
        }
    },
    /**
     *   
     * 
     * @param {Number} trophy 
     */
    setData: function(trophy) {
        var me = this,
            relative = me.getRelativeTrophy(trophy),
            percent = relative.current >= 0 ? relative.current / relative.total : 0;
        me.updateProgress(percent, Math.floor(percent * 100) + '%');
        me.tooltip.update(relative);
    },
    /**
     *          
     * 
     * @param {Number} trophy    
     * @return {Object}   
     * 
     *  {
     *      current: <_>,
     *      total: <_>
     *  }
     */
    getRelativeTrophy: function(trophy) {
        var me = this,
            levels = ExGods.references.get('user_trophy'),
            level = me.user.get('hoard').trophy_level || 1,
            min = level ? levels.get(level).trophy : 0,
            max = levels.get(level + 1) ? levels.get(level + 1).trophy : levels.get(level).trophy;
        if (max - min == 0)  {
            min = levels.get(level - 1).trophy;
        }
        
        return {
            current: Math.max(Math.min(trophy, max) - min, 0),
            total: max - min
        };
    },
    /**
     *     
     * 
     * @param {ExGods.model.User} user  
     */
    setUser: function(user) {
        var me = this;
        if (me.user != user) {
            me.mun(me.user, {
                trophychanged: me.setData,
                //trophy_levelchanged: me.setData,
                scope: me
            });
            me.user = user;
            me.setData(user.get('hoard').trophy);
            me.mon(user, {
                trophychanged: me.setData,
                //trophy_levelchanged: me.setData,
                scope: me
            });
        }
    }
});

/**
 *     
 */
Ext.define('ExGods.view.user.TechInfo', {
    extend: Ext.container.Container,
    alias: 'widget.techinfo',
    cls: 'tech-info-container',
    id: 'tech-info',
    /**
     * @cfg {Boolean} enemy
     *      
     */
    enemy: false,
    height: 95,
    layout: 'absolute',
    /**
     * @cfg {ExGods.model.User} user
     * ,    
     */
    width: 285,
    initComponent: function() {
        var me = this,
            shift = 0,
            isInBattle = (me.enemy || me.user.get('battle')) ? true : false;
        if (me.enemy) {
            shift = 54;
        }
        me.thumb = Ext.widget('button', {
            cls: me.enemy ? 'enemy-btn flip-h' : '',
            height: 50,
            icon: Ext.BLANK_IMAGE_URL,
            itemId: 'avatar-thumb',
            listeners: {
                click: {
                    fn: me.avatarThumbClick,
                    scope: me
                }
            },
            width: 50,
            ui: 'image',
            x: 5 + shift,
            y: 5
        });
        me.displayTitle = Ext.widget('component', {
            tpl: [
                '{[ ExGods.printUser(values, {fields: ["name", "rank"], maxNameWidth: 150 }) ]}'
            ],
            x: 66 + shift,
            y: 4
        });
        me.healthBar = Ext.widget('healthbar', {
            user: me.user,
            hidden: !isInBattle,
            x: 75 + shift,
            y: 26
        });
        me.manaBar = Ext.widget('manabar', {
            user: me.user,
            hidden: !isInBattle,
            x: 75 + shift,
            y: 41,
            empty: me.enemy
        });
        me.shieldBar = Ext.widget('shieldbar', {
            user: me.user,
            hidden: !isInBattle,
            x: 159 + shift,
            y: 26
        });
        me.experienceBar = Ext.widget('experiencebar', {
            user: me.enemy ? null : me.user,
            hidden: isInBattle,
            x: 76 + shift,
            y: 41
        });
        me.trophyBar = Ext.widget('trophybar', {
            user: me.enemy ? null : me.user,
            hidden: isInBattle,
            x: 76 + shift,
            y: 26
        });
        me.level = Ext.widget('component', {
            cls: 'level',
            height: 13,
            width: 20,
            x: 135 + shift + (me.enemy ? 1 : 0),
            y: 67
        });
        me.items = [
            me.thumb,
            me.displayTitle,
            me.healthBar,
            me.manaBar,
            me.shieldBar,
            me.experienceBar,
            me.trophyBar,
            me.level
        ];
        me.callParent();
        if (me.user) {
            me.setUser(me.user);
        }
        me.on({
            battlestart: function() {
                me.el.addCls('in-battle');
                me.healthBar.show();
                me.manaBar.show();
                me.shieldBar.show();
                me.experienceBar.hide();
                me.trophyBar.hide();
            },
            battlefinish: {
                fn: me.onBattleFinish,
                scope: me
            }
        });
    },
    onBattleFinish: function() {
        var me = this,
            hoard = me.user.get('hoard');
        me.el.removeCls('in-battle');
        me.healthBar.hide();
        me.manaBar.hide();
        me.shieldBar.hide();
        me.experienceBar.show();
        me.trophyBar.show();
        me.user.set('hoard', hoard);
    },
    setHealthBar: function(hp) {
        this.setProgressBar(this.healthBar, hp);
    },
    setManaBar: function(mp) {
        this.setProgressBar(this.manaBar, mp);
    },
    /**
     *    
     */
    setProgressBar: function(bar, progress) {
        var value = parseInt(progress[0]),
            max = parseInt(progress[1]);
        bar.updateProgress(value / max, value + ' / ' + max);
    },
    avatarThumbClick: function() {
        var me = this;
        me.fireEvent('thumbclick', me);
    },
    /**
     *      
     * @param {ExGods.model.User} user
     */
    setUser: function(user) {
        var me = this,
            userEvents = {
                change: me.updateUser,
                avatar_ruin_changed: me.updateThumbIcon,
                scope: me
            };
        if (me.user) {
            me.user.un(userEvents);
        }
        me.user = user;
        me.updateUser();
        user.on(userEvents);
        if (user.isBattle()) {
            me.healthBar.setUser(user);
            me.manaBar.setUser(user);
            me.shieldBar.setUser(user);
        } else if (!me.enemy) {
            me.experienceBar.setUser(user);
            me.trophyBar.setUser(user);
        }
    },
    /**
     *     
     */
    updateUser: function() {
        var me = this,
            user = me.user,
            level = parseInt(user.getLevel()),
            valourRef = user.getValourRef();
        if (me.enemy && user.get('is_bot')) {
            me.addCls('is_bot');
        } else {
            me.removeCls('is_bot');
        }
        //  
        me.updateThumbIcon();
        //  
        me.displayTitle.update(user.data);
        var timed = user.get('timed');
        //   
        //me.setManaBar(timed.mp);
        var hoard = user.get('hoard');
        //   
        var valour = parseInt(hoard.valour),
            valourLevels = ExGods.ref('user_valour'),
            maxValour = null;
        //  
        var arr = level.toString().split('');
        var levelStr = '';
        Ext.Array.forEach(arr, function(item) {
            levelStr += '<img alt="' + item + '" class="number number-' + item + '" height="13" src="' + Ext.BLANK_IMAGE_URL + '" width="10" />';
        });
        me.level.update(levelStr);
    },
    /**
     * @private    
     */
    updateThumbIcon: function() {
        var me = this,
            iconEl = me.thumb.btnIconEl,
            backgrounds = [];
        if (!me.thumb.rendered) {
            me.thumb.on('afterrender', me.updateThumbIcon, me, {
                single: true
            });
            return;
        }
        if (!me.user.data.real_user && me.user.data.is_bot) {
            me.thumb.addCls('bot_thumb');
        } else {
            me.thumb.removeCls('bot_thumb');
        }
        if (me.user.hasFeature("avatar_ruin")) {
            backgrounds.push('url(' + ExGods.ref('images|avatar_ruin').image.avatar_ruin_small + ') no-repeat 50% 50%');
        }
        backgrounds.push('url(' + me.user.getThumb() + ') no-repeat 50% 50%');
        if (iconEl) {
            iconEl.setStyle('background', backgrounds.join(','));
        }
    },
    getResources: function() {
        var me = this,
            images = [];
        var imgs = ExGods.ref('images|avatar_ruin').image;
        for (var it in imgs) {
            images.push(imgs[it]);
        }
        if (me.user) {
            images.push(me.user.getThumb());
        }
        return {
            images: images
        };
    }
});

/**
 * 
 */
Ext.define('ExGods.view.item.Item', {
    extend: Ext.button.Button,
    alias: 'widget.item',
    /**
     * @cfg {Object} item (required)
     * 
     */
    /**
     * @cfg {ExGods.model.User} user
     * 
     */
    cls: 'item',
    height: 64,
    /**
     * @property {Boolean} isLoaded   
     */
    isLoaded: false,
    renderTpl: '<em id="{id}-btnWrap" class="{splitCls}">' + '<div id="{id}-btnEl" type="{type}" hidefocus="true"' + // the autocomplete="off" is required to prevent Firefox from remembering
    // the button's disabled state between page reloads.
    '<tpl if="tabIndex"> tabIndex="{tabIndex}"</tpl> role="button" autocomplete="off">' + '<span id="{id}-btnInnerEl" class="{baseCls}-inner" style="{innerSpanStyle}">' + '{text}' + '</span>' + '<span id="{id}-btnIconEl" class="{baseCls}-icon {iconCls}">&#160;</span>' + '</div>' + '</em>' + '<div class="stack-counter" id="{id}-btnStackCounter"></div>' + '<div class="upgrade_stars_container" id="{id}-upgradeStarsContainer"></div>',
    padding: 0,
    text: ' ',
    width: 64,
    initComponent: function() {
        var me = this;
        if (me.item)  {
            me.itemPrototype = ExGods.app.getItemPrototypesStore().data.getByKey(me.item.get('proto_id'));
        }
        
        me.callParent();
    },
    getSlot: function() {
        var slot_id = this.slot.id,
            user = this.user || ExGods.app.user;
        return user.slots().data.getByKey(slot_id);
    },
    /**
     * /    
     */
    updateItem: function() {
        var me = this;
        me.isLoaded = true;
        if (me.item) {
            if (me.el) {
                me.el.setStyle('background-image', me.getItemBckgImage());
            } else {
                me.style = {
                    'background-image': me.getItemBckgImage()
                };
            }
        }
    },
    onRender: function(ct, position) {
        var me = this;
        me.callParent(arguments);
        me.btnStackCounter = me.el.down('#' + me.id + '-btnStackCounter');
        me.upgradeStarsContainer = me.el.down('#' + me.id + '-upgradeStarsContainer');
        if (me.item) {
            me.updateItem();
            var count = me.item.get('count');
        }
        if (count > 1) {
            me.btnStackCounter.update(count);
            me.btnStackCounter.show();
        } else {
            me.btnStackCounter.hide();
        }
        if (me.item && me.item.get('param').upgrades > 0) {
            var stars = '<div class="upgrade_stars_container">';
            for (i = 0; i < me.item.get('param').upgrades; i++) {
                stars += '<div class="upgrade_star"></div>';
            }
            stars += '</div>';
            me.upgradeStarsContainer.update(stars);
            me.upgradeStarsContainer.show();
        } else {
            me.upgradeStarsContainer.hide();
        }
        //     -    
        var slotType = me.slot.get('type'),
            obj = {
                'data-qh_otype': 'active_slot',
                'data-qh_oid': slotType
            };
        if ([
            1,
            2,
            5,
            8
        ].indexOf(slotType) != -1) {
            obj['data-qh_opts'] = "{&quot;cls&quot;:&quot;flip-h&quot;}";
        }
        if ([
            1,
            2,
            4,
            5,
            8,
            11,
            12,
            13
        ].indexOf(slotType) != -1) {
            me.el.addCls('qh-object active-slot');
            me.el.set(obj);
        }
        // 
        if (me.item) {
            ExGods.Tooltips.makeElementAsTip(me.el, 'item', me.item.get('item_id') + '|user_info');
        }
    },
    getItemBckgImage: function() {
        var me = this,
            slotType = me.getSlot().get('type'),
            active = references.get('slot_type').getByKey(slotType).active,
            result = '';
        if (me.item.hasCriticalDurability()) {
            result = 'url(' + ExGods.references.get('images').get('item_critical_status').image['img60'] + '), ';
        }
        if (me.slot.data.protect == 1) {
            result += 'url(' + IMAGE_URL + '/slots/new/frm.png),';
        }
        result += 'url(' + me.itemPrototype.getImage(active ? 'on' : 'off') + ')';
        return result;
    },
    onDestroy: function() {
        var me = this;
        // me.clearTip(); //    
        me.callParent(arguments);
    }
});

/**
 *  
 */
Ext.define('ExGods.view.user.DollPanel', {
    extend: Ext.panel.Panel,
    alias: 'widget.dollpanel',
    mixins: [
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.InventoryDragHighlight
    ],
    cls: 'doll',
    layout: 'absolute',
    x: 5,
    y: 22,
    style: {
        'float': 'left'
    },
    /**
     * @cfg {ExGods.model.User} user (required)
     * ,   
     */
    width: 358,
    initComponent: function() {
        var me = this,
            user = me.user;
        me.plugins = [
            'inventory_frame'
        ];
        me.callParent();
        me.data_items = [];
        me.slotsWdg = undefined;
        me.initDoll();
        me.mon(user.slots(), 'load', me.initDoll, me);
    },
    /**
     * @private    
     */
    getSlotsConfig: function() {
        return {
            11: {
                //
                height: 64,
                width: 64,
                x: 274,
                y: 192
            },
            12: {
                //
                height: 64,
                width: 64,
                x: 274,
                y: 0
            },
            2: {
                // 
                height: 64,
                width: 64,
                x: 0,
                y: 0
            },
            1: {
                // 
                height: 64,
                width: 64,
                x: 0,
                y: 128
            },
            5: {
                // 
                height: 64,
                width: 64,
                x: 0,
                y: 64
            },
            13: {
                // 
                height: 64,
                width: 64,
                x: 274,
                y: 64
            },
            24: {
                // 
                height: 64,
                width: 64,
                x: 274,
                y: 256
            },
            4: {
                // 
                height: 64,
                width: 64,
                x: 274,
                y: 128
            },
            8: {
                // 
                height: 64,
                width: 64,
                x: 0,
                y: 192
            }
        };
    },
    /**
     *   
     */
    initDoll: function() {
        var me = this,
            user = me.user,
            userSlots = user.slots(),
            slots, slotConfigs;
        slotConfigs = me.getSlotsConfig();
        var slots = [];
        userSlots.each(function(slot) {
            var config = slotConfigs[slot.get('type')];
            if (config) {
                slots.push(me.initSlotComponent(slot, config));
            }
        });
        me.suspendLayouts();
        me.removeAll(true);
        me.add(me.initAvatar());
        if (slots) {
            //me.add(slots);
            me.slotsWdg = slots;
        }
        //  show   ,    
        me.resumeLayouts(true);
    },
    initSlotComponent: function(slot, config) {
        var me = this,
            user = me.user;
        Ext.apply(config, {
            slot: slot,
            type: slot.get('type'),
            user: user
        });
        var wdg = Ext.widget('dollslot', config);
        if (wdg.stuff) {
            me.data_items.push(wdg.stuff);
        }
        return wdg;
    },
    onRender: function() {
        var me = this,
            itemController = ExGods.app.getController('Item');
        user = me.user;
        me.callParent(arguments);
        if (me.slotsWdg) {
            me.add(me.slotsWdg);
        }
        me.mon(user.slots(), 'new_slot', me.onNewSlot, me);
        me.mon(user, 'avatar_ruin_changed', me.updateAvatar, me);
        me.mon(user, 'shapechanged', me.updateAvatar, me);
        if (user == ExGods.app.user && user.getMaskSlot()) {
            me.mon(user.getMaskSlot().items(), 'datachanged', me.updateAvatar, me);
        }
        if (me.user == ExGods.app.user) {
            me.initDrop({
                onDrop: function(target, dd, e, data) {
                    if (Ext.getClassName(data.item) != 'ExGodsCore.model.Item')  {
                        return false;
                    }
                    
                    var type = data.item.getType().slot_on,
                        isValid = false;
                    me.user.slots().each(function(slot) {
                        if (slot.get('type') == type) {
                            isValid = true;
                        }
                    });
                    if ([
                        1,
                        2,
                        4,
                        5,
                        8,
                        11,
                        12,
                        13
                    ].indexOf(data.slot.get('type')) != -1) {
                        isValid = false;
                    }
                    if (isValid) {
                        itemController.putOn(data.item, data.cancel);
                    }
                    return isValid;
                }
            });
            me.initDragHighlight();
        }
    },
    /**
     * @private     
     */
    onNewSlot: function(slot) {
        var me = this,
            config = me.getSlotsConfig()[slot.data.type];
        if (config) {
            me.add(me.initSlotComponent(slot, config));
        }
    },
    initAvatar: function() {
        var me = this;
        me.avatar = Ext.widget('component', {
            itemId: 'avatar',
            style: this.getAvatarStyle(),
            height: 316,
            width: 210,
            x: 64,
            y: 1
        });
        me.maskGradeLine = Ext.widget('maskgradeline', {
            x: 124,
            y: 296,
            maskProto: me.user.getMaskProto()
        });
        return [
            me.avatar,
            me.maskGradeLine
        ];
    },
    /**
     *   
     */
    updateAvatar: function() {
        var me = this;
        //  
        if (me.avatar.el) {
            me.avatar.el.setStyle(me.getAvatarStyle());
            me.avatar.style = me.getAvatarStyle();
        } else {
            me.avatar.style = me.getAvatarStyle();
        }
        //   
        me.maskGradeLine.update(me.user.getMaskProto());
    },
    /**
     * @private
     *     
     */
    getAvatarStyle: function() {
        var me = this,
            backgrounds = [];
        if (me.user.hasFeature("avatar_ruin")) {
            backgrounds.push('url(' + ExGods.references.get('images').get('avatar_ruin').image.avatar_ruin + ') no-repeat 50% 50%');
        }
        backgrounds.push('url(' + me.user.getInventoryAvatar() + ') no-repeat 50% 50%');
        return {
            background: backgrounds.join(',')
        };
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var obj = ExGods.ref('images|avatar_ruin').image;
        for (var i in obj) {
            arr_images.push(obj[i]);
        }
        //    
        me.user.slots().each(function(slot) {
            obj = ExGods.ref('slot_type|' + slot.get('type')).images;
            for (var i in obj) {
                arr_images.push(obj[i]);
            }
        });
        return {
            stuff: me.data_items || [],
            images: [
                me.user.getInventoryAvatar(),
                IMAGE_URL + 'inventory/frm_top_left.jpg',
                IMAGE_URL + 'inventory/frm_top_center.jpg',
                IMAGE_URL + 'inventory/frm_top_right.jpg',
                IMAGE_URL + 'inventory/frm_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_right.jpg',
                IMAGE_URL + 'inventory/frm_bottom_center.jpg',
                IMAGE_URL + 'inventory/frm_bottom_left.jpg',
                IMAGE_URL + 'inventory/frm_left.jpg',
                IMAGE_URL + 'inventory/frm_top.png',
                //   
                IMAGE_URL + 'battle/peril-trafaret.png',
                IMAGE_URL + 'battle/peril-ico.png',
                //   
                IMAGE_URL + 'inventory/btn_axes.png',
                IMAGE_URL + 'inventory/frm_avatar_bottom.jpg',
                IMAGE_URL + 'slot_locked.jpg',
                IMAGE_URL + 'inventory/frm_avatar_top.jpg'
            ].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.Stats', {
    extend: Ext.container.Container,
    alias: 'widget.userstats',
    layout: {
        type: 'vbox',
        align: 'stretch'
    },
    cls: 'user-info-stats',
    width: 225,
    height: 325,
    plugins: [
        'paperdeco'
    ],
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    /**
     * @cfg {ExGods.store.UserContacts} userContacts (required)
     *   ExGods.user
     */
    initComponent: function() {
        var me = this,
            user = me.user;
        me.items = [
            {
                xtype: 'component',
                data: me.prepareData(user.data),
                tpl: [
                    '<div style="margin: 7px 5px;">',
                    '<tpl if="ExGods.app.user.get(\'display_title\') == title">',
                    '<tpl if="guild">',
                    '<div class="stats-list">',
                    '<div style="text-align: center; max-width: 185px;" class="ellipsis"><strong>[{guild.tag}]&nbsp;{guild.title}</strong></div>',
                    '</div>',
                    '<div class="separator"></div>',
                    '</tpl>',
                    '<div class="stats-list">',
                    '<ul class="table-list">' + '<li><span class="label">' + references.get('user_hoard').getByKey('level').label + '</span><span class="value">{[ this.printIcon("level", "user_hoard") ]} </span><span class="value">{hoard.level}</span></li>' + '<li class="even"><span class="label">' + references.get('user_hoard').getByKey('expa').label + '</span><span class="value">{[ this.printIcon("expa", "user_hoard") ]} </span><span class="value">{[this.printExp(values.experience)]}</span></li>' + '<li><span class="label">' + references.get('user_hoard').getByKey('trophy_level').label + '</span><span class="value">{[ this.printIcon("trophy_level", "user_hoard") ]} </span><span class="value">{trophy_level_label}</span></li>' + '<li class="even"><span class="label">' + references.get('user_hoard').getByKey('trophy').label + '</span><span class="value">{[ this.printIcon("trophy", "user_hoard") ]} </span><span class="value">{trophy.current}{trophy.total}</span></li>' + '{elo_string}' + '<li class="even"><span class="label">' + references.get('user_stat').getByKey('weightlift').label + '</span><span class="value">{[ this.printIcon("weightlift", "user_stat") ]}</span><span class="value">{stats.summary.mass}/{stats.modif.capacity}</span></li>' + '</ul>' + '</div>',
                    '<tpl else>',
                    '<div class="stats-list">',
                    '<div style="text-align: center;"><strong>{title}</strong></div>',
                    '<tpl if="guild">',
                    '<div style="text-align: center; max-width: 185px;" class="ellipsis"><strong>[{guild.tag}]&nbsp;{guild.title}</strong></div>',
                    '</tpl>',
                    '</div>',
                    '<div class="separator"></div>',
                    '<div class="stats-list">',
                    '<ul class="table-list">' + '<li><span class="label">' + references.get('user_hoard').getByKey('level').label + '</span><span class="value">{[ this.printIcon("level", "user_hoard") ]} </span><span class="value">{hoard.level}</span></li>' + '<li class="even"><span class="label">' + references.get('user_hoard').getByKey('trophy_level').label + '</span><span class="value">{[ this.printIcon("trophy_level", "user_hoard") ]} </span><span class="value">{trophy_level_label}</span></li>' + '<li><span class="label">' + references.get('user_hoard').getByKey('trophy').label + '</span><span class="value">{[ this.printIcon("trophy", "user_hoard") ]} </span><span class="value">{trophy.current}{trophy.changes}</span></li>' + '{elo_string_even}' + '</ul>' + '</div>',
                    '</tpl>',
                    '<div class="separator"></div>',
                    '<div class="stats-list">',
                    '{user_stat}',
                    '</div>',
                    '<div class="separator"></div>',
                    '<tpl if="this.getMaskProto()">',
                    '<div class="paper-title ellipsis" style="max-width:207px; font-weight: bold;">{[ this.getMaskProto().title ]}</div>',
                    '</tpl>',
                    '<div class="user_stats_image">',
                    '{[ ExGods.util.User.printUserStats(values.stats.stats, {visibleValue: 2}) ]}',
                    '</div>',
                    '</div>',
                    {
                        printExp: function(exp) {
                            return ExGods.printNumber(exp.current, 100000) + '/' + ExGods.printNumber(exp.total, 100000);
                        },
                        getMaskProto: function() {
                            return me.user.getMaskProto();
                        },
                        printIcon: function(name, reference) {
                            var iconHtml = '';
                            var icon = reference == 'user_hoard' ? references.get(reference).getByKey(name).icon : reference == 'user_stat' ? references.get(reference).getByKey(name).param.icon : reference == 'user_summary' ? references.get(reference).getByKey(name).icon : name;
                            if (icon) {
                                iconHtml = '<img width="16" height="16" style="margin: 0 2px -3px 0;" src="' + IMAGE_URL + icon + '"/>';
                            }
                            return iconHtml;
                        }
                    }
                ]
            }
        ];
        me.callParent();
        me.mon(user, 'change', function() {
            var data = me.prepareData(user.data);
            me.items.first().update(data);
        }, me);
        if (user == ExGods.app.user) {
            me.addCls('myinfo');
        }
    },
    /**
     *         
     * 
     * @param {Object} data   {ExGods.model.User}
     * @return {Object}
     */
    prepareData: function(data) {
        var me = this,
            user = me.user,
            levels = ExGods.references.get('user_level'),
            level = data.hoard.level,
            min = level ? levels.getByKey(level).expa : 0,
            max = levels.getByKey(level + 1).expa,
            expa = data.hoard.expa,
            trophy_level_label, curr_trophy, next_trophy;
        preparedData = data;
        //  
        preparedData.elo_string = '';
        preparedData.elo_string_even = '';
        var string_id = 0;
        Ext.Object.each(data.elo, function(key, value) {
            var elo_change = parseInt(value) - parseInt(ExGods.app.user.data.elo[key]);
            var elo_change_string = '';
            if (elo_change != 0) {
                elo_change_string = '<small>(<span class="' + (elo_change > 0 ? "up" : "down") + '">' + (elo_change > 0 ? "+" : "") + elo_change + '</span>)</small>';
            }
            preparedData.elo_string += '<li class="' + (string_id % 2 == 0 ? "" : "even") + '"><span class="label">' + ExGods.ref('user_elo|' + key).label + '</span><span class="value"></span><span class="value">' + value + elo_change_string + '</span></li>';
            preparedData.elo_string_even += '<li class="' + (string_id % 2 == 0 ? "even" : "") + '"><span class="label">' + ExGods.ref('user_elo|' + key).label + '</span><span class="value"></span><span class="value">' + value + elo_change_string + '</span></li>';
            string_id++;
        });
        //  
        if (data.hoard.trophy_level == 0)  {
            data.hoard.trophy_level = 1;
        }
        
        Ext.Object.each(ExGods.references.map.user_trophy.map, function(key, item) {
            if (item.level == data.hoard.trophy_level) {
                preparedData.trophy_level_label = item.description.label;
                curr_trophy = item.trophy;
            }
            if (item.level == data.hoard.trophy_level + 1) {
                next_trophy = item.trophy;
            }
        });
        //
        var changes = data.hoard.trophy - ExGods.app.user.data.hoard.trophy;
        preparedData.trophy = {
            current: data.hoard.trophy,
            total: '/' + next_trophy,
            changes: '<small>(<span class="' + (changes > 0 ? "up" : "down") + '">' + (changes > 0 ? "+" : "") + changes + '</span>)</small>'
        };
        //
        preparedData.experience = {
            current: expa,
            total: max
        };
        var preparedChanges = {};
        Ext.each(config.references.user_stat, function(item) {
            if (item.visible == 1 && !item.param.fill) {
                var curStat = user.data.stats.stats[item.name],
                    wasStat = ExGods.app.user.data.stats.stats[item.name],
                    changes = parseInt(curStat) - parseInt(wasStat),
                    className = '';
                preparedChanges[item.name] = changes;
            }
        });
        preparedData.user_stat = ExGods.util.User.printUserStats(user.data.stats.stats, {
            visibleValue: 1,
            changes: preparedChanges,
            align: 'right'
        });
        return preparedData;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'icons/stats/ico_injury16.png',
                IMAGE_URL + 'icons/stats/ico_life16.png',
                IMAGE_URL + 'icons/stats/ico_shield16.png',
                IMAGE_URL + 'icons/stats/ico_mana16.png',
                IMAGE_URL + 'icons/stats/ico_fury16.png',
                IMAGE_URL + 'mask/ico_adroitness.png',
                IMAGE_URL + 'mask/star_red.png',
                IMAGE_URL + 'mask/star_green.png',
                IMAGE_URL + 'mask/star.png',
                IMAGE_URL + 'mask/stars_bg.png',
                IMAGE_URL + 'mask/ico_power.png',
                IMAGE_URL + 'mask/ico_armor.png',
                IMAGE_URL + 'mask/ico_accuracy.png'
            ].concat(arr_images)
        };
    }
});

/**
 *     
 */
Ext.define('ExGods.view.user.Info', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.userinfo',
    tabUi: 'skintext',
    cls: 'owerflow_visible_panel',
    bodyPadding: '0 11 11',
    closable: false,
    plugins: [
        'skindeco'
    ],
    /**
     * @cfg {ExGods.model.User} user (required)
     * ,    
     */
    initComponent: function() {
        var me = this,
            icons = ExGods.references.get('images'),
            user = me.user,
            items;
        if (user != ExGods.app.user || user.isBattle()) {
            me.closable = true;
        }
        user.setRaidAchievements();
        items = [
            {
                icon: ExGods.ref('images|inventory_tabs').image['inventory'],
                layout: 'absolute',
                items: [
                    {
                        xtype: 'button',
                        text: ExGods.getMsgByKey('inventory_params_btn_text'),
                        x: 132,
                        y: 8,
                        width: 104,
                        height: 18,
                        cls: 'inventory-params',
                        style: {
                            'z-index': '999'
                        },
                        handler: function() {
                            if (Ext.ComponentQuery.query('#info-stats')[0].isVisible()) {
                                Ext.ComponentQuery.query('#info-stats')[0].hide();
                                this.removeCls('opened');
                            } else {
                                Ext.ComponentQuery.query('#info-stats')[0].show();
                                this.addClass('opened');
                            }
                        }
                    },
                    {
                        xtype: 'userstats',
                        user: user,
                        // id: 'user-info-stats',
                        itemId: 'info-stats',
                        hidden: true,
                        width: 225,
                        height: 325,
                        style: {
                            'z-index': '999'
                        },
                        x: 72,
                        y: 32
                    },
                    {
                        xtype: 'dollpanel',
                        user: user
                    },
                    {
                        xtype: 'panel',
                        headerText: ExGods.getMsgByKey('view_user_info_bagtitle'),
                        x: 395,
                        width: 340,
                        height: 337,
                        y: 22,
                        plugins: [
                            'inventory_frame'
                        ],
                        items: [
                            {
                                xtype: 'component',
                                style: {
                                    position: 'absolute',
                                    width: '337px',
                                    height: '335px',
                                    left: '-9px',
                                    top: '-5px'
                                },
                                tpl: '<div style="display: table; height: 100%;"><div style="padding: 0px 20px 0px 25px; position: relative; display: table-cell; vertical-align: middle; text-align: center; ">' + (user.data.title === ExGods.app.user.data.title ? ExGods.ref('message_client|my_user_info') : ExGods.ref('message_client|enemy_user_info')) + '</div>',
                                data: user.data,
                                plugins: [
                                    'paperdeco'
                                ]
                            }
                        ]
                    }
                ]
            },
            {
                icon: ExGods.ref('images|inventory_tabs').image.raids,
                layout: 'absolute',
                items: [
                    {
                        xtype: 'guildraids',
                        store: me.raidsStore,
                        show_rewards: false
                    }
                ]
            }
        ];
        me.items = items;
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        var imgs = ExGods.ref('images|inventory_tabs').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        var obj = me.callParent();
        return {
            stuff: [].concat(obj.stuff),
            images: [].concat(arr_images).concat(obj.images)
        };
    }
});

Ext.define('ExGods.view.user.PowerChange', {
    extend: Ext.Component,
    alias: 'widget.powerchange',
    cls: 'user-power-change',
    id: 'user_power_change',
    autoShow: true,
    closable: false,
    width: 366,
    height: 104,
    y: 163,
    //(430 - 104)/2
    x: 247,
    //(860 - 366)/2
    renderTo: 'center',
    style: {
        opacity: 0
    },
    animData: {
        up: {
            images: [
                'add_power.png'
            ],
            frames: [
                [
                    0,
                    0,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    0,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    107,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    107,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    214,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    214,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    321,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    321,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    428,
                    366,
                    107,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    428,
                    366,
                    107,
                    0,
                    0,
                    0
                ]
            ]
        },
        down: {
            images: [
                'delete_power.png'
            ],
            frames: [
                [
                    0,
                    0,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    0,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    104,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    104,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    208,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    208,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    312,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    312,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    0,
                    416,
                    366,
                    104,
                    0,
                    0,
                    0
                ],
                [
                    366,
                    416,
                    366,
                    104,
                    0,
                    0,
                    0
                ]
            ]
        }
    },
    initComponent: function() {
        var me = this,
            text;
        if (me.positive) {
            text = ExGods.app.applyTpl(ExGods.getMsgByKey('powerchange_positive'), {
                change: me.change
            });
        } else {
            text = ExGods.app.applyTpl(ExGods.getMsgByKey('powerchange_negative'), {
                change: me.change
            });
        }
        me.html = [
            '<div class="user-power-change-text">' + text + '</div>'
        ];
    },
    onRender: function() {
        var me = this,
            animData = me.positive ? me.animData.up : me.animData.down,
            top = me.y + (me.positive ? -100 : 100);
        var spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                images: animData.images,
                frames: animData.frames,
                renderTo: me.getEl(),
                infinite: true
            });
        spriteSheet.start();
        me.el.animate({
            to: {
                opacity: 1
            },
            duration: Number(ExGods.ref('constants|powerchange_fade_id_speed').value),
            callback: function() {
                me.el.animate({
                    to: {
                        opacity: 0,
                        top: top + 'px'
                    },
                    delay: Number(ExGods.ref('constants|powerchange_delay').value),
                    duration: Number(ExGods.ref('constants|powerchange_fade_out_speed').value),
                    callback: function() {
                        me.el.remove();
                        me.destroy();
                    }
                });
            }
        });
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var it in me.animData) {
            arr_images = arr_images.concat(me.animData[it].images);
        }
        return {
            stuff: [],
            images: [].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.user.ExperienceTable', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.userexperiencetable',
    id: 'user-experience-table',
    autoShow: true,
    bodyPadding: 0,
    /**
     * @cfg {Ext.data.Store} store (required)
     * 
     */
    /**
     * @cfg {ExGods.model.User} [user]
     * 
     */
    y: 142,
    initComponent: function() {
        var me = this,
            grid,
            feats = [];
        if (me.user) {
            var featureStore = me.user.get('feature'),
                feats = featureStore.getExpFeatures();
        }
        grid = Ext.widget({
            xtype: 'dataview',
            itemSelector: 'tbody tr',
            store: me.store,
            tpl: [
                '<div class="paper-title" style="margin:2px 1px 0">',
                '<h4>' + ExGods.getMsgByKey('stuff_tooltip_experience') + '</h4>',
                '</div>',
                '<table>',
                '<thead>',
                '<tr>',
                '<th>' + ExGods.getMsgByKey('view_arena_enemylist_level') + '</th>',
                '<th class="expa">' + ExGods.getMsgByKey('stuff_tooltip_experience') + '</th>',
                '</tr>',
                '</thead>',
                '<tbody>',
                '<tpl for=".">',
                '<tr {[this.getCls(xindex)]}>',
                '<td>{level}</td>',
                '<td class="expa">{expa:number("0,0")}</td>',
                '</tr>',
                '</tpl>',
                '</tbody>',
                '</table>',
                '<tpl if="this.checkBonuses(values)">',
                '<div class="paper-separator"></div>',
                '<div class="paper-title" style="margin:2px 1px 0">',
                '<h4>' + ExGods.getMsgByKey('view_user_exptable_bonuses') + '</h4>',
                '</div>',
                '<ul class="exp-bonuses"></ul>',
                '</tpl>',
                {
                    getCls: function(i) {
                        return i % 2 ? 'class="even"' : '';
                    },
                    checkBonuses: function() {
                        return feats.length > 0;
                    }
                }
            ],
            width: 225
        });
        me.items = [
            grid
        ];
        me.mon(featureStore, 'datachanged', me.renderBonuses, me);
        me.callParent();
        if (me.user) {
            grid.on('viewready', me.onViewReady, me);
        }
    },
    onViewReady: function(grid) {
        var me = this,
            selModel = grid.getSelectionModel();
        if (me.user) {
            me.renderBonuses(me.user.get('feature'));
        }
        selModel.select(me.user.getLevel() - 1);
        selModel.setLocked(true);
    },
    renderBonuses: function(store) {
        var me = this,
            feats = store.getExpFeatures(),
            l = Math.min(feats.length, 4),
            el = me.el.down('.exp-bonuses'),
            calcTime = function(feat) {
                return Math.floor(Math.max((ExGods.util.Date.normalizeServerDateTime(new Date(feat.get('ended').split('-').join('/'))).getTime() - new Date().getTime()) / 1000, 0));
            },
            onClickFn = function(feature) {
                Ext.widget('commondetailswindow', {
                    itemElement: this,
                    cascade: false,
                    data: {
                        label: feature.data.label,
                        description: feature.data.description,
                        image: feature.data.images.main
                    }
                });
            };
        ExGods.util.Ticker.removeListener(me.timer);
        me.timers = [];
        if (el) {
            if (l) {
                var el = me.el.down('.exp-bonuses'),
                    i = 0,
                    feat, li, timer;
                while (el.dom.firstChild) {
                    el.dom.firstChild.onclick = null;
                    el.dom.removeChild(el.dom.firstChild);
                }
                for (; i < l; i++) {
                    feat = feats[i];
                    li = document.createElement('li');
                    li.style.backgroundImage = 'url(' + feat.get('images').main + ')';
                    timer = document.createElement('div');
                    timer.innerHTML = Ext.util.Format.countdown(calcTime(feat), {
                        format: "short"
                    });
                    me.timers.push(timer);
                    li.onclick = onClickFn.bind(li, feat);
                    li.appendChild(timer);
                    el.dom.appendChild(li);
                }
                var _onTick = function() {
                        for (i = 0; i < l; i++) {
                            me.timers[i].innerHTML = Ext.util.Format.countdown(calcTime(feats[i]), {
                                format: "short"
                            });
                        }
                    };
                setTimeout(function() {
                    me.timer = ExGods.util.Ticker.addListener(_onTick, me);
                    _onTick();
                }, 0);
            } else {
                el.dom.removeChild(el.dom.firstChild);
            }
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: []
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.User', {
    extend: ExGods.controller.Base,
    models: [
        'User'
    ],
    views: [
        'CommonWindow',
        'user.ExperienceTable',
        'user.Info',
        'user.TechInfo',
        'user.TrophyTable',
        'user.PowerChange'
    ],
    refs: [
        {
            /**
         * @method getTechInfoContainer
         *     
         * @return {Ext.container.Container}
         */
            ref: 'techInfoContainer',
            selector: '#tech-info-container'
        },
        {
            /**
         * @method getTechInfo
         *     
         * @return {ExGods.view.user.TechInfo}
         */
            ref: 'techInfo',
            selector: '#tech-info'
        },
        {
            /**
         * @method getHeaderRight
         *       
         * @return {Ext.container.Container}
         */
            ref: 'headerRight',
            selector: '#header-right'
        },
        {
            ref: 'questButton',
            selector: '#mainmenu-quests-button'
        }
    ],
    tooltips: [
        'item',
        'slot'
    ],
    init: function(app) {
        var me = this;
        me.control({
            'techinfo': {
                thumbclick: me.onTechInfoClick
            },
            'chatmessagelist': {
                infoclick: me.onNickInfoClick
            },
            'experiencebar': {
                click: me.onUserExpirienceClick
            },
            'trophybar': {
                click: me.onUserTrophyClick
            },
            'userfinance': {
                render: me.updateMoney
            }
        });
        app.on({
            /**
             * @event nickinfoclick
             *       
             * @member ExGods.app
             * 
             * @param {String} title
             */
            nickinfoclick: me.onNickInfoClick,
            scope: me
        });
        app.getChatConnection().on({
            command_user: me.onUserCommand,
            command_reload: me.onReloadCommand,
            scope: me
        });
        //        "user"
        me.addAjaxRequestKeyHandler('user', function(data) {
            me.getUser().set(data.user);
            var slots = me.getUser().get('slots');
            Ext.each(data.user.update_slots, function(slot) {
                var record = slots.getById(parseInt(slot.ekey));
                if (record) {
                    record.set(slot);
                }
            });
            if (me.getQuestButton()) {
                me.getQuestButton().reset();
                me.getQuestButton().addCount(ExGods.app.user.availableQuestsStore.totalCount);
            }
        }, me);
        ExGods.Components.addComponentInitializer('user_target_panel', me.initUserTargetPanelComponent, me);
        me.getUser().on('statschanged', me.onPowerChanged, me);
        me.getUser().on('money' + ExGods.ref('constants|currency').value + 'changed', me.onMoneyChanged, me);
        me.getUser().on('moneycrystalchanged', me.onMoneyChanged, me);
    },
    onLaunch: function(app) {
        var me = this,
            user = me.getUser();
        me.getTechInfoContainer().add({
            xtype: 'techinfo',
            id: 'tech-info',
            user: user
        });
        if (me.getQuestButton())  {
            me.getQuestButton().addCount(ExGods.app.user.availableQuestsStore.totalCount);
        }
        
    },
    /**
     *    command_user  
     */
    onUserCommand: function() {
        this.getUser().loadRemote();
    },
    /**
     *    reload.
     */
    onReloadCommand: function() {
        location.reload();
    },
    onPowerChanged: function(user, newStats, oldStats) {
        var change = newStats.power - oldStats.power;
        if (Ext.get('user_power_change'))  {
            return;
        }
        
        var positive = undefined;
        if (change > 0) {
            positive = true;
        } else if (change < 0) {
            positive = false;
        }
        if (positive != undefined) {
            var wdj = Ext.widget('powerchange', {
                    positive: positive,
                    change: change,
                    autoShow: false
                });
            ExGods.Resources.load(wdj, function() {
                wdj.show();
            });
        }
    },
    onMoneyChanged: function(newValue, oldValue, record, key) {
        var me = this,
            isBattle = me.user.getBattle(),
            cmp = Ext.getCmp('user-finance');
        if (!cmp || !cmp.rendered) {
            if (!me.old_values)  {
                me.old_values = {};
            }
            
            me.old_values[key] = oldValue;
            return;
        }
        if (cmp.animating[key])  {
            return;
        }
        
        cmp.updateMoney.apply(cmp, arguments);
    },
    updateMoney: function() {
        var me = this,
            cmp = Ext.getCmp('user-finance'),
            money = me.user.get('money'),
            value;
        if (!me.old_values || cmp.animating[key])  {
            return;
        }
        
        for (var key in me.old_values) {
            cmp.updateMoney(money[key], me.old_values[key], me.user, key);
        }
        delete me.old_values;
    },
    /**
     *     
     * 
     * @param {ExGods.model.User} [user] ,   ,   
     */
    initUserInfo: function(user) {
        var me = this,
            app = me.application,
            info,
            raidsStore = ExGods.app.getGuildRaidsStore();
        if (!user)  {
            user = app.user;
        }
        
        info = Ext.widget('window2', {
            id: 'user-info',
            autoShow: false,
            user: user,
            items: [
                {
                    xtype: 'userinfo',
                    user: user,
                    raidsStore: raidsStore,
                    listeners: {
                        close: function() {
                            info.close();
                        }
                    }
                }
            ]
        });
        if (user != app.user) {
            info.on('destroy', function(view) {
                user.destroyStores();
            });
        }
        ExGods.app.block();
        ExGods.Resources.load(info, function() {
            ExGods.app.unblock();
            info.show();
        });
        return info;
    },
    /**
     * @private
     */
    onTechInfoClick: function(data) {
        var me = this;
        if (!data.displayTitle.data.real_user && data.displayTitle.data.is_bot) {} else // ignore
        {
            me.onNickInfoClick(data.displayTitle.data.display_title);
        }
    },
    /**
     *      .    .  .
     * @private
     *
     * @param {String} title  
     */
    onNickInfoClick: function(title) {
        var me = this,
            cmp, cmpId,
            viewport = me.app.getController('Viewport');
        if (me.user.get('display_title') != title) {
            me.request({
                url: '/game.pl?cmd=info_user',
                params: {
                    title: title
                },
                success: function(json) {
                    if (json.user_info) {
                        ExGods.helpme.loadProtos(json.user_info, 'slots.items.proto_id|mask_proto_id', function() {
                            me.showUserInfo(json.user_info);
                        });
                    }
                }
            });
        } else {
            me.showMyInfo();
        }
    },
    /**
     * @private
     *    
     */
    showMyInfo: function() {
        var me = this;
        if (me.getUser().isBattle()) {
            me.showUserInfo(me.user);
        } else {
            ExGods.Components.toggle('INVENTORY');
        }
    },
    /**
     *       
     * @private
     * 
     * @param {Object} user     
     */
    showUserInfo: function(user) {
        var me = this,
            user,
            viewport = me.app.getController('Viewport'),
            info = Ext.getCmp('user-info');
        if (Ext.getClassName(user) != 'ExGods.model.User') {
            user = Ext.create('ExGods.model.User', user);
        }
        if (info) {
            if (info.user != user) {
                info.destroy();
                me.initUserInfo(user);
            } else {
                info.destroy();
            }
        } else {
            me.initUserInfo(user);
        }
    },
    /**
     *     
     * @private
     *
     * @param {ExGods.view.user.ExperienceBar} cmp  
     */
    onUserExpirienceClick: function(cmp) {
        var me = this,
            user = cmp.user,
            data, store, cmp;
        data = Ext.Array.clone(ExGods.references.get('user_level').items);
        data.pop();
        //   ,    ,  
        store = Ext.create('Ext.data.Store', {
            fields: [
                'level',
                'expa'
            ],
            data: data,
            proxy: {
                type: 'memory'
            }
        });
        cmp = Ext.widget('userexperiencetable', {
            store: store,
            user: user,
            autoShow: false
        });
        ExGods.Resources.load(cmp, function() {
            cmp.show();
        });
    },
    /**
     *     
     * @private
     *
     * @param {ExGods.view.user.TrophyBar} cmp  
     */
    onUserTrophyClick: function(cmp) {
        var me = this,
            user = cmp.user,
            data, cmp, store;
        data = Ext.Array.clone(ExGods.references.get('user_trophy').getValues());
        data.pop();
        //   ,    ,  
        store = Ext.create('Ext.data.Store', {
            fields: [
                'description',
                'trophy'
            ],
            data: data,
            proxy: {
                type: 'memory'
            }
        });
        cmp = Ext.widget('usertrophytable', {
            store: store,
            user: user,
            autoShow: false
        });
        ExGods.Resources.load(cmp, function() {
            cmp.show();
        });
    },
    initUserTargetPanelComponent: function(config, componentId) {
        var me = this,
            store = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.User'
            }),
            actions = [],
            wnd;
        if (config.users) {
            store.loadRawData(config.users);
        } else {
            switch (config.source) {
                case 'battle':
                    var mySide = me.getUser().getBattleSide(),
                        targetSide = (mySide == config.side) ? 'allies' : 'enemies';
                    var users = Ext.Array.filter(me.application.getController('battle.BattleView')[targetSide].getRange(), function(item) {
                            var valid = true;
                            if (config.dead == item.getBattleInfo().live) {
                                valid = false;
                            }
                            return valid;
                        });
                    store.loadRecords(users);
                    break;
                default:
                    var users = me.application.getChatContactsStore().data.items;
                    store.loadRecords(users);
                    break;
            }
        }
        for (var i = 1; i < 5; i++) {
            var label = config['btn' + i];
            if (label) {
                var act = config['act' + i];
                var clientAction = {
                        text: label,
                        xtype: "textbutton",
                        cls: 'no_border',
                        margin: '3 5 0 5',
                        disabled: true
                    };
                if (Ext.isObject(act)) {
                    Ext.apply(clientAction, {
                        clientAction: act.id,
                        handler: function(button, event) {
                            var selection = button.up().down('viewpanel').getView().getSelectionModel().getSelection();
                            if (selection.length) {
                                ExGods.ClientActions.createAndInvoke({
                                    actionId: this.clientAction,
                                    selected_target: selection[0]
                                }, function() {
                                    wnd.close();
                                }, function(err) {
                                    /***/
                                    me.log('error', err);
                                });
                            }
                        }
                    });
                }
                actions.push(clientAction);
            }
        }
        wnd = Ext.widget('floatwindow', {
            id: componentId,
            autoShow: false,
            width: 360,
            height: 360,
            plugins: [
                'skindeco'
            ],
            y: 100,
            items: [
                {
                    xtype: 'usertargetwindow',
                    componentCls: config.componentCls,
                    windowTitle: config.windowTitle,
                    store: store,
                    action: config.action,
                    clientActions: actions,
                    listeners: config.listeners || [],
                    singleBtn: false,
                    searchEmptyText: config.searchEmptyText,
                    buttonCls: 'user-button no_border',
                    buttonText: config.buttonText || ExGods.getMsgByKey('apply_btn_text')
                }
            ]
        });
        ExGods.Resources.load(wnd, function() {
            wnd.show();
        });
        return wnd;
    },
    /**
     *    
     */
    getTooltipData: function(type, value) {
        var me = this,
            userInfo = Ext.getCmp('user-info'),
            data;
        value = value.split('|');
        if (userInfo) {
            if (type == 'item' && value[1] == 'user_info') {
                userInfo.user.slots().each(function(slot) {
                    slot.items().each(function(item) {
                        if (item.data.item_id == value[0]) {
                            data = {
                                item: item
                            };
                        }
                    });
                });
            } else if (type == 'slot') {
                userInfo.user.slots().each(function(slot) {
                    if (slot.data.ekey == value[0]) {
                        data = {
                            slot: slot
                        };
                    }
                });
            }
        }
        return data;
    }
});

/**
 *  .    .
 *
 *      setLayout(<layoutName>).     before<layoutName>Layout,
 *      set<layoutName>Layout    "layoutchanged".
 *
 * @author orangecat
 * @music Moby - Natural Blues
 */
Ext.define('ExGodsCore.controller.Viewport', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            error: true,
            warn: true
        },
        prefix: 'ViewportCore:'
    },
    /**
     * @cfg {Array} layouts   .
     *        before<LayoutName>Layout  set<LayoutName>Layout
     */
    layouts: [
        'main'
    ],
    /**
     * @property {String} layout   
     * @param this
     * @param {String} layout  
     */
    layout: null,
    init: function() {
        var me = this;
        //    
        Ext.Array.each(me.layouts, function(layout) {
            var beforeMethodName = 'before' + Ext.String.capitalize(layout) + 'Layout',
                setMethodName = 'set' + Ext.String.capitalize(layout) + 'Layout';
            if (!me[beforeMethodName]) {
                me[beforeMethodName] = Ext.emptyFn;
            }
            if (!me[setMethodName]) {
                me[setMethodName] = Ext.emptyFn;
            }
        });
        me.callParent();
    },
    /**
     *    
     */
    setLayout: function(layout, callback) {
        var me = this,
            methodName = 'set' + Ext.String.capitalize(layout) + 'Layout';
        if (typeof me[methodName] == 'function') {
            me[methodName](function() {
                me.layout = layout;
                me.fireEvent('layoutchanged', me, me.layout);
                if (callback) {
                    callback();
                }
            });
        } else {
            /***/
            me.log('error', '    "' + layout + '"  .');
        }
    }
});

/**
 *  
 *
 * @author Viatluhin Dmitry
 */
Ext.define('ExGods.view.LogOutDialog', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.logoutdialog',
    /**
     * @cfg {String} message  
     */
    message: '',
    /**
     * @cfg {Array} buttons  
     */
    buttons: null,
    minWidth: 250,
    plugins: [
        'skindeco'
    ],
    closable: false,
    y: 260,
    //     
    padding: '0 0 12 0',
    initComponent: function() {
        var me = this;
        Ext.apply(me, {
            autoShow: true,
            items: [
                {
                    xtype: 'panel',
                    tpl: new Ext.Template(me.message),
                    data: {
                        time_to_end: me.time_to_end
                    },
                    plugins: [
                        'paperdeco'
                    ],
                    padding: '20 10 30 10',
                    width: 500,
                    margin: '0 0 -15 0'
                }
            ],
            bodyStyle: 'text-align: center; line-height: 18px; overflow: visible;',
            buttonAlign: 'center',
            buttons: {
                defaults: {
                    xtype: 'textbutton',
                    cls: 'in_one_row double_text_btn',
                    minWidth: 190
                },
                items: me.buttons
            }
        });
        me.callParent();
    }
});

/**
 *   .
 *
 *   clicklink -      
 */
Ext.define('ExGods.view.battle_new.Header', {
    extend: Ext.Component,
    alias: 'widget.battle_header',
    timerValue: 0,
    initComponent: function() {
        var me = this;
        me.html = '<a class="btn-battle selected" style="background-image: url(' + ExGods.ref('images|battle_images').image['fight_btn_text'] + ')"></a>' + '<a class="btn-group" style="background-image: url(' + ExGods.ref('images|battle_images').image['group_btn_text'] + ')"></a>' + '<div class="timer"></div>';
        me.callParent(arguments);
    },
    setBlocked: function(blocked) {
        var me = this,
            _turnTimer = function() {
                var blockedEl;
                if (me.getEl()) {
                    blockedEl = me.getEl().down('.blocked');
                    if (blockedEl) {
                        blockedEl.applyStyles({
                            'background-image': 'none'
                        });
                        ExGods.helpme.shine(blockedEl, 'blocked-timer', 9, -54, ExGods.ref('constants|bat_anim_header_timer_spf').value, function() {
                            blockedEl.applyStyles({
                                'background-image': 'url(' + IMAGE_URL + 'battle/watch_for_compile.png)'
                            });
                            setTimeout(function() {
                                if (me.blocked) {
                                    _turnTimer();
                                }
                            }, ExGods.ref('constants|bat_anim_header_timer_pause').value);
                        });
                    }
                }
            };
        if (!me.died) {
            if (me.blocked !== blocked) {
                me.blocked = blocked;
                if (me.rendered) {
                    if (me.blocked) {
                        me.getEl().down('.timer').setHTML('<div class="blocked"></div>');
                        _turnTimer();
                    } else {
                        me.updateTimer();
                    }
                }
            }
        }
    },
    setDied: function() {
        var me = this;
        me.died = true;
        me.blocked = true;
        me.getEl().down('.timer').setHTML('');
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.getEl().on('click', me.onLinkClick, me, {
            delegate: 'a'
        });
    },
    /**
     *    time 
     */
    setTime: function(time) {
        var me = this;
        me.timerValue = time;
        if (!me.blocked) {
            if (me.timerValue > 0) {
                me.updateTimer();
            } else {
                me.setBlocked(true);
            }
        }
    },
    updateTimer: function() {
        var me = this,
            el = me.getEl().down('.timer');
        el.setHTML(ExGods.util.Sprite.printSprite(me.timerValue, false, {
            width: 18,
            height: 38,
            horizontal: false
        }));
    },
    onLinkClick: function(e, el) {
        var me = this;
        el = Ext.get(el);
        if (!el.hasCls('selected')) {
            me.getEl().select('a').removeCls('selected');
            el.addCls('selected');
            if (el.hasCls('btn-battle')) {
                me.getEl().select('.timer').show();
                me.fireEvent('showbattle');
            } else {
                me.getEl().select('.timer').hide();
                me.fireEvent('showgroup');
            }
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.battle_new.Container', {
    extend: Ext.container.Container,
    alias: 'widget.battlecontainer',
    id: 'battle-container',
    layout: 'card',
    padding: 0,
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [],
            imgs;
        imgs = ExGods.ref('images|battle_images').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        imgs = ExGods.ref('images|combat_bgs').image;
        for (var it in imgs) {
            arr_images.push(imgs[it]);
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.Message', {
    extend: Ext.panel.Panel,
    alias: 'widget.message',
    closable: true,
    floating: true,
    shadow: false,
    width: 458,
    height: 74,
    bodyPadding: '0 25 0 25',
    y: 23,
    initComponent: function() {
        var me = this;
        if (/<br/.test(me.html)) {
            me.bodyStyle = {
                margin: '-5px'
            };
        }
        me.callParent();
    }
});

/**
 *     
 */
Ext.define('ExGods.view.location.Info', {
    alias: 'widget.locationinfo',
    extend: Ext.Component,
    renderTpl: [
        '<span id="location-info-world">{world}</span>',
        '<span id="location-info-location">{location}</span>'
    ],
    childEls: [
        'world',
        'location'
    ],
    id: 'location-info',
    layout: 'absolute',
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.location = me.el.down('#location-info-location');
        me.world = me.el.down('#location-info-world');
    },
    update: function(renderData) {
        var me = this;
        me.location.update(renderData.location);
        me.world.update(renderData.world);
    }
});

/**
 *          
 * (  )    .   
 *         .
 */
Ext.define('ExGods.view.user.Finance', {
    extend: Ext.Component,
    alias: 'widget.userfinance',
    id: 'user-finance',
    /**
     * @private
     * @property {String} gameCur
     *   
     */
    /**
     * @private
     * @property {String} crystalCur
     *  ,    
     */
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    animating: {},
    animData: {
        gold: {
            images: [
                'user/add_coins.png'
            ],
            frames: [
                [
                    0,
                    0,
                    26,
                    25,
                    0,
                    -66.2,
                    0.5499999999999998
                ],
                [
                    26,
                    0,
                    38,
                    25,
                    0,
                    -66.2,
                    0.5499999999999998
                ],
                [
                    64,
                    0,
                    52,
                    25,
                    0,
                    -65.2,
                    0.5499999999999998
                ],
                [
                    116,
                    0,
                    65,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ],
                [
                    0,
                    25,
                    78,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ],
                [
                    78,
                    25,
                    92,
                    26,
                    0,
                    -63.2,
                    1.5499999999999998
                ],
                [
                    0,
                    51,
                    97,
                    27,
                    0,
                    -62.2,
                    2.55
                ],
                [
                    97,
                    51,
                    103,
                    27,
                    0,
                    -61.2,
                    2.55
                ],
                [
                    0,
                    78,
                    107,
                    28,
                    0,
                    -61.2,
                    3.55
                ],
                [
                    107,
                    78,
                    113,
                    29,
                    0,
                    -60.2,
                    4.55
                ],
                [
                    0,
                    107,
                    114,
                    29,
                    0,
                    -59.2,
                    4.55
                ],
                [
                    114,
                    107,
                    115,
                    30,
                    0,
                    -58.2,
                    5.55
                ],
                [
                    0,
                    137,
                    114,
                    29,
                    0,
                    -59.2,
                    4.55
                ],
                [
                    114,
                    137,
                    113,
                    29,
                    0,
                    -60.2,
                    4.55
                ],
                [
                    0,
                    166,
                    113,
                    28,
                    0,
                    -60.2,
                    3.55
                ],
                [
                    113,
                    166,
                    112,
                    28,
                    0,
                    -61.2,
                    3.55
                ],
                [
                    0,
                    194,
                    113,
                    28,
                    0,
                    -60.2,
                    2.55
                ],
                [
                    113,
                    194,
                    113,
                    28,
                    0,
                    -60.2,
                    2.55
                ],
                [
                    0,
                    222,
                    113,
                    27,
                    0,
                    -60.2,
                    1.5499999999999998
                ],
                [
                    113,
                    222,
                    112,
                    25,
                    0,
                    -61.2,
                    0.5499999999999998
                ],
                [
                    0,
                    249,
                    112,
                    25,
                    0,
                    -61.2,
                    0.5499999999999998
                ],
                [
                    112,
                    249,
                    112,
                    25,
                    0,
                    -61.2,
                    0.5499999999999998
                ],
                [
                    0,
                    274,
                    111,
                    25,
                    0,
                    -62.2,
                    0.5499999999999998
                ],
                [
                    111,
                    274,
                    111,
                    25,
                    0,
                    -62.2,
                    0.5499999999999998
                ],
                [
                    0,
                    299,
                    110,
                    25,
                    0,
                    -63.2,
                    0.5499999999999998
                ],
                [
                    110,
                    299,
                    110,
                    25,
                    0,
                    -63.2,
                    0.5499999999999998
                ],
                [
                    0,
                    324,
                    110,
                    25,
                    0,
                    -63.2,
                    0.5499999999999998
                ],
                [
                    110,
                    324,
                    109,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ],
                [
                    0,
                    349,
                    109,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ],
                [
                    109,
                    349,
                    109,
                    25,
                    0,
                    -64.2,
                    0.5499999999999998
                ]
            ]
        },
        crystal: {
            images: [
                'user/crystall_add.png'
            ],
            frames: [
                [
                    0,
                    0,
                    17,
                    13,
                    0,
                    -60.6,
                    -26.05
                ],
                [
                    17,
                    0,
                    22,
                    14,
                    0,
                    -59.6,
                    -26.05
                ],
                [
                    39,
                    0,
                    29,
                    15,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    68,
                    0,
                    29,
                    18,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    97,
                    0,
                    34,
                    23,
                    0,
                    -57.6,
                    -26.05
                ],
                [
                    131,
                    0,
                    37,
                    25,
                    0,
                    -56.6,
                    -26.05
                ],
                [
                    168,
                    0,
                    48,
                    26,
                    0,
                    -55.6,
                    -25.05
                ],
                [
                    0,
                    26,
                    61,
                    27,
                    0,
                    -55.6,
                    -24.05
                ],
                [
                    61,
                    26,
                    75,
                    27,
                    0,
                    -54.6,
                    -24.05
                ],
                [
                    136,
                    26,
                    89,
                    28,
                    0,
                    -53.6,
                    -23.05
                ],
                [
                    0,
                    54,
                    101,
                    29,
                    0,
                    -53.6,
                    -22.05
                ],
                [
                    101,
                    54,
                    107,
                    29,
                    0,
                    -52.6,
                    -22.05
                ],
                [
                    0,
                    83,
                    111,
                    29,
                    0,
                    -52.6,
                    -22.05
                ],
                [
                    111,
                    83,
                    113,
                    28,
                    0,
                    -53.6,
                    -23.05
                ],
                [
                    0,
                    112,
                    118,
                    28,
                    0,
                    -54.6,
                    -23.05
                ],
                [
                    118,
                    112,
                    118,
                    27,
                    0,
                    -54.6,
                    -24.05
                ],
                [
                    0,
                    140,
                    117,
                    27,
                    0,
                    -55.6,
                    -24.05
                ],
                [
                    117,
                    140,
                    117,
                    26,
                    0,
                    -55.6,
                    -25.05
                ],
                [
                    0,
                    167,
                    116,
                    25,
                    0,
                    -56.6,
                    -26.05
                ],
                [
                    116,
                    167,
                    115,
                    25,
                    0,
                    -57.6,
                    -26.05
                ],
                [
                    0,
                    192,
                    115,
                    25,
                    0,
                    -57.6,
                    -26.05
                ],
                [
                    115,
                    192,
                    114,
                    25,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    0,
                    217,
                    113,
                    25,
                    0,
                    -59.6,
                    -26.05
                ],
                [
                    113,
                    217,
                    113,
                    25,
                    0,
                    -59.6,
                    -26.05
                ],
                [
                    0,
                    242,
                    112,
                    25,
                    0,
                    -60.6,
                    -26.05
                ],
                [
                    112,
                    242,
                    112,
                    25,
                    0,
                    -60.6,
                    -26.05
                ],
                [
                    0,
                    267,
                    113,
                    25,
                    0,
                    -59.6,
                    -26.05
                ],
                [
                    113,
                    267,
                    114,
                    25,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    0,
                    292,
                    114,
                    25,
                    0,
                    -58.6,
                    -26.05
                ],
                [
                    114,
                    292,
                    115,
                    25,
                    0,
                    -57.6,
                    -26.05
                ],
                [
                    0,
                    317,
                    116,
                    25,
                    0,
                    -56.6,
                    -26.05
                ],
                [
                    116,
                    317,
                    117,
                    26,
                    0,
                    -55.6,
                    -25.05
                ],
                [
                    0,
                    343,
                    117,
                    27,
                    0,
                    -55.6,
                    -24.05
                ],
                [
                    117,
                    343,
                    118,
                    27,
                    0,
                    -54.6,
                    -24.05
                ],
                [
                    0,
                    370,
                    119,
                    28,
                    0,
                    -53.6,
                    -23.05
                ]
            ]
        }
    },
    initComponent: function() {
        var me = this,
            user = me.user,
            money = user.get('money'),
            constants = ExGods.references.get('constants'),
            gameCur = constants.get('currency').value,
            crystalCur = 'crystal';
        me.gameCur = gameCur;
        me.crystalCur = crystalCur;
        if (user) {
            me.childEls = [
                'icon',
                gameCur,
                gameCur + 'Btn',
                crystalCur,
                crystalCur + 'Btn'
            ];
            me.renderTpl = [
                '<span id="user-finance-icon"></span>',
                '<div id="frame-anim-' + gameCur + '"></div>',
                '<span class="money money-1" id="{id}-' + gameCur + '">{' + gameCur + '}</span>',
                '<input class="add-btn add-btn-1" id="{id}-' + gameCur + 'Btn" type="button" />',
                '<div id="frame-anim-' + crystalCur + '"></div>',
                '<span class="money money-2" id="{id}-' + crystalCur + '">{' + crystalCur + '}<div class="frame-anim-container"></div></span>',
                '<input class="add-btn add-btn-2" id="{id}-' + crystalCur + 'Btn" type="button" />'
            ];
            me.renderData = {};
            me.renderData[gameCur] = Ext.util.Format.number(money[gameCur], '0,0');
            me.renderData[crystalCur] = Ext.util.Format.number(money[crystalCur], '0,0');
        }
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        // migration 4.1.2 -> 5.1.1 fix
        me.icon = me.el.down('#' + me.id + '-icon');
        me[me.gameCur] = me.el.down('#' + me.id + '-' + me.gameCur);
        me[me.gameCur + 'Btn'] = me.el.down('#' + me.id + '-' + me.gameCur + 'Btn');
        me[me.crystalCur] = me.el.down('#' + me.id + '-' + me.crystalCur);
        me[me.crystalCur + 'Btn'] = me.el.down('#' + me.id + '-' + me.crystalCur + 'Btn');
        /**
         * @event iconclick
         *      
         */
        me.mon(me.icon, 'click', Ext.Function.pass(me.fireEvent, [
            'iconclick'
        ], me));
        /**
         * @event adddefaultcurrency
         *   "+"   
         */
        me.mon(me[me.gameCur + 'Btn'], 'click', Ext.Function.pass(me.fireEvent, [
            'adddefaultcurrency'
        ], me));
        /**
         * @event addrealcurrency
         *   "+"   
         */
        me.mon(me[me.crystalCur + 'Btn'], 'click', Ext.Function.pass(me.fireEvent, [
            'addrealcurrency'
        ], me));
    },
    /**
     * @private
     *    
     *
     * @param {Number} newValue
     * @param {Number} oldValue
     * @param {Ext.data.Model} record
     * @param {String} key    
     */
    updateMoney: function(newValue, oldValue, record, key) {
        var me = this,
            user = me.user,
            animData = me.animData[key],
            l = animData.frames.length,
            color;
        if (newValue - oldValue > 0) {
            me.animating[key] = true;
            document.getElementById('frame-anim-' + key).style.display = 'block';
            var spriteSheet = Ext.create('ExGods.view.FramesAnim', {
                    images: animData.images,
                    frames: animData.frames,
                    renderTo: 'frame-anim-' + key,
                    onProgress: function(index) {
                        me[key].update(Ext.util.Format.number(Math.floor(oldValue + (user.get('money')[key] - oldValue) * index / l), '0,0'));
                    },
                    onFinish: function() {
                        me[key].update(Ext.util.Format.number(user.get('money')[key], '0,0'));
                        var dom = document.getElementById('frame-anim-' + key);
                        if (dom)  {
                            dom.style.display = 'none';
                        }
                        
                        me.animating[key] = false;
                    }
                });
            spriteSheet.start();
        } else {
            me[key].update(Ext.util.Format.number(user.get('money')[key], '0,0'));
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            arr_images = [];
        for (var it in me.animData) {
            arr_images = arr_images.concat(me.animData[it].images);
        }
        return {
            images: [
                IMAGE_URL + 'user/add_coins.png',
                IMAGE_URL + 'user/crystall_add.png',
                IMAGE_URL + 'user-finance-icon.jpg',
                IMAGE_URL + 'user-finance-add.jpg',
                IMAGE_URL + 'panel_user.png',
                IMAGE_URL + 'panel_user_combo.png',
                IMAGE_URL + 'panel_finances.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.location.Container', {
    extend: Ext.panel.Panel,
    alias: 'widget.locationcontainer',
    /**
     * @cfg user 
     */
    user: {},
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'locationview',
                user: me.user
            }
        ];
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this,
            images = [];
        if (me.user.location && me.user.location.data) {
            images.push(me.user.location.data.blob.image);
            if (me.user.location.data.blob.objects) {
                Ext.Array.each(me.user.location.data.blob.objects, function(obj) {
                    if (obj.interactive.view == "button" && /^img\:/.test(obj.interactive.params_display.label)) {
                        images.push(obj.interactive.params_display.label.replace('img:', ''));
                    } else if (obj.interactive.view == "image") {
                        images.push(obj.interactive.params_display.image);
                    } else if (obj.interactive.view == "component") {}
                    //
                    images.push(obj.interactive.image_mask);
                });
            }
        }
        return {
            images: images
        };
    }
});

/**
 *   ,     textbutton
 */
Ext.define('ExGods.view.Loader', {
    extend: Ext.Component,
    alias: 'widget.loader',
    width: 840,
    height: 410,
    y: 8,
    x: 10,
    style: {
        backgroundColor: 'black',
        backgroundRepeat: 'no-repeat',
        opacity: 0,
        zIndex: 301,
        position: 'absolute'
    },
    hidden: true,
    /**
     *    
     * options: img,html,duration
     */
    addLoader: function(callback, options) {
        if (!options)  {
            options = {};
        }
        
        var me = this,
            duration = (options && options.duration) ? options.duration : parseInt(ExGods.ref('constants|location_loader_duration').value),
            timeout = options.timeout || ExGods.ref('constants|location_loader_spinner_delay').value,
            world = ExGods.app.getLocationController().service.data.location.world,
            image = ExGods.ref('images|location_loader').image[world],
            spinnerTop;
        if (me.isVisible()) {
            if (callback) {
                setTimeout(callback, new Date() - me.maskSetTime + duration);
            }
            //    ,       
            return;
        }
        
        if (options.img === undefined) {
            options.img = image;
            spinnerTop = '193px !important';
        }
        options.img = options.img.indexOf('http') == -1 ? IMAGE_URL + options.img : options.img;
        me.el.dom.style.backgroundImage = 'url(' + options.img + ')';
        me.el.dom.innerHTML = options.html || '';
        me.loaderOptions = options;
        me.show();
        me.animating = true;
        me.el.animate({
            duration: duration,
            to: {
                opacity: 1
            },
            callback: function() {
                me.animating = false;
                if (callback)  {
                    callback();
                }
                
            }
        });
        me.spinnerTimeout = setTimeout(me.addSpinner.bind(me, spinnerTop), timeout);
        me.maskSetTime = new Date();
    },
    /**
     *    
     * options: img,html,duration
     */
    addLoadRemover: function(callback, options) {
        if (!options)  {
            options = {};
        }
        
        var me = this;
        Ext.applyIf(options, me.loaderOptions);
        var duration = (options && options.duration) ? options.duration : parseInt(ExGods.ref('constants|location_loader_duration').value);
        if (me.removing) {
            if (callback)  {
                callback();
            }
            
            return;
        }
        
        me.removing = true;
        clearTimeout(me.spinnerTimeout);
        me.removeSpinner();
        me.el.animate({
            duration: duration,
            to: {
                opacity: 0
            },
            callback: function() {
                me.removing = false;
                me.hide();
                me.fireEvent('loader_removed');
                if (callback)  {
                    callback();
                }
                
            }
        });
    },
    /**
     *   addLoader  addLoadRemover,   -
     * options: img,html,duration
     */
    loadAndRemove: function(callback, options) {
        var me = this;
        me.addLoader(function() {
            if (callback)  {
                callback();
            }
            
            me.addLoadRemover();
        }, options);
    },
    addSpinner: function(top) {
        var me = this,
            spriteY = 0;
        me.el.mask('', 'new-mask-loading').addCls('global-mask');
        var el = me.el.down('.new-mask-loading');
        setTimeout(function() {
            if (top) {
                el.dom.setAttribute('style', 'top:' + top);
                setTimeout(function() {
                    if (el.dom)  {
                        el.dom.style.opacity = 1;
                    }
                    
                }, 500);
            } else {
                el.dom.style.opacity = 1;
            }
            me.blockInterval = setInterval(function() {
                if (el.dom) {
                    spriteY -= el.getHeight();
                    if (spriteY <= -3445)  {
                        spriteY = 0;
                    }
                    
                    el.dom.style.backgroundPosition = '0 ' + spriteY + 'px';
                } else {
                    clearInterval(me.blockInterval);
                }
            }, 42);
        }, 0);
    },
    removeSpinner: function() {
        clearInterval(this.blockInterval);
        this.el.unmask();
    },
    getResources: function() {
        var me = this,
            images = [
                IMAGE_URL + 'loader_waiting.png'
            ];
        Ext.Object.each(ExGods.ref('images|location_loader').image, function(k, v) {
            images.push(v);
        });
        return {
            images: images
        };
    }
});

/**
 *     
 */
Ext.define('ExGods.view.Window1', {
    extend: Ext.panel.Panel,
    alias: 'widget.window1',
    layout: 'fit',
    layer: 'layer-over1',
    animating: false,
    closable: false,
    autoShow: true,
    width: 860,
    height: 430,
    y: 0,
    x: 0,
    plugins: [
        'skindeco'
    ]
});

/**
 *   
 */
Ext.define('ExGods.view.Window2', {
    extend: Ext.panel.Panel,
    alias: 'widget.window2',
    layout: 'fit',
    closable: true,
    layer: 'layer-over2',
    width: 780,
    height: 430,
    y: 0,
    x: 40,
    plugins: [
        'skindeco'
    ],
    autoShow: true
});

/**
 *  .     .
 */
Ext.define('ExGods.view.FloatWindow', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.floatwindow',
    cls: 'float-window',
    y: 260,
    width: 320,
    height: 155,
    closeAction: 'destroy',
    toFrontOnShow: true,
    bodyPadding: 0,
    layout: 'fit',
    title: '',
    autoShow: true
});

/**
 *     .
 *         .
 */
Ext.define('ExGods.controller.Viewport', {
    extend: ExGodsCore.controller.Viewport,
    views: [
        'CommonWindow',
        'Message',
        'skin.TabPanel',
        'TextButton',
        'Window1',
        'Window2',
        'FloatWindow',
        'user.Finance',
        'battle_new.Header',
        'LogOutDialog',
        'location.Container',
        'location.Info',
        'Loader',
        'battle_new.Container'
    ],
    layouts: [
        'main',
        'battle'
    ],
    refs: [
        {
            /**
         * @method getCenter
         *     
         * @return {Ext.container.Container}
         */
            ref: 'center',
            selector: '#center'
        },
        {
            /**
         * @method getBottom
         *     
         * @return {Ext.container.Container}
         */
            ref: 'bottom',
            selector: '#bottom'
        },
        {
            /**
         * @method getHeaderCenterContainer          
         * @return {Ext.container.Container}
         */
            ref: 'headerCenterContainer',
            selector: '#header-center'
        },
        {
            /**
         * @method getHeaderRight
         *       
         * @return {Ext.container.Container}
         */
            ref: 'headerRight',
            selector: '#header-right'
        },
        {
            /**
         * @method getMessage
         *    
         * @return {ExGods.view.ErrorReport}
         */
            ref: 'message',
            selector: '#message'
        },
        {
            ref: 'mainMenu',
            selector: '#mainmenu'
        },
        {
            ref: 'newsListCmp',
            selector: '#game-news-list'
        },
        {
            ref: 'viewportView',
            selector: '#viewport'
        },
        {
            ref: 'announcmentsView',
            selector: '#announcments-view'
        },
        {
            ref: 'chatContainer',
            selector: '#chat-container'
        },
        {
            ref: 'chestsHeaderButton',
            selector: '#chests-header-button'
        },
        {
            //getToolsMenuLangSelector
            ref: 'toolsMenuLangSelector',
            selector: '#tools_menu_lang_select'
        }
    ],
    /**
     * @property {ExGods.model.User} user
     * @inheritdoc ExGods.app#user
     */
    /**
     * @property {Boolean} gameShown
     */
    gameShown: false,
    tooltips: [
        'text',
        'item',
        'proto_item',
        'ingredient',
        'currency',
        'timed'
    ],
    init: function(app) {
        var me = this;
        me.user = app.user;
        me.listen({
            component: {
                '#chat-container': {
                    render: function(panel) {
                        panel.body.insertHtml('beforeEnd', '<div class="chat-deco chat-deco-tl"></div>' + '<div class="chat-deco chat-deco-tr"></div>');
                    }
                },
                '#chat-toolbar': {
                    render: function(bottom) {
                        bottom.getEl().insertHtml('beforeEnd', '<img alt="" height="4" id="splitter-chat-contacts-bottom" src="' + IMAGE_URL + 'chat-splitter-contacts-bottom.png" width="39" />');
                    }
                },
                'systemmenu button': {
                    click: me.onSystemMenuButtonClick
                },
                'window1': {
                    beforeshow: me.closeAllWindows,
                    beforeclose: me.onWindow1BeforeClose
                },
                'window2': {
                    beforeclose: me.onWindow2BeforeClose
                },
                'mainmenubutton': {
                    click: me.onMenuButtonClick
                },
                '#announcments-view': {
                    viewupdate: me.refreshViewportSize
                },
                '#chat-container': {
                    hide: me.onChatHide,
                    show: me.onChatShow
                },
                '#viewport': {
                    afterrender: me.onAfterViewportRendered
                },
                '#center': {
                    show: me.onCenterShow
                }
            }
        });
        app.on({
            logmessage: me.onLogMessage,
            gamestarted: me.onGameStarted,
            scope: me
        });
        Ext.getDoc().on({
            keyup: function(e) {
                if (e.altKey && e.ctrlKey && e.getCharCode() == e.Z) {
                    this.doFullscreen();
                }
            },
            scope: me
        });
        Ext.on('resize', me.refreshViewportSize, me);
        Ext.getBody().on('click', function(e, t) {
            var el = Ext.fly(t),
                parentDom = t.parentNode,
                proto;
            //    " "
            if (el.hasCls('info-icon')) {
                ExGods.app.fireEvent('nickinfoclick', el.parent('.userinfo').getAttribute('data-uname'));
            }
            //  
            // parentDom.className.indexOf  SVG 
            if (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('ability') != -1) {
                var protoId = parentDom.getAttribute('data-ability_id');
                /*         */
                ExGods.app.getAbilityPrototypesStore().loadNew(protoId, function() {
                    proto = this.data.getByKey(protoId);
                    if (proto) {
                        Ext.widget('commondetailswindow', {
                            itemElement: el.dom,
                            data: {
                                label: proto.data.label,
                                description: proto.data.description,
                                image: IMAGE_URL + proto.data.images.a
                            }
                        });
                    }
                });
            }
            //   
            if (el.hasCls('turn-link') || (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('turn-link') != -1)) {
                var turn = ExGods.ref('battle_turn').get(el.getAttribute('data-turn_name') || parentDom.getAttribute('data-turn_name'));
                Ext.widget('commondetailswindow', {
                    itemElement: el.dom,
                    data: {
                        label: turn.label,
                        description: turn.desc.desc,
                        image: IMAGE_URL + turn.desc.images.active
                    }
                });
            }
            //   
            if (el.hasCls('prep-link') || (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('prep-link') != -1)) {
                var prep = ExGods.ref('battle_prep').get(el.getAttribute('data-prep_name') || parentDom.getAttribute('data-prep_name'));
                Ext.widget('commondetailswindow', {
                    itemElement: el.dom,
                    data: {
                        label: prep.label,
                        description: prep.desc.desc,
                        image: IMAGE_URL + prep.desc.images.active
                    }
                });
            }
            //   
            if (el.hasCls('battleaction-link') || (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('battleaction-link') != -1)) {
                var battleaction = ExGods.ref('battle_actions').get(el.getAttribute('data-battleaction_id') || parentDom.getAttribute('data-battleaction_id'));
                Ext.widget('commondetailswindow', {
                    itemElement: el.dom,
                    data: {
                        label: battleaction.label,
                        description: battleaction.desc.msg,
                        image: IMAGE_URL + battleaction.desc.img
                    }
                });
            }
            //  
            if (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('feature') != -1) {
                var featureProtoId = parentDom.getAttribute('data-feature_id');
                /*         */
                ExGods.app.getFeaturePrototypesStore().loadNew(featureProtoId, function() {
                    proto = this.data.getByKey(featureProtoId);
                    if (proto) {
                        Ext.widget('commondetailswindow', {
                            itemElement: el.dom,
                            data: {
                                label: proto.data.label,
                                description: proto.data.description,
                                image: IMAGE_URL + proto.data.images.main
                            }
                        });
                    }
                });
            }
            //  
            if (parentDom && parentDom.className.indexOf && parentDom.className.indexOf('action-item') != -1) {
                var actionId = parentDom.getAttribute('data-action_id');
                proto = ExGods.ref('direct_actions|' + actionId);
                if (proto) {
                    Ext.widget('commondetailswindow', {
                        itemElement: el.dom,
                        data: {
                            label: proto.images.name,
                            description: proto.images.description,
                            image: IMAGE_URL + proto.images.simple
                        }
                    });
                }
            }
            //  
            if (el.parent('.item')) {
                var item = el.parent('.item').dom;
                if (item) {
                    if (item.getAttribute('data-proto_id')) {
                        var slot = ExGods.app.user.slots().data.getByKey(item.getAttribute('data-slot_id')),
                            user_item = slot ? slot.items().getById(Number(item.getAttribute('data-item_id'))) : null;
                        ExGods.app.fireEvent('itemclick', {
                            itemEl: item,
                            item: user_item,
                            proto_id: item.getAttribute('data-proto_id'),
                            type: user_item ? 'iteminstance' : 'item',
                            quantity: 1
                        });
                    }
                    if (item.getAttribute('data-big_stuff_type')) {
                        ExGods.app.fireEvent('itemclick', {
                            itemEl: item,
                            proto_id: item.getAttribute('data-big_stuff_id'),
                            type: item.getAttribute('data-big_stuff_type'),
                            quantity: item.getAttribute('data-big_stuff_value')
                        });
                    }
                }
            }
        });
        me.on('layoutchanged', function() {
            if (me.startGameData) {
                me.showGame();
            }
        }, me, {
            single: true
        });
        me.callParent(arguments);
    },
    onLaunch: function(app) {
        var me = this;
        if (!me.user.isChatOn()) {
            Ext.getBody().addCls('chat-off');
        }
    },
    onAfterViewportRendered: function() {
        var me = this;
        /*   */
        var locationLayer = ExGods.Layers.factory({
                id: 'location-layer',
                renderTo: 'center',
                width: 860,
                height: 430,
                layout: 'fit',
                hidden: false
            });
        var layerOver1 = ExGods.Layers.factory({
                id: 'layer-over1',
                renderTo: 'center',
                type: 'single',
                style: {
                    zIndex: '101'
                },
                hidden: true
            });
        var layerOver2 = ExGods.Layers.factory({
                id: 'layer-over2',
                renderTo: 'center',
                type: 'single',
                style: {
                    zIndex: '201'
                },
                hidden: true,
                listeners: {
                    cmp_visible: function() {
                        layerOver1.mask();
                        locationLayer.mask();
                    },
                    hide: function() {
                        layerOver1.unmask();
                        locationLayer.unmask();
                    }
                }
            });
        /**   */
        ExGods.Layers.factory({
            id: 'directions-layer',
            renderTo: 'viewport',
            type: 'stack',
            hidden: true,
            style: {
                'background-color': 'rgba(85, 85, 85, 0.15)',
                'zIndex': '10002'
            }
        });
        //     global-mask-ct.  ,    global-mask-ct 
        /** loader component */
        ExGods.loaderCt = me.loaderCt = Ext.widget('loader', {
            renderTo: 'center'
        });
        if (me.user.isBattle()) {
            me.app.getController('battle.Battle').loadStart();
        } else //        battle.BattleView
        {
            me.setLayout('main');
        }
        me.refreshViewportSize();
    },
    onGameStarted: function(data) {
        var me = this;
        me.startGameData = data;
        if (me.layout) {
            me.showGame();
        }
    },
    /**
     *   
     */
    showGame: function() {
        var me = this,
            data = me.startGameData,
            dailyBonusDialog;
        setTimeout(function() {
            exGodsLoader.finishAndDestroy(function() {
                me.getAnnouncmentsView().updateLayout();
                //     
                me.getMainMenu().updateLayout();
                me.refreshViewportSize();
                me.getChatContainer().scrollChatToBottom();
                //   
                if (data.bonus && data.bonus.login_days && data.bonus.login_days > 1) {
                    //      
                    dailyBonusDialog = ExGods.Components.factory('DIALOG_DAILY_BONUS', {
                        selectedIndex: data.bonus.login_days
                    });
                }
                //   
                if (dailyBonusDialog && !dailyBonusDialog.rendered) {
                    //   
                    dailyBonusDialog.on('close', function() {
                        me.app.getController('Direction').setDisabled(false);
                    }, me, {
                        single: true
                    });
                } else {
                    // 
                    me.app.getController('Direction').setDisabled(false);
                }
                ExGods.app.getChatConnection().on({
                    ping: me.onPing,
                    scope: me
                });
                me.gameShown = true;
                me.fireEvent('gameshown', me);
            });
        }, 200);
    },
    /**
     *   
     */
    setMainLayout: function(fireLayoutChange) {
        var me = this,
            headerCenterCt = me.getHeaderCenterContainer(),
            headerRightCt = me.getHeaderRight(),
            mainMenu = me.getMainMenu(),
            chestsButton = me.getChestsHeaderButton(),
            langSelector = me.getToolsMenuLangSelector(),
            locationHeader, lcoationContainer, userFinance, preloads;
        if (langSelector) {
            langSelector.show();
        }
        locationHeader = Ext.widget('container', {
            id: 'location-header',
            layout: 'fit',
            items: [
                {
                    xtype: 'locationinfo',
                    renderData: {
                        location: me.user.location.get('name'),
                        world: me.user.location.getWorld().get('title')
                    }
                }
            ]
        });
        userFinance = Ext.widget('userfinance', {
            user: me.user
        });
        locationContainer = Ext.widget('locationcontainer', {
            id: 'location-container',
            layout: 'fit',
            user: me.user,
            plugins: [
                'skindeco'
            ]
        });
        preloads = [
            'system-menu',
            'tools-menu',
            'tech-info',
            'quick-slots',
            mainMenu,
            locationContainer,
            ExGods.loaderCt,
            'user-finance'
        ];
        /*****/
        ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView     ');
        ExGods.Resources.loadMulti(preloads, function() {
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView  ');
            Ext.getBody().removeCls('body-battle');
            //  
            headerCenterCt.removeAll();
            headerCenterCt.add(locationHeader);
            //      
            headerRightCt.removeAll();
            headerRightCt.add(userFinance);
            //   
            ExGods.Layers.get('location-layer').clear();
            ExGods.Layers.get('location-layer').add(locationContainer);
            if (me.user.isChain()) {
                mainMenu.disableMenu([
                    'inventory'
                ]);
            } else //        
            {
                mainMenu.enableMenu();
            }
            if (chestsButton) {
                chestsButton.setDisabled(false);
            }
            /*****/
            ExGods.util.RemoteDebug.get('battle_no_finish').log('@battleView   -  ');
            fireLayoutChange();
        });
    },
    /**
     *   
     */
    setBattleLayout: function(fireLayoutChange) {
        var me = this,
            battleViewController = me.app.getController('battle.BattleView'),
            battleAnimController = me.app.getController('battle.Animation'),
            locationController = me.app.getController('Location'),
            headerCenterCt = me.getHeaderCenterContainer(),
            headerRightCt = me.getHeaderRight(),
            mainMenu = me.getMainMenu(),
            chestsButton = me.getChestsHeaderButton(),
            langSelector = me.getToolsMenuLangSelector(),
            battleHeader = Ext.getCmp('battle-header'),
            battleContainer = Ext.getCmp('battle-container'),
            enemyInfo = Ext.getCmp('battle-enemy-info'),
            preloads;
        if (langSelector) {
            langSelector.hide();
        }
        if (battleContainer)  {
            battleContainer.close();
        }
        
        if (battleHeader)  {
            battleHeader.destroy();
        }
        
        if (enemyInfo)  {
            enemyInfo.destroy();
        }
        
        battleHeader = Ext.widget('battle_header', {
            id: 'battle-header',
            autoShow: false
        });
        enemyInfo = Ext.widget('techinfo', {
            id: 'battle-enemy-info',
            enemy: true
        });
        battleContainer = Ext.widget('battlecontainer', {
            autoShow: false
        });
        preloads = [
            'system-menu',
            'tools-menu',
            'tech-info',
            'battle-enemy-info',
            'quick-slots',
            mainMenu,
            battleViewController,
            battleAnimController,
            battleContainer,
            battleHeader
        ];
        ExGods.Resources.loadMulti(preloads, function() {
            me.closeAllWindows();
            Ext.getBody().addCls('body-battle');
            //  
            headerCenterCt.removeAll();
            headerCenterCt.add(battleHeader);
            //       
            headerRightCt.removeAll();
            headerRightCt.add(enemyInfo);
            //   
            ExGods.Layers.get('location-layer').clear();
            ExGods.Layers.get('location-layer').add(battleContainer);
            mainMenu.disableMenu();
            if (chestsButton) {
                chestsButton.setDisabled(true);
            }
            fireLayoutChange();
            locationController.unmaskLocation();
        });
    },
    //        (onBattleLoadStart)
    closeAllWindows: function() {
        var me = this;
        me.closeAllFloatWindows();
        ExGods.Layers.get('layer-over1').clear();
        ExGods.Layers.get('layer-over2').clear();
    },
    closeAllFloatWindows: function() {
        var me = this,
            floates = [
                'commondetailswindow',
                'parchmentwindow'
            ];
        Ext.Array.each(floates, function(windowCls) {
            var items = Ext.ComponentQuery.query(windowCls);
            Ext.Array.each(items, function(item) {
                if (item.plugins)  {
                    item.close();
                }
                
            });
        });
    },
    /**
     * @private     
     */
    onSystemMenuButtonClick: function(button) {
        var me = this;
        if (button.action && !button.href) {
            ExGods.ClientActions.doAction(button.action, function(res) {
                if (res.error) {
                    /***/
                    me.log('error', err);
                }
            });
        }
    },
    /**
     * @private
     *     
     *
     * @param {String} message   
     */
    onLogMessage: function(message) {
        var me = this,
            win = me.getMessage();
        if (!message)  {
            return;
        }
        
        if (win) {
            clearTimeout(win.closeTimeout);
            win.el.stopAnimation();
            win.destroy();
        }
        win = Ext.widget('message', {
            id: 'message',
            autoShow: true,
            html: message,
            style: {
                background: 'url(' + IMAGE_URL + "/message/popap_messages.png)"
            }
        });
        //renderTo: 'header-center'
        //.center();
        win.el.setOpacity(0).fadeIn({
            opacity: 1,
            easing: 'easeIn',
            duration: 500
        });
        win.closeTimeout = setTimeout(function() {
            if (!win || !win.el)  {
                return;
            }
            
            win.el.stopAnimation();
            win.el.fadeOut({
                opacity: 0,
                easing: 'easeOut',
                duration: 500,
                callback: Ext.Function.bind(win.destroy, win)
            });
        }, 4000);
    },
    doFullscreen: function() {
        var me = this,
            sendFullScreenRequest = function() {
                me.request({
                    url: 'game.pl?cmd=do_full_screen'
                });
            },
            doFullscreen__ = function() {
                if (screenfull && screenfull.enabled) {
                    screenfull.toggle();
                } else if (Ext.browser.is.Safari) {
                    var fullScreenApi = {
                            supportsFullScreen: false,
                            nonNativeSupportsFullScreen: false,
                            isFullScreen: function() {
                                return false;
                            },
                            requestFullScreen: function() {},
                            cancelFullScreen: function() {},
                            fullScreenEventName: '',
                            prefix: ''
                        },
                        browserPrefixes = 'webkit moz o ms khtml'.split(' ');
                    // check for native support
                    if (typeof document.cancelFullScreen != 'undefined') {
                        fullScreenApi.supportsFullScreen = true;
                    } else {
                        // check for fullscreen support by vendor prefix
                        for (var i = 0,
                            il = browserPrefixes.length; i < il; i++) {
                            fullScreenApi.prefix = browserPrefixes[i];
                            if (typeof document[fullScreenApi.prefix + 'CancelFullScreen'] != 'undefined') {
                                fullScreenApi.supportsFullScreen = true;
                                break;
                            }
                        }
                    }
                    // update methods to do something useful
                    if (fullScreenApi.supportsFullScreen) {
                        fullScreenApi.fullScreenEventName = fullScreenApi.prefix + 'fullscreenchange';
                        fullScreenApi.isFullScreen = function() {
                            switch (this.prefix) {
                                case '':
                                    return document.fullScreen;
                                case 'webkit':
                                    return document.webkitIsFullScreen;
                                default:
                                    return document[this.prefix + 'FullScreen'];
                            }
                        };
                        fullScreenApi.requestFullScreen = function(el) {
                            return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();
                        };
                        fullScreenApi.cancelFullScreen = function(el) {
                            return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();
                        };
                    }
                    // export api
                    me.fullScreenApi = fullScreenApi;
                    if (me.fullScreenApi.isFullScreen()) {
                        me.fullScreenApi.cancelFullScreen(document.body);
                    } else {
                        me.fullScreenApi.requestFullScreen(document.body);
                    }
                    var isflscr = me.fullScreenApi.isFullScreen();
                    if (!me.screenfull_SAFARI) {
                        me.screenfull_SAFARI = {};
                    }
                    me.screenfull_SAFARI.isFullscreen = isflscr;
                } else if (Ext.browser.is.IE11) {
                    if (!document.inFullScreen) {
                        document.inFullScreen = false;
                    }
                    function makeFullScreen(divObj) {
                        if (divObj.requestFullscreen) {
                            divObj.requestFullscreen();
                        } else if (divObj.msRequestFullscreen) {
                            document.addEventListener("MSFullscreenError", function(evt) {
                                console.log("full screen error has occured " + evt.target);
                            }, true);
                            divObj.msRequestFullscreen();
                        } else if (divObj.mozRequestFullScreen) {
                            divObj.mozRequestFullScreen();
                        } else if (divObj.webkitRequestFullscreen) {
                            divObj.webkitRequestFullscreen();
                        } else {
                            console.log("Fullscreen API is not supported");
                        }
                        document.inFullScreen = true;
                    }
                    function reset() {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.msExitFullscreen) {
                            document.msExitFullscreen();
                        } else if (document.mozCancelFullScreen) {
                            document.mozCancelFullScreen();
                        } else if (document.webkitCancelFullScreen) {
                            document.webkitCancelFullScreen();
                        }
                        document.inFullScreen = false;
                        return;
                    }
                    if (document.inFullScreen && document.inFullScreen == true) {
                        reset(document.body);
                    } else {
                        makeFullScreen(document.body);
                    }
                    screenfull = screenfull || {};
                    screenfull.isFullscreen = document.inFullScreen;
                } else if (Ext.browser.is.IE) {
                    //    IE (  10)       
                    screenfull = screenfull || {};
                    var wscript = new ActiveXObject("WScript.Shell");
                    if (wscript !== null) {
                        screenfull.isFullscreen = !screenfull.isFullscreen;
                        wscript.SendKeys("{F11}");
                    }
                }
            };
        if ((!screenfull || !screenfull.isFullscreen) || (Ext.browser.is.Safari && (!me.screenfull_SAFARI || !me.screenfull_SAFARI.isFullscreen))) {
            sendFullScreenRequest();
        }
        doFullscreen__();
    },
    onWindow1BeforeClose: function() {
        this.closeAllFloatWindows();
    },
    onWindow2BeforeClose: function() {
        this.closeAllFloatWindows();
    },
    /**
     * @private     
     */
    onMenuButtonClick: function(button) {
        var me = this;
        if (button.action && !button.el.hasCls('x-btn-disabled') && !button.el.hasCls('x-btn-blocked')) {
            ExGods.ClientActions.createAndInvoke({
                src: 'menu',
                actionId: button.action
            }, null, function(err) {
                /***/
                me.log('error', err);
            });
        }
    },
    onPing: function(data) {
        var me = this;
        if (data.validate_key && data.validate_to) {
            me.showLogOutDialog(data);
        }
    },
    showLogOutDialog: function(data) {
        var me = this,
            confirmBtnText = ExGods.ref('message_client|button_logout_confirm'),
            abortBtnText = ExGods.ref('message_client|button_logout_abort'),
            logoutFn = function() {
                if (isSocialApp) {
                    window.location.href = '/logout-social.html';
                } else {
                    window.location.href = '/reg.pl?cmd=exit';
                }
                dialog.destroy();
            },
            abortFn = function() {
                clearInterval(intervalId);
                me.request({
                    url: '/game.pl?cmd=afk_validate&key=' + data.validate_key
                });
                dialog.destroy();
            };
        if (Math.random() > 0.5) {
            var buttons = [
                    {
                        text: confirmBtnText,
                        handler: logoutFn
                    },
                    {
                        text: abortBtnText,
                        handler: abortFn
                    }
                ];
        } else {
            var buttons = [
                    {
                        text: abortBtnText,
                        handler: abortFn
                    },
                    {
                        text: confirmBtnText,
                        handler: logoutFn
                    }
                ];
        }
        var dialog = Ext.widget('logoutdialog', {
                message: ExGods.ref('message_client|before_log_out_message'),
                time_to_end: Number(data.validate_to) + 1,
                buttons: buttons,
                minWidth: 510,
                logOutWindow: true,
                autoShow: false,
                listeners: {
                    close: abortFn
                }
            });
        ExGods.Resources.load(dialog, function() {
            dialog.show();
        });
        var intervalId = setInterval(function() {
                if (data.validate_to >= 1) {
                    dialog.items.items[0].update({
                        time_to_end: data.validate_to--
                    });
                } else {
                    dialog.items.items[0].update({
                        time_to_end: 0
                    });
                    ExGods.app.getChatConnection().ping();
                }
            }, 1000);
    },
    refreshViewportSize: function() {
        var me = this,
            viewportView = me.getViewportView(),
            chatContainer = me.getChatContainer(),
            centerContainer = me.getCenter(),
            headerHeight = 95,
            //  
            centerHeight = 430,
            //   
            screenHeight = Ext.getBody().parent().getHeight(),
            announceHeight = me.getAnnouncmentsView().getHeight() || me.getAnnouncmentsView().minHeight,
            chatHeight,
            socialCtrl = me.app.getSocialController();
        if (me.user.isChatOn()) {
            chatHeight = Math.min(Math.max(screenHeight - headerHeight - centerHeight, ExGods.ref('constants|chat_min_height').value), ExGods.ref('constants|chat_max_height').value);
            if (centerContainer.isVisible()) {
                chatContainer.setHeight(chatHeight);
            } else {
                chatContainer.setHeight(chatHeight + centerHeight);
            }
        } else {
            chatHeight = 56;
        }
        viewportView.setHeight(Math.max(window.innerHeight, headerHeight + centerHeight + chatHeight + announceHeight));
        //     
        if (socialCtrl && socialCtrl.initialized) {
            socialCtrl.setSize(viewportView.getWidth(), viewportView.getHeight());
        }
    },
    onChatShow: function() {
        var me = this;
        me.refreshViewportSize();
        Ext.getBody().removeCls('chat-off');
    },
    onChatHide: function() {
        var me = this,
            centerContainer = me.getCenter();
        if (!centerContainer.isVisible()) {
            centerContainer.setVisible(true);
        }
        me.refreshViewportSize();
        Ext.getBody().addCls('chat-off');
    },
    // /    
    toggleChatExpand: function() {
        var me = this,
            centerContainer = me.getCenter();
        centerContainer.setVisible(!centerContainer.isVisible());
        me.refreshViewportSize();
    },
    onCenterShow: function() {
        ExGods.Layers.get('layer-over2').updateLayout();
    },
    getTooltipData: function(type, value) {
        var me = this,
            data;
        value = value.split('|');
        if (value[1] && value[1] != 'use')  {
            return;
        }
        
        if (type == 'item') {
            me.user.slots().each(function(slot) {
                slot.items().each(function(item) {
                    if (item.data.item_id == value[0]) {
                        data = {
                            item: item
                        };
                        if (value[1]) {
                            data.tooltipText = ExGods.getMsgByKey('tooltip_text');
                        }
                    }
                });
            });
        } else if (type == 'proto_item') {
            data = {
                proto: ExGods.app.getItemPrototypesStore().data.getByKey(value[0])
            };
            if (value[1]) {
                data.tooltipText = ExGods.getMsgByKey('tooltip_text');
            }
        } else if (type == 'ingredient') {
            ExGods.ref('ingredients').each(function(key, ingredient) {
                if (key == value[0]) {
                    data = {
                        label: ingredient.label,
                        description: ingredient.params.description,
                        image: IMAGE_URL + ingredient.params.images.img_1
                    };
                    if (value[1]) {
                        data.rows = [
                            {
                                content: ExGods.getMsgByKey('tooltip_text')
                            }
                        ];
                    }
                }
            });
        } else if (type == 'currency') {
            ExGods.ref('user_money').each(function(currency) {
                if (currency.name == value[0]) {
                    data = {
                        label: currency.label,
                        description: ExGods.getMsgByKey('currency_description_' + currency.name),
                        image: currency.image_big
                    };
                    if (value[1]) {
                        data.rows = [
                            {
                                content: ExGods.getMsgByKey('tooltip_text')
                            }
                        ];
                    }
                }
            });
        } else if (type == 'timed') {
            ExGods.ref('user_timed').each(function(name, timed) {
                if (name == value[0]) {
                    data = {
                        label: timed.img.label,
                        description: timed.img.desc,
                        image: IMAGE_URL + timed.img.img2
                    };
                    if (value[1]) {
                        data.rows = [
                            {
                                content: ExGods.getMsgByKey('tooltip_text')
                            }
                        ];
                    }
                }
            });
        }
        return data;
    }
});

Ext.define('ExGods.view.lair.stuff.SkullItem', {
    extend: ExGods.stuff.stuff.Item,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators = [
            ExGods.view.lair.stuff.decorator.Skull
        ];
        return data;
    }
});

/**
 *     
 */
Ext.define('ExGods.view.lair.stuff.decorator.Skull', {
    extend: ExGods.stuff.Decorator,
    statics: {
        decorateAfter: function(data) {
            return '<div class="exg-stuff-decorator-quantity-counter"><span class="skull"><div></div>x ' + (data.stuff.params.quantity || 1) + '</span></div>';
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.model.LairStage', {
    extend: Ext.data.Model,
    idProperty: 'number',
    fields: [
        {
            // 
            name: 'number',
            type: 'int'
        },
        {
            //    
            name: 'allowed',
            type: 'int'
        },
        {
            //  
            name: 'description',
            type: 'string'
        },
        {
            //Object,  ,     
            name: 'images',
            type: 'auto'
        },
        {
            //Array,     
            name: 'reward',
            type: 'auto'
        },
        {
            //Array,    ,      
            name: 'description_stuff',
            type: 'auto'
        },
        {
            //Array,    ,      
            name: 'description_items',
            type: 'auto',
            convert: function(v, r) {
                return Ext.Array.map(v || [], function(item) {
                    return {
                        type: 'skull_item',
                        params: item
                    };
                });
            }
        },
        {
            //Array,    ,     
            name: 'drop_timeout_stuff',
            type: 'auto'
        },
        {
            //Array,    ,     
            name: 'pay_stuff',
            type: 'auto'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'cooldown',
            type: 'auto'
        },
        {
            name: 'is_boss',
            type: 'int'
        },
        {
            name: 'level',
            type: 'int'
        },
        {
            name: 'message',
            type: 'auto'
        }
    ]
});

Ext.define('ExGods.view.lair.Container', {
    extend: Ext.container.Container,
    alias: 'widget.laircontainer',
    layout: 'absolute',
    plugins: [
        'skindeco'
    ],
    initComponent: function() {
        var me = this,
            comboStoreConfig = [],
            modes = me.service.data.lair.modes,
            lair_id = me.service.data.lair.id,
            title = me.service.data.lair.title,
            key, i;
        var headerTpl = [
                '<div class="lair-title-bg">',
                '<div class="lair-title" style="background-image:url({[this.getTitle(values.title)]})"></div>',
                '</div>',
                '<div class="lair-modes-text" style="background-image: url(' + ExGods.ref('images|lair_images').image['text_level'] + ');"></div>',
                '<div class="lair-selecting">{[this.getModes()]}</div>',
                {
                    getTitle: function(title) {
                        return IMAGE_URL + title;
                    },
                    getModes: function() {
                        var images = ExGods.ref('images|lair_icons').image,
                            j = 1,
                            print = '',
                            sortedModes = [];
                        for (key in modes) {
                            sortedModes.push(Ext.apply(modes[key], {
                                mode: key
                            }));
                        }
                        Ext.Array.sort(sortedModes, function(a, b) {
                            return parseInt(a.order) - parseInt(b.order);
                        });
                        for (i = 0; i < sortedModes.length; i++) {
                            print += '<div class="qh-object lair-mode-icon' + (sortedModes[i].message ? ' disabled' : '') + '" id="lair-mode-' + sortedModes[i].mode + '"' + 'style="background-image:url(' + images['level' + j] + ');margin-right:-' + (8 + ((j != 1) ? 4 : 0)) + 'px" ' + 'data-qtip="' + sortedModes[i].title + '" data-qh_otype="lair_mode" data-qh_oid="' + lair_id + '_' + sortedModes[i].mode + '"></div>';
                            j++;
                        }
                        return print;
                    }
                }
            ];
        me.items = [
            {
                xtype: 'room',
                closeText: me.closeText,
                closeColor: me.closeColor,
                closeCallback: function() {
                    me.fireEvent('close');
                },
                backgroundImage: me.backImg,
                rightPanelX: 245,
                items: [
                    {
                        itemId: 'npcImg',
                        width: 330,
                        height: 410,
                        style: {
                            backgroundImage: "url(" + IMAGE_URL + me.npcImg + ")",
                            zIndex: 10,
                            backgroundSize: "auto 100%",
                            backgroundRepeat: "no-repeat"
                        }
                    },
                    {
                        xtype: 'component',
                        itemId: 'robbery_next',
                        html: '<div class="robbery-next">' + '<div class="info"></div>' + '<div class="timer"></div>' + '</div>',
                        style: {
                            zIndex: 100
                        },
                        hidden: !me.getRobberyNextTime(),
                        listeners: {
                            afterrender: function(view) {
                                if (!view.hidden) {
                                    var interval = setInterval(function() {
                                            if (!view.getEl() || !view.getEl().dom) {
                                                clearInterval(interval);
                                                return;
                                            }
                                            ExGods.helpme.shine(view.getEl(), 'robbery-next-shine', 22, 116, 25).on('click', function(e) {
                                                me.onTurnClick(e, turnEl);
                                            });
                                        }, 5000);
                                }
                            }
                        }
                    },
                    {
                        xtype: 'panel',
                        layout: 'absolute',
                        activeTab: 0,
                        x: 245,
                        y: 15,
                        width: 579,
                        height: 353,
                        plugins: [
                            'skindeco'
                        ],
                        closable: true,
                        bodyStyle: {
                            background: 'url(' + IMAGE_URL + 'lair/blood.png) no-repeat'
                        },
                        items: [
                            {
                                xtype: 'component',
                                tpl: headerTpl,
                                data: {
                                    title: me.titleImg
                                },
                                listeners: {
                                    render: function() {
                                        this.el.on('click', function(e, target) {
                                            this.fireEvent('selectmode', target);
                                        }, this, {
                                            delegate: '.lair-mode-icon'
                                        });
                                    }
                                }
                            },
                            {
                                xtype: 'panel',
                                itemId: 'lairComponent',
                                layout: 'card',
                                y: 55
                            }
                        ],
                        listeners: {
                            beforeclose: {
                                fn: function() {
                                    me.fireEvent('close');
                                    return false;
                                }
                            }
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.down('.robbery-next').on('click', function() {
            Ext.widget('commondetailswindow', {
                itemElement: me.el.down('.robbery-next').dom,
                //name: name,
                data: {
                    label: ExGods.getMsgByKey('robbery_defence_dialog_label'),
                    description: ExGods.getMsgByKey('robbery_defence_dialog_text'),
                    image: IMAGE_URL + ExGods.getMsgByKey('robbery_defence_dialog_img')
                }
            });
        });
        if (me.getRobberyNextTime()) {
            me.updateRobberyNext();
            ExGods.util.Ticker.addListener(me.updateRobberyNext, me);
        }
    },
    updateRobberyNext: function() {
        var me = this,
            time = me.getRobberyNextTime();
        if (!time) {
            me.el.down('.robbery-next').parent().hide();
        } else {
            try {
                me.el.down('.robbery-next .timer').setHTML(ExGods.util.Time.printTime(time / 1000, {
                    format: 'short'
                }));
            } catch (e) {}
            
        }
    },
    getRobberyNextTime: function() {
        var me = this,
            robbery_next = me.service.data.lair.robbery_next ? ExGods.util.Date.normalizeUnixTime(me.service.data.lair.robbery_next) : null,
            time = robbery_next ? Math.max(0, robbery_next - Date.now()) : 0;
        return time;
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Ticker.removeListener(me.updateRobberyNext);
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this,
            lair_icons = ExGods.ref('images|lair_icons').image,
            images = [
                IMAGE_URL + me.titleImg,
                IMAGE_URL + me.npcImg,
                IMAGE_URL + 'lair/blood.png'
            ];
        Ext.Object.each(lair_icons, function(k, v) {
            images.push(v);
        });
        var imgs_ref = ExGods.ref('images|lair_images').image;
        for (var it in imgs_ref) {
            images.push(imgs_ref[it]);
        }
        return images;
    }
});

Ext.define('ExGods.view.lair.Panel', {
    extend: Ext.panel.Panel,
    alias: 'widget.lair',
    cls: 'stage-container',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    initComponent: function() {
        var me = this,
            config = me.config,
            store = Ext.create('Ext.data.Store', {
                model: 'ExGods.model.LairStage',
                data: config.stages
            });
        me.store = store;
        me.singleLair = store.getCount() == 1;
        me.items = [
            {
                xtype: 'dataview',
                store: store,
                itemSelector: 'li.stage',
                tpl: [
                    '<ul style="height:150px">',
                    '<tpl for=".">',
                    '<tpl if="xcount == 1">',
                    '<li class="stage single-lair-description">',
                    '<div class="paper paper-tl"></div>',
                    '<div class="paper paper-tm"></div>',
                    '<div class="paper paper-tr"></div>',
                    '<div class="paper paper-mr"></div>',
                    '<div class="paper paper-br"></div>',
                    '<div class="paper paper-bm"></div>',
                    '<div class="paper paper-bl"></div>',
                    '<div class="paper paper-ml"></div>',
                    '<div class="paper paper-bg"></div>',
                    '<div class="single-lair-description-content">',
                    '<div class="desc">{description}</div>',
                    '<div class="lair-reward-items">{[ExGods.stuff.StuffManager.image(values.description_items)]}</div>',
                    '</div>',
                    '</li>',
                    '<tpl else>',
                    '<li class="{[this.setClass(values)]} qh-object" data-qtip="{title}" data-qh_otype="lair" data-qh_oid="' + me.lair_id + '_' + me.itemId + '_{number}" {[this.checkIndex(xindex)]}>',
                    '<div class="stage-bg-{is_boss}"></div>',
                    '<div class="stage-image-{number}"></div>',
                    '<p>{[this.printTimer(values.cooldown,values.number)]}</p>',
                    '<span class="stage-click-enabler"></span>',
                    '</li>',
                    '</tpl>',
                    '</tpl>',
                    '</ul>',
                    {
                        checkIndex: function(index) {
                            var cls = index == 1 ? ' data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : '';
                            return cls;
                        },
                        getBg: function(background) {
                            return IMAGE_URL + background;
                        },
                        printTimer: function(cd, num) {
                            var text = '',
                                date = new Date(Date.now() + cd * 1000);
                            if (cd > 0) {
                                text = '<span class="pager-text-left"></span>' + '<span class="pager-text-center"></span>' + '<span class="pager-text-right"></span>' + '<span class="pager-text-text">' + ExGods.util.Timers.printTimer('rest', 'lair-stage-cd' + me.lair_id + me.itemId + num, date, {
                                    needNormalized: true,
                                    format: 'threenums'
                                }) + '</span>';
                            }
                            return text;
                        },
                        setClass: function(values) {
                            var cls = [
                                    'stage',
                                    'multiple'
                                ],
                                lvlDelta = parseInt(ExGods.ref('constants|lair_level_delta').value),
                                userLvl = parseInt(ExGods.app.user.getLevel());
                            if (!values.allowed)  {
                                cls.push('disabled');
                            }
                            
                            if (me.user_modes[me.itemId] && parseInt(me.user_modes[me.itemId].finished_stage) < values.number) {
                                cls.push('incomplete');
                            }
                            if (values.level > lvlDelta + userLvl)  {
                                cls.push('high-level');
                            }
                            
                            return cls.join(' ');
                        }
                    }
                ]
            }
        ];
        me.dockedItems = [
            {
                xtype: 'component',
                dock: 'bottom',
                cls: 'stage-info',
                data: {},
                tpl: [
                    '<div class="lair-stage-description">',
                    '<div class="paper paper-tl"></div>',
                    '<div class="paper paper-tm"></div>',
                    '<div class="paper paper-tr"></div>',
                    '<div class="paper paper-mr"></div>',
                    '<div class="paper paper-br"></div>',
                    '<div class="paper paper-bm"></div>',
                    '<div class="paper paper-bl"></div>',
                    '<div class="paper paper-ml"></div>',
                    '<div class="paper paper-bg"></div>',
                    '<tpl if="title">',
                    '<div class="paper-title">',
                    '{[this.getTitleText()]}',
                    '</div>',
                    '</tpl>',
                    '<div class="lair-stage-description-text">',
                    '<tpl if="title">',
                    '{[this.getRewards(values)]}',
                    '<tpl else>',
                    '<p class="lair-hint">{[this.getHint(values)]}</p>',
                    '</tpl>',
                    '</div>',
                    '</div>',
                    //'<div id="enter-lair" data-qh_otype="lair_button_start" data-qh_oid="1" class="  {[this.getBtnCls(values)]}"></div>',
                    '<div class="enter-lair-btn-cnt" id="enter-lair-btn-cnt-' + me.itemId + '"></div>',
                    {
                        // getBtnCls:function(values){
                        //  var cls = 'qh-object ';
                        //  if(values.drop_timeout_stuff && values.cooldown > 0){
                        //      cls += 'lair-reset-btn';
                        //      if(!ExGods.app.getUser().checkStuff(values.drop_timeout_stuff)){
                        //          cls += ' disabled';
                        //      } else {
                        //          cls += ' ';
                        //      }
                        //  }else{
                        //      cls += 'lair-enter-btn';
                        //      if(!values || !values.allowed || values.cooldown > 0){
                        //          cls += ' disabled';
                        //      } else {
                        //          cls += ' ';
                        //      }
                        //  }
                        //  return cls;
                        // },
                        getTitleText: function() {
                            if (me.singleLair) {
                                return ExGods.getMsgByKey('rewards_title_single');
                            } else {
                                return ExGods.getMsgByKey('rewards_title');
                            }
                        },
                        getHint: function(values) {
                            if (me.singleLair && values.no_stages_allowed) {
                                return ExGods.ref('message_client|no_stages_allowed_single');
                            } else if (me.singleLair) {
                                //return ExGods.ref('message_client|lair_hint_single');
                                return this.getRewards(values);
                            } else if (values.no_stages_allowed) {
                                return ExGods.ref('message_client|no_stages_allowed');
                            } else {
                                return ExGods.ref('message_client|lair_hint');
                            }
                        },
                        getRewards: function(stage, itemFlag) {
                            var me = this,
                                stuff = ExGods.helpme.sumStuff(stage.reward || [], stage.description_stuff || []);
                            return '<div class="lair-reward-items">' + ExGods.stuff.StuffManager.image(stuff) + '</div>';
                        }
                    }
                ]
            }
        ];
        me.callParent(arguments);
    },
    // afterRender:function(){
    //  var me = this;
    //  me.callParent(arguments);
    //  me.renderBtn();
    // },
    renderBtn: function() {
        var me = this;
        if (!me.timed)  {
            return;
        }
        
        me.timedtimer = Ext.widget('timedtimer', {
            textbutton: {
                itemId: 'enter-lair'
            },
            qh: {
                'data-qh_otype': 'lair_button_start',
                'data-qh_oid': '1'
            },
            timed: me.timed,
            quantity: 1,
            renderTo: 'enter-lair-btn-cnt-' + me.itemId,
            autoShow: false
        });
        ExGods.Resources.load(me.timedtimer, function() {
            me.timedtimer.show();
        });
    },
    updateDocked: function(data) {
        var me = this,
            fn = function() {
                if (me.timedtimer)  {
                    me.timedtimer.destroy();
                }
                
                me.getDockedComponent(0).update(data);
                me.renderBtn();
            };
        if (me.rendered) {
            fn();
        } else {
            me.on('afterrender', fn, me);
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            var itm = me.store.data.items[i].data;
            for (var j = 0; j < itm.description_stuff.length; j++) {
                stuff_arr.push(itm.description_stuff[j]);
            }
            for (var j = 0; j < itm.description_items.length; j++) {
                stuff_arr.push(itm.description_items[j]);
            }
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [].concat(arr_images)
        };
    }
});

/**
 *  .
 */
Ext.define('ExGods.controller.Lair', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            wrap: false,
            error: false
        },
        prefix: 'Lair:'
    },
    models: [
        'LairStage'
    ],
    views: [
        'lair.Container',
        'lair.Panel',
        'TimedTimer'
    ],
    refs: [
        {
            /**
         * @method getLairContainer
         *    
         * @return {Ext.container.Container}
         */
            ref: 'lairContainer',
            selector: 'laircontainer'
        }
    ],
    init: function(app) {
        var me = this;
        me.control({
            'laircontainer component': {
                selectmode: me.onModeSelect
            },
            'laircontainer': {
                afterrender: me.afterContainerRender
            },
            'lair > dataview': {
                itemclick: me.onStageClick
            },
            'lair': {
                afterrender: me.afterModeRender
            },
            'battleresult': {
                close: me.showLair
            }
        });
        ExGods.stuff.StuffManager.register({
            'skull_item': ExGods.view.lair.stuff.SkullItem
        });
        ExGods.Components.addComponentInitializer('lair', me.initLairComponent, me);
    },
    //,      -  true
    isLairBattle: false,
    onModeSelect: function(target) {
        mode = target.id.substr(10);
        if (Ext.get(target).hasCls('disabled'))  {
            return;
        }
        
        Ext.select('.lair-mode-icon').removeCls('selected');
        Ext.get(target).addCls('selected');
        this.changeMode(mode);
    },
    /**
     *   .  
     */
    changeMode: function(newMode) {
        var me = this,
            ct = me.getLairContainer(),
            card = ct.down('#lairComponent'),
            cmp = card.down('#' + newMode),
            config = me.service.data.lair.modes[newMode],
            npcImg;
        me.selectedStage = -1;
        if (!cmp) {
            config.width = 550;
            cmp = Ext.widget('lair', {
                config: config,
                lair_id: me.service.data.lair.id,
                timed: me.findTimed(newMode),
                autoShow: false,
                user_modes: me.service.data.lair.user_modes,
                itemId: newMode
            });
            ExGods.helpme.loadProtos(cmp.store.getAt(0).get('description_items'), 'params.id', function() {
                ExGods.Resources.load(cmp, function() {
                    card.add(cmp);
                });
            });
        }
        var allowed = false;
        Ext.Array.each(config.stages, function(stage) {
            if (stage.allowed) {
                allowed = true;
            }
        });
        if (cmp.el) {
            cmp.el.select('li').removeCls('selected');
        }
        me.activeMode = newMode;
        var callback = function() {
                card.getLayout().setActiveItem(cmp);
                cmp.items.getAt(0).refresh();
                if (!cmp.singleLair || !allowed) {
                    cmp.updateDocked({
                        no_stages_allowed: !allowed
                    });
                    cmp.timedtimer.setDisable();
                }
                // , ..      
                /***/
                me.log('  ');
                //    npc 
                npcImg = ct['npcImg_' + newMode] || ct['npcImg'];
                ct.down('#npcImg').getEl().applyStyles({
                    'background-image': 'url(' + IMAGE_URL + npcImg + ')'
                });
            };
        if (cmp.singleLair) {
            if (cmp.rendered) {
                me.selectStage(cmp, cmp.store.getAt(0), false, callback);
            } else {
                cmp.on('afterrender', me.selectStage.bind(me, cmp, cmp.store.getAt(0), false, callback), me, {
                    single: true
                });
            }
        } else  {
            callback();
        }
        
    },
    /**
     *         
     */
    findTimed: function(mode) {
        var me = this,
            stages = me.service.data.lair.modes[mode].stages,
            timed;
        for (var i = 0; i < stages.length; i++) {
            var stuff = stages[i].pay_stuff;
            if (timed)  {
                break;
            }
            
            if (!stuff || !stuff.length)  {
                
                continue;
            }
            
            for (var j = 0; j < stuff.length; j++) {
                if (stuff[j].type == 'timed') {
                    timed = stuff[j].params.id;
                    break;
                }
            }
        }
        return timed;
    },
    afterContainerRender: function(container) {
        var me = this,
            combo = container.down('combo'),
            modes = me.service.data.lair.modes,
            sortedModes = [],
            index = 0,
            key;
        for (key in modes) {
            sortedModes.push(Ext.apply(modes[key], {
                mode: key
            }));
        }
        Ext.Array.sort(sortedModes, function(a, b) {
            return a.order - b.order;
        });
        Ext.each(sortedModes, function(el, i) {
            if (el.allowed != 0) {
                Ext.Array.each(el.stages, function(stage) {
                    if (stage.allowed)  {
                        index = i;
                    }
                    
                });
            }
        });
        newMode = sortedModes[index].mode;
        Ext.select('.lair-mode-icon').item(index).addCls('selected');
        this.changeMode(newMode);
    },
    afterModeRender: function(panel) {
        var me = this,
            store = panel.down('dataview').getStore(),
            lastStage = store.getAt(0),
            i = 0,
            el;
    },
    // store.each(function(record, index){
    //  if(record.get('allowed')){
    //      lastStage = record;
    //      i = index;
    //  }
    // });
    // panel.down('dataview').on('viewready',function(){
    //  if(lastStage){
    //      el = panel.el.query('li')[i];
    //      me.selectStage(panel,lastStage,el);
    //  }
    // });
    /**
     *      
     */
    onStageClick: function(dataview, record, el, index, e) {
        var me = this,
            panel = dataview.up('lair');
        me.selectStage(panel, record, el);
    },
    /**
     *  el   -  single lair
     */
    selectStage: function(panel, record, el, callback) {
        var me = this,
            docked = panel.getDockedComponent(0),
            itemRewards = [],
            protos = ExGods.app.getItemPrototypesStore(),
            missedProtos = [],
            _selectStage = function() {
                //if(Ext.get(el).hasCls('selected')) return;
                panel.el.select('li').removeCls('selected');
                if (el)  {
                    Ext.get(el).addCls('selected');
                }
                
                panel.updateDocked(record.data);
                if (callback)  {
                    callback();
                }
                
                var button = panel.timedtimer.textbutton,
                    service = me.service,
                    mode = me.getLairContainer();
                if (record.get('allowed') && record.get('cooldown') <= 0) {
                    panel.timedtimer.setEnable();
                } else {
                    panel.timedtimer.setDisable();
                }
                button.on('click', function() {
                    var fn = function() {
                            me.service.command('lair_start', {
                                id: service.data.lair.id,
                                mode: me.activeMode,
                                stage: record.get('number')
                            }, function() {
                                me.isLairBattle = service.id;
                            });
                        };
                    if (record.get('allowed') && record.get('cooldown') <= 0) {
                        var lvlDelta = parseInt(ExGods.ref('constants|lair_level_delta').value),
                            userLvl = parseInt(ExGods.app.user.getLevel());
                        if (record.get('level') > lvlDelta + userLvl) {
                            Ext.widget('confirmdialog', {
                                title: '',
                                message: new Ext.XTemplate(ExGods.ref('message_client|high_level_lair')).apply(),
                                handler: fn
                            });
                        } else  {
                            fn();
                        }
                        
                    } else if (record.get('drop_timeout_stuff') && record.get('cooldown') > 0) {
                        Ext.widget('confirmdialog', {
                            title: '',
                            message: new Ext.XTemplate(ExGods.ref('message_client|drop_timeout_confirm')).apply({
                                lair: service.data.lair.title,
                                stage: record.get('number'),
                                cooldown: Ext.util.Format.countdown(record.get('cooldown'), {
                                    format: 'threenums'
                                }),
                                cost: record.get('drop_timeout_stuff')
                            }),
                            handler: function() {
                                me.service.command('lair_drop_timeout', {
                                    id: service.data.lair.id,
                                    mode: me.activeMode,
                                    stage: record.get('number')
                                }, function(data) {
                                    if (!data.msg)  {
                                        record.set('cooldown', 0);
                                    }
                                    
                                    var stageEl = Ext.get(panel.down('dataview').getNode(record));
                                    stageEl.removeCls('disabled');
                                    stageEl.addCls('selected');
                                    button.removeCls('disabled');
                                    button.removeCls('lair-reset-btn');
                                    if (!button.hasCls('lair-enter-btn'))  {
                                        button.addCls('lair-enter-btn');
                                    }
                                    
                                });
                            }
                        });
                    }
                });
            };
        me.selectedStage = record.get('number');
        var itemRewards = [];
        if (record.data.reward) {
            itemRewards = itemRewards.concat(Ext.Array.filter(record.data.reward, function(item) {
                return item.type == 'item';
            }));
        }
        if (record.data.description_stuff) {
            itemRewards = itemRewards.concat(Ext.Array.filter(record.data.description_stuff, function(item) {
                return item.type == 'item';
            }));
        }
        //        
        ExGods.util.Helper.maskElement(me.getLairContainer().getEl());
        ExGods.helpme.loadProtos(itemRewards, 'params.id', function() {
            /***/
            me.log('  ');
            _selectStage();
            me.getLairContainer().getEl().unmask();
        });
    },
    showLair: function() {
        var me = this;
        if (me.isLairBattle && ExGods.app.user.getSetting('reopen_interface') == 1) {
            ExGods.ClientActions.createAndInvoke({
                actionId: me.isLairBattle
            }, null, function(err) {
                /***/
                me.log('error', err);
            });
            me.isLairBattle = false;
        }
    },
    // startService:function(callback, options){
    //  var me = this;      
    //  me.app.ServiceMgr.showServiceComponent(me.service, callback);
    // },
    initLairComponent: function(config, componentId) {
        var me = this,
            cmp;
        if (Ext.getCmp(componentId)) {
            return;
        }
        //   ,   
        me.service = config.service;
        Ext.apply(config, {
            style: {
                backgroundImage: "url(" + IMAGE_URL + config.backImg + ")",
                backgroundSize: "100% auto",
                backgroundRepeat: "no-repeat"
            },
            listeners: {
                close: {
                    fn: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            wnd.close();
                        }, {
                            img: config.backImg
                        });
                        return false;
                    },
                    single: true
                }
            }
        });
        /***/
        me.log('  ');
        cmp = Ext.apply({
            xtype: 'laircontainer'
        }, config);
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            items: [
                cmp
            ],
            getResources: function() {
                return {
                    images: [
                        IMAGE_URL + config.backImg
                    ]
                };
            }
        });
        ExGods.Resources.load(wnd, function() {
            ExGods.app.getController('Location').maskLocation(function() {
                //  
                wnd.show();
                ExGods.app.getController('Location').unmaskLocation();
            }, {
                img: config.backImg
            });
        });
        return wnd;
    }
});

/**
 *   .  , ,  .
 */
Ext.define('ExGods.view.skills.Window', {
    extend: ExGods.view.parchment.Window,
    alias: 'widget.skillwindow',
    cls: 'skill-window',
    padding: '7 10 17',
    initComponent: function() {
        var me = this;
        me.data = me.skill.data;
        me.tpl = [
            '<div class="paper-title">{skill.data.label}</div>',
            '<ul class="skill-params">',
            '<li>',
            '<div class="skill-param-label">' + me.clientConfig.level + '</div>',
            '<div class="skill-param-value">{level}</div>',
            '</li>',
            '<li>',
            '<div class="skill-param-label">' + me.clientConfig.bonus + '</div>',
            '<div class="skill-param-value">{[ExGods.app.applyTpl(values.description)]}</div>',
            '</li>',
            '<tpl if="this.timeIsVisible(values)">',
            '<li>',
            '<tpl if="current && skill.data.progress">',
            '<div class="skill-param-label">' + me.clientConfig.time_left + '</div>',
            '<div class="skill-param-value">{[this.printLeftTime(values)]}</div>',
            '<tpl else>',
            '<div class="skill-param-label">' + me.clientConfig.time_learn + '</div>',
            '<div class="skill-param-value">{[this.printTime(values)]}</div>',
            '</tpl>',
            '</li>',
            '</tpl>',
            '<tpl if="this.costIsVisible(values)">',
            '<li>',
            '<div class="skill-param-label">' + me.clientConfig.learn_cost + '</div>',
            '<div class="skill-param-value">{[this.printStuff(values)]}</div>',
            '</li>',
            '</tpl>',
            '</ul>',
            '<div class="paper-separator"></div>',
            '<div class="paper-title">' + me.clientConfig.condition_title + '</div>',
            '<div class="skill-condition">{skill.data.description2}</div>',
            '<tpl if="current">',
            '<div class="paper-separator"></div>',
            '<div class="skill-comment">{[this.isAnotherLearningSkill(values)]}</div>',
            '<tpl elseif="!complete">',
            '<div class="paper-separator"></div>',
            '<div class="skill-comment">' + me.clientConfig.learn_previous_skill + '</div>',
            '</tpl>',
            {
                printLeftTime: function(values) {
                    var progress = values.skill.data.progress;
                    if (progress.pause) {
                        return ExGods.util.Time.printTime((new Date(progress.end) - new Date(progress.pause)) / 1000 + 1, {
                            format: 'twonums'
                        });
                    } else {
                        return ExGods.util.Timers.printRestTimer('skill-window-timer', progress.end, {
                            needNormalized: true,
                            format: 'twonums'
                        });
                    }
                },
                printTime: function(values) {
                    return ExGods.util.Time.printTime(values.time, {
                        format: 'twonums'
                    });
                },
                printStuff: function(values) {
                    return ExGods.stuff.StuffManager.print(values.stuff);
                },
                isAnotherLearningSkill: function(values) {
                    if (me.other_skill == values.skill)  {
                        return '';
                    }
                    
                    if (me.other_skill && me.other_skill.data.progress.is_ready) {
                        return me.clientConfig.another_ready_comment;
                    } else if (me.other_skill) {
                        return me.clientConfig.another_learning_comment;
                    } else  {
                        return '';
                    }
                    
                },
                costIsVisible: function(values) {
                    return !values.complete && (!values.current || !values.skill.data.progress);
                },
                timeIsVisible: function(values) {
                    return !values.complete && (!values.current || !values.skill.data.progress || !values.skill.data.progress.is_ready);
                }
            }
        ];
        if (me.tooltip) {
            me.closable = false;
            if (me.skill.get('current')) {
                me.buttons = {
                    xtype: 'component',
                    cls: 'textcenter',
                    html: ExGods.getMsgByKey('tooltip_text')
                };
            }
        }
        if (me.buttons && me.buttons.length) {
            me.dockedItems = [
                {
                    xtype: 'toolbar',
                    layout: 'anchor',
                    dock: 'bottom',
                    itemId: 'actions',
                    padding: '4 16',
                    defaults: {
                        anchor: '100%',
                        margin: '2 0',
                        cls: 'no_border'
                    },
                    defaultType: 'textbutton',
                    items: me.buttons
                }
            ];
        }
        delete me.buttons;
        me.callParent(arguments);
    }
});

Ext.define('ExGods.model.Skill', {
    extend: Ext.data.Model,
    idProperty: 'name',
    fields: [
        {
            name: 'can_master',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description2',
            type: 'string'
        },
        {
            name: 'enabled',
            type: 'int'
        },
        {
            name: 'images',
            type: 'auto'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            name: 'label_img',
            type: 'string'
        },
        {
            name: 'level',
            type: 'int'
        },
        {
            name: 'master',
            type: 'auto'
        },
        {
            name: 'name',
            type: 'string'
        },
        {
            name: 'progress',
            type: 'auto',
            defaultValue: ''
        },
        {
            name: 'group',
            type: 'string'
        },
        {
            name: 'message',
            type: 'string'
        },
        {
            name: 'levels',
            type: 'auto',
            convert: function(v, r) {
                if (!r.levelsStore) {
                    r.levelsStore = Ext.create('Ext.data.Store', {
                        model: 'ExGods.model.SkillLevel',
                        record: r
                    });
                }
                r.levelsStore.loadRawData(Ext.Array.map(ExGods.ref('skills|' + r.get('name')).data.levels, function(el) {
                    var complete = el.level <= r.get('level'),
                        current = el.level == r.get('level') + 1;
                    return Ext.apply({
                        complete: complete,
                        current: current,
                        skill: r
                    }, el);
                }));
                return r.levelsStore;
            }
        },
        {
            name: 'stats',
            type: 'auto',
            convert: function(v) {
                return Ext.Array.map(v || [], function(el) {
                    return el.stat;
                });
            }
        },
        {
            name: 'order',
            type: 'int'
        }
    ],
    /**
     *  true/false    
     */
    affects: function(stat_name) {
        return this.get('stats').indexOf(stat_name) != -1;
    },
    /**
     *         
     */
    getImages: function() {
        var me = this,
            images = [
                IMAGE_URL + me.get('label_img')
            ];
        me.levelsStore.each(function(level) {
            images = images.concat(level.getImages());
        });
        return images;
    }
});

Ext.define('ExGods.model.SkillGroup', {
    extend: Ext.data.Model,
    idProperty: 'label',
    fields: [
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'description',
            mapping: 'params.description',
            type: 'string'
        },
        {
            name: 'image',
            mapping: 'params.image',
            type: 'string'
        },
        {
            name: 'l_order',
            type: 'int'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            name: 'group',
            type: 'string'
        },
        {
            name: 'visible',
            type: 'int'
        },
        {
            name: 'skills',
            type: 'auto',
            convert: function(v, r) {
                return Ext.create('Ext.data.Store', {
                    model: 'ExGods.model.Skill',
                    record: r,
                    sorters: [
                        {
                            property: 'order',
                            direction: 'ASC'
                        }
                    ],
                    data: []
                });
            }
        }
    ],
    /**
     *   ,   ,     
     */
    getSource: function() {
        var me = this,
            store = me.get('skills');
        //  getSource -   ,        (source)
        return store.data.getSource() || store;
    },
    /**
     *       
     */
    getImages: function() {
        var me = this,
            images = [
                IMAGE_URL + me.get('image')
            ];
        me.getSource().each(function(skill) {
            images = images.concat(skill.getImages());
        });
        return images;
    }
});

Ext.define('ExGods.model.SkillLevel', {
    extend: Ext.data.Model,
    idProperty: 'level',
    fields: [
        {
            name: 'level',
            type: 'int'
        },
        {
            name: 'image_b',
            type: 'string'
        },
        {
            name: 'image_r',
            type: 'string'
        },
        {
            name: 'complete',
            type: 'boolean'
        },
        {
            name: 'current',
            type: 'boolean'
        },
        {
            name: 'skill',
            type: 'auto'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description2',
            type: 'string'
        },
        {
            name: 'time',
            type: 'int'
        },
        {
            name: 'stuff',
            type: 'auto'
        }
    ],
    /**
     *    
     */
    getImages: function() {
        var me = this;
        return [
            IMAGE_URL + me.get('image_r'),
            IMAGE_URL + me.get('image_b')
        ];
    }
});

/**
 *  
 */
Ext.define('ExGods.view.skills.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.skillstabpanel',
    id: 'skill-tabs',
    tabUi: 'skintext',
    bodyPadding: '0 12 8 5',
    initComponent: function() {
        var me = this;
        me.items = [];
        me.store.each(function(group) {
            var width = 100,
                img = group.get('image');
            if (!!~img.indexOf('equipment_sprite')) {
                width = 120;
            } else if (!!~img.indexOf('group_sprite')) {
                width = 120;
            } else if (!!~img.indexOf('potion_sprite')) {
                width = 195;
            } else if (!!~img.indexOf('mask_sprite')) {
                width = 120;
            }
            me.items.push({
                xtype: 'skillgroup',
                id: 'skill_group_' + group.get('entry'),
                skills: group.get('skills'),
                free_boost: me.free_boost,
                clientConfig: me.clientConfig,
                tabConfig: {
                    icon: IMAGE_URL + img,
                    width: width
                }
            });
        });
        me.plugins = [
            {
                ptype: 'pager',
                marginLeft: -30,
                marginRight: -30,
                top: 190,
                textTop: 395,
                textLeft: 326,
                totalTabs: me.store.getCount()
            }
        ];
        me.callParent(arguments);
    },
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'skills/icon_skills_learning_left.png',
                IMAGE_URL + 'skills/icon_skills_learning_accelerate.png',
                IMAGE_URL + 'mask/arrow.png',
                IMAGE_URL + 'mask/arrow_dis.png',
                IMAGE_URL + 'skills/skills_skin_01.png',
                IMAGE_URL + 'skills/skills_skin_02.png',
                IMAGE_URL + 'skills/skills_skin_03.png',
                IMAGE_URL + 'skills/skills_skin_04.png',
                IMAGE_URL + 'skills/skills_skin_05.png',
                IMAGE_URL + 'skills/skills_skin_06.png',
                IMAGE_URL + 'skills/skills_skin_01_locked.png',
                IMAGE_URL + 'skills/skills_skin_02_locked.png',
                IMAGE_URL + 'skills/skills_skin_03_locked.png',
                IMAGE_URL + 'skills/skills_skin_04_locked.png',
                IMAGE_URL + 'skills/skills_skin_05_locked.png',
                IMAGE_URL + 'skills/skills_skin_06_locked.png',
                IMAGE_URL + 'skills/skills_frame_01.png',
                IMAGE_URL + 'skills/skills_frame_02.png',
                IMAGE_URL + 'skills/skills_frame_03.png',
                IMAGE_URL + 'skills/skills_frame_04.png',
                IMAGE_URL + 'skills/skills_frame_05.png',
                IMAGE_URL + 'skills/skills_frame_06.png',
                IMAGE_URL + 'skills/skills_frame_01_locked.png',
                IMAGE_URL + 'skills/skills_frame_02_locked.png',
                IMAGE_URL + 'skills/skills_frame_03_locked.png',
                IMAGE_URL + 'skills/skills_frame_04_locked.png',
                IMAGE_URL + 'skills/skills_frame_05_locked.png',
                IMAGE_URL + 'skills/skills_frame_06_locked.png'
            ].concat(me.store.getImages())
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.view.skills.Group', {
    extend: Ext.container.Container,
    alias: 'widget.skillgroup',
    padding: '10 17 0',
    initComponent: function() {
        var me = this;
        //  , ..      
        me.store = me.skills;
        me.callParent(arguments);
        me.onStoreDataChanged();
        me.mon(me.store, 'datachanged', me.onStoreDataChanged, me);
    },
    onStoreDataChanged: function() {
        var me = this,
            current_items = [];
        me.items.each(function(item) {
            current_items.push(item);
        });
        me.store.each(function(skill) {
            me.add(Ext.widget('skill', {
                skill: skill,
                free_boost: me.free_boost,
                clientConfig: me.clientConfig
            }));
        });
        Ext.Array.each(current_items, function(item) {
            me.remove(item);
        });
    },
    bindStore: function(store) {
        var me = this;
        me.mun(me.store, 'datachanged', me.onStoreDataChanged, me);
        me.store = store;
        me.mon(me.store, 'datachanged', me.onStoreDataChanged, me);
        me.onStoreDataChanged();
    },
    bindDefaultStore: function() {
        this.bindStore(this.skills);
    }
});

/**
 *  
 */
Ext.define('ExGods.view.skills.Skill', {
    extend: Ext.view.View,
    alias: 'widget.skill',
    itemSelector: '.skill-level',
    initComponent: function() {
        var me = this;
        me.store = me.skill.get('levels');
        me.tpl = [
            '<div class="skill-label" style="background-image:url(' + IMAGE_URL + me.skill.get('label_img') + ')"></div>',
            '<ul>',
            '<tpl for=".">',
            '<tpl if="level &gt; 1">',
            '<li class="skill-arrow{[this.isActive(values)]}"></li>',
            '</tpl>',
            '<li class="skill-level qh-object skill-level-{level}{[this.isActive(values)]}"{[this.getAttributes(values)]}>',
            '<div class="skill-frame">',
            '<div class="skill-img" style="background-image:url({[IMAGE_URL + this.getImage(values)]})"></div>',
            '<tpl if="complete">',
            '<div class="skill-complete"></div>',
            '<tpl elseif="current && skill.data.progress && !skill.data.progress.is_ready">',
            '{[this.createTimer(values)]}',
            '</tpl>',
            '</div>',
            '<div class="skill-description">',
            '<tpl if="current && skill.data.progress && skill.data.progress.pause">',
            '<span class="skill-timer"></span>{[this.getTime(values)]}',
            '<tpl elseif="current && skill.data.progress && !skill.data.progress.is_ready">',
            '<span class="skill-timer"></span>{[this.getTimer(values)]}',
            '<tpl else>',
            //ExGods.app.applyTpl(me.skill.get('description')),
            '{[ExGods.app.applyTpl(values.description)]}',
            '</tpl>',
            '</div>',
            '<div class="skill-info"></div>',
            '<tpl if="current && skill.data.progress && skill.data.progress.is_ready">',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="itemId">skill_complete_btn</span>',
            '<span role="skill_name">{skill.data.name}</span>',
            '<span role="text">',
            me.clientConfig.ready_btn,
            '</span>',
            '<span role="qh:object">{[this.getQuestHelperInfo(values)]}</span>',
            '<span role="cls">x-btn-txt-green qh-object</span>',
            '</div>',
            '<tpl elseif="current && skill.data.progress && !skill.data.progress.pause && this.canBoost()">',
            '<div class="component">',
            '<span role="xtype">textbutton</span>',
            '<span role="itemId">skill_boost_btn</span>',
            '<span role="skill_name">{skill.data.name}</span>',
            '<span role="text">',
            '<span class="skill-boost-icon"></span>',
            '{[this.printBoostStuff(values)]}',
            '</span>',
            '<span role="qh:object">{[this.getQuestHelperInfo(values)]}</span>',
            '<span role="cls">x-btn-txt-green skill-boost-btn qh-object</span>',
            '</div>',
            '</tpl>',
            '</li>',
            '</tpl>',
            '</ul>',
            '<div class="skill-separator"></div>',
            {
                isActive: function(values) {
                    return (values.complete || values.current) ? '' : '-locked locked';
                },
                getImage: function(values) {
                    return (values.complete || (values.current && values.skill.data.progress)) ? values.image_r : values.image_b;
                },
                getTimer: function(values) {
                    return ExGods.util.Timers.printRestTimer('skill-timer', values.skill.data.progress.end, {
                        needNormalized: true,
                        format: 'twonums'
                    });
                },
                getTime: function(values) {
                    var progress = values.skill.data.progress;
                    return ExGods.util.Time.printTime((new Date(progress.end) - new Date(progress.pause)) / 1000 + 1, {
                        format: 'twonums'
                    });
                },
                canBoost: function() {
                    return me.free_boost || me.skill.get('progress').stuff_boost_complete;
                },
                printBoostStuff: function(values) {
                    var progress = values.skill.data.progress;
                    if (me.free_boost || Ext.isEmpty(progress.stuff_boost_complete)) {
                        return ExGods.getMsgByKey('skills_free_pay_text');
                    } else {
                        return ExGods.stuff.StuffManager.print(progress.stuff_boost_complete);
                    }
                },
                getAttributes: function(values) {
                    return values.current && (!values.skill.data.progress || !values.skill.data.progress.is_ready) ? ' data-qh_otype="skill_interface" data-qh_oid="' + values.skill.data.name + '" data-qh_opts="{&quot;cls&quot;:&quot;flip-h&quot;}"' : '';
                },
                getQuestHelperInfo: function(values) {
                    return JSON.stringify({
                        'data-qh_otype': 'skill_interface_boost_complete',
                        'data-qh_oid': values.skill.data.name,
                        'data-qh_opts': '{"cls":"flip-h"}'
                    });
                },
                createTimer: function(values) {
                    var progress = values.skill.data.progress,
                        progress_end, progress_start, progress_pause;
                    if (progress.end)  {
                        progress_end = ExGods.util.Date.normalizeServerDateTime(progress.end);
                    }
                    
                    if (progress.start)  {
                        progress_start = ExGods.util.Date.normalizeServerDateTime(progress.start);
                    }
                    
                    if (progress.pause)  {
                        progress_pause = ExGods.util.Date.normalizeServerDateTime(progress.pause);
                    }
                    
                    return ExGods.util.Timers.printSquareTimer({
                        end: progress_end,
                        start: progress_start,
                        pause: progress_pause
                    });
                }
            }
        ];
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.on({
            beforerefresh: function() {
                ExGods.util.Helper.destroyComponents(me.el);
            },
            refresh: function() {
                ExGods.util.Helper.renderComponents(me.el, me);
            }
        });
        me.callParent(arguments);
    },
    onBeforeDestroy: function() {
        var me = this;
        me.clearListeners();
        ExGods.util.Helper.destroyComponents(me.el);
        me.callParent(arguments);
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Skills', {
    extend: ExGodsCore.controller.Base,
    models: [
        'SkillGroup',
        'SkillLevel',
        'Skill'
    ],
    views: [
        'skills.TabPanel',
        'skills.Group',
        'skills.Skill',
        'skills.Window'
    ],
    refs: [
        {
            /**
         * @method getSkillsButton
         */
            ref: 'skillsButton',
            selector: '#mainmenu-combos-and-features-button'
        },
        {
            /**
         * @method getSkillTabs
         */
            ref: 'skillTabs',
            selector: 'skillstabpanel'
        },
        {
            /**
         * @method getSearchInput
         */
            ref: 'searchInput',
            selector: '#skill-text-search'
        }
    ],
    //       
    pager_original_state: {},
    init: function() {
        var me = this,
            user = me.getUser();
        me.service = ExGods.Services.get('skills');
        me.service.on('update', me.onServiceUpdate, me);
        me.skillsStore = me.app.getSkillsStore();
        me.skillsStore.loadRawData(ExGods.ref('skill_groups'));
        //  ,     
        me.allSkillsStore = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.Skill'
        });
        me.app.getViewportController().on('gameshown', me.onServiceUpdate, me);
        me.control({
            'skillstabpanel': {
                next: me.openNextPage,
                prev: me.openPrevPage,
                tabchange: me.onTabChange,
                beforetabchange: me.onBeforeTabChange,
                scope: me
            },
            'skill': {
                itemclick: me.onSkillClick,
                itemmouseenter: me.onSkillOver,
                itemmouseleave: me.onSkillOut,
                scope: me
            },
            '#skill_complete_btn': {
                click: me.onSkillCompleteBtnClick,
                scope: me
            },
            '#skill_boost_btn': {
                click: me.onSkillBoostBtnClick,
                scope: me
            }
        });
        ExGods.Components.addComponentInitializer('skills', me.initSkillsComponent, me);
        me.app.chatcn.on({
            command_refresh_skill_service: me.service.update,
            scope: me
        });
    },
    onServiceUpdate: function() {
        var me = this,
            cmp = Ext.getCmp('SKILLS');
        me.skillsStore.each(function(group) {
            group.get('skills').loadRawData(Ext.Array.findBy(me.service.data.skill_groups, function(el) {
                return el.label == group.get('label');
            }).skills);
        });
        me.allSkillsStore.loadRecords(me.skillsStore.getAll());
        me.startMenuTimer();
        //   -  ,    .      .
        if (!cmp)  {
            return;
        }
        
        if (me.service.data.free_boost) {
            if (cmp)  {
                cmp.free_boost = true;
            }
            
            me.free_boost = true;
        } else {
            if (cmp)  {
                cmp.free_boost = false;
            }
            
            me.free_boost = false;
        }
        me.setPage();
    },
    onBeforeTabChange: function(tabpanel, newTab, oldTab) {
        var me = this,
            textfield = me.getSearchInput();
        if (!textfield)  {
            return;
        }
        
        textfield.suspendEvents();
        textfield.setValue('');
        textfield.resumeEvents();
        me.filtered = false;
        oldTab.bindDefaultStore();
        Ext.apply(tabpanel.pager, me.pager_original_state);
        me.pager_original_state = {};
    },
    onTabChange: function(tabpanel, newTab, oldTab) {
        tabpanel.pager.currentTab = tabpanel.items.indexOf(newTab);
        this.setPageInCurrentTab(1);
    },
    openNextPage: function(pager) {
        var me = this;
        me.setPage(pager.current);
    },
    openPrevPage: function(pager) {
        var me = this;
        me.setPage(pager.current);
    },
    setPage: function(pageIndex) {
        var me = this,
            tabs = me.getSkillTabs();
        if (!tabs)  {
            return;
        }
        
        var pager = tabs.pager,
            store = tabs.getActiveTab().store;
        me.closeTips();
        if (!pageIndex)  {
            pageIndex = pager.current;
        }
        
        store.removeFilter('pager', true);
        if (me.filtered) {
            if (pageIndex < 1)  {
                return;
            }
            
            if (pageIndex * 2 > store.getCount() + 1)  {
                return;
            }
            
        } else {
            if (pageIndex < 1 && pager.currentTab <= 0) {
                return false;
            } else if (pageIndex < 1) {
                store = tabs.setActiveTab(pager.currentTab - 1).store;
                store.removeFilter('pager', true);
                pageIndex = Math.ceil(store.getCount() / 2) || 1;
            } else if (pageIndex * 2 > store.getCount() + 1 && tabs.items.getCount() <= pager.currentTab + 1) {
                return false;
            } else if (pageIndex * 2 > store.getCount() + 1) {
                store = tabs.setActiveTab(pager.currentTab + 1).store;
                store.removeFilter('pager', true);
                pageIndex = 1;
            }
        }
        pager.total = Math.ceil(store.getCount() / 2);
        pager.current = pageIndex;
        store.addFilter(Ext.util.Filter({
            filterFn: function(rec) {
                var page = Math.floor(store.indexOf(rec) / 2) + 1;
                return pageIndex == page;
            },
            id: 'pager'
        }));
        pager.refresh();
    },
    setPageInCurrentTab: function(pageIndex) {
        var me = this,
            tabs = me.getSkillTabs(),
            pager = tabs.pager,
            store = tabs.getActiveTab().store;
        me.closeTips();
        if (!pageIndex)  {
            pageIndex = pager.current;
        }
        
        store.removeFilter('pager', true);
        pager.total = Math.ceil(store.getCount() / 2);
        pager.current = pageIndex;
        store.addFilter(Ext.util.Filter({
            filterFn: function(rec) {
                var page = Math.floor(store.indexOf(rec) / 2) + 1;
                return pageIndex == page;
            },
            id: 'pager'
        }));
        pager.refresh();
    },
    onSkillBoostBtnClick: function(btn) {
        var me = this,
            skill = me.skillsStore.getSkillByName(btn.skill_name);
        if (skill) {
            me.closeTips();
            me.boost(skill);
        }
    },
    onSkillCompleteBtnClick: function(btn) {
        var me = this,
            skill = me.skillsStore.getSkillByName(btn.skill_name);
        if (skill) {
            me.closeTips();
            me.complete(skill);
        }
    },
    onSkillClick: function(view, record, el, index, event) {
        var me = this,
            buttons = [],
            target = Ext.fly(event.target),
            current_learning_skill = me.skillsStore.getLearningSkill();
        //  -       
        if (target.hasCls('.x-btn') || target.up('.x-btn'))  {
            return;
        }
        
        if (record.get('current')) {
            var skill = record.get('skill'),
                progress = skill.get('progress'),
                master = skill.get('master'),
                name = skill.get('name'),
                learning = Boolean(current_learning_skill),
                boost_btn_cfg;
            if (current_learning_skill && current_learning_skill.data.progress.is_ready) {
                boost_btn_cfg = {
                    text: me.clientConfig.ready_other_btn,
                    cls: 'no_border x-btn-txt-green',
                    handler: function() {
                        if (me.skillWindow)  {
                            me.skillWindow.close();
                        }
                        
                        me.complete(current_learning_skill);
                    }
                };
            } else if (current_learning_skill) {
                var stuff = current_learning_skill.data.progress.stuff_boost_complete;
                boost_btn_cfg = {
                    text: (me.free_boost || Ext.isEmpty(stuff)) ? me.clientConfig.boost_btn_free : '<span class="skill-boost-icon"></span>' + ExGods.stuff.StuffManager.print(stuff),
                    cls: 'no_border x-btn-txt-green',
                    handler: function() {
                        if (me.skillWindow)  {
                            me.skillWindow.close();
                        }
                        
                        me.boost(current_learning_skill);
                    }
                };
            }
            if (progress) {
                if (progress.pause) {
                    if (learning) {
                        buttons.push(boost_btn_cfg);
                    } else {
                        buttons.push({
                            text: me.clientConfig.continue_btn,
                            disabled: learning,
                            handler: function() {
                                if (me.skillWindow)  {
                                    me.skillWindow.close();
                                }
                                
                                me.service.command('skills_unpause', {
                                    name: name
                                }, function(response) {
                                    me.afterResponse(response);
                                });
                            }
                        });
                    }
                } else if (progress.is_ready) {
                    buttons.push({
                        text: me.clientConfig.ready_btn,
                        cls: 'no_border x-btn-txt-green',
                        handler: function() {
                            if (me.skillWindow)  {
                                me.skillWindow.close();
                            }
                            
                            me.complete(skill);
                        }
                    });
                } else {
                    buttons.push({
                        text: me.clientConfig.pause_btn,
                        handler: function() {
                            if (me.skillWindow)  {
                                me.skillWindow.close();
                            }
                            
                            me.service.command('skills_pause', {
                                name: name
                            }, function(response) {
                                me.afterResponse(response);
                            });
                        }
                    });
                }
            } else if (master.enabled) {
                if (learning) {
                    buttons.push(boost_btn_cfg);
                } else {
                    buttons.push({
                        text: me.clientConfig.learn_btn,
                        disabled: learning,
                        handler: function() {
                            me.master(skill);
                        },
                        cls: 'qh-object no_border',
                        qh: {
                            'data-qh_otype': 'skill_interface',
                            'data-qh_oid': name
                        }
                    });
                }
            }
        }
        if (me.skillWindow)  {
            me.skillWindow.close();
        }
        
        el = Ext.fly(el);
        el.set({
            'data-qh_oid': 0
        });
        me.skillWindow = Ext.widget('skillwindow', {
            itemElement: el,
            skill: record,
            clientConfig: me.clientConfig,
            free_boost: me.free_boost,
            buttons: buttons,
            other_skill: current_learning_skill,
            listeners: {
                close: function() {
                    me.skillWindow = false;
                    if (el) {
                        el.set({
                            'data-qh_oid': record.get('skill').get('name')
                        });
                    }
                }
            }
        });
    },
    onSkillOver: function(view, record, el, index, event) {
        var me = this;
        if (me.skillWindow)  {
            return;
        }
        
        me.skillTip = Ext.widget('skillwindow', {
            itemElement: el,
            skill: record,
            clientConfig: me.clientConfig,
            free_boost: me.free_boost,
            tooltip: true,
            listeners: {
                close: function() {
                    me.skillTip = false;
                }
            }
        });
    },
    onSkillOut: function(view, record, el, index, event) {
        var me = this;
        if (me.skillTip) {
            me.skillTip.close();
        }
    },
    onSearch: Ext.Function.createBuffered(function(textfield, value, previous) {
        var me = this,
            tabs = me.getSkillTabs(),
            tab = tabs.getActiveTab(),
            pager = tabs.pager,
            escapeSpecialChars = function(text) {
                return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            };
        if (!value) {
            me.filtered = false;
            tab.bindDefaultStore();
            Ext.apply(pager, me.pager_original_state);
            me.pager_original_state = {};
            me.setPage();
            return;
        }
        me.filtered = true;
        tab.bindStore(me.allSkillsStore);
        if (Ext.Object.isEmpty(me.pager_original_state)) {
            me.pager_original_state = {
                current: pager.current,
                total: pager.total,
                currentTab: pager.currentTab,
                totalTabs: pager.totalTabs
            };
        }
        value = new RegExp('^.*' + escapeSpecialChars(value) + '.*$', 'i');
        me.allSkillsStore.clearFilter(true);
        me.allSkillsStore.filterBy(function(record) {
            return value.test(record.get('label'));
        });
        pager.currentTab = 0;
        pager.totalTabs = 0;
        pager.current = 1;
        me.setPage();
    }, 200),
    onCheckboxChange: function(field) {
        var me = this,
            values = [],
            all_checked = true;
        Ext.Array.each(field.up().up().query('checkboxfield'), function(checkBox) {
            if (checkBox.getValue()) {
                values.push(checkBox.stat_name);
            } else  {
                all_checked = false;
            }
            
        });
        me.skillsStore.each(function(group) {
            var store = group.get('skills');
            store.removeFilter('stats');
            if (!all_checked) {
                store.addFilter(Ext.util.Filter({
                    filterFn: function(rec) {
                        var i = values.length;
                        while (i--) {
                            if (rec.affects(values[i]))  {
                                return true;
                            }
                            
                        }
                    },
                    id: 'stats'
                }));
            }
        });
        me.setPageInCurrentTab(1);
    },
    closeTips: function() {
        var me = this;
        if (me.skillWindow)  {
            me.skillWindow.close();
        }
        
        if (me.skillTip)  {
            me.skillTip.close();
        }
        
    },
    boost: function(skill) {
        var me = this,
            progress = skill.get('progress'),
            message = ExGods.app.applyTpl(ExGods.ref('message_client|skills_burst_complete_message'), {
                burst_time: ExGods.util.Time.printTime((progress.time + 1) * ExGods.ref('constants|skill_boost_rate').value, {
                    format: 'detailed'
                }),
                level: skill.get('level'),
                next_level: skill.get('level') + 1,
                name: skill.get('label'),
                stuff: (me.free_boost || Ext.isEmpty(progress.stuff_boost_complete)) ? ExGods.getMsgByKey('skills_free_pay_text') : Ext.String.format(ExGods.getMsgByKey("skills_boost_pay"), ExGods.stuff.StuffManager.print(progress.stuff_boost_complete))
            });
        Ext.widget('confirmdialog', {
            message: message,
            handler: function() {
                var end = ExGods.util.Date.normalizeServerDateTime(progress.end),
                    time = new Date();
                if (end <= time)  {
                    return;
                }
                
                me.service.command('skills_boost_complete', {
                    name: skill.get('name')
                }, function(response) {
                    me.afterResponse(response);
                });
            }
        });
    },
    complete: function(skill) {
        var me = this;
        me.service.command('skills_complete', {
            name: skill.get('name')
        }, function(response) {
            me.afterResponse(response);
        });
    },
    master: function(skill) {
        var me = this,
            master = skill.get('master'),
            message = ExGods.app.applyTpl(ExGods.getMsgByKey('skills_learn_cost_message'), {
                time: ExGods.util.Time.printTime(master.time, {
                    format: 'detailed'
                }),
                level: skill.get('level'),
                next_level: skill.get('level') + 1,
                name: skill.get('label'),
                stuff: ExGods.stuff.StuffManager.print(master.stuff)
            });
        Ext.widget('confirmdialog', {
            message: message,
            handler: function() {
                me.service.command('skills_master', {
                    name: skill.get('name')
                }, function(response) {
                    me.afterResponse(response);
                });
            }
        });
    },
    afterResponse: function(response) {
        var me = this;
        if (response.success && response.skill_groups) {
            me.service.data.skill_groups = response.skill_groups;
            me.onServiceUpdate();
        }
    },
    /**
     * @private
     *      (   ""  )
     */
    startMenuTimer: function(view) {
        var me = this,
            skill = me.skillsStore.getLearningSkill(),
            menu_btn = me.getSkillsButton(),
            timer_id = 'skill-timer';
        ExGods.util.Helper.stopMenuTimer(timer_id);
        if (!menu_btn)  {
            return;
        }
        
        if (!skill) {
            return menu_btn.reset();
        }
        var progress = skill.get('progress'),
            end_time = progress.end,
            menu_id = menu_btn.id;
        if (progress.is_ready) {
            return me.updateMenuBtnCount();
        } else {
            menu_btn.reset();
        }
        ExGods.util.Helper.startMenuTimer(menu_id, timer_id, end_time, function() {
            me.learningSkillComplete();
            ExGods.util.Helper.stopMenuTimer(timer_id);
        });
    },
    learningSkillComplete: function() {
        var me = this,
            skill = me.skillsStore.getLearningSkill(),
            progress = skill.get('progress');
        progress.is_ready = 1;
        progress.can_boost = 0;
        progress.can_pause = 0;
        skill.set('progress', progress);
        me.setPage();
        me.updateMenuBtnCount();
    },
    updateMenuBtnCount: function() {
        var me = this;
        me.getSkillsButton().addCount(1);
    },
    initSkillsComponent: function(config) {
        var me = this,
            wnd,
            stats = [];
        //  
        if (me.initializing_component)  {
            return;
        }
        
        ExGods.app.block();
        me.initializing_component = true;
        me.clientConfig = config;
        Ext.Array.each(me.skillsStore.getAll(), function(record) {
            stats = stats.concat(record.get('stats'));
        });
        stats = Ext.Array.unique(stats);
        stats = Ext.Array.map(stats, function(name) {
            var ref = ExGods.ref('user_stat|' + name);
            if (ref) {
                return {
                    boxLabel: ExGods.printStat(name),
                    stat_name: name
                };
            }
        });
        stats = Ext.Array.clean(stats);
        wnd = Ext.widget('window2', {
            id: 'SKILLS',
            layout: 'absolute',
            items: [
                {
                    xtype: 'skillstabpanel',
                    store: me.skillsStore,
                    free_boost: me.free_boost,
                    clientConfig: config
                },
                {
                    xtype: 'form',
                    x: 347,
                    y: 8,
                    width: 400,
                    height: 30,
                    tbar: {
                        xtype: 'panel',
                        bodyCls: 'skills-checkbox-container',
                        defaults: {
                            xtype: 'checkboxfield',
                            checked: true,
                            listeners: {
                                change: me.onCheckboxChange,
                                scope: me
                            }
                        },
                        items: stats,
                        layout: {
                            type: 'hbox',
                            align: 'right',
                            pack: 'end'
                        }
                    }
                }
            ],
            /*{
                x: 585,
                y: 9,
                width: 152,
                height: 30,
                xtype: 'textfield',
                emptyText: me.clientConfig.search_empty_text,
                id: 'skill-text-search',
                cls: 'text-search-input',
                listeners: {
                    change: me.onSearch,
                    scope: me
                },
                value: ''
            }*/
            autoShow: false,
            listeners: {
                close: function() {
                    me.filtered = false;
                    me.pager_original_state = {};
                    me.skillsStore.each(function(group) {
                        group.get('skills').clearFilter(true);
                    });
                }
            }
        });
        me.service.update(null, function() {
            ExGods.Resources.load(wnd, function() {
                var learning = me.skillsStore.getLearningSkill(),
                    group = me.skillsStore.getLearningGroup(),
                    tabs = me.getSkillTabs();
                ExGods.app.unblock();
                me.initializing_component = false;
                //     
                if (!tabs)  {
                    return;
                }
                
                if (learning) {
                    tabs.setActiveTab('skill_group_' + group.get('entry'));
                    var store = group.get('skills');
                    store.removeFilter('pager');
                    me.setPage(Math.floor(store.indexOf(learning) / 2) + 1);
                } else {
                    me.setPage(1);
                }
                wnd.show();
            });
        });
        return wnd;
    }
});

/**
 *     

     :
    
        type: 'fucina_source',
        params: {
            stuff: <Object>,
        }
        sourceModel: <Object>

 */
Ext.define('ExGods.view.fucina.stuff.FucinaSource', {
    extend: ExGods.stuff.Composite,
    dblclickAction: '',
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.decorators = data.decorators || [];
        if (me.stuff.sourceModel.get('selected')) {
            me.dblclickAction = 'putoff';
        } else {
            me.dblclickAction = 'put';
            me.replaceQuantityDecorator(data.decorators);
        }
        if (me.stuff.sourceModel.get('invalid')) {
            data.decorators.push(ExGods.stuff.decorator.Disabled);
        }
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        if (data.itemModel && data.itemModel.data.clothed) {
            Ext.Array.insert(data.blocks, 1, [
                ExGods.view.fucina.stuff.block.ClothedTextSource
            ]);
        }
        if (me.stuff.sourceModel.get('selected') && me.wrappedStuff.type == 'iteminstance') {
            me.replaceItemStatsBlock(data.blocks);
        }
        return Ext.apply(data, {
            buttons: [
                {
                    text: ExGods.getMsgByKey('fucina_puton'),
                    action: 'put',
                    hidden: me.stuff.sourceModel.get('selected')
                },
                {
                    text: ExGods.getMsgByKey('fucina_putoff'),
                    action: 'putoff',
                    hidden: !me.stuff.sourceModel.get('selected')
                }
            ]
        });
    },
    /**
     *    -
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.fucina.stuff.decorator.SourceQuantity);
    },
    /**
     *          
     */
    replaceItemStatsBlock: function(blocks) {
        var index = blocks.indexOf(ExGods.stuff.block.item.Stats2);
        Ext.Array.replace(blocks, index, 1, [
            ExGods.view.fucina.stuff.block.EmptyStats2
        ]);
    }
});

/**
 *     (    )

     :
    
        type: 'fucina_resource',
        params: {
            stuff: <Object>,            
        },
        resultInfo: <Object>     (  ,    min-max )

 */
Ext.define('ExGods.view.fucina.stuff.FucinaResource', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        data.resultInfo = me.stuff.resultInfo;
        //  Disabled 
        if (me.wrappedStuff.type == 'currency') {
            if (ExGods.app.user.get('money')[me.wrappedStuff.params.id] < me.wrappedStuff.params.quantity) {
                data.decorators.push(ExGods.stuff.decorator.Disabled);
            }
        } else if (me.wrappedStuff.type == 'item') {
            if (ExGods.app.user.slots().getItemCount(me.wrappedStuff.params.id) < me.wrappedStuff.params.quantity) {
                data.decorators.push(ExGods.stuff.decorator.Disabled);
            }
        } else if (me.wrappedStuff.type == 'ingredients') {
            if (ExGods.app.user.getIngredientCountByName(me.wrappedStuff.params.id) < me.wrappedStuff.params.quantity) {
                data.decorators.push(ExGods.stuff.decorator.Disabled);
            }
        }
        //    - 
        me.replaceQuantityDecorator(data.decorators);
        return data;
    },
    /**
     *    -
     */
    replaceQuantityDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.Quantity);
        decorators.push(ExGods.view.fucina.stuff.decorator.RequiredQuantity);
    }
});

/**
 *    

     :
    
        type: 'fucina_prognoz',
        fucinaType: <String>
        sourceModel: <Object>
        params: {
            stuff: <Object>,
        },

 */
Ext.define('ExGods.view.fucina.stuff.FucinaPrognoz', {
    extend: ExGods.stuff.Composite,
    getImageData: function() {
        var me = this,
            data = me.callParent();
        if (me.stuff.sourceModel.get('selected') && me.stuff.sourceModel.get('invalid')) {
            data.decorators.push(ExGods.stuff.decorator.Disabled);
        }
        if (me.wrappedStuff.type == 'iteminstance' && me.stuff.fucinaType == 'upgrade') {
            me.replaceItemGradeDecorator(data.decorators);
        }
        return data;
    },
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        data.sourceModel = me.stuff.sourceModel;
        me.replaceItemStats1Block(data.blocks);
        me.replaceItemStats2Block(data.blocks);
        if (me.wrappedStuff.type == 'iteminstance') {
            if (me.stuff.fucinaType == 'upgrade') {
                me.replaceItemGradeDecorator(data.decorators);
            } else if (me.stuff.fucinaType == 'enchant') {
                me.replaceFeaturesBlock(data.blocks);
            } else if (me.stuff.fucinaType == 'transmutation') {
                Ext.Array.insert(data.blocks, 1, [
                    ExGods.stuff.block.item.Description
                ]);
            }
        }
        return data;
    },
    /**
     *        +1 
     */
    replaceItemGradeDecorator: function(decorators) {
        Ext.Array.remove(decorators, ExGods.stuff.decorator.ItemGrade);
        decorators.push(ExGods.view.fucina.stuff.decorator.ItemGradePrognoz);
    },
    /**
     *     (, ..) 
     */
    replaceItemStats1Block: function(blocks) {
        var me = this,
            index = blocks.indexOf(ExGods.stuff.block.item.Stats1),
            fucinaType = me.stuff.fucinaType;
        if (fucinaType == 'transmutation') {
            Ext.Array.replace(blocks, index, 1, [
                ExGods.view.fucina.stuff.block.TransmuteStats1Prognoz
            ]);
        }
    },
    /**
     *     (, ..) 
     */
    replaceItemStats2Block: function(blocks) {
        var me = this,
            index = blocks.indexOf(ExGods.stuff.block.item.Stats2),
            fucinaType = me.stuff.fucinaType;
        if (fucinaType == 'upgrade') {
            Ext.Array.replace(blocks, index, 1, [
                ExGods.view.fucina.stuff.block.Stats2Prognoz
            ]);
        } else if (fucinaType == 'enchant') {
            Ext.Array.replace(blocks, index, 1, [
                ExGods.view.fucina.stuff.block.EmptyStats2
            ]);
        } else if (fucinaType == 'transmutation') {
            Ext.Array.replace(blocks, index, 1, [
                ExGods.view.fucina.stuff.block.TransmuteStats2Prognoz
            ]);
        }
    },
    /**
     *    ,    "" 
     */
    replaceFeaturesBlock: function(blocks) {
        var index = blocks.indexOf(ExGods.stuff.block.item.Features);
        Ext.Array.replace(blocks, index, 1, [
            ExGods.view.fucina.stuff.block.FeaturesPrognoz
        ]);
    }
});

/**
 *    

     :
    
        type: 'fucina_result',
        fucinaType: <String>
        params: {
            stuff: <Object>,
        }
        workData: <Object> //      ({result: <Object>, was_result: <Object>, work: <Object>, etc })

 */
Ext.define('ExGods.view.fucina.stuff.FucinaResult', {
    extend: ExGods.stuff.Composite,
    getDetailsData: function() {
        var me = this,
            data = me.callParent();
        data.decorators.push(ExGods.stuff.decorator.Quantity);
        if (me.stuff.fucinaType == 'transmutation') {
            me.replaceItemStats1Block(data.blocks);
        }
        if (me.wrappedStuff.type == 'iteminstance') {
            me.replaceItemStats2Block(data.blocks);
        }
        data.workData = me.stuff.workData;
        //     
        return data;
    },
    /**
     *     ,        
     */
    replaceItemStats1Block: function(blocks) {
        var index = blocks.indexOf(ExGods.stuff.block.item.Stats1);
        Ext.Array.replace(blocks, index, 1, [
            ExGods.view.fucina.stuff.block.TransmuteStats1Prognoz
        ]);
    },
    /**
     *     ,        
     */
    replaceItemStats2Block: function(blocks) {
        var index = blocks.indexOf(ExGods.stuff.block.item.Stats2);
        Ext.Array.replace(blocks, index, 1, [
            ExGods.view.fucina.stuff.block.Stats2Result
        ]);
    }
});

/**
 *  + 1    
 */
Ext.define('ExGods.view.fucina.stuff.decorator.ItemGradePrognoz', {
    extend: ExGods.stuff.decorator.ItemGrade,
    statics: {
        /**
        * @override
        */
        getGrade: function(data) {
            return data.itemModel && data.itemModel.isUpgraded() ? data.itemModel.get('param').upgrades + 1 : 1;
        }
    }
});

/**
 *  "-  "
 */
Ext.define('ExGods.view.fucina.stuff.decorator.RequiredQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getCls: function(data) {
            var cls = 'fucina-stuff-decorator-required-quantity',
                userQuantity = this.getUserQuantityOfStuff(data),
                requiredQuantity = data.stuff.params.quantity || 0;
            if (!data.resultInfo && requiredQuantity > userQuantity) {
                cls += ' fucina-stuff-decorator-required-quantity-red';
            }
            return cls;
        },
        /**
         * @override
         */
        getQuantity: function(data) {
            var userQuantity, requiredQuantity;
            if (data.resultInfo) {
                return data.resultInfo.min + ' - ' + data.resultInfo.max;
            } else {
                userQuantity = this.getUserQuantityOfStuff(data);
                requiredQuantity = data.stuff.params.quantity || 0;
                if (data.stuff.type == 'currency') {
                    return requiredQuantity;
                } else {
                    return userQuantity + '/' + requiredQuantity;
                }
            }
        },
        /**
         *   -           
         */
        getUserQuantityOfStuff: function(data) {
            var userQuantity = 0;
            if (data.stuff.type == 'currency') {
                userQuantity = ExGods.app.user.get('money')[data.stuff.params.id];
            } else if (data.stuff.type == 'item') {
                userQuantity = ExGods.app.user.slots().getItemCount(data.stuff.params.id);
            } else if (data.stuff.type == 'ingredients') {
                userQuantity = ExGods.app.user.getIngredientCountByName(data.stuff.params.id);
            }
            return userQuantity;
        }
    }
});

/**
 *  "-"   
 */
Ext.define('ExGods.view.fucina.stuff.decorator.SourceQuantity', {
    extend: ExGods.stuff.decorator.Quantity,
    statics: {
        /**
         * @override
         */
        getQuantity: function(data) {
            var quantity = this.superclass.self.getQuantity(data);
            if (quantity == 1) {
                return false;
            } else {
                return quantity;
            }
        }
    }
});

/**
 *    (   )
 */
Ext.define('ExGods.view.fucina.stuff.block.EmptyStats2', {
    extend: ExGods.stuff.block.item.Stats2,
    statics: {
        /**
         * @override
         */
        getStatsChanged: function(data) {
            return {};
        }
    }
});

/**
 *   " "
 */
Ext.define('ExGods.view.fucina.stuff.block.ClothedTextSource', {
    extend: ExGods.stuff.Block,
    statics: {
        /**
         * @override
         */
        getContent: function(data) {
            return '<div style="text-align: center; font-weight: bold; padding: 0 10px;">' + ExGods.getMsgByKey('fucina_putedon_item') + '</div>';
        }
    }
});

/**
 *        (    )
 */
Ext.define('ExGods.view.fucina.stuff.block.Stats2Prognoz', {
    extend: ExGods.stuff.block.item.Stats2,
    statics: {
        /**
         * @override
         */
        getStatsChanged: function(data) {
            var changes = {};
            Ext.Object.each(data.protoModel.data.data.stats, function(key, value) {
                changes[key] = '<span class="up">+?</span>';
            });
            return changes;
        }
    }
});

/**
 *       (        )
 */
Ext.define('ExGods.view.fucina.stuff.block.Stats2Result', {
    extend: ExGods.stuff.block.item.Stats2,
    statics: {
        /**
         * @override
         */
        getItemStats: function(data) {
            var changes = this.getStatsChanged(data),
                stats = this.superclass.self.getItemStats(data);
            //   
            //      
            // Ext.Object.each(changes, function(key, value) {
            //  if (stats[key]) {
            //      stats[key] += value;
            //  }
            // });
            return stats;
        },
        /**
         * @override
         */
        getStatsChanged: function(data) {
            var changes = {},
                newStats = {},
                oldStats = {};
            if (data.workData && data.workData.result && data.workData.result.param.stat) {
                newStats = Ext.clone(data.workData.result.param.stat);
            }
            if (data.workData && data.workData.work && data.workData.work.source_data && data.workData.work.source_data.param.stat) {
                oldStats = Ext.clone(data.workData.work.source_data.param.stat);
            }
            Ext.Object.each(newStats, function(key, value) {
                changes[key] = value - (oldStats[key] || 0);
            });
            return changes;
        },
        /**
         * @override
         */
        getStatsMax: function(data) {
            var max = {};
            if (data.workData && data.workData.was_result && data.workData.was_result.list && data.workData.was_result.list.length) {
                data.workData.was_result.list.forEach(function(item) {
                    if (item.type == 'stat') {
                        max[item.data] = item.max;
                    }
                });
            }
            return max;
        }
    }
});

/**
 *      
 */
Ext.define('ExGods.view.fucina.stuff.block.FeaturesPrognoz', {
    extend: ExGods.stuff.block.item.Features,
    statics: {
        /**
         * @override
         */
        getFeaturesData: function(data) {
            var features = [];
            //   ,   ""   
            Ext.Array.each(data.protoModel.get('action_full') || [], function(action) {
                if (action.type == 'feature' && action.only_proto) {
                    features.push(action);
                }
            });
            return features;
        }
    }
});

/**
 *        (, .. )
 *      
 */
Ext.define('ExGods.view.fucina.stuff.block.TransmuteStats1Prognoz', {
    extend: ExGods.stuff.block.item.Stats1,
    statics: {
        /**
         * @override
         */
        getContent: function(data) {
            var content = this.superclass.self.getContent(data);
            var expireTime = this.getExpirationTime(data);
            if (expireTime) {
                content.push([
                    ExGods.getMsgByKey('item_expire_after'),
                    '',
                    ExGods.util.Time.printRestTime(expireTime, {
                        format: 'short'
                    })
                ]);
            }
            return content;
        },
        /**
         *        ()
         */
        getExpirationTime: function(data) {
            var me = this;
            if (data.protoModel.data.data.expire_after) {
                return ExGods.util.Date.parseString(data.protoModel.data.data.expire_after);
            }
        }
    }
});

/**
 *       
 */
Ext.define('ExGods.view.fucina.stuff.block.TransmuteStats2Prognoz', {
    extend: ExGods.stuff.block.item.Stats2,
    statics: {
        /**
         * @override
         */
        getStatsChanged: function(data) {
            var changes = {},
                itemStats = {},
                sourceStats = {},
                sourceProto;
            itemStats = this.superclass.self.getItemStats(data);
            sourceProto = ExGods.app.getItemPrototypesStore().getById(parseInt(data.sourceModel.data.source_data.proto_id));
            if (sourceProto) {
                sourceStats = Ext.clone(sourceProto.data.data.stats);
                if (data.sourceModel.data.source_data.param && data.sourceModel.data.source_data.param.stat) {
                    Ext.Object.each(data.sourceModel.data.source_data.param.stat, function(key, value) {
                        sourceStats[key] += value;
                    });
                }
            }
            Ext.Object.each(itemStats, function(key, value) {
                changes[key] = value - (sourceStats[key] || 0);
            });
            return changes;
        }
    }
});

/**
 *     -  
 */
Ext.define('ExGods.view.stone.Tab', {
    extend: Ext.tab.Tab,
    alias: 'widget.stonetab',
    /**
     *     
     */
    counter: 0,
    border: 0,
    height: 47,
    margin: 0,
    width: 47,
    ui: 'stone',
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.counterEl = me.btnEl.insertHtml('beforeEnd', '<div class="counter">' + me.counter + '</div>', true);
        me.counterEl.setVisibilityMode(Ext.Element.DISPLAY);
        me.counterEl[me.counter ? 'show' : 'hide']();
    },
    addCount: function(value) {
        var me = this;
        me.counter += value;
        if (me.counterEl) {
            me.counterEl[me.counter ? 'show' : 'hide']();
            me.counterEl.setHTML(me.counter);
        }
    },
    reset: function() {
        var me = this;
        me.counter = 0;
        if (me.counterEl) {
            me.counterEl.hide();
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.stone.TabPanel', {
    extend: Ext.tab.Panel,
    alias: 'widget.stonetabpanel',
    activeTab: 0,
    /**
     * @cfg
     */
    tabUi: 'stone',
    // stone  stonetext
    constructor: function(config) {
        var me = this;
        config.tabBar = Ext.apply({
            height: 60,
            layout: {
                align: 'top'
            },
            margin: '0 0 -16 0',
            padding: '11 5 0 38',
            ui: 'stone',
            style: {
                'z-index': 1
            }
        }, config.tabBar || {});
        me.callParent(arguments);
    },
    onAdd: function(item, index) {
        var me = this;
        if (!item.tabConfig) {
            item.tabConfig = {};
        }
        Ext.applyIf(item.tabConfig, {
            xtype: 'stonetab',
            ui: me.tabUi,
            width: me.cls == 'inventory_tabpanel' ? 120 : me.tabUi == 'stone' ? 47 : 198
        });
        me.callParent(arguments);
    }
});

/**
 *  
 */
Ext.define('ExGods.view.fucina.FucinaTabs', {
    extend: ExGods.view.stone.TabPanel,
    alias: 'widget.fucinatabs',
    cls: 'fucinatabs',
    /**
     * @cfg service {ExGods.service.Fucina}  
     */
    service: null,
    plugins: [
        'stonedeco'
    ],
    closable: true,
    bodyPadding: '0 20 10 10',
    width: 660,
    height: 420,
    y: 5,
    x: 210,
    layout: {
        type: 'absolute'
    },
    /**
     * @property filters [Array]
     */
    filters: [],
    initComponent: function() {
        var me = this;
        me.hidden = me.service.data.fucina.data.result;
        me.initFiltersBar();
        me.initTabs();
        me.callParent(arguments);
        me.mon(me.service, 'update', me.onServiceUpdate, me);
    },
    /*************** PRIVATES *******************/
    initTabs: function() {
        var me = this,
            currentTabIndex = 0,
            tabs = [];
        //     
        me.service.data.fucina.entry_list.forEach(function(fucina, index) {
            var itemSources = [],
                forceSourceId;
            if (me.service.data.fucina.current == fucina.entry) {
                currentTabIndex = index;
                itemSources = me.service.data.fucina.data.source;
                forceSourceId = me.service.data.fucina.data.force_source_id;
            }
            tabs.push({
                xtype: 'fucina',
                tabConfig: {
                    xtype: 'fucinatab',
                    fucinaType: fucina.fucina_type,
                    tooltip: fucina.desc.desc,
                    icon: IMAGE_URL + fucina.desc.img,
                    counter: fucina.count
                },
                itemSources: itemSources,
                fucinaData: fucina,
                forceSourceId: forceSourceId,
                itemId: 'fucina-' + fucina.entry
            });
        });
        if (!me.rendered) {
            me.activeTab = currentTabIndex;
            me.items = tabs;
            me.on('afterrender', function() {
                me.on('beforetabchange', me.onBeforeTabChange, me);
            });
        } else {
            me.un('beforetabchange', me.onBeforeTabChange, me);
            me.removeAll();
            ExGods.Resources.load({
                items: {
                    items: tabs
                },
                getResources: function() {
                    return {
                        images: []
                    };
                }
            }, function() {
                me.add(tabs);
                me.setActiveTab('fucina-' + me.service.data.fucina.current);
                me.on('beforetabchange', me.onBeforeTabChange, me);
            });
        }
    },
    onBeforeTabChange: function(tabPanel, newTab) {
        var me = this;
        me.fireEvent('fucina-tab-click', me, newTab.fucinaData.entry);
        return false;
    },
    onServiceUpdate: function() {
        var me = this;
        if (me.service.data.fucina.data.result) {
            me.suspendEvents();
            //     'beforetabchange'
            me.removeAll();
            me.resumeEvents();
            me.hide();
        } else {
            me.initTabs();
            me.show();
        }
    },
    initFiltersBar: function() {
        var me = this;
        me.dockedItems = [
            {
                dock: 'top',
                items: [
                    {
                        layout: {
                            type: 'hbox',
                            pack: 'end'
                        },
                        defaults: {
                            xtype: 'checkboxfield',
                            checked: true,
                            listeners: {
                                change: me.onFilterChange,
                                scope: me
                            }
                        },
                        items: [
                            {
                                boxLabel: ExGods.getMsgByKey('fucina_filter_checkbox_items'),
                                name: 'type_item',
                                padding: '0 15 0 0'
                            },
                            {
                                boxLabel: ExGods.getMsgByKey('fucina_filter_checkbox_ingredients'),
                                name: 'type_ingredient'
                            }
                        ]
                    }
                ],
                margin: '21 80 -45 280',
                style: {
                    'z-index': 2
                }
            }
        ];
    },
    onFilterChange: function(checkbox) {
        var me = this,
            activeView = me.getActiveTab();
        activeView.setFilter(checkbox.name, checkbox.getValue());
        activeView.applyFilters();
    }
});

/**
 *   
 */
Ext.define('ExGods.view.fucina.Result', {
    extend: Ext.Panel,
    alias: 'widget.fucinaresult',
    cls: 'fucina-result',
    width: 627,
    height: 367,
    y: 5,
    x: 210,
    padding: '8 0 0 5',
    layout: {
        type: 'absolute'
    },
    plugins: [
        'skinpaperdeco'
    ],
    /**
     * @cfg service {ExGods.service.Fucina} service
     */
    initComponent: function() {
        var me = this;
        me.hidden = true;
        me.cls = me.cls + ' fucina-result-' + me.service.data.fucina.fucina_type;
        me.tpl = [
            '<tpl if="values.data.work">',
            // 
            '<div class="fucina-result-item">',
            '<div class="paper-title title">' + ExGods.getMsgByKey('fucina_result') + '</div>',
            '<div>{[ this.printFucinaResult(values) ]}</div>',
            '</div>',
            '<div class="v-separator"></div>',
            //   //
            '<div class="fucina-result-resources {[ values.data.no_replay ? "no-replay" : "" ]}">',
            '<div class="paper-title title">' + ExGods.getMsgByKey('fucina_result_more') + '</div>',
            '{[ this.printRequiredResources(values) ]}',
            '<span class="fucina-result-replay-btn-tip">' + ExGods.getMsgByKey('fucina_result_more2') + '</span>',
            '<div class="component fucina-result-replay-btn">',
            '<span role="xtype">textbutton</span>',
            '<span role="disabled:bool">{[ values.data.invalid ? true : false ]}</span>',
            '<span role="cls">x-btn-txt-green no_border</span>',
            '<span role="action">fucina-result-replay</span>',
            '<span role="minWidth:int">90</span>',
            '<span role="text">',
            '{[ this.printButtonText(values) ]}',
            '</span>',
            '</div>',
            '<div class="separator"></div>',
            '</div>',
            //  //
            '<div class="fucina-rewards">',
            '<div class="paper-title title">' + ExGods.getMsgByKey('fucina_result_bonus') + '</div>',
            '<tpl if="values.data.reward">',
            '{[ ExGods.stuff.StuffManager.image(values.data.reward) ]}',
            '</tpl>',
            '<div class="component fucina-result-finish-btn">',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">no_border qh-object</span>',
            '<span role="action">fucina-result-finish</span>',
            '<span role="qh:object">{[this.getQuestHelperInfo(values)]}</span>',
            '<span role="minWidth:int">170</span>',
            '<span role="text">' + ExGods.getMsgByKey('fucina_finish') + '</span>',
            '</div>',
            '</div>',
            '</tpl>',
            {
                printFucinaResult: function(values) {
                    var stuff, wrappedStuff;
                    if (Ext.isArray(values.data.result)) {
                        if (values.data.result.length == 1) {
                            wrappedStuff = values.data.result[0].stuff;
                        } else {
                            wrappedStuff = [];
                            values.data.result.forEach(function(item) {
                                wrappedStuff.push(item.stuff);
                            });
                        }
                    } else if (values.data.result.proto_id) {
                        wrappedStuff = {
                            type: 'iteminstance',
                            params: {
                                itemModel: Ext.create('ExGods.model.Item', values.data.result)
                            }
                        };
                    } else {
                        wrappedStuff = values.data.result;
                    }
                    if (wrappedStuff.length) {
                        stuff = [];
                        wrappedStuff.forEach(function(item) {
                            stuff.push({
                                type: 'fucina_result',
                                params: {
                                    stuff: item
                                },
                                workData: values.data,
                                fucinaType: me.service.data.fucina.fucina_type
                            });
                        });
                    } else {
                        stuff = {
                            type: 'fucina_result',
                            params: {
                                stuff: wrappedStuff
                            },
                            workData: values.data,
                            fucinaType: me.service.data.fucina.fucina_type
                        };
                    }
                    return ExGods.stuff.StuffManager.details(stuff);
                },
                printRequiredResources: function(values) {
                    var stuff = [],
                        workSourceModel;
                    if (values.data.was_required && values.data.was_required.length) {
                        stuff = values.data.was_required;
                    }
                    if (values.fucina_type == 'fragmentation') {
                        workSourceModel = Ext.create('ExGods.model.FucinaSourceItem', values.data.work);
                        stuff.push(workSourceModel.data.stuff);
                    }
                    return ExGods.stuff.StuffManager.image(stuff);
                },
                printButtonText: function(values) {
                    var price = '';
                    if (values.data.price) {
                        price = ExGods.util.Stuff.printStuff(values.data.price);
                    }
                    return ExGods.getMsgByKey('fucina_rerol') + ' ' + price;
                },
                getQuestHelperInfo: function(values) {
                    return JSON.stringify({
                        'data-qh_otype': 'forge_type_ready_button',
                        'data-qh_oid': me.service.data.fucina.fucina_type
                    });
                }
            }
        ];
        me.config.data = {};
        me.mon(me.service, 'update', me.onServiceUpdate, me);
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.showHideResult();
    },
    /**
     * @private
     */
    onServiceUpdate: function() {
        var me = this;
        me.showHideResult();
    },
    /**
     *         
     */
    showHideResult: function() {
        var me = this,
            fucinaResultStuff, sourceModel;
        if (me.service.data.fucina.data.result) {
            if (me.rendered) {
                me.update(me.service.data.fucina);
                me.renderTemplateComponents();
                me.show();
            }
        } else {
            if (me.rendered) {
                me.hide();
            }
        }
    },
    /**
     *   
     */
    renderTemplateComponents: function() {
        var me = this;
        ExGods.helpme.renderComponents(me.el, me);
        //     ,   
        setTimeout(function() {
            Ext.Array.each(me.query('textbutton'), function(btn) {
                btn.updateLayout();
            });
        }, 0);
    }
});

/**
 *  - 
 *    ,  , .
 */
Ext.define('ExGods.model.FucinaSourceItem', {
    extend: Ext.data.Model,
    idProperty: 'source_id',
    fields: [
        {
            // id 
            name: 'source_id',
            type: 'string'
        },
        {
            //   (item, stuff)
            name: 'source_type',
            type: 'string'
        },
        {
            //  
            name: 'source_data',
            type: 'auto'
        },
        {
            //     
            name: 'stuff',
            convert: function(v, record) {
                if (record.data.source_type == 'stuff') {
                    return {
                        params: {
                            stuff: record.data.source_data
                        },
                        sourceModel: record,
                        type: 'fucina_source'
                    };
                } else if (record.data.source_type == 'item') {
                    return {
                        params: {
                            stuff: {
                                type: 'iteminstance',
                                params: {
                                    itemModel: Ext.create('ExGods.model.Item', record.data.source_data)
                                }
                            }
                        },
                        sourceModel: record,
                        type: 'fucina_source'
                    };
                }
            }
        },
        {
            //    
            name: 'reward',
            type: 'auto'
        },
        {
            //    
            name: 'result',
            type: 'auto'
        },
        {
            //    
            name: 'required',
            type: 'auto'
        },
        {
            //  
            name: 'price',
            type: 'auto'
        },
        {
            //   
            name: 'invalid',
            type: 'auto'
        },
        {
            //      
            name: 'selected',
            type: 'auto'
        }
    ]
});

/**
 *         DOM- 
 */
Ext.define('ExGods.view.plugin.QuestHelperTarget', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.qh_target',
    /**
     * @cfg {Object} target     {type: <String>, id: <String>, opts: <Object>}
     */
    target: null,
    init: function(cmp) {
        var me = this;
        cmp.on('render', this.onRender, this);
    },
    onRender: function() {
        var me = this,
            cmp = me.cmp;
        if (me.target) {
            cmp.el.addCls('qh-object');
            cmp.el.set({
                'data-qh_otype': me.target.type,
                'data-qh_oid': me.target.id,
                'data-qh_opts': me.target.opts ? Ext.htmlEncode(JSON.stringify(me.target.opts)) : ''
            });
        }
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.onRender, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'interface/quest_helper/item.png'
            ]
        };
    }
});

/**
 *     -  
 */
Ext.define('ExGods.view.fucina.Tab', {
    extend: ExGods.view.stone.Tab,
    alias: 'widget.fucinatab',
    cls: 'fucinatab',
    /**
     * @cfg {String} fucinaType  
     */
    fucinaType: '',
    initComponent: function() {
        var me = this;
        me.plugins = [
            {
                ptype: 'qh_target',
                target: {
                    type: 'forge_type',
                    id: me.fucinaType,
                    opts: {
                        cls: 'flip-h'
                    }
                }
            }
        ];
        me.callParent(arguments);
    }
});

/**
 * 
 */
Ext.define('ExGods.view.fucina.Fucina', {
    extend: Ext.Panel,
    alias: 'widget.fucina',
    layout: 'absolute',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.Highlightable
    ],
    /**
     * @cfg itemSources {Array} ,      
     */
    itemSources: [],
    /**
     * @cfg fucinaData {Object}  
     */
    fucinaData: {},
    /**
     * @cfg forceSourceId {Number} ID     
     */
    forceSourceId: null,
    /**
     * @property store {Ext.data.Store}  
     */
    store: null,
    /**
     * @property filters {Array}    
     */
    filters: {},
    initComponent: function() {
        var me = this;
        me.cls = 'fucina ' + 'fucina-' + me.fucinaData.fucina_type;
        me.store = me.initItemSourcesStore();
        me.gridView = Ext.widget('slotsgrid', {
            height: 320,
            x: 312,
            y: 36,
            store: me.store,
            autoShow: false,
            bodyPadding: '35 7px 3px 8px',
            style: {
                background: 'url(' + IMAGE_URL + 'fucina/fucina_frm.png) -3px 24px no-repeat'
            },
            calcWidth: function() {
                this.width = 256 + 22;
            },
            // 22 -   
            itemSelector: '.exg-grid-item',
            itemTpl: [
                '<div class="qh-object" data-qh_otype="forge_item" data-qh_oid="{[ values.source_type == "item" ? values.source_data.proto_id : "" ]}">',
                '{[ ExGods.stuff.StuffManager.image(values.stuff) ]}',
                '</div>'
            ],
            pager: {
                marginRight: -27,
                textTop: 301
            },
            listeners: {
                afterrender: function(view) {
                    me.initDragAndDrop();
                    view.el.on('click', function(e, t) {
                        Ext.fly(t).parent().down('.exg-stuff-item').dom.click();
                    }, me, {
                        delegate: '.qh-pointer'
                    });
                }
            },
            plugins: [
                {
                    ptype: 'frame_title',
                    text: ExGods.getMsgByKey('inventory_title_text'),
                    size: '4slots'
                }
            ]
        });
        me.anvilView = Ext.widget('fucinaanvil', {
            width: 282,
            height: 320,
            x: 29,
            y: 36,
            bodyPadding: '41 0 0 0',
            autoShow: false,
            plugins: [
                {
                    ptype: 'frame_title',
                    text: me.fucinaData.desc.label,
                    size: '0slots'
                }
            ],
            fucinaType: me.fucinaData.fucina_type,
            bodyStyle: {
                margin: '-18px 0 0 0'
            },
            listeners: {
                startdrag: function() {
                    me.highlight(true);
                },
                stopdrag: function() {
                    me.highlight(false);
                }
            }
        });
        me.on({
            'activate': function() {
                me.gridView.showPager();
            },
            'deactivate': function() {
                me.gridView.hidePager();
            },
            startdrag: function() {
                me.anvilView.highlight(true);
            },
            stopdrag: function() {
                me.anvilView.highlight(false);
            },
            scope: me
        });
        me.items = [
            me.gridView,
            me.anvilView
        ];
        me.margin = '-25 0 0 0';
        me.callParent();
    },
    /**
     *      
     */
    setFilter: function(type, value) {
        var me = this;
        if (type == 'type_item') {
            me.setTypeItemFilter(value);
        } else if (type == 'type_ingredient') {
            me.setTypeIngredientFilter(value);
        }
    },
    /**
     *  
     */
    applyFilters: function() {
        var me = this,
            filters = [];
        for (var filterName in me.filters) {
            if (me.filters.hasOwnProperty(filterName)) {
                filters.push(me.filters[filterName]);
            }
        }
        me.store.clearFilter();
        me.store.filter(filters);
    },
    /**
     *  
     */
    clearFilters: function() {
        var me = this;
        me.filters = {};
        me.store.clearFilter();
    },
    /****************** PRIVATES ************************/
    afterRender: function() {
        var me = this,
            sourceModel;
        me.callParent(arguments);
        if (me.forceSourceId) {
            sourceModel = me.store.getById(me.forceSourceId);
            if (!sourceModel) {
                // source_id     <proto_id>:<slot_id>:<item_id>,  forceSourceId   <proto_id>
                //     
                me.store.each(function(item) {
                    if (item.data.source_id.split(':')[0] == me.forceSourceId) {
                        sourceModel = item;
                    }
                });
            }
            if (sourceModel) {
                ExGods.app.getController('Fucina').doPutSource(sourceModel);
            }
        }
    },
    initItemSourcesStore: function() {
        var me = this;
        return Ext.create('Ext.data.Store', {
            model: 'ExGods.model.FucinaSourceItem',
            data: me.itemSources,
            sorters: [
                {
                    sorterFn: function(o1, o2) {
                        if (!o1 || !o2)  {
                            return 0;
                        }
                        
                        var item1Invalid = (o1.data.invalid) ? 1 : 0;
                        var item2Invalid = (o2.data.invalid) ? 1 : 0;
                        if (item1Invalid == item2Invalid) {
                            var item1Type = (o1.data.source_data.type == 'item' || o1.data.source_type == 'item') ? 1 : 0;
                            var item2Type = (o2.data.source_data.type == 'item' || o2.data.source_type == 'item') ? 1 : 0;
                            if (item1Type == item2Type) {
                                var item1Upgrd = 0;
                                var item2Upgrd = 0;
                                if (o1.data.source_data.param && o1.data.source_data.param.upgrades) {
                                    item1Upgrd = o1.data.source_data.param.upgrades;
                                }
                                if (o2.data.source_data.param && o2.data.source_data.param.upgrades) {
                                    item2Upgrd = o2.data.source_data.param.upgrades;
                                }
                                if (item1Upgrd == item2Upgrd) {
                                    //      ,    .   id 
                                    if (o1.data.source_id < o2.data.source_id) {
                                        return -1;
                                    } else if (o1.data.source_id > o2.data.source_id) {
                                        return 1;
                                    } else {
                                        return 0;
                                    }
                                } else {
                                    if (me.fucinaData.fucina_type == 'fragmentation') {
                                        return (item1Upgrd < item2Upgrd) ? -1 : 1;
                                    } else {
                                        return (item1Upgrd < item2Upgrd) ? 1 : -1;
                                    }
                                }
                            } else {
                                return (item1Type < item2Type) ? 1 : -1;
                            }
                        } else {
                            return (item1Invalid < item2Invalid) ? -1 : 1;
                        }
                    }
                }
            ]
        });
    },
    /**
     *   ExGods.mixin.Highlightable
     */
    getHighlitableTarget: function() {
        var me = this;
        return Ext.fly(me.gridView.itemsView.getEl().down('.exg-grid-inner'));
    },
    /**
     * @private
     */
    initDragAndDrop: function() {
        var me = this;
        me.initDrag({
            view: me.gridView.itemsView
        });
        me.initDrop({
            view: me.gridView.itemsView,
            onDrop: function(target, dd, e, data) {
                ExGods.app.getController('Fucina').doPutOffSource(data.item);
                return false;
            }
        });
    },
    /**
     *      ""
     */
    setTypeItemFilter: function(value) {
        var me = this;
        if (!value) {
            me.filters['type_item'] = new Ext.util.Filter({
                filterFn: function(item) {
                    return item.data.source_type != "item";
                }
            });
        } else {
            delete me.filters['type_item'];
        }
    },
    /**
     *      ""
     */
    setTypeIngredientFilter: function(value) {
        var me = this;
        if (!value) {
            me.filters['type_ingredient'] = new Ext.util.Filter({
                filterFn: function(item) {
                    return item.data.source_type != "stuff";
                }
            });
        } else {
            delete me.filters['type_ingredient'];
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        if (me.store.data.items) {
            for (var i = 0; i < me.store.data.items.length; i++) {
                var itm = me.store.data.items[i].data;
                if (itm.price.stuff) {
                    stuff_arr.concat(itm.price.stuff);
                }
                if (itm.reward) {
                    stuff_arr.concat(itm.reward);
                }
                if (itm.result) {
                    for (var j = 0; j < itm.result.length; j++) {
                        stuff_arr.push(itm.result[j].data);
                    }
                }
            }
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [
                IMAGE_URL + 'fucina/fucina_frm.png',
                IMAGE_URL + me.fucinaData.desc.img,
                //   CSS
                IMAGE_URL + 'interface/quest_helper/item.png',
                IMAGE_URL + 'fucina/arrow_down.png',
                IMAGE_URL + 'interface/quest_helper/item.png',
                IMAGE_URL + 'slots/slot_regular.png',
                IMAGE_URL + 'fucina/icon_bg_slot.png',
                IMAGE_URL + 'fucina/fucina_frm_top_small.png',
                IMAGE_URL + 'fucina/arrow.png',
                IMAGE_URL + 'fucina/arrow_up.png',
                IMAGE_URL + 'fucina/checkbox_grey.png',
                IMAGE_URL + 'fucina/checkbox_grey_checked.png',
                IMAGE_URL + 'interface/quest_helper/item.png',
                IMAGE_URL + 'interface/quest_helper/item.png'
            ].concat(arr_images)
        };
    }
});

/**
 *       
 */
Ext.define('ExGods.view.plugin.FrameTitle', {
    extend: Ext.AbstractPlugin,
    alias: 'plugin.frame_title',
    size: '5slots',
    //  : 5slots, 4slots, 0slots
    init: function(cmp) {
        cmp.on('render', this.addTitle, this);
    },
    addTitle: function() {
        var me = this,
            cmp = me.cmp;
        cmp.el.insertHtml('afterBegin', '<div class="exg-frame-title exg-frame-title-' + me.size + '">' + '<div class="exg-frame-title-text">' + me.text + '</div>' + '<div class="exg-frame-title-text exg-frame-title-text2">' + me.text + '</div>' + '</div>');
    },
    destroy: function() {
        var me = this;
        me.cmp.un('render', me.addTitle, me);
        me.cmp = null;
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: [
                IMAGE_URL + 'inventory/frm_top.png',
                IMAGE_URL + 'fucina/fucina_frm_top.png',
                IMAGE_URL + 'fucina/fucina_frm_top_small.png'
            ]
        };
    }
});

/**
 * ,      ,    
 */
Ext.define('ExGods.view.fucina.Anvil', {
    extend: Ext.Panel,
    alias: 'widget.fucinaanvil',
    cls: 'fucina-anvil',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.ItemDroppable,
        ExGods.mixin.Highlightable
    ],
    /**
     * @cfg sourceModel {ExGods.model.FucinaSourceItem} sourceModel
     */
    /**
     * @cfg fucinaType {String}  
     */
    initComponent: function() {
        var me = this;
        me.tpl = [
            //    
            '<div class="anvil">',
            '<div class="fucina-anvil-slot fucina-anvil-target-slot">',
            '<div class="fucina-anvil-target-slot-inner">',
            '<tpl if="values.sourceModel">',
            '{[ ExGods.stuff.StuffManager.image(values.sourceModel.data.stuff) ]}',
            '</tpl>',
            '</div>',
            '</div>',
            '<div class="fucina-arrow fucina-anvil-prognoz-arrow"></div>',
            '<div class="fucina-anvil-slot fucina-anvil-prognoz-slot">',
            '<tpl if="values.sourceModel">',
            '{[ this.printPrognoz(values) ]}',
            '</tpl>',
            '</div>',
            '</div>',
            //  
            '<div class="component anvil-btn">',
            '<span role="xtype">textbutton</span>',
            '<span role="cls">x-btn-txt-green stone_double_btn in_one_row qh-object</span>',
            '<span role="disabled:bool">{[ values.sourceModel && !values.sourceModel.data.invalid ? false : true ]}</span>',
            '<span role="qh:object">{[this.getQuestHelperInfo(values)]}</span>',
            '<span role="action">fucina-make</span>',
            '<span role="width:int">110</span>',
            '<span role="text">',
            '{[ this.printButtonText() ]}',
            '</span>',
            '</div>',
            '<div class="fucina-arrow fucina-arrow-action"></div>',
            //   (  )
            '<ul class="resources-list">',
            '<li class="fucina-anvil-slot">',
            '{[ this.printResource(0) ]}',
            '</li>',
            '<li class="fucina-anvil-slot">',
            '{[ this.printResource(1) ]}',
            '</li>',
            '<li class="fucina-anvil-slot">',
            '{[ this.printResource(2) ]}',
            '</li>',
            '</ul>',
            {
                printPrognoz: function() {
                    var stuff = '',
                        proto;
                    if (me.fucinaType == 'transmutation') {
                        stuff = {
                            type: 'iteminstance',
                            params: {
                                itemModel: Ext.create('ExGods.model.Item', me.sourceModel.data.result)
                            }
                        };
                    } else {
                        stuff = me.sourceModel.data.stuff.params.stuff;
                    }
                    return ExGods.stuff.StuffManager.image({
                        type: "fucina_prognoz",
                        sourceModel: me.sourceModel,
                        fucinaType: me.fucinaType,
                        params: {
                            stuff: stuff
                        }
                    });
                },
                printResource: function(index) {
                    if (me.sourceModel) {
                        if (me.sourceModel.data.required && me.sourceModel.data.required.length) {
                            if (me.sourceModel.data.required[index]) {
                                return ExGods.stuff.StuffManager.image({
                                    type: "fucina_resource",
                                    params: {
                                        stuff: me.sourceModel.data.required[index]
                                    }
                                });
                            }
                        } else if (me.sourceModel.data.result && me.sourceModel.data.result.length) {
                            if (me.sourceModel.data.result[index] && me.sourceModel.data.result[index].data) {
                                return ExGods.stuff.StuffManager.image({
                                    type: "fucina_resource",
                                    params: {
                                        stuff: me.sourceModel.data.result[index].data
                                    },
                                    resultInfo: me.sourceModel.data.result[index]
                                });
                            }
                        }
                    }
                },
                printButtonText: function() {
                    if (me.sourceModel && me.sourceModel.data.price && me.sourceModel.data.price.stuff && me.sourceModel.data.price.stuff.length) {
                        return ExGods.getMsgByKey("fucina_make") + " " + ExGods.util.Stuff.printStuff(me.sourceModel.data.price.stuff);
                    } else {
                        return ExGods.getMsgByKey("fucina_make_free");
                    }
                },
                getQuestHelperInfo: function(values) {
                    return JSON.stringify({
                        'data-qh_otype': 'forge_item_action_btn',
                        'data-qh_oid': values.sourceModel && !values.sourceModel.data.invalid && values.sourceModel.data.source_type == "item" ? values.sourceModel.data.source_data.proto_id : ""
                    });
                }
            }
        ];
        me.data = {};
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        ExGods.helpme.renderComponents(me.el, me);
        me.initDragAndDrop();
    },
    /**
     *    
     * @return {Ext.model.FucinaSourceItem}  
     */
    removeSourceModel: function() {
        var me = this,
            sourceModel;
        if (me.sourceModel) {
            sourceModel = me.sourceModel;
            me.sourceModel = null;
            me.updateView();
            sourceModel.set('selected', false);
            return sourceModel;
        }
    },
    /**
     *   
     */
    setSourceModel: function(sourceModel) {
        var me = this;
        me.sourceModel = sourceModel;
        me.sourceModel.set('selected', true);
        me.loadProtos(function() {
            ExGods.Resources.load(me, function() {
                me.updateView();
            });
        });
    },
    /**
     *   ExGods.mixin.Highlightable
     */
    getHighlitableTarget: function() {
        var me = this;
        return Ext.fly(me.getEl().down('.fucina-anvil-target-slot-inner'));
    },
    /************** PRIVATES **************/
    updateView: function() {
        var me = this;
        me.update({
            sourceModel: me.sourceModel
        });
        ExGods.helpme.destroyComponents(me.el);
        ExGods.helpme.renderComponents(me.el, me);
    },
    /**
     * @private
     */
    initDragAndDrop: function() {
        var me = this;
        me.initDrag({
            getSourceEl: function(e) {
                if (me.sourceModel && e.getTarget('.fucina-anvil-target-slot')) {
                    return Ext.get(e.getTarget('.exg-stuff-item'));
                }
            },
            getItem: function() {
                return me.sourceModel;
            }
        });
        me.initDrop({
            onDrop: function(target, dd, e, data) {
                ExGods.app.getController('Fucina').doPutSource(data.item);
                return true;
            }
        });
    },
    /**
     * @private
     */
    loadProtos: function(callback) {
        var me = this,
            paths = [
                'required.params.id',
                'result.proto_id'
            ];
        ExGods.helpme.loadProtos(me.sourceModel.data, paths.join('|'), function() {
            callback();
        });
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            stuff = undefined,
            arr_images = [];
        if (me.sourceModel) {
            if (me.fucinaType == 'transmutation') {
                stuff = {
                    type: 'iteminstance',
                    params: {
                        itemModel: Ext.create('ExGods.model.Item', me.sourceModel.data.result)
                    }
                };
            } else {
                stuff = me.sourceModel.data.stuff.params.stuff;
            }
            if (stuff) {
                stuff_arr.push(stuff);
            }
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [
                IMAGE_URL + 'fucina/arrow_up.png',
                IMAGE_URL + 'fucina/arrow_down.png'
            ].concat(arr_images)
        };
    }
});

/**
 *  
 *
 */
Ext.define('ExGods.controller.Fucina', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: true,
            wrap: true,
            error: true
        },
        prefix: 'Fucina:'
    },
    views: [
        'fucina.Tab',
        'fucina.FucinaTabs',
        'fucina.Fucina',
        'fucina.Anvil',
        'fucina.Result'
    ],
    models: [
        'FucinaSourceItem'
    ],
    init: function() {
        var me = this;
        me.service = ExGods.Services.get('fucina');
        me.service.on({
            update: me.onServiceUpdate,
            scope: me
        });
        me.control({
            'textbutton[action="fucina-make"]': {
                click: me.onMakeBtnClick
            },
            'textbutton[action="fucina-result-replay"]': {
                click: me.onReplayBtnClick
            },
            'textbutton[action="fucina-result-finish"]': {
                click: me.onFinishBtnClick
            }
        });
        ExGods.stuff.StuffManager.register({
            'fucina_source': {
                classObj: ExGods.view.fucina.stuff.FucinaSource,
                listeners: {
                    'put': me.onFucinaSourcePut,
                    'putoff': me.onFucinaSourcePutOff,
                    'scope': me
                }
            },
            'fucina_resource': ExGods.view.fucina.stuff.FucinaResource,
            'fucina_prognoz': ExGods.view.fucina.stuff.FucinaPrognoz,
            'fucina_result': ExGods.view.fucina.stuff.FucinaResult
        });
        me.user.on('item_on', me.onUserItemOnOff, me);
        me.user.on('item_off', me.onUserItemOnOff, me);
        ExGods.Components.addComponentInitializer('fucina', me.initFucinaComponent, me);
    },
    /**
     *  
     */
    initFucinaComponent: function(config, componentId) {
        var me = this,
            tabs = [],
            currentTabIndex = 0,
            cmp, wnd;
        if (Ext.getCmp(componentId)) {
            return;
        }
        wnd = Ext.widget('window1', {
            id: componentId,
            autoShow: false,
            closable: false,
            getResources: function() {
                return {
                    images: [
                        config.backgroundImage,
                        config.backImg
                    ]
                };
            }
        });
        ExGods.Resources.load({
            getResources: function() {
                return {
                    images: [
                        config.backgroundImage
                    ]
                };
            }
        }, function() {
            ExGods.app.getController('Location').maskLocation(function() {
                me.loadProtos(function() {
                    me.fucinaTabs = {
                        xtype: 'fucinatabs',
                        service: me.service,
                        listeners: {
                            beforeclose: {
                                fn: function() {
                                    ExGods.loaderCt.loadAndRemove(function() {
                                        wnd.close();
                                    }, {
                                        img: config.backgroundImage
                                    });
                                    return false;
                                }
                            },
                            'fucina-tab-click': me.onFucinaTabClick,
                            scope: me
                        }
                    };
                    me.fucinaResult = Ext.apply({
                        xtype: 'fucinaresult'
                    }, {
                        service: me.service
                    });
                    Ext.apply(config, {
                        closeBtnUI: 'stone',
                        rightPanelX: 220,
                        closeCallback: function() {
                            ExGods.loaderCt.loadAndRemove(function() {
                                wnd.close();
                            }, {
                                img: config.backgroundImage
                            });
                        },
                        margin: '0 10 10 0',
                        items: [
                            me.fucinaTabs,
                            me.fucinaResult
                        ],
                        backgroundImage: config.backImg
                    });
                    cmp = Ext.apply({
                        xtype: 'room'
                    }, config);
                    wnd.add(cmp);
                    me.fucinaTabs = wnd.down('fucinatabs');
                    ExGods.Resources.load(wnd, function() {
                        wnd.show();
                        ExGods.app.getController('Location').unmaskLocation();
                    });
                });
            }, {
                img: config.backgroundImage
            });
        });
        return wnd;
    },
    /**
     *    
     */
    doPutSource: function(sourceModel) {
        var me = this,
            fucinaView = me.fucinaTabs.getActiveTab();
        if (fucinaView) {
            //    
            if (fucinaView.anvilView.sourceModel) {
                fucinaView.store.add(fucinaView.anvilView.removeSourceModel());
            }
            //    
            fucinaView.anvilView.setSourceModel(sourceModel);
            fucinaView.store.remove(sourceModel);
        }
    },
    /**
     *  
     */
    doPutOffSource: function() {
        var me = this,
            fucinaView = me.fucinaTabs.getActiveTab();
        //    
        if (fucinaView && fucinaView.anvilView.sourceModel) {
            fucinaView.store.add(fucinaView.anvilView.removeSourceModel());
        }
    },
    /**
     * @private   "put" 
     */
    onFucinaSourcePut: function(obj, btn, win) {
        var me = this;
        me.doPutSource(obj.stuff.sourceModel);
        win.close();
    },
    /**
     * @private   "putoff" 
     */
    onFucinaSourcePutOff: function(obj, btn, win) {
        var me = this;
        me.doPutOffSource();
        win.close();
    },
    /**
     * @private   
     */
    onFucinaTabClick: function(tabPanel, entry) {
        var me = this;
        ExGods.app.block();
        me.service.command('fucina', {
            entry: entry
        }, function(resp) {
            ExGods.app.unblock();
            if (resp && resp.fucina) {
                me.service.update({
                    fucina: resp.fucina
                });
            } else {
                /****/
                me.log('error', '@onFucinaTabClick     ', resp);
            }
        });
    },
    /**
     * @priavte     /  
     */
    onUserItemOnOff: function() {
        var me = this;
        if (Ext.getCmp('FUCINA')) {
            ExGods.app.block();
            me.service.command('fucina', {
                entry: me.service.data.fucina.current
            }, function(resp) {
                ExGods.app.unblock();
                if (resp && resp.fucina) {
                    me.service.update({
                        fucina: resp.fucina
                    });
                }
            });
        }
    },
    /**
     * @private     
     */
    onMakeBtnClick: function() {
        var me = this,
            confirmText = ExGods.getMsgByKey('make_fucina_' + me.service.data.fucina.fucina_type),
            sourceModel = me.fucinaTabs.getActiveTab().anvilView.sourceModel,
            cost;
        if (sourceModel && !sourceModel.data.invalid) {
            cost = sourceModel.data.price && sourceModel.data.price.stuff ? ExGods.util.Stuff.printStuff(sourceModel.data.price.stuff) : '';
            Ext.widget('confirmdialog', {
                message: new Ext.Template(confirmText).apply({
                    cost: cost
                }),
                handler: function() {
                    ExGods.app.block();
                    me.service.command('fucina', {
                        action: 'make',
                        entry: me.service.data.fucina.current,
                        value: sourceModel.data.source_id
                    }, function(resp) {
                        ExGods.app.unblock();
                        if (resp.fucina.message) {
                            me.app.fireEvent('logmessage', resp.fucina.message);
                        } else {
                            me.service.update({
                                fucina: resp.fucina
                            });
                        }
                    });
                }
            });
        }
    },
    /**
     * @private     
     */
    onReplayBtnClick: function() {
        var me = this;
        ExGods.app.block();
        me.service.command('fucina', {
            action: 'replay'
        }, function(resp) {
            ExGods.app.unblock();
            if (resp.fucina.message) {
                me.app.fireEvent('logmessage', resp.fucina.message);
            } else {
                me.service.update({
                    fucina: resp.fucina
                });
            }
        });
    },
    /**
     * @private     
     */
    onFinishBtnClick: function() {
        var me = this;
        ExGods.app.block();
        me.service.command('fucina', {
            action: 'finish'
        }, function(resp) {
            ExGods.app.unblock();
            if (resp.fucina.message) {
                me.app.fireEvent('logmessage', resp.fucina.message);
            } else {
                me.service.update({
                    fucina: resp.fucina
                });
            }
        });
    },
    /**
     * @private   
     */
    onServiceUpdate: function() {
        var me = this;
        if (!me.service.loadedProtos) {
            me.service.loadProcessCount = (me.service.loadProcessCount || 0) + 1;
            me.loadProtos(function() {
                if (--me.service.loadProcessCount == 0) {
                    setTimeout(function() {
                        me.service.loadedProtos = true;
                        me.service.update(me.service.data);
                    }, 0);
                }
            });
            return false;
        } else {
            delete me.service.loadedProtos;
            return true;
        }
    },
    /**
     * @private     
     */
    loadProtos: function(callback) {
        var me = this,
            paths = [
                'fucina.data.result.proto_id',
                'fucina.data.result.stuff.params.id',
                'fucina.data.work.source_data.proto_id',
                'fucina.data.source.source_data.proto_id',
                'fucina.data.source.source_data.params.id'
            ];
        ExGods.helpme.loadProtos(me.service.data, paths.join('|'), function() {
            callback();
        });
    }
});

Ext.define('ExGods.view.chests.stuff.ChestStuff', {
    extend: ExGods.stuff.Composite
});

Ext.define('ExGods.view.chests.Info', {
    extend: Ext.panel.Panel,
    alias: 'widget.chestinfo',
    id: 'chest_info',
    config: {
        plugins: [
            'skindeco'
        ]
    },
    layout: 'absolute',
    closable: true,
    width: 314,
    height: 390,
    y: 15,
    style: {
        position: 'absolute',
        zIndex: 2
    },
    itemsInRow: 4,
    rowsInPage: 3,
    initComponent: function() {
        var me = this,
            chestX = me.itemElement.el.dom.offsetLeft,
            chestWidth = me.itemElement.el.dom.offsetWidth,
            maxWidth = 840;
        me.itemsRows = [];
        me.rowTitles = [];
        me.prepareRows();
        if (chestX + chestWidth + me.width <= maxWidth) {
            me.x = chestX + chestWidth;
        } else if (chestX - me.width > 0) {
            me.x = chestX - me.width;
        } else if (chestX + me.width <= maxWidth) {
            me.x = maxWidth - me.width;
        } else {
            me.x = 0;
        }
        me.items = [
            {
                xtype: 'component',
                width: 297,
                height: 356,
                margin: 8,
                data: Ext.apply(me.record.data, {
                    page: 1
                }),
                tpl: [
                    '<div class="paper paper-tl"></div>',
                    '<div class="paper paper-tm"></div>',
                    '<div class="paper paper-tr"></div>',
                    '<div class="paper paper-mr"></div>',
                    '<div class="paper paper-br"></div>',
                    '<div class="paper paper-bm"></div>',
                    '<div class="paper paper-bl"></div>',
                    '<div class="paper paper-ml"></div>',
                    '<div class="paper paper-bg"></div>',
                    '<div class="paper-title"><h4>{label}</h4></div>',
                    '<div class="chest-description">',
                    '<p class="chest-info-text"></p>',
                    '<div class="chest-progress-h">',
                    '<div class="chest-progress-line-h"></div>',
                    '<div class="chest-progress-glow-h"></div>',
                    '<div class="chest-progress-nums-h">{open_counter}/{open_cooldown}</div>',
                    '</div>',
                    '<div class="item_info"></div>',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    '<div class="paper-title">{[this.getLabel(values)]}</div>',
                    '{[this.getRows(values)]}',
                    {
                        getLabel: function(values) {
                            return me.rowTitles[(values.page - 1) * me.rowsInPage];
                        },
                        getRows: function(values) {
                            var rows = [],
                                startRow = (values.page - 1) * me.rowsInPage,
                                i = me.rowsInPage;
                            while (i > 0) {
                                i--;
                                var html = me.itemsRows[startRow + i];
                                if (typeof html == 'function') {
                                    html = html();
                                }
                                rows.unshift(html);
                            }
                            return rows.join('');
                        }
                    }
                ]
            }
        ];
        me.config.plugins.push({
            ptype: 'pager',
            marginLeft: -31,
            marginRight: -31,
            top: 165,
            textTop: 374,
            textLeft: me.x + 95,
            total: Math.ceil(me.itemsRows.length / me.rowsInPage)
        });
        me.listeners = {
            prev: me.setPage,
            next: me.setPage,
            scope: me
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.updateData();
        me.callParent();
        me.el.on('click', function(e) {
            me.fireEvent('show_chest_tooltip', me);
        }, me, {
            delegate: '.chest-description'
        });
    },
    setPage: function() {
        var me = this,
            curPage = me.pager.current;
        me.items.getAt(0).update(Ext.apply(me.record.data, {
            page: curPage
        }));
        me.setInfoText();
        var open_counter = me.record.get('open_counter'),
            open_cooldown = me.record.get('open_cooldown'),
            lineEl = me.el.down('.chest-progress-line-h'),
            calcW = 149,
            pos = Math.floor(open_counter * calcW / open_cooldown) + 10;
        lineEl.setWidth(pos);
        me.pager.refresh();
    },
    prepareRows: function() {
        var me = this,
            titles = me.loot.titles;
        Ext.Array.each(me.loot.items, function(items, index) {
            var l = Math.ceil(items.length / me.itemsInRow),
                i = 0;
            if (me.itemsRows.length % me.rowsInPage > 0 && me.itemsRows.length % me.rowsInPage < me.rowsInPage - 1 && titles[index] !== titles[0]) {
                var title = me.prepareTitle(titles[index]);
                if (title) {
                    me.itemsRows.push(title);
                    me.rowTitles.push(titles[index]);
                }
            } else if (me.itemsRows.length % me.rowsInPage == me.rowsInPage - 1 && titles[index] !== titles[0]) {
                //     -         
                me.itemsRows.push('');
                me.rowTitles.push('');
            }
            for (; i < l; i++) {
                //         DOM,     
                var getHtml = function(index) {
                        return [
                            '<div class="chest-info-rewards-row">',
                            new ExGods.stuff.StuffCollection({
                                stuff: items.slice(index * me.itemsInRow, (index + 1) * me.itemsInRow),
                                sorted: false
                            }).image(),
                            '</div>'
                        ].join('');
                    };
                me.itemsRows.push(getHtml.bind(me, i));
                me.rowTitles.push(titles[index]);
            }
        });
    },
    updateData: function() {
        if (!this.el) {
            return;
        }
        this.setProgress();
        this.setInfoText();
    },
    setProgress: function() {
        if (!this.el) {
            return;
        }
        var me = this,
            open_counter = me.record.get('open_counter'),
            open_cooldown = me.record.get('open_cooldown'),
            lineEl = me.el.down('.chest-progress-line-h'),
            glowEl = me.el.down('.chest-progress-glow-h'),
            numsEl = me.el.down('.chest-progress-nums-h'),
            maxW = 169,
            calcW = 149,
            pos = Math.floor(open_counter * calcW / open_cooldown) + 10;
        if (pos != maxW) {
            glowEl.setStyle('opacity', 0);
        }
        lineEl.stopAnimation();
        lineEl.animate({
            to: {
                width: pos
            },
            duration: 1000,
            callback: function() {
                numsEl.setHTML(open_counter + '/' + open_cooldown);
                if (pos == calcW + 10) {
                    glowEl.animate({
                        to: {
                            opacity: 1
                        },
                        duration: 500
                    });
                }
            }
        });
    },
    setInfoText: function() {
        if (!this.el) {
            return;
        }
        var lucky = ExGods.ref('message_client|chests_info_lucky_open_text'),
            unlucky = ExGods.ref('message_client|chests_info_unlucky_open_text'),
            open_counter = this.record.get('open_counter'),
            open_cooldown = this.record.get('open_cooldown'),
            p = this.el.down('.chest-info-text');
        if (p)  {
            p.setHTML(open_counter == open_cooldown ? lucky : unlucky);
        }
        
    },
    /**
     *       
     */
    prepareTitle: function(title) {
        return '<div class="paper-separator"></div><div class="paper-title">' + title + '</div>';
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        for (var i = 0; i < me.record.data.items.length; i++) {
            stuff_arr.push(me.record.data.items[i]);
        }
        for (var i = 0; i < me.record.data.main_items.length; i++) {
            stuff_arr.push(me.record.data.main_items[i]);
        }
        return {
            stuff: [].concat(stuff_arr),
            images: [
                IMAGE_URL + 'chests/chest_progress_bar_full_h.png',
                IMAGE_URL + 'chests/chest_progress_bar_empty_h.png',
                IMAGE_URL + 'chests/chest_progress_bar_glow_h.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.chests.Container', {
    extend: Ext.panel.Panel,
    alias: 'widget.chestscontainer',
    id: 'chests_container',
    plugins: [
        'irondeco'
    ],
    margin: '3 5 7',
    chestPositions: [
        [
            97,
            27,
            215,
            184
        ],
        [
            311,
            7,
            221,
            202
        ],
        [
            506,
            93,
            286,
            266
        ],
        [
            265,
            164,
            273,
            249
        ],
        [
            16,
            172,
            245,
            242
        ]
    ],
    initComponent: function() {
        var me = this;
        me.style = {
            backgroundImage: "url(" + IMAGE_URL + me.backImg + ")"
        };
        me.html = '<div class="chests-header" style="background-image: url(' + ExGods.ref('images|chests_images').image['header_btn'] + ');"><div class="chests-close-btn"></div></div>';
        me.callParent();
        var i = 0;
        me.removeAll();
        me.store.each(function(el) {
            me.add({
                xtype: 'chest',
                record: el,
                x: me.chestPositions[i][0],
                y: me.chestPositions[i][1],
                width: me.chestPositions[i][2],
                height: me.chestPositions[i][3],
                btnOpenText: me.openText,
                btnOpenColor: me.openColor,
                btnGetText: me.getText,
                btnGetColor: me.getColor,
                glowingDelay: me.glowingDelay,
                glowingSpeed: me.glowingSpeed,
                glowingMaxBrightTime: me.glowingMaxBrightTime,
                chestAppearSpeed: Number(me.chestAppearSpeed),
                chestAppearDelay: Number(me.chestAppearDelay)
            });
            i++;
        });
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.renderBtns();
        me.el.on('click', function(e) {
            me.fireEvent('close');
        }, me, {
            delegate: '.chests-close-btn'
        });
    },
    renderBtns: function() {
        var me = this,
            openCls = me.openAllColor ? 'x-btn-txt-' + me.openAllColor : '',
            getCls = me.getAllColor ? 'x-btn-txt-' + me.getAllColor : '',
            can_take = me.store.canTake();
        me.add(/*{
                            xtype:'textbutton',
                            style:{
                                position:'absolute'
                            },
                            text:can_take ? me.getAllText : me.openAllText,
                            cls:can_take ? getCls : openCls,
                            x:631,
                            y:375,
                            itemId:'open_all_chests',
                            listeners:{
                                click:function(){this.disable()}
                            }
                        },*/
        {
            xtype: 'textbutton',
            style: {
                position: 'absolute'
            },
            text: me.closeText,
            cls: me.closeColor ? 'x-btn-txt-' + me.closeColor : '',
            x: 737,
            y: 375,
            handler: function() {
                me.fireEvent('close');
            }
        });
    },
    /**
         *   
         */
    getResources: function() {
        var me = this,
            arr_images = [];
        var images = ExGods.ref('images|chests_images').image;
        for (var i in images) {
            arr_images.push(images[i]);
        }
        return {
            images: [
                IMAGE_URL + me.backImg,
                me.openText,
                //me.getText,
                me.closeText,
                IMAGE_URL + 'button-text-30green.png',
                IMAGE_URL + 'button-text-30.png',
                IMAGE_URL + 'chests/chest_progress_bar_glow.png',
                IMAGE_URL + 'chests/chest_progress_bar_full.png',
                IMAGE_URL + 'chests/chest_progress_bar_empty.png',
                IMAGE_URL + 'chests/chest_index.png',
                IMAGE_URL + 'ind.png',
                IMAGE_URL + 'bid/timer.png',
                IMAGE_URL + 'chests/slot_glow.png'
            ].concat(arr_images)
        };
    }
});

/**
 *     
 */
Ext.define('ExGods.view.chests.Chest', {
    extend: Ext.panel.Panel,
    alias: 'widget.chest',
    style: {
        position: 'absolute',
        cursor: 'pointer'
    },
    hidingClasses: [
        'chest-progress',
        'chest-stuff-container',
        'chest-button-place',
        'chest-bg-glow',
        'chest-you-got',
        'chest-slot-glow'
    ],
    initComponent: function() {
        var me = this;
        me.data = me.record.data;
        me.tpl = [
            '<div class="chest-bg" style="background-image:url({[ IMAGE_URL + values.image ]});height:' + me.height + 'px">',
            '<div class="chest-bg-glow" style="background:url({[ IMAGE_URL + values.image ]}) 0 -' + me.height + 'px;height:' + me.height + 'px;opacity:0"></div>',
            '<div class="chest-progress" style="opacity:0">',
            '<div class="chest-progress-line"></div>',
            '<div class="chest-progress-glow"></div>',
            '<div class="chest-progress-nums">{open_counter}/{open_cooldown}</div>',
            '</div>',
            '<div class="chest-slot-glow" style="opacity:0"></div>',
            '<div class="chest-you-got" style="background-image: url(' + ExGods.ref('images|chests_images').image.you_got + ');opacity:0"></div>',
            '<div class="chest-stuff-container" style="opacity:0"></div>',
            '<div class="chest-button-place" id="chest_button_place_{id}" style="opacity:0"></div>',
            '</div>'
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.renderBtn();
        me.updateData();
        me.startGlowing();
        me.callParent();
        me.el.on('click', function(e) {
            if (!e.getTarget('.x-btn') && !e.getTarget('.item')) {
                me.fireEvent('chestinfo', me, me.record);
                me.record.infoShown = true;
            }
        }, me);
        me.el.on('mouseenter', function() {
            me.overed = true;
            me.setVisible();
        }, me);
        me.el.on('mouseleave', function() {
            me.overed = false;
            me.setHidden();
        }, me);
    },
    renderBtn: function() {
        var me = this,
            r = me.record,
            has_dropped_items = r.get('dropped_items').length,
            can_open = r.get('can_open'),
            openCls = me.btnOpenColor ? 'x-btn-txt-' + me.btnOpenColor : '',
            getCls = me.btnGetColor ? 'x-btn-txt-' + me.btnGetColor : '';
        me.btn = Ext.widget('textbutton', {
            renderTo: 'chest_button_place_' + r.get('id'),
            record: me.record,
            cmp: me,
            text: has_dropped_items ? me.btnGetText : me.btnOpenText,
            cls: has_dropped_items ? getCls : openCls,
            itemId: 'open_chest',
            listeners: {
                click: function() {
                    this.disable();
                }
            }
        });
    },
    updateData: function(data) {
        if (!this.el)  {
            return;
        }
        
        var me = this;
        if (data)  {
            me.record.set(data);
        }
        
        me.setBtn();
        ExGods.Resources.load(me, function() {
            me.printStuff();
            if (!me.record.get('can_take')) {
                me.setHidden([
                    'chest-you-got',
                    'chest-slot-glow'
                ], true);
            } else {
                me.setVisible([
                    'chest-you-got',
                    'chest-slot-glow'
                ], true);
                me.setHidden([
                    'chest-bg-glow'
                ], true);
            }
            me.setProgress();
            me.setImage();
            me.updateVisibility();
        });
    },
    setBtn: function() {
        var me = this,
            r = me.record,
            has_dropped_items = r.get('dropped_items').length,
            can_open = r.get('can_open'),
            openCls = me.btnOpenColor ? 'x-btn-txt-' + me.btnOpenColor : '',
            getCls = me.btnGetColor ? 'x-btn-txt-' + me.btnGetColor : '';
        if (me.btn.rendered) {
            me.btn.setText(has_dropped_items ? me.btnGetText : me.btnOpenText);
            me.btn.removeCls(has_dropped_items ? openCls : getCls);
            me.btn.addCls(has_dropped_items ? getCls : openCls);
            me.btn.setDisabled(!has_dropped_items && !can_open);
        }
    },
    updateVisibility: function() {
        var can_take = this.record.get('can_take');
        if (can_take) {
            this.setVisible();
        } else if (!this.overed) {
            this.setHidden();
        }
        if (this.record.get('is_key') && this.record.get('key_count') > 0) {
            this.setVisible([
                'chest-stuff-container'
            ]);
        }
    },
    setVisible: function(classes, instant) {
        var me = this;
        if (me.blockedAnimation)  {
            return;
        }
        
        classes = classes || me.hidingClasses;
        Ext.Array.each(classes, function(cls) {
            var el = me.el.down('.' + cls);
            if (el.dom.style.opacity == 1)  {
                return;
            }
            
            if (el.dom.className.indexOf('chest-you-got') != -1 && !me.record.get('can_take'))  {
                return;
            }
            
            if (el.dom.className.indexOf('chest-slot-glow') != -1 && !me.record.get('can_take'))  {
                return;
            }
            
            if (el.dom.className.indexOf('chest-bg-glow') != -1 && !me.record.get('can_open'))  {
                return;
            }
            
            el.stopAnimation();
            if (instant) {
                el.setStyle('opacity', 1);
            } else {
                el.animate({
                    to: {
                        opacity: 1
                    },
                    duration: me.chestAppearSpeed,
                    delay: me.chestAppearDelay
                });
            }
        });
    },
    setHidden: function(classes, instant) {
        var me = this;
        if (!me.el)  {
            return;
        }
        
        if (me.blockedAnimation)  {
            return;
        }
        
        if (!classes && (me.record.get('can_take') || me.record.infoShown))  {
            return;
        }
        
        classes = classes || me.hidingClasses;
        Ext.Array.each(classes, function(cls) {
            var el = me.el.down('.' + cls);
            if (cls == 'chest-stuff-container' && me.record.get('is_key') && me.record.get('key_count') > 0)  {
                return;
            }
            
            el.stopAnimation();
            if (instant) {
                el.setStyle('opacity', 0);
            } else {
                el.animate({
                    to: {
                        opacity: 0
                    },
                    duration: me.chestAppearSpeed,
                    delay: me.chestAppearDelay
                });
            }
        });
    },
    printStuff: function() {
        var me = this,
            r = me.record,
            html = '';
        if (r.get('dropped_items').length) {
            html += ExGods.stuff.StuffManager.image(r.get('dropped_items'));
        } else if (r.get('is_key') && r.get('key_count') > 0) {
            html += me.printKey(r.get('key'), r.get('key_count'));
        } else if (r.get('price')) {
            html += me.printPrice(r.get('price').stuff);
        } else if (r.get('is_key')) {
            html += me.printKey(r.get('key'), 0);
        }
        if (me.el) {
            me.el.down('.chest-stuff-container').setHTML(html);
        }
    },
    printKey: function(item_stuff, count) {
        var proto, img;
        if (item_stuff.type == 'timed') {
            proto = ExGods.ref('user_timed|' + item_stuff.params.id);
            img = IMAGE_URL + proto.img.img2;
        } else {
            proto = ExGods.ref('ingredients|' + item_stuff.params.id);
            img = IMAGE_URL + proto.params.images.img_2;
        }
        return [
            '<div class="chest-open-item" style="background-image:url(' + img + ')">',
            '<span class="stack-counter">' + count + '</span>',
            '</div>'
        ].join('');
    },
    printPrice: function(stuff) {
        return Ext.Array.map(stuff, function(item_stuff) {
            var proto = ExGods.ref('user_money|' + item_stuff.params.id),
                img = IMAGE_URL + proto.param.image_chest;
            return [
                '<div class="chest-open-item" style="background-image:url(' + img + ')">',
                (item_stuff.params.quantity < 99 ? ('<span class="stack-counter">' + item_stuff.params.quantity + '</span>') : '<span class="stack-counter big_counter"><span class="big_counter_mid">' + item_stuff.params.quantity + '</span></span>'),
                '</div>'
            ].join('');
        }).join('');
    },
    setProgress: function() {
        if (!this.el) {
            return;
        }
        var me = this,
            open_counter = me.record.get('open_counter'),
            open_cooldown = me.record.get('open_cooldown'),
            lineEl = me.el.down('.chest-progress-line'),
            glowEl = me.el.down('.chest-progress-glow'),
            numsEl = me.el.down('.chest-progress-nums'),
            maxH = 169,
            calcH = 149,
            pos = Math.floor(open_counter * calcH / open_cooldown) + 10;
        if (pos != maxH) {
            glowEl.setStyle('opacity', 0);
        }
        lineEl.stopAnimation();
        if (open_cooldown > 50) {
            lineEl.dom.style.backgroundPosition = '0 -' + (maxH - pos) + 'px';
            lineEl.dom.style.height = pos + 'px';
            lineEl.dom.style.top = (maxH - pos) + 'px';
            numsEl.setHTML(open_counter + '/' + open_cooldown);
            if (pos == calcH + 10) {
                glowEl.animate({
                    to: {
                        opacity: 1
                    },
                    duration: 500
                });
            }
        } else {
            lineEl.animate({
                to: {
                    height: pos,
                    top: maxH - pos
                },
                duration: 1000,
                callback: function() {
                    numsEl.setHTML(open_counter + '/' + open_cooldown);
                    if (pos == calcH + 10) {
                        glowEl.animate({
                            to: {
                                opacity: 1
                            },
                            duration: 500
                        });
                    }
                }
            });
        }
    },
    setImage: function() {
        var me = this,
            el = me.el.down('.chest-bg'),
            posY;
        if (me.record.get('can_take')) {
            posY = 0;
        } else if (me.record.get('can_open')) {
            posY = me.height * 2;
        } else {
            posY = me.height * 3;
        }
        el.setStyle('background-position', '0 -' + posY + 'px');
    },
    startGlowing: function() {
        var me = this;
        me.glowingInterval = setInterval(function() {
            if (!me.overed && !me.record.infoShown && me.record.get('can_open')) {
                if (!me.el || !me.el.dom)  {
                    return;
                }
                
                var el = me.el.dom.querySelector('.chest-bg-glow');
                if (!el)  {
                    return clearInterval(me.glowingInterval);
                }
                
                var glowingSpeed = Number(me.glowingSpeed),
                    its = Math.ceil(Number(me.glowingSpeed) / 40),
                    //40 - 1000/25   25 fps
                    i = its,
                    value = 1 / its,
                    setOpacity = function(positive, i, callback) {
                        el.style.opacity = Math.max(0, Math.min(1, Number(el.style.opacity) + value * (positive ? 1 : -1)));
                        i--;
                        if (i > 0) {
                            setTimeout(function() {
                                setOpacity(positive, i, callback);
                            }, 40);
                        } else if (callback) {
                            callback();
                        }
                    };
                setOpacity(true, i, function() {
                    setTimeout(function() {
                        i = its;
                        setOpacity(false, i);
                    }, Number(me.glowingMaxBrightTime) || 0);
                });
            }
        }, me.glowingDelay);
    },
    onDestroy: function() {
        clearInterval(this.glowingInterval);
        this.callParent();
    },
    blockAnimation: function() {
        this.blockedAnimation = true;
    },
    unblockAnimation: function() {
        this.blockedAnimation = false;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            r = me.record,
            stuff_arr = [],
            arr_images = [];
        if (r.get('dropped_items').length) {
            stuff_arr = stuff_arr.concat(r.get('dropped_items'));
        } else if (r.get('is_key') && r.get('key_count') > 0) {
            stuff_arr = stuff_arr.concat(r.get('key'));
        } else if (r.get('price')) {
            stuff_arr = stuff_arr.concat(r.get('price').stuff);
        }
        var main_items__ = r.get('main_items');
        if (main_items__.length) {
            stuff_arr = stuff_arr.concat(main_items__);
        }
        return {
            stuff: [],
            images: [
                IMAGE_URL + r.data.image
            ].concat(arr_images)
        };
    }
});

/**
 *       
 */
Ext.define('ExGods.view.chests.HeaderButton', {
    extend: Ext.Component,
    alias: 'widget.chestsheaderbutton',
    id: 'chests-header-button',
    width: 92,
    height: 69,
    isDisabled: false,
    /**
     * @cfg {Array}   -,     .
     */
    timedWithKeys: [
        'goods'
    ],
    /**
     *   
     */
    counter: 0,
    initComponent: function() {
        var me = this;
        me.tpl = [
            '<div class="glow-bg"></div>',
            '<div class="counter {[ values.counter > 0 ? "" : "hidden" ]}">{counter}</div>',
            '<div class="timer"></div>'
        ];
        me.data = {
            counter: me.counter
        };
        me.mon(ExGods.util.Timers, 'chests-header-button-timer-expire', me.onNextKeyTimerExpire, me);
        me.mon(ExGods.app.user, 'timedchanged', me.onTimedChanged, me);
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.on('click', function() {
            if (!me.isDisabled) {
                me.fireEvent('click');
            }
        });
        me.setDisabled(me.isDisabled);
        if (me.counter == 0) {
            me.showNextKeyTimer();
        } else {
            me.hideNextKeyTimer();
        }
    },
    /**
     *  
     */
    setDisabled: function(disabled) {
        var me = this;
        me.isDisabled = disabled;
        if (me.isDisabled) {
            me.stopGlow();
            me.el.addCls('disabled');
        } else {
            me.startGlow();
            me.el.removeCls('disabled');
        }
    },
    /**
     *  
     */
    setCounter: function(counter) {
        var me = this,
            counterEl = me.el.down('.counter');
        if (me.counter === counter) {
            return;
        }
        me.counter = counter;
        if (me.counter > 0) {
            me.hideNextKeyTimer();
            counterEl.removeCls('hidden');
            counterEl.setHTML(me.counter);
        } else {
            me.showNextKeyTimer();
            counterEl.addCls('hidden');
        }
    },
    /**
     * @private
     */
    showNextKeyTimer: function() {
        var me = this,
            el = Ext.get(me.el.down('.timer')),
            timed = ExGods.app.user.data.timed[me.timedWithKeys[0]],
            timedDate = timed ? timed[3] : null;
        if (timedDate && timedDate - Date.now() > 0) {
            el.setHTML(ExGods.util.Timers.printTimer('rest', 'chests-header-button-timer', timedDate, {
                needNormalized: false
            }));
            el.removeCls('hidden');
        } else {
            me.hideNextKeyTimer();
        }
    },
    /**
     * @private
     */
    hideNextKeyTimer: function() {
        var me = this,
            el = Ext.get(me.el.down('.timer'));
        el.setHTML('');
        el.addCls('hidden');
    },
    /**
     * @private
     */
    onNextKeyTimerExpire: function() {
        var me = this;
        me.hideNextKeyTimer();
    },
    /**
     * @private    .
     *   ,  
     */
    onTimedChanged: function() {
        var me = this;
        if (me.counter == 0) {
            me.showNextKeyTimer();
        }
    },
    /**
     * @private  
     */
    startGlow: function() {
        var me = this,
            ticktime = 100,
            time1 = parseFloat(ExGods.ref('constants|chests_button_anim_to_show').value),
            time2 = parseFloat(ExGods.ref('constants|chests_button_anim_pause').value),
            time3 = parseFloat(ExGods.ref('constants|chests_button_anim_to_hide').value),
            phases = [
                {
                    from: 0,
                    to: 1,
                    dur: time1,
                    perTick: 1 / (time1 / ticktime)
                },
                {
                    from: 1,
                    to: 1,
                    dur: time2,
                    perTick: 0
                },
                {
                    from: 1,
                    to: 0,
                    dur: time3,
                    perTick: -1 / (time3 / ticktime)
                },
                {
                    from: 0,
                    to: 0,
                    dur: time2,
                    perTick: 0
                }
            ],
            curPhase = 0,
            curTime = 0,
            curValue = phases[curPhase].from,
            el = me.el.down('.glow-bg');
        if (me.glowInterval) {
            return;
        }
        me.glowInterval = setInterval(function() {
            curTime += ticktime;
            if (phases[curPhase].dur > curTime) {
                curValue += phases[curPhase].perTick;
                el.setStyle('opacity', curValue);
            } else {
                el.setStyle('opacity', phases[curPhase].to);
                curPhase = curPhase == 3 ? 0 : curPhase + 1;
                curTime = 0;
                curValue = phases[curPhase].from;
            }
        }, ticktime);
    },
    /**
     * @private  
     */
    stopGlow: function() {
        var me = this;
        clearInterval(me.glowInterval);
        me.glowInterval = null;
    }
});

/**
 *  
 */
Ext.define('ExGods.model.Chest', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'id',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'image',
            type: 'string'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            //    
            name: 'can_open',
            type: 'int',
            convert: function(v, r) {
                if (v && r.get('is_key') && r.get('key_count') == 0 && !r.get('price')) {
                    return 0;
                } else  {
                    return v;
                }
                
            }
        },
        {
            //     
            name: 'can_take',
            type: 'int'
        },
        {
            //  
            name: 'dropped_items',
            type: 'auto',
            convert: function(v, r) {
                return v || [];
            }
        },
        {
            //   
            name: 'is_key',
            type: 'int'
        },
        {
            // stuff 
            name: 'key',
            type: 'auto'
        },
        {
            // ,   
            name: 'items',
            type: 'auto',
            convert: function(v, r) {
                var items = [],
                    main_items = [];
                Ext.Array.sort(v, function(a, b) {
                    return a.l_order > b.l_order ? 1 : -1;
                });
                Ext.Array.each(v, function(el) {
                    if (el.is_main == 1) {
                        main_items.push(el.stuff);
                    } else {
                        items.push(el.stuff);
                    }
                });
                r.set('main_items', main_items);
                return items;
            }
        },
        {
            //  
            name: 'main_items',
            type: 'auto'
        },
        {
            //  
            name: 'key_count',
            type: 'int'
        },
        {
            // 
            name: 'l_order',
            type: 'int'
        },
        {
            //       ""
            name: 'open_cooldown',
            type: 'int'
        },
        {
            //  
            name: 'open_counter',
            type: 'int'
        },
        {
            //  
            name: 'price',
            type: 'auto'
        }
    ]
});

/**
 *  
 */
Ext.define('ExGods.store.Chests', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Chest',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'l_order',
            direction: 'DESC'
        }
    ],
    canOpen: function() {
        var ret = 0;
        this.each(function(record) {
            ret += record.get('can_open');
        });
        return !!ret;
    },
    canOpenByKey: function() {
        var ret = 0;
        this.each(function(record) {
            ret += record.get('key_count');
        });
        return !!ret;
    },
    canTake: function() {
        var ret = 0;
        this.each(function(record) {
            ret += record.get('can_take');
        });
        return !!ret;
    },
    hasMultipleDrop: function() {
        var has = false;
        this.each(function(record) {
            if (record.get('dropped_items').length > 1)  {
                has = true;
            }
            
        });
        return has;
    },
    getTotalKeysCount: function() {
        var count = 0;
        this.each(function(record) {
            if (record.get('is_key'))  {
                count += record.get('key_count');
            }
            
        });
        return count;
    },
    getAllDroppedItems: function() {
        var dropped = [];
        this.each(function(record) {
            [].push.apply(dropped, record.get('dropped_items'));
        });
        return dropped;
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Chests', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    views: [
        'chests.Container',
        'chests.Chest',
        'chests.Info',
        'chests.HeaderButton'
    ],
    stores: [
        'Chests'
    ],
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'Chests:'
    },
    init: function(app) {
        var me = this;
        me.service = ExGods.Services.get('chests');
        if (me.service.on) {
            me.service.on('update', me.onServiceUpdate, me);
        }
        me.app.getChestsStore().loadRawData(me.service.data.chests);
        me.control({
            '#open_chest': {
                click: me.onChestBtnClick
            },
            'chest': {
                chestinfo: me.onChestInfo
            },
            'chestinfo': {
                show_chest_tooltip: me.showChestTooltip
            }
        });
        // ,     ""
        me.user.on('ingredientschanged', me.onIngredientsChanged, me);
        //   timed
        // me.user.on('goodschanged', me.onGoldTriesChanged, me);
        // me.gold_tries = Math.floor(me.user.get('timed').goods[0]);
        me.user.on('gold_chest_trieschanged', me.onGoldTriesChanged, me);
        me.gold_tries = Math.floor(me.user.get('timed').gold_chest_tries[0]);
        ExGods.stuff.StuffManager.register({
            'chest_stuff': ExGods.view.chests.stuff.ChestStuff
        });
        ExGods.Components.addComponentInitializer('chests', me.initChestsComponent, me);
    },
    onLaunch: function() {
        var me = this;
        me.initHeaderButton();
    },
    onIngredientsChanged: function() {
        var me = this;
        if (me.cmp && me.cmp.isVisible()) {
            me.service.update();
        }
    },
    onGoldTriesChanged: function(timed) {
        var me = this,
            cur_tries = me.gold_tries,
            value = Math.floor(timed[0]);
        //  
        if (value == cur_tries)  {
            return;
        }
        
        me.gold_tries = value;
        if (me.cmp && me.cmp.isVisible() && cur_tries < value) {
            me.service.update();
        }
    },
    initHeaderButton: function() {
        var me = this,
            store = me.app.getChestsStore(),
            btn,
            getTotalKeysCount = function(src) {
                var count = 0,
                    timedWithKeys = [
                        'gold_chest_tries'
                    ];
                if (src == 'store') {
                    count = store.getTotalKeysCount();
                } else {
                    timedWithKeys.forEach(function(name) {
                        if (me.user.data.timed[name]) {
                            count += Math.floor(me.user.data.timed[name][0]);
                        }
                    });
                    count += me.user.getIngredientsGroupCount('');
                    count += me.user.getIngredientsGroupCount('Chests');
                }
                return count;
            };
        btn = Ext.widget('chestsheaderbutton', {
            renderTo: 'header',
            isDisabled: me.user.isBattle(),
            counter: getTotalKeysCount('store'),
            timedWithKeys: [
                'gold_chest_tries'
            ],
            listeners: {
                click: function() {
                    ExGods.ClientActions.createAndInvoke({
                        actionId: me.service.id
                    });
                }
            }
        });
        store.on('update', function() {
            btn.setCounter(getTotalKeysCount('store'));
        });
        store.on('datachanged', function() {
            btn.setCounter(getTotalKeysCount('store'));
        });
        // ,     ""
        me.user.on('ingredientschanged', function() {
            btn.setCounter(getTotalKeysCount());
        });
        //   timed
        ExGods.app.user.on('gold_chest_trieschanged', function() {
            btn.setCounter(getTotalKeysCount());
        });
    },
    onServiceUpdate: function() {
        var me = this;
        Ext.Array.each(me.service.data.chests, function(chest) {
            me.app.getChestsStore().each(function(record) {
                if (record.get('l_order') == chest.l_order) {
                    record.set(chest);
                    //     ,      convert  
                    //  set     
                    record.set('can_open', chest.can_open);
                }
            });
            if (me.cmp && me.cmp.isVisible()) {
                me.cmp.items.each(function(item) {
                    if (item.xtype == 'chest' && item.record.get('l_order') == chest.l_order) {
                        ExGods.helpme.loadProtosFromStuff(chest.dropped_items, function() {
                            item.updateData(chest);
                            if (me.chestInfo)  {
                                me.chestInfo.updateData();
                            }
                            
                        });
                    }
                });
            }
        });
    },
    onChestBtnClick: function(btn) {
        var me = this,
            can_take = btn.record.get('can_take');
        btn.cmp.blockAnimation();
        me.service.suspendEvents();
        me.service.command(can_take ? 'chest_take' : 'chest_open', {
            id: btn.record.get('id')
        }, function(data) {
            if (data && data.chests) {
                var newData = Ext.Array.findBy(data.chests, function(el) {
                        return el.l_order == btn.record.get('l_order');
                    });
                ExGods.helpme.loadProtosFromStuff(newData.dropped_items, function() {
                    ExGods.Resources.loadStuff(newData.dropped_items, function() {
                        btn.cmp.unblockAnimation();
                        btn.cmp.updateData(newData);
                        if (me.chestInfo)  {
                            me.chestInfo.updateData();
                        }
                        
                    });
                });
            } else {
                btn.cmp.updateData();
            }
            me.service.resumeEvents();
        });
    },
    onChestInfo: function(chestView, record) {
        var me = this,
            items = record.get('items'),
            main_items = record.get('main_items'),
            rows = [];
        ExGods.app.block();
        if (me.chestInfo) {
            me.chestInfo.close();
        }
        me.chestInfo = Ext.widget('chestinfo', {
            itemElement: chestView.el,
            autoShow: false,
            loot: {
                items: [
                    main_items,
                    items
                ],
                titles: [
                    ExGods.getMsgByKey('chest_main_reward_title'),
                    ExGods.getMsgByKey('chest_reward_title')
                ]
            },
            record: record,
            onDestroy: function() {
                record.infoShown = false;
                chestView.setHidden();
                me.chestInfo = false;
                if (me.chesttooltip)  {
                    me.chesttooltip.close();
                }
                
                this.callParent();
            }
        });
        ExGods.Resources.load(me.chestInfo, function() {
            me.cmp.add(me.chestInfo);
            ExGods.app.unblock();
        });
    },
    showChestTooltip: function(chestinfo) {
        var me = this,
            el = chestinfo.el.down('.chest-description');
        me.chesttooltip = Ext.widget('parchmentwindow', {
            itemElement: el,
            html: [
                '<div class="chest-info-tooltip-text">',
                ExGods.ref('message_client|chest_info_tooltip'),
                '</div>'
            ].join(''),
            listeners: {
                close: function() {
                    me.chesttooltip = false;
                }
            }
        });
    },
    initChestsComponent: function(config, id) {
        var me = this,
            store = me.app.getChestsStore();
        me.onServiceUpdate();
        me.cmp = Ext.widget('chestscontainer', Ext.applyIf({
            service: me.service,
            store: store,
            listeners: {
                close: {
                    fn: function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            if (me.chestInfo)  {
                                me.chestInfo.close();
                            }
                            
                            me.wnd.close();
                        }, {
                            img: config.loadImg
                        });
                        return false;
                    },
                    single: true
                }
            }
        }, config));
        me.wnd = Ext.widget('window1', {
            id: id,
            items: [
                me.cmp
            ],
            autoShow: false,
            getResources: function() {
                var me = this;
                return {
                    images: [
                        config.loadImg
                    ]
                };
            }
        });
        ExGods.app.getController('Location').maskLocation(function() {
            //  
            ExGods.Resources.load(me.wnd, function() {
                ExGods.Resources.loadStuff(store.getAllDroppedItems(), function() {
                    me.wnd.show();
                    if (store.hasMultipleDrop())  {
                        me.showDropCmp();
                    }
                    
                    ExGods.app.getController('Location').unmaskLocation();
                });
            });
        }, {
            img: config.loadImg
        });
        return me.wnd;
    }
});

/**
 *   
 */
Ext.define('ExGods.model.GuildQuest', {
    extend: Ext.data.Model,
    idProperty: 'task_id',
    fields: [
        {
            name: 'task_id',
            type: 'int'
        },
        {
            name: 'create_date',
            type: 'auto'
        },
        {
            name: 'done_date',
            type: 'auto'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'description_short',
            type: 'string'
        },
        {
            name: 'image',
            type: 'string'
        },
        {
            name: 'short_title',
            type: 'string'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'guild_id',
            type: 'int'
        },
        {
            name: 'params',
            type: 'auto'
        },
        {
            name: 'stages',
            type: 'auto'
        },
        {
            //  ,    
            name: 'pcp',
            type: 'auto',
            convert: function(v, r) {
                if (!v)  {
                    return [];
                }
                
                // var i = v.length;
                // while(i--){
                //  //TODO  .       
                //  //if(v[i])
                // }
                v.sort(function(a, b) {
                    return Number(a.count) > Number(b.count) ? -1 : 1;
                });
                return v;
            }
        },
        {
            name: 'expanded',
            type: 'boolean'
        }
    ]
});

/**
 *    
 */
Ext.define('ExGods.model.GuildRaid', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'entry',
            type: 'int'
        },
        {
            name: 'counter',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'image',
            type: 'string'
        },
        {
            name: 'image2',
            type: 'string'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'achievement',
            type: 'auto'
        },
        {
            name: 'l_order',
            type: 'int'
        },
        {
            name: 'empty',
            type: 'boolean'
        },
        {
            name: 'short_description',
            type: 'string'
        },
        {
            name: 'rewards',
            type: 'auto'
        }
    ],
    isComplete: function() {
        return this.get('counter') && this.get('counter') > 0;
    }
});

/**
 *    
 */
Ext.define('ExGods.model.GuildRequest', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'id',
            type: 'int'
        },
        {
            name: 'current_count',
            type: 'int',
            convert: function(v, r) {
                r.set('left_count', r.get('max_count') - v);
                return Number(v);
            }
        },
        {
            name: 'owner',
            type: 'auto'
        },
        {
            name: 'max_count',
            type: 'int'
        },
        {
            name: 'left_count',
            type: 'int'
        },
        {
            name: 'type',
            type: 'int',
            convert: function(v, r) {
                var ref = ExGods.ref('guild_request_types|' + v);
                r.set('label', ref.label);
                r.set('type_request', ref.type);
                return Number(v);
            }
        },
        {
            name: 'type_request',
            type: 'string'
        },
        {
            name: 'label',
            type: 'string'
        },
        {
            name: 'timeout',
            type: 'int',
            convert: function(v, r) {
                if (v && !r.timerStarted)  {
                    r.startTimer();
                }
                
                return Number(v);
            }
        },
        {
            name: 'index',
            type: 'int'
        }
    ],
    isFull: function() {
        return this.get('owner') ? this.get('current_count') == this.get('max_count') : false;
    },
    isUserOwner: function() {
        return this.get('owner') ? this.get('owner').display_title == ExGods.app.getUser().get('display_title') : false;
    },
    startTimer: function() {
        this.timerStarted = true;
        ExGods.util.Ticker.addListener(this.updateTimeout, this);
    },
    updateTimeout: function() {
        var left = this.get('timeout');
        left--;
        if (left <= 0) {
            ExGods.util.Ticker.removeListener(this.updateTimeout, this);
            this.timerStarted = false;
        }
        this.set('timeout', Math.max(left, 0));
    }
});

/**
 *    
 */
Ext.define('ExGods.model.GuildGroup', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'id',
            type: 'int'
        },
        {
            name: 'creator',
            type: 'string'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'level',
            type: 'int'
        },
        {
            name: 'users',
            type: 'auto'
        }
    ]
});

Ext.define('ExGods.view.guild.Container', {
    extend: Ext.container.Container,
    alias: 'widget.guildcontainer',
    id: 'guild_container',
    layout: 'card'
});

/**
 *   .  , ,  .
 */
Ext.define('ExGods.view.guild.RaidInfoWindow', {
    extend: ExGods.view.CommonDetailsWindow,
    alias: 'widget.raidinfowindow',
    initComponent: function() {
        var me = this,
            data = me.record.data;
        me.config.data = {
            image: IMAGE_URL + (me.complete ? data.image : data.image2),
            label: data.title,
            description: data.description
        };
        if (me.show_rewards) {
            me.config.data.rows = [
                {
                    title: ExGods.ref('message_client|view_battle_rewards_rewardstitle'),
                    content: ExGods.stuff.StuffManager.image(data.rewards)
                }
            ];
        }
        me.callParent(arguments);
    }
});

Ext.define('ExGods.view.guild.TabPanel', {
    extend: ExGods.view.skin.TabPanel,
    alias: 'widget.guildtabpanel',
    bodyPadding: '0 10 8 8',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.items = [];
        //guild info
        me.items.push({
            xtype: 'guildinfo',
            guild: me.guild,
            service: me.service,
            tabConfig: {
                tooltip: cfg.tab_info_tt,
                icon: IMAGE_URL + cfg.tab_info_img
            }
        });
        //guild requests
        me.items.push({
            xtype: 'guildhelp',
            guild: me.guild,
            service: me.service,
            myRequestsStore: me.myRequestsStore,
            requestsStore: me.requestsStore,
            tabConfig: {
                id: 'guild_help_tab',
                tooltip: cfg.tab_req_tt,
                icon: IMAGE_URL + cfg.tab_req_img
            }
        });
        //guild shop
        if (Number(me.service.data.shop_service_id)) {
            me.items.push({
                xtype: 'guildshop',
                guild: me.guild,
                service: me.service,
                tabConfig: {
                    tooltip: cfg.tab_shop_tt,
                    icon: IMAGE_URL + cfg.tab_shop_img
                }
            });
        }
        //guild quests
        me.items.push({
            xtype: 'guildquests',
            guild: me.guild,
            service: me.service,
            store: me.questsStore,
            tabConfig: {
                tooltip: cfg.tab_quest_tt,
                icon: IMAGE_URL + cfg.tab_quest_img
            }
        });
        //guild groups
        me.items.push({
            xtype: 'guildgroups',
            guild: me.guild,
            service: me.service,
            groupsStore: me.groupsStore,
            tabConfig: {
                tooltip: cfg.tab_group_tt,
                icon: IMAGE_URL + cfg.tab_group_img
            }
        });
        //guild raids
        me.items.push({
            xtype: 'guildraids',
            guild: me.guild,
            service: me.service,
            store: me.raidsStore,
            tabConfig: {
                tooltip: cfg.tab_raids_tt,
                icon: IMAGE_URL + cfg.tab_raids_img
            }
        });
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            cfg = me.service.init_config;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + cfg.tab_info_img,
                IMAGE_URL + cfg.tab_req_img,
                IMAGE_URL + cfg.tab_shop_img,
                IMAGE_URL + cfg.tab_quest_img,
                IMAGE_URL + cfg.tab_group_img,
                IMAGE_URL + cfg.tab_raids_img
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.model.Guild', {
    extend: Ext.data.Model,
    fields: [
        {
            name: 'id',
            type: 'int'
        },
        {
            name: 'current_count',
            type: 'int',
            convert: function(v, r) {
                r.set('left_count', r.get('max_count') - v);
                return v;
            }
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            // 
            name: 'head',
            type: 'auto'
        },
        {
            name: 'max_count',
            type: 'int'
        },
        {
            name: 'left_count',
            type: 'int'
        },
        {
            name: 'open',
            type: 'int'
        },
        {
            name: 'tag',
            type: 'string'
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'bids',
            type: 'auto'
        },
        {
            name: 'users',
            type: 'auto',
            convert: function(v, r) {
                if (!v)  {
                    return v;
                }
                
                if (!r.guildMembers) {
                    r.guildMembers = Ext.create('ExGods.store.GuildMembers', {
                        guild: r
                    });
                }
                setTimeout(function() {
                    r.guildMembers.loadRawData(v.concat([
                        r.get('head')
                    ].concat(r.get('bids') || [])));
                }, 0);
                return r.guildMembers;
            }
        }
    ],
    isFull: function() {
        return this.get('current_count') == this.get('max_count');
    },
    isUserHead: function() {
        return this.get('head').display_title == ExGods.app.getUser().get('display_title');
    },
    getMembersCount: function() {
        var bids = this.get('bids'),
            bidsCount = bids ? bids.length : 0;
        return this.get('users').getCount() - bidsCount;
    }
});

/**
 *  
 */
Ext.define('ExGods.store.Guilds', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Guild',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'left_count',
            direction: 'ASC'
        }
    ],
    getUserGuild: function() {
        if (ExGods.app.getUser().getGuild())  {
            return this.getAt(0);
        }
        
    }
});

/**
 *   
 */
Ext.define('ExGods.model.GuildMember', {
    extend: ExGods.model.BasicUser,
    fields: [
        {
            name: 'guild_points',
            type: 'int'
        },
        {
            name: 'isBid',
            type: 'boolean'
        },
        {
            name: 'guild_noob',
            type: 'int'
        },
        {
            //  
            name: 'guild',
            type: 'auto',
            convert: function(v) {
                if (typeof v != 'object') {
                    return '';
                }
                return v;
            }
        },
        {
            //  -        .  
            name: 'can_snet_notice_inactive',
            type: 'int'
        },
        {
            //  .   (user_id, social_net, social_net_id)
            name: 'social',
            type: 'auto'
        }
    ]
});

/**
 *   
 */
Ext.define('ExGods.store.GuildMembers', {
    extend: Ext.data.Store,
    model: 'ExGods.model.GuildMember',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'isBid',
            direction: 'DESC'
        },
        {
            property: 'online',
            direction: 'DESC'
        },
        {
            property: 'guild_points',
            direction: 'DESC'
        }
    ],
    constructor: function(config) {
        var me = this;
        Ext.apply(me.config, config);
        me.config.sorters.push({
            sorterFn: function(m1, m2) {
                if (!me.config.guild)  {
                    return 0;
                }
                
                var title = me.config.guild.get('head').display_title,
                    v = 0;
                if (m1.get('display_title') == title)  {
                    v = -1;
                }
                
                if (m2.get('display_title') == title)  {
                    v = 1;
                }
                
                return v;
            }
        });
        me.callParent(arguments);
    }
});

/**
 *    
 */
Ext.define('ExGods.store.GuildGroupOnlineList', {
    extend: ExGodsCore.store.ChatContacts,
    model: 'ExGods.model.BasicUser'
});

/**
 *   
 */
Ext.define('ExGods.store.GuildRaids', {
    extend: Ext.data.Store,
    model: 'ExGods.model.GuildRaid',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            property: 'l_order',
            direction: 'ASC'
        }
    ],
    loadRawData: function(data) {
        var me = this,
            i = data.length,
            addRewards = function(recData) {
                var i = recData.achievement.stages.length,
                    rewards = [];
                while (i--) {
                    rewards = rewards.concat(recData.achievement.stages[i].rewards);
                }
                recData.rewards = rewards;
            };
        while (i--) {
            addRewards(data[i]);
        }
        me.callParent(arguments);
    }
});

/**
 *   
 */
Ext.define('ExGods.store.GuildRequests', {
    extend: Ext.data.Store,
    model: 'ExGods.model.GuildRequest',
    proxy: {
        type: 'memory'
    },
    sorters: [
        {
            sorterFn: function(m1, m2) {
                var v = 0;
                if (m1.get('owner'))  {
                    v = -1;
                }
                
                if (m2.get('owner'))  {
                    v = 1;
                }
                
                return v;
            }
        },
        {
            property: 'timeout',
            direction: 'ASC'
        }
    ]
});

/**
 *   
 */
Ext.define('ExGods.store.GuildGroups', {
    extend: Ext.data.Store,
    model: 'ExGods.model.GuildGroup',
    proxy: {
        type: 'memory'
    }
});

Ext.define('ExGods.view.guild.Search', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildsearch',
    id: 'guild_search',
    layout: 'fit',
    padding: '6 10 12',
    margin: 4,
    plugins: [
        'paperdeco'
    ],
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-title"><h4>' + cfg.search_title + '</h4></div>'
            },
            {
                dock: 'top',
                xtype: 'form',
                layout: {
                    type: 'hbox',
                    pack: 'center',
                    align: 'center'
                },
                margin: '3 8',
                items: [
                    {
                        xtype: 'textfield',
                        ui: 'guild',
                        enableKeyEvents: true,
                        emptyText: cfg.search_empty_text,
                        margin: 2,
                        width: 180
                    },
                    {
                        xtype: 'radiogroup',
                        ui: 'guild',
                        layout: 'hbox',
                        items: [
                            {
                                boxLabel: cfg.search_radio_all_guilds,
                                inputValue: 0,
                                name: 'guild_type',
                                checked: true,
                                width: 120
                            },
                            {
                                boxLabel: cfg.search_radio_open_guilds,
                                inputValue: 1,
                                name: 'guild_type',
                                width: 120
                            },
                            {
                                boxLabel: cfg.search_radio_closed_guilds + '<span class="closed-guild"></span>',
                                inputValue: 2,
                                name: 'guild_type',
                                width: 120
                            }
                        ]
                    },
                    {
                        xtype: 'combo',
                        ui: 'guild',
                        store: Ext.create('Ext.data.Store', {
                            fields: [
                                'value',
                                'label'
                            ],
                            data: [
                                {
                                    value: 'ASC',
                                    label: cfg.search_combo_asc
                                },
                                {
                                    value: 'DESC',
                                    label: cfg.search_combo_desc
                                }
                            ]
                        }),
                        value: 'ASC',
                        editable: false,
                        queryMode: 'local',
                        displayField: 'label',
                        valueField: 'value',
                        margin: 2,
                        width: 180
                    }
                ]
            },
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            },
            {
                dock: 'bottom',
                xtype: 'panel',
                margin: '0 10 10 5',
                height: 43,
                items: [
                    {
                        xtype: 'component',
                        padding: '8 5',
                        height: 48,
                        style: {
                            display: 'table-cell',
                            verticalAlign: 'middle'
                        },
                        html: cfg.search_create_guild_description
                    }
                ],
                dockedItems: [
                    {
                        dock: 'right',
                        xtype: 'textbutton',
                        itemId: 'show_create_form',
                        text: cfg.search_create_guild_btn,
                        cls: 'no_border_double'
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.items = [
            {
                xtype: 'guildslist',
                noEmpty: true,
                store: me.store
            }
        ];
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'combobox_btn.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.CreateForm', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildcreate',
    id: 'guild_create',
    layout: 'fit',
    padding: '0 0 8 0',
    margin: 4,
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.guildOptions = {};
        me.items = [
            {
                xtype: 'form',
                plugins: [
                    'paperdeco'
                ],
                padding: '6 10 12',
                margin: '0 0 -4 0',
                items: [
                    {
                        xtype: 'component',
                        html: [
                            '<div class="paper-title"><h4>' + cfg.create_title + '</h4></div>',
                            '<p class="guild-create-description">' + cfg.create_description + '</p>',
                            '<div class="paper-separator"></div>'
                        ]
                    },
                    {
                        xtype: 'textfield',
                        fieldLabel: cfg.create_title_field,
                        //maxLength:500,
                        labelWidth: 110,
                        width: 410,
                        //allowBlank:false,
                        margin: '10 0 0 10',
                        name: 'title'
                    },
                    {
                        xtype: 'textfield',
                        fieldLabel: cfg.create_tag_field,
                        //maxLength:10,
                        labelWidth: 110,
                        width: 235,
                        //allowBlank:false,
                        margin: '10 0 0 10',
                        name: 'tag'
                    },
                    {
                        xtype: 'textarea',
                        fieldLabel: cfg.create_description_field,
                        maxLength: 1500,
                        labelWidth: 110,
                        width: 725,
                        height: 100,
                        name: 'description',
                        margin: '10 0 10 10'
                    },
                    {
                        xtype: 'component',
                        html: '<div class="paper-separator"></div>'
                    },
                    {
                        xtype: 'radiogroup',
                        margin: '10 0 10 10',
                        layout: 'vbox',
                        minWidth: 500,
                        items: [
                            {
                                boxLabel: cfg.create_option_open_guild,
                                inputValue: 0,
                                minWidth: 500,
                                name: 'options',
                                checked: true
                            }
                        ].concat(Ext.Array.map(me.service.data.options, function(opt, i) {
                            var label = opt.label;
                            if (opt.price && opt.price.length) {
                                label += ExGods.util.Stuff.printStuff(opt.price);
                            }
                            if (opt.description) {
                                label += '<div class="item_info" data-option_id="' + opt.entry + '"></div>';
                                me.guildOptions[opt.entry] = opt.description;
                            }
                            return {
                                minWidth: 500,
                                boxLabel: label,
                                inputValue: opt.entry,
                                name: 'options'
                            };
                        }))
                    }
                ]
            }
        ];
        me.buttons = {
            defaultType: 'textbutton',
            items: [
                {
                    text: cfg.create_create_btn,
                    itemId: 'create_guild',
                    minWidth: 100,
                    margin: '0 5'
                },
                {
                    text: cfg.create_back_btn,
                    itemId: 'back_to_guild_search',
                    minWidth: 100,
                    margin: '0 5',
                    cls: 'x-btn-txt-red'
                }
            ]
        };
        me.callParent();
    },
    afterRender: function() {
        var me = this;
        me.callParent();
        me.el.on('click', function(e) {
            var optEl = e.target,
                desc = me.guildOptions[optEl.dataset.option_id];
            me.fireEvent('optioninfoclick', me, optEl, desc);
        }, me, {
            delegate: '.item_info'
        });
    },
    onShow: function() {
        var me = this;
        me.callParent();
        me.items.getAt(0).items.getAt(1).inputEl.focus();
    }
});

Ext.define('ExGods.view.guild.WaitBid', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildwait',
    id: 'guild_wait',
    layout: 'fit',
    padding: '6 10 12',
    margin: 4,
    plugins: [
        'paperdeco'
    ],
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                itemId: 'guild_description',
                data: me.service.data.guild,
                tpl: [
                    '<div class="paper-title"><h4>{[this.getTitleTpl(values)]}{[this.getClosedHTML(values)]}</h4></div>',
                    '<div class="guild-info-description">',
                    '{description}',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    {
                        getClosedHTML: function(values) {
                            if (!values.open) {
                                return '<span class="closed-guild"></span>';
                            } else {
                                return '';
                            }
                        },
                        getTitleTpl: function(values) {
                            return ExGods.app.applyTpl(cfg.wait_title_tpl, values);
                        }
                    }
                ]
            },
            {
                xtype: 'toolbar',
                dock: 'bottom',
                layout: {
                    pack: 'center'
                },
                items: [
                    {
                        xtype: 'textbutton',
                        text: cfg.wait_call_back_bit_btn,
                        itemId: 'call_back_bid',
                        cls: 'no_border'
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.items = [
            {
                xtype: 'component',
                cls: 'guild-wait-description',
                html: ExGods.app.applyTpl(cfg.wait_desc, Ext.applyIf({
                    head: ExGods.printUser(me.service.data.guild.head, {
                        fields: "infoiconleft,name,rank,level"
                    })
                }, me.service.data.guild))
            }
        ];
        me.callParent();
    }
});

Ext.define('ExGods.view.guild.ListItem', {
    extend: ExGods.view.ListItem,
    alias: 'widget.guildlistitem',
    //margin:'0 0 -3px 0',
    viewChangeSelector: '.guild-item-view-change-selector',
    initComponent: function() {
        var me = this;
        var templateHelpers = {
                getFullCls: function(values) {
                    return values.current_count < values.max_count ? '' : ' full';
                },
                printClosed: function(values) {
                    return values.open ? '' : '<span class="closed-guild"></span>';
                }
            };
        var expanded = [
                '<div class="guild-item-title"><span>[{tag}] {title}</span>{[this.templateHelpers.printClosed(values)]}</div>',
                '<div class="guild-item-head">{[ ExGods.printUser(values.head, {fields: "infoiconleft,name,rank,level", maxNameWidth: 84})]}</div>',
                '<div class="guild-item-users{[this.templateHelpers.getFullCls(values)]}">{current_count}/{max_count}</div>',
                '<div class="guild-item-collapse guild-item-view-change-selector"></div>',
                '<div class="guild-item-btn-place" id="guild-item-btn-place-{id}"></div>',
                '<div class="guild-item-description">{description}</div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        var collapsed = [
                '<div class="guild-item-title"><span>[{tag}] {title}</span>{[this.templateHelpers.printClosed(values)]}</div>',
                '<div class="guild-item-head">{[ ExGods.printUser(values.head, {fields: "infoiconleft,name,rank,level", maxNameWidth: 84})]}</div>',
                '<div class="guild-item-users{[this.templateHelpers.getFullCls(values)]}">{current_count}/{max_count}</div>',
                '<div class="guild-item-expand guild-item-view-change-selector"></div>',
                '<div class="guild-item-btn-place" id="guild-item-btn-place-{id}"></div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        //me.itemId = me.record.get('proto_id');
        me.cls = me.record.store.indexOf(me.record) % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
        me.expanded = me.setTpl(expanded);
        me.collapsed = me.setTpl(collapsed);
        me.callParent(arguments);
        me.on('render', function() {
            if (me.record.get('expanded') == true) {
                me.expand();
            } else {
                me.collapse();
            }
        });
    },
    renderButton: function() {
        var me = this;
        Ext.widget('textbutton', {
            xtype: 'textbutton',
            text: ExGods.getMsgByKey('view_guild_enter_btn_text'),
            cls: 'no_border',
            renderTo: 'guild-item-btn-place-' + me.record.get('id'),
            handler: function() {
                me.fireEvent('join_guild', me.record);
            }
        });
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.on('afterlayout', function() {
            ExGods.util.Helper.renderComponents(me.el, me);
        }, me);
    },
    collapse: function() {
        var me = this;
        me.collapsed.overwrite(me.el, me.record.data);
        me.renderButton();
        me.record.set('expanded', false);
        me.callParent();
    },
    expand: function() {
        var me = this;
        me.expanded.overwrite(me.el, me.record.data);
        me.renderButton();
        me.record.set('expanded', true);
        me.callParent();
    }
});

Ext.define('ExGods.view.guild.GuildsList', {
    extend: ExGods.view.List,
    alias: 'widget.guildslist',
    initComponent: function() {
        var me = this;
        me.itemWidgetConfig = {
            xtype: 'guildlistitem',
            listeners: {
                expand: me.onItemExpand,
                collapse: me.onItemCollapse,
                scope: me
            }
        };
        me.callParent();
    },
    onItemExpand: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onItemCollapse: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'guild/btn_list_close.png',
                IMAGE_URL + 'guild/btn_list_open.png',
                IMAGE_URL + 'ico_guild_closed.png',
                IMAGE_URL + 'radiobutton.png',
                IMAGE_URL + 'radiobutton_selected_blue.png',
                IMAGE_URL + 'shop/btn_buy.png',
                IMAGE_URL + 'btn_standart_high.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.GuildInfo', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildinfo',
    id: 'guild_info',
    layout: 'fit',
    padding: '6 10 12',
    plugins: [
        'paperdeco'
    ],
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            can_leave = !me.guild.isUserHead() || me.guild.getMembersCount() == 1,
            cfg = me.service.init_config,
            store = me.guild.get('users');
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                itemId: 'guild_description',
                data: me.guild.data,
                tpl: [
                    '<div class="paper-title"><h4>{[this.getTitleTpl(values)]}{[this.getClosedHTML(values)]} ({current_count}/{max_count})</h4></div>',
                    '<div class="guild-info-description">',
                    '{description}',
                    '<div class="guild-info-change-description-btn{[this.setVisible(values)]}"></div>',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    {
                        setVisible: function() {
                            return me.guild.isUserHead() ? '' : ' hidden';
                        },
                        getClosedHTML: function(values) {
                            if (!values.open) {
                                return '<span class="closed-guild"></span>';
                            } else {
                                return '';
                            }
                        },
                        getTitleTpl: function(values) {
                            return ExGods.app.applyTpl(cfg.guild_title_tpl, values);
                        }
                    }
                ],
                listeners: {
                    render: function() {
                        this.el.on('click', function() {
                            if (me.guild.isUserHead())  {
                                me.fireEvent('change_description', me.guild, me);
                            }
                            
                        }, me, {
                            delegate: '.guild-info-change-description-btn'
                        });
                        this.el.on('dblclick', function() {
                            if (me.guild.isUserHead())  {
                                me.fireEvent('change_description', me.guild, me);
                            }
                            
                        }, me, {
                            delegate: '.guild-info-description'
                        });
                    }
                }
            },
            {
                xtype: 'toolbar',
                dock: 'bottom',
                layout: {
                    pack: 'center'
                },
                //ui:'footer',
                //defaults: {minWidth: minButtonWidth},
                items: [
                    {
                        xtype: 'textbutton',
                        text: cfg.guild_change_head,
                        itemId: 'change_guild_head',
                        cls: 'no_border',
                        hidden: can_leave
                    },
                    {
                        xtype: 'textbutton',
                        text: cfg.guild_leave,
                        itemId: 'leave_guild',
                        cls: 'no_border',
                        hidden: !can_leave
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                items: [
                    {
                        xtype: 'dataview',
                        store: store,
                        autoEl: 'ul',
                        cls: 'guild-info-list',
                        itemSelector: 'li',
                        tpl: [
                            '<tpl for=".">',
                            '<li class="{[this.getBgCls(xindex)]}">',
                            '<div class="guild-member-online{[this.getOnlineCls(values)]}"></div>',
                            '<div class="guild-member-status">',
                            '{[this.getHead(values.display_title)]}',
                            '</div>',
                            '<div class="guild-member-title">',
                            '{[ ExGods.printUser(values, {fields: "infoiconleft,name,rank,level", maxNameWidth: 350})]}',
                            '</div>',
                            '<div class="guild-member-points">{[this.getGuildPoints(values)]}</div>',
                            '<tpl if="this.isUserHead()">',
                            '<tpl if="isBid">',
                            '<div class="guild-member-bid-accept-btn"></div>',
                            '<div class="guild-member-bid-decline-btn"></div>',
                            '<tpl elseif="!this.getHead(values.display_title)">',
                            '<div class="guild-member-kick-btn"></div>',
                            '<tpl if="this.canSendSocialMessage(values)">',
                            '<div class="guild-member-send-social-message-btn" data-qtip="' + ExGods.getMsgByKey('view_guild_social_message_btn_tip') + '"></div>',
                            '</tpl>',
                            '</tpl>',
                            '</tpl>',
                            '</li>',
                            '</tpl>',
                            {
                                getBgCls: function(i) {
                                    return i % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
                                },
                                getOnlineCls: function(values) {
                                    if (values.isBid) {
                                        return ' bid';
                                    } else if (values.online) {
                                        return ' online';
                                    } else {
                                        return '';
                                    }
                                },
                                getHead: function(title) {
                                    return me.guild.get('head').display_title == title ? cfg.head : '';
                                },
                                isUserHead: function() {
                                    return me.guild.isUserHead();
                                },
                                getGuildPoints: function(values) {
                                    if (values.isBid) {
                                        return cfg.candidate;
                                    } else if (values.guild_noob) {
                                        return cfg.guild_noob;
                                    } else {
                                        return '<span class="rating-value" data-qtip="' + cfg.guild_points_tt + '" style="background-image: url(' + IMAGE_URL + cfg.guild_points_img + ')">' + values.guild_points + '</span>';
                                    }
                                },
                                canSendSocialMessage: function(values) {
                                    return values.can_snet_notice_inactive && ExGods.app.getSocialController().isCanSendUserToUserMessage();
                                }
                            }
                        ]
                    }
                ]
            }
        ];
        me.callParent();
        store.on('datachanged', me.updateBtns, me);
        store.on('update', me.updateBtns, me);
    },
    updateBtns: function(store) {
        var me = this;
        if (me.guild.isUserHead() && me.guild.getMembersCount() > 1) {
            me.down('#change_guild_head').show();
            me.down('#leave_guild').hide();
        } else {
            me.down('#change_guild_head').hide();
            me.down('#leave_guild').show();
        }
    },
    onDestroy: function() {
        var me = this,
            store = me.guild.get('users');
        store.un('datachanged', me.updateBtns, me);
        store.un('update', me.updateBtns, me);
        me.callParent(arguments);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            cfg = me.service.init_config;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'guild/offline.png',
                IMAGE_URL + 'guild/online.png',
                IMAGE_URL + 'guild/request.png',
                IMAGE_URL + 'guild/btn_exclude.png',
                IMAGE_URL + 'guild/btn_send_msg.png',
                IMAGE_URL + 'guild/btn_accept.png',
                IMAGE_URL + 'guild/btn_exclude.png',
                IMAGE_URL + 'guild/btn_edit.png',
                IMAGE_URL + cfg.guild_points_img
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.Help', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildhelp',
    id: 'guild_help',
    layout: 'hbox',
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser(),
            cfg = me.service.init_config;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                html: [
                    '<div class="paper-title"><h4>' + cfg.help_title + '</h4></div>',
                    '<p class="guild-help-description"></p>'
                ],
                listeners: {
                    afterrender: function() {
                        me.updateTimed(user.get('timed')[me.service.data.timed], true);
                        user.on(me.service.data.timed + 'changed', me.updateTimed, me);
                    },
                    destroy: function() {
                        user.un(me.service.timed + 'changed', me.updateTimed, me);
                    }
                }
            }
        ];
        me.items = [
            {
                xtype: 'guildrequestslist',
                store: me.myRequestsStore,
                title: cfg.help_my_requests_title,
                description: cfg.help_my_requests_description,
                listItemTpl: [
                    '<div class="guild-my-request-label{[this.getCls(values.timeout,values.owner)]}">',
                    '{label}',
                    '<span class="right">',
                    '<tpl if="owner">',
                    '<span class="current">{current_count}</span>/{max_count}',
                    '<tpl else>',
                    '<tpl if="timeout">',
                    '{[ExGods.util.Time.printTime(values.timeout,{format:"short"})]}',
                    '<tpl else>',
                    ExGods.getMsgByKey('view_guild_help_availrequest'),
                    '</tpl>',
                    '</tpl>',
                    '</span>',
                    '</div>'
                ].join(''),
                listItemMethods: {
                    getCls: function(timeout, owner) {
                        return timeout && !owner ? ' grey' : '';
                    }
                },
                width: 300
            },
            {
                xtype: 'guildrequestslist',
                store: me.requestsStore,
                listItemTpl: [
                    '<div class="guild-request-title">',
                    '{[ this.getHead(values.owner.display_title) ]}',
                    '{[ ExGods.printUser(values.owner, {fields: "infoiconleft,name,rank,level", maxNameWidth: 84})]}',
                    '</div>',
                    '<div class="guild-request-label">',
                    '{label}',
                    '</div>',
                    '<div class="guild-request-count">',
                    '<span class="current">{current_count}</span>/{max_count}',
                    '</div>',
                    '<div class="guild-request-help-btn">',
                    '<div class="component">',
                    '<span role="xtype">textbutton</span>',
                    '<span role="cls">no_border{[this.red(values)]}</span>',
                    '<span role="text">' + cfg.help_help_btn + '</span>',
                    '<span role="width">70px</span>',
                    '<span role="minWidth">70px</span>',
                    '<span role="action">guild_help</span>',
                    '<span role="request_id">{id}</span>',
                    '</div>',
                    '</div>'
                ].join(''),
                title: cfg.help_requests_title,
                description: cfg.help_requests_description,
                listItemMethods: {
                    getHead: function(title) {
                        return me.guild.get('head').display_title == title ? '<span class="guild-member-head">' + cfg.head + '</span>' : '';
                    },
                    red: function(values) {
                        return values.type_request == 'meddle' ? ' x-btn-txt-red' : '';
                    }
                },
                flex: 1
            }
        ];
        me.callParent();
    },
    updateTimed: function(timed, value_changed) {
        var me = this,
            cfg = me.service.init_config,
            time = new Date(timed[3]) - new Date() + 1000;
        // 
        if (!me.el)  {
            return;
        }
        
        time = Math.max(1, time / 1000);
        var el = me.el.down('.guild-help-description'),
            text = (timed[3] && timed[0] != timed[1]) ? cfg.help_timed_text : cfg.help_full_timed_text;
        tpl = ExGods.app.applyTpl(text, {
            timed_current: Math.floor(timed[0]),
            timed_max: timed[1],
            timed_timer: [
                '<span id="guild-help-timed-timer">',
                ExGods.util.Time.printTime(time, {
                    format: 'short'
                }),
                '</span>'
            ].join('')
        });
        el.setHTML(tpl);
    }
});

Ext.define('ExGods.view.guild.RequestsList', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildrequestslist',
    cls: 'guild-request-list',
    plugins: [
        'paperdeco'
    ],
    height: '100%',
    listItemTpl: '',
    listItemMethods: {},
    initComponent: function() {
        var me = this,
            title = me.title;
        me.title = false;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-title"><h4>' + title + '<div class="item_info"></div></h4></div>'
            }
        ];
        me.items = [
            {
                xtype: 'dataview',
                itemSelector: 'li',
                autoEl: 'ul',
                padding: '0 11',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                store: me.store,
                tpl: [
                    '<tpl for=".">',
                    '<li class="{[this.getBgCls(values.index)]}">',
                    me.listItemTpl,
                    '</li>',
                    '</tpl>',
                    Ext.apply({
                        getBgCls: function(i) {
                            return i % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
                        }
                    }, me.listItemMethods)
                ],
                listeners: {
                    beforerefresh: function(view) {
                        ExGods.util.Helper.destroyComponents(view.el);
                    },
                    refresh: function(view) {
                        ExGods.util.Helper.renderComponents(view.el, view);
                    }
                }
            }
        ];
        me.callParent(arguments);
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.down('.item_info').on('click', me.onInfoClick, me);
    },
    onInfoClick: function(e) {
        this.fireEvent('infoclick', this, e.currentTarget, this.description);
    },
    onDestroy: function() {
        var me = this;
        if (me.el && me.el.down('.item_info'))  {
            me.el.down('.item_info').un('click', me.onInfoClick, me);
        }
        
        me.callParent(arguments);
    }
});

Ext.define('ExGods.view.guild.Shop', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildshop',
    id: 'guild-shop',
    /**
     * @cfg {ExGods.model.Guild} guild  
     */
    guild: null,
    /**
     * @cfg {ExGods.service.Guilds} service  
     */
    service: null,
    plugins: [
        {
            ptype: 'pager',
            marginLeft: -38,
            marginRight: -36,
            top: 164,
            textTop: 348,
            textLeft: 324
        }
    ],
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser(),
            cfg = me.service.init_config;
        me.store = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.ShopItem'
        });
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'panel',
                plugins: [
                    'paperdeco'
                ],
                id: 'guild-shop-header',
                layout: {
                    type: 'vbox',
                    align: 'stretch'
                },
                margin: '0 0 -5 0',
                items: [
                    {
                        xtype: 'component',
                        html: '<div class="paper-title"><h4>' + cfg.guild_shop_title + '</h4></div>'
                    },
                    {
                        layout: 'hbox',
                        margin: '-6 0 0 0',
                        bodyPadding: '0 20 15 20',
                        items: [
                            {
                                xtype: 'component',
                                itemId: 'guild-points',
                                cls: 'points-text',
                                tpl: cfg.guild_shop_points_text,
                                data: {
                                    points: ExGods.util.Stuff.printStuff({
                                        type: 'currency',
                                        params: {
                                            id: 'guild',
                                            quantity: ExGods.app.user.get('money').guild || 0
                                        }
                                    })
                                }
                            },
                            {
                                xtype: 'tbfill'
                            },
                            {
                                xtype: 'checkboxfield',
                                boxLabel: cfg.guild_shop_avail_text,
                                checked: true,
                                style: {
                                    color: '#e3ac69'
                                },
                                listeners: {
                                    change: function(f, value) {
                                        me.updateFilters('level', value);
                                    },
                                    scope: me
                                },
                                margin: '0 20 0 0'
                            },
                            {
                                xtype: 'textfield',
                                emptyText: cfg.guild_shop_search_placeholder,
                                height: 22,
                                listeners: {
                                    change: {
                                        fn: function(f, value) {
                                            me.updateFilters('text', value);
                                        },
                                        buffer: 100
                                    },
                                    scope: me
                                },
                                padding: 1,
                                value: ''
                            }
                        ]
                    }
                ]
            }
        ];
        me.shopView = Ext.widget('shop', {
            height: 283,
            store: me.store,
            emptyText: cfg.guild_shop_empty_text
        });
        me.items = [
            me.shopView
        ];
        me.on({
            next: me.showNextPage,
            prev: me.showPrevPage,
            scope: me
        });
        me.mon(ExGods.app.user, 'moneychanged', me.onUserMoneyChanged, me);
        me.callParent();
    },
    // =============== PRIVATES ============================
    afterRender: function() {
        var me = this,
            _bindService = function() {
                me.mon(me.service.shopService, 'init', me.fillStoreFromService, me);
                me.mon(me.service.shopService, 'update', me.fillStoreFromService, me);
                me.shopService = me.service.shopService;
                if (!me.service.shopService.initialized) {
                    ExGods.app.block();
                } else //   
                {
                    me.fillStoreFromService();
                }
            };
        if (me.service.shopService) {
            _bindService();
        } else {
            setTimeout(function() {
                _bindService();
            }, 0);
        }
        me.callParent(arguments);
    },
    fillStoreFromService: function() {
        var me = this,
            items = [],
            missedProtos = [],
            shopModel;
        if (me.service.shopService.data.shops.length) {
            missedProtos = ExGods.model.Shop.getMissedProtos(me.service.shopService.data.shops[0]);
            ExGods.app.getItemPrototypesStore().loadNew(missedProtos, function() {
                shopModel = Ext.create('ExGods.model.Shop', me.service.shopService.data.shops[0]);
                me.store.loadRawData(shopModel.items().getRange());
                me.updatePager();
                ExGods.app.unblock();
            });
        } else {
            ExGods.app.unblock();
        }
    },
    updateFilters: function(filterName, value) {
        var me = this;
        if (filterName == 'level') {
            me.shopView.setFilterByLevel(value);
        } else if (filterName == 'text') {
            me.shopView.setTextFilter(value);
        }
        me.updatePager();
    },
    updatePager: function() {
        var me = this,
            total;
        if (me.pager) {
            //   (   8 ,    -   8)      
            if (me.store.getCount()) {
                total = Math.ceil(me.store.getCount() / 8);
            } else {
                total = 1;
            }
            Ext.apply(me.pager, {
                current: 1,
                total: total
            });
            me.pager.refresh();
        }
    },
    showNextPage: function() {
        var me = this;
        me.openPage(-1);
        me.pager.refresh();
    },
    showPrevPage: function() {
        var me = this;
        me.openPage(1);
        me.pager.refresh();
    },
    openPage: function(direction) {
        var me = this,
            ul = me.shopView.getEl().down('.shop-items'),
            marginTop = parseInt(ul.getStyle('margin-top').split('p')[0]),
            offsetHeight = 282;
        ul.setStyle('margin-top', (marginTop + offsetHeight * direction) + 'px');
    },
    onUserMoneyChanged: function() {
        var me = this;
        me.dockedItems.items[0].down('#guild-points').update({
            points: ExGods.util.Stuff.printStuff({
                type: 'currency',
                params: {
                    id: 'guild',
                    quantity: ExGods.app.user.get('money').guild || 0
                }
            })
        });
    }
});

Ext.define('ExGods.view.guild.Quests', {
    extend: ExGods.view.List,
    alias: 'widget.guildquests',
    id: 'guild_quests',
    cls: 'questnewlist',
    //margin:'-3px -3px 0 -3px',
    plugins: [
        {
            animate: true,
            ptype: 'scroller',
            scrollDeltaY: 50,
            autoHide: true,
            autoRestorePosition: true,
            padding: '3px 3px 0 0'
        }
    ],
    emptyTpl: [
        '<p class="central-window-empty">{text}</p>'
    ],
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.itemWidgetConfig = {
            xtype: 'guildquestlistitem',
            service: me.service,
            listeners: {
                expand: me.onItemExpand,
                collapse: me.onItemCollapse,
                scope: me
            }
        };
        me.emptyData = {
            text: me.service.data.guild_noob ? cfg.quests_guild_noob : cfg.quests_empty_text
        };
        me.callParent(arguments);
    },
    onItemExpand: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    onItemCollapse: function() {
        var me = this;
        me.scroller.catchPosition();
        me.updateLayout();
        me.scroller.restorePosition();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            cfg = me.service.init_config;
        var arr_images = [];
        return {
            stuff: [],
            images: [].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.QuestListItem', {
    extend: ExGods.view.ListItem,
    alias: 'widget.guildquestlistitem',
    margin: '0 0 -3px 0',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        var templateHelpers = {
                printDailyTimer: function(values) {
                    if (!values.done_date) {
                        var task_id = values.task_id,
                            y = new Date().getFullYear(),
                            m = new Date().getMonth() + 1,
                            d = new Date().getDate() + 1;
                        if (m.toString().length == 1)  {
                            m = '0' + m;
                        }
                        
                        if (d.toString().length == 1)  {
                            d = '0' + d;
                        }
                        
                        var date = new Date(y + '-' + m + '-' + d);
                        if (!date.getTime()) {
                            m = new Date().getMonth() + 2;
                            if (m.toString().length == 1)  {
                                m = '0' + m;
                            }
                            
                            date = new Date(y + '-' + m + '-01');
                        }
                        date = date.getTime() + date.getTimezoneOffset() * 60 * 1000 - ExGods.util.Date.serverTimeOffset * 1000;
                        return ExGods.util.Timers.printTimer('rest', 'guild-quest-timer' + task_id, new Date(date), {
                            needNormalized: false,
                            format: 'short'
                        });
                    } else {
                        return cfg.quest_complete;
                    }
                },
                getCompleteCls: function(values) {
                    return values.done_date ? ' complete' : '';
                }
            };
        var expanded = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{title}</h4>',
                '<div class="view-change-selector expanded"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url(' + IMAGE_URL + '{image})"></div>',
                '</div>',
                '<div class="quest-timer{[this.templateHelpers.getCompleteCls(values)]}">',
                '<span class="dropdown">',
                '{[this.templateHelpers.printDailyTimer(values)]}',
                '</span>',
                '</div>',
                '</div>',
                '<div class="wide-column">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_aim'] + ');"></div>',
                '<div class="info-box-content guild-short-description">',
                '{description_short} ({params.points}/{[values.stages[values.stages.length - 1].counter]})',
                '</div>',
                '</div>',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_award'] + ');"></div>',
                '<div class="info-box-content info-box-rewards">',
                '<ul>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '<li class="info-box-itembox"></li>',
                '</ul>',
                '<tpl for="stages">',
                '<div class="guild-quest-stage-count">',
                '<img src="{[this.getStageCompleteIcon(parent.params.stage,xindex)]}">',
                '{[ExGods.printNumber(values.counter,1000,"0","0.0")]}',
                '</div>',
                '</tpl>',
                '</div>',
                '</div>',
                '</div>',
                '<div class="quest-description">{description}</div>',
                '<div class="paper-separator"></div>',
                '</div>',
                '<div class="guild-quest-pcp">',
                '<div class="paper-title"><h4>' + cfg.quests_pcp_title + '</h4></div>',
                //TODO
                '<tpl if="pcp.length">',
                '<table class="list">',
                '<tpl for="pcp">',
                '<tr class="{[ xindex % 2 ? "exg-share-bg-light" : "exg-share-bg-dark" ]}">',
                '<td class="place-cell">',
                '<tpl if="xindex &gt;= 1 && xindex &lt;= 3">',
                '<div class="place-{[xindex]}"><img width="76" height="24" src="{[ this.getPlaceImage(xindex) ]}"></div>',
                '<tpl else>',
                '<span>{[ExGods.app.applyTpl("' + ExGods.getMsgByKey('rating_place') + '",{place:xindex})]}</span>',
                '</tpl>',
                '</td>',
                '<td class="username-cell">',
                '{[ ExGods.printUser(values.user, {fields: "name,rank,level,infoicon"}) ]}',
                '</td>',
                '<td class="count-cell">',
                '{[this.printValue(values.count)]}',
                '</td>',
                '</tr>',
                '</tpl>',
                '</table>',
                '</tpl>',
                '</div>',
                {
                    templateHelpers: templateHelpers,
                    printValue: function(value) {
                        return '<span class="rating-value" style="background-image: url(' + IMAGE_URL + cfg.guild_points_img + ')">' + value + '</span>';
                    },
                    getStageCompleteIcon: function(stage, index) {
                        return stage >= index ? IMAGE_URL + 'icons/done.png' : IMAGE_URL + 'icons/undone.png';
                    },
                    getPlaceImage: function(rank) {
                        return ExGods.ref('images|rating_place_icons').image['place' + rank];
                    }
                }
            ];
        var collapsed = [
                '<div class="paper paper-tl"></div>',
                '<div class="paper paper-tm"></div>',
                '<div class="paper paper-tr"></div>',
                '<div class="paper paper-mr"></div>',
                '<div class="paper paper-br"></div>',
                '<div class="paper paper-bm"></div>',
                '<div class="paper paper-bl"></div>',
                '<div class="paper paper-ml"></div>',
                '<div class="paper paper-bg"></div>',
                '<div class="paper-title">',
                '<h4>{title}</h4>',
                '<div class="view-change-selector collapsed"></div>',
                '</div>',
                '<div class="quest-deco-body">',
                '<div class="narrow-column">',
                '<div class="quest-giver-border">',
                '<div class="quest-giver-image" style="background-image:url(' + IMAGE_URL + '{image})"></div>',
                '</div>',
                '<div class="quest-timer{[this.templateHelpers.getCompleteCls(values)]}">',
                '<span class="dropdown">',
                '{[this.templateHelpers.printDailyTimer(values)]}',
                '</span>',
                '</div>',
                '</div>',
                '<div class="wide-column">',
                '<div class="info-box">',
                '<div class="info-box-bg"></div>',
                '<div class="info-box-tl"></div>',
                '<div class="info-box-t"></div>',
                '<div class="info-box-tr"></div>',
                '<div class="info-box-l"></div>',
                '<div class="info-box-r"></div>',
                '<div class="info-box-bl"></div>',
                '<div class="info-box-b"></div>',
                '<div class="info-box-br"></div>',
                '<div class="title-image" style="background-image:url(' + ExGods.ref('images|common_text_images').image['title_aim'] + ');"></div>',
                '<div class="info-box-content guild-short-description">',
                '{description_short} ({params.points}/{[values.stages[values.stages.length - 1].counter]})',
                '</div>',
                '</div>',
                '</div>',
                '</div>',
                {
                    templateHelpers: templateHelpers
                }
            ];
        me.expanded = me.setTpl(expanded);
        me.collapsed = me.setTpl(collapsed);
        me.callParent(arguments);
        me.on('render', function() {
            if (me.record.get('expanded') == true) {
                me.expand();
            } else {
                me.collapse();
            }
        });
    },
    getRewards: function() {
        var me = this,
            rewards = [];
        Ext.Array.each(me.record.get('stages'), function(stage) {
            if (stage.reward && stage.reward.length)  {
                rewards.push(stage.reward[0]);
            }
            
        });
        if (rewards.length) {
            var rewardsHtml = ExGods.stuff.StuffManager.image(rewards),
                rewardsEl = document.createElement('div'),
                ul = me.el && me.el.down('.info-box-rewards ul');
            rewardsEl.innerHTML = rewardsHtml;
            Ext.get(rewardsEl).select('li').addCls('info-box-itembox');
            if (ul) {
                ul.update(rewardsEl.firstChild.innerHTML);
                for (var i = rewards.length; i < 7; i++) {
                    ul.insertHtml('beforeEnd', '<li class="info-box-itembox"></li>');
                }
            }
        }
    },
    collapse: function() {
        var me = this;
        me.collapsed.overwrite(me.el, me.record.data);
        me.record.set('expanded', false);
        me.callParent();
    },
    expand: function() {
        var me = this;
        me.expanded.overwrite(me.el, me.record.data);
        me.getRewards();
        me.record.set('expanded', true);
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            cfg = me.service.init_config;
        var arr_images = [];
        return {
            images: [
                IMAGE_URL + 'quests/bg.png',
                IMAGE_URL + 'quests/top_1.png',
                IMAGE_URL + 'quests/top_2.png',
                IMAGE_URL + 'quests/top_3.png',
                IMAGE_URL + 'quests/side_left.png',
                IMAGE_URL + 'quests/side_right.png',
                IMAGE_URL + 'quests/bottom_1.png',
                IMAGE_URL + 'quests/bottom_2.png',
                IMAGE_URL + 'quests/bottom_3.png',
                IMAGE_URL + 'quests/item_box.jpg',
                IMAGE_URL + 'quests/button_task_close.png',
                IMAGE_URL + 'scrollbar/thumb.png',
                IMAGE_URL + 'scrollbar/bg_midle.png',
                IMAGE_URL + 'scrollbar/bg_top.png',
                IMAGE_URL + 'scrollbar/bg_bottom.png',
                IMAGE_URL + 'shop/btn_buy.png',
                IMAGE_URL + 'btn_red.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.Groups', {
    extend: Ext.container.Container,
    alias: 'widget.guildgroups',
    id: 'guild_groups',
    layout: 'card',
    initComponent: function() {
        var me = this;
        me.callParent(arguments);
    },
    //me.showGroupsList();
    showGroupsList: function(data) {
        var me = this;
        if (!me.listCard) {
            me.listCard = Ext.widget('guildgroupsearch', {
                store: me.groupsStore,
                service: me.service,
                loot_types: data.loot_types
            });
            me.add(me.listCard);
        }
        me.getLayout().setActiveItem(me.listCard);
    },
    showGroupInfo: function(data) {
        var me = this;
        if (!me.infoCard) {
            me.infoCard = Ext.widget('guildgroupinfo', {
                service: me.service,
                autoShow: false
            });
            ExGods.Resources.load(me.infoCard, function() {
                me.infoCard.show();
            });
            me.add(me.infoCard);
        }
        me.infoCard.update(data);
        me.getLayout().setActiveItem(me.infoCard);
    }
});

Ext.define('ExGods.view.guild.GroupSearch', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildgroupsearch',
    id: 'guild_group_search',
    layout: 'fit',
    padding: '6 10 12',
    plugins: [
        'paperdeco'
    ],
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: [
                    '<div class="paper-title"><h4>' + cfg.group_search_title + '</h4></div>',
                    '<div class="guild-info-description">' + cfg.group_search_description + '</div>',
                    '<div class="paper-separator"></div>'
                ]
            },
            {
                xtype: 'toolbar',
                dock: 'bottom',
                vertical: true,
                layout: {
                    align: 'center',
                    pack: 'center'
                },
                items: [
                    {
                        xtype: 'textfield',
                        fieldLabel: cfg.group_create_input,
                        emptyText: cfg.group_create_input_text,
                        labelWidth: 130,
                        labelCls: 'guild-group-create-input-label',
                        width: 300,
                        margin: '5 0'
                    },
                    {
                        xtype: 'textbutton',
                        text: cfg.group_create_btn,
                        itemId: 'create_guild_group',
                        width: 130,
                        margin: '0 0 5 0',
                        cls: 'no_border'
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        if (me.loot_types.length) {
            var lootTypesRadio = {
                    xtype: 'radiogroup',
                    layout: {
                        type: 'hbox',
                        align: 'stretch',
                        pack: 'center'
                    },
                    margin: '0 0 10 0',
                    items: []
                };
            Ext.Array.each(me.loot_types, function(type, i) {
                lootTypesRadio.items.push({
                    boxLabel: cfg['group_loottype_' + type],
                    inputValue: type,
                    name: 'loot_type',
                    checked: !i
                });
            });
            me.dockedItems[1].items.splice(1, 0, lootTypesRadio);
        }
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                items: [
                    {
                        xtype: 'dataview',
                        store: me.store,
                        autoEl: 'ul',
                        cls: 'guild-groups-list',
                        itemSelector: 'li',
                        tpl: [
                            '<tpl for=".">',
                            '<li class="{[this.getBgCls(xindex)]}">',
                            '<div class="guild-groups-shape" style="background-image: url({[this.getShape(values)]})"></div>',
                            '<div class="guild-groups-creator">',
                            '{[this.getCreatorInfo(values)]}',
                            '</div>',
                            '<div class="guild-groups-description">',
                            '"{description}" [{users.length} ' + ExGods.getMsgByKey('view_guild_people_text_short') + ']',
                            '</div>',
                            '<div class="guild-groups-join-btn">',
                            '<div class="component">',
                            '<span role="xtype">textbutton</span>',
                            '<span role="cls">no_border_double</span>',
                            '<span role="text">' + cfg.group_join_btn + '</span>',
                            '<span role="minWidth">90</span>',
                            '<span role="action">guild_group_join</span>',
                            '<span role="group_id">{id}</span>',
                            '</div>',
                            '</div>',
                            '</li>',
                            '</tpl>',
                            {
                                getBgCls: function(i) {
                                    return i % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
                                },
                                getShape: function(values) {
                                    var creator,
                                        i = values.users.length;
                                    while (i--) {
                                        if (values.users[i].is_creator) {
                                            creator = values.users[i];
                                            break;
                                        }
                                    }
                                    return ExGods.ref('user_shape|' + creator.shape).thumb;
                                },
                                getCreatorInfo: function(values) {
                                    var creator,
                                        i = values.users.length;
                                    while (i--) {
                                        if (values.users[i].is_creator) {
                                            creator = values.users[i];
                                            break;
                                        }
                                    }
                                    return ExGods.printUser(creator, {
                                        fields: 'infoiconleft,name,rank,level',
                                        maxNameWidth: 270
                                    });
                                }
                            }
                        ],
                        listeners: {
                            beforerefresh: function(view) {
                                ExGods.util.Helper.destroyComponents(view.el);
                            },
                            refresh: function(view) {
                                ExGods.util.Helper.renderComponents(view.el, view);
                            }
                        }
                    }
                ]
            }
        ];
        me.callParent();
    },
    // store.on('datachanged',me.updateBtns,me);
    // store.on('update',me.updateBtns,me);
    updateBtns: function(store) {
        var me = this;
        if (me.guild.isUserHead() && me.guild.getMembersCount() > 1) {
            me.down('#change_guild_head').show();
            me.down('#leave_guild').hide();
        } else {
            me.down('#change_guild_head').hide();
            me.down('#leave_guild').show();
        }
    },
    onDestroy: function() {
        var me = this;
        // store.un('datachanged',me.updateBtns,me);
        // store.un('update',me.updateBtns,me);
        me.callParent(arguments);
    }
});

Ext.define('ExGods.view.guild.GroupInfo', {
    extend: Ext.panel.Panel,
    alias: 'widget.guildgroupinfo',
    id: 'guild_group_info',
    layout: 'fit',
    padding: '6 10 12',
    plugins: [
        'paperdeco'
    ],
    buttonAlign: 'center',
    initComponent: function() {
        var me = this,
            cfg = me.service.init_config;
        me.store = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.BasicUser',
            proxy: {
                type: 'memory'
            },
            sorters: [
                {
                    property: 'is_creator',
                    direction: 'ASC'
                }
            ]
        });
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                data: {},
                tpl: [
                    '<div class="paper-title"><h4>{[this.getTitleTpl(values)]}</h4></div>',
                    {
                        getTitleTpl: function(values) {
                            return ExGods.app.applyTpl(cfg.group_title_tpl, values);
                        }
                    }
                ]
            },
            {
                xtype: 'toolbar',
                dock: 'bottom',
                layout: {
                    pack: 'center'
                },
                items: [
                    {
                        xtype: 'textbutton',
                        text: cfg.group_change_leader,
                        itemId: 'change_guild_group_leader',
                        cls: 'no_border',
                        width: 150,
                        margin: '0 15 0 0'
                    },
                    {
                        xtype: 'textbutton',
                        text: cfg.group_leave,
                        itemId: 'leave_guild_group',
                        cls: 'no_border',
                        width: 150
                    }
                ]
            },
            {
                dock: 'bottom',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.items = [
            {
                xtype: 'panel',
                plugins: [
                    {
                        ptype: 'scroller',
                        autoHide: true,
                        autoRestorePosition: true,
                        padding: '0 1px 0 0'
                    }
                ],
                items: [
                    {
                        xtype: 'dataview',
                        store: me.store,
                        autoEl: 'ul',
                        cls: 'guild-info-list',
                        itemSelector: 'li.guild-group-member',
                        tpl: [
                            '<tpl for=".">',
                            '<li class="guild-group-member {[this.getBgCls(xindex)]}">',
                            '<div class="guild-groups-shape" style="background-image: url({[this.getShape(values)]})"></div>',
                            '<div class="guild-groups-creator">',
                            '{[this.printLeader(values)]}{[ExGods.printUser(values,{fields:"infoiconleft,name,rank,level",maxNameWidth:270})]}',
                            '<div class="guild-groups-mask-group">{mask_group}</div>',
                            '<div class="mask-grade-line">{[this.getMaskGrade(values)]}</div>',
                            '</div>',
                            '<div class="guild-groups-description">',
                            '{[ExGods.util.User.printUserStats(values.stats.stats,{inline:true})]}',
                            '</div>',
                            '<tpl if="this.canKick(values)">',
                            '<div class="guild-group-kick-btn"></div>',
                            '</tpl>',
                            '</li>',
                            '</tpl>',
                            {
                                getBgCls: function(i) {
                                    return i % 2 ? 'exg-share-bg-dark' : 'exg-share-bg-light';
                                },
                                getShape: function(values) {
                                    return ExGods.ref('user_shape|' + values.shape).thumb;
                                },
                                printLeader: function(values) {
                                    return values.display_title == me.group.creator ? cfg.leader : '';
                                },
                                canKick: function(values) {
                                    return me.group.creator == ExGods.app.getUser().get('display_title') && values.display_title != me.group.creator;
                                },
                                getMaskGrade: function(values) {
                                    var proto = ExGods.app.getItemPrototypesStore().data.getByKey(values.mask_proto_id),
                                        html = '',
                                        i = proto ? proto.data.data.item_grade : 0;
                                    while (i--) {
                                        html += '<div></div>';
                                    }
                                    return html;
                                }
                            }
                        ],
                        getResources: function() {
                            var arr_images = [];
                            for (var i = 0; i < me.store.data.items.length; i++) {
                                arr_images.push(ExGods.ref('user_shape|' + me.store.data.items[i].data.shape).thumb);
                            }
                            return {
                                stuff: [],
                                images: [].concat(arr_images)
                            };
                        }
                    }
                ]
            }
        ];
        me.callParent();
    },
    update: function(data) {
        var me = this;
        me.group = data;
        me.getDockedComponent(0).update(data);
        me.updateBtns();
        me.store.loadRawData(data.users);
    },
    updateBtns: function(store) {
        var me = this,
            changeLeaderBtn = me.down('#change_guild_group_leader');
        if (me.group.creator == ExGods.app.getUser().get('display_title') && me.group.users.length > 1) {
            changeLeaderBtn.show();
        } else {
            changeLeaderBtn.hide();
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'guild/paper_skull_bg.png'
            ].concat(arr_images)
        };
    }
});

/**
 * C    
 */
Ext.define('ExGods.view.grid.SkinGrid', {
    extend: ExGods.view.grid.Grid,
    alias: 'widget.exg_skin_grid',
    cellWidth: 105,
    cellHeight: 112,
    /**
     * isEnabled {Function}  ,  values (  ),  true/false
     */
    isEnabled: Ext.emptyFn,
    /**
     * getImage {Function}  ,  values (  ),    
     */
    getImage: Ext.emptyFn,
    initComponent: function() {
        var me = this;
        if (me.pager) {
            me.calcWidth();
            me.pager = Ext.apply({
                textTop: -31,
                textLeft: me.width / 2 - 112 / 2 - 10
            }, me.pager);
        }
        me.callParent(arguments);
    },
    /**
     *     
     * @override
     */
    initItemTemplate: function() {
        var me = this;
        me.itemTpl = [
            '<div class="exg-grid-skin-item{[this.isEnabled(values)]}">',
            '<div class="exg-grid-skin-frm"></div>',
            '<img class="image" src="{[this.getImage(values)]}">',
            '<div class="notify_i"></div>',
            '<div class="x-clear"></div>',
            '</div>',
            {
                isEnabled: function(values) {
                    return me.isEnabled(values) ? ' enabled' : '';
                },
                getImage: me.getImage.bind(me)
            }
        ];
        me.callParent(arguments);
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.addCls('exg-grid-skin');
        me.itemsView.on({
            refresh: me.renderEmptySlots,
            scope: me
        });
    },
    renderEmptySlots: function() {
        var me = this,
            pager = me.getPager(),
            ul = me.el.down('.exg-grid-items');
        var itemsPerPage = me.rowsCount * me.columnsCount,
            i = itemsPerPage - me.store.getCount() % itemsPerPage;
        while (i--) {
            ul.insertHtml('beforeEnd', [
                '<li class="exg-grid-item" style="width:' + me.cellWidth + 'px;height:' + me.cellHeight + 'px">',
                '<div class="exg-grid-skin-item empty">',
                '<div class="exg-grid-skin-frm"></div>',
                '<img class="image" src="' + IMAGE_URL + 'locations/monster_absent.jpg">',
                '<div class="x-clear"></div>',
                '</div>',
                '</li>'
            ].join(''));
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            stuff: [],
            images: [
                IMAGE_URL + 'locations/monster_absent.jpg',
                IMAGE_URL + 'locations/monster_frame_green.png',
                IMAGE_URL + 'locations/monster_frame_neutral.png',
                IMAGE_URL + 'mask/panel.png'
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.guild.Raids', {
    extend: ExGods.view.grid.SkinGrid,
    alias: 'widget.guildraids',
    itemId: 'guild_raids',
    layout: 'fit',
    padding: 20,
    rowsCount: 3,
    columnsCount: 7,
    isEnabled: function(values) {
        return values.counter > 0;
    },
    getImage: function(values) {
        if (values.counter && values.counter > 0) {
            return IMAGE_URL + values.image;
        } else {
            return IMAGE_URL + values.image2;
        }
    },
    initComponent: function() {
        var me = this;
        if (me.store.getCount() > me.rowsCount * me.columnsCount) {
            me.pager = {
                marginLeft: -63,
                marginRight: -84,
                textTop: -13
            };
        }
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        for (var i = 0; i < 0; i++) {
            arr_images.push(me.store.data.items[i].data.image);
            arr_images.push(me.store.data.items[i].data.image2);
        }
        var parent = me.callParent();
        return {
            stuff: [].concat(parent.stuff),
            images: [].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Guild', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /**
         * @method getGuildButton
         *   ""
         * @return {ExGods.view.menu.MainMenuButton}
         */
            ref: 'guildButton',
            selector: '#mainmenu-guild-button'
        },
        {
            /**
         * @method getRequestsTab
         *   ""
         * @return {ExGods.view.skin.Tab}
         */
            ref: 'requestsTab',
            selector: '#guild_help_tab'
        },
        {
            /**
         * @method getGroups
         *   ""
         * @return {ExGods.view.guild.Groups}
         */
            ref: 'groups',
            selector: '#guild_groups'
        }
    ],
    views: [
        'List',
        'guild.Container',
        'guild.Search',
        'guild.ListItem',
        'guild.GuildsList',
        'guild.CreateForm',
        'guild.GuildInfo',
        'guild.TabPanel',
        'guild.Help',
        'guild.RequestsList',
        'guild.Shop',
        'guild.Quests',
        'guild.QuestListItem',
        'guild.WaitBid',
        'guild.Groups',
        'guild.GroupSearch',
        'guild.GroupInfo',
        'guild.Raids',
        'guild.RaidInfoWindow'
    ],
    stores: [
        'Guilds',
        'GuildMembers',
        'GuildGroupOnlineList',
        'GuildRaids',
        'GuildRequests',
        'GuildGroups'
    ],
    models: [
        'GuildQuest',
        'GuildRaid',
        'GuildRequest',
        'GuildGroup'
    ],
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'Guild:'
    },
    newRequests: 0,
    init: function(app) {
        var me = this;
        me.service = ExGods.Services.get('guilds');
        if (me.service.on) {
            me.service.on('update', me.onServiceUpdate, me);
        }
        me.app.getGuildsStore().service = me.service;
        //  ,      updateRequests
        me.myRequestsStore = Ext.create('ExGods.store.GuildRequests');
        me.requestsStore = Ext.create('ExGods.store.GuildRequests');
        //  
        me.groupsStore = Ext.create('ExGods.store.GuildGroups');
        //  
        me.raidsStore = ExGods.app.getGuildRaidsStore();
        me.raidsStore.loadRawData(ExGods.references.get('guild_raids').getArray());
        //  ,      updateQuests
        me.questsStore = Ext.create('Ext.data.Store', {
            model: 'ExGods.model.GuildQuest',
            proxy: {
                type: 'memory'
            },
            sorters: [
                {
                    sorterFn: function(m1, m2) {
                        var v = 0;
                        //  
                        // 
                        // 1.   ,   
                        // 2.     
                        m1_c = m1.get('create_date') ? ExGods.util.Date.normalizeServerDateTime(m1.get('create_date')).getTime() : 0 , m2_c = m2.get('create_date') ? ExGods.util.Date.normalizeServerDateTime(m2.get('create_date')).getTime() : 0 , m1_d = m1.get('done_date') ? ExGods.util.Date.normalizeServerDateTime(m1.get('done_date')).getTime() : 0 , m2_d = m2.get('done_date') ? ExGods.util.Date.normalizeServerDateTime(m2.get('done_date')).getTime() : 0;
                        // 
                        // 
                        // 1)     .      .   .
                        // 2)      ,      ,   
                        //      
                        if (m1_d == 0 && m1_d != m2_d) {
                            return -1;
                        }
                        if (m2_d == 0 && m1_d != m2_d) {
                            return 1;
                        }
                        //        (    )
                        if (m1_c > m2_c)  {
                            v = -1;
                        }
                        
                        if (m1_c < m2_c)  {
                            v = 1;
                        }
                        
                        if (m1_d > m2_d)  {
                            v = -1;
                        }
                        
                        if (m1_d < m2_d)  {
                            v = 1;
                        }
                        
                        return v;
                    }
                }
            ]
        });
        me.control({
            '#show_create_form': {
                click: me.showCreate
            },
            '#back_to_guild_search': {
                click: me.showSearch
            },
            '#create_guild': {
                click: me.createGuild
            },
            '#guild_search textfield': {
                keyup: me.searchForGuild
            },
            '#guild_info dataview': {
                itemclick: me.doActionWithMember
            },
            '#leave_guild': {
                click: me.leaveGuild
            },
            '#change_guild_head': {
                click: me.changeGuildHead
            },
            '#guild_search combo': {
                select: me.onSorterSelect
            },
            '#guild_search radiogroup': {
                change: me.onGuildTypeChange
            },
            '#guild_info': {
                change_description: me.onChangeDescription
            },
            'guildlistitem': {
                join_guild: me.joinGuild
            },
            'textbutton[action="guild_help"]': {
                click: me.onGuildHelpClick
            },
            'guildquestlistitem': {
                expand: me.onQuestExpand
            },
            '#guild-shop dataview': {
                itemclick: me.onShopItemClick
            },
            'guildtabpanel': {
                tabchange: me.onActivateTab
            },
            '#guild_create': {
                optioninfoclick: me.onInfoClick
            },
            '#call_back_bid': {
                click: me.callBackBid
            },
            'guildrequestslist': {
                infoclick: me.onInfoClick
            },
            '#create_guild_group': {
                click: me.onCreateGroupClick
            },
            'textbutton[action="guild_group_join"]': {
                click: me.onGroupJoinClick
            },
            '#change_guild_group_leader': {
                click: me.changeGroupLeader
            },
            '#leave_guild_group': {
                click: me.onGroupLeaveClick
            },
            '#guild_group_info dataview': {
                itemclick: me.doActionWithGroup
            },
            '#guild_raids': {
                itemclick: me.showRaidInfo
            }
        });
        me.user.on('guildchanged', me.onGuildChange, me);
        me.app.chatcn.on({
            command_update_guild_requests: me.onUpdateRequests,
            command_chat_update_group: me.updateGroups,
            scope: me
        });
        ExGods.Components.addComponentInitializer('guild', me.initGuildComponent, me);
    },
    onServiceUpdate: function() {
        var me = this,
            store = me.app.getGuildsStore(),
            guilds = me.service.data.guilds || [
                Ext.clone(me.service.data.guild)
            ];
        //    -       ,    
        if (me.service.data.guild && !me.service.data.guild.id)  {
            me.service.data.guild.id = ExGods.app.getUser().getGuild();
        }
        
        if (!me.guildCard || !me.service.data.guild)  {
            store.loadRawData(guilds);
        }
        
        var guild = store.getUserGuild();
        if (guild && guild.isUserHead()) {
            //         
            Ext.Array.each(me.service.data.bids, function(bid) {
                bid.isBid = true;
            });
            guild.set('bids', me.service.data.bids || []);
            guild.set(me.service.data.guild);
        }
    },
    updateRequests: function() {
        var me = this;
        me.service.command('guilds_requests', {}, function(data) {
            me.myRequestsStore.loadRawData(me.prepareMyRequests(data.my_request, data.types_request));
            me.requestsStore.loadRawData(me.prepareRequests(data.requests));
            me.onRequestsEmpty();
        });
    },
    updateShop: function() {
        var me = this;
        if (!me.service.shopService) {
            me.service.shopService = ExGods.Services.factory(me.service.data.shop_service_id);
        }
        me.service.shopService.init(null, function() {});
    },
    //
    updateQuests: function() {
        var me = this;
        if (!me.service.data.guild_noob) {
            me.service.command('guild_tasks', {}, function(data) {
                if (data.tasks) {
                    me.questsStore.loadRawData(data.tasks);
                    if (me.questsStore.getAt(0))  {
                        me.questsStore.getAt(0).set('expanded', true);
                    }
                    
                }
            });
        }
    },
    updateGroups: function(cb) {
        var me = this;
        if (ExGods.app.getUser().getBattle())  {
            return;
        }
        
        //    
        me.service.command('guild_groups', {}, function(data) {
            if (data.groups) {
                me.groupsStore.loadRawData(data.groups);
                me.getGroups().showGroupsList(data);
            } else  {
                me.showGroupInfo(data);
            }
            
            if (typeof cb == 'function')  {
                cb();
            }
            
        });
    },
    updateRaids: function(cb) {
        var me = this;
        me.service.command('guild_raids_info', {}, function(data) {
            if (data.raids) {
                Ext.Array.each(data.raids, function(raid) {
                    me.raidsStore.getById(Number(raid.entry)).set(raid);
                });
            }
            if (typeof cb == 'function')  {
                cb();
            }
            
        });
    },
    prepareMyRequests: function(requests, types_request) {
        var me = this,
            preparedRequests = [],
            myTypes = Ext.Array.map(requests, function(el) {
                return Number(el.type);
            });
        ExGods.references.get('guild_request_types').each(function(k, el) {
            var index = myTypes.indexOf(Number(el.entry));
            if (index != -1) {
                preparedRequests.push(requests[index]);
            } else {
                var request = {
                        type: el.entry
                    };
                var type_request = types_request ? Ext.Array.findBy(types_request, function(t) {
                        return t.entry == el.entry;
                    }) : null;
                if (type_request)  {
                    request.timeout = /*Math.floor(Math.random()*15) + 5*/
                    type_request.timeout;
                }
                
                preparedRequests.push(request);
            }
        });
        preparedRequests.reverse(function(r) {
            var c = 0;
            if (r.owner)  {
                c = 5;
            }
            
            if (!r.timeout)  {
                c++;
            }
            
            return c;
        });
        for (var i = 0; i < preparedRequests.length; i++) {
            preparedRequests[i].index = i;
        }
        return preparedRequests;
    },
    prepareRequests: function(requests) {
        // , ..           ,
        //.. xindex     -    1,    
        //  
        for (var i = 0; i < requests.length; i++) {
            requests[i].index = i;
        }
        return requests || [];
    },
    /**
     *    
     */
    showSearch: function() {
        var me = this,
            store = me.app.getGuildsStore();
        if (!me.searchCard) {
            me.searchCard = Ext.widget('guildsearch', {
                store: store,
                service: me.service
            });
            me.cmp.add(me.searchCard);
        }
        me.cmp.getLayout().setActiveItem(me.searchCard);
    },
    /**
     *      
     */
    showGuild: function() {
        var me = this,
            store = me.app.getGuildsStore();
        if (!me.guildCard) {
            me.guildCard = Ext.widget('guildtabpanel', {
                service: me.service,
                guild: store.getAt(0),
                myRequestsStore: me.myRequestsStore,
                requestsStore: me.requestsStore,
                questsStore: me.questsStore,
                groupsStore: me.groupsStore,
                raidsStore: me.raidsStore,
                listeners: {
                    afterrender: function() {
                        if (me.newRequests)  {
                            me.markRequestsTab(me.newRequests);
                        }
                        
                    }
                }
            });
            me.cmp.add(me.guildCard);
        }
        me.cmp.getLayout().setActiveItem(me.guildCard);
    },
    /**
     *    
     */
    showCreate: function() {
        var me = this;
        if (!me.createFormCard) {
            me.createFormCard = Ext.widget('guildcreate', {
                service: me.service
            });
            me.cmp.add(me.createFormCard);
        }
        me.cmp.getLayout().setActiveItem(me.createFormCard);
    },
    /**
     *      
     */
    showWait: function() {
        var me = this;
        if (!me.waitCard) {
            me.waitCard = Ext.widget('guildwait', {
                service: me.service
            });
            me.cmp.add(me.waitCard);
        }
        me.cmp.getLayout().setActiveItem(me.waitCard);
    },
    createGuild: function(btn) {
        var me = this,
            form = btn.up('guildcreate').down('form').getForm(),
            store = me.app.getGuildsStore();
        if (form.isValid()) {
            var params = form.getValues();
            if (params.options == 0)  {
                delete params.options;
            }
            
            if (params.description)  {
                params.description = params.description.replace(/\r?\n/g, '<br />');
            }
            
            Ext.widget('confirmdialog', {
                title: '',
                message: me.service.init_config.confirm_create,
                handler: function() {
                    me.service.command('create_guild', params, function(data) {
                        me.afterEnterGuildRequest(data);
                    });
                }
            });
        } else {
            form.markInvalid();
        }
    },
    joinGuild: function(guild) {
        var me = this,
            store = me.app.getGuildsStore();
        me.service.command('guild_add_user', {
            guild_id: guild.get('id')
        }, function(data) {
            me.afterEnterGuildRequest(data);
        });
    },
    afterEnterGuildRequest: function(data) {
        var me = this;
        if (data.success) {
            me.service.update(null, function() {
                if (ExGods.app.getUser().getGuild()) {
                    me.updateQuests();
                    me.updateRequests();
                    //me.updateShop();
                    me.showGuild();
                } else {
                    me.showWait();
                }
                me.destroyCards('searchCard');
            });
        }
    },
    searchForGuild: Ext.Function.createBuffered(function(textfield, e) {
        var me = this,
            value = textfield.getValue(),
            store = me.app.getGuildsStore();
        if (value) {
            me.service.command('search_guild', {
                title: textfield.getValue()
            }, function(data) {
                if (data.success)  {
                    store.loadRawData(data.guilds);
                }
                
            });
        } else {
            me.service.update();
        }
    }, 500),
    doActionWithMember: function(dataview, record, dom, index, e) {
        var me = this;
        if (e.target.className.indexOf('kick') != -1) {
            Ext.widget('confirmdialog', {
                title: '',
                message: me.service.init_config.confirm_kick,
                handler: function() {
                    me.service.command('remove_user_from_guild', {
                        user_to: record.get('display_title')
                    }, function(data) {
                        if (data.success) {
                            if (data.guilds) {
                                me.showSearch();
                                me.service.update(me.service.parseData(data));
                                me.destroyCards('guildCard');
                            } else {
                                me.service.update(me.service.parseData(data));
                            }
                        }
                    });
                }
            });
        } else if (e.target.className.indexOf('accept') != -1 || e.target.className.indexOf('decline') != -1) {
            Ext.widget('confirmdialog', {
                width: 350,
                title: '',
                message: me.service.init_config[e.target.className.indexOf('accept') != -1 ? 'confirm_confirm_bid' : 'confirm_refuse_bid'],
                handler: function() {
                    me.service.command(e.target.className.indexOf('accept') != -1 ? 'confirm_bid' : 'refuse_bid', {
                        user_to: record.get('display_title')
                    }, function(data) {
                        if (data.success) {
                            me.service.update(me.service.parseData(data));
                        }
                    });
                }
            });
        } else if (e.target.className.indexOf('send-social-message') != -1 && e.target.className.indexOf('disabled') == -1) {
            me.app.getSocialController().sendUserToUserMessage([
                record.get('social').social_net_id
            ], me.service.data.guild.snet_notice_inactive, function() {
                me.service.command('guild_snet_notice_inactive_sent', {
                    user_id: record.get('social').user_id
                });
                Ext.get(e.target).addCls('disabled');
            });
        }
    },
    leaveGuild: function() {
        var me = this;
        Ext.widget('confirmdialog', {
            title: '',
            message: me.service.init_config.confirm_leave,
            handler: function() {
                me.service.command('leave_guild', {}, function(data) {
                    if (data.success) {
                        me.service.update(null, function() {
                            me.showSearch();
                            me.destroyCards('guildCard');
                        });
                    }
                }, {
                    queue: false
                });
            }
        });
    },
    changeGuildHead: function() {
        var me = this,
            cfg = me.service.init_config,
            usersStore = me.app.getGuildsStore().getUserGuild().get('users'),
            users = usersStore.queryBy(function(rec) {
                return !rec.get('isBid') && rec.get('display_title') != ExGods.app.getUser().get('display_title');
            }).items;
        var wnd = ExGods.Components.factory('USER_TARGET_PANEL', {
                windowTitle: cfg.guild_change_head_wnd_title,
                users: users,
                searchEmptyText: cfg.guild_change_head_empty_text,
                buttonText: cfg.guild_change_head,
                listeners: {
                    select: function(panel, record) {
                        me.service.command('change_head_guild', {
                            user_to: record.get('display_title')
                        }, function(data) {
                            if (data.success) {
                                me.service.update(me.service.parseData(data));
                                var guildInfo = me.guildCard.down('#guild_info');
                                if (guildInfo && guildInfo.isVisible()) {
                                    guildInfo.down('#guild_description').update(data.guild);
                                }
                                wnd.close();
                            }
                        });
                    }
                }
            });
    },
    changeGroupLeader: function() {
        var me = this,
            cfg = me.service.init_config,
            usersStore = me.getGroups().getLayout().getActiveItem().store,
            users = usersStore.queryBy(function(rec) {
                return rec.get('display_title') != ExGods.app.getUser().get('display_title');
            }).items;
        var wnd = ExGods.Components.factory('USER_TARGET_PANEL', {
                windowTitle: cfg.group_change_head_wnd_title,
                users: users,
                searchEmptyText: cfg.group_change_head_empty_text,
                buttonText: cfg.group_change_leader,
                listeners: {
                    select: function(view, record) {
                        me.service.command('guild_change_group_creator', {
                            title: record.get('display_title')
                        }, function(data) {
                            if (data.success) {
                                me.updateGroups(function() {
                                    wnd.close();
                                });
                            }
                        });
                    }
                }
            });
    },
    callBackBid: function() {
        var me = this;
        me.service.command('callback_bid', {}, function(data) {
            if (data.success) {
                me.service.update(null, function() {
                    me.showSearch();
                    me.destroyCards('waitCard');
                });
            }
        });
    },
    onSorterSelect: function(combo, selected) {
        var me = this,
            value = selected.data.value,
            store = me.app.getGuildsStore();
        store.getSorters().getAt(0).setDirection(value);
        store.sort();
    },
    onGuildTypeChange: function(radiogroup, newValue, oldValue) {
        var me = this,
            value = newValue.guild_type,
            store = me.app.getGuildsStore();
        store.removeFilter('guild_type');
        if (value == 1) {
            store.addFilter(Ext.util.Filter({
                filterFn: function(rec) {
                    return rec.get('open') == 1;
                },
                id: 'guild_type'
            }));
        } else if (value == 2) {
            store.addFilter(Ext.util.Filter({
                filterFn: function(rec) {
                    return rec.get('open') == 0;
                },
                id: 'guild_type'
            }));
        }
    },
    onChangeDescription: function(guild, component) {
        var me = this,
            cfg = me.service.init_config;
        Ext.widget('floatwindow', {
            width: 400,
            buttonAlign: 'center',
            buttons: {
                defaultType: 'textbutton',
                items: [
                    {
                        text: cfg.guild_save_description_btn,
                        cls: 'no_border',
                        handler: function() {
                            var _me = this,
                                wnd = _me.up('floatwindow'),
                                value = wnd.down('textarea').getValue();
                            me.service.command('change_description', {
                                description: value.replace(/\r?\n/g, '<br />')
                            }, function(data) {
                                if (data.success) {
                                    guild.set('description', value.replace(/\r?\n/g, '<br />'));
                                    if (component && component.isVisible())  {
                                        component.down('#guild_description').update(guild.data);
                                    }
                                    
                                    wnd.close();
                                }
                            });
                        }
                    },
                    {
                        text: cfg.guild_cancel_change_descr_btn,
                        cls: 'no_border x-btn-txt-red',
                        handler: function() {
                            this.up('floatwindow').close();
                        }
                    }
                ]
            },
            items: [
                {
                    xtype: 'textarea',
                    height: 100,
                    margin: '7 5',
                    value: guild.get('description').replace(/<br\s*\/?>/mg, "\n")
                }
            ]
        });
    },
    onGuildHelpClick: function(btn) {
        var me = this;
        me.service.command('answer_request', {
            request_id: btn.request_id
        }, function(data) {
            me.updateRequests();
        });
    },
    onQuestExpand: function(listitem) {
        var me = this,
            r = listitem.record;
        if (r.task_pcp_requested)  {
            return;
        }
        
        r.task_pcp_requested = true;
        me.service.command('guild_task_pcp', {
            task_id: r.get('task_id')
        }, function(data) {
            if (data.pcp) {
                r.set('pcp', data.pcp);
                //       15 .    , ..         
                setTimeout(function() {
                    r.task_pcp_requested = false;
                }, 15000);
            } else {
                r.task_pcp_requested = false;
            }
        });
    },
    onActivateTab: function(tabpanel, activeCmp) {
        var me = this;
        if (activeCmp.id == 'guild-shop') {
            me.updateShop();
        } else if (activeCmp.id == 'guild_help') {
            me.unmarkMenuBtn();
            me.unmarkRequestTab();
        } else if (activeCmp.id == 'guild_groups') {
            me.updateGroups();
        } else if (activeCmp.xtype == 'guildraids') {
            me.updateRaids();
        }
    },
    onInfoClick: function(view, optEl, desc) {
        var me = this;
        if (me.optToolTip)  {
            me.optToolTip.close();
        }
        
        me.optToolTip = Ext.widget('parchmentwindow', {
            itemElement: optEl,
            html: [
                '<div class="chest-info-tooltip-text">',
                desc,
                '</div>'
            ].join('')
        });
    },
    onGuildChange: function(guild_id) {
        var me = this;
        //    -   
        if (!me.wnd || !me.wnd.isVisible())  {
            return;
        }
        
        var card = me.cmp.getLayout().getActiveItem();
        if (guild_id && card.xtype == 'guildwait') {
            me.service.update(null, function() {
                me.updateQuests();
                me.updateRequests();
                //me.updateShop();
                me.showGuild();
                me.destroyCards('waitCard');
            });
        } else if (!guild_id && card.xtype == 'guildtabpanel') {
            me.service.update(null, function() {
                me.showSearch();
                me.destroyCards('guildCard');
            });
        }
    },
    /**
     *     update_guild_requests
     */
    onUpdateRequests: function(chatcn, data) {
        var me = this;
        if (me.user.get('id') == data.body.user)  {
            return;
        }
        
        me.newRequests++;
        //    -  
        if (!me.wnd || !me.wnd.isVisible())  {
            return me.markMenuBtn();
        }
        
        var card = me.cmp.getLayout().getActiveItem();
        if (card.xtype == 'guildtabpanel') {
            me.updateRequests();
            if (card.getActiveTab().xtype != 'guildhelp') {
                me.markMenuBtn();
                me.markRequestsTab();
            } else {
                me.newRequests--;
            }
        } else  {
            me.markMenuBtn();
        }
        
    },
    /**
     *            onUpdateRequests,
     *              -    
     */
    onRequestsEmpty: function() {
        var me = this,
            count = me.requestsStore.getCount();
        if (!count) {
            me.unmarkMenuBtn();
            if (me.wnd && me.wnd.isVisible())  {
                me.unmarkRequestTab();
            }
            
        }
    },
    onCreateGroupClick: function(btn) {
        var me = this,
            title = btn.up('toolbar').down('textfield').getValue(),
            loot_type = btn.up('toolbar').down('radiogroup') ? btn.up('toolbar').down('radiogroup').getValue() : '';
        me.service.command('guild_create_group', {
            title: title,
            loot_type: loot_type
        }, me.showGroupInfo.bind(me));
    },
    onGroupJoinClick: function(btn) {
        var me = this;
        me.service.command('guild_join_group', {
            entry: btn.group_id
        }, me.showGroupInfo.bind(me));
    },
    onGroupLeaveClick: function() {
        var me = this;
        Ext.widget('confirmdialog', {
            title: '',
            message: me.service.init_config.confirm_leave_group,
            handler: function() {
                me.service.command('guild_unjoin_group', {}, function(data) {
                    if (data.success) {
                        me.updateGroups();
                    }
                });
            }
        });
    },
    //me.app.getChatGroupController().deactivateGroup();
    doActionWithGroup: function(dataview, record, dom, index, e) {
        var me = this;
        if (e.target.className.indexOf('kick') != -1) {
            Ext.widget('confirmdialog', {
                title: '',
                message: me.service.init_config.confirm_kick_group,
                handler: function() {
                    me.service.command('guild_kick_user_group', {
                        title: record.get('display_title')
                    }, function(data) {
                        if (data.success) {
                            me.updateGroups();
                        }
                    });
                }
            });
        }
    },
    showRaidInfo: function(dataview, record, dom, index, e) {
        var me = this,
            rewards = record.get('rewards'),
            show = function() {
                Ext.widget('raidinfowindow', {
                    complete: record.isComplete(),
                    record: record,
                    show_rewards: dataview.up('guildraids').show_rewards,
                    itemElement: dom
                });
            };
        if (record.get('empty'))  {
            return;
        }
        
        if (rewards && rewards.length) {
            var me = this,
                missedProtos = [],
                protos = ExGods.app.getItemPrototypesStore(),
                i = rewards.length;
            while (i--) {
                if (parseInt(rewards[i].params.id) && !protos.data.getByKey(rewards[i].params.id))  {
                    missedProtos.push(rewards[i].params.id);
                }
                
            }
            protos.loadNew(missedProtos, show);
        } else {
            show();
        }
    },
    showGroupInfo: function(data) {
        if (!data.group)  {
            return;
        }
        
        if (!this.getGroups())  {
            return;
        }
        
        var me = this,
            missedProtos = [],
            protos = ExGods.app.getItemPrototypesStore(),
            i = data.group.users.length;
        while (i--) {
            if (!protos.data.getByKey(data.group.users[i].mask_proto_id))  {
                missedProtos.push(data.group.users[i].mask_proto_id);
            }
            
        }
        protos.loadNew(missedProtos, function() {
            if (me.getGroups())  {
                me.getGroups().showGroupInfo(data.group);
            }
            
        });
    },
    markMenuBtn: function() {
        var me = this;
        me.getGuildButton().reset();
        me.getGuildButton().addCount(me.newRequests);
    },
    markRequestsTab: function(count) {
        this.getRequestsTab().addCount(count || 1);
    },
    unmarkMenuBtn: function() {
        this.getGuildButton().reset();
        this.newRequests = 0;
    },
    unmarkRequestTab: function() {
        this.getRequestsTab().reset();
        this.newRequests = 0;
    },
    initGuildComponent: function(config, id) {
        var me = this,
            user_guild = me.app.getUser().getGuild();
        me.onServiceUpdate();
        me.cmp = Ext.widget('guildcontainer', config);
        me.service.init_config = config;
        me.wnd = Ext.widget('window2', {
            id: id,
            items: [
                me.cmp
            ],
            autoShow: false,
            onDestroy: function() {
                me.destroyCards();
                this.callParent();
            }
        });
        if (user_guild && me.service.data.guild) {
            me.updateQuests();
            me.updateRequests();
            //me.updateShop();
            me.showGuild();
        } else if (me.service.data.guild) {
            me.showWait();
        } else {
            me.showSearch();
        }
        ExGods.app.block();
        ExGods.Resources.load(me.wnd, function() {
            ExGods.app.unblock();
            me.wnd.show();
        });
        return me.wnd;
    },
    destroyCards: function(card_name) {
        var me = this;
        if (card_name) {
            if (me[card_name]) {
                me[card_name].destroy();
                me[card_name] = false;
            }
        } else {
            me.destroyCards('guildCard');
            me.destroyCards('searchCard');
            me.destroyCards('waitCard');
            me.destroyCards('createFormCard');
        }
    },
    /**
     *      
     */
    onShopItemClick: function(itemView, shopItem, itemEl, zero, event) {
        var me = this,
            target = event.target || event.srcElement;
        if (!target.getTarget('.x-btn')) {
            me.app.getController('Shop').buyItem(shopItem, 1, me.service.shopService);
            event.stopPropagation();
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.store.GuildOnlineList', {
    extend: ExGodsCore.store.ChatContacts,
    model: 'ExGods.model.BasicUser'
});

/**
 *     
 */
Ext.define('ExGods.controller.GuildOnline', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    views: [],
    //
    models: [
        'BasicUser'
    ],
    stores: [
        'GuildOnlineList'
    ],
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'GuildOnline:'
    },
    init: function(app) {
        var me = this;
        me.control({
            '#guild-chat-messages': {
                render: me.onChatMessagesRender,
                destroy: me.onChatMessagesDestroy
            }
        });
        me.app.getChatConnection().on({
            command_online_guild_user: me.onOnlineUser,
            command_offline_guild_user: me.onOfflineUser,
            scope: me
        });
        me.callParent(arguments);
    },
    /*********** PRIVATES *************

    /**
     * @private
     *   
     */
    getGuildOnlineList: function(callback) {
        var me = this,
            user = me.getUser();
        me.request({
            url: 'game.pl?cmd=guild_online',
            method: 'GET',
            queue: false,
            success: function(result) {
                var userList = result.guild_online,
                    users = me.getBasicUserModel().proxy.reader.read(userList).records,
                    onlineList = [],
                    type, user, i;
                for (i = 0; i < users.length; i++) {
                    user = users[i];
                    onlineList.push(user);
                }
                callback(onlineList);
            }
        });
    },
    /**
     * @private
     *     
     */
    onChatMessagesRender: function() {
        var me = this;
        me.getGuildOnlineList(function(records) {
            me.app.getStore('GuildOnlineList').loadRecords(records);
        });
    },
    /**
     * @private
     *     
     */
    onChatMessagesDestroy: function() {
        var me = this;
        me.app.getStore('GuildOnlineList').removeAll();
    },
    /**
     * @private
     *    "online_guild_user"
     */
    onOnlineUser: function(conn, data) {
        var me = this,
            store = me.app.getStore('GuildOnlineList'),
            index = store.findBy(function(rec) {
                return rec.data.display_title == data.body.user.display_title;
            });
        if (index == -1) {
            store.add(data.body.user);
        }
    },
    /**
     * @private
     *    "offline_guild_user"
     */
    onOfflineUser: function(conn, data) {
        var me = this,
            store = me.app.getStore('GuildOnlineList'),
            index = store.findBy(function(rec) {
                return rec.data.display_title == data.body.user.display_title;
            });
        if (index != -1) {
            store.removeAt(index);
        }
    }
});

/**
 *   
 */
Ext.define('ExGods.view.loot.Container', {
    extend: Ext.panel.Panel,
    alias: 'widget.lmcontainer',
    id: 'loot_manager_container',
    layout: {
        type: 'hbox',
        align: 'stretch'
    },
    padding: '6 10 11',
    //margin:4,
    plugins: [
        'paperdeco'
    ],
    initComponent: function() {
        var me = this;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-title"><h4>' + ExGods.getMsgByKey('loot_title') + '</h4></div>'
            },
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="loot-description">' + ExGods.getMsgByKey('loot_descr') + '</div>',
                padding: '0 17'
            },
            {
                dock: 'top',
                xtype: 'lootslots'
            },
            {
                dock: 'top',
                xtype: 'component',
                html: '<div class="paper-separator"></div>'
            }
        ];
        me.inventoryType = {
            xtype: 'loottype',
            id: 'loottypeInventoryTypeId',
            margin: '0 0 0 1',
            loot_type: 'inventory'
        };
        me.guildType = {
            xtype: 'loottype',
            id: 'loottypeGuildTypeId',
            loot_type: 'guild'
        };
        me.groupType = {
            xtype: 'loottype',
            id: 'loottypeGroupTypeId',
            loot_type: 'group',
            width: 242
        };
        me.items = [
            me.inventoryType,
            {
                xtype: 'component',
                html: '<div class="v-separator"></div>'
            },
            me.guildType,
            {
                xtype: 'component',
                html: '<div class="v-separator"></div>'
            },
            me.groupType
        ];
        me.inventoryType = undefined;
        me.guildType = undefined;
        me.groupType = undefined;
        me.callParent();
    },
    initLootTypes: function() {
        if (!this.inventoryType) {
            this.inventoryType = Ext.getCmp('loottypeInventoryTypeId');
            this.guildType = Ext.getCmp('loottypeGuildTypeId');
            this.groupType = Ext.getCmp('loottypeGroupTypeId');
        }
    },
    highlight: function(types) {
        var me = this,
            i = types.length;
        me.initLootTypes();
        while (i--) {
            me[types[i] + 'Type'].highlight();
        }
    },
    unhighlight: function() {
        var me = this;
        me.initLootTypes();
        this.inventoryType.unhighlight();
        this.guildType.unhighlight();
        this.groupType.unhighlight();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        return {
            images: []
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.loot.Slots', {
    extend: ExGods.view.grid.SlotsGrid,
    alias: 'widget.lootslots',
    mixins: [
        ExGods.mixin.ItemDraggable,
        ExGods.mixin.InventoryDragHighlight
    ],
    margin: '0 17 5',
    initComponent: function() {
        var me = this;
        //  
        me.rowsCount = 2;
        me.columnsCount = 11;
        me.pager = {
            hideIfSinglePage: true,
            tpl: null
        };
        me.cls += ' virtual-store';
        me.store = ExGods.app.getStore('Loot');
        me.itemTpl = [
            '{[ExGods.stuff.StuffManager.image(values)]}'
        ];
        me.callParent(arguments);
        me.view = me.down('dataview');
        me.view.on('afterrender', function() {
            me.initDrag({
                view: me.view
            });
            me.initDragHighlight();
        });
    },
    collectData: function(records) {
        var me = this,
            data = [];
        Ext.Array.each(records, function(rec) {
            data.push({
                type: 'virtual_store_stuff',
                sourceModel: rec,
                params: {
                    stuff: {
                        params: {
                            id: rec.data.stuff.params.id,
                            quantity: rec.data.stuff.params.quantity
                        },
                        type: rec.data.stuff.type
                    }
                }
            });
        });
        return data;
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [];
        for (var i = 0; i < me.store.data.items.length; i++) {
            var itm = me.store.data.items[i];
            stuff_arr.push(itm.data.stuff);
        }
        return {
            stuff: stuff_arr,
            images: []
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.loot.Type', {
    extend: Ext.panel.Panel,
    alias: 'widget.loottype',
    mixins: [
        ExGods.mixin.ItemDroppable
    ],
    cls: 'loot-type',
    layout: 'fit',
    width: 241,
    initComponent: function() {
        var me = this;
        me.dockedItems = [
            {
                dock: 'top',
                xtype: 'component',
                //width:246,
                html: '<div class="paper-title"><h4>' + ExGods.getMsgByKey('loot_type_title_' + me.loot_type) + '</h4></div>'
            }
        ];
        me.html = [
            //'<div class="loot-type-description">'+ExGods.getMsgByKey('loot_type_descr_'+me.loot_type)+'</div>',
            '<div class="loot-type-image" style="background-image:url(' + ExGods.ref('images|loot_slots').image[me.loot_type] + ')"></div>'
        ];
        me.callParent();
    },
    highlight: function() {
        this.el.down('.loot-type-image').addCls('highlight');
    },
    unhighlight: function() {
        this.el.down('.loot-type-image').removeCls('highlight');
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.initDrop({
            onNodeDrop: function(target, dd, e, data) {
                if (target.className.indexOf('highlight') != -1 || (target.childNodes[0] && target.childNodes[0].className && target.childNodes[0].className.indexOf('highlight') != -1)) {
                    me.fireEvent('drop', me, target, data.item, data.itemEl);
                    return false;
                } else  {
                    return false;
                }
                
            }
        });
    },
    getResources: function() {
        var me = this,
            arr_images = [];
        var img = ExGods.ref('images|loot_slots').image[me.loot_type];
        return {
            images: [
                img
            ].concat(arr_images)
        };
    }
});

/**
 *    
 */
Ext.define('ExGods.controller.LootManager', {
    extend: ExGodsCore.controller.Base,
    refs: [],
    //
    views: [
        'loot.Container',
        'loot.Slots',
        'loot.Type'
    ],
    init: function(app) {
        var me = this;
        me.lootStore = ExGods.app.getStore('Loot');
        me.vsctrl = ExGods.app.getInventoryVirtualStoreController();
        me.inventory = ExGods.app.getInventoryInventoryController();
        me.control({
            '#loot_manager_btn': {
                click: me.onOpenBtnClick
            },
            'lootslots': {
                startdrag: me.onStartDrag,
                stopdrag: me.onStopDrag
            },
            'loottype': {
                drop: me.onDrop
            },
            '#self_loot_btn': {
                click: me.onSelfLootBtnClick
            }
        });
    },
    onSelfLootBtnClick: function() {
        var me = this;
        me.app.block();
        me.inventory.service.command('put_from_store_loot', {}, function(json) {
            me.app.unblock();
        });
    },
    onOpenBtnClick: function(btn, e) {
        var inventory = Ext.getCmp('INVENTORY');
        if (inventory && inventory.down('#loot_manager_btn')) {
            var counterEl = inventory.down('#loot_manager_btn').el.down('.newitems-counter');
            if (counterEl) {
                counterEl.remove();
            }
        }
        this.openLootManager();
    },
    onStartDrag: function(data) {
        var rec = data.item,
            destinations = [],
            rec_destinations = rec.get('destinations');
        if (rec_destinations.indexOf('inventory') != -1)  {
            destinations.push('inventory');
        }
        
        if (rec_destinations.indexOf('guild_store') != -1)  {
            destinations.push('guild');
        }
        
        if (rec_destinations.indexOf('group') != -1)  {
            destinations.push('group');
        }
        
        Ext.getCmp('VIRTUAL_STORE').down('lmcontainer').highlight(destinations);
    },
    onStopDrag: function(data) {
        Ext.getCmp('VIRTUAL_STORE').down('lmcontainer').unhighlight();
    },
    onDrop: function(cmp, target, rec, el) {
        var me = this;
        switch (cmp.loot_type) {
            case 'inventory':
                me.toInventory(rec);
                break;
            case 'guild':
                me.toGuild(rec);
                break;
            case 'group':
                me.toGroup(rec);
                break;
        }
    },
    toInventory: function(rec) {
        this.vsctrl.doPutItems.call(this.vsctrl, rec, 1);
    },
    toGuild: function(rec) {
        this.vsctrl.doPutItems.call(this.vsctrl, rec, 1, false, {
            destination: 'guild_store'
        });
    },
    toGroup: function(rec) {
        this.vsctrl.doPutOnGroup.call(this.vsctrl, rec, 1);
    },
    openLootManager: function() {
        ExGods.Components.factory("VIRTUAL_STORE");
    }
});

Ext.define('ExGods.view.pet.Info', {
    extend: Ext.panel.Panel,
    alias: 'widget.petinfo',
    cls: 'pet-info',
    plugins: [
        'extraparchmentdeco'
    ],
    closable: false,
    width: 218,
    height: 370,
    /**
     * @required
     * @cfg pet -  
     */
    initComponent: function() {
        var me = this;
        me.data = me.pet.data;
        if (!me.data.title) {
            me.data.title = me.data.item_proto.title || ExGods.app.getItemPrototypesStore().data.getByKey(me.data.item_proto).data.title;
        }
        if (!me.data.actions || !me.data.actions.length) {
            me.data.actions = me.data.item_proto.action_full || ExGods.app.getItemPrototypesStore().data.getByKey(me.data.item_proto).data.action_full;
        }
        me.tpl = [
            '<h6 class="pet-info-title ellipsis">{title}</h6>',
            '<div class="pet-info-group ellipsis">{group}</div>',
            '<div class="parchment-separator"></div>',
            '<tpl if="stats">',
            '<div class="paper-title">' + me.clientConfig.stats_title + '</div>',
            '<div class="pet-stats">',
            '{[ ExGods.util.User.printUserStats(values.fit_stats || ExGods.app.user.data.stats.stats, {visibleValue: 1, align: "right", changes: this.getChanges(values)}) ]}',
            '</div>',
            '<div class="parchment-separator"></div>',
            '</tpl>',
            '<tpl if="actions.length">',
            '<div class="paper-title">' + me.clientConfig.actions_title + '</div>',
            '<div class="pet-actions">',
            '<tpl if="actions.length &gt; 1">',
            '<tpl for="actions">',
            '<tpl if="xindex < 4">',
            '<div class="action" data-qtip="{label}" data-type="feature">',
            '<div class="notify_i"></div>',
            '<img height="50" width="50" src="{[IMAGE_URL + values.images.main]}">',
            '{title}',
            '</div>',
            '</tpl>',
            '</tpl>',
            '<tpl else>',
            '<tpl for="actions">',
            '{[this.printFeature(values)]}',
            '</tpl>',
            '</tpl>',
            '</div>',
            '<div class="parchment-separator"></div>',
            '</tpl>',
            '<div class="paper-title">' + me.clientConfig.battle_actions_title + '</div>',
            '<tpl if="battle_actions.length">',
            '<div class="pet-battle-actions">',
            '<tpl for="battle_actions">',
            '<tpl if="xindex < 4">',
            '<div class="action{[this.getBattleActionCls(parent)]}" data-id="{id}" data-type="{type}" data-qtip="{title}">',
            '<div class="notify_i"></div>',
            '<img height="50" width="50" src="{img}">',
            '<strong>{title}</strong>',
            '</div>',
            '</tpl>',
            '</tpl>',
            '</div>',
            '<tpl else>',
            '<div class="pet-battle-actions-empty">' + me.clientConfig.battle_actions_empty + '</div>',
            '</tpl>',
            '<div class="parchment-separator"></div>',
            '<div class="paper-title">' + me.clientConfig.control_title + '</div>',
            '<tpl if="has">',
            '<div class="pet-info-state">',
            '<div class="component">',
            '<span role="xtype">petstate</span>',
            '<span role="pet_id">{entry}</span>',
            //'<span role="clientConfig:object">' + Ext.encode(me.clientConfig) + '</span>',
            '</div>',
            '</div>',
            '<tpl else>',
            '<div class="pet-no-pet">' + me.clientConfig.no_pet_text + '</div>',
            '</tpl>',
            //'<div class="parchment-separator"></div>',
            {
                printFeature: function(values) {
                    return me.printFeatureTpl(values);
                },
                getBattleActionCls: function(values) {
                    return values.battle_actions.length == 1 || (values.battle_actions.length == 2 && !values.actions.length && !values.stats) ? ' single' : '';
                },
                getChanges: function(values) {
                    var user = ExGods.app.user,
                        changes = {};
                    if (values.fit_stats) {
                        Ext.each(config.references.user_stat, function(item) {
                            if (item.visible == 1 && !item.param.fill) {
                                var cur_stat = values.fit_stats[item.name],
                                    was_stat = user.data.stats.stats[item.name],
                                    change = Number(cur_stat) - Number(was_stat);
                                changes[item.name] = change;
                            }
                        });
                    }
                    return changes;
                }
            }
        ];
        // 
        // me.buttons = {
        //  vertical: true,
        //  margin: '13 31',
        //  defaults: {
        //      xtype: 'textbutton',
        //      cls: 'no_border',
        //      width: 150,
        //      margin: '0 0 10'
        //  },
        //  items: [{
        //      text: me.clientConfig.pet_control_btn,
        //      disabled: !me.pet.get('has'),
        //      itemId: 'pet_control_btn'
        //  }].concat(me.buttons || [])
        // }
        me.callParent();
        if (me.pet.get('has')) {
            me.addCls('has');
        }
    },
    onRender: function() {
        var me = this;
        me.callParent(arguments);
        me.el.on('click', me.onItemClick, me, {
            delegate: '.action'
        });
    },
    onDestroy: function() {
        var me = this;
        ExGods.util.Helper.destroyComponents(me.el);
        me.callParent(arguments);
    },
    update: function(data) {
        var me = this;
        me[data.has ? 'addCls' : 'removeCls']('has');
        //me.down('#pet_control_btn').setDisabled(!data.has);
        me.callParent(arguments);
        ExGods.util.Helper.renderComponents(me.el, me);
    },
    onItemClick: function(e, el) {
        var me = this,
            id = el.getAttribute('data-id'),
            type = el.getAttribute('data-type'),
            title = el.getAttribute('data-qtip'),
            info = ExGods.ref(type + '|' + id);
        if (info) {
            if (type == 'battle_turn') {
                info.turn_type = ExGods.getMsgByKey('masks_turn_type_name');
            } else if (type == 'battle_prep') {
                info.turn_type = ExGods.getMsgByKey('masks_prep_type_name');
            } else if (type == 'battle_actions') {
                info.turn_type = ExGods.getMsgByKey('masks_action_type_name');
            }
            Ext.widget('commondetailswindow', {
                itemElement: el,
                data: {
                    label: info.label,
                    image: IMAGE_URL + (info.desc.images ? info.desc.images['active'] : info.desc.img),
                    rows: [
                        {
                            content: info.turn_type
                        },
                        {
                            content: info.desc.desc || info.desc.description
                        }
                    ]
                }
            });
        } else if (type == 'feature') {
            //   IV
            var feature_data = Ext.Array.findBy(me.pet.get('actions'), function(el) {
                    return el.label == title;
                });
            Ext.widget('commondetailswindow', {
                itemElement: el,
                padding: '6 0 12',
                headerTpl: me.printFeatureTpl(feature_data),
                data: feature_data
            });
        }
    },
    printFeatureTpl: function(data) {
        var me = this;
        return new Ext.XTemplate('<div class="display_like_table item_feature">', '<tpl if="images.main">', '<div class="cell_align_middle feature-image" style="background-image: url({[IMAGE_URL + values.images.main]})"></div>', '</tpl>', '<div class="cell_align_middle feature-content{[this.getFeatureCls(values)]}">', '<div class="feature-label" style="color:{[this.getFeatureColor()]}">{label}</div>', '<tpl if="grade">', '<div class="item_grade_stars">', '<div class="item_star_bg" style="width:' + ExGods.ref('constants|item_feature_stars').value * 14 + 'px">', '<div class="item_star" style="{[this.getStarsStyle(values)]}"></div>', '</div>', '</div>', '</tpl>', '<div>{description2}</div>', '</div>', '</div>', {
            getFeatureCls: function(values) {
                return values.images.main && typeof values.grade == 'number' ? ' left-line' : '';
            },
            getFeatureColor: function() {
                var item_grade = Number(me.pet.get('item_proto').data.item_grade);
                return ExGods.references.get('constants_list').item_grades.value[Math.max(item_grade, 0)];
            },
            getStarsStyle: function(values) {
                return [
                    'height: 14px;',
                    'width: ' + values.grade * 14 + 'px;',
                    'max-width:' + ExGods.ref('constants|item_feature_stars').value * 14 + 'px'
                ].join('');
            }
        }).apply(data);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        for (var i = 0; i < me.data.battle_actions.length; i++) {
            arr_images.push(me.data.battle_actions[i].img);
        }
        var act = me.pet.get('actions');
        for (var i = 0; i < act.length; i++) {
            for (var it in act[i].images) {
                if (act[i].images[it]) {
                    arr_images.push(act[i].images[it]);
                }
            }
        }
        return {
            images: [
                me.data.image
            ].concat(arr_images)
        };
    }
});

Ext.define('ExGods.view.pet.Tape', {
    extend: ExGods.view.Tape,
    alias: 'widget.pettape',
    cls: 'mask-items',
    bodyStyle: {
        overflow: 'visible'
    },
    cellWidth: 86,
    cellHeight: 82,
    initComponent: function() {
        var me = this;
        me.itemTpl = [
            '<div class="qh-object item {[this.getClass(values)]}" data-qh_otype="room_pet" data-qh_oid="{item_proto.entry}" id="petid-{entry}" data-qtip="{[this.getEscapedTitle(values)]}" >',
            '<div class="mask_frm"></div>',
            '<img class="image" src="{[this.getImage(values)]}" width="50" height="50">',
            '<div class="sticker"{[ this.getStickerStyle(values) ]}></div>',
            '</div>',
            {
                getClass: function(values) {
                    return values.has ? ' has' : '';
                },
                checkDur: function(values) {
                    return values.item_proto.param.nonbr == 0;
                },
                getEscapedTitle: function(values) {
                    return Ext.String.htmlEncode(values.item_proto.title);
                },
                getImage: function(values) {
                    return values.has ? values.item_proto.images.on : values.item_proto.images.off;
                },
                getStickerStyle: function(values) {
                    var style = '';
                    if (values.steepness > 1) {
                        var images = ExGods.ref('images|pets_images').image,
                            image = values.has ? images.trophies_rare : images.trophies_rare_bw;
                        style = ' style="background-image: url(' + image + ')"';
                    }
                    return style;
                }
            }
        ];
        me.scrollDuration = ExGods.ref('constants|mask_scroll_time').value * 1000;
        me.callParent();
    },
    onRender: function() {
        var me = this;
        me.callParent();
        me.printSelector();
    },
    printSelector: function() {
        var me = this;
        me.el.insertHtml('beforeEnd', '<div class="mask_selected_frame"></div>');
    },
    /**
     * override
     */
    getNodeByRecord: function(record) {
        return this.el.down('#petid-' + record.get('entry'));
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        var parent = me.callParent();
        var images_trophies = ExGods.ref('images|pets_images').image;
        for (var it in images_trophies) {
            arr_images.push(images_trophies[it]);
        }
        return {
            stuff: [].concat(parent.stuff),
            images: [
                IMAGE_URL + 'mask/mask_select.png'
            ].concat(arr_images).concat(parent.images)
        };
    }
});

/**
 *      
 */
Ext.define('ExGods.view.pet.AllPets', {
    extend: Ext.panel.Panel,
    alias: 'widget.allpets',
    bodyPadding: '7 8 0 6',
    initComponent: function() {
        var me = this;
        me.items = [
            {
                xtype: 'panel',
                layout: 'absolute',
                height: 415,
                items: [
                    {
                        xtype: 'petinfo',
                        clientConfig: me.clientConfig,
                        pet: me.pet,
                        x: 6,
                        y: 0,
                        //height: 415,
                        padding: '0 0 6'
                    },
                    // buttons: [{
                    //  text: me.clientConfig.pet_leave_btn,
                    //  cls: 'no_border x-btn-txt-red',
                    //  itemId: 'pet_release_btn'
                    // }]
                    {
                        xtype: 'petsgrid',
                        x: 240,
                        y: 32,
                        store: me.store,
                        pager: {
                            marginLeft: -278,
                            marginRight: -41,
                            textTop: -20
                        },
                        listeners: {
                            viewready: function() {
                                me.setPet();
                            }
                        }
                    },
                    {
                        // xtype: 'textbutton',
                        // itemId: 'feed_all_pets',
                        // cls: 'x-btn-txt-green',
                        // disabled: !me.store.isAnyPet() || me.store.isAllFeed(),
                        // text: me.clientConfig.feed_all_text,
                        cls: 'x-btn-txt-green',
                        xtype: 'textbutton',
                        text: me.clientConfig.pet_control_btn,
                        itemId: 'pet_control_btn',
                        disabled: !me.pet.get('has'),
                        x: 64,
                        /*235*/
                        y: 374
                    }
                ]
            }
        ];
        /*, {
                xtype: 'textbutton',
                itemId: 'release_all_pets',
                cls: 'x-btn-txt-red',
                disabled: !me.store.isAnyPet(),
                text: me.clientConfig.release_all_text,
                x: 630,
                y: 374
            }*/
        me.callParent();
    },
    setPet: function(record, stats) {
        record = record || this.pet;
        var me = this,
            dataview = me.down('dataview'),
            info = me.down('petinfo'),
            controlBtn = me.down('#pet_control_btn');
        info.pet = record;
        info.update(Ext.apply({
            fit_stats: stats
        }, record.data));
        controlBtn.setDisabled(!record.get('has'));
        dataview.select(record);
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.pet.Control', {
    extend: ExGods.view.CommonWindow,
    alias: 'widget.petcontrol',
    autoShow: true,
    width: 298,
    bodyPadding: 5,
    y: 180,
    //     
    plugins: [
        'skindeco'
    ],
    cls: 'pet-control',
    buttonAlign: 'center',
    /**
     * @required
     * @cfg pet -  
     */
    initComponent: function() {
        var me = this,
            value = me.pet.get('item').param.dur,
            max = me.pet.get('item_proto').param.dur,
            to_feed = Math.max(max - value, 1),
            has_price_stuff = !Ext.isEmpty(me.pet.get('price_stuff')) && me.pet.get('price_stuff').type;
        if (has_price_stuff) {
            me.y -= 40;
        }
        me.items = [
            {
                plugins: [
                    'paperdeco'
                ],
                width: me.width - 10,
                height: has_price_stuff ? 291 : 205,
                padding: '7 10 20',
                data: me.pet.data,
                tpl: [
                    '<div class="paper-title"><h4>{title}</h4></div>',
                    '<div class="pet-control-img">',
                    '<img src="{item_proto.images.on}">',
                    '</div>',
                    '<div class="pet-control-state">',
                    '<div class="component">',
                    '<span role="xtype">petstate</span>',
                    '<span role="pet_id">{entry}</span>',
                    //'<span role="clientConfig:object">' + Ext.encode(me.clientConfig) + '</span>',
                    '</div>',
                    '</div>',
                    '<div class="paper-separator"></div>',
                    '<tpl if="this.hasPriceStuff(values)">',
                    '<div class="pet-feed-stuff-image">',
                    '{[ExGods.stuff.StuffManager.image(values.price_stuff)]}',
                    '</div>',
                    '<div class="pet-feed-stuff-title">{[ExGods.stuff.StuffManager.title(values.price_stuff)]}</div>',
                    '<div class="pet-feed-stuff-count">{[this.printStuffCount(values.count_price_stuff)]}</div>',
                    '<div class="paper-separator"></div>',
                    '</tpl>',
                    {
                        hasPriceStuff: function(values) {
                            return has_price_stuff;
                        },
                        printStuffCount: function(count) {
                            return ExGods.app.applyTpl(me.clientConfig.count_price_stuff, {
                                count: count
                            });
                        }
                    }
                ],
                dockedItems: [
                    {
                        dock: 'bottom',
                        xtype: 'container',
                        layout: {
                            type: 'vbox',
                            align: 'center',
                            pack: 'center'
                        },
                        items: [
                            {
                                xtype: 'exg_slider',
                                width: 250,
                                value: to_feed,
                                maxValue: to_feed,
                                disabled: !(max - value),
                                title: me.clientConfig.slider_title,
                                upperScale: me.getUpperScale(to_feed),
                                listeners: {
                                    change: me.updateFeedBtn,
                                    scope: me
                                },
                                hidden: !me.pet.get('active')
                            },
                            {
                                xtype: 'textbutton',
                                itemId: 'feed_pet',
                                cls: 'no_border x-btn-txt-green',
                                text: me.printFeedText(to_feed),
                                disabled: !(max - value),
                                width: 220,
                                hidden: !me.pet.get('active')
                            },
                            {
                                xtype: 'textbutton',
                                itemId: 'resurrect_pet',
                                cls: 'no_border',
                                text: ExGods.app.applyTpl(me.clientConfig.resurrect_pet_btn, {
                                    cost: ExGods.util.Stuff.printStuff(me.pet.get('price_live'))
                                }),
                                width: 240,
                                margin: '0 0 24 0',
                                hidden: !!me.pet.get('active')
                            }
                        ]
                    }
                ]
            }
        ];
        me.buttons = {
            margin: '-5 0 15 0',
            defaults: {
                xtype: 'textbutton',
                minWidth: 100
            },
            items: [
                {
                    cls: 'x-btn-txt-red',
                    text: me.clientConfig.pet_release_in_control_btn,
                    itemId: 'pet_release_btn'
                },
                {
                    text: me.clientConfig.pet_off_btn,
                    itemId: 'pet_off_btn',
                    hidden: me.can_put_on
                },
                {
                    text: me.clientConfig.fitText,
                    cls: 'x-btn-txt-green',
                    itemId: 'pet_on_btn',
                    hidden: !me.can_put_on
                }
            ]
        };
        me.callParent();
        me.view = me.items.getAt(0);
        me.view.on({
            render: function() {
                ExGods.util.Helper.renderComponents(me.view.el, me.view);
            },
            destroy: function() {
                ExGods.util.Helper.destroyComponents(me.view.el);
            }
        });
    },
    getUpperScale: function(value) {
        return value / this.clientConfig.scale_count;
    },
    update: function(data) {
        var me = this;
        me.callParent(arguments);
        ExGods.util.Helper.renderComponents(me.view.el, me.view);
        me.updateFeedBtn();
        me.updateResurrectBtn();
    },
    updateFeedBtn: function() {
        var me = this,
            value = me.down('exg_slider').getValue();
        me.down('#feed_pet').setText(me.printFeedText(value));
    },
    updateResurrectBtn: function() {
        var me = this;
        me.down('#resurrect_pet').setText(ExGods.app.applyTpl(me.clientConfig.resurrect_pet_btn, {
            cost: ExGods.util.Stuff.printStuff(me.pet.get('price_live'))
        }));
    },
    printFeedText: function(count) {
        var me = this,
            cost = Ext.clone(me.pet.get('price')),
            count_price_stuff = me.pet.get('count_price_stuff') || 0;
        count = count || 1;
        var cost_count = Math.max(count - count_price_stuff, 0);
        cost.value = cost.value * cost_count;
        if (cost_count) {
            return ExGods.app.applyTpl(me.clientConfig.feed_pet_btn, {
                days: count + ' ' + Ext.util.Format.plural(count, ExGods.getMsgByKey('date_format_days_text').split(',')),
                cost: ExGods.printMoney(cost)
            });
        } else {
            return ExGods.app.applyTpl(me.clientConfig.feed_pet_btn_free, {
                days: count + ' ' + Ext.util.Format.plural(count, ExGods.getMsgByKey('date_format_days_text').split(','))
            });
        }
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            stuff_arr = [],
            arr_images = [];
        var pet_data = me.pet.data;
        for (var it in pet_data.item_proto.images) {
            arr_images.push(pet_data.item_proto.images[it]);
        }
        for (var i = 0; i < me.pet.data.price_stuff.length; i++) {
            stuff_arr.push(me.pet.data.price_stuff[i]);
        }
        for (var i = 0; i < me.pet.data.price_garanted.length; i++) {
            stuff_arr.push(me.pet.data.price_garanted[i]);
        }
        for (var i = 0; i < me.pet.data.price_live.length; i++) {
            stuff_arr.push(me.pet.data.price_live[i]);
        }
        return {
            images: [
                me.pet.data.image
            ].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.model.Pet', {
    extend: Ext.data.Model,
    idProperty: 'entry',
    fields: [
        {
            name: 'chance_domestication',
            type: 'int'
        },
        {
            name: 'description',
            type: 'string'
        },
        {
            name: 'group',
            type: 'string'
        },
        {
            name: 'image',
            type: 'string',
            convert: function(v, r) {
                return IMAGE_URL + v;
            }
        },
        {
            name: 'item_proto',
            type: 'auto',
            convert: function(v, r) {
                var proto_data = ExGods.app.getItemPrototypesStore().data.getByKey(v).data,
                    stats;
                setTimeout(function() {
                    r.data.title = proto_data.title;
                    r.data.actions = proto_data.action_full;
                    for (var key in proto_data.data.stats) {
                        if (proto_data.data.stats[key]) {
                            if (!stats) {
                                stats = {};
                            }
                            stats[key] = proto_data.data.stats[key];
                        }
                    }
                    r.data.stats = stats;
                }, 0);
                return proto_data;
            }
        },
        {
            name: 'order',
            type: 'int'
        },
        {
            name: 'g_order',
            type: 'int'
        },
        {
            //   1 
            name: 'price',
            type: 'auto'
        },
        {
            //stuff
            name: 'price_garanted',
            type: 'auto'
        },
        {
            // 
            name: 'price_live',
            type: 'auto'
        },
        {
            // ,   
            name: 'price_stuff',
            type: 'auto'
        },
        {
            name: 'productivity',
            type: 'int'
        },
        {
            name: 'steepness',
            type: 'int'
        },
        {
            name: 'time_tame',
            type: 'int'
        },
        {
            name: 'battle_actions',
            type: 'auto',
            convert: function(v, r) {
                var battle_actions = [];
                if (v.battle_instants && v.battle_instants.length) {
                    Ext.Array.each(v.battle_instants, function(item) {
                        var id = item.name,
                            info = ExGods.ref('battle_prep|' + id);
                        battle_actions.push({
                            id: id,
                            type: 'battle_prep',
                            title: info.label,
                            img: IMAGE_URL + info.desc.images['active'],
                            desc: info.desc.desc
                        });
                    });
                }
                if (v.battle_turns && v.battle_turns.length) {
                    Ext.Array.each(v.battle_turns, function(item) {
                        var id = item.name,
                            info = ExGods.ref('battle_turn|' + id);
                        battle_actions.push({
                            id: id,
                            type: 'battle_turn',
                            title: info.label,
                            img: IMAGE_URL + info.desc.images['active'],
                            desc: info.desc.desc
                        });
                    });
                }
                if (v.battle_actions && v.battle_actions.length) {
                    Ext.Array.each(v.battle_actions, function(item) {
                        var id = item.id,
                            info = ExGods.ref('battle_actions|' + id);
                        battle_actions.push({
                            id: id,
                            type: 'battle_actions',
                            title: info.label,
                            img: IMAGE_URL + info.desc.img,
                            desc: info.desc.description
                        });
                    });
                }
                //    : ", , "
                battle_actions = Ext.Array.sort(battle_actions, function(a, b) {
                    if (a.type == b.type) {
                        return 0;
                    } else if (a.type == 'battle_turn') {
                        return -1;
                    } else if (a.type == 'battle_actions') {
                        return 1;
                    } else if (b.type == 'battle_turn') {
                        return 1;
                    } else {
                        return -1;
                    }
                });
                return battle_actions;
            }
        },
        {
            name: 'title',
            type: 'string'
        },
        {
            name: 'has',
            type: 'int'
        },
        {
            name: 'active',
            type: 'int'
        },
        {
            //    ,   
            name: 'item',
            type: 'auto'
        },
        {
            //   ,   
            name: 'count_price_stuff',
            type: 'int'
        },
        {
            //  
            name: 'actions',
            type: 'auto',
            convert: function(v, r) {
                //TEST
                //return ExGods.app.getUser().slots().data.getByKey(3102).get('items').findRecord('proto_id',68).get('features');
                return v || [];
            }
        },
        {
            //  
            name: 'stats',
            type: 'auto'
        }
    ],
    canFeed: function() {
        return this.data.item && this.data.item.param.dur != 0 && this.data.item.param.dur != this.data.item_proto.param.dur;
    }
});

/**
 *  
 */
Ext.define('ExGods.store.Pets', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Pet',
    proxy: 'memory',
    sorters: [
        {
            property: 'active',
            direction: 'DESC'
        },
        {
            property: 'has',
            direction: 'DESC'
        },
        {
            property: 'order',
            direction: 'DESC'
        }
    ],
    /**
     *     ,     
     */
    updateFromService: function(data, silent) {
        var me = this,
            need_reload_protos = false;
        me.each(function(rec) {
            rec.set({
                active: 0,
                has: 0,
                item: null
            });
        });
        Ext.Array.each(data.active_pets, function(pet) {
            var rec = me.data.getByKey(pet.proto.entry);
            //start TEST
            //pet.item.param.dur = 5;
            //end TEST
            if (rec) {
                rec.set(Ext.apply({
                    active: 1,
                    has: 1,
                    item: pet.item
                }, pet.current));
            } else  {
                need_reload_protos = true;
            }
            
        });
        Ext.Array.each(data.passive_pets, function(pet) {
            var rec = me.data.getByKey(pet.proto.entry);
            if (rec) {
                rec.set(Ext.apply({
                    active: 0,
                    has: 1,
                    item: pet.item
                }, pet.current));
            } else  {
                need_reload_protos = true;
            }
            
        });
        me.sort();
        if (need_reload_protos && !silent) {
            me.fireEvent('request_protos');
        }
    },
    /**
     *       
     */
    isAnyPet: function() {
        var has = false;
        this.each(function(rec) {
            if (rec.get('has')) {
                has = true;
            }
        });
        return has;
    },
    /**
     *     
     */
    isAllFeed: function() {
        var feed = true;
        this.each(function(rec) {
            if (rec.canFeed()) {
                feed = false;
            }
        });
        return feed;
    }
});

/**
 *   
 */
Ext.define('ExGods.view.pet.State', {
    extend: Ext.Component,
    alias: 'widget.petstate',
    cls: 'pet-state-cmp',
    /**
     * @required
     * @cfg pet_id - entry 
     */
    width: 200,
    initComponent: function() {
        var me = this;
        me.store = ExGods.app.getPetsController().store;
        me.data = me.store.data.getByKey(me.pet_id).data;
        me.clientConfig = ExGods.app.getPetsController().clientConfig;
        me.tpl = [
            '<div class="pet-state">{[this.getState(values)]}</div>',
            '<div class="pet-state-food exg-share-bg-dark" style="width:' + me.width + 'px">',
            '<div class="pet-state-food-label">' + me.clientConfig.satiety + '</div>',
            '<div class="pet-state-food-value">&nbsp;{[this.getPercent(values)]}%</div>',
            '<div class="pet-state-food-progress">',
            '<div class="pet-state-food-progress-value" style="width:{[this.getProgress(values)]}px"></div>',
            '</div>',
            '{[this.getLeftTime(values)]}',
            '</div>',
            {
                getState: function(values) {
                    return values.active ? me.clientConfig.pet_active : me.clientConfig.pet_inactive;
                },
                getPercent: function(values) {
                    return Math.floor(values.item.param.dur * 100 / values.item_proto.param.dur);
                },
                getProgress: function(values) {
                    //84 -   
                    return Math.floor(values.item.param.dur * 84 / values.item_proto.param.dur);
                },
                getLeftTime: function(values) {
                    if (!values.active || !values.item.checked)  {
                        return '';
                    }
                    
                    var check_date = ExGods.util.Date.normalizeServerDateTime(values.item.checked);
                    date = check_date.getTime() + values.item.param.dur * Number(me.clientConfig.service.data.period_to_eat) * 60 * 60 * 1000;
                    return [
                        '<div class="pet-state-left">',
                        ExGods.app.applyTpl(me.clientConfig.timer, {
                            time: ExGods.util.Timers.printTimer('rest', 'pet-timer' + values.entry, new Date(date), {
                                needNormalized: false,
                                format: 'twonums'
                            })
                        }),
                        '</div>'
                    ].join('');
                }
            }
        ];
        me.callParent();
    },
    /**
     *   
     */
    getResources: function() {
        var me = this;
        var arr_images = [];
        return {
            images: []
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.pet.Grid', {
    extend: ExGods.view.grid.SkinGrid,
    alias: 'widget.petsgrid',
    cls: 'pets-grid',
    rowsCount: 3,
    columnsCount: 5,
    cellHeight: 124,
    //height: 365,
    //    
    empty_cells: 0,
    //DOM Objects,  dom   .    - undefined
    rowHeaders: [],
    isEnabled: function(values) {
        return values.has;
    },
    getImage: function(values) {
        return values.has ? values.item_proto.images.on : values.item_proto.images.off;
    },
    initComponent: function() {
        var me = this,
            petsStore = me.store;
        me.store = Ext.create('ExGods.store.Pets', {
            sorters: [
                {
                    property: 'g_order',
                    direction: 'DESC'
                },
                {
                    property: 'order',
                    direction: 'DESC'
                }
            ]
        });
        me.store.loadRecords(petsStore.data.items);
        me.mon(petsStore, 'datachanged', function() {
            me.store.loadRecords(petsStore.data.items);
        });
        me.callParent();
    },
    /**
     * override
     *       
     */
    getTotalPagesCount: function() {
        var me = this,
            rec_group, index, next_rec, i;
        me.empty_cells = 0;
        me.store.each(function(rec) {
            rec_group = rec.get('group');
            index = me.store.indexOf(rec);
            next_rec = me.store.getAt(index + 1);
            i = me.columnsCount - (index + me.empty_cells) % me.columnsCount - 1;
            if (!next_rec || next_rec.get('group') != rec_group) {
                me.empty_cells += i;
            }
        });
        return Math.ceil((me.store.getCount() + me.empty_cells) / (me.rowsCount * me.columnsCount)) || 1;
    },
    /**
     * override
     *       
     */
    renderEmptySlots: function() {
        var me = this,
            rec_group, index, node, i, next_rec, header,
            headersHtml = '',
            ul = me.el.down('.exg-grid-items'),
            itemsPerPage = me.rowsCount * me.columnsCount,
            emptyNode = [
                '<li class="exg-grid-item" style="width:' + me.cellWidth + 'px;height:' + me.cellHeight + 'px">',
                '<div class="exg-grid-skin-item empty">',
                '<div class="exg-grid-skin-frm"></div>',
                '<img class="image" src="' + IMAGE_URL + 'locations/monster_absent.jpg">',
                '<div class="x-clear"></div>',
                '</div>',
                '</li>'
            ].join('');
        me.empty_cells = 0;
        me.rowHeaders = [];
        me.store.each(function(rec) {
            rec_group = rec.get('group');
            index = me.store.indexOf(rec);
            next_rec = me.store.getAt(index + 1);
            node = me.itemsView.getNodeByRecord(rec);
            i = me.columnsCount - (index + me.empty_cells) % me.columnsCount - 1;
            if ((index + me.empty_cells) % (3 * me.columnsCount) == 0) {
                me.rowHeaders[(index + me.empty_cells) / me.columnsCount] = rec_group;
            }
            if (!next_rec || next_rec.get('group') != rec_group) {
                me.empty_cells += i;
                if (next_rec) {
                    me.rowHeaders[Math.ceil((index + me.empty_cells) / me.columnsCount)] = next_rec.get('group');
                }
                while (i--) {
                    Ext.get(node).insertSibling(emptyNode, 'after');
                }
            }
        });
        ul = me.el.down('.exg-grid-items');
        i = itemsPerPage - (me.store.getCount() + me.empty_cells) % itemsPerPage;
        while (i--) {
            ul.insertHtml('beforeEnd', emptyNode);
        }
        // 
        i = me.rowHeaders.length;
        me.headersEl = document.createElement('div');
        me.headersEl.className = 'all-pets-headers';
        me.headersEl.style.marginTop = ul.getStyle('margin-top');
        while (i--) {
            if (me.rowHeaders[i]) {
                header = document.createElement('div');
                header.className = 'all-pets-header';
                header.style.top = me.cellHeight * i + 'px';
                header.innerHTML = me.rowHeaders[i] + '<div>' + me.rowHeaders[i] + '</div>';
                if (i >= 3) {
                    header.style.display = 'none';
                }
                me.rowHeaders[i] = header;
                me.headersEl.appendChild(header);
            }
        }
        me.el.appendChild(me.headersEl);
        //  "".  , ..   
        me.store.each(function(rec) {
            node = me.itemsView.getNodeByRecord(rec);
            if (rec.get('steepness') > 1) {
                var el = document.createElement('div'),
                    images = ExGods.ref('images|pets_images').image,
                    image = rec.get('has') ? images.trophies_rare : images.trophies_rare_bw;
                el.className = 'sticker';
                el.style.top = node.offsetTop + 'px';
                el.style.left = node.offsetLeft + 'px';
                el.style.backgroundImage = 'url(' + image + ')';
                me.headersEl.appendChild(el);
            }
        });
    },
    initPager: function(ct) {
        var me = this;
        me.callParent(arguments);
        ct.openPage = function(pageIndex) {
            var ul = me.getEl().down('.exg-grid-items'),
                margin = (pageIndex - 1) * me.rowsCount * me.cellHeight,
                startI = (pageIndex - 1) * 3,
                endI = pageIndex * 3;
            ul.setStyle('margin-top', '-' + margin + 'px');
            if (me.headersEl) {
                me.headersEl.style.marginTop = -margin + 'px';
                Ext.Array.each(me.rowHeaders, function(header, i) {
                    if (!header)  {
                        return;
                    }
                    
                    if (i >= startI && i < endI) {
                        header.style.display = 'block';
                    } else {
                        header.style.display = 'none';
                    }
                });
                var i = me.headersEl.childNodes.length,
                    sticker;
                while (i--) {
                    if (me.headersEl.childNodes[i].className.indexOf('sticker') != -1) {
                        sticker = me.headersEl.childNodes[i];
                        if (parseInt(sticker.style.top) >= Math.abs(ul.dom.offsetTop) && parseInt(sticker.style.top) < Math.abs(ul.dom.offsetTop) + ul.dom.parentNode.offsetHeight) {
                            sticker.style.display = 'block';
                        } else {
                            sticker.style.display = 'none';
                        }
                    }
                }
            }
        };
    },
    /**
     *   
     */
    getResources: function() {
        var me = this,
            images,
            arr_images = [];
        me.store.each(function(rec) {
            if (rec.get('steepness') > 1) {
                var el = document.createElement('div'),
                    images = ExGods.ref('images|pets_images').image,
                    image = rec.get('has') ? images.trophies_rare : images.trophies_rare_bw;
                arr_images.push(image);
            }
        });
        images = ExGods.ref('images|pets_images').image;
        for (var it in images) {
            arr_images.push(images[it]);
        }
        for (var i = 0; i < me.store.data.items.length; i++) {
            var imgs = me.store.data.items[i].data.item_proto.images;
            for (var it in imgs) {
                arr_images.push(imgs[it]);
            }
        }
        return {
            images: [].concat(arr_images)
        };
    }
});

/**
 *  
 */
Ext.define('ExGods.controller.Pets', {
    extend: ExGodsCore.controller.Base,
    refs: [
        {
            /**
         * @method getBackInTown
         *   " "
         */
            ref: 'backInTown',
            selector: '#back_in_town'
        },
        {
            /**
         * @method getPetInfo
         *     
         * @return {ExGods.view.pet.Info}
         */
            ref: 'petInfo',
            selector: '#pet_info'
        },
        {
            /**
         * @method getPetImage
         *     
         * @return {Ext.Component}
         */
            ref: 'petImage',
            selector: '#pet_image'
        },
        {
            /**
         * @method getAllPets
         *      
         * @return {ExGods.view.pet.AllPets}
         */
            ref: 'allPets',
            selector: 'allpets'
        },
        {
            /**
         * @method getTape
         *   
         * @return {ExGods.pet.Tape}
         */
            ref: 'tape',
            selector: 'pettape'
        },
        {
            /**
         * @method getPetControlBtn
         *    
         * @return {ExGods.view.TextButton}
         */
            ref: 'petControlBtn',
            selector: '#pet_control_btn'
        }
    ],
    views: [
        'pet.Tape',
        'pet.Info',
        'pet.AllPets',
        'pet.State',
        'pet.Control',
        'grid.SkinGrid',
        'pet.Grid'
    ],
    models: [
        'Pet'
    ],
    stores: [
        'Pets'
    ],
    logConfig: {
        enabled: {
            info: true,
            warn: true,
            error: true
        },
        prefix: 'Pets:'
    },
    init: function(app) {
        var me = this;
        me.store = Ext.create('ExGods.store.Pets');
        me.store.on('request_protos', me.updateProtos, me);
        me.control({
            'pettape': {
                select: me.onPetSelect
            },
            'allpets dataview': {
                itemclick: me.onPetItemClick
            },
            '#pet_control_btn': {
                click: me.onControlBtnClick
            },
            '#pet_release_btn': {
                click: me.onReleaseBtnClick
            },
            '#pet_off_btn': {
                click: me.onOffBtnClick
            },
            '#pet_on_btn': {
                click: me.onOnBtnClick
            },
            '#feed_all_pets': {
                click: me.onFeedAllPetsBtnClick
            },
            '#feed_pet': {
                click: me.onFeedPetClick
            },
            '#resurrect_pet': {
                click: me.onResurrectPetClick
            },
            '#release_all_pets': {
                click: me.onReleaseAllPetsBtnClick
            }
        });
        ExGods.Components.addComponentInitializer('pets', me.initPetsComponent, me);
    },
    onServiceUpdate: function() {
        var me = this,
            allPets = me.getAllPets();
        me.store.updateFromService(me.service.data);
        if (allPets) {
            allPets.down('#feed_all_pets').setDisabled(!me.store.isAnyPet() || me.store.isAllFeed());
            allPets.down('#release_all_pets').setDisabled(!me.store.isAnyPet());
        }
    },
    onPetSelect: Ext.Function.createBuffered(function(tape, dataview, record, index) {
        var me = this;
        me.setPet(record);
    }, 400),
    onPetItemClick: Ext.Function.createBuffered(function(grid, record, dom) {
        var me = this;
        me.getTape().setActiveEl(record, {
            silent: true
        });
        me.setPet(record);
    }, 400),
    onControlBtnClick: function(btn) {
        var me = this,
            price_stuff = Ext.Array.clean([
                me.currentPet.get('price_stuff')
            ]);
        ExGods.helpme.loadProtosFromStuff(price_stuff, function() {
            var wnd = Ext.widget('petcontrol', {
                    pet: me.currentPet,
                    autoShow: false,
                    can_put_on: me.canPutOn(me.currentPet),
                    clientConfig: me.clientConfig
                });
            ExGods.Resources.load(wnd, function() {
                wnd.show();
            });
        });
    },
    onReleaseBtnClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol');
        Ext.widget('confirmdialog', {
            message: me.clientConfig.confirm_pet_remove,
            handler: function() {
                me.service.command('pet_remove', {
                    slot: me.currentPet.get('item').slot_id,
                    item: me.currentPet.get('item').item_id
                }, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update(null, function() {
                        if (wnd)  {
                            wnd.close();
                        }
                        
                    });
                });
            }
        });
    },
    onFeedAllPetsBtnClick: function(btn) {
        var me = this;
        Ext.widget('confirmdialog', {
            message: ExGods.app.applyTpl(me.clientConfig.confirm_pets_repair_all, {
                cost: me.calcTotalFeedPrice()
            }),
            handler: function() {
                me.service.command('pets_repair_all', {}, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update();
                });
            }
        });
    },
    onReleaseAllPetsBtnClick: function(btn) {
        var me = this;
        Ext.widget('confirmdialog', {
            message: me.clientConfig.confirm_pet_remove_all,
            handler: function() {
                me.service.command('pet_remove_all', {}, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update();
                });
            }
        });
    },
    onFeedPetClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol'),
            value = wnd.down('exg_slider').getValue();
        Ext.widget('confirmdialog', {
            message: me.clientConfig.confirm_pets_repair,
            handler: function() {
                me.service.command('pets_repair', {
                    slot: me.currentPet.get('item').slot_id,
                    item: me.currentPet.get('item').item_id,
                    value: value
                }, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update(null, function() {
                        wnd.close();
                    });
                });
            }
        });
    },
    onResurrectPetClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol');
        Ext.widget('confirmdialog', {
            message: me.clientConfig.confirm_pets_live,
            handler: function() {
                me.service.command('pets_live', {
                    slot: me.currentPet.get('item').slot_id,
                    item: me.currentPet.get('item').item_id
                }, function(resp) {
                    if (!resp.success)  {
                        return;
                    }
                    
                    me.service.update(null, function() {
                        wnd.close();
                    });
                });
            }
        });
    },
    onOffBtnClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol');
        me.service.command('pets_off', {
            slot: me.currentPet.get('item').slot_id
        }, function(resp) {
            if (!resp.success)  {
                return;
            }
            
            me.service.update(null, function() {
                if (wnd)  {
                    wnd.close();
                }
                
            });
        });
    },
    onOnBtnClick: function(btn) {
        var me = this,
            wnd = btn.up('petcontrol');
        me.putOnPet(function() {
            if (wnd)  {
                wnd.close();
            }
            
        });
    },
    calcTotalFeedPrice: function() {
        var me = this,
            prices = {},
            money = [];
        me.store.each(function(rec) {
            if (!rec.get('active'))  {
                return;
            }
            
            var price = rec.get('price'),
                value = rec.get('item').param.dur,
                max = rec.get('item_proto').param.dur,
                to_feed = max - value;
            if (to_feed) {
                if (!prices[price.name]) {
                    prices[price.name] = 0;
                }
                prices[price.name] += price.value * to_feed;
            }
        });
        for (var name in prices) {
            money.push({
                name: name,
                value: prices[name]
            });
        }
        return ExGods.printMoney(money);
    },
    /**
     *       
     */
    setPet: function(record) {
        var me = this,
            cur_pet = me.getCurrent(),
            _setPet = function(stats) {
                var info = me.getPetInfo(),
                    allPets = me.getAllPets(),
                    imgCmp = me.getPetImage(),
                    controlBtn = me.getPetControlBtn(),
                    fitBtn = me.getBackInTown(),
                    tape = me.getTape();
                ExGods.app.block();
                ExGods.Resources.load({
                    getResources: function() {
                        return {
                            images: [
                                me.clientConfig.fitText,
                                me.clientConfig.closeText,
                                record.get('image')
                            ]
                        };
                    }
                }, function() {
                    ExGods.app.unblock();
                    if (!info) {
                        return;
                    }
                    me.currentPet = record;
                    info.pet = record;
                    info.update(Ext.apply({
                        fit_stats: stats
                    }, record.data));
                    if (allPets) {
                        allPets.setPet(record, stats);
                    }
                    tape.setActiveEl(record, {
                        silent: true
                    });
                    if (me.canPutOn(record)) {
                        fitBtn.setText(me.clientConfig.fitText);
                        fitBtn.el.set({
                            'data-qh_oid': 1
                        });
                    } else {
                        fitBtn.setText(me.clientConfig.closeText);
                        fitBtn.el.set({
                            'data-qh_oid': 0
                        });
                    }
                    controlBtn[record.get('has') ? 'show' : 'hide']();
                    var speed = parseInt(ExGods.ref('constants|mask_house_change_speed').value),
                        wait = parseInt(ExGods.ref('constants|mask_house_change_wait_time').value);
                    if (!me.prevImagePets) {
                        me.prevImagePets = '';
                    }
                    if (me.prevImagePets != record.get('image')) {
                        me.prevImagePets = record.get('image');
                        imgCmp.el.animate({
                            duration: speed,
                            to: {
                                opacity: 0
                            },
                            listeners: {
                                afteranimate: function() {
                                    imgCmp.el.setStyle('background-image', 'url(' + record.get('image') + ')');
                                }
                            }
                        }).animate({
                            delay: wait,
                            duration: speed,
                            to: {
                                opacity: 1
                            }
                        });
                    }
                });
            };
        // resources load
        if (record == cur_pet) {
            _setPet();
        } else {
            me.service.command('fit_pet', {
                id: record.get('entry')
            }, function(resp) {
                if (!resp.success)  {
                    return;
                }
                
                try {
                    _setPet(resp.fit.stats);
                } catch (e) {
                    me.log('warn', ' ');
                }
            });
        }
    },
    canPutOn: function(record) {
        var me = this,
            slots = ExGods.app.getUser().slots(),
            active_pet_slot = slots.findRecord('type', 25);
        //25  -   
        if (!active_pet_slot) {
            return;
        }
        var active_pets_store = active_pet_slot.get('items');
        return record.get('active') && !active_pets_store.findRecord('item_id', record.get('item').item_id);
    },
    getCurrent: function() {
        var me = this,
            slots = ExGods.app.getUser().slots(),
            active_pet_slot = slots.findRecord('type', 25);
        //25  -   
        if (!active_pet_slot) {
            return false;
        }
        var active_pets_store = active_pet_slot.get('items'),
            fit_pet;
        me.store.each(function(rec) {
            var item = rec.get('item');
            if (item && active_pets_store.findRecord('item_id', item.item_id)) {
                fit_pet = rec;
            }
        });
        return fit_pet;
    },
    /**
     * Xclicked - ,    
     */
    checkFitOnClose: function(Xclicked) {
        var me = this,
            prevent_close = false,
            closeWindow = function() {
                if (prevent_close)  {
                    return;
                }
                
                var fittedPet = me.getCurrent() || me.currentPet,
                    callback = function() {
                        ExGods.loaderCt.loadAndRemove(function() {
                            Ext.getCmp('PETS').close();
                        }, {
                            img: me.clientConfig.backImg
                        });
                    };
                if (fittedPet) {
                    me.getTape().setActiveEl(fittedPet, {
                        animate: true,
                        silent: true,
                        forced: true,
                        callback: callback
                    });
                } else  {
                    callback();
                }
                
            };
        if (me.currentPet && me.canPutOn(me.currentPet)) {
            if (Xclicked) {
                Ext.widget('confirmdialog', {
                    message: me.clientConfig.check_on_fit_message_no_close,
                    handler: function(btn) {
                        prevent_close = true;
                        me.putOnPet(function() {
                            prevent_close = false;
                            closeWindow();
                        });
                    },
                    listeners: {
                        close: closeWindow
                    }
                });
            } else {
                Ext.widget('confirmdialog', {
                    message: me.clientConfig.check_on_fit_message,
                    handler: function(btn) {
                        me.putOnPet();
                    }
                });
            }
        } else  {
            closeWindow();
        }
        
        return false;
    },
    putOnPet: function(cb) {
        var me = this;
        if (!me.currentPet || !me.currentPet.get('item')) {
            /***/
            me.log('warn', '  ! ');
            return;
        }
        me.service.command('pets_on', {
            slot: me.currentPet.get('item').slot_id,
            item: me.currentPet.get('item').item_id
        }, function(resp) {
            if (!resp.success)  {
                return;
            }
            
            me.service.update(null, function() {
                if (cb)  {
                    cb();
                }
                
            });
        });
    },
    updateProtos: function() {
        var me = this;
        ExGods.Services.get('pets').command('pets_proto', {}, function(resp) {
            if (resp.list) {
                var ref = ExGods.references.get('pets');
                ref.clear();
                Ext.Array.each(resp.list, function(item) {
                    ref.add(item.entry, item);
                });
                me.store.loadRawData(resp.list);
                if (me.service) {
                    me.store.updateFromService(me.service.data, true);
                }
                if (me.cmp && me.cmp.isVisible()) {
                    me.setPet(me.store.first());
                }
            }
        });
    },
    initPetsComponent: function(config) {
        var me = this,
            pets = ExGods.references.get('pets').getValues(),
            wnd = Ext.getCmp('PETS'),
            closeCallback = function() {
                ExGods.loaderCt.loadAndRemove(function() {
                    wnd.close();
                }, {
                    img: me.clientConfig.backImg
                });
                return false;
            };
        me.service = config.service;
        me.service.onUpdate = function(data) {
            me.store.updateFromService(data);
            me.setPet(me.currentPet);
        };
        me.clientConfig = config;
        me.cmp = Ext.create('ExGods.view.Room', {
            cls: 'pets',
            backgroundImage: config.backImg,
            closeText: config.closeText,
            closeColor: config.closeColor,
            closeCallback: Ext.Function.bind(me.checkFitOnClose, me, []),
            rightPanelX: 715,
            margin: '0 10 10 0',
            closable: true,
            items: [
                {
                    xtype: 'component',
                    margin: '0 0 0 722',
                    html: '<div class="mask_header" style="background: url(' + IMAGE_URL + config.icon + ');"></div>'
                }
            ],
            listeners: {
                beforeclose: function() {
                    me.service.onUpdate = Ext.emptyFn;
                    return me.checkFitOnClose(true);
                }
            }
        });
        if (wnd) {
            wnd.close();
        }
        wnd = Ext.widget('window1', {
            id: 'PETS',
            autoShow: false,
            items: [
                me.cmp
            ],
            getResources: function() {
                var me = this;
                return {
                    images: [
                        config.backImg
                    ]
                };
            }
        });
        ExGods.app.getController('Location').maskLocation(function() {
            //  
            ExGods.helpme.loadProtos(pets, 'item_proto', function() {
                me.store.loadRawData(Ext.clone(pets));
                me.store.updateFromService(me.service.data);
                me.currentPet = me.getCurrent() || me.store.first();
                if (me.currentPet) {
                    me.cmp.add({
                        xtype: 'petinfo',
                        id: 'pet_info',
                        clientConfig: me.clientConfig,
                        pet: me.currentPet,
                        x: 10,
                        y: 6
                    }, {
                        xtype: 'component',
                        id: 'pet_image',
                        style: {
                            backgroundImage: 'url(' + me.currentPet.get('image') + ')'
                        },
                        x: 205,
                        y: 0,
                        width: 440,
                        height: 410,
                        getResources: function() {
                            return {
                                images: [
                                    me.currentPet.get('image')
                                ]
                            };
                        }
                    }, {
                        xtype: 'pettape',
                        itemId: 'petTape',
                        x: 615,
                        y: 40,
                        width: 225,
                        height: 325,
                        store: me.store,
                        startRecord: me.currentPet
                    }, {
                        height: 30,
                        x: 55,
                        y: 375,
                        width: 120,
                        xtype: 'textbutton',
                        text: me.clientConfig.all_pets_btn,
                        handler: function(btn) {
                            var wnd = Ext.widget('window2', {
                                    autoShow: false,
                                    items: [
                                        {
                                            xtype: 'allpets',
                                            clientConfig: me.clientConfig,
                                            store: me.store,
                                            pet: me.currentPet
                                        }
                                    ]
                                });
                            ExGods.Resources.load(wnd, function() {
                                wnd.show();
                            });
                        }
                    }, {
                        style: {
                            right: '113px',
                            top: '373px'
                        },
                        //cls: 'x-btn-txt-green',
                        xtype: 'textbutton',
                        text: me.clientConfig.pet_control_btn,
                        itemId: 'pet_control_btn',
                        hidden: !me.currentPet.get('has')
                    });
                }
                ExGods.Resources.load(wnd, function() {
                    wnd.show();
                    if (me.currentPet) {
                        me.setPet(me.currentPet);
                    }
                    me.getBackInTown().el.set({
                        'data-qh_otype': 'room_pet_button_puton'
                    });
                    //   
                    setTimeout(function() {
                        ExGods.app.getController('Location').unmaskLocation();
                    }, 100);
                });
            });
        }, {
            img: me.clientConfig.backImg
        });
        return wnd;
    }
});

/**
 *    
 *
 *  -   ,     .
 *      ,     ,    ..
 *
 *      {@link ExGods.controller.Direction#processText},    
 *    .
 *
 * @author  
 *
 */
Ext.define('ExGods.controller.Direction', {
    extend: ExGodsCore.controller.Base,
    logConfig: {
        enabled: {
            info: false,
            warn: true,
            error: true
        },
        prefix: 'Direction:'
    },
    disabled: true,
    init: function() {
        var me = this;
        me.storage = Ext.util.LocalStorage.get('directions');
        me.storage.directionsItemId = 'directions';
        me.control({
            '#battle-result': {
                destroy: {
                    fn: me.showDirections,
                    delay: 100
                }
            }
        });
        var directions = me.storage.getItem(me.storage.directionsItemId) || [];
        Ext.Array.each(directions, function(d) {
            if (d.data.object_name) {
                me.listenComponent(d.data.object_name);
            }
        });
        ExGods.Components.addComponentInitializer('direction', me.initDirectionDialogComponent, me);
        //    
        ExGods.testDirection = function(directionName) {
            me.processText('[# ' + directionName + ' #]');
        };
    },
    shown: {},
    onLaunch: function(app) {
        var me = this;
        me.showDirections();
    },
    /**
     *  / c    
     */
    setDisabled: function(disabled) {
        var me = this;
        if (me.disabled !== disabled) {
            me.disabled = disabled;
            if (!me.disabled) {
                me.showDirections();
            }
        }
    },
    canShowDirections: function() {
        var me = this;
        return !me.disabled;
    },
    isBattle: function() {
        var me = this;
        return me.user.isBattle() || me.app.getController('battle.BattleView').isRendered() || Ext.getCmp('battle-result');
    },
    /**
     *   
     */
    showDirections: function(cmpId) {
        var me = this,
            directions = me.storage.getItem(me.storage.directionsItemId) || [],
            _waitAndShow = function(cmp, d) {
                var times = 0,
                    interval;
                interval = setInterval(function() {
                    if (cmp && cmp.isVisible() && !ExGods.loaderCt.isVisible()) {
                        me.runDirection(d);
                        Ext.Array.remove(directions, d);
                        me.storage.setItem(me.storage.directionsItemId, directions);
                        clearInterval(interval);
                    } else {
                        if (++times > 10) {
                            clearInterval(interval);
                        }
                    }
                }, 250);
            };
        if (!me.canShowDirections()) {
            return;
        }
        Ext.Array.sort(directions, function(a, b) {
            return b.priority - a.priority;
        });
        /***/
        me.log(' ');
        var showen = [],
            lc = ExGods.loaderCt;
        Ext.Array.each(directions, function(d) {
            if (d.data.object_name && !d.data.not_show_with_open_component) {
                var cmp = Ext.getCmp(d.data.object_name);
                if (cmp) {
                    if (cmp.isVisible()) {
                        me.runDirection(d);
                        showen.push(d);
                    } else {
                        _waitAndShow(cmp, d);
                    }
                }
            } else if (me.isBattle() && d.data.show_in_battle != 1) {}
            //
            else if (lc.isVisible()) {
                lc.on('loader_removed', function() {
                    me.runDirection(d);
                }, me, {
                    single: true
                });
                showen.push(d);
            } else {
                me.runDirection(d);
                showen.push(d);
            }
        });
        directions = Ext.Array.difference(directions, showen);
        me.storage.setItem(me.storage.directionsItemId, directions);
    },
    /**
     *  
     */
    runDirection: function(d) {
        var me = this;
        /***/
        me.log(' ', d);
        var fn = function() {
                if (d.data.make == 'service') {
                    //     
                    ExGods.ClientActions.createAndInvoke({
                        actionId: d.data.make_data.id
                    }, null, function(err) {
                        /***/
                        me.log('error', err);
                    });
                } else if (d.data.make == 'component') {
                    if (d.data.make_data.object_name) {
                        //    
                        var cmp = ExGods.Components.factory(d.data.make_data.object_name);
                        if (cmp == 'wrong_setting') {
                            /***/
                            me.log('info', '    ', d);
                            return;
                        } else if (cmp && !cmp.error) {
                            if (cmp.config.auto_run && cmp.directionAutoRun) {
                                cmp.directionAutoRun();
                                cmp.destroy();
                            } else if (cmp.autoShow !== false && !cmp.rendered) {
                                if (typeof cmp.getResources == 'function') {
                                    ExGods.Resources.load(cmp, function() {
                                        cmp.show();
                                    });
                                } else {
                                    cmp.show();
                                }
                            }
                        } else {
                            /***/
                            me.log('error', cmp ? cmp.error : '     ', d);
                        }
                    }
                } else {
                    /***/
                    me.log('error', '  -     ,  ');
                }
                if (d.data.sound) {
                    var sound = ExGods.ref('sounds|' + d.data.sound);
                    if (sound) {
                        ExGods.app.getSoundController().play(sound.audio);
                    }
                }
                if (d.data.caption) {
                    me.blinkTitle(d.data.caption);
                }
            };
        if (d.data.ask_direction && d.data.ask_direction.length) {
            var requests = Ext.Array.map(d.data.ask_direction, function(cfg) {
                    return me.askDirection.bind(me, cfg.command, function() {
                        requests.shift();
                        if (requests[0]) {
                            requests[0]();
                        } else  {
                            fn();
                        }
                        
                    });
                });
            requests[0]();
        } else {
            fn();
        }
    },
    askDirection: function(cmd, callback) {
        var me = this;
        me.request({
            url: '/game.pl',
            params: {
                cmd: 'ask_direction',
                ask: cmd
            },
            success: function(result) {
                me.onAskDirectionSuccess(result);
                callback();
            },
            failure: callback
        });
    },
    onAskDirectionSuccess: function(result) {
        if (result.ask_direction.mainmenu) {
            Ext.getCmp('mainmenu').updateMenu(result.ask_direction.mainmenu);
        }
    },
    /**
     *      .
     *
     *       :
     *
     *  "... [# <direction_name> #]...."
     *  
     * direction_name -     
     *
     * :
     *
     *  "... [# hint_<hint_id> #]...."
     *
     * hint_id - ID .
     *
     * @param {String} Text
     * @return {String}   (  )
     */
    processText: function(text) {
        var me = this,
            pattern = /\[#\s([\w\d-_]+)\s#\]/ig,
            directions = [],
            hints = [],
            matches, d;
        while ((matches = pattern.exec(text)) != null) {
            if (/^hint_/.test(matches[1])) {
                if (me.user.getSetting('disable_hints') != 1)  {
                    hints.push(matches[1].replace('hint_', ''));
                }
                
            } else {
                d = ExGods.references.get('user_directions').get(matches[1]);
                if (d) {
                    directions.push(d);
                }
            }
        }
        if (directions.length) {
            Ext.Array.each(directions, function(d) {
                me.addDirection(d);
            });
            me.showDirections();
        }
        if (hints.length) {
            var hintsController = me.app.getController('Hints');
            Ext.Array.each(hints, function(h) {
                hintsController.showHintById(h);
            });
        }
        return text.replace(pattern, '');
    },
    /**
     * @private
     */
    addDirection: function(d) {
        var me = this,
            saved = me.storage.getItem(me.storage.directionsItemId) || [],
            alreadyHas = false;
        if (d.data.not_show_with_open_component == 1 && d.data.object_name && Ext.getCmp(d.data.object_name) && Ext.getCmp(d.data.object_name).isVisible()) {
            return;
        }
        //   ,    "   "   
        /***/
        me.log('   ', d);
        Ext.Array.each(saved, function(sd) {
            if (sd.entry == d.entry) {
                alreadyHas = true;
            }
        });
        if (!alreadyHas) {
            saved.push(d);
            me.storage.setItem(me.storage.directionsItemId, saved);
            if (d.data.object_name) {
                me.listenComponent(d.data.object_name);
            }
        }
    },
    listenComponent: function(cmpId) {
        var me = this,
            listener = {};
        me.listened = me.listened || [];
        if (Ext.Array.indexOf(me.listened, cmpId) == -1) {
            /****/
            me.log('    ', cmpId);
            listener['#' + cmpId] = {
                show: {
                    fn: function() {
                        me.showDirections(cmpId);
                    },
                    single: false
                }
            };
            me.control(listener);
            me.listened.push(cmpId);
        }
    },
    /**
     *      
     */
    initDirectionDialogComponent: function(config, componentId) {
        var me = this,
            action,
            opts = {},
            view;
        //     
        if (me.user.getSetting('disable_hints') == 1 && config.close_btn && config.close_btn != 0 && config.close_btn != '')  {
            return 'wrong_setting';
        }
        
        if (Ext.getCmp('LETTER_' + componentId)) {
            return false;
        }
        if (config.serviceId && config.serviceId.id) {
            if (config.extra_service_opts) {
                opts = Ext.decode(config.extra_service_opts);
            }
            action = ExGods.ClientActions.factory({
                actionId: config.serviceId.id,
                src: 'direction',
                options: opts
            });
        }
        config.action = action;
        config.btn = {
            handler: function() {
                //   
                if (config.closeAll) {
                    me.app.getController('Viewport').closeAllWindows();
                }
                //   
                if (action) {
                    ExGods.ClientActions.doAction(action, function(res) {
                        if (res.error) {
                            /***/
                            me.log('error', res.error);
                        }
                    });
                }
                //   
                this.up('direction').close();
            }
        };
        view = Ext.widget('direction', {
            id: 'LETTER_' + componentId,
            //    ID, .. 5-    ID   
            layer: 'directions-layer',
            autoShow: false,
            config: config
        });
        ExGods.Resources.load(view, function() {
            view.show();
        });
        return view;
    },
    blinkTitle: function(text) {
        var originalTitle = document.title,
            duration = ExGods.ref('constants|direction_title_blink_duration').value,
            blinkTime = ExGods.ref('constants|direction_title_blink_time').value,
            pauseTime = ExGods.ref('constants|direction_title_blink_time').value,
            spentTime = 0,
            started = new Date(),
            phase, now;
        document.title = text;
        phase = {
            type: 'blink',
            started: started,
            dur: blinkTime
        };
        var interval = setInterval(function() {
                now = new Date();
                spentTime = now - started;
                if (spentTime > duration) {
                    clearInterval(interval);
                    document.title = originalTitle;
                } else {
                    if (now - phase.started > phase.dur) {
                        if (phase.type == 'blink') {
                            document.title = originalTitle;
                            phase = {
                                type: 'pause',
                                started: now,
                                dur: pauseTime
                            };
                        } else {
                            document.title = text;
                            phase = {
                                type: 'blink',
                                started: now,
                                dur: blinkTime
                            };
                        }
                    }
                }
            }, 100);
    }
});

/**
 *     
 * @author Oleg Mikhailov
 */
Ext.define('ExGods.view.chat.Smiles', {
    extend: Ext.Panel,
    alias: 'widget.chatsmiles',
    id: 'chat-smiles-panel',
    tabConfig: {
        hidden: true
    },
    plugins: [
        {
            ptype: 'scroller',
            autoHide: true,
            scrollDeltaY: 23
        }
    ],
    padding: '5 5 5 10',
    initComponent: function() {
        var me = this;
        me.items = [
            this.getSmilesPanel()
        ];
        me.callParent(arguments);
        me.on('afterrender', me.onAfterRender, me);
    },
    onAfterRender: function() {
        var me = this;
        me.getEl().on('click', function(e, t) {
            /**
             * @event smileclick
             * param {String} smileCode
             */
            me.fireEvent('smileclick', Ext.fly(t).getAttribute('data-code'));
        }, me, {
            delegate: '.chat-smiles-icon'
        });
    },
    getSmilesPanel: function() {
        var me = this,
            iconCodes = ExGods.ref('images|chat_message_icons').image,
            html = '';
        Ext.Object.each(iconCodes, function(key, value) {
            var keys = key.split('|');
            html += '<span class="chat-smiles-icon" data-code="' + keys[0] + '" data-qtip="' + keys.join(' ' + ExGods.getMsgByKey('view_chat_smiles_delimiter') + ' ') + '" style="background-image: url(' + value + ');" /></span>';
        });
        return {
            xtype: 'component',
            html: html
        };
    }
});

/**
 *   
 */
Ext.define('ExGods.view.chat.ContactsMenu', {
    extend: ExGods.view.parchment.Window,
    alias: 'widget.chatcontactsmenu',
    cls: 'chat-menu-list',
    width: 180,
    height: 91,
    padding: '7 12',
    autoShow: true,
    header: false,
    xyOffset: [
        75,
        18
    ],
    /**
     * @cfg DOM     
     */
    clickedEl: null,
    tpl: [
        '<ul>',
        '<tpl foreach=".">',
        '<li menu-element-id="{id_element}">{label}</li>',
        '</tpl>',
        '</ul>'
    ],
    initComponent: function() {
        var me = this;
        me.prepareData();
        me.calcSize();
        me.calcPosition();
        me.callParent(arguments);
    },
    prepareData: function() {
        var me = this;
        me.data = Ext.Array.sort(config.menu.contacts || [], function(a, b) {
            var pos1 = parseInt(a.position);
            var pos2 = parseInt(b.position);
            return pos1 - pos2;
        });
    },
    calcSize: function() {
        var me = this;
        me.height = (me.data.length + 1) * 20 + 19;
    },
    calcPosition: function() {
        var me = this,
            pos,
            bodyEl = Ext.getBody(),
            htmlEl = bodyEl.parent();
        pos = Ext.get(me.clickedEl).getXY();
        me.x = pos[0] + me.xyOffset[0];
        me.y = pos[1] + me.xyOffset[1];
        if (me.y + me.height - bodyEl.dom.scrollTop > htmlEl.dom.clientHeight) {
            me.y = htmlEl.dom.clientHeight + bodyEl.dom.scrollTop - me.height;
        }
    },
    afterRender: function() {
        var me = this;
        me.callParent(arguments);
        me.getEl().on('click', function(e) {
            var el = e.getTarget(),
                menuElementId = el.getAttribute('menu-element-id');
            me.fireEvent('itemclick', menuElementId);
            me.close();
        }, me, {
            delegate: 'li'
        });
    }
});

/**
 *   
 */
Ext.define('ExGods.view.chat.MessagesMenu', {
    extend: ExGods.view.chat.ContactsMenu,
    alias: 'widget.chatmessagesmenu',
    xyOffset: [
        -20,
        12
    ],
    prepareData: function() {
        var me = this;
        me.data = Ext.Array.sort(config.menu.messages || [], function(a, b) {
            var pos1 = parseInt(a.position);
            var pos2 = parseInt(b.position);
            return pos1 - pos2;
        });
    }
});

/**
 *   
 */
Ext.define('ExGods.controller.Chat', {
    extend: ExGodsCore.controller.Chat,
    logConfig: {
        enabled: {
            info: true,
            error: true,
            warn: true
        },
        prefix: 'ChatView:'
    },
    views: [
        'chat.Smiles',
        'chat.ContactsMenu',
        'chat.MessagesMenu'
    ],
    refs: [
        {
            /**
             * @method getArena
             *   
             * @return {ExGods.view.chat.MessageList}
             */
            ref: 'arena',
            selector: '#arena-location'
        },
        {
            /**
             * @private
             * @method getContactTabPanel
             */
            ref: 'contactTabPanel',
            selector: '#contact-tab-panel'
        },
        {
            /**
             * @private
             * @method getContactTabPanel
             */
            ref: 'contactsFilterView',
            selector: '#chat-contacts-filter'
        },
        {
            /**
             * @method getChatContactsView
             *      
             * @return {Ext.view.View}
             */
            ref: 'chatContactsView',
            selector: '#chat-contact-list dataview'
        },
        {
            /**
             * @method getSmilesPanel
             */
            ref: 'smilesPanel',
            selector: '#chat-smiles-panel'
        }
    ],
    /**
     * @property {Object[]} channelPatterns
     *  ( )  :
     *
     *      [
     *          {
     *              xtype: <_>
     *              id: <>
     *              pattern: <____>
     *              title: <__>
     *              type: <_>
     *          },
     *          ...
     *      ]
     */
    channelPatterns: [],
    /**
     * @property {ExGods.view.chat.MessageList} activeTab
     *    
     */
    init: function(app) {
        var me = this,
            user = app.user;
        me.channelPatterns = [
            {
                xtype: 'chatmessagelist',
                id: 'world-chat-messages',
                pattern: /^world#\d+$/,
                title: ExGods.getMsgByKey('chat_world_title'),
                name: 'worldChatMessageList',
                type: {
                    world: true,
                    input: true,
                    'private': false
                }
            },
            {
                xtype: 'chatmessagelist',
                id: 'guild-chat-messages',
                pattern: /^guild#\d+$/,
                title: ExGods.getMsgByKey('chat_guild_title'),
                name: 'guildChatMessageList',
                type: {
                    'guild': true,
                    'input': true,
                    'private': true
                },
                autoshow: false,
                autoremove: true
            },
            {
                xtype: 'chatmessagelist',
                id: 'guild-group-messages',
                pattern: /^guild_group#\d+$/,
                title: ExGods.getMsgByKey('chat_guild_group_title'),
                name: 'guildChatMessageList',
                type: {
                    'guild_group': true,
                    'input': true,
                    'private': true
                },
                autoshow: false,
                autoremove: true
            },
            {
                xtype: 'chatmessagelist',
                id: 'location-chat-messages',
                pattern: /^\d+$/,
                title: ExGods.getMsgByKey('chat_location_title'),
                name: 'locationChatMessageList',
                type: {
                    location: true,
                    'default': true,
                    input: true,
                    'private': true
                },
                autoshow: true
            }
        ];
        /*{
            xtype: 'chatmessagelist',
            id: 'battle-chat-messages',
            pattern: /^battle_log#\d+$/,
            title: '',
            name:'battleChatMessageList',
            type: {
                battle:true
            },
            autoshow:true
        }, {
            xtype: 'chatmessagelist',
            id: 'group-chat-messages',
            pattern: /^common_group#\d+$/,
            title: '',
            name:'groupChatMessageList',
            type: {
                group:true,
                input:true,
                'private':true
            },
            autoremove:true
        },*/
        me.channels = new Ext.util.MixedCollection();
        me.control({
            '#chat-tab-panel': {
                tabchange: me.onChatTabChange
            },
            'chatmessagelist': {
                'addmessage': me.onChatMessageAdd,
                'message-menu-click': me.showMessageMenu,
                'user-menu-click': me.showContactsMenu,
                'user-click': function(user, type) {
                    me.addUserToMessage(user, type);
                }
            },
            'chatinputfield': {
                'user-menu-click': me.showContactsMenu
            },
            '#chat-toolbar button[action="togglesmiles"]': {
                click: me.toggleSmilesPanel
            },
            '#contact-tab-panel': {
                tabchange: me.onContactTabChange
            },
            '#chat-contact-list': {
                afterstorechanged: me.onChatContactsStoreChanged
            },
            '#chat-contacts-filter textfield': {
                keyup: {
                    fn: me.onContactsFilterChanged,
                    buffer: 100
                }
            },
            '#chat-smiles-panel': {
                smileclick: me.onSmileClick
            },
            '#chat-off-panel textbutton': {
                click: function() {
                    me.toggleChat();
                }
            },
            '#chat-off-btn': {
                click: function() {
                    me.toggleChat();
                }
            },
            '#chat-question-btn': {
                click: me.onQuestionBtnClick
            },
            '#chat-question-big-btn': {
                click: me.onQuestionBtnClick
            },
            '#chat-expand-btn': {
                click: me.toggleExpand
            }
        });
        app.getChatConnection().on({
            command_noticeboard: me.onNoticeBoardMessage,
            scope: me
        });
        //        
        me.getUser().on('settingschanged', me.applyUserSettings, me);
        me.applyUserSettings();
        me.initNotebook();
        me.initIgnoreList();
        me.createCSSRules();
        me.callParent(arguments);
    },
    onLaunch: function(app) {
        var me = this,
            user = app.user,
            tabs = me.getChatTabPanel(),
            worldPattern = me.getChannelPatternByType('world'),
            locationPattern = me.getChannelPatternByType('location');
        tabs.add({
            xtype: worldPattern.xtype,
            channelId: '',
            channelType: worldPattern.type,
            channelParams: worldPattern,
            id: worldPattern.id,
            title: worldPattern.title,
            user: user,
            hidden: (me.isWorldChatDisable() || me.isChatDisable())
        }, {
            xtype: locationPattern.xtype,
            channelId: '',
            channelType: locationPattern.type,
            id: locationPattern.id,
            title: ExGods.app.user.location.data.name,
            //locationPattern.title,
            user: user
        });
        if (!me.isChatDisable() && !me.isWorldChatDisable()) {
            tabs.setActiveTab(0);
        } else {
            tabs.setActiveTab(1);
        }
    },
    /**
     *    .
     * @param {Object} user  
     * @param {String} type  
     * @param {Boolean} strongType true,  type   
     *
     */
    addUserToMessage: function(user, type, strongType) {
        var me = this;
        if (typeof user == 'object') {
            this.notebook.add(user);
            me.addNickToMessage(user.display_title, type, strongType);
        } else {
            me.addNickToMessage(user, type, strongType);
        }
    },
    /**
     * @private
     *    . /   
     *  
     */
    onChatTabChange: function(chatTabs, newCard) {
        var me = this,
            contactTabs = me.getContactTabPanel();
        if (newCard.tab.hasCls('x-tab-new-private')) {
            chatTabs.items.each(function(item) {
                item.tab.removeClsWithUI('new-private');
            });
        }
        if (newCard.tab.hasCls('x-tab-new-room')) {
            newCard.tab.removeClsWithUI('new-room');
        }
        if (!me.isChatDisable()) {
            if ((newCard.channelType.battle) || (newCard.channelType.battle_obs)) {
                me.disableInput();
            } else {
                me.enableInput();
            }
        }
        contactTabs.suspendEvents();
        if (newCard.channelType.guild) {
            contactTabs.setActiveTab('guild-contact-list');
        } else if (newCard.channelType.guild_group) {
            contactTabs.setActiveTab('guild-group-list');
        } else if (newCard.channelType.group) {
            contactTabs.setActiveTab('chat-group');
        } else {
            contactTabs.setActiveTab('chat-contact-list');
        }
        contactTabs.resumeEvents();
    },
    onContactTabChange: function(contactTabs, newCard) {
        var me = this,
            chatTabs = me.getChatTabPanel();
        if (!contactTabs.eventsSuspended) {
            // suspendEvents  ,   Ext.app.Controller#method-control
            switch (newCard.getId()) {
                case 'chat-smiles-panel':
                    break;
                case 'chat-group':
                    chatTabs.setActiveTab('group-chat-messages');
                    break;
                default:
                    if (!me.isChatDisable() && !me.isWorldChatDisable()) {
                        chatTabs.setActiveTab('world-chat-messages');
                    } else {
                        chatTabs.setActiveTab('location-chat-messages');
                    };
                    break;
            }
        }
    },
    /**
     *   ExGodsCore.controller.Chat
     */
    onMessageTypeRoom: function(chatcn, data) {
        var me = this;
        if (!me.ignoreList.users[data.from]) {
            if (data.x && data.x.users_info) {
                data.x.users_info = Ext.JSON.decode(data.x.users_info);
            }
            me.callParent(arguments);
        }
    },
    /**
     *   ExGodsCore.controller.Chat
     */
    onMessageTypePrivate: function(chatcn, data) {
        var me = this;
        if (!data.x || !me.ignoreList.users[data.x.from_realuser]) {
            if (data.x && data.x.users_info) {
                data.x.users_info = Ext.JSON.decode(data.x.users_info);
            }
            me.callParent(arguments);
            if (!me.user.isChatOn()) {
                Ext.getCmp('chat-off-panel').incCounter();
            }
        }
    },
    // END:       
    /**
     * @private
     *       
     */
    onContactListItemClick: function(view, record, item, index, e) {
        var me = this;
        if (e.getTarget('.action-icon')) {
            if (e.getTarget('.private-msg-icon')) {
                me.addUserToMessage(record.data, 'private', true);
            } else if (e.getTarget('.user-info-icon')) {
                me.app.fireEvent('nickinfoclick', record.get('display_title'));
            }
        } else if (e.getTarget('.menu-icon')) {
            me.showContactsMenu(item, record.data);
        } else {
            me.addUserToMessage(record.data);
        }
    },
    onChatMessageAdd: function(data, panel) {
        var me = this,
            activeTab = me.getChatTabPanel().getActiveTab();
        //        ,        -     
        if (data.type == 'private' && panel.channelType["private"] && !activeTab.channelType["private"]) {
            panel.tab.addClsWithUI('new-private');
        }
        //            ,    
        if (data.type == 'room' && me.isMessageToMe(data) && activeTab != panel) {
            panel.tab.addClsWithUI('new-room');
        }
    },
    /**
     * @private
     *  ID ,    
     *
     * @return {String}
     */
    getChatRoomName: function() {
        var me = this,
            tabs = me.getChatTabPanel(),
            tab = tabs.getActiveTab(),
            room;
        if (tab.channelType.location) {
            room = ExGods.app.user.location.get('chat_room_name');
        } else if (tab.channelType.world) {
            room = me.getWorld().get('chat_room_name');
        } else {
            room = tab.channelId;
        }
        return room || false;
    },
    /*
    *         "to"  "private"
     */
    isMyMessage: function(data) {
        var me = this,
            type = data.type;
        if (data.x.to) {
            type = 'to';
        }
        if (type == 'private' || type == 'to') {
            if (data.x.from_realuser == me.user.get('display_title')) {
                return true;
            }
        }
        return false;
    },
    /*
    *     
     */
    isMessageToMe: function(data) {
        var me = this,
            type = data.type;
        if (data.x.to) {
            type = 'to';
        }
        if (type == 'private' || type == 'to') {
            var recipients = [];
            if (type == 'private' && data.x.to_realuser) {
                recipients = data.x.to_realuser.split(',');
            } else if (type == 'to') {
                recipients = Ext.decode(data.x.to);
            }
            if (Ext.Array.indexOf(recipients, me.user.get('display_title')) != -1) {
                return true;
            }
        }
        return false;
    },
    /**
     *   {messages: , signes: },       
     */
    getMessagesFromStorage: function() {
        var storage = Ext.util.LocalStorage.get('chat-user-messages'),
            messages = storage.getItem('messages') || [],
            i = messages.length,
            time = new Date().getTime(),
            signes = 0,
            timeout = parseInt(ExGods.ref('constants|chat_message_expire_time').value) * 1000;
        while (i > 0) {
            i--;
            if (messages[i] && messages[i].time + timeout < time) {
                messages.splice(i, 1);
            } else if (messages[i]) {
                signes += messages[i].msg.length;
            }
        }
        storage.setItem('messages', messages);
        return {
            messages: messages,
            signes: signes
        };
    },
    /**
     *      
     */
    pushMessageToStorage: function(msg) {
        var storage = Ext.util.LocalStorage.get('chat-user-messages'),
            messages = storage.getItem('messages') || [];
        msg = {
            msg: msg,
            time: new Date().getTime()
        };
        messages.push(msg);
        storage.setItem('messages', messages);
        return msg;
    },
    /**
     *  .      ,   .
     */
    sendMessage: function() {
        var me = this,
            message = me.getSendMessageData(),
            content = Ext.String.trim(message.content),
            msgObject = me.getMessagesFromStorage(),
            maxMsgs = parseInt(ExGods.ref('constants|chat_messages_cap').value),
            maxSignes = parseInt(ExGods.ref('constants|chat_signes_cap').value),
            d = ExGods.util.Date.normalizeServerDateTime(new Date()),
            field = me.getInputField(),
            attrs = {};
        if (!content) {
            return;
        }
        if (ExGods.app.getUser().get('moder') == 0 && (msgObject.messages.length >= maxMsgs || msgObject.signes + content.length > maxSignes)) {
            field.setMessage();
            me.onMessageTypeDefault(null, {
                x: {},
                //time:d.getHours()+':'+d.getMinutes()+':'+d.getSeconds()
                type: 'message',
                body: {
                    body: ExGods.ref('message_client|message_limit')
                }
            });
            return;
        }
        if (message.to) {
            attrs.users_info = Ext.JSON.encode(me.notebook.prepareInfo(message));
        }
        message.from = ExGods.app.user.get('display_title');
        message.roomId = me.getChatRoomName();
        message.content = content;
        me.pushMessageToStorage(message.content);
        me.app.getChatConnection().sendMessage(message, attrs);
        field.setMessage();
    },
    // End:   
    /**
     *    core
     */
    onClearBtnClick: function() {
        var me = this,
            field = me.getInputField(),
            message = field.getMessage();
        if (message.content) {
            message.content = '';
            field.setMessage(message);
        } else if (message.to && message.to.length) {
            message.to = [];
            message.type = 'room';
            field.setMessage(message);
        } else {
            me.callParent(arguments);
        }
    },
    onQuestionBtnClick: function() {
        var me = this;
        if (Ext.getCmp('ERROR_REPORT')) {
            Ext.getCmp('ERROR_REPORT').destroy();
        } else {
            ExGods.Components.factory('ERROR_REPORT');
        }
    },
    /**
     *      
     */
    toggleExpand: function() {
        var me = this;
        me.app.getController('Viewport').toggleChatExpand();
        me.expanded = !me.expanded;
    },
    /**
     * /   
     */
    toggleSmilesPanel: function() {
        var me = this,
            smilesPanel = me.getSmilesPanel(),
            contactTabPanel = me.getContactTabPanel();
        if (!smilesPanel) {
            smilesPanel = Ext.widget('chatsmiles');
        }
        if (contactTabPanel) {
            if (contactTabPanel.layout.getActiveItem() == smilesPanel) {
                contactTabPanel.suspendEvents();
                //       
                contactTabPanel.layout.setActiveItem(smilesPanel.previousTab);
                contactTabPanel.resumeEvents();
            } else {
                smilesPanel.previousTab = contactTabPanel.layout.getActiveItem();
                contactTabPanel.layout.setActiveItem(smilesPanel);
            }
        }
    },
    /**
     * @private
     *    "noticeboard"
     */
    onNoticeBoardMessage: function() {
        var me = this;
        me.request({
            url: '/game.pl?cmd=noticeboard'
        });
    },
    /**
     * @private
     *       
     */
    onContactsFilterChanged: function(f) {
        var me = this;
        me.doFilterContacts(f.getValue());
    },
    /**
     * @private
     * ,       
     */
    onChatContactsStoreChanged: function() {
        var me = this,
            filterView = me.getContactsFilterView();
        if (filterView) {
            me.doFilterContacts(filterView.down('textfield').getValue());
        }
    },
    /**
     * @private
     *       
     */
    onSmileClick: function(smileCode) {
        var me = this,
            message = me.getSendMessageData(),
            maxLength = parseInt(ExGods.ref('constants|chat_message_max_length').value);
        if (parseInt(message.content.length + 3) < maxLength) {
            //      3 
            message.content += smileCode;
            me.updateSendMessageField(message);
        }
    },
    /**
     * @private 
     *   
     * @param filterValue {String}   (required)
     */
    doFilterContacts: function(filterValue) {
        var me = this;
        filterValue = filterValue.toLowerCase().trim() , contacts = me.getChatContactsView().getStore();
        contacts.clearFilter();
        if (filterValue) {
            contacts.filter([
                {
                    filterFn: function(contact) {
                        return contact.get('display_title').toLowerCase().indexOf(filterValue) != -1;
                    }
                }
            ]);
        } else {
            contacts.sort();
        }
    },
    //     
    /**
     * @private
     *     
     */
    onChatDisabled: function() {
        var me = this;
        //    
        var tabs = me.getChatTabPanel();
        if (tabs && tabs.rendered) {
            tabs.items.getAt(0).hide();
            tabs.tabBar.items.getAt(0).hide();
        }
        if (tabs.getActiveTab() == tabs.items.getAt(0)) {
            //      -    ,    
            tabs.setActiveTab('location-chat-messages');
        }
        //   
        me.disableInput();
    },
    /**
     * @private
     *     
     */
    onChatEnabled: function() {
        var me = this;
        if (!me.isWorldChatDisable()) {
            //    
            var tabs = me.getChatTabPanel();
            if (tabs && tabs.rendered) {
                tabs.items.getAt(0).show();
                tabs.tabBar.items.getAt(0).show();
            }
        }
        //   
        me.enableInput();
    },
    /**
     *    core
     */
    getSendMessageData: function() {
        var me = this;
        return me.getInputField().getMessage();
    },
    /**
     *    core
     */
    updateSendMessageField: function(newMessage) {
        var me = this;
        me.getInputField().setMessage(newMessage ? newMessage : me.getSendMessageData());
    },
    /**
     *           
     */
    showContactsMenu: function(el, user) {
        var me = this,
            query;
        //     -  
        query = Ext.ComponentQuery.query('chatcontactsmenu');
        if (query.length) {
            for (var i = 0; i < query.length; i++) {
                if (query[i].clickedEl == el) {
                    query[i].close();
                    return;
                }
            }
        }
        Ext.widget('chatcontactsmenu', {
            clickedEl: el,
            xyOffset: Ext.get(el).up('.message') ? [
                -30,
                10
            ] : [
                75,
                18
            ],
            listeners: {
                itemclick: function(itemId) {
                    if (itemId == 'info') {
                        me.app.fireEvent('nickinfoclick', typeof user == 'object' ? user.display_title : user);
                    } else if (itemId == 'private') {
                        me.addUserToMessage(user, 'private', true);
                    }
                }
            }
        });
    },
    /**
     *       
     */
    showMessageMenu: function(el, message) {
        var me = this;
        //     -  
        query = Ext.ComponentQuery.query('chatmessagesmenu');
        if (query.length) {
            for (var i = 0; i < query.length; i++) {
                if (query[i].clickedEl == el) {
                    query[i].close();
                    return;
                }
            }
        }
        Ext.widget('chatmessagesmenu', {
            clickedEl: el,
            listeners: {
                itemclick: function(itemId) {
                    if (itemId == 'complain') {
                        me.doComplainMessage(message);
                    }
                }
            }
        });
    },
    /**
     *   
     */
    doComplainMessage: function(message) {
        var me = this;
        Ext.widget('confirmdialog', {
            message: ExGods.getMsgByKey('message_complain_confirm'),
            handler: function() {
                ExGods.app.block();
                me.request({
                    url: 'game.pl',
                    params: {
                        cmd: 'chat_complain',
                        chunk: message.x.chunk,
                        mid: message.x.mid
                    },
                    success: function(resp) {
                        ExGods.app.unblock();
                        if (resp && resp.success == 1) {
                            if (message.from) {
                                me.ignoreList.add(message.from);
                            } else if (message.x.from_realuser) {
                                me.ignoreList.add(message.x.from_realuser);
                            }
                        }
                    }
                });
            }
        });
    },
    /**
     *  
     */
    chatOff: function() {
        var me = this,
            chatOffPanel = Ext.getCmp('chat-off-panel');
        me.user.setChatOn(false);
        Ext.getCmp('chat-container').hide();
        chatOffPanel.resetCounter();
        chatOffPanel.show();
    },
    /**
     *  
     */
    chatOn: function() {
        var me = this,
            chatOffPanel = Ext.getCmp('chat-off-panel'),
            chatContainer = Ext.getCmp('chat-container'),
            chatTabs = Ext.getCmp('chat-tab-panel');
        me.user.setChatOn(true);
        chatOffPanel.hide();
        chatContainer.show();
        chatContainer.scrollChatToBottom();
        chatTabs.items.each(function(cmp) {
            if (cmp.rendered) {
                cmp.scroller.scrollToBottom();
            }
        });
    },
    /**
     *  
     */
    toggleChat: function() {
        var me = this;
        if (me.user.isChatOn()) {
            me.chatOff();
        } else {
            me.chatOn();
        }
    },
    /**
     * @private    
     */
    applyUserSettings: function() {
        var me = this,
            showPrivateInLocation = parseInt(me.user.getSetting('chat_private_location')) || 0,
            showPrivateInGuild = parseInt(me.user.getSetting('chat_private_guild')) || 0;
        me.channelPatterns.forEach(function(pattern) {
            if (pattern.type.location) {
                pattern.type["private"] = !!showPrivateInLocation;
            }
            if (pattern.type.guild) {
                pattern.type["private"] = !!showPrivateInGuild;
            }
        });
    },
    /**
     *  ,             
     */
    initNotebook: function() {
        this.notebook = {
            users: {},
            add: function(user) {
                if (Ext.isArray(user)) {
                    for (var i = 0; i < user.length; i++) {
                        this.users[user[i].display_title] = user[i];
                    }
                } else if (typeof user == 'object') {
                    this.users[user.display_title] = user;
                } else {
                    this.users[user] = {
                        display_title: user
                    };
                }
            },
            prepareInfo: function(message) {
                var info = {};
                if (message.to && message.to.length) {
                    for (var i = 0; i < message.to.length; i++) {
                        if (this.users[message.to[i]]) {
                            info[this.users[message.to[i]].display_title] = {
                                race: this.users[message.to[i]].race || 0,
                                moder: this.users[message.to[i]].moder || 0
                            };
                        } else {
                            info[this.users[message.to[i]].display_title] = {
                                race: 0,
                                moder: 0
                            };
                        }
                    }
                }
                return info;
            }
        };
    },
    /**
     * - .
     *
     * -          .
     *      .
     *
     */
    initIgnoreList: function() {
        var me = this;
        me.ignoreList = {
            users: {},
            add: function(displayTitle) {
                this.users[displayTitle] = 1;
            }
        };
    },
    /**
     * @private     
     */
    createCSSRules: function() {
        var me = this;
        Ext.util.CSS.createStyleSheet([
            '#chat-contact-list .userlist-item.moder { background-color: ' + ExGods.ref('constants|chat_moder_color').value + ';}',
            '.chat-messages .moder-message .message-info { background-color: ' + ExGods.ref('constants|chat_moder_color').value + ';}'
        ].join(''));
    }
});

/**
 *   
 */
Ext.define('ExGods.model.ItemPrototype', {
    extend: ExGodsCore.model.ItemPrototype,
    id: 'item-prototypes',
    canPutInWareHouse: function() {
        var action_full = this.get('action_full'),
            valid = false;
        if (action_full && action_full.length) {
            var i = action_full.length;
            while (i--) {
                if (action_full[i].type == 'warehouse') {
                    valid = true;
                    break;
                }
            }
        }
        return valid;
    },
    getWareHouseCost: function() {
        var action_full = this.get('action_full'),
            cost;
        if (action_full && action_full.length) {
            var i = action_full.length;
            while (i--) {
                if (action_full[i].type == 'warehouse') {
                    cost = action_full[i].cost;
                    break;
                }
            }
        }
        return cost;
    }
});

/**
 *  
 */
Ext.define('ExGods.store.ItemPrototypes', {
    extend: ExGodsCore.store.ItemPrototypes,
    model: 'ExGods.model.ItemPrototype'
});

Ext.define('ExGods.store.Skills', {
    extend: Ext.data.Store,
    model: 'ExGods.model.SkillGroup',
    idProperty: 'entry',
    proxy: {
        type: 'memory'
    },
    filters: [
        function(item) {
            return item.get('visible') == 1;
        }
    ],
    /**
     *  Ext.data.Model   
     */
    getSkillByName: function(name) {
        var me = this,
            found;
        me.each(function(group) {
            if (found)  {
                return;
            }
            
            group.get('skills').each(function(skill) {
                if (!found && skill.get('name') == name) {
                    found = skill;
                }
            });
        });
        return found;
    },
    /**
     *  true  false,     
     */
    isLearning: function() {
        var me = this,
            learning = false;
        me.each(function(group) {
            if (learning)  {
                return;
            }
            
            group.getSource().each(function(skill) {
                if (!learning && skill.get('progress') && !skill.get('progress').pause) {
                    learning = true;
                }
            });
        });
        return learning;
    },
    /**
     *  Ext.data.Model ,   
     */
    getLearningSkill: function() {
        var me = this,
            learning;
        me.each(function(group) {
            if (learning)  {
                return;
            }
            
            group.getSource().each(function(skill) {
                if (!learning && skill.get('progress') && !skill.get('progress').pause) {
                    learning = skill;
                }
            });
        });
        return learning;
    },
    /**
     *  Ext.data.Model ,    
     */
    getLearningGroup: function() {
        var me = this,
            learning;
        me.each(function(group) {
            if (learning)  {
                return;
            }
            
            group.getSource().each(function(skill) {
                if (!learning && skill.get('progress') && !skill.get('progress').pause) {
                    learning = group;
                }
            });
        });
        return learning;
    },
    /**
     *    
     */
    getAll: function() {
        var me = this,
            skills = [];
        me.each(function(group) {
            group.getSource().each(function(skill) {
                skills.push(skill);
            });
        });
        return skills;
    },
    /**
     *     
     */
    getImages: function() {
        var me = this,
            images = [];
        me.each(function(group) {
            images = images.concat(group.getImages());
        });
        return images;
    }
});

Ext.define('ExGods.store.SpecialDeals', {
    extend: Ext.data.Store,
    model: 'ExGods.model.SpecialDeal',
    proxy: {
        type: 'memory'
    }
});

/**
 *    
 */
Ext.define('ExGods.store.Loot', {
    extend: Ext.data.Store,
    model: 'ExGods.model.VirtualStoreStuff',
    proxy: 'memory',
    filters: [
        function(item) {
            return !item.isExpired() && [
                'item',
                'currency'
            ].indexOf(item.data.stuff.type) != -1;
        }
    ]
});

/**
 *   
 */
Ext.define('ExGods.store.Masks', {
    extend: Ext.data.Store,
    model: 'ExGods.model.Mask',
    proxy: 'memory',
    sorters: [
        {
            sorterFn: function(o1, o2) {
                return parseInt(o1.data.has) > parseInt(o2.data.has) ? -1 : parseInt(o1.data.has) < parseInt(o2.data.has) ? 1 : 0;
            }
        },
        {
            sorterFn: function(o1, o2) {
                return parseInt(o1.data.l_order) > parseInt(o2.data.l_order) ? -1 : parseInt(o1.data.l_order) < parseInt(o2.data.l_order) ? 1 : 0;
            }
        }
    ],
    /**
     *    
     */
    getCurrent: function() {
        return this.findRecord('slot_on', 1);
    },
    /**
     *    ,        (   -  false);
     */
    canFitAndUse: function(record) {
        if (!record)  {
            return false;
        }
        
        var id = record.isModel ? record.get('id') : record;
        //     
        record = this.findRecord('id', id);
        return record.get('has') && this.getCurrent() != record;
    },
    /**
     *      
     */
    getGroups: function() {
        var me = this,
            groups = [];
        me.each(function(record) {
            var group = record.get('group'),
                g_order = record.get('g_order'),
                type = record.get('type');
            if (!groups[g_order]) {
                groups[g_order] = {
                    g_order: g_order,
                    type: type,
                    name: group,
                    records: []
                };
            }
            groups[g_order].records.push(record);
        });
        groups = Ext.Array.clean(groups);
        Ext.Array.each(groups, function(group) {
            Ext.Array.sort(group.records, function(o1, o2) {
                return Number(o1.data.l_order) > Number(o2.data.l_order) ? -1 : Number(o1.data.l_order) < Number(o2.data.l_order) ? 1 : 0;
            });
        });
        Ext.Array.sort(groups, function(g1, g2) {
            return Number(g1.g_order) > Number(g2.g_order) ? -1 : Number(g1.g_order) < Number(g2.g_order) ? 1 : 0;
        });
        return groups;
    }
});

/**
 * @property {Boolean} isMobile
 * true -      ,
 * false -   
 */
var isMobile = Ext.is.iOS || Ext.is.Android;
if (!isMobile) {
    //  touch     
    Ext.supports.Touch = false;
    Ext.supports.TouchEvents = false;
}
var isVK = config.user.payment == 'vka';
var isOK = config.user.payment == 'oka';
var isMM = config.user.payment == 'mma';
var isFB = config.user.payment == 'fba';
var isKG = config.user.payment == 'kga';
/**
 * @property {Boolean} isSocialApp
 *    
 */
var isSocialApp = isVK || isOK || isMM || isFB || isKG;
/**
 * @property {Boolean} isCompact
 * @deprecated        
 *    .
 */
var isCompact = false;
//isVK || !!config.force_compact;
/**
 * @property {String} IMAGE_URL
 * URL  ,   
 */
var IMAGE_URL;
/**
 * @class ExGods
 * @singleton
 *
 * Namespace   ExGods.app
 */
Ext.ns('ExGods');
var references;
Ext.Loader.setConfig({
    enabled: true,
    paths: {
        'Ext': '/j/extjs/src',
        'ExGods': '/j/exgods2/app',
        'ExGodsCore': '/j/exgodscore'
    }
});
;
if (isMobile) {
    Ext.getBody().parent().addCls('mobile');
}
Ext.getBody().parent().addCls('app');
setTimeout(function() {
    Ext.getBody().addCls('loading');
}, 0);
Ext.onReady(function() {
    var i, j;
    if ((top == window) && isSocialApp) {
        Ext.util.Cookies.set(config.auth_cookie.name, null, new Date("January 1, 1970"), '/', config.auth_cookie.domain);
        Ext.create('Ext.form.Panel', {
            renderTo: Ext.getBody(),
            hidden: true
        }).getForm().submit({
            url: '/reg.pl?cmd=error',
            method: 'POST',
            params: {
                message: '        .        .'
            },
            standardSubmit: true
        });
        return;
    }
    if (Ext.supports.Touch && !Ext.is.Phone) {
        new NoClickDelay(Ext.getBody().dom);
    }
    Ext.apply(Ext.util.Format, {
        thousandSeparator: ' ',
        /**
         *      
         * @member Ext.util.Format
         * 
         * @param {Number} num 
         * @param {String[]} cases  ,  ['', '', '']
         * @return {String}
         */
        plural: function(num, cases) {
            num = Math.abs(num);
            var word = '';
            if (num != NaN) {
                if (num.toString().indexOf('.') > -1) {
                    word = cases[1];
                } else {
                    word = (num % 10 == 1 && num % 100 != 11 ? cases[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? cases[1] : cases[2]);
                }
            }
            return word;
        },
        /**
         *     
         * [rickyrosario.com](http://rickyrosario.com/blog/converting-a-url-into-a-link-in-javascript-linkify-function/)
         * @member Ext.util.Format
         *
         * @param {String} text             
         * @return {String}
         */
        linkify: function(text) {
            var valid_urls;
            if (text) {
                valid_urls = ExGods.references.get('constants_list').valid_urls.value;
                text = text.replace(/<br\/?>/g, '\n');
                //     ,  <br/>
                // TODO: -,   <br>    ( )  
                text = text.replace(/(https?\:\/\/)?([a-z-0-9_\-]+\.)?([a-z-0-9_\-]+)\.([a-z]{2,4}|)(\/\S*|#\S*)?/gi, function(url) {
                    //   
                    // var spl = url.split(':'),
                    //  smiles = [],
                    //  i = spl.length;
                    // while(i > 0){
                    //  i--;
                    //  if(!spl[i] || spl[i].match('[a-z-0-9_\-]+\.')[0] === spl[i]){
                    //      if(spl[i]) smiles.unshift(spl[i]);
                    //      spl.pop();
                    //  }else{
                    //      break;
                    //  }
                    // }
                    // url = spl.join(':');
                    var full_url = url,
                        i = 0;
                    full_url = ExGods.util.Helper.processTextWithSmiles(full_url);
                    var smiles = full_url.split('<');
                    full_url = smiles[0];
                    smiles.shift();
                    smiles = smiles.length ? '<' + smiles.join('<') : '';
                    if (!full_url.match('^https?://')) {
                        full_url = 'http://' + full_url;
                    }
                    for (; i < valid_urls.length; i++) {
                        if (full_url.match('^https?://([^.]+.)?' + valid_urls[i]))  {
                            return '<a href="' + full_url + '" target="_blank">#' + ExGods.getMsgByKey('chat_link_text') + '</a>' + smiles;
                        }
                        
                    }
                    return '<' + ExGods.getMsgByKey('chat_censor_text') + '>';
                });
                text = text.replace(/\n/g, '<br/>');
            }
            return text;
        },
        /**
         *       
         * @member Ext.util.Format
         *
         * @param {Number} time   
         * @return {String}
         */
        countdown: ExGods.util.Time.printTime,
        /**
         *    : '123 456 '
         * @param {Number} value  
         * @param {String} type   - "crystal", "real"
         * @param {String} format      Ext.String.format  '{0} {1}',
         *    0 -  , 1 -  
         * @return {String}
         */
        money: function(value, type, format) {
            var curValue = 0,
                curLabel = '',
                format = format ? format : '{0} {1}';
            curValue = Ext.util.Format.number(value, '0,0');
            if (type) {
                if (type == 'crystal') {
                    labels = ExGods.getMsgByKey('crystal_name').split(',');
                } else if (type == 'real') {
                    if (isVK) {
                        labels = ExGods.getMsgByKey('payment_vka');
                    } else if (isOK) {
                        labels = ExGods.getMsgByKey('payment_oka');
                    } else if (isMM) {
                        labels = ExGods.getMsgByKey('payment_mma');
                    } else {
                        labels = ExGods.getMsgByKey('roubles_names').split(',');
                    }
                }
                if (labels)  {
                    curLabel = Ext.util.Format.plural(value, labels);
                }
                
            }
            return Ext.String.format(format, curValue, curLabel);
        }
    });
    exGodsLoader.setPercentage(20, 40);
    /**
     *   
     */
    Ext.application({
        extend: ExGodsCore.Application,
        appFolder: '/j/exgods2/app',
        appProperty: 'app',
        mainView: 'ExGods.view.Viewport',
        enableQuickTips: isMobile ? false : true,
        name: 'ExGods',
        logConfig: {
            enabled: {
                info: false,
                warn: true,
                error: true
            },
            prefix: 'ExGodsApp:'
        },
        controllers: [
            'Error',
            //  ,     AJAX 
            'Services',
            'Layers',
            'Components',
            'ClientActions',
            'CSS',
            'Announcments',
            'Arena',
            'Arena2',
            'Action',
            'Bank',
            'Bank2',
            'BattleChain',
            'battle.Battle',
            'battle.BattleView',
            'battle.Animation',
            'battle.Stability',
            'ChatGroup',
            'Communication',
            'Resources',
            'Dialog',
            'Shop',
            'inventory.Inventory',
            'inventory.VirtualStore',
            'Item',
            'Hints',
            'Location',
            'Log',
            'Market',
            'Masks',
            'OnlineList',
            // 'PerformanceTest',
            'Preloader',
            'Ratings',
            'Robbery',
            'Settings',
            'social.VK',
            'social.OK',
            'social.MM',
            'social.FB',
            'social.KG',
            'Sound',
            'SpecialDeal',
            'Surging',
            'Teleport',
            'ToolsMenu',
            'TooltipManager',
            'Quest',
            'QuestHelper',
            'QuickSlot',
            'User',
            'Viewport',
            'Lair',
            'Skills',
            'Fucina',
            'Chests',
            'Guild',
            'GuildOnline',
            'LootManager',
            'Pets',
            'Direction',
            //    Viewport
            'Chat'
        ],
        //  ,         
        models: [
            'Shop',
            'User',
            'Ability',
            'FeaturePrototype'
        ],
        stores: [
            /**
             * @method getChatContactsStore
             *     
             * @return {ExGods.store.ChatContacts}
             */
            'ChatContacts@ExGodsCore.store',
            /**
             * @method getItemPrototypesStore
             *    
             * @return {ExGods.store.ItemPrototypes}
             */
            'ItemPrototypes',
            /**
             * @method getAbilityPrototypesStore
             *    
             * @return {ExGods.store.AbilityPrototypes}
             */
            'AbilityPrototypes',
            /**
             * @method getFeaturePrototypesStore
             *    
             * @return {ExGods.store.FeaturePrototypes}
             */
            'FeaturePrototypes',
            /**
             * @method getMonsterStore
             *      
             * @return {ExGods.store.Monster}
             */
            'Monster',
            /**
             * @method getLocationsStore
             *       
             * @return {ExGods.store.Locations}
             */
            'Locations',
            /**
             * @method getSkillsStore
             *    
             * @return {ExGods.store.Skills}
             */
            'Skills',
            /**
             * @method getSpecialDealsStore
             *    
             * @return {ExGods.store.SpecialDeals}
             */
            'SpecialDeals',
            /**
             * @method getChestsStore
             *   
             * @return {ExGods.store.Chests}
             */
            'Chests',
            /**
             * @method getGuildsStore
             *   
             * @return {ExGods.store.Guilds}
             */
            'Guilds',
            /**
             * @method getGuildRaidsStore
             *    
             * @return {ExGods.store.GuildRaids}
             */
            'GuildRaids',
            /**
             * @method getLootStore
             *     
             * @return {ExGods.store.Loot}
             */
            'Loot',
            /**
             * @method getWorldsStore
             *    
             * @return {ExGods.store.Worlds}
             */
            'Worlds',
            /**
             * @method getMasksStore
             *    
             * @return {ExGods.store.Masks}
             */
            'Masks'
        ],
        /**
         *    
         * @return {Ext.data.Model}
         */
        getUser: function() {
            return this.user;
        },
        /**
         *    
         * @return {Ext.data.Model}
         */
        getLocation: function() {
            var me = this,
                user = me.getUser(),
                locations = me.getLocationsStore();
            return locations.data.getByKey(user.getLocation());
        },
        /**
         *    
         * @return {Ext.data.Model}
         */
        getWorld: function() {
            var me = this,
                user = me.getUser(),
                worlds = me.getWorldsStore();
            return worlds.data.getByKey(user.getWorld());
        },
        getImageUrl: function() {
            if (typeof ExgMobile != 'undefined') {
                return ExgMobile.config.image_url;
            } else {
                return this.callParent(arguments);
            }
        },
        getHostUrl: function() {
            if (typeof ExgMobile != 'undefined') {
                return ExgMobile.config.host_url;
            } else {
                return this.callParent(arguments);
            }
        },
        /**
         * @cfg {Array} serverRequestKeyHandlerSequence . {@link ExGodsCore.AjaxRequest#keyHandlersSequence keyHandlersSequence}
         */
        serverRequestKeyHandlerSequence: [
            'user',
            'quests',
            'bots',
            'trace_quest'
        ],
        init: function() {
            var me = this;
            /***/
            me.log('info', '  ');
            me.callParent(arguments);
            //    ..        app
            ExGods.references = references = me.references;
            //   
            me.getChatConnection().on({
                ping: me.onPing,
                scope: me
            });
            /***/
            me.log('info', ' ');
        },
        /**
         *  
         */
        launch: function() {
            var me = this;
            me.callParent(arguments);
            //  SDK .
            if (isSocialApp) {
                me.getSocialController().initSDK();
            }
        },
        /**
         *    
         */
        getSocialController: function() {
            var me = this;
            switch (config.user.payment) {
                case 'vka':
                    return me.getController('social.VK');
                case 'oka':
                    return me.getController('social.OK');
                case 'mma':
                    return me.getController('social.MM');
                case 'fba':
                    return me.getController('social.FB');
                case 'kga':
                    return me.getController('social.KG');
            }
        },
        /**
         *    
         * @author  
         * 
         * @param {String} tpl 
         * @param {Object} data 
         * @return {ExGods.view.Template}
         */
        applyTpl: function(tpl, data) {
            var me = this;
            if (!me.template) {
                me.template = Ext.create('ExGods.view.Template', {
                    compiled: false,
                    disableFormats: false
                });
            }
            tpl = tpl.replace('\\', '&#92;');
            me.template.set(tpl, false);
            return me.template.apply(data);
        },
        /**
         *   
         *
         * @param {String} [msg=""]   
         */
        block: function(msg) {
            Ext.getBody().mask((msg || ExGods.getMsgByKey('wait_message')), 'global-mask-msg').addCls('global-mask');
        },
        /**
         *   
         */
        unblock: function() {
            Ext.getBody().unmask();
        },
        /**
         *  
         */
        onPing: function(data) {
            //     
            ExGods.util.Date.serverTimeOffset = parseInt(new Date().getTime() / 1000, 10) - data.now;
        }
    });
});

/**
 *    
 */
Ext.define('ExGods.view.ErrorReport', {
    extend: Ext.panel.Panel,
    alias: 'widget.errorreport',
    cls: 'report-error',
    //layout: 'fit',
    plugins: [
        'paperdeco'
    ],
    padding: '0 0 20 0',
    margin: 10,
    /**
     * @cfg {ExGods.model.User} user (required)
     * 
     */
    initComponent: function() {
        var me = this,
            user = ExGods.app.getUser(),
            formItems = [];
        formItems.push({
            xtype: 'hiddenfield',
            name: 'cmd',
            value: 'bugs'
        }, {
            xtype: 'radiogroup',
            fieldLabel: ExGods.getMsgByKey('view_error_cat'),
            //  
            labelAlign: 'top',
            vertical: true,
            columns: 1,
            items: [
                {
                    boxLabel: ExGods.getMsgByKey('view_error_senderror'),
                    name: 'type',
                    inputValue: '2',
                    checked: true
                },
                /*{
                boxLabel: ExGods.getMsgByKey('view_error_ask'),
                name: 'type',
                inputValue: '1'
            }, */
                {
                    boxLabel: ExGods.getMsgByKey('view_error_complain'),
                    name: 'type',
                    inputValue: '7'
                }
            ]
        });
        formItems.push({
            xtype: 'textfield',
            name: 'subject',
            fieldLabel: ExGods.getMsgByKey('view_error_theme') + '<span class="required">*</span>',
            labelAlign: 'top',
            allowBlank: false
        }, {
            xtype: 'textareafield',
            name: 'message',
            fieldLabel: ExGods.getMsgByKey('view_error_problem') + '<span class="required">*</span>',
            labelAlign: 'top',
            allowBlank: false,
            height: /*140*/
            160
        }, {
            xtype: 'component',
            html: ExGods.getMsgByKey('view_error_comment')
        });
        me.items = [
            {
                xtype: 'component',
                html: '<h2 class="paper-title">' + ExGods.getMsgByKey('error_report_title') + '</h2>'
            },
            {
                xtype: 'form',
                url: '/game.pl',
                margin: '0 20',
                defaults: {
                    xtype: 'component',
                    anchor: '100%'
                },
                items: formItems,
                buttonAlign: 'center',
                buttons: {
                    items: [
                        {
                            xtype: 'textbutton',
                            type: 'submit',
                            id: 'submit',
                            text: ExGods.getMsgByKey('view_error_publish'),
                            width: 150,
                            cls: 'no_border x-btn-txt-green'
                        },
                        {
                            xtype: 'tbspacer',
                            width: 50
                        },
                        {
                            xtype: 'textbutton',
                            type: 'reset',
                            text: ExGods.getMsgByKey('view_error_clear'),
                            id: 'reset',
                            itemId: 'reset',
                            width: 150,
                            cls: 'no_border x-btn-txt-red'
                        }
                    ]
                }
            }
        ];
        me.callParent();
        me.down('radiogroup').on('change', me.onChange, me);
    },
    onChange: function(radiogroup, value) {
        var me = this,
            label_title, desc_title;
        switch (value.type) {
            case '2':
                label_title = ExGods.getMsgByKey('view_error_theme');
                desc_title = ExGods.getMsgByKey('view_error_problem');
                break;
            case '1':
                label_title = ExGods.getMsgByKey('view_error_question_theme');
                desc_title = ExGods.getMsgByKey('view_error_question_problem');
                break;
            case '7':
                label_title = ExGods.getMsgByKey('view_error_complain_theme');
                desc_title = ExGods.getMsgByKey('view_error_complain_problem');
                break;
            default:
                break;
        }
        if (label_title) {
            me.down('textfield').setFieldLabel(label_title + '<span class="required">*</span>');
        }
        if (desc_title) {
            me.down('textareafield').setFieldLabel(desc_title + '<span class="required">*</span>');
        }
    }
});

